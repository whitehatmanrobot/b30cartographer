                        0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS)
        return TRUE;

    dwSize = sizeof(dwCountOld);
    lResult = RegQueryValueEx (hKey, TEXT("Count"), NULL, &dwType,
                               (LPBYTE) &dwCountOld, &dwSize);

    if ( lResult != ERROR_SUCCESS ) {
        DebugMsg((DM_VERBOSE, TEXT("ReadMembershipList: Failed to read old group count") ));
        goto Exit;
    }

    //
    // Now compare the old and new number of security groups
    //

    if ( dwCountOld != dwCountCur ) {
        DebugMsg((DM_VERBOSE, TEXT("ReadMembershipList: Old count %d is different from current count %d"),
                  dwCountOld, dwCountCur ));
        goto Exit;
    }

    //
    // Total group count is the same, now check that each individual group is the same.
    // First read the size of the largest value in this key.
    //

    lResult = RegQueryInfoKey (hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                               &dwMaxSize, NULL, NULL);
    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("ReadMembershipList: Failed to query max size with %d."), lResult));
        goto Exit;
    }

    //
    // RegQueryInfoKey does not account for trailing 0 in strings
    //

    dwMaxSize += sizeof( WCHAR );
    
        
    //
    // Allocate buffer based upon the largest value
    //

    lpSid = (LPTSTR) LocalAlloc (LPTR, dwMaxSize);

    if (!lpSid) {
        DebugMsg((DM_WARNING, TEXT("ReadMembershipList: Failed to allocate memory with %d."), lResult));
        goto Exit;
    }

    for ( i=0; i<dwCountOld; i++ ) {

        wsprintf( szGroup, TEXT("Group%d"), i );

        dwSize = dwMaxSize;
        lResult = RegQueryValueEx (hKey, szGroup, NULL, &dwType,
                                   (LPBYTE) lpSid, &dwSize);
        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("ReadMembershipList: Failed to read value %ws"), szGroup ));
            goto Exit;
        }

        if ( !GroupInList( lpSid, pGroupsCur ) ) {
            DebugMsg((DM_WARNING, TEXT("ReadMembershipList: Group %ws not in current list of token groups"), lpSid ));
            goto Exit;
        }

    }

    bDiff = FALSE;

Exit:

    if ( lpSid )
        LocalFree( lpSid );

    if ( hKey )
        RegCloseKey (hKey);

    return bDiff;
}



//*************************************************************
//
//  SavesMembershipList()
//
//  Purpose:    Caches memberhip list
//
//  Parameters: lpGPOInfo - LPGPOINFO struct
//              lpwszSidUser - Sid of user, if non-null then it means
//                             per user local setting
//              pGroups   - List of token groups to cache
//
//  Notes:      The count is saved last because it serves
//              as a commit point for the entire save operation.
//
//*************************************************************

void SaveMembershipList( LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUser, PTOKEN_GROUPS pGroups )
{
    TCHAR szKey[250];
    TCHAR szGroup[30];
    DWORD i;
    LONG lResult;
    DWORD dwCount = 0, dwSize, dwDisp;
    NTSTATUS ntStatus;
    UNICODE_STRING unicodeStr;
    HKEY hKey = NULL;

    //
    // Start with clean key
    //

    if ( lpwszSidUser == 0 )
        wsprintf( szKey, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\GroupMembership") );
    else
        wsprintf( szKey, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws\\GroupMembership"),
                  lpwszSidUser );

    if (!RegDelnode ( lpwszSidUser ? HKEY_LOCAL_MACHINE : lpGPOInfo->hKeyRoot, szKey) ) {
        DebugMsg((DM_VERBOSE, TEXT("SaveMembershipList: RegDelnode failed.")));
        return;
    }

    lResult = RegCreateKeyEx ( lpwszSidUser ? HKEY_LOCAL_MACHINE : lpGPOInfo->hKeyRoot,
                               szKey, 0, NULL,
                               REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisp);
    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("SaveMemberList: Failed to create key with %d."), lResult));
        goto Exit;
    }

    for ( i=0; i < pGroups->GroupCount; i++) {

        if (SE_GROUP_LOGON_ID & pGroups->Groups[i].Attributes )
            continue;

        dwCount++;

        //
        // Convert user SID to a string.
        //

        ntStatus = RtlConvertSidToUnicodeString( &unicodeStr,
                                                 pGroups->Groups[i].Sid,
                                                 (BOOLEAN)TRUE ); // Allocate
        if ( !NT_SUCCESS(ntStatus) ) {
            DebugMsg((DM_WARNING, TEXT("SaveMembershipList: RtlConvertSidToUnicodeString failed, status = 0x%x"),
                      ntStatus));
            goto Exit;
        }

        wsprintf( szGroup, TEXT("Group%d"), dwCount-1 );

        dwSize = (lstrlen (unicodeStr.Buffer) + 1) * sizeof(TCHAR);
        lResult = RegSetValueEx (hKey, szGroup, 0, REG_SZ,
                                 (LPBYTE) unicodeStr.Buffer, dwSize);

        RtlFreeUnicodeString( &unicodeStr );

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("SaveMemberList: Failed to set value %ws with %d."),
                      szGroup, lResult));
            goto Exit;
        }

    }   // for

    //
    // Commit by writing count
    //

    dwSize = sizeof(dwCount);
    lResult = RegSetValueEx (hKey, TEXT("Count"), 0, REG_DWORD,
                             (LPBYTE) &dwCount, dwSize);

Exit:
    if (hKey)
        RegCloseKey (hKey);
}





//*************************************************************
//
//  ExtensionHasPerUserLocalSetting()
//
//  Purpose:    Checks registry if extension has per user local setting
//
//  Parameters: pwszExtension - Extension guid
//              hKeyRoot      - Registry root
//
//  Returns:    True if extension has per user local setting
//              False otherwise
//
//*************************************************************

BOOL ExtensionHasPerUserLocalSetting( LPTSTR pszExtension, HKEY hKeyRoot )
{
    TCHAR szKey[200];
    DWORD dwType, dwSetting = 0, dwSize = sizeof(DWORD);
    LONG lResult;
    HKEY hKey;

    wsprintf ( szKey, GP_EXTENSIONS_KEY,
               pszExtension );

    lResult = RegOpenKeyEx ( hKeyRoot, szKey, 0, KEY_READ, &hKey);
    if ( lResult != ERROR_SUCCESS )
        return FALSE;

    lResult = RegQueryValueEx( hKey, TEXT("PerUserLocalSettings"), NULL,
                               &dwType, (LPBYTE) &dwSetting,
                               &dwSize );
    RegCloseKey( hKey );

    if (lResult == ERROR_SUCCESS)
        return dwSetting;
    else
        return FALSE;
}



//*************************************************************
//
//  GetAppliedGPOList()
//
//  Purpose:    Queries for the list of applied Group Policy
//              Objects for the specified user or machine
//              and specified client side extension.
//
//  Parameters: dwFlags    -  User or machine policy, if it is GPO_LIST_FLAG_MACHINE
//                            then machine policy
//              pMachineName  - Name of remote computer in the form \\computername. If null
//                              then local computer is used.
//              pSidUser      - Security id of user (relevant for user policy). If pMachineName is
//                              null and pSidUser is null then it means current logged on user.
//                              If pMachine is null and pSidUser is non-null then it means user
//                              represented by pSidUser on local machine. If pMachineName is non-null
//                              then and if dwFlags specifies user policy, then pSidUser must be
//                              non-null.
//              pGuid      -  Guid of the specified extension
//              ppGPOList  -  Address of a pointer which receives the link list of GPOs
//
//  Returns:    Win32 error code
//
//*************************************************************

DWORD GetAppliedGPOList( DWORD dwFlags,
                         LPCTSTR pMachineName,
                         PSID pSidUser,
                         GUID *pGuidExtension,
                         PGROUP_POLICY_OBJECT *ppGPOList)
{
    DWORD dwRet = E_FAIL;
    TCHAR szExtension[64];
    BOOL bOk;
    BOOL bMachine = dwFlags & GPO_LIST_FLAG_MACHINE;
    NTSTATUS ntStatus;
    UNICODE_STRING  unicodeStr;

    *ppGPOList = 0;

    if ( pGuidExtension == 0 )
        return ERROR_INVALID_PARAMETER;

    GuidToString( pGuidExtension, szExtension );

    DebugMsg((DM_VERBOSE, TEXT("GetAppliedGPOList: Entering. Extension = %s"),
              szExtension));

    if ( pMachineName == NULL ) {

        //
        // Local case
        //

        if ( bMachine ) {

            bOk = ReadGPOList( szExtension,
                               HKEY_LOCAL_MACHINE,
                               HKEY_LOCAL_MACHINE,
                               0,
                               FALSE, ppGPOList );

            return bOk ? ERROR_SUCCESS : E_FAIL;

        } else {

            BOOL bUsePerUserLocalSetting = ExtensionHasPerUserLocalSetting( szExtension, HKEY_LOCAL_MACHINE );
            LPTSTR lpwszSidUser = NULL;

            if ( pSidUser == NULL ) {

                //
                // Current logged on user
                //

                if ( bUsePerUserLocalSetting ) {

                    HANDLE hToken = NULL;
                    if (!OpenThreadToken (GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken)) {
                        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
                            DebugMsg((DM_WARNING, TEXT("GetAppliedGPOList:  Failed to get user token with  %d"),
                                      GetLastError()));
                            return GetLastError();
                        }
                    }

                    lpwszSidUser = GetSidString( hToken );
                    CloseHandle( hToken );

                    if ( lpwszSidUser == NULL ) {
                        DebugMsg((DM_WARNING, TEXT("GetAppliedGPOList: GetSidString failed.")));
                        return E_FAIL;
                    }

                }

                bOk = ReadGPOList( szExtension,
                                   HKEY_CURRENT_USER,
                                   HKEY_LOCAL_MACHINE,
                                   lpwszSidUser,
                                   FALSE, ppGPOList );
                if ( lpwszSidUser )
                    DeleteSidString( lpwszSidUser );

                return bOk ? ERROR_SUCCESS : E_FAIL;

            } else {

                //
                // User represented by pSidUser
                //

                HKEY hSubKey;

                ntStatus = RtlConvertSidToUnicodeString( &unicodeStr,
                                                         pSidUser,
                                                         (BOOLEAN)TRUE  ); // Allocate
                if ( !NT_SUCCESS(ntStatus) )
                    return E_FAIL;

                dwRet = RegOpenKeyEx ( HKEY_USERS, unicodeStr.Buffer, 0, KEY_READ, &hSubKey);

                if (dwRet != ERROR_SUCCESS) {
                    RtlFreeUnicodeString(&unicodeStr);

                    if (dwRet == ERROR_FILE_NOT_FOUND)
                        return ERROR_SUCCESS;
                    else
                        return dwRet;
                }

                bOk = ReadGPOList( szExtension,
                                   hSubKey,
                                   HKEY_LOCAL_MACHINE,
                                   bUsePerUserLocalSetting ? unicodeStr.Buffer : NULL,
                                   FALSE, ppGPOList );

                RtlFreeUnicodeString(&unicodeStr);
                RegCloseKey(hSubKey);

                return bOk ? ERROR_SUCCESS : E_FAIL;

            }  // else if psiduser == null

        }      // else if bmachine

    } else {   // if pmachine == null

        //
        // Remote case
        //

        if ( bMachine ) {

            HKEY hKeyRemote;

            dwRet = RegConnectRegistry( pMachineName,
                                        HKEY_LOCAL_MACHINE,
                                        &hKeyRemote );
            if ( dwRet != ERROR_SUCCESS )
                return dwRet;

            bOk = ReadGPOList( szExtension,
                               hKeyRemote,
                               hKeyRemote,
                               0,
                               FALSE, ppGPOList );
            RegCloseKey( hKeyRemote );

            dwRet = bOk ? ERROR_SUCCESS : E_FAIL;
            return dwRet;

        } else {

            //
            // Remote user
            //

            HKEY hKeyRemoteMach;
            BOOL bUsePerUserLocalSetting;

            if ( pSidUser == NULL )
                return ERROR_INVALID_PARAMETER;

            ntStatus = RtlConvertSidToUnicodeString( &unicodeStr,
                                                     pSidUser,
                                                     (BOOLEAN)TRUE  ); // Allocate
            if ( !NT_SUCCESS(ntStatus) )
                return E_FAIL;

            dwRet = RegConnectRegistry( pMachineName,
                                        HKEY_LOCAL_MACHINE,
                                        &hKeyRemoteMach );

            bUsePerUserLocalSetting = ExtensionHasPerUserLocalSetting( szExtension, hKeyRemoteMach );

            if ( bUsePerUserLocalSetting ) {

                //
                // Account for per user local settings
                //

                bOk = ReadGPOList( szExtension,
                                   hKeyRemoteMach,
                                   hKeyRemoteMach,
                                   unicodeStr.Buffer,
                                   FALSE, ppGPOList );

                RtlFreeUnicodeString(&unicodeStr);
                RegCloseKey(hKeyRemoteMach);

                return bOk ? ERROR_SUCCESS : E_FAIL;

            } else {

                HKEY hKeyRemote, hSubKeyRemote;

                RegCloseKey( hKeyRemoteMach );

                dwRet = RegConnectRegistry( pMachineName,
                                            HKEY_USERS,
                                            &hKeyRemote );
                if ( dwRet != ERROR_SUCCESS ) {
                    RtlFreeUnicodeString(&unicodeStr);
                    return dwRet;
                }

                dwRet = RegOpenKeyEx (hKeyRemote, unicodeStr.Buffer, 0, KEY_READ, &hSubKeyRemote);

                RtlFreeUnicodeString(&unicodeStr);

                if (dwRet != ERROR_SUCCESS) {
                    RegCloseKey(hKeyRemote);

                    if (dwRet == ERROR_FILE_NOT_FOUND)
                        return ERROR_SUCCESS;
                    else
                        return dwRet;
                }

                bOk = ReadGPOList( szExtension,
                                   hSubKeyRemote,
                                   hSubKeyRemote,
                                   0,
                                   FALSE, ppGPOList );

                RegCloseKey(hSubKeyRemote);
                RegCloseKey(hKeyRemote);

                return bOk ? ERROR_SUCCESS : E_FAIL;

            } // else if bUsePerUserLocalSettings

        } // else if bMachine

    }   // else if pMachName == null

    return dwRet;
}

#define FORCE_FOREGROUND_LOGGING L"ForceForegroundLogging"

#define SITENAME    L"Site-Name"
#define DN          L"Distinguished-Name"
#define LOOPBACKDN  L"Loopback-Distinguished-Name"
#define SLOWLINK    L"SlowLink"
#define GPO         L"GPO-List"
#define LOOPBACK    L"Loopback-GPO-List"
#define EXTENSION   L"Extension-List"
#define GPLINKLIST  L"GPLink-List"
#define LOOPBACKGPL L"Loopback-GPLink-List"

#define GPOID       L"GPOID"
#define VERSION     L"Version"
#define SOM         L"SOM"
#define WQL         L"WQLFilterPass"
#define ACCESS      L"AccessDenied"
#define DISPLAYNAME L"DisplayName"
#define DISABLED    L"GPO-Disabled"
#define WQLID       L"WQL-Id"
#define OPTIONS     L"Options"
#define STARTTIME1  L"StartTimeLo"
#define ENDTIME1    L"EndTimeLo"
#define STARTTIME2  L"StartTimeHi"
#define ENDTIME2    L"EndTimeHi"
#define STATUS      L"Status"
#define LOGSTATUS   L"LoggingStatus"
#define ENABLED     L"Enabled"
#define NOOVERRIDE  L"NoOverride"
#define DSPATH      L"DsPath"

DWORD RegSaveGPL(   HKEY hKeyState,
                    LPSCOPEOFMGMT pSOM,
                    LPWSTR szGPLKey )
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // delete the existing list of GPLs
    //
    if ( !RegDelnode( hKeyState, szGPLKey ) )
    {
        dwError = GetLastError();
    }

    if ( dwError == ERROR_SUCCESS )
    {
        HKEY    hKeyGPL;

        //
        // recreate the GPL key
        //
        dwError = RegCreateKeyEx(   hKeyState,
                                    szGPLKey,
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyGPL,
                                    0 );
        if ( dwError == ERROR_SUCCESS )
        {
            DWORD   dwGPLs = 0;

            while ( pSOM )
            {
                LPGPLINK pGPLink = pSOM->pGpLinkList;

                while ( pGPLink )
                {
                    HKEY    hKeyNumber = 0;
                    WCHAR   szNumber[32];

                    //
                    // create the number key of GPLs
                    //
                    dwError = RegCreateKeyEx(   hKeyGPL,
                                                _itow( dwGPLs, szNumber, 16 ),
                                                0,
                                                0,
                                                0,
                                                KEY_ALL_ACCESS,
                                                0,
                                                &hKeyNumber,
                                                0 );
                    if ( dwError != ERROR_SUCCESS )
                    {
                        break;
                    }

                    //
                    // Enabled
                    //
                    dwError = RegSetValueEx(hKeyNumber,
                                            ENABLED,
                                            0,
                                            REG_DWORD,
                                            (BYTE*) &( pGPLink->bEnabled ),
                                            sizeof( pGPLink->bEnabled ) );
                    if ( dwError != ERROR_SUCCESS )
                    {
                        RegCloseKey( hKeyNumber );
                        break;
                    }

                    //
                    // NoOverride
                    //
                    dwError = RegSetValueEx(hKeyNumber,
                                            NOOVERRIDE,
                                            0,
                                            REG_DWORD,
                                            (BYTE*) &( pGPLink->bNoOverride ),
                                            sizeof( pGPLink->bNoOverride ) );
                    if ( dwError != ERROR_SUCCESS )
                    {
                        RegCloseKey( hKeyNumber );
                        break;
                    }

                    //
                    // DS PATH
                    //
                    LPWSTR szTemp = pGPLink->pwszGPO ? pGPLink->pwszGPO : L"";
                    dwError = RegSetValueEx(hKeyNumber,
                                            DSPATH,
                                            0,
                                            REG_SZ,
                                            (BYTE*) szTemp,
                                            ( wcslen( szTemp ) + 1 ) * sizeof( WCHAR ) );
                    if ( dwError != ERROR_SUCCESS )
                    {
                        RegCloseKey( hKeyNumber );
                        break;
                    }

                    //
                    // SOM
                    //
                    szTemp = pSOM->pwszSOMId ? pSOM->pwszSOMId : L"";
                    dwError = RegSetValueEx(hKeyNumber,
                                            SOM,
                                            0,
                                            REG_SZ,
                                            (BYTE*) szTemp,
                                            ( wcslen( szTemp ) + 1 ) * sizeof( WCHAR ) );
                    if ( dwError != ERROR_SUCCESS )
                    {
                        RegCloseKey( hKeyNumber );
                        break;
                    }

                    RegCloseKey( hKeyNumber );
                    pGPLink = pGPLink->pNext;
                    dwGPLs++;
                }

                pSOM = pSOM->pNext;
            }
            RegCloseKey( hKeyGPL );
        }
    }

    return dwError;
}

DWORD RegCompareGPLs(   HKEY hKeyState,
                        LPSCOPEOFMGMT pSOM,
                        LPWSTR szGPLKey,
                        BOOL* pbChanged )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY  hKeyGPL;

    *pbChanged = FALSE;

    //
    // open the GPL key
    //
    dwError = RegOpenKeyEx( hKeyState,
                            szGPLKey,
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyGPL );
    if ( dwError != ERROR_SUCCESS )
    {
        *pbChanged = TRUE;
        return dwError;
    }

    WCHAR   szNumber[32];
    HKEY    hKeyNumber = 0;

    //
    // compare each GPL and its corr. key for changes
    //
    DWORD dwGPLs = 0;
    while ( pSOM )
    {
        LPGPLINK pGPLink = pSOM->pGpLinkList;

        while ( pGPLink && dwError == ERROR_SUCCESS && !*pbChanged )
        {
            WCHAR   szBuffer[2*MAX_PATH+1];
            DWORD   dwType;
            DWORD   dwSize;
            DWORD   dwBuffer;

            //
            // open the key corr. to the GPL
            //
            dwError = RegOpenKeyEx( hKeyGPL,
                                    _itow( dwGPLs, szNumber, 16 ),
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hKeyNumber );
            if ( dwError != ERROR_SUCCESS )
            {
                *pbChanged = TRUE;
                continue;
            }
            
            //
            // Enabled
            //
            dwType = 0;
            dwBuffer = 0;
            dwSize = sizeof( dwBuffer );
            dwError = RegQueryValueEx(  hKeyNumber,
                                        ENABLED,
                                        0,
                                        &dwType,
                                        (BYTE*) &dwBuffer,
                                        &dwSize );
            if ( dwError != ERROR_SUCCESS || dwBuffer != pGPLink->bEnabled )
            {
                *pbChanged = TRUE;
                continue;
            }

            //
            // NoOverride
            //
            dwType = 0;
            dwBuffer = 0;
            dwSize = sizeof( dwBuffer );
            dwError = RegQueryValueEx(  hKeyNumber,
                                        NOOVERRIDE,
                                        0,
                                        &dwType,
                                        (BYTE*) &dwBuffer,
                                        &dwSize );
            if ( dwError != ERROR_SUCCESS || dwBuffer != pGPLink->bNoOverride )
            {
                *pbChanged = TRUE;
                continue;
            }

            //
            // DS PATH
            //
            LPWSTR szTemp = pGPLink->pwszGPO ? pGPLink->pwszGPO : L"";
            dwType = 0;
            szBuffer[0] = 0;
            dwSize = sizeof( szBuffer );
            dwError = RegQueryValueEx(  hKeyNumber,
                                        DSPATH,
                                        0,
                                        &dwType,
                                        (BYTE*) szBuffer,
                                        &dwSize );
            if ( dwError != ERROR_SUCCESS || _wcsicmp( szBuffer, szTemp ) )
            {
                *pbChanged = TRUE;
                continue;
            }

            //
            // SOM
            //
            szTemp = pSOM->pwszSOMId ? pSOM->pwszSOMId : L"";
            dwType = 0;
            szBuffer[0] = 0;
            dwSize = sizeof( szBuffer );
            dwError = RegQueryValueEx(  hKeyNumber,
                                        SOM,
                                        0,
                                        &dwType,
                                        (BYTE*) szBuffer,
                                        &dwSize );
            if ( dwError != ERROR_SUCCESS || _wcsicmp( szBuffer, szTemp ) )
            {
                *pbChanged = TRUE;
                continue;
            }

            RegCloseKey( hKeyNumber );
            hKeyNumber = 0;
            pGPLink = pGPLink->pNext;
            dwGPLs++;
        }

        pSOM = pSOM->pNext;
    }

    if ( hKeyNumber )
    {
        RegCloseKey( hKeyNumber );
    }
    RegCloseKey( hKeyGPL );

    return dwError;
}

DWORD RegSaveGPOs(  HKEY hKeyState,
                    LPGPCONTAINER pGPOs,
                    BOOL bMachine,
                    LPWSTR szGPOKey )
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // delete the existing list of GPOs
    //
    if ( !RegDelnode( hKeyState, szGPOKey ) )
    {
        dwError = GetLastError();
    }

    if ( dwError == ERROR_SUCCESS )
    {
        HKEY    hKeyGPO;

        //
        // recreate the GPO key
        //
        dwError = RegCreateKeyEx(   hKeyState,
                                    szGPOKey,
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyGPO,
                                    0 );
        if ( dwError == ERROR_SUCCESS )
        {
            DWORD   dwGPOs = 0;

            while ( pGPOs )
            {
                HKEY    hKeyNumber = 0;
                WCHAR   szNumber[32];

                //
                // create the number key of GPOs
                //
                dwError = RegCreateKeyEx(   hKeyGPO,
                                            _itow( dwGPOs, szNumber, 16 ),
                                            0,
                                            0,
                                            0,
                                            KEY_ALL_ACCESS,
                                            0,
                                            &hKeyNumber,
                                            0 );
                if ( dwError != ERROR_SUCCESS )
                {
                    break;
                }

                //
                // version
                //
                dwError = RegSetValueEx(hKeyNumber,
                                        VERSION,
                                        0,
                                        REG_DWORD,
                                        (BYTE*) ( bMachine ? &pGPOs->dwMachVersion : &pGPOs->dwUserVersion ),
                                        sizeof( DWORD ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                //
                // WQL
                //
                dwError = RegSetValueEx(hKeyNumber,
                                        WQL,
                                        0,
                                        REG_DWORD,
                                        (BYTE*) &pGPOs->bFilterAllowed,
                                        sizeof( DWORD ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                //
                // Access
                //
                dwError = RegSetValueEx(hKeyNumber,
                                        ACCESS,
                                        0,
                                        REG_DWORD,
                                        (BYTE*) &pGPOs->bAccessDenied,
                                        sizeof( DWORD ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                //
                // disabled
                //
                dwError = RegSetValueEx(hKeyNumber,
                                        DISABLED,
                                        0,
                                        REG_DWORD,
                                        (BYTE*) ( bMachine ? &pGPOs->bMachDisabled : &pGPOs->bUserDisabled ),
                                        sizeof( DWORD ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                //
                // Options
                //
                dwError = RegSetValueEx(hKeyNumber,
                                        OPTIONS,
                                        0,
                                        REG_DWORD,
                                        (BYTE*) &( pGPOs->dwOptions ),
                                        sizeof( DWORD ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                //
                // GPO GUID
                //
                dwError = RegSetValueEx(hKeyNumber,
                                        GPOID,
                                        0,
                                        REG_SZ,
                                        (BYTE*) pGPOs->pwszGPOName,
                                        ( wcslen( pGPOs->pwszGPOName ) + 1 ) * sizeof( WCHAR ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                //
                // SOM
                //
                dwError = RegSetValueEx(hKeyNumber,
                                        SOM,
                                        0,
                                        REG_SZ,
                                        (BYTE*) pGPOs->szSOM,
                                        ( wcslen( pGPOs->szSOM ) + 1 ) * sizeof( WCHAR ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                LPWSTR  szTemp;

                //
                // display name
                //
                szTemp = pGPOs->pwszDisplayName ? pGPOs->pwszDisplayName : L"";
                dwError = RegSetValueEx(hKeyNumber,
                                        DISPLAYNAME,
                                        0,
                                        REG_SZ,
                                        (BYTE*) szTemp,
                                        ( wcslen( szTemp ) + 1 ) * sizeof( WCHAR ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                //
                // WQL filter
                //
                szTemp = pGPOs->pwszFilterId ? pGPOs->pwszFilterId : L"";
                dwError = RegSetValueEx(hKeyNumber,
                                        WQLID,
                                        0,
                                        REG_SZ,
                                        (BYTE*) szTemp,
                                        ( wcslen( szTemp ) + 1 ) * sizeof( WCHAR ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                RegCloseKey( hKeyNumber );
                pGPOs = pGPOs->pNext;
                dwGPOs++;
            }

            RegCloseKey( hKeyGPO );
        }
    }

    return dwError;
}

DWORD RegCompareGPOs(   HKEY hKeyState,
                        LPGPCONTAINER pGPOs,
                        BOOL bMachine,
                        LPWSTR szGPOKey,
                        BOOL* pbChanged,
                        BOOL* pbListChanged )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY    hKeyGPO;

    *pbChanged = FALSE;

    //
    // open the GPO key
    //
    dwError = RegOpenKeyEx( hKeyState,
                            szGPOKey,
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyGPO );
    if ( dwError != ERROR_SUCCESS )
    {
        *pbChanged = TRUE;
        return dwError;
    }

    DWORD dwSubKeys = 0;

    //
    // get the number of sub keys
    //
    dwError = RegQueryInfoKey(  hKeyGPO,
                                0,
                                0,
                                0,
                                &dwSubKeys,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0 );
    if ( dwError != ERROR_SUCCESS )
    {
        *pbChanged = TRUE;
        *pbListChanged = TRUE;
        RegCloseKey( hKeyGPO );
        return dwError;
    }

    LPGPCONTAINER pTemp = pGPOs;
    DWORD dwGPOs = 0;

    //
    // count the number of GPOs
    //
    while ( pTemp )
    {
        dwGPOs++;
        pTemp = pTemp->pNext;
    }

    //
    // the number of GPOs and the keys should match
    //
    if ( dwGPOs != dwSubKeys )
    {
        *pbChanged = TRUE;
        *pbListChanged = TRUE;
        RegCloseKey( hKeyGPO );
        return dwError;
    }

    WCHAR   szNumber[32];
    HKEY    hKeyNumber = 0;

    //
    // compare each GPO and its corr. key for changes
    //
    dwGPOs = 0;
    while ( pGPOs && dwError == ERROR_SUCCESS && !*pbChanged )
    {
        WCHAR   szBuffer[2*MAX_PATH+1];
        DWORD   dwType;
        DWORD   dwSize;
        DWORD   dwBuffer;

        //
        // open the key corr. to the GPO
        //
        dwError = RegOpenKeyEx( hKeyGPO,
                                _itow( dwGPOs, szNumber, 16 ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyNumber );
        if ( dwError != ERROR_SUCCESS )
        {
            *pbChanged = TRUE;
            continue;
        }
        
        //
        // version
        //
        dwType = 0;
        dwBuffer = 0;
        dwSize = sizeof( dwBuffer );
        dwError = RegQueryValueEx(  hKeyNumber,
                                    VERSION,
                                    0,
                                    &dwType,
                                    (BYTE*) &dwBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || dwBuffer != ( bMachine ? pGPOs->dwMachVersion : pGPOs->dwUserVersion ) )
        {
            *pbChanged = TRUE;
            continue;
        }

        //
        // WQL
        //
        dwType = 0;
        dwBuffer = 0;
        dwSize = sizeof( dwBuffer );
        dwError = RegQueryValueEx(  hKeyNumber,
                                    WQL,
                                    0,
                                    &dwType,
                                    (BYTE*) &dwBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || (BOOL) dwBuffer != pGPOs->bFilterAllowed )
        {
            *pbChanged = TRUE;
            continue;
        }

        //
        // Access
        //
        dwType = 0;
        dwBuffer = 0;
        dwSize = sizeof( dwBuffer );
        dwError = RegQueryValueEx(  hKeyNumber,
                                    ACCESS,
                                    0,
                                    &dwType,
                                    (BYTE*) &dwBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || (BOOL) dwBuffer != pGPOs->bAccessDenied )
        {
            *pbChanged = TRUE;
            continue;
        }

        //
        // disabled
        //
        dwType = 0;
        dwBuffer = 0;
        dwSize = sizeof( dwBuffer );
        dwError = RegQueryValueEx(  hKeyNumber,
                                    DISABLED,
                                    0,
                                    &dwType,
                                    (BYTE*) &dwBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || (BOOL) dwBuffer != ( bMachine ? pGPOs->bMachDisabled : pGPOs->bUserDisabled ) )
        {
            *pbChanged = TRUE;
            continue;
        }

        //
        // Options
        //
        dwType = 0;
        dwBuffer = 0;
        dwSize = sizeof( dwBuffer );
        dwError = RegQueryValueEx(  hKeyNumber,
                                    OPTIONS,
                                    0,
                                    &dwType,
                                    (BYTE*) &dwBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || dwBuffer != pGPOs->dwOptions )
        {
            *pbChanged = TRUE;
            continue;
        }

        //
        // GPO GUID
        //
        dwType = 0;
        szBuffer[0] = 0;
        dwSize = sizeof( szBuffer );
        dwError = RegQueryValueEx(  hKeyNumber,
                                    GPOID,
                                    0,
                                    &dwType,
                                    (BYTE*) szBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || _wcsicmp( szBuffer, pGPOs->pwszGPOName ) )
        {
            *pbChanged = TRUE;
            continue;
        }

        //
        // SOM
        //
        dwType = 0;
        szBuffer[0] = 0;
        dwSize = sizeof( szBuffer );
        dwError = RegQueryValueEx(  hKeyNumber,
                                    SOM,
                                    0,
                                    &dwType,
                                    (BYTE*) szBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || _wcsicmp( szBuffer, pGPOs->szSOM ) )
        {
            *pbChanged = TRUE;
            continue;
        }

        LPWSTR szTemp;

        //
        // display name
        //
        szTemp = pGPOs->pwszDisplayName ? pGPOs->pwszDisplayName : L"";
        dwType = 0;
        szBuffer[0] = 0;
        dwSize = sizeof( szBuffer );
        dwError = RegQueryValueEx(  hKeyNumber,
                                    DISPLAYNAME,
                                    0,
                                    &dwType,
                                    (BYTE*) szBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || _wcsicmp( szBuffer, szTemp ) )
        {
            *pbChanged = TRUE;
            continue;
        }

        //
        // WQL filter
        //
        szTemp = pGPOs->pwszFilterId ? pGPOs->pwszFilterId : L"";
        dwType = 0;
        szBuffer[0] = 0;
        dwSize = sizeof( szBuffer );
        dwError = RegQueryValueEx(  hKeyNumber,
                                    WQLID,
                                    0,
                                    &dwType,
                                    (BYTE*) szBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || _wcsicmp( szBuffer, szTemp ) )
        {
            *pbChanged = TRUE;
            continue;
        }

        RegCloseKey( hKeyNumber );
        hKeyNumber = 0;
        pGPOs = pGPOs->pNext;
        dwGPOs++;
    }

    if ( hKeyNumber )
    {
        RegCloseKey( hKeyNumber );
    }
    RegCloseKey( hKeyGPO );

    return dwError;
}

//*************************************************************
//
//  SavePolicyState()
//
//  Purpose:    Saves enough information about the policy application
//              to determine if RSoP data needs to be re-logged
//
//   HKLM\Software\Microsoft\Windows\CurrentVersion\Group Policy\State
//                                                                  |- Machine
//                                                                  |      |-SiteName
//                                                                  |      |-DN
//                                                                  |      |-GPO
//                                                                  |          |-0
//                                                                  |            |-GPOID
//                                                                  |            |-SOM
//                                                                  |            |-Version
//                                                                  |            |-WQL
//                                                                  |            |-Access
//                                                                  |          |-1
//                                                                  |            |-GPOID
//                                                                  |            |-SOM
//                                                                  |            |-Version
//                                                                  |            |-WQL
//                                                                  |            |-Access
//                                                                  |            ...
//                                                                  |          |-N
//                                                                  |            |-GPOID
//                                                                  |            |-SOM
//                                                                  |            |-Version
//                                                                  |            |-WQL
//                                                                  |            |-Access
//                                                                  |-{UserSID}
//                                                                         |-SiteName
//                                                                         |-DN
//                                                                         |-GPO
//                                                                             |-0
//                                                                               |-GPOID
//                                                                               |-SOM
//                                                                               |-Version
//                                                                               |-WQL
//                                                                               |-Access
//                                                                             |-1
//                                                                               |-GPOID
//                                                                               |-SOM
//                                                                               |-Version
//                                                                               |-WQL
//                                                                               |-Access
//                                                                               ...
//                                                                             |-N
//                                                                               |-GPOID
//                                                                               |-SOM
//                                                                               |-Version
//                                                                               |-WQL
//                                                                               |-Access
//  Parameters:
//              pInfo - current state of affairs
//
//  Returns:    Win32 error code
//
//*************************************************************

DWORD
SavePolicyState( LPGPOINFO pInfo )
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    bMachine = (pInfo->dwFlags & GP_MACHINE) != 0;
    HKEY    hKeyState = 0;
    WCHAR   szKeyState[MAX_PATH+1];
    LPWSTR szSite = pInfo->szSiteName ? pInfo->szSiteName : L"";
    LPWSTR szDN = pInfo->lpDNName ? pInfo->lpDNName : L"";
    BOOL    bSlowLink = (pInfo->dwFlags & GP_SLOW_LINK) != 0;

    //
    // determine the subkey to create
    //
    if ( bMachine )
    {
        wsprintf( szKeyState, GP_STATE_KEY, L"Machine" );
    }
    else
    {
        wsprintf( szKeyState, GP_STATE_KEY, pInfo->lpwszSidUser );
    }

    dwError = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                                szKeyState,
                                0,
                                0,
                                0,
                                KEY_ALL_ACCESS,
                                0,
                                &hKeyState,
                                0 );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    // reset forced logging in foreground
    //
    if ( !(pInfo->dwFlags & GP_BACKGROUND_THREAD) )
    {
        //
        // set the FORCE_FOREGROUND_LOGGING value
        //
        DWORD dwFalse = 0;
        dwError = RegSetValueEx(hKeyState,
                                FORCE_FOREGROUND_LOGGING,
                                0,
                                REG_DWORD,
                                (BYTE*) &dwFalse,
                                sizeof( DWORD ) );
        if ( dwError != ERROR_SUCCESS )
        {
            goto Exit;
        }
    }

    //
    // set the SITENAME value
    //
    dwError = RegSetValueEx(hKeyState,
                            SITENAME,
                            0,
                            REG_SZ,
                            (BYTE*) szSite,
                            ( wcslen( szSite ) + 1 ) * sizeof( WCHAR ) );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    // set the DN value
    //
    dwError = RegSetValueEx(hKeyState,
                            DN,
                            0,
                            REG_SZ,
                            (BYTE*) szDN,
                            ( wcslen( szDN ) + 1 ) * sizeof( WCHAR ) );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    // slow link
    //
    dwError = RegSetValueEx(hKeyState,
                            SLOWLINK,
                            0,
                            REG_DWORD,
                            (BYTE*) ( &bSlowLink ),
                            sizeof( DWORD ) );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

#if 0
    if ( !bMachine )
    {
        //
        // set the LOOPBACKDN value
        //
        dwError = RegSetValueEx(hKeyState,
                                LOOPBACKDN,
                                0,
                                REG_SZ,
                                (BYTE*) pInfo->lpDNName,
                                ( wcslen( pInfo->lpDNName ) + 1 ) * sizeof( WCHAR ) );
        if ( dwError != ERROR_SUCCESS )
        {
            goto Exit;
        }
    }
#endif

    //
    // save the list of GPOs
    //
    dwError =  RegSaveGPOs( hKeyState, pInfo->lpGpContainerList, bMachine, GPO );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    if ( !bMachine )
    {
        //
        // save the list of Loopback GPOs
        //
        dwError =  RegSaveGPOs( hKeyState, pInfo->lpLoopbackGpContainerList, bMachine, LOOPBACK );
        if ( dwError != ERROR_SUCCESS )
        {
            goto Exit;
        }
    }

    //
    // save the list of GPLinks
    //
    dwError = RegSaveGPL( hKeyState, pInfo->lpSOMList, GPLINKLIST );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    if ( !bMachine )
    {
        //
        // save the list of Loopback GPLinks
        //
        dwError =  RegSaveGPL( hKeyState, pInfo->lpLoopbackSOMList, LOOPBACKGPL );
    }

Exit:
    if ( hKeyState )
    {
        RegCloseKey( hKeyState );
    }
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SavePolicyState: Failed Registry operation with %d", dwError ) );
    }

    return dwError;
}

//*************************************************************
//
//  SaveLinkState()
//
//  Purpose:    Saves link speed information for the policy application
//
//  Parameters:
//              pInfo - current state of affairs
//
//  Returns:    Win32 error code
//
//*************************************************************

DWORD
SaveLinkState( LPGPOINFO pInfo )
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    bMachine = (pInfo->dwFlags & GP_MACHINE) != 0;
    HKEY    hKeyState = 0;
    WCHAR   szKeyState[MAX_PATH+1];
    BOOL    bSlowLink = (pInfo->dwFlags & GP_SLOW_LINK) != 0;

    //
    // determine the subkey to create
    //
    if ( bMachine )
    {
        wsprintf( szKeyState, GP_STATE_KEY, L"Machine" );
    }
    else
    {
        wsprintf( szKeyState, GP_STATE_KEY, pInfo->lpwszSidUser );
    }

    dwError = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                                szKeyState,
                                0,
                                0,
                                0,
                                KEY_ALL_ACCESS,
                                0,
                                &hKeyState,
                                0 );
    if ( dwError == ERROR_SUCCESS )
    {
        //
        // slow link
        //
        dwError = RegSetValueEx(hKeyState,
                                SLOWLINK,
                                0,
                                REG_DWORD,
                                (BYTE*) ( &bSlowLink ),
                                sizeof( DWORD ) );

        RegCloseKey( hKeyState );
    }

    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLinkState: Failed Registry operation with %d", dwError ) );
    }

    return dwError;
}

//*************************************************************
//
//  ComparePolicyState()
//
//  Purpose:    Compares the policy state saved in the registry
//              with the state in LPGPOINFO
//
//  Parameters:
//              pInfo       - current state of affairs
//              pbLinkChanged   - has the link speed changed?
//              pbStateChanged   - has the state changed?
//
//  Returns:    Win32 error code
//
//*************************************************************

DWORD
ComparePolicyState( LPGPOINFO pInfo, BOOL* pbLinkChanged, BOOL* pbStateChanged, BOOL *pbNoState )
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    bMachine = (pInfo->dwFlags & GP_MACHINE) != 0;
    HKEY    hKeyState = 0;
    WCHAR   szKeyState[MAX_PATH+1];
    DWORD   dwBuffer;
    BOOL    bSlowLink = (pInfo->dwFlags & GP_SLOW_LINK) != 0;
    BOOL    bListChanged = FALSE;

    *pbStateChanged = FALSE;
    *pbLinkChanged = FALSE;
    *pbNoState = FALSE;

    //
    // determine the subkey to open
    //
    if ( bMachine )
    {
        wsprintf( szKeyState, GP_STATE_KEY, L"Machine" );
    }
    else
    {
        wsprintf( szKeyState, GP_STATE_KEY, pInfo->lpwszSidUser );
    }

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            szKeyState,
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyState );
    if ( dwError != ERROR_SUCCESS )
    {
        *pbStateChanged = TRUE;
        *pbNoState = TRUE;
        if (dwError == ERROR_FILE_NOT_FOUND) {
            return S_OK;
        }
        else {
            goto Exit;
        }
    }

    WCHAR   szBuffer[2*MAX_PATH+1];
    DWORD   dwType;
    DWORD   dwSize;

    //
    // check for forced logging in foreground
    //
    if ( !(pInfo->dwFlags & GP_BACKGROUND_THREAD) )
    {
        //
        // get the FORCE_FOREGROUND_LOGGING value
        //
        dwType = 0;
        dwBuffer = 0;
        dwSize = sizeof( dwBuffer );
        dwError = RegQueryValueEx(  hKeyState,
                                    FORCE_FOREGROUND_LOGGING,
                                    0,
                                    &dwType,
                                    (BYTE*) &dwBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || dwBuffer != FALSE )
        {
            *pbStateChanged = TRUE;
            goto Exit;
        }
    }

    //
    // get the SITENAME value
    //
    dwSize = sizeof( szBuffer );
    dwType = 0;
    dwError = RegQueryValueEx(  hKeyState,
                                SITENAME,
                                0,
                                &dwType,
                                (BYTE*) szBuffer,
                                &dwSize );
    if ( dwError == ERROR_SUCCESS )
    {
        LPWSTR szSite = pInfo->szSiteName ? pInfo->szSiteName : L"";

        if ( _wcsicmp( szBuffer, szSite ) )
        {
            *pbStateChanged = TRUE;
            goto Exit;
        }
    }
    else
    {
        goto Exit;
    }

    //
    // get the DN value
    //
    dwSize = sizeof( szBuffer );
    dwType = 0;
    dwError = RegQueryValueEx(  hKeyState,
                                DN,
                                0,
                                &dwType,
                                (BYTE*) szBuffer,
                                &dwSize );
    if ( dwError == ERROR_SUCCESS )
    {
        LPWSTR szDN = pInfo->lpDNName ? pInfo->lpDNName : L"";

        if ( _wcsicmp( szBuffer, szDN ) )
        {
            *pbStateChanged = TRUE;
            //
            // set forced logging in foreground
            //
            if ( (pInfo->dwFlags & GP_BACKGROUND_THREAD) )
            {
                //
                // set the FORCE_FOREGROUND_LOGGING value
                //
                DWORD dwTrue = TRUE;
                dwError = RegSetValueEx(hKeyState,
                                        FORCE_FOREGROUND_LOGGING,
                                        0,
                                        REG_DWORD,
                                        (BYTE*) &dwTrue,
                                        sizeof( DWORD ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    goto Exit;
                }
            }
            goto Exit;
        }
    }
    else
    {
        goto Exit;
    }

    //
    // slow link
    //
    dwType = 0;
    dwBuffer = 0;
    dwSize = sizeof( dwBuffer );
    dwError = RegQueryValueEx(  hKeyState,
                                SLOWLINK,
                                0,
                                &dwType,
                                (BYTE*) &dwBuffer,
                                &dwSize );
    if ( dwError != ERROR_SUCCESS || dwBuffer != (DWORD)bSlowLink )
    {
        *pbLinkChanged = TRUE;
    }

#if 0
    if ( !bMachine )
    {
        //
        // set the LOOPBACKDN value
        //
        dwSize = sizeof( szBuffer );
        dwType = 0;
        dwError = RegQueryValueEx(  hKeyState,
                                    LOOPBACKDN,
                                    0,
                                    &dwType,
                                    (BYTE*) szBuffer,
                                    &dwSize );
        if ( dwError == ERROR_SUCCESS )
        {
            if ( _wcsicmp( szBuffer, pInfo->lpDNName ) )
            {
                *pbStateChanged = TRUE;
                goto Exit;
            }
        }
        else
        {
            goto Exit;
        }
    }
#endif

    //
    // has the list of GPOs or the GPOs changed
    //
    dwError = RegCompareGPOs(   hKeyState,
                                pInfo->lpGpContainerList,
                                bMachine,
                                GPO,
                                pbStateChanged,
                                &bListChanged );
    //
    // set forced logging in foreground
    //
    if ( (pInfo->dwFlags & GP_BACKGROUND_THREAD) && bListChanged )
    {
        //
        // set the FORCE_FOREGROUND_LOGGING value
        //
        DWORD dwTrue = TRUE;
        dwError = RegSetValueEx(hKeyState,
                                FORCE_FOREGROUND_LOGGING,
                                0,
                                REG_DWORD,
                                (BYTE*) &dwTrue,
                                sizeof( DWORD ) );
        if ( dwError != ERROR_SUCCESS )
        {
            goto Exit;
        }
    }

    if ( dwError == ERROR_SUCCESS && !*pbStateChanged && !bMachine )
    {
        //
        // has the list of loopback GPOs or the GPOs changed
        //
        dwError = RegCompareGPOs(   hKeyState,
                                    pInfo->lpLoopbackGpContainerList,
                                    bMachine,
                                    LOOPBACK,
                                    pbStateChanged,
                                    &bListChanged );
        //
        // set forced logging in foreground
        //
        if ( (pInfo->dwFlags & GP_BACKGROUND_THREAD) && bListChanged )
        {
            //
            // set the FORCE_FOREGROUND_LOGGING value
            //
            DWORD dwTrue = TRUE;
            dwError = RegSetValueEx(hKeyState,
                                    FORCE_FOREGROUND_LOGGING,
                                    0,
                                    REG_DWORD,
                                    (BYTE*) &dwTrue,
                                    sizeof( DWORD ) );
            if ( dwError != ERROR_SUCCESS )
            {
                goto Exit;
            }
        }

        if ( dwError == ERROR_SUCCESS && !*pbStateChanged )
        {
            dwError = RegCompareGPLs(   hKeyState,
                                        pInfo->lpSOMList,
                                        GPLINKLIST,
                                        pbStateChanged );
            if ( !*pbStateChanged )
            {
                dwError = RegCompareGPLs(   hKeyState,
                                            pInfo->lpLoopbackSOMList,
                                            LOOPBACKGPL,
                                            pbStateChanged );
            }
        }
    }

Exit:
    if ( hKeyState )
    {
        RegCloseKey( hKeyState );
    }
    if ( dwError != ERROR_SUCCESS )
    {
        *pbStateChanged = TRUE;
        DebugMsg( ( DM_WARNING, L"ComparePolicyState: Failed Registry operation with %d", dwError ) );
    }

    return dwError;
}

//*************************************************************
//
//  DeletePolicyState()
//
//  Purpose:    deletes the policy state saved in the registry
//
//  Parameters:
//              szSID       - user SID or 0 for machine
//
//  Returns:    Win32 error code
//
//*************************************************************

DWORD
DeletePolicyState( LPCWSTR   szSid )
{
    DWORD   dwError = ERROR_SUCCESS;
    HKEY    hKeyState = 0;
    LPWSTR  szState = L"Machine";

    if ( szSid && *szSid )
    {
        szState = (LPWSTR) szSid;
    }

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            GP_STATE_ROOT_KEY,
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyState );
    if ( dwError == ERROR_SUCCESS )
    {
        if ( !RegDelnode( hKeyState, (LPWSTR) szState ) )
        {
            dwError = GetLastError();
        }

        RegCloseKey( hKeyState );
    }

    return dwError;
}

//*************************************************************
//
//  SaveLoggingStatus()
//
//  Purpose:    Saving the extension status into the registry
//
//  Parameters:
//              szSid           - Null for machine, otherwise the user sid
//              lpExt           - Extension info (null for GP Engine itself)
//              lpRsopExtStatus - A pointer to the RsopExtStatus corresponding
//                                to this extension
//
//  Returns:    Win32 error code
//
//*************************************************************


DWORD SaveLoggingStatus(LPWSTR szSid, LPGPEXT lpExt, RSOPEXTSTATUS *lpRsopExtStatus)
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    bMachine = (szSid == 0);
    HKEY    hKeyState = 0, hKeyExtState = 0, hKeyExt = 0;
    WCHAR   szKeyState[MAX_PATH+1];
    LPWSTR  lpExtId;

    if ( bMachine )
    {
        wsprintf( szKeyState, GP_STATE_KEY, L"Machine" );
    }
    else
    {
        wsprintf( szKeyState, GP_STATE_KEY, szSid );
    }

    dwError = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                                szKeyState,
                                0,
                                0,
                                0,
                                KEY_ALL_ACCESS,
                                0,
                                &hKeyState,
                                0 );

    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to create state key with %d", dwError ) );
        goto Exit;
    }

    dwError = RegCreateKeyEx(   hKeyState,
                                EXTENSION,
                                0,
                                0,
                                0,
                                KEY_ALL_ACCESS,
                                0,
                                &hKeyExtState,
                                0 );

    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to create extension key with %d", dwError ) );
        goto Exit;
    }


    lpExtId = lpExt ? lpExt->lpKeyName : GPCORE_GUID;

    dwError = RegCreateKeyEx(   hKeyExtState,
                                lpExtId,
                                0,
                                0,
                                0,
                                KEY_ALL_ACCESS,
                                0,
                                &hKeyExt,
                                0 );

    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to create CSE key with %d", dwError ) );
        goto Exit;
    }


    dwError = RegSetValueEx(hKeyExt, STARTTIME1, 0, REG_DWORD, 
                            (BYTE *)(&((lpRsopExtStatus->ftStartTime).dwLowDateTime)),
                            sizeof(DWORD));
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to set STARTTIME1 with %d", dwError ) );
        goto Exit;
    }

    dwError = RegSetValueEx(hKeyExt, STARTTIME2, 0, REG_DWORD, 
                            (BYTE *)(&((lpRsopExtStatus->ftStartTime).dwHighDateTime)),
                            sizeof(DWORD));
                            
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to set STARTTIME2 with %d", dwError ) );
        goto Exit;
    }
    
    dwError = RegSetValueEx(hKeyExt, ENDTIME1, 0, REG_DWORD, 
                            (BYTE *)(&((lpRsopExtStatus->ftEndTime).dwLowDateTime)),
                            sizeof(DWORD));
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to set ENDTIME1 with %d", dwError ) );
        goto Exit;
    }

    dwError = RegSetValueEx(hKeyExt, ENDTIME2, 0, REG_DWORD, 
                            (BYTE *)(&((lpRsopExtStatus->ftEndTime).dwHighDateTime)),
                            sizeof(DWORD));
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to set ENDTIME2 with %d", dwError ) );
        goto Exit;
    }

    dwError = RegSetValueEx(hKeyExt, STATUS, 0, REG_DWORD, 
                            (BYTE *)(&(lpRsopExtStatus->dwStatus)),
                            sizeof(DWORD));
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to set STATUS with %d", dwError ) );
        goto Exit;
    }

    dwError = RegSetValueEx(hKeyExt, LOGSTATUS, 0, REG_DWORD, 
                            (BYTE *)(&(lpRsopExtStatus->dwLoggingStatus)),
                            sizeof(DWORD));
                            
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to set LOGSTATUS with %d", dwError ) );
        goto Exit;
    }


Exit:
    
    if (hKeyExt) 
        RegCloseKey(hKeyExt);


    if (hKeyExtState) 
        RegCloseKey(hKeyExtState);


    if (hKeyState) 
        RegCloseKey(hKeyState);

    return dwError;

}

//*************************************************************
//
//  ReadLoggingStatus()
//
//  Purpose:    Read the extension status into the registry
//
//  Parameters:
//              szSid           - Null for machine, otherwise the user sid
//              szExtId         - Extension info (null for GP Engine itself)
//              lpRsopExtStatus - A pointer to the RsopExtStatus (that will be filled up)
//
//  Returns:    Win32 error code
//
//
//*************************************************************

DWORD ReadLoggingStatus(LPWSTR szSid, LPWSTR szExtId, RSOPEXTSTATUS *lpRsopExtStatus)
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    bMachine = (szSid == 0);
    HKEY    hKeyExt = 0;
    WCHAR   szKeyStateExt[MAX_PATH+1];
    LPWSTR  lpExtId;
    DWORD   dwType, dwSize;

    if ( bMachine )
    {
        wsprintf( szKeyStateExt, GP_STATE_KEY, L"Machine" );
    }
    else
    {
        wsprintf( szKeyStateExt, GP_STATE_KEY, szSid );
    }

    CheckSlash(szKeyStateExt);
    wcscat(szKeyStateExt, EXTENSION);
    CheckSlash(szKeyStateExt);
    lpExtId = szExtId ? szExtId : GPCORE_GUID;    
    wcscat(szKeyStateExt, lpExtId);


    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                szKeyStateExt,
                                0,
                                KEY_READ,
                                &hKeyExt);

    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"ReadLoggingStatus: Failed to create state key with %d", dwError ) );
        goto Exit;
    }


    dwSize = sizeof(DWORD);
    dwError = RegQueryValueEx(hKeyExt, STARTTIME1, 0, &dwType, 
                            (BYTE *)(&((lpRsopExtStatus->ftStartTime).dwLowDateTime)),
                            &dwSize);
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"ReadLoggingStatus: Failed to set STARTTIME1 with %d", dwError ) );
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    dwError = RegQueryValueEx(hKeyExt, STARTTIME2, 0, &dwType, 
                            (BYTE *)(&((lpRsopExtStatus->ftStartTime).dwHighDateTime)),
                            &dwSize);
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"ReadLoggingStatus: Failed to set STARTTIME1 with %d", dwError ) );
        goto Exit;
    }
    
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueEx(hKeyExt, ENDTIME1, 0, &dwType, 
                            (BYTE *)(&((lpRsopExtStatus->ftEndTime).dwLowDateTime)),
                            &dwSize);
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"ReadLoggingStatus: Failed to set ENDTIME1 with %d", dwError ) );
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    dwError = RegQueryValueEx(hKeyExt, ENDTIME2, 0, &dwType, 
                            (BYTE *)(&((lpRsopExtStatus->ftEndTime).dwHighDateTime)),
                            &dwSize);
                            
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"ReadLoggingStatus: Failed to set ENDTIME2 with %d", dwError ) );
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    dwError = RegQueryValueEx(hKeyExt, STATUS, 0, &dwType, 
                            (BYTE *)(&(lpRsopExtStatus->dwStatus)),
                            &dwSize);
                            
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"ReadLoggingStatus: Failed to set STATUS with %d", dwError ) );
        goto Exit;
    }


    dwSize = sizeof(DWORD);
    dwError = RegQueryValueEx(hKeyExt, LOGSTATUS, 0, &dwType, 
                            (BYTE *)(&(lpRsopExtStatus->dwLoggingStatus)),
                            &dwSize);
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"ReadLoggingStatus: Failed to set LOGSTATUS with %d", dwError ) );
        goto Exit;
    }


Exit:
    
    if (hKeyExt) 
        RegCloseKey(hKeyExt);

    return dwError;

}

#define POLICY_KEY          L"Software\\Policies\\Microsoft\\Windows NT\\CurrentVersion\\winlogon"
#define PREFERENCE_KEY      L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon"
#define GP_SYNCFGREFRESH    L"SyncForegroundPolicy"

BOOL WINAPI
GetFgPolicySetting( HKEY hKeyRoot )
{
    HKEY    hKeyPolicy = 0;
    HKEY    hKeyPreference = 0;
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   dwType = REG_DWORD;
    DWORD   dwSize = sizeof( DWORD );
    BOOL    bSync = FALSE;
    
    //
    // async only on Pro
    //
    OSVERSIONINFOEXW version;
    version.dwOSVersionInfoSize = sizeof(version);
    if ( !GetVersionEx( (LPOSVERSIONINFO) &version ) )
    {
        //
        // conservatively assume non Pro SKU
        //
        return TRUE;
    }
    else
    {
        if ( version.wProductType != VER_NT_WORKSTATION )
        {
            //
            // force sync refresh on non Pro SKU
            //
            return TRUE;
        }
    }

    dwError = RegOpenKeyEx( hKeyRoot,
                            PREFERENCE_KEY,
                            0,
                            KEY_READ,
                            &hKeyPreference );
    if ( dwError == ERROR_SUCCESS )
    {
        //
        // read the preference value
        //
        RegQueryValueEx(hKeyPreference,
                        GP_SYNCFGREFRESH,
                        0,
                        &dwType,
                        (LPBYTE) &bSync,
                        &dwSize );
        RegCloseKey( hKeyPreference );
    }

    dwError = RegOpenKeyEx( hKeyRoot,
                            POLICY_KEY,
                            0,
                            KEY_READ,
                            &hKeyPolicy );
    if ( dwError == ERROR_SUCCESS )
    {
        //
        // read the policy
        //
        RegQueryValueEx(hKeyPolicy,
                        GP_SYNCFGREFRESH,
                        0,
                        &dwType,
                        (LPBYTE) &bSync,
                        &dwSize );
        RegCloseKey( hKeyPolicy );
    }

    return bSync;
}

#define PREVREFRESHMODE     L"PrevRefreshMode"
#define NEXTREFRESHMODE     L"NextRefreshMode"
#define PREVREFRESHREASON   L"PrevRefreshReason"
#define NEXTREFRESHREASON   L"NextRefreshReason"

#define STATE_KEY           L"Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\State\\"

DWORD WINAPI
gpGetFgPolicyRefreshInfo(BOOL bPrev,
                              LPWSTR szUserSid,
                              LPFgPolicyRefreshInfo pInfo )
{
    DWORD   dwError = ERROR_SUCCESS;
    WCHAR   szKeyState[MAX_PATH+1] = STATE_KEY;
    HKEY    hKeyState = 0;
    DWORD   dwType;
    DWORD   dwSize;

    if ( !pInfo )
    {
        return E_INVALIDARG;
    }

    pInfo->mode = GP_ModeUnknown;
    pInfo->reason = GP_ReasonUnknown;

    //
    // determine the subkey to create
    //
    if ( !szUserSid )
    {
        wcscat( szKeyState, L"Machine" );
    }
    else
    {
        wcscat( szKeyState, szUserSid );
    }

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            szKeyState,
                            0,
                            KEY_READ,
                            &hKeyState );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    // refresh mode
    //
    dwType = REG_DWORD;
    dwSize = sizeof( DWORD );
    dwError = RegQueryValueEx(  hKeyState,
                                bPrev ? PREVREFRESHMODE : NEXTREFRESHMODE ,
                                0,
                                &dwType,
                                (LPBYTE) &pInfo->mode,
                                &dwSize );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    // refresh reason
    //
    dwType = REG_DWORD;
    dwSize = sizeof( DWORD );
    dwError = RegQueryValueEx(  hKeyState,
                                bPrev ? PREVREFRESHREASON : NEXTREFRESHREASON ,
                                0,
                                &dwType,
                                (LPBYTE) &pInfo->reason,
                                &dwSize );

Exit:
    //
    // cleanup
    //
    if ( hKeyState )
    {
        RegCloseKey( hKeyState );
    }

    //
    // assume first logon/startup
    //
    if ( dwError == ERROR_FILE_NOT_FOUND )
    {
        pInfo->mode = GP_ModeSyncForeground;
        pInfo->reason = GP_ReasonFirstPolicy;
        dwError = ERROR_SUCCESS;
    }

    return dwError;
}

LPWSTR g_szModes[] = 
{
    L"Unknown",
    L"Synchronous",
    L"Asynchronous",
};

LPWSTR g_szReasons[] = 
{
    L"NoNeedForSync",
    L"FirstPolicyRefresh",
    L"CSERequiresForeground",
    L"CSEReturnedError",
    L"ForcedSyncRefresh",
    L"SyncPolicy",
    L"NonCachedCredentials",
    L"SKU",
};

DWORD WINAPI
gpSetFgPolicyRefreshInfo(BOOL bPrev,
                              LPWSTR szUserSid,
                              FgPolicyRefreshInfo info )
{
    DWORD   dwError = ERROR_SUCCESS;
    WCHAR   szKeyState[MAX_PATH+1] = STATE_KEY;
    HKEY    hKeyState = 0;
    DWORD   dwType = REG_DWORD;
    DWORD   dwSize = sizeof( DWORD );

    //
    // determine the subkey to create
    //
    if ( !szUserSid )
    {
        wcscat( szKeyState, L"Machine" );
    }
    else
    {
        wcscat( szKeyState, szUserSid );
    }

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            szKeyState,
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyState );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    // refresh mode
    //
    dwError = RegSetValueEx(hKeyState,
                            bPrev ? PREVREFRESHMODE : NEXTREFRESHMODE ,
                            0,
                            REG_DWORD,
                            (LPBYTE) &info.mode,
                            sizeof( DWORD ) );
    //
    // refresh reason
    //
    dwType = REG_DWORD;
    dwSize = sizeof( DWORD );
    dwError = RegSetValueEx(hKeyState,
                            bPrev ? PREVREFRESHREASON : NEXTREFRESHREASON ,
                            0,
                            REG_DWORD,
                            (LPBYTE) &info.reason,
                            sizeof( DWORD ) );

Exit:
    //
    // cleanup
    //
    if ( hKeyState )
    {
        RegCloseKey( hKeyState );
    }

    if ( dwError == ERROR_SUCCESS )
    {
        DebugMsg( ( DM_VERBOSE,
                    L"SetFgRefreshInfo: %s %s Fg policy %s, Reason: %s.",
                    bPrev ? L"Previous" : L"Next",
                    szUserSid ? L"User" : L"Machine",
                    g_szModes[info.mode % ARRAYSIZE( g_szModes )],
                    g_szReasons[info.reason % ARRAYSIZE( g_szReasons )] ) );
    }
    
    return dwError;
}

USERENVAPI
DWORD
WINAPI
GetPreviousFgPolicyRefreshInfo( LPWSTR szUserSid,
                                      FgPolicyRefreshInfo* pInfo )

{
    return gpGetFgPolicyRefreshInfo( TRUE, szUserSid, pInfo );
}

USERENVAPI
DWORD
WINAPI
GetNextFgPolicyRefreshInfo( LPWSTR szUserSid,
                                 FgPolicyRefreshInfo* pInfo )
{
    return gpGetFgPolicyRefreshInfo( FALSE, szUserSid, pInfo );
}

USERENVAPI
DWORD
WINAPI
GetCurrentFgPolicyRefreshInfo(  LPWSTR szUserSid,
                                      FgPolicyRefreshInfo* pInfo )
{
    return gpGetFgPolicyRefreshInfo( FALSE, szUserSid, pInfo );
}

USERENVAPI
DWORD
WINAPI
SetPreviousFgPolicyRefreshInfo( LPWSTR szUserSid,
                                      FgPolicyRefreshInfo info )

{
    return gpSetFgPolicyRefreshInfo( TRUE, szUserSid, info );
}

USERENVAPI
DWORD
WINAPI
SetNextFgPolicyRefreshInfo( LPWSTR szUserSid,
                                 FgPolicyRefreshInfo info )
{
    return gpSetFgPolicyRefreshInfo( FALSE, szUserSid, info );
}

USERENVAPI
DWORD
WINAPI
ForceSyncFgPolicy( LPWSTR szUserSid )
{
    FgPolicyRefreshInfo info = { GP_ReasonSyncForced, GP_ModeSyncForeground };
    return gpSetFgPolicyRefreshInfo( FALSE, szUserSid, info );
}

USERENVAPI
BOOL
WINAPI
IsSyncForegroundPolicyRefresh(   BOOL bMachine,
                                        HANDLE hToken )
{
    BOOL    bSyncRefresh;
    DWORD   dwError = ERROR_SUCCESS;

    bSyncRefresh = GetFgPolicySetting( HKEY_LOCAL_MACHINE );
    if ( bSyncRefresh )
    {
        //
        // policy sez sync
        //
        DebugMsg( ( DM_VERBOSE, L"IsSyncForegroundPolicyRefresh: Synchronous, Reason: policy set to SYNC" ) );

        return TRUE;
    }

    LPWSTR szSid = !bMachine ? GetSidString( hToken ) : 0;
    FgPolicyRefreshInfo info;
    
    dwError = GetCurrentFgPolicyRefreshInfo( szSid, &info );

    if ( szSid )
    {
        DeleteSidString( szSid );
    }

    if ( dwError != ERROR_SUCCESS )
    {
        //
        // error reading the refresh mode, treat as sync
        //
        DebugMsg( ( DM_VERBOSE, L"IsSyncForegroundPolicyRefresh: Synchronous, Reason: Error 0x%x ", dwError ) );

        return TRUE;
    }

    bSyncRefresh = ( info.mode == GP_ModeAsyncForeground ) ? FALSE : TRUE;

    DebugMsg( ( DM_VERBOSE,
                L"IsSyncForegroundPolicyRefresh: %s, Reason: %s",
                g_szModes[info.mode % ARRAYSIZE( g_szModes )],
                g_szReasons[info.reason % ARRAYSIZE( g_szReasons )] ) );

    return bSyncRefresh;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\policy\gpreg.cpp ===
//*************************************************************
//
//  Group Policy Support for registry policies
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//*************************************************************

#include "gphdr.h"


//*************************************************************
//
//  DeleteRegistryValue()
//
//  Purpose:    Callback from ParseRegistryFile that deletes
//              registry policies
//
//  Parameters: lpGPOInfo   -  GPO Information
//              lpKeyName   -  Key name
//              lpValueName -  Value name
//              dwType      -  Registry data type
//              lpData      -  Registry data
//              pwszGPO     -   Gpo
//              pwszSOM     -   Sdou that the Gpo is linked to
//              pHashTable  -   Hash table for registry keys
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL DeleteRegistryValue (LPGPOINFO lpGPOInfo, LPTSTR lpKeyName,
                          LPTSTR lpValueName, DWORD dwType,
                          DWORD dwDataLength, LPBYTE lpData,
                          WCHAR *pwszGPO,
                          WCHAR *pwszSOM, REGHASHTABLE *pHashTable)
{
    DWORD dwDisp;
    HKEY hSubKey;
    LONG lResult;
    INT iStrLen;
    TCHAR szPolicies1[] = TEXT("Software\\Policies");
    TCHAR szPolicies2[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies");
    XLastError xe;


    //
    // Check if there is a keyname
    //

    if (!lpKeyName || !(*lpKeyName)) {
        return TRUE;
    }


    //
    // Check if the key is in one of the policies keys
    //

    iStrLen = lstrlen(szPolicies1);
    if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE, szPolicies1,
                       iStrLen, lpKeyName, iStrLen) != CSTR_EQUAL) {

        iStrLen = lstrlen(szPolicies2);
        if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE, szPolicies2,
                           iStrLen, lpKeyName, iStrLen) != CSTR_EQUAL) {
            return TRUE;
        }
    }


    //
    // Check if the value name starts with **
    //

    if (lpValueName && (lstrlen(lpValueName) > 1)) {

        if ( (*lpValueName == TEXT('*')) && (*(lpValueName+1) == TEXT('*')) ) {
            return TRUE;
        }
    }


    //
    // We found a value that needs to be deleted
    //

    if (RegCleanUpValue (lpGPOInfo->hKeyRoot, lpKeyName, lpValueName)) {
        DebugMsg((DM_VERBOSE, TEXT("DeleteRegistryValue: Deleted %s\\%s"),
                 lpKeyName, lpValueName));
    } else {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("DeleteRegistryValue: Failed to delete %s\\%s"),
                 lpKeyName, lpValueName));
        return FALSE;
    }


    return TRUE;
}


//*************************************************************
//
//  ResetPolicies()
//
//  Purpose:    Resets the Policies and old Policies key to their
//              original state.
//
//  Parameters: lpGPOInfo   -   GPT information
//              lpArchive   -   Name of archive file
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ResetPolicies (LPGPOINFO lpGPOInfo, LPTSTR lpArchive)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp, dwValue = 0x91;
    XLastError xe;


    DebugMsg((DM_VERBOSE, TEXT("ResetPolicies: Entering.")));


    //
    // Parse the archive file and delete any policies
    //

    if (!ParseRegistryFile (lpGPOInfo, lpArchive,
                            DeleteRegistryValue, NULL, NULL, NULL, NULL, FALSE  )) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ResetPolicies: Leaving")));
        return FALSE;
    }


    //
    // Recreate the new policies key
    //

    lResult = RegCreateKeyEx (lpGPOInfo->hKeyRoot,
                              TEXT("Software\\Policies"),
                              0, NULL, REG_OPTION_NON_VOLATILE,
                              KEY_WRITE, NULL, &hKey, &dwDisp);

    if (lResult == ERROR_SUCCESS) {

        //
        // Re-apply security
        //

        RegCloseKey (hKey);

        if (!MakeRegKeySecure((lpGPOInfo->dwFlags & GP_MACHINE) ? NULL : lpGPOInfo->hToken,
                              lpGPOInfo->hKeyRoot,
                              TEXT("Software\\Policies"))) {
            DebugMsg((DM_WARNING, TEXT("ResetPolicies: Failed to secure reg key.")));
        }

    } else {
        DebugMsg((DM_WARNING, TEXT("ResetPolicies: Failed to create reg key with %d."), lResult));
    }


    //
    // Recreate the old policies key
    //

    lResult = RegCreateKeyEx (lpGPOInfo->hKeyRoot,
                              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies"),
                              0, NULL, REG_OPTION_NON_VOLATILE,
                              KEY_WRITE, NULL, &hKey, &dwDisp);

    if (lResult == ERROR_SUCCESS) {

        //
        // Re-apply security
        //

        RegCloseKey (hKey);

        if (!MakeRegKeySecure((lpGPOInfo->dwFlags & GP_MACHINE) ? NULL : lpGPOInfo->hToken,
                              lpGPOInfo->hKeyRoot,
                              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies"))) {
            DebugMsg((DM_WARNING, TEXT("ResetPolicies: Failed to secure reg key.")));
        }

    } else {
        DebugMsg((DM_WARNING, TEXT("ResetPolicies: Failed to create reg key with %d."), lResult));
    }


    //
    // If this is user policy, reset the NoDriveTypeAutoRun default value
    //

    if (!(lpGPOInfo->dwFlags & GP_MACHINE)) {


        if (RegCreateKeyEx (lpGPOInfo->hKeyRoot,
                          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"),
                          0, NULL, REG_OPTION_NON_VOLATILE,
                          KEY_WRITE, NULL, &hKey, &dwDisp) == ERROR_SUCCESS) {

            RegSetValueEx (hKey, TEXT("NoDriveTypeAutoRun"), 0,
                           REG_DWORD, (LPBYTE) &dwValue, sizeof(dwValue));

            RegCloseKey (hKey);
        }
    }

    DebugMsg((DM_VERBOSE, TEXT("ResetPolicies: Leaving.")));

    return TRUE;
}




//*************************************************************
//
//  ArchiveRegistryValue()
//
//  Purpose:    Archives a registry value in the specified file
//
//  Parameters: hFile - File handle of archive file
//              lpKeyName    -  Key name
//              lpValueName  -  Value name
//              dwType       -  Registry value type
//              dwDataLength -  Registry value size
//              lpData       -  Registry value
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ArchiveRegistryValue(HANDLE hFile, LPWSTR lpKeyName,
                          LPWSTR lpValueName, DWORD dwType,
                          DWORD dwDataLength, LPBYTE lpData)
{
    BOOL bResult = FALSE;
    DWORD dwBytesWritten;
    DWORD dwTemp;
    const WCHAR cOpenBracket = L'[';
    const WCHAR cCloseBracket = L']';
    const WCHAR cSemiColon = L';';
    XLastError xe;


    //
    // Write the entry to the text file.
    //
    // Format:
    //
    // [keyname;valuename;type;datalength;data]
    //

    // open bracket
    if (!WriteFile (hFile, &cOpenBracket, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write open bracket with %d"),
                 GetLastError()));
        goto Exit;
    }


    // key name
    dwTemp = (lstrlen (lpKeyName) + 1) * sizeof (WCHAR);
    if (!WriteFile (hFile, lpKeyName, dwTemp, &dwBytesWritten, NULL) ||
        dwBytesWritten != dwTemp)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write key name with %d"),
                 GetLastError()));
        goto Exit;
    }


    // semicolon
    if (!WriteFile (hFile, &cSemiColon, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write semicolon with %d"),
                 GetLastError()));
        goto Exit;
    }

    // value name
    dwTemp = (lstrlen (lpValueName) + 1) * sizeof (WCHAR);
    if (!WriteFile (hFile, lpValueName, dwTemp, &dwBytesWritten, NULL) ||
        dwBytesWritten != dwTemp)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write value name with %d"),
                 GetLastError()));
        goto Exit;
    }


    // semicolon
    if (!WriteFile (hFile, &cSemiColon, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write semicolon with %d"),
                 GetLastError()));
        goto Exit;
    }

    // type
    if (!WriteFile (hFile, &dwType, sizeof(DWORD), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(DWORD))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write data type with %d"),
                 GetLastError()));
        goto Exit;
    }

    // semicolon
    if (!WriteFile (hFile, &cSemiColon, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write semicolon with %d"),
                 GetLastError()));
        goto Exit;
    }

    // data length
    if (!WriteFile (hFile, &dwDataLength, sizeof(DWORD), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(DWORD))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write data type with %d"),
                 GetLastError()));
        goto Exit;
    }

    // semicolon
    if (!WriteFile (hFile, &cSemiColon, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write semicolon with %d"),
                 GetLastError()));
        goto Exit;
    }

    // data
    if (!WriteFile (hFile, lpData, dwDataLength, &dwBytesWritten, NULL) ||
        dwBytesWritten != dwDataLength)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write data with %d"),
                 GetLastError()));
        goto Exit;
    }

    // close bracket
    if (!WriteFile (hFile, &cCloseBracket, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write close bracket with %d"),
                 GetLastError()));
        goto Exit;
    }


    //
    // Sucess
    //

    bResult = TRUE;

Exit:

    return bResult;
}


//*************************************************************
//
//  ParseRegistryFile()
//
//  Purpose:    Parses a registry.pol file
//
//  Parameters: lpGPOInfo          -   GPO information
//              lpRegistry         -   Path to registry.pol
//              pfnRegFileCallback -   Callback function
//              hArchive           -   Handle to archive file
//              pwszGPO            -   Gpo
//              pwszSOM            -   Sdou that the Gpo is linked to
//              pHashTable         -   Hash table for registry keys
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ParseRegistryFile (LPGPOINFO lpGPOInfo, LPTSTR lpRegistry,
                        PFNREGFILECALLBACK pfnRegFileCallback,
                        HANDLE hArchive, WCHAR *pwszGPO,
                        WCHAR *pwszSOM, REGHASHTABLE *pHashTable,
                        BOOL bRsopPlanningMode)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    BOOL bResult = FALSE;
    DWORD dwTemp, dwBytesRead, dwType, dwDataLength;
    LPWSTR lpKeyName = 0, lpValueName = 0, lpTemp;
    LPBYTE lpData = NULL;
    WCHAR  chTemp;
    HANDLE hOldToken;
    XLastError xe;


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ParseRegistryFile: Entering with <%s>."),
             lpRegistry));


    //
    // Open the registry file
    //

    if(!bRsopPlanningMode) {
        if (!ImpersonateUser(lpGPOInfo->hToken, &hOldToken)) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to impersonate user")));
            goto Exit;
        }
    }

    hFile = CreateFile (lpRegistry, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);

    if(!bRsopPlanningMode) {
        RevertToUser(&hOldToken);
    }

    if (hFile == INVALID_HANDLE_VALUE) {
        if ((GetLastError() == ERROR_FILE_NOT_FOUND) ||
            (GetLastError() == ERROR_PATH_NOT_FOUND))
        {
            bResult = TRUE;
            goto Exit;
        }
        else
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: CreateFile failed with %d"),
                     GetLastError()));
            CEvents ev(TRUE, EVENT_NO_REGISTRY);
            ev.AddArg(lpRegistry); ev.AddArgWin32Error(GetLastError()); ev.Report();
            goto Exit;
        }
    }


    //
    // Allocate buffers to hold the keyname, valuename, and data
    //

    lpKeyName = (LPWSTR) LocalAlloc (LPTR, MAX_KEYNAME_SIZE * sizeof(WCHAR));

    if (!lpKeyName)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to allocate memory with %d"),
                 GetLastError()));
        goto Exit;
    }


    lpValueName = (LPWSTR) LocalAlloc (LPTR, MAX_VALUENAME_SIZE * sizeof(WCHAR));

    if (!lpValueName)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to allocate memory with %d"),
                 GetLastError()));
        goto Exit;
    }


    //
    // Read the header block
    //
    // 2 DWORDS, signature (PReg) and version number and 2 newlines
    //

    if (!ReadFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(dwTemp))
    {
        xe = ERROR_INVALID_DATA;
        DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read signature with %d"),
                 GetLastError()));
        goto Exit;
    }


    if (dwTemp != REGFILE_SIGNATURE)
    {
        xe = ERROR_INVALID_DATA;
        DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Invalid file signature")));
        goto Exit;
    }


    if (!ReadFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(dwTemp))
    {
        xe = ERROR_INVALID_DATA;
        DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read version number with %d"),
                 GetLastError()));
        goto Exit;
    }

    if (dwTemp != REGISTRY_FILE_VERSION)
    {
        xe = ERROR_INVALID_DATA;
        DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Invalid file version")));
        goto Exit;
    }


    //
    // Read the data
    //

    while (TRUE)
    {

        //
        // Read the first character.  It will either be a [ or the end
        // of the file.
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                xe = ERROR_INVALID_DATA;
                DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read first character with %d"),
                         GetLastError()));
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L'['))
        {
            break;
        }


        //
        // Read the keyname
        //

        lpTemp = lpKeyName;
        dwTemp = 0;

        while (dwTemp < MAX_KEYNAME_SIZE)
        {

            if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
            {
                xe = ERROR_INVALID_DATA;
                DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read keyname character with %d"),
                         GetLastError()));
                goto Exit;
            }

            *lpTemp++ = chTemp;

            if (chTemp == TEXT('\0'))
                break;

            dwTemp++;
        }

        if (dwTemp >= MAX_KEYNAME_SIZE)
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Keyname exceeded max size")));
            goto Exit;
        }


        //
        // Read the semi-colon
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                xe = ERROR_INVALID_DATA;
                DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read first character with %d"),
                         GetLastError()));
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L';'))
        {
            break;
        }


        //
        // Read the valuename
        //

        lpTemp = lpValueName;
        dwTemp = 0;

        while (dwTemp < MAX_VALUENAME_SIZE)
        {

            if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
            {
                xe = ERROR_INVALID_DATA;
                DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read valuename character with %d"),
                         GetLastError()));
                goto Exit;
            }

            *lpTemp++ = chTemp;

            if (chTemp == TEXT('\0'))
                break;

            dwTemp++;
        }

        if (dwTemp >= MAX_VALUENAME_SIZE)
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Valuename exceeded max size")));
            goto Exit;
        }


        //
        // Read the semi-colon
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                xe = ERROR_INVALID_DATA;
                DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read first character with %d"),
                         GetLastError()));
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L';'))
        {
            break;
        }


        //
        // Read the type
        //

        if (!ReadFile (hFile, &dwType, sizeof(DWORD), &dwBytesRead, NULL))
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read type with %d"),
                     GetLastError()));
            goto Exit;
        }


        //
        // Skip semicolon
        //

        if (!ReadFile (hFile, &dwTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to skip semicolon with %d"),
                     GetLastError()));
            goto Exit;
        }


        //
        // Read the data length
        //

        if (!ReadFile (hFile, &dwDataLength, sizeof(DWORD), &dwBytesRead, NULL))
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to data length with %d"),
                     GetLastError()));
            goto Exit;
        }


        //
        // Skip semicolon
        //

        if (!ReadFile (hFile, &dwTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to skip semicolon with %d"),
                     GetLastError()));
            goto Exit;
        }


        //
        // Allocate memory for data
        //

        lpData = (LPBYTE) LocalAlloc (LPTR, dwDataLength);

        if (!lpData)
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to allocate memory for data with %d"),
                     GetLastError()));
            goto Exit;
        }


        //
        // Read data
        //

        if (!ReadFile (hFile, lpData, dwDataLength, &dwBytesRead, NULL))
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read data with %d"),
                     GetLastError()));
            goto Exit;
        }


        //
        // Skip closing bracket
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to skip closing bracket with %d"),
                     GetLastError()));
            goto Exit;
        }

        if (chTemp != L']')
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Expected to find ], but found %c"),
                     chTemp));
            goto Exit;
        }


        //
        // Call the callback function
        //

        if (!pfnRegFileCallback (lpGPOInfo, lpKeyName, lpValueName,
                                 dwType, dwDataLength, lpData,
                                 pwszGPO, pwszSOM, pHashTable ))
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Callback function returned false.")));
            goto Exit;
        }


        //
        // Archive the data if appropriate
        //

        if (hArchive) {
            if (!ArchiveRegistryValue(hArchive, lpKeyName, lpValueName,
                                      dwType, dwDataLength, lpData)) {
                DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: ArchiveRegistryValue returned false.")));
            }
        }

        LocalFree (lpData);
        lpData = NULL;

    }

    bResult = TRUE;

Exit:

    //
    // Finished
    //

    if ( !bResult )
    {
        CEvents ev(TRUE, EVENT_REGISTRY_TEMPLATE_ERROR);
        ev.AddArg(lpRegistry ? lpRegistry : TEXT("")); ev.AddArgWin32Error( xe ); ev.Report();
    }

    DebugMsg((DM_VERBOSE, TEXT("ParseRegistryFile: Leaving.")));
    if (lpData) {
        LocalFree (lpData);
    }
    if ( hFile != INVALID_HANDLE_VALUE ) {
        CloseHandle (hFile);
    }
    if ( lpKeyName ) {
        LocalFree (lpKeyName);
    }
    if ( lpValueName ) {
        LocalFree (lpValueName);
    }

    return bResult;
}


//*************************************************************
//
//  ProcessRegistryValue()
//
//  Purpose: Callback passed to ParseRegistryFile from ProcessRegistryFiles. Invokes AddRegHashEntry
//                  with appropriate parameters depending on the registry policy settings.
//
//  Parameters:
//                          pUnused -    Not used. It si there only to conform to the signature
//                                              expected by ParseRegistryFile.
//                          lpKeyName - registry key name
//                          lpValueName - Registry value name
//                          dwType -    Registry value type
//                          dwDataLength - Length of registry value data.
//                          lpData - Regsitry value data
//                          *pwszGPO - GPO associated with this registry setting
//                          *pwszSOM - SOM associated with the GPO
//                          *pHashTable - Hash table containing registry policy data for a policy target.
//
//  Return:     TRUE if successful
//                  FALSE if an error occurs
//
//*************************************************************

BOOL ProcessRegistryValue (   void* pUnused,
                                    LPTSTR lpKeyName,
                                    LPTSTR lpValueName,
                                    DWORD dwType,
                                    DWORD dwDataLength,
                                    LPBYTE lpData,
                                    WCHAR *pwszGPO,
                                    WCHAR *pwszSOM,
                                    REGHASHTABLE *pHashTable)
{
    BOOL bLoggingOk = TRUE;

    //
    // Special case some values
    //

    if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       TEXT("**del."), 6, lpValueName, 6) == 2)
    {
        LPTSTR lpRealValueName = lpValueName + 6;


        //
        // Delete one specific value
        //

        bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEVALUE, lpKeyName,
                                      lpRealValueName, 0, 0, NULL,
                                      pwszGPO, pwszSOM, lpValueName, TRUE );
    }
    else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       TEXT("**delvals."), 10, lpValueName, 10) == 2)
    {

        //
        // Delete all values in the destination key
        //

        bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEALLVALUES, lpKeyName,
                                      NULL, 0, 0, NULL,
                                      pwszGPO, pwszSOM, lpValueName, TRUE );

    }
    else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       TEXT("**DeleteValues"), 14, lpValueName, 14) == 2)
    {
        TCHAR szValueName[MAX_PATH];
        LPTSTR lpName, lpNameTemp;

        lpName = (LPTSTR)lpData;

        while (*lpName) {

            lpNameTemp = szValueName;

            while (*lpName && *lpName == TEXT(' ')) {
                lpName++;
            }

            while (*lpName && *lpName != TEXT(';')) {
                *lpNameTemp++ = *lpName++;
            }

            *lpNameTemp= TEXT('\0');

            while (*lpName == TEXT(';')) {
                lpName++;
            }


            bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEVALUE, lpKeyName,
                                          szValueName, 0, 0, NULL,
                                          pwszGPO, pwszSOM, lpValueName, TRUE );
        }
    }

    else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       TEXT("**DeleteKeys"), 12, lpValueName, 12) == 2)
    {
        TCHAR szKeyName[MAX_KEYNAME_SIZE];
        LPTSTR lpName, lpNameTemp, lpEnd;

        lpName = (LPTSTR)lpData;

        while (*lpName) {

            szKeyName[0] = TEXT('\0');
            lpNameTemp = szKeyName;

            while (*lpName && *lpName == TEXT(' ')) {
                lpName++;
            }

            while (*lpName && *lpName != TEXT(';')) {
                *lpNameTemp++ = *lpName++;
            }

            *lpNameTemp= TEXT('\0');

            while (*lpName == TEXT(';')) {
                lpName++;
            }

            bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEKEY, lpKeyName,
                                          NULL, 0, 0, NULL,
                                          pwszGPO, pwszSOM, lpValueName, TRUE );
        }
    }
    else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       TEXT("**soft."), 7, lpValueName, 7) == 2)
    {
        //
        // In planning mode we will assume the value does not exist in the target computer.
        // Therefore, we set it if no value exists in the hash table.
        //
        // Soft add is dealt with differently in planning mode vs. diag mode.
        // In diag mode, check is done while processing policy and it is logged as a add value
        // if the key doesn't exist.
        // In planning mode, key is not supposed to exist beforehand and the hash table itself is
        // used to determine whether to add the key or not.


        LPTSTR lpRealValueName = lpValueName + 7;

        bLoggingOk = AddRegHashEntry( pHashTable, REG_SOFTADDVALUE, lpKeyName,
                                      lpRealValueName, dwType, dwDataLength, lpData,
                                      pwszGPO, pwszSOM, lpValueName, TRUE );

    }
    else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       TEXT("**SecureKey"), 11, lpValueName, 11) == 2)
    {
        // There is nothing to do here.
    } else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       TEXT("**Comment:"), 10, lpValueName, 10) == 2)
    {
        //
        // Comment - can be ignored
        //
    }
    else
    {

        //
        // AddRegHashEntry needs to log a key being logged but no values.
        //

        bLoggingOk = AddRegHashEntry( pHashTable, REG_ADDVALUE, lpKeyName,
                                      lpValueName, dwType, dwDataLength, lpData,
                                      pwszGPO, pwszSOM, TEXT(""), TRUE );
    }

    return bLoggingOk;
}


//*************************************************************
//
//  ResetRegKeySecurity
//
//  Purpose:    Resets the security on a user's key
//
//  Parameters: hKeyRoot    -   Handle to the root of the hive
//              lpKeyName   -   Subkey name
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ResetRegKeySecurity (HKEY hKeyRoot, LPTSTR lpKeyName)
{
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwSize = 0;
    LONG lResult;
    HKEY hSubKey;
    XLastError xe;


    RegGetKeySecurity(hKeyRoot, DACL_SECURITY_INFORMATION, pSD, &dwSize);

    if (!dwSize) {
       DebugMsg((DM_WARNING, TEXT("ResetRegKeySecurity: RegGetKeySecurity returned 0")));
       return FALSE;
    }

    pSD = LocalAlloc (LPTR, dwSize);

    if (!pSD) {
       xe = GetLastError();
       DebugMsg((DM_WARNING, TEXT("ResetRegKeySecurity: Failed to allocate memory")));
       return FALSE;
    }


    lResult = RegGetKeySecurity(hKeyRoot, DACL_SECURITY_INFORMATION, pSD, &dwSize);
    if (lResult != ERROR_SUCCESS) {
        xe = GetLastError();
       DebugMsg((DM_WARNING, TEXT("ResetRegKeySecurity: Failed to query key security with %d"),
                lResult));
       LocalFree (pSD);
       return FALSE;
    }


    lResult = RegOpenKeyEx(hKeyRoot,
                         lpKeyName,
                         0,
                         WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                         &hSubKey);

    if (lResult != ERROR_SUCCESS) {
       xe = GetLastError();
       DebugMsg((DM_WARNING, TEXT("ResetRegKeySecurity: Failed to open sub key with %d"),
                lResult));
       LocalFree (pSD);
       return FALSE;
    }

    lResult = RegSetKeySecurity (hSubKey, DACL_SECURITY_INFORMATION, pSD);

    RegCloseKey (hSubKey);
    LocalFree (pSD);

    if (lResult != ERROR_SUCCESS) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ResetRegKeySecure: Failed to set security, error = %d"), lResult));
        return FALSE;
    }

    return TRUE;

}


//*************************************************************
//
//  SetRegistryValue()
//
//  Purpose:    Callback from ParseRegistryFile that sets
//              registry policies
//
//  Parameters: lpGPOInfo   -  GPO Information
//              lpKeyName   -  Key name
//              lpValueName -  Value name
//              dwType      -  Registry data type
//              lpData      -  Registry data
//              pwszGPO     -   Gpo
//              pwszSOM     -   Sdou that the Gpo is linked to
//              pHashTable  -   Hash table for registry keys
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL SetRegistryValue (LPGPOINFO lpGPOInfo, LPTSTR lpKeyName,
                       LPTSTR lpValueName, DWORD dwType,
                       DWORD dwDataLength, LPBYTE lpData,
                       WCHAR *pwszGPO,
                       WCHAR *pwszSOM, REGHASHTABLE *pHashTable)
{
    DWORD dwDisp;
    HKEY hSubKey;
    LONG lResult;
    BOOL bLoggingOk = TRUE;
    BOOL bRsopLogging = (pHashTable != NULL);  // Is diagnostic mode Rsop logging enabled ?
    BOOL bUseValueName = FALSE;
    BOOL bRegOpSuccess =  TRUE;
    XLastError xe;
    
    //
    // Special case some values
    //
    if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       TEXT("**del."), 6, lpValueName, 6) == 2)
    {
        LPTSTR lpRealValueName = lpValueName + 6;

        //
        // Delete one specific value
        //

        lResult = RegOpenKeyEx (lpGPOInfo->hKeyRoot,
                        lpKeyName, 0, KEY_WRITE, &hSubKey);

        if (lResult == ERROR_SUCCESS)
        {
            lResult = RegDeleteValue(hSubKey, lpRealValueName);

            if ((lResult == ERROR_SUCCESS) || (lResult == ERROR_FILE_NOT_FOUND))
            {
                DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: Deleted value <%s>."),
                         lpRealValueName));
                if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                    CEvents ev(FALSE, EVENT_DELETED_VALUE);
                    ev.AddArg(lpRealValueName); ev.Report();
                }

                if ( bRsopLogging ) {
                    bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEVALUE, lpKeyName,
                                                  lpRealValueName, 0, 0, NULL,
                                                  pwszGPO, pwszSOM, lpValueName, TRUE );
                    if (!bLoggingOk) {
                        DebugMsg((DM_WARNING, TEXT("SetRegistryValue: AddRegHashEntry failed for REG_DELETEVALUE <%s>."), lpRealValueName));
                        pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("SetRegistryValue: Failed to delete value <%s> with %d"),
                         lpRealValueName, lResult));
                xe = lResult;
                CEvents ev(TRUE, EVENT_FAIL_DELETE_VALUE);
                ev.AddArg(lpRealValueName); ev.AddArgWin32Error(lResult); ev.Report();
                bRegOpSuccess = FALSE;
            }

            RegCloseKey (hSubKey);
        }
        else if (lResult == ERROR_FILE_NOT_FOUND) {
            
            //
            // Log into rsop even if the key is not found
            //

            if ( bRsopLogging ) {
                bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEVALUE, lpKeyName,
                                              lpRealValueName, 0, 0, NULL,
                                              pwszGPO, pwszSOM, lpValueName, TRUE );
                if (!bLoggingOk) {
                    pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
                    DebugMsg((DM_WARNING, TEXT("SetRegistryValue: AddRegHashEntry failed for REG_DELETEVALUE (notfound) <%s>."), lpRealValueName));
                }
            }
        }
    }
    else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       TEXT("**delvals."), 10, lpValueName, 10) == 2)
    {

        //
        // Delete all values in the destination key
        //
        lResult = RegOpenKeyEx (lpGPOInfo->hKeyRoot,
                        lpKeyName, 0, KEY_WRITE | KEY_READ, &hSubKey);

        if (lResult == ERROR_SUCCESS)
        {
            if (!bRsopLogging)
                bRegOpSuccess = DeleteAllValues(hSubKey);
            else
                bRegOpSuccess = RsopDeleteAllValues(hSubKey, pHashTable, lpKeyName,
                                              pwszGPO, pwszSOM, lpValueName, &bLoggingOk );

            DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: Deleted all values in <%s>."),
                     lpKeyName));
            RegCloseKey (hSubKey);

            if (!bRegOpSuccess) {
                xe = GetLastError();
            }

            DebugMsg((DM_WARNING, TEXT("SetRegistryValue: DeleteAllvalues finished for %s. bRegOpSuccess = %s, bLoggingOk = %s."), 
                      lpKeyName, (bRegOpSuccess ? TEXT("TRUE") : TEXT("FALSE")), (bLoggingOk ? TEXT("TRUE") : TEXT("FALSE"))));

        }
        else if (lResult == ERROR_FILE_NOT_FOUND) {
            
            //
            // Log into rsop even if the key is not found
            // as just deleteallvalues
            //

            if ( bRsopLogging ) {
                bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEALLVALUES, lpKeyName,
                              NULL, 0, 0, NULL,
                              pwszGPO, pwszSOM, lpValueName, TRUE );

                if (!bLoggingOk) {
                    DebugMsg((DM_WARNING, TEXT("SetRegistryValue: AddRegHashEntry failed for REG_DELETEALLVALUES (notfound) key - <%s>, value <%s>."), lpKeyName, lpValueName));
                }
            }
        }
    }
    else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       TEXT("**DeleteValues"), 14, lpValueName, 14) == 2)
    {
        TCHAR szValueName[MAX_PATH];
        LPTSTR lpName, lpNameTemp;
        LONG   lKeyResult;

        //
        // Delete the values  (semi-colon separated)
        //

        lKeyResult = RegOpenKeyEx (lpGPOInfo->hKeyRoot,
                        lpKeyName, 0, KEY_WRITE, &hSubKey);

        lpName = (LPTSTR)lpData;

        while (*lpName) {

            lpNameTemp = szValueName;

            while (*lpName && *lpName == TEXT(' ')) {
                lpName++;
            }

            while (*lpName && *lpName != TEXT(';')) {
                *lpNameTemp++ = *lpName++;
            }

            *lpNameTemp= TEXT('\0');

            while (*lpName == TEXT(';')) {
                lpName++;
            }


            if (lKeyResult == ERROR_SUCCESS)
            {
                lResult = RegDeleteValue (hSubKey, szValueName);

                if ((lResult == ERROR_SUCCESS) || (lResult == ERROR_FILE_NOT_FOUND))
                {
                    DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: Deleted value <%s>."),
                             szValueName));
                    if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                        CEvents ev(FALSE, EVENT_DELETED_VALUE);
                        ev.AddArg(szValueName); ev.Report();
                    }
                    
                    if ( bRsopLogging ) {
                        bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEVALUE, lpKeyName,
                                                      szValueName, 0, 0, NULL,
                                                      pwszGPO, pwszSOM, lpValueName, TRUE );

                        if (!bLoggingOk) {
                            DebugMsg((DM_WARNING, TEXT("SetRegistryValue: AddRegHashEntry failed for REG_DELETEVALUE value <%s>."), szValueName));
                            pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
                        }
                    }
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("SetRegistryValue: Failed to delete value <%s> with %d"),
                             szValueName, lResult));
                    CEvents ev(TRUE, EVENT_FAIL_DELETE_VALUE);
                    ev.AddArg(szValueName); ev.AddArgWin32Error(lResult); ev.Report();
                    xe = lResult;
                    bRegOpSuccess = FALSE;
                }
            }
            else if (lKeyResult == ERROR_FILE_NOT_FOUND) {
                if ( bRsopLogging ) {
                    bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEVALUE, lpKeyName,
                                                  szValueName, 0, 0, NULL,
                                                  pwszGPO, pwszSOM, lpValueName, TRUE );

                    if (!bLoggingOk) {
                        DebugMsg((DM_WARNING, TEXT("SetRegistryValue: AddRegHashEntry failed for REG_DELETEVALUE value (not found case) <%s>."), szValueName));
                        pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
            }
        }


        if (lKeyResult == ERROR_SUCCESS)
        {
            RegCloseKey (hSubKey);
        }
    }
    else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       TEXT("**DeleteKeys"), 12, lpValueName, 12) == 2)
    {
        TCHAR szKeyName[MAX_KEYNAME_SIZE];
        LPTSTR lpName, lpNameTemp, lpEnd;

        //
        // Delete keys
        //

        lpName = (LPTSTR)lpData;

        while (*lpName) {

            szKeyName[0] = TEXT('\0');
            lpNameTemp = szKeyName;

            while (*lpName && *lpName == TEXT(' ')) {
                lpName++;
            }

            while (*lpName && *lpName != TEXT(';')) {
                *lpNameTemp++ = *lpName++;
            }

            *lpNameTemp= TEXT('\0');

            while (*lpName == TEXT(';')) {
                lpName++;
            }


            if (RegDelnode (lpGPOInfo->hKeyRoot,
                        szKeyName))
            {
                DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: Deleted key <%s>."),
                         szKeyName));
                if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                    CEvents ev(FALSE, EVENT_DELETED_KEY);
                    ev.AddArg(szKeyName); ev.Report();
                }
            }
            else
            {
                xe = GetLastError();
                bRegOpSuccess = FALSE;
                DebugMsg((DM_WARNING, TEXT("SetRegistryValue: RegDelnode for key <%s>."), szKeyName));
            }

            if ( bRsopLogging ) {
                bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEKEY, szKeyName,
                                              NULL, 0, 0, NULL,
                                              pwszGPO, pwszSOM, lpValueName, TRUE );
                if (!bLoggingOk) { 
                    DebugMsg((DM_WARNING, TEXT("SetRegistryValue: AddRegHashEntry failed for REG_DELETEKEY  <%s>."), szKeyName));
                    pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
                }
            }

        }

    }
    else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       TEXT("**soft."), 7, lpValueName, 7) == 2)
    {

        //
        // "soft" value, only set this if it doesn't already
        // exist in destination
        //

        lResult = RegOpenKeyEx (lpGPOInfo->hKeyRoot,
                        lpKeyName, 0, KEY_QUERY_VALUE, &hSubKey);

        if (lResult == ERROR_SUCCESS)
        {
            TCHAR TmpValueData[MAX_PATH+1];
            DWORD dwSize=sizeof(TmpValueData);

            lResult = RegQueryValueEx(hSubKey, lpValueName + 7,
                                      NULL,NULL,(LPBYTE) TmpValueData,
                                      &dwSize);

            RegCloseKey (hSubKey);

            if (lResult != ERROR_SUCCESS)
            {
                lpValueName += 7;
                bUseValueName = TRUE;
                goto SetValue;
            }
        }
    }
    else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       TEXT("**SecureKey"), 11, lpValueName, 11) == 2)
    {
        //
        // Secure / unsecure a key (user only)
        //
        if (!(lpGPOInfo->dwFlags & GP_MACHINE))
        {
            if (*((LPDWORD)lpData) == 1)
            {
                DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: Securing key <%s>."),
                         lpKeyName));
                bRegOpSuccess = MakeRegKeySecure(lpGPOInfo->hToken, lpGPOInfo->hKeyRoot, lpKeyName);
            }
            else
            {

                DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: Unsecuring key <%s>."),
                         lpKeyName));

                bRegOpSuccess = ResetRegKeySecurity (lpGPOInfo->hKeyRoot, lpKeyName);
            }

            if (!bRegOpSuccess) {
                xe = GetLastError();
            }
        }
    }
    else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                       TEXT("**Comment:"), 10, lpValueName, 10) == 2)
    {
        //
        // Comment - can be ignored
        //

        DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: Found comment %s."),
                 (lpValueName+10)));
    }
    else
    {
SetValue:
        //
        // Save registry value
        //

        lResult = RegCreateKeyEx (lpGPOInfo->hKeyRoot,
                        lpKeyName, 0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_WRITE, NULL, &hSubKey, &dwDisp);

        if (lResult == ERROR_SUCCESS)
        {

            if ((dwType == REG_NONE) && (dwDataLength == 0) &&
                (*lpValueName == L'\0'))
            {
                lResult = ERROR_SUCCESS;
            }
            else
            {
                lResult = RegSetValueEx (hSubKey, lpValueName, 0, dwType,
                                         lpData, dwDataLength);
            }

            if ( bRsopLogging ) {
                bLoggingOk = AddRegHashEntry( pHashTable, REG_ADDVALUE, lpKeyName,
                                              lpValueName, dwType, dwDataLength, lpData,
                                              pwszGPO, pwszSOM, bUseValueName ? lpValueName : TEXT(""), TRUE );
                if (!bLoggingOk) {
                    DebugMsg((DM_WARNING, TEXT("SetRegistryValue: AddRegHashEntry failed for REG_ADDVALUE key <%s>, value <%s>."), lpKeyName, lpValueName));
                    pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
                }
            }


            RegCloseKey (hSubKey);

            if (lResult == ERROR_SUCCESS)
            {
                switch (dwType) {
                    case REG_SZ:
                    case REG_EXPAND_SZ:
                        DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: %s => %s  [OK]"),
                                 lpValueName, (LPTSTR)lpData));
                        if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                            CEvents ev(FALSE, EVENT_SET_STRING_VALUE);
                            ev.AddArg(lpValueName); ev.AddArg((LPTSTR)lpData); ev.Report();
                        }

                        break;

                    case REG_DWORD:
                        DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: %s => %d  [OK]"),
                                 lpValueName, *((LPDWORD)lpData)));
                        if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                            CEvents ev(FALSE, EVENT_SET_DWORD_VALUE);
                            ev.AddArg(lpValueName); ev.AddArg((DWORD)*lpData); ev.Report();
                        }

                        break;

                    case REG_NONE:
                        break;

                    default:
                        DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: %s was set successfully"),
                                 lpValueName));
                        if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                            CEvents ev(FALSE, EVENT_SET_UNKNOWN_VALUE);
                            ev.AddArg(lpValueName); ev.Report();
                        }
                        break;
                }


                if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                   TEXT("Control Panel\\Colors"), 20, lpKeyName, 20) == 2) {
                    lpGPOInfo->dwFlags |= GP_REGPOLICY_CPANEL;

                } else if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                   TEXT("Control Panel\\Desktop"), 21, lpKeyName, 21) == 2) {
                    lpGPOInfo->dwFlags |= GP_REGPOLICY_CPANEL;
                }


            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("SetRegistryValue: Failed to set value <%s> with %d"),
                         lpValueName, lResult));
                xe = lResult;
                CEvents ev(TRUE, EVENT_FAILED_SET);
                ev.AddArg(lpValueName); ev.AddArgWin32Error(lResult); ev.Report();
                bRegOpSuccess = FALSE;
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("SetRegistryValue: Failed to open key <%s> with %d"),
                     lpKeyName, lResult));
            xe = lResult;
            CEvents ev(TRUE, EVENT_FAILED_CREATE);
            ev.AddArg(lpKeyName); ev.AddArgWin32Error(lResult); ev.Report();
            bRegOpSuccess = FALSE;
        }
    }

    return bLoggingOk && bRegOpSuccess;
}


//*************************************************************
//
//  ProcessGPORegistryPolicy()
//
//  Purpose:    Proceses GPO registry policy
//
//  Parameters: lpGPOInfo       -   GPO information
//              pChangedGPOList - Link list of changed GPOs
//
//  Notes:      This function is called in the context of
//              local system, which allows us to create the
//              directory, write to the file etc.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ProcessGPORegistryPolicy (LPGPOINFO lpGPOInfo,
                               PGROUP_POLICY_OBJECT pChangedGPOList, HRESULT *phrRsopLogging)
{
    PGROUP_POLICY_OBJECT lpGPO;
    TCHAR szPath[MAX_PATH];
    TCHAR szBuffer[MAX_PATH];
    TCHAR szKeyName[100];
    LPTSTR lpEnd, lpGPOComment;
    HANDLE hFile;
    DWORD dwTemp, dwBytesWritten;
    REGHASHTABLE *pHashTable = NULL;
    WIN32_FIND_DATA findData;
    ADMFILEINFO *pAdmFileCache = NULL;
    XLastError xe;

    //
    // Get the path name to the appropriate profile
    //

    *phrRsopLogging = S_OK;

    szPath[0] = TEXT('\0');
    dwTemp = ARRAYSIZE(szPath);

    if (lpGPOInfo->dwFlags & GP_MACHINE) {
        GetAllUsersProfileDirectoryEx(szPath, &dwTemp, TRUE);
    } else {
        GetUserProfileDirectory(lpGPOInfo->hToken, szPath, &dwTemp);
    }

    if (szPath[0] == TEXT('\0')) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: Failed to get path to profile root")));
        return FALSE;
    }


    //
    // Tack on the archive file name
    //

    DmAssert( lstrlen(szPath) + lstrlen(TEXT("\\ntuser.pol")) < MAX_PATH );

    lstrcat (szPath, TEXT("\\ntuser.pol"));


    //
    // Delete any existing policies
    //

    if (!ResetPolicies (lpGPOInfo, szPath)) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: ResetPolicies failed.")));
        return FALSE;
    }


    //
    // Delete the old archive file
    //

    SetFileAttributes (szPath, FILE_ATTRIBUTE_NORMAL);
    DeleteFile (szPath);


    //
    // Recreate the archive file
    //

    hFile = CreateFile (szPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                        FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: Failed to create archive file with %d"),
                 GetLastError()));
        return FALSE;
    }

    //
    // Set the header information in the archive file
    //

    dwTemp = REGFILE_SIGNATURE;

    if (!WriteFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(dwTemp))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: Failed to write signature with %d"),
                 GetLastError()));
        CloseHandle (hFile);
        return FALSE;
    }


    dwTemp = REGISTRY_FILE_VERSION;

    if (!WriteFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(dwTemp))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: Failed to write version number with %d"),
                 GetLastError()));
        CloseHandle (hFile);
        return FALSE;
    }

    if ( lpGPOInfo->pWbemServices ) {

        //
        // If Rsop logging is enabled, setup hash table
        //

        pHashTable = AllocHashTable();
        if ( pHashTable == NULL ) {
            CloseHandle (hFile);
            *phrRsopLogging = HRESULT_FROM_WIN32(GetLastError());
            xe = GetLastError();
            return FALSE;
        }

    }

    //
    // Now loop through the GPOs applying the registry.pol files
    //

    lpGPO = pChangedGPOList;

    while ( lpGPO ) {

        //
        // Add the source GPO comment
        //

        lpGPOComment = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpGPO->lpDisplayName) + 25) * sizeof(TCHAR));

        if (lpGPOComment) {

            lstrcpy (szKeyName, TEXT("Software\\Policies\\Microsoft\\Windows\\Group Policy Objects\\"));
            lstrcat (szKeyName, lpGPO->szGPOName);

            lstrcpy (lpGPOComment, TEXT("**Comment:GPO Name: "));
            lstrcat (lpGPOComment, lpGPO->lpDisplayName);

            if (!ArchiveRegistryValue(hFile, szKeyName, lpGPOComment, REG_SZ, 0, NULL)) {
                DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: ArchiveRegistryValue returned false.")));
            }

            LocalFree (lpGPOComment);
        }


        //
        // Build the path to registry.pol
        //

        DmAssert( lstrlen(lpGPO->lpFileSysPath) + lstrlen(c_szRegistryPol) + 1 < MAX_PATH );

        lstrcpy (szBuffer, lpGPO->lpFileSysPath);
        lpEnd = CheckSlash (szBuffer);
        lstrcpy (lpEnd, c_szRegistryPol);

        if (!ParseRegistryFile (lpGPOInfo, szBuffer, SetRegistryValue, hFile,
                                lpGPO->lpDSPath, lpGPO->lpLink, pHashTable, FALSE )) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: ParseRegistryFile failed.")));
            CloseHandle (hFile);
            FreeHashTable( pHashTable );
            // no logging is done in any case
            return FALSE;
        }

        if ( lpGPOInfo->pWbemServices ) {

            //
            // Log Adm data
            //

            HANDLE hFindFile;
            WIN32_FILE_ATTRIBUTE_DATA attrData;
            DWORD dwFilePathSize = lstrlen( lpGPO->lpFileSysPath );
            TCHAR szComputerName[3*MAX_COMPUTERNAME_LENGTH + 1];
            DWORD dwSize;

            dwSize = 3*MAX_COMPUTERNAME_LENGTH + 1;
            if (!GetComputerName(szComputerName, &dwSize)) {
                DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: Couldn't get the computer Name with error %d."), GetLastError()));
                szComputerName[0] = TEXT('\0');
            }


            dwSize = dwFilePathSize + MAX_PATH;

            WCHAR *pwszEnd;
            WCHAR *pwszFile = (WCHAR *) LocalAlloc( LPTR, dwSize * sizeof(WCHAR) );

            if ( pwszFile == 0 ) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: ParseRegistryFile failed to allocate memory.")));
                CloseHandle (hFile);
                FreeHashTable( pHashTable );
                // no logging is done in any case
                return FALSE;
            }

            lstrcpy( pwszFile, lpGPO->lpFileSysPath );

            //
            // Strip off trailing 'machine' or 'user'
            //

            pwszEnd = pwszFile + lstrlen( pwszFile );

            if ( lpGPOInfo->dwFlags & GP_MACHINE )
                pwszEnd -= 7;   // length of "machine"
            else
                pwszEnd -= 4;   // length of "user"

            lstrcpy( pwszEnd, L"Adm\\*.adm");

            //
            // Remember end point so that the actual Adm filename can be
            // easily concatenated.
            //

            pwszEnd = pwszEnd + lstrlen( L"Adm\\" );

            //
            // Enumerate all Adm files
            //

            hFindFile = FindFirstFile( pwszFile, &findData);

            if ( hFindFile != INVALID_HANDLE_VALUE )
            {
                do
                {
                    if ( !(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
                    {
                        DmAssert( dwFilePathSize + lstrlen(findData.cFileName) + lstrlen( L"\\Adm\\" ) < dwSize );

                        lstrcpy( pwszEnd, findData.cFileName);

                        ZeroMemory (&attrData, sizeof(attrData));

                        if ( GetFileAttributesEx (pwszFile, GetFileExInfoStandard, &attrData ) != 0 ) {

                            if ( !AddAdmFile( pwszFile, lpGPO->lpDSPath, &attrData.ftLastWriteTime,
                                              szComputerName, &pAdmFileCache ) ) {
                                DebugMsg((DM_WARNING,
                                          TEXT("ProcessGPORegistryPolicy: AddAdmFile failed.")));

                                if (pHashTable->hrError == S_OK)
                                    pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
                            }

                        }
                    }   // if findData & file_attr_dir
                }  while ( FindNextFile(hFindFile, &findData) );//  do

                FindClose(hFindFile);

            }   // if hfindfile

            LocalFree( pwszFile );

        }   //  if rsoploggingenabled

        lpGPO = lpGPO->pNext;
    }

    //
    // Log registry data to Cimom database
    //

    if ( lpGPOInfo->pWbemServices ) {

        if ( ! LogRegistryRsopData( lpGPOInfo->dwFlags, pHashTable, lpGPOInfo->pWbemServices ) )  {
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Error when logging Registry Rsop data. Continuing.")));

            if (pHashTable->hrError == S_OK)
                pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
        }
        if ( ! LogAdmRsopData( pAdmFileCache, lpGPOInfo->pWbemServices ) ) {
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Error when logging Adm Rsop data. Continuing.")));

            if (pHashTable->hrError == S_OK)
                pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
        }

        *phrRsopLogging = pHashTable->hrError;
    }


    FreeHashTable( pHashTable );
    FreeAdmFileCache( pAdmFileCache );

    CloseHandle (hFile);

#if 0
    //
    // Set the security on the file
    //

    if (!MakeFileSecure (szPath, 0)) {
        DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: Failed to set security on the group policy registry file with %d"),
                 GetLastError()));
    }
#endif

    return TRUE;
}


//*************************************************************
//
//  AddAdmFile()
//
//  Purpose:    Prepends to list of Adm files
//
//  Parameters: pwszFile       - File path
//              pwszGPO        - Gpo
//              pftWrite       - Last write time
//              ppAdmFileCache - List of Adm files processed
//
//*************************************************************

BOOL AddAdmFile( WCHAR *pwszFile, WCHAR *pwszGPO, FILETIME *pftWrite, WCHAR *szComputerName,
                 ADMFILEINFO **ppAdmFileCache )
{
    XPtrLF<WCHAR> xszLongPath;
    LPTSTR pwszUNCPath;

    DebugMsg((DM_VERBOSE, TEXT("AllocAdmFileInfo: Adding File name <%s> to the Adm list."), pwszFile));
    if ((szComputerName) && (*szComputerName) && (!IsUNCPath(pwszFile))) {
        xszLongPath = MakePathUNC(pwszFile, szComputerName);

        if (!xszLongPath) {
            DebugMsg((DM_WARNING, TEXT("AllocAdmFileInfo: Failed to Make the path UNC with error %d."), GetLastError()));
            return FALSE;
        }
        pwszUNCPath = xszLongPath;
    }
    else
        pwszUNCPath = pwszFile;


    ADMFILEINFO *pAdmInfo = AllocAdmFileInfo( pwszUNCPath, pwszGPO, pftWrite );
    if ( pAdmInfo == NULL )
        return FALSE;

    pAdmInfo->pNext = *ppAdmFileCache;
    *ppAdmFileCache = pAdmInfo;

    return TRUE;
}


//*************************************************************
//
//  FreeAdmFileCache()
//
//  Purpose:    Frees Adm File list
//
//  Parameters: pAdmFileCache - List of Adm files to free
//
//
//*************************************************************

void FreeAdmFileCache( ADMFILEINFO *pAdmFileCache )
{
    ADMFILEINFO *pNext;

    while ( pAdmFileCache ) {
        pNext = pAdmFileCache->pNext;
        FreeAdmFileInfo( pAdmFileCache );
        pAdmFileCache = pNext;
    }
}


//*************************************************************
//
//  AllocAdmFileInfo()
//
//  Purpose:    Allocates a new struct for ADMFILEINFO
//
//  Parameters: pwszFile  -  File name
//              pwszGPO   -  Gpo
//              pftWrite  -  Last write time
//
//
//*************************************************************

ADMFILEINFO * AllocAdmFileInfo( WCHAR *pwszFile, WCHAR *pwszGPO, FILETIME *pftWrite )
{
    XLastError xe;

    ADMFILEINFO *pAdmFileInfo = (ADMFILEINFO *) LocalAlloc( LPTR, sizeof(ADMFILEINFO) );
    if  ( pAdmFileInfo == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocAdmFileInfo: Failed to allocate memory.")));
        return NULL;
    }

    pAdmFileInfo->pwszFile = (WCHAR *) LocalAlloc( LPTR, (lstrlen(pwszFile) + 1) * sizeof(WCHAR) );
    if ( pAdmFileInfo->pwszFile == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AllocAdmFileInfo: Failed to allocate memory.")));
        LocalFree( pAdmFileInfo );
        return NULL;
    }

    pAdmFileInfo->pwszGPO = (WCHAR *) LocalAlloc( LPTR, (lstrlen(pwszGPO) + 1) * sizeof(WCHAR) );
    if ( pAdmFileInfo->pwszGPO == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AllocAdmFileInfo: Failed to allocate memory.")));
        LocalFree( pAdmFileInfo->pwszFile );
        LocalFree( pAdmFileInfo );
        return NULL;
    }

    lstrcpy( pAdmFileInfo->pwszFile, pwszFile );
    lstrcpy( pAdmFileInfo->pwszGPO, pwszGPO );

    pAdmFileInfo->ftWrite = *pftWrite;

    return pAdmFileInfo;
}


//*************************************************************
//
//  FreeAdmFileInfo()
//
//  Purpose:    Deletes a ADMFILEINFO struct
//
//  Parameters: pAdmFileInfo - Struct to delete
//              pftWrite   -  Last write time
//
//
//*************************************************************

void FreeAdmFileInfo( ADMFILEINFO *pAdmFileInfo )
{
    if ( pAdmFileInfo ) {
        LocalFree( pAdmFileInfo->pwszFile );
        LocalFree( pAdmFileInfo->pwszGPO );
        LocalFree( pAdmFileInfo );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\policy\gpt.cpp ===
//*************************************************************
//
//  Group Policy Support
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//*************************************************************


#include "gphdr.h"

//
// DS Object class types
//

TCHAR szDSClassAny[]    = TEXT("(objectClass=*)");
TCHAR szDSClassGPO[]    = TEXT("groupPolicyContainer");
TCHAR szDSClassSite[]   = TEXT("site");
TCHAR szDSClassDomain[] = TEXT("domainDNS");
TCHAR szDSClassOU[]     = TEXT("organizationalUnit");
TCHAR szObjectClass[]   = TEXT("objectClass");

TCHAR wszKerberos[] = TEXT("Kerberos");

//
// Global flags for Gpo shutdown processing. These are accessed outside
// the lock because its value is either 0 or 1. Even if there is a race,
// all it means is that shutdown will start one iteration later.
//

BOOL g_bStopMachGPOProcessing = FALSE;
BOOL g_bStopUserGPOProcessing = FALSE;

//
// Critical section for handling concurrent, asynchronous completion
//

CRITICAL_SECTION g_GPOCS;

//
// Global pointers for maintaining asynchronous completion context
//

LPGPINFOHANDLE g_pMachGPInfo = 0;
LPGPINFOHANDLE g_pUserGPInfo = 0;

//
// Status UI critical section, callback, and proto-types
//

CRITICAL_SECTION g_StatusCallbackCS;
PFNSTATUSMESSAGECALLBACK g_pStatusMessageCallback = NULL;

DWORD WINAPI
SetPreviousFgPolicyRefreshInfo( LPWSTR szUserSid,
                                      FgPolicyRefreshInfo info );
DWORD WINAPI
SetNextFgPolicyRefreshInfo( LPWSTR szUserSid,
                                 FgPolicyRefreshInfo info );

DWORD WINAPI
GetCurrentFgPolicyRefreshInfo(  LPWSTR szUserSid,
                                      FgPolicyRefreshInfo* pInfo );
//*************************************************************
//
//  ApplyGroupPolicy()
//
//  Purpose:    Processes group policy
//
//  Parameters: dwFlags         -  Processing flags
//              hToken          -  Token (user or machine)
//              hEvent          -  Termination event for background thread
//              hKeyRoot        -  Root registry key (HKCU or HKLM)
//              pStatusCallback -  Callback function for display status messages
//
//  Return:     Thread handle if successful
//              NULL if an error occurs
//
//*************************************************************

HANDLE WINAPI ApplyGroupPolicy (DWORD dwFlags, HANDLE hToken, HANDLE hEvent,
                                HKEY hKeyRoot, PFNSTATUSMESSAGECALLBACK pStatusCallback)
{
    HANDLE hThread = NULL;
    DWORD dwThreadID;
    LPGPOINFO lpGPOInfo = NULL;
    SECURITY_ATTRIBUTES sa;
    OLE32_API *pOle32Api = NULL;
    XPtrLF<SECURITY_DESCRIPTOR> xsd;
    CSecDesc Csd;
    XLastError  xe;

    //
    // Verbose output
    //
    DebugMsg((DM_VERBOSE, TEXT("ApplyGroupPolicy: Entering. Flags = %x"), dwFlags));


    //
    // Save the status UI callback function
    //
    EnterCriticalSection (&g_StatusCallbackCS);
    g_pStatusMessageCallback = pStatusCallback;
    LeaveCriticalSection (&g_StatusCallbackCS);


    //
    // Allocate a GPOInfo structure to work with.
    //
    lpGPOInfo = (LPGPOINFO) LocalAlloc (LPTR, sizeof(GPOINFO));

    if (!lpGPOInfo) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to alloc lpGPOInfo (%d)."),
                 GetLastError()));
        CEvents ev(TRUE, EVENT_FAILED_ALLOCATION);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }

    lpGPOInfo->dwFlags = dwFlags;
    lpGPOInfo->hToken = hToken;
    lpGPOInfo->hEvent = hEvent;
    lpGPOInfo->hKeyRoot = hKeyRoot;

    if (dwFlags & GP_MACHINE) {
        lpGPOInfo->pStatusCallback = MachinePolicyCallback;
    } else {
        lpGPOInfo->pStatusCallback = UserPolicyCallback;
    }


    //
    // Create an event so other processes can trigger policy
    // to be applied immediately
    //


    Csd.AddLocalSystem();
    Csd.AddAdministrators();
    
    if (!(dwFlags & GP_MACHINE)) {

        //
        // User events
        //
        XPtrLF<SID> xSid = (SID *)GetUserSid(hToken);

        if (!xSid) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to find user Sid %d"),
                     GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_SETACLS);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            goto Exit;
        }

        Csd.AddSid((SID *)xSid, 
                   GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE);
    }
    else {

        //
        // Machine Events
        // Allow Everyone Access by default but can be overridden by policy or preference
        //

        DWORD dwUsersDenied = 0;
        HKEY  hSubKey;
        DWORD dwType=0, dwSize=0;

        //
        // Check for a preference
        //

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ,
                         &hSubKey) == ERROR_SUCCESS) {

            dwSize = sizeof(dwUsersDenied);
            RegQueryValueEx(hSubKey, MACHPOLICY_DENY_USERS, NULL, &dwType,
                            (LPBYTE) &dwUsersDenied, &dwSize);

            RegCloseKey(hSubKey);
        }


        //
        // Check for a policy
        //

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY, 0, KEY_READ,
                         &hSubKey) == ERROR_SUCCESS) {

            dwSize = sizeof(dwUsersDenied);
            RegQueryValueEx(hSubKey, MACHPOLICY_DENY_USERS, NULL, &dwType,
                            (LPBYTE) &dwUsersDenied, &dwSize);

            RegCloseKey(hSubKey);
        }


        if (!dwUsersDenied) {
            Csd.AddAuthUsers(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE);
        }
    }

    xsd = Csd.MakeSD();

    if (!xsd) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to create Security Descriptor with %d"),
                 GetLastError()));
        CEvents ev(TRUE, EVENT_FAILED_SETACLS);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }

    sa.lpSecurityDescriptor = (SECURITY_DESCRIPTOR *)xsd;
    sa.bInheritHandle = FALSE;
    sa.nLength = sizeof(sa);

    lpGPOInfo->hTriggerEvent = CreateEvent (&sa, FALSE, FALSE,
                                            (dwFlags & GP_MACHINE) ?
                                            MACHINE_POLICY_REFRESH_EVENT : USER_POLICY_REFRESH_EVENT);


    lpGPOInfo->hForceTriggerEvent = CreateEvent (&sa, FALSE, FALSE,
                                            (dwFlags & GP_MACHINE) ?
                                            MACHINE_POLICY_FORCE_REFRESH_EVENT : USER_POLICY_FORCE_REFRESH_EVENT);

    
    //
    // Create the notification events. 
    // These should already be created in InitializePolicyProcessing..
    //

    lpGPOInfo->hNotifyEvent = OpenEvent (EVENT_ALL_ACCESS, FALSE,
                                           (dwFlags & GP_MACHINE) ?
                                           MACHINE_POLICY_APPLIED_EVENT : USER_POLICY_APPLIED_EVENT);

    //
    // Create the needfg event
    //

    lpGPOInfo->hNeedFGEvent = OpenEvent (EVENT_ALL_ACCESS, FALSE,
                                           (dwFlags & GP_MACHINE) ?
                                           MACHINE_POLICY_REFRESH_NEEDFG_EVENT : 
                                           USER_POLICY_REFRESH_NEEDFG_EVENT);
                                           
    //
    // Create the done event
    //

    lpGPOInfo->hDoneEvent = OpenEvent (EVENT_ALL_ACCESS, FALSE,
                                           (dwFlags & GP_MACHINE) ?
                                           MACHINE_POLICY_DONE_EVENT : 
                                           USER_POLICY_DONE_EVENT);
                                           
    //
    // Initilialize shutdown gpo processing support
    //

    if ( dwFlags & GP_MACHINE )
        g_bStopMachGPOProcessing = FALSE;
    else
        g_bStopUserGPOProcessing = FALSE;

    pOle32Api = LoadOle32Api();
    if ( pOle32Api == NULL ) {
        DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to load ole32.dll.") ));
    }
    else {

        HRESULT hr = pOle32Api->pfnCoInitializeEx( NULL, COINIT_MULTITHREADED );

        if ( SUCCEEDED(hr) ) {
            lpGPOInfo->bFGCoInitialized = TRUE;
        }
        else {
            DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: CoInitializeEx failed with 0x%x."), hr ));
        }
    }

    if ( lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND )
    {
        lpGPOInfo->dwFlags |= GP_BACKGROUND_THREAD;
    }

    //
    // Process the GPOs
    //
    ProcessGPOs(lpGPOInfo);

    if ( lpGPOInfo->bFGCoInitialized ) {
        pOle32Api->pfnCoUnInitialize();
        lpGPOInfo->bFGCoInitialized = FALSE;
    }

    if ( lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND )
    {
        lpGPOInfo->dwFlags &= ~GP_ASYNC_FOREGROUND;
        lpGPOInfo->dwFlags &= ~GP_BACKGROUND_THREAD;
    }

    //
    // If requested, create a background thread to keep updating
    // the profile from the gpos
    //
    if (lpGPOInfo->dwFlags & GP_BACKGROUND_REFRESH) {

        //
        // Create a thread which sleeps and processes GPOs
        //

        hThread = CreateThread (NULL, 64*1024, // 64k as the stack size
                                (LPTHREAD_START_ROUTINE) GPOThread,
                                (LPVOID) lpGPOInfo, CREATE_SUSPENDED, &dwThreadID);

        if (!hThread) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to create background thread (%d)."),
                     GetLastError()));
            goto Exit;
        }

        SetThreadPriority (hThread, THREAD_PRIORITY_IDLE);
        lpGPOInfo->pStatusCallback = NULL;
        ResumeThread (hThread);

        //
        // Reset the status UI callback function
        //

        EnterCriticalSection (&g_StatusCallbackCS);
        g_pStatusMessageCallback = NULL;
        LeaveCriticalSection (&g_StatusCallbackCS);

        DebugMsg((DM_VERBOSE, TEXT("ApplyGroupPolicy: Leaving successfully.")));

        return hThread;
    }

    DebugMsg((DM_VERBOSE, TEXT("ApplyGroupPolicy: Background refresh not requested.  Leaving successfully.")));
    hThread = (HANDLE) 1;

Exit:
    EnterCriticalSection( &g_GPOCS );
    if ( dwFlags & GP_MACHINE ) {

        if ( g_pMachGPInfo )
            LocalFree( g_pMachGPInfo );
        g_pMachGPInfo = 0;
    } else {
        if ( g_pUserGPInfo )
            LocalFree( g_pUserGPInfo );
        g_pUserGPInfo = 0;
    }
    LeaveCriticalSection( &g_GPOCS );

    if (lpGPOInfo) {

        if (lpGPOInfo->hTriggerEvent) {
            CloseHandle (lpGPOInfo->hTriggerEvent);
        }

        if (lpGPOInfo->hForceTriggerEvent) {
            CloseHandle (lpGPOInfo->hForceTriggerEvent);
        }
        
        if (lpGPOInfo->hNotifyEvent) {
            CloseHandle (lpGPOInfo->hNotifyEvent);
        }

        if (lpGPOInfo->hNeedFGEvent) {
            CloseHandle (lpGPOInfo->hNeedFGEvent);
        }
          
        if (lpGPOInfo->lpwszSidUser)
            DeleteSidString( lpGPOInfo->lpwszSidUser );

        if (lpGPOInfo->szName)
            LocalFree(lpGPOInfo->szName);

        if (lpGPOInfo->szTargetName)
            LocalFree(lpGPOInfo->szTargetName);
            
        LocalFree (lpGPOInfo);
    }

    //
    // Reset the status UI callback function
    //

    EnterCriticalSection (&g_StatusCallbackCS);
    g_pStatusMessageCallback = NULL;
    LeaveCriticalSection (&g_StatusCallbackCS);

    return hThread;
}


extern "C" void ProfileProcessGPOs( void* );

//*************************************************************
//
//  GPOThread()
//
//  Purpose:    Background thread for GPO processing.
//
//  Parameters: lpGPOInfo   - GPO info
//
//  Return:     0
//
//*************************************************************

DWORD WINAPI GPOThread (LPGPOINFO lpGPOInfo)
{
    HINSTANCE hInst;
    HKEY hKey;
    HANDLE hHandles[4] = {NULL, NULL, NULL, NULL};
    DWORD dwType, dwSize, dwResult;
    DWORD dwTimeout, dwOffset;
    BOOL bSetBkGndFlag, bForceBkGndFlag;
    TCHAR szEventName[60];
    LARGE_INTEGER DueTime;
    HRESULT hr;
    ULONG TTLMinutes;
    XLastError  xe;

    OLE32_API *pOle32Api = LoadOle32Api();

    hInst = LoadLibrary (TEXT("userenv.dll"));

    hHandles[0] = lpGPOInfo->hEvent;
    hHandles[1] = lpGPOInfo->hTriggerEvent;
    hHandles[2] = lpGPOInfo->hForceTriggerEvent;

    for (;;)
    {
        //
        // Initialize
        //

        bForceBkGndFlag = FALSE;
        

        if (lpGPOInfo->dwFlags & GP_MACHINE) {
            if (lpGPOInfo->iMachineRole == 3) {
                dwTimeout = GP_DEFAULT_REFRESH_RATE_DC;
                dwOffset = GP_DEFAULT_REFRESH_RATE_OFFSET_DC;
            } else {
                dwTimeout = GP_DEFAULT_REFRESH_RATE;
                dwOffset = GP_DEFAULT_REFRESH_RATE_OFFSET;
            }
        } else {
            dwTimeout = GP_DEFAULT_REFRESH_RATE;
            dwOffset = GP_DEFAULT_REFRESH_RATE_OFFSET;
        }


        //
        // Query for the refresh timer value and max offset
        //

        if (RegOpenKeyEx (lpGPOInfo->hKeyRoot,
                          SYSTEM_POLICIES_KEY,
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {


            if ((lpGPOInfo->iMachineRole == 3) && (lpGPOInfo->dwFlags & GP_MACHINE)) {

                dwSize = sizeof(dwTimeout);
                RegQueryValueEx (hKey,
                                 TEXT("GroupPolicyRefreshTimeDC"),
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &dwTimeout,
                                 &dwSize);

                dwSize = sizeof(dwOffset);
                RegQueryValueEx (hKey,
                                 TEXT("GroupPolicyRefreshTimeOffsetDC"),
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &dwOffset,
                                 &dwSize);

            } else {

                dwSize = sizeof(dwTimeout);
                RegQueryValueEx (hKey,
                                 TEXT("GroupPolicyRefreshTime"),
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &dwTimeout,
                                 &dwSize);

                dwSize = sizeof(dwOffset);
                RegQueryValueEx (hKey,
                                 TEXT("GroupPolicyRefreshTimeOffset"),
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &dwOffset,
                                 &dwSize);
            }

            RegCloseKey (hKey);
        }


        //
        // Limit the timeout to once every 64800 minutes (45 days)
        //

        if (dwTimeout >= 64800) {
            dwTimeout = 64800;
        }


        //
       // Convert seconds to milliseconds
        //

        dwTimeout =  dwTimeout * 60 * 1000;


        //
        // Limit the offset to 1440 minutes (24 hours)
        //

        if (dwOffset >= 1440) {
            dwOffset = 1440;
        }


        //
        // Special case 0 milliseconds to be 7 seconds
        //

        if (dwTimeout == 0) {
            dwTimeout = 7000;

        } else {

            //
            // If there is an offset, pick a random number
            // from 0 to dwOffset and then add it to the timeout
            //

            if (dwOffset) {
                dwOffset = GetTickCount() % dwOffset;

                dwOffset = dwOffset * 60 * 1000;
                dwTimeout += dwOffset;
            }
        }


        //
        // Setup the timer
        //

        if (dwTimeout >= 60000) {
            DebugMsg((DM_VERBOSE, TEXT("GPOThread:  Next refresh will happen in %d minutes"),
                     ((dwTimeout / 1000) / 60)));
        } else {
            DebugMsg((DM_VERBOSE, TEXT("GPOThread:  Next refresh will happen in %d seconds"),
                     (dwTimeout / 1000)));
        }


        wsprintf (szEventName, TEXT("userenv: refresh timer for %d:%d"),
                  GetCurrentProcessId(), GetCurrentThreadId());
        hHandles[3] = CreateWaitableTimer (NULL, TRUE, szEventName);


        if (hHandles[3] == NULL) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GPOThread: CreateWaitableTimer failed with error %d"),
                     GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_TIMER);
            ev.AddArg( TEXT("CreateWaitableTimer")); ev.AddArgWin32Error(GetLastError()); ev.Report();
            break;
        }

        DueTime.QuadPart = UInt32x32To64(10000, dwTimeout);
        DueTime.QuadPart *= -1;

        if (!SetWaitableTimer (hHandles[3], &DueTime, 0, NULL, 0, FALSE)) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GPOThread: Failed to set timer with error %d"),
                     GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_TIMER);
            ev.AddArg(TEXT("SetWaitableTimer")); ev.AddArgWin32Error(GetLastError()); ev.Report();
            break;
        }

        dwResult = WaitForMultipleObjects( 4, hHandles, FALSE, INFINITE );

        if ( (dwResult - WAIT_OBJECT_0) == 0 )
        {
            //
            // for machine policy thread, this is a shutdown.
            // for user policy thread, this is a logoff.
            //
            goto ExitLoop;
        }
        else if ( (dwResult - WAIT_OBJECT_0) == 2 ) {
            bForceBkGndFlag = TRUE;
        }
        else if ( dwResult == WAIT_FAILED )
        {
            xe = GetLastError();
            DebugMsg( ( DM_WARNING, L"GPOThread: MsgWaitForMultipleObjects with error %d", GetLastError() ) );
            CEvents ev(TRUE, EVENT_FAILED_TIMER);
            ev.AddArg(TEXT("WaitForMultipleObjects")); ev.AddArgWin32Error(GetLastError()); ev.Report();
            goto ExitLoop;
        }

        //
        // Check if we should set the background flag.  We offer this
        // option for the test team's automation tests.  They need to
        // simulate logon / boot policy without actually logging on or
        // booting the machine.
        //

        bSetBkGndFlag = TRUE;

        if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                          WINLOGON_KEY,
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            dwSize = sizeof(bSetBkGndFlag);
            RegQueryValueEx (hKey,
                             TEXT("SetGroupPolicyBackgroundFlag"),
                             NULL,
                             &dwType,
                             (LPBYTE) &bSetBkGndFlag,
                             &dwSize);

            RegCloseKey (hKey);
        }


        lpGPOInfo->dwFlags &= ~GP_REGPOLICY_CPANEL;
        lpGPOInfo->dwFlags &= ~GP_SLOW_LINK;
        lpGPOInfo->dwFlags &= ~GP_VERBOSE;
        lpGPOInfo->dwFlags &= ~GP_BACKGROUND_THREAD;
        lpGPOInfo->dwFlags &= ~GP_FORCED_REFRESH;

        //
        // In case of forced refresh flag, we override the extensions nobackground policy and prevent 
        // it from getting skipped early on in the processing. We bypass the history logic and force 
        // policy to be applied for extensions that do not care abt. whether they are run in the 
        // foreground or background. for only foreground extensions we write a registry value saying 
        // that the extension needs to override the history logic when they get applied in the foreground 
        // next.
        // In addition we pulse the needfg event so that the calling app knows a reboot/relogon is needed
        // for application of fgonly extensions 
        //
        
        if (bForceBkGndFlag) {
            lpGPOInfo->dwFlags |= GP_FORCED_REFRESH;
        }
            
        //
        // Set the background thread flag so components known
        // when they are being called from the background thread
        // vs the main thread.
        //

        if (bSetBkGndFlag) {
            lpGPOInfo->dwFlags |= GP_BACKGROUND_THREAD;
        }

        if ( !lpGPOInfo->bBGCoInitialized && pOle32Api != NULL ) {

            hr = pOle32Api->pfnCoInitializeEx( NULL, COINIT_MULTITHREADED );
            if ( SUCCEEDED(hr) ) {
                lpGPOInfo->bBGCoInitialized = TRUE;
            }
        }

        ProcessGPOs(lpGPOInfo);

        if ( lpGPOInfo->dwFlags & GP_MACHINE ) {

            //
            // Delete garbage-collectable namespaces under root\rsop that are
            // older than 1 week. We can have a policy to configure this time-to-live value.
            //

            TTLMinutes = 24 * 60;

            if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                              WINLOGON_KEY,
                              0, KEY_READ, &hKey) == ERROR_SUCCESS) {

                dwSize = sizeof(TTLMinutes);
                RegQueryValueEx (hKey,
                                 TEXT("RSoPGarbageCollectionInterval"),
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &TTLMinutes,
                                 &dwSize);

                RegCloseKey (hKey);
            }


            if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                              SYSTEM_POLICIES_KEY,
                              0, KEY_READ, &hKey) == ERROR_SUCCESS) {

                dwSize = sizeof(TTLMinutes);
                RegQueryValueEx (hKey,
                                 TEXT("RSoPGarbageCollectionInterval"),
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &TTLMinutes,
                                 &dwSize);

                RegCloseKey (hKey);
            }



            //
            // Synchronize with other processes that may be concurrently creating namespaces,
            // during diagnostic mode or planning mode data generation. 
            //

            XCriticalPolicySection xCritSect( EnterCriticalPolicySection(TRUE ) );
            if ( xCritSect )
                GarbageCollectNamespaces(TTLMinutes);
        }

        CloseHandle (hHandles[3]);
        hHandles[3] = NULL;
    }

ExitLoop:

    //
    // Cleanup
    //

    if (hHandles[3]) {
        CloseHandle (hHandles[3]);
    }

    if (lpGPOInfo->hTriggerEvent) {
        CloseHandle (lpGPOInfo->hTriggerEvent);
    }

    if (lpGPOInfo->hForceTriggerEvent) {
        CloseHandle (lpGPOInfo->hForceTriggerEvent);
    }

    if (lpGPOInfo->hNotifyEvent) {
        CloseHandle (lpGPOInfo->hNotifyEvent);
    }

    if (lpGPOInfo->hNeedFGEvent) {
        CloseHandle (lpGPOInfo->hNeedFGEvent);
    }
    
    if (lpGPOInfo->hDoneEvent) {
        CloseHandle (lpGPOInfo->hDoneEvent);
    }
    
    if ( lpGPOInfo->bBGCoInitialized ) {

        OLE32_API *pOle32Api = LoadOle32Api();
        if ( pOle32Api == NULL ) {
            DebugMsg((DM_WARNING, TEXT("GPOThread: Failed to load ole32.dll.") ));
        }
        else {
            pOle32Api->pfnCoUnInitialize();
            lpGPOInfo->bBGCoInitialized = FALSE;
        }

    }

    EnterCriticalSection( &g_GPOCS );

    if ( lpGPOInfo->dwFlags & GP_MACHINE ) {

       if ( g_pMachGPInfo )
           LocalFree( g_pMachGPInfo );

       g_pMachGPInfo = 0;
    } else {

        if ( g_pUserGPInfo )
            LocalFree( g_pUserGPInfo );

        g_pUserGPInfo = 0;
     }

    LeaveCriticalSection( &g_GPOCS );

    if (lpGPOInfo->lpwszSidUser)
        DeleteSidString( lpGPOInfo->lpwszSidUser );

    if (lpGPOInfo->szName)
        LocalFree(lpGPOInfo->szName);

    if (lpGPOInfo->szTargetName)
        LocalFree(lpGPOInfo->szTargetName);
        
    LocalFree (lpGPOInfo);

    FreeLibraryAndExitThread (hInst, 0);
    return 0;
}


//*************************************************************
//
//  GPOExceptionFilter()
//
//  Purpose:    Exception filter when procssing GPO extensions
//
//  Parameters: pExceptionPtrs - Pointer to exception pointer
//
//  Returns:    EXCEPTION_EXECUTE_HANDLER
//
//*************************************************************

LONG GPOExceptionFilter( PEXCEPTION_POINTERS pExceptionPtrs )
{
    PEXCEPTION_RECORD pExr = pExceptionPtrs->ExceptionRecord;
    PCONTEXT pCxr = pExceptionPtrs->ContextRecord;

    DebugMsg(( DM_WARNING, L"GPOExceptionFilter: Caught exception 0x%x, exr = 0x%x, cxr = 0x%x\n",
              pExr->ExceptionCode, pExr, pCxr ));

    DmAssert( ! L"Caught unhandled exception when processing group policy extension" );

    return EXCEPTION_EXECUTE_HANDLER;
}

BOOL WINAPI
GetFgPolicySetting( HKEY hKeyRoot );

//*************************************************************
//
//  ProcessGPOs()
//
//  Purpose:    Processes GPOs
//
//  Parameters: lpGPOInfo   -   GPO information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ProcessGPOs (LPGPOINFO lpGPOInfo)
{
    BOOL bRetVal = FALSE;
    DWORD dwThreadID;
    HANDLE hThread;
    DWORD dwType, dwSize, dwResult;
    HKEY hKey;
    BOOL bResult;
    PDOMAIN_CONTROLLER_INFO pDCI = NULL;
    LPTSTR lpDomain = NULL;
    LPTSTR lpName = NULL;
    LPTSTR lpDomainDN = NULL;
    LPTSTR lpComputerName;
    PGROUP_POLICY_OBJECT lpGPO = NULL;
    PGROUP_POLICY_OBJECT lpGPOTemp;
    BOOL bAllSkipped;
    LPGPEXT lpExt;
    LPGPINFOHANDLE pGPHandle = NULL;
    ASYNCCOMPLETIONHANDLE pAsyncHandle = 0;
    HANDLE hOldToken;
    UINT uExtensionCount = 0;
    PNETAPI32_API pNetAPI32;
    DWORD dwUserPolicyMode = 0;
    DWORD dwCurrentTime = 0;
    INT iRole;
    BOOL bSlow;
    BOOL bForceNeedFG = FALSE;
    CLocator locator;
    RSOPEXTSTATUS gpCoreStatus;
    XLastError    xe;
    LPWSTR  szNetworkName = 0;
    FgPolicyRefreshInfo info = { GP_ReasonUnknown, GP_ModeAsyncForeground };
    PTOKEN_GROUPS  pTokenGroups = NULL;
    BOOL bAsyncFg = lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND ? TRUE : FALSE;
    LPWSTR szPolicyMode = 0;

    if ( lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND )
    {
        szPolicyMode = L"Async forground";
    }
    else if ( !( lpGPOInfo->dwFlags & GP_BACKGROUND_REFRESH ) )
    {
        szPolicyMode = L"Sync forground";
    }
    else
    {
        szPolicyMode = L"Background";
    }

    //
    // Allow debugging level to be changed dynamically between
    // policy refreshes.
    //

    InitDebugSupport( FALSE );

    //
    // Debug spew
    //

    memset(&gpCoreStatus, 0, sizeof(gpCoreStatus));


    if (lpGPOInfo->dwFlags & GP_MACHINE) {
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:")));
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:")));
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:  Starting computer Group Policy (%s) processing..."),szPolicyMode ));
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:")));
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:")));
    } else {
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:")));
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:")));
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs: Starting user Group Policy (%s) processing..."),szPolicyMode ));
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:")));
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:")));
    }

    if ( !( lpGPOInfo->dwFlags & GP_MACHINE ) && lpGPOInfo->lpwszSidUser )
    {
        lpGPOInfo->lpwszSidUser = GetSidString( lpGPOInfo->hToken );
        if ( lpGPOInfo->lpwszSidUser == 0 )
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: GetSidString failed.")));
            CEvents ev(TRUE, EVENT_FAILED_GET_SID); ev.Report();
            goto Exit;
        }
    }

    GetSystemTimeAsFileTime(&gpCoreStatus.ftStartTime);
    gpCoreStatus.bValid = TRUE;

    //
    // Check if we should be verbose to the event log
    //

    if (CheckForVerbosePolicy()) {
        lpGPOInfo->dwFlags |= GP_VERBOSE;
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs:  Verbose output to eventlog requested.")));
    }

    if (lpGPOInfo->dwFlags & GP_VERBOSE) {
        if (lpGPOInfo->dwFlags & GP_MACHINE) {
            CEvents ev(FALSE, EVENT_START_MACHINE_POLICY); ev.Report();
        } else {
            CEvents ev(FALSE, EVENT_START_USER_POLICY); ev.Report();
        }
    }


    //
    // Claim the critical section
    //

    lpGPOInfo->hCritSection = EnterCriticalPolicySection((lpGPOInfo->dwFlags & GP_MACHINE));

    if (!lpGPOInfo->hCritSection) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to claim the policy critical section with %d."),
                 GetLastError()));
        CEvents ev(TRUE, EVENT_FAILED_CRITICAL_SECTION);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }


    //
    // Set the security on the Group Policy registry key
    //

    if (!MakeRegKeySecure((lpGPOInfo->dwFlags & GP_MACHINE) ? NULL : lpGPOInfo->hToken,
                          lpGPOInfo->hKeyRoot,
                          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy"))) {
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to secure reg key.")));
    }

    //
    // Check if user's sid has changed
    // Check the change in user's sid before doing any rsop logging..
    //

    if ( !CheckForChangedSid( lpGPOInfo, &locator ) ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Check for changed sid failed")));
        goto Exit;
    }


    //
    // This flag will be used for all further Rsop Logging..
    //
    
    lpGPOInfo->bRsopLogging = RsopLoggingEnabled();

    //
    // Load netapi32
    //

    pNetAPI32 = LoadNetAPI32();

    if (!pNetAPI32) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs:  Failed to load netapi32 with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Get the role of this computer
    //

    if (!GetMachineRole (&iRole)) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs:  Failed to get the role of the computer.")));
        CEvents ev(TRUE, EVENT_FAILED_ROLE); ev.Report();
        goto Exit;
    }

    lpGPOInfo->iMachineRole = iRole;

    DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs:  Machine role is %d."), iRole));

    if (lpGPOInfo->dwFlags & GP_VERBOSE) {

        switch (iRole) {
        case 0:
               {
                    CEvents ev(FALSE, EVENT_ROLE_STANDALONE); ev.Report();
                    break;
               }

        case 1:
                {
                    CEvents ev(FALSE, EVENT_ROLE_DOWNLEVEL_DOMAIN); ev.Report();
                    break;
                }
        default:
                {
                    CEvents ev(FALSE, EVENT_ROLE_DS_DOMAIN); ev.Report();
                    break;
                }
        }
    }


    //
    // If we are going to apply policy from the DS
    // query for the user's DN name, domain name, etc
    //

    if (lpGPOInfo->dwFlags & GP_APPLY_DS_POLICY)
    {
        //
        // Query for the user's domain name
        //

        if (!ImpersonateUser(lpGPOInfo->hToken, &hOldToken))
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to impersonate user")));
            goto Exit;
        }

        lpDomain = MyGetDomainName ();

        RevertToUser(&hOldToken);

        if (!lpDomain) {
            xe = GetLastError();
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: MyGetDomainName failed with %d."),
                     dwResult));
            goto Exit;
        }

        //
        // Query for the DS server name
        //
        DWORD   dwAdapterIndex = (DWORD) -1;

        dwResult = GetDomainControllerInfo( pNetAPI32,
                                            lpDomain,
                                            DS_DIRECTORY_SERVICE_REQUIRED | DS_IS_FLAT_NAME
                                            | DS_RETURN_DNS_NAME |
                                            ((lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD) ? DS_BACKGROUND_ONLY : 0),
                                            lpGPOInfo->hKeyRoot,
                                            &pDCI,
                                            &bSlow,
                                            &dwAdapterIndex );

        if (dwResult != ERROR_SUCCESS) {
            xe = dwResult;
            
            if ((dwResult == ERROR_BAD_NETPATH) ||
                (dwResult == ERROR_NETWORK_UNREACHABLE) ||
                (dwResult == ERROR_NO_SUCH_DOMAIN)) {

                //
                // couldn't find DC. Nothing more we can do, abort
                //
               if ( (!(lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD)) || 
                    (lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND) ||
                    (lpGPOInfo->iMachineRole == 3) ) 
                {
                   DebugMsg((DM_WARNING, TEXT("ProcessGPOs: The DC for domain %s is not available. aborting"),
                            lpDomain));

                    CEvents ev(TRUE, EVENT_FAILED_DSNAME);
                    ev.AddArgWin32Error(dwResult); ev.Report();
                }
                else {
                    DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: The DC for domain %s is not available."), lpDomain));

                    if (lpGPOInfo->dwFlags & GP_VERBOSE)
                    {
                        CEvents ev(FALSE, EVENT_FAILED_DSNAME);
                        ev.AddArgWin32Error(dwResult); ev.Report();
                    }
                }
            } else {

                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: DSGetDCName failed with %d."),
                         dwResult));
                CEvents ev(TRUE, EVENT_FAILED_DSNAME);
                ev.AddArgWin32Error(dwResult); ev.Report();
            }

            goto Exit;
        } else {

            //
            // success, slow link?
            //
            if (bSlow) {
                lpGPOInfo->dwFlags |= GP_SLOW_LINK;
                if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                    CEvents ev(FALSE, EVENT_SLOWLINK); ev.Report();
                }
                DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: A slow link was detected.")));
            }

            if ( ( lpGPOInfo->dwFlags & GP_MACHINE ) != 0 )
            {
                dwResult = GetNetworkName( &szNetworkName, dwAdapterIndex );
                if ( dwResult != ERROR_SUCCESS )
                {
                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: GetNetworkName failed with %d."), dwResult ));
                }
                else
                {
                    DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: network name is %s"), szNetworkName ? szNetworkName : L"" ));
                }
            }
        }

        //
        // Get the user's DN name
        //

        if (!ImpersonateUser(lpGPOInfo->hToken, &hOldToken)) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to impersonate user")));
            goto Exit;
        }

        lpName = MyGetUserName (NameFullyQualifiedDN);

        RevertToUser(&hOldToken);

        if (!lpName) {
            xe = GetLastError();
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: MyGetUserName failed with %d."),
                     dwResult));
            CEvents ev(TRUE, EVENT_FAILED_USERNAME);
            ev.AddArgWin32Error(dwResult); ev.Report();
            goto Exit;
        }


        lpDomainDN = pDCI->DomainName;

        if (lpGPOInfo->dwFlags & GP_VERBOSE) {
            CEvents ev(FALSE, EVENT_USERNAME); ev.AddArg(L"%.500s", lpName); ev.Report();
            CEvents ev1(FALSE, EVENT_DOMAINNAME); ev1.AddArg(L"%.500s", lpDomain); ev1.Report();
            CEvents ev2(FALSE, EVENT_DCNAME); ev2.AddArg(pDCI->DomainControllerName); ev2.Report();
        }

        lpGPOInfo->lpDNName = lpName;
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs:  User name is:  %s, Domain name is:  %s"),
             lpName, lpDomain));

        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Domain controller is:  %s  Domain DN is %s"),
                 pDCI->DomainControllerName, lpDomainDN));


        if (!(lpGPOInfo->dwFlags & GP_MACHINE)) {
            CallDFS(pDCI->DomainName, pDCI->DomainControllerName);
        }


        //
        // Save the DC name in the registry for future reference
        //

        DWORD dwDisp;

        if (RegCreateKeyEx (lpGPOInfo->hKeyRoot,
                          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History"),
                            0, NULL, REG_OPTION_NON_VOLATILE,
                          KEY_SET_VALUE, NULL, &hKey, &dwDisp) == ERROR_SUCCESS)
        {
            dwSize = (lstrlen(pDCI->DomainControllerName) + 1) * sizeof(TCHAR);
            RegSetValueEx (hKey, TEXT("DCName"), 0, REG_SZ,
                           (LPBYTE) pDCI->DomainControllerName, dwSize);

            if ( ( lpGPOInfo->dwFlags & GP_MACHINE ) != 0 )
            {
                LPWSTR szTemp = szNetworkName ? szNetworkName : L"";

                dwSize = ( wcslen( szTemp ) + 1 ) * sizeof( WCHAR );
                RegSetValueEx(  hKey,
                                L"NetworkName",
                                0,
                                REG_SZ,
                               (LPBYTE) szTemp,
                               dwSize );
            }
            RegCloseKey (hKey);
        }
    }


    //
    // Read the group policy extensions from the registry
    //

    if ( !ReadGPExtensions( lpGPOInfo ) )
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: ReadGPExtensions failed.")));
        CEvents ev(TRUE, EVENT_READ_EXT_FAILED); ev.Report();
        goto Exit;
    }


    //
    // Get the user policy mode if appropriate
    //

    if (!(lpGPOInfo->dwFlags & GP_MACHINE)) {

        if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                          SYSTEM_POLICIES_KEY,
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            dwSize = sizeof(dwUserPolicyMode);
            RegQueryValueEx (hKey,
                             TEXT("UserPolicyMode"),
                             NULL,
                             &dwType,
                             (LPBYTE) &dwUserPolicyMode,
                             &dwSize);

            RegCloseKey (hKey);
        }

        if (dwUserPolicyMode > 0) {

            if (!(lpGPOInfo->dwFlags & GP_APPLY_DS_POLICY)) {
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Loopback is not allowed for downlevel or local user accounts.  Loopback will be disabled.")));
                CEvents ev(FALSE, EVENT_LOOPBACK_DISABLED1); ev.Report();
                dwUserPolicyMode = 0;
            }

            if (dwUserPolicyMode > 0) {
                if (lpGPOInfo->iMachineRole < 2) {
                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Loopback is not allowed on machines joined to a downlevel domain or running standalone.  Loopback will be disabled.")));
                    CEvents ev(TRUE, EVENT_LOOPBACK_DISABLED2); ev.Report();
                    dwUserPolicyMode = 0;
                }
            }
        }
    }
    
    
    if (!ImpersonateUser(lpGPOInfo->hToken, &hOldToken)) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to impersonate user")));
        CEvents ev(TRUE, EVENT_FAILED_IMPERSONATE);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }


    //
    // Read each of the extensions status..
    //

    if (!ReadExtStatus(lpGPOInfo)) {
        // event logged by ReadExtStatus
        xe = GetLastError();
        RevertToUser(&hOldToken);
        goto Exit;
    }


    //
    // Check if any extensions can be skipped. If there is ever a case where
    // all extensions can be skipped, then exit successfully right after this check.
    // Currently RegistryExtension is always run unless there are no GPO changes,
    // but the GPO changes check is done much later.
    //

    if ( !CheckForSkippedExtensions( lpGPOInfo, FALSE ) ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Checking extensions for skipping failed")));
        //
        // LogEvent() is called by CheckForSkippedExtensions()
        //
        RevertToUser(&hOldToken);
        goto Exit;
    }

    LPWSTR szSiteName;
    dwResult = pNetAPI32->pfnDsGetSiteName(0, &szSiteName);

    if ( dwResult != ERROR_SUCCESS )
    {
        if ( dwResult == ERROR_NO_SITENAME )
        {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs:  No site name defined.  Skipping site policy.")));

            if ( lpGPOInfo->dwFlags & GP_VERBOSE )
            {
                CEvents ev(TRUE, EVENT_NO_SITENAME);
                ev.Report();
            }
            szSiteName = 0;
        }
        else
        {
            xe = dwResult;
            CEvents ev(TRUE, EVENT_FAILED_QUERY_SITE);
            ev.AddArgWin32Error(dwResult); ev.Report();

            DebugMsg((DM_WARNING, TEXT("ProcessGPOs:  DSGetSiteName failed with %d, exiting."), dwResult));
            RevertToUser(&hOldToken);
            goto Exit;
        }
    }

    lpGPOInfo->szSiteName = szSiteName;

    //
    // Query for the GPO list based upon the mode
    //
    // 0 is normal
    // 1 is merge.  Merge user list + machine list
    // 2 is replace.  use machine list instead of user list
    //

    
    if (dwUserPolicyMode == 0) {

        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Calling GetGPOInfo for normal policy mode")));

        bResult = GetGPOInfo ((lpGPOInfo->dwFlags & GP_MACHINE) ? GPO_LIST_FLAG_MACHINE : 0,
                              lpDomainDN, lpName, NULL, &lpGPOInfo->lpGPOList,
                              &lpGPOInfo->lpSOMList,
                              &lpGPOInfo->lpGpContainerList,
                              pNetAPI32, TRUE, 0, szSiteName, 0, &locator);

        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: GetGPOInfo failed.")));
            CEvents ev(TRUE, EVENT_GPO_QUERY_FAILED); ev.Report();
        }


    } else if (dwUserPolicyMode == 2) {

        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Calling GetGPOInfo for replacement user policy mode")));

        lpComputerName = MyGetComputerName (NameFullyQualifiedDN);

        if (lpComputerName) {

            PDOMAIN_CONTROLLER_INFO pDCInfo;

            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Using computer name %s for query."), lpComputerName));

            dwResult = pNetAPI32->pfnDsGetDcName(   0,
                                                    0,
                                                    0,
                                                    0,
                                                    DS_DIRECTORY_SERVICE_REQUIRED | 
                                                    ((lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD) ? DS_BACKGROUND_ONLY : 0),
                                                    &pDCInfo);
            if ( dwResult == 0 )
            {
                bResult = GetGPOInfo (0, pDCInfo->DomainName, lpComputerName, NULL,
                                      &lpGPOInfo->lpGPOList,
                                      &lpGPOInfo->lpLoopbackSOMList,
                                      &lpGPOInfo->lpLoopbackGpContainerList,
                                      pNetAPI32, FALSE, 0, szSiteName, 0, &locator );

                if (!bResult) {
                    xe = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: GetGPOInfo failed.")));
                    CEvents ev(TRUE, EVENT_GPO_QUERY_FAILED); ev.Report();
                }

                pNetAPI32->pfnNetApiBufferFree( pDCInfo );
            }
            else
            {
                xe = dwResult;
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to get the computer domain name with %d"),
                             GetLastError()));
                CEvents ev(TRUE, EVENT_NO_MACHINE_DOMAIN);
                ev.AddArg(lpComputerName); ev.AddArgWin32Error(GetLastError()); ev.Report();
                bResult = FALSE;
            }
            LocalFree (lpComputerName);

        } else {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to get the computer name with %d"),
                         GetLastError()));

            CEvents ev(TRUE, EVENT_FAILED_MACHINENAME);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            bResult = FALSE;
        }
    } else {

        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Calling GetGPOInfo for merging user policy mode")));

        lpComputerName = MyGetComputerName (NameFullyQualifiedDN);

        if (lpComputerName) {

            lpGPOInfo->lpGPOList = NULL;
            bResult = GetGPOInfo (0, lpDomainDN, lpName, NULL,
                                  &lpGPOInfo->lpGPOList,
                                  &lpGPOInfo->lpSOMList,
                                  &lpGPOInfo->lpGpContainerList,
                                  pNetAPI32, FALSE, 0, szSiteName, 0, &locator );

            if (bResult) {

                PDOMAIN_CONTROLLER_INFO pDCInfo;

                DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Using computer name %s for query."), lpComputerName));

                lpGPO = NULL;

                dwResult = pNetAPI32->pfnDsGetDcName(   0,
                                                        0,
                                                        0,
                                                        0,
                                                        DS_DIRECTORY_SERVICE_REQUIRED |
                                                        ((lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD) ? DS_BACKGROUND_ONLY : 0),
                                                        &pDCInfo);
                if ( dwResult == 0 )
                {
                    bResult = GetGPOInfo (0, pDCInfo->DomainName, lpComputerName, NULL,
                                      &lpGPO,
                                      &lpGPOInfo->lpLoopbackSOMList,
                                      &lpGPOInfo->lpLoopbackGpContainerList,
                                      pNetAPI32, FALSE, 0, szSiteName, 0, &locator );

                    if (bResult) {

                        if (lpGPOInfo->lpGPOList && lpGPO) {

                            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Both user and machine lists are defined.  Merging them together.")));

                            //
                            // Need to merge the lists together
                            //

                            lpGPOTemp = lpGPOInfo->lpGPOList;

                            while (lpGPOTemp->pNext) {
                                lpGPOTemp = lpGPOTemp->pNext;
                            }

                            lpGPOTemp->pNext = lpGPO;

                        } else if (!lpGPOInfo->lpGPOList && lpGPO) {

                            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Only machine list is defined.")));
                            lpGPOInfo->lpGPOList = lpGPO;

                        } else {

                            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Only user list is defined.")));
                        }

                    } else {
                        xe = GetLastError();
                        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: GetGPOInfo failed for computer name.")));
                        CEvents ev(TRUE, EVENT_GPO_QUERY_FAILED); ev.Report();
                    }
                    pNetAPI32->pfnNetApiBufferFree( pDCInfo );

                }
            else
            {
                xe = dwResult;
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to get the computer domain name with %d"),
                         GetLastError()));
                CEvents ev(TRUE, EVENT_NO_MACHINE_DOMAIN);
                ev.AddArg(lpComputerName); ev.AddArgWin32Error(GetLastError()); ev.Report();
                bResult = FALSE;
            }

            } else {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: GetGPOInfo failed for user name.")));
                CEvents ev(TRUE, EVENT_GPO_QUERY_FAILED); ev.Report();
            }

            LocalFree (lpComputerName);

        } else {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to get the computer name with %d"),
                         GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_MACHINENAME);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            bResult = FALSE;
        }

    }


    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to revert to self")));
    }


    if (!bResult) {
        goto Exit;
    }

    bResult = SetupGPOFilter( lpGPOInfo );

    if (!bResult) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: SetupGPOFilter failed.")));
        CEvents ev(TRUE, EVENT_SETUP_GPOFILTER_FAILED); ev.Report();
        goto Exit;
    }

    //
    // Log Gpo info to WMI's database
    //

    //
    // Need to check if the security group membership has changed the first time around
    //

    if ( !(lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD) || (lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND) ) {

        if ((lpGPOInfo->dwFlags & GP_MACHINE) && (lpGPOInfo->dwFlags & GP_APPLY_DS_POLICY)) {


            HANDLE hLocToken=NULL;

            //
            // if it is machine policy processing, get the machine token so that we can check
            // security group membership using the right token. This causes GetMachineToken to be called twice
            // but moving it to the beginning requires too much change.
            //


            hLocToken = GetMachineToken();

            if (hLocToken) {
                CheckGroupMembership( lpGPOInfo, hLocToken, &lpGPOInfo->bMemChanged, &lpGPOInfo->bUserLocalMemChanged, &pTokenGroups);
                CloseHandle(hLocToken);
            }
            else {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs:  Failed to get the machine token with  %d"), GetLastError()));
                goto Exit;
            }
        }
        else {

            //
            // In the user case just use the token passed in
            //

            CheckGroupMembership( lpGPOInfo, lpGPOInfo->hToken, &lpGPOInfo->bMemChanged, &lpGPOInfo->bUserLocalMemChanged, &pTokenGroups);
        }
    }


    if ( lpGPOInfo->bRsopLogging )
    {
        if ( SetRsopTargetName(lpGPOInfo) )
        {
            RSOPSESSIONDATA rsopSessionData;

            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Logging Data for Target <%s>."), lpGPOInfo->szTargetName));

            //
            // fill up the rsop data
            //
            rsopSessionData.pwszTargetName = lpGPOInfo->szName;
            rsopSessionData.pwszSOM = lpGPOInfo->lpDNName ? GetSomPath( lpGPOInfo->lpDNName ) : TEXT("Local");
            rsopSessionData.pSecurityGroups = pTokenGroups;
            rsopSessionData.bLogSecurityGroup = lpGPOInfo->bMemChanged || lpGPOInfo->bUserLocalMemChanged;
            rsopSessionData.pwszSite =  lpGPOInfo->szSiteName;
            rsopSessionData.bMachine = (lpGPOInfo->dwFlags & GP_MACHINE);
            rsopSessionData.bSlowLink = bSlow;

            //
            // Fill in the current time
            //

            BOOL bStateChanged = FALSE;
            BOOL bLinkChanged  = FALSE;
            BOOL bNoState = FALSE;

            //
            // log RSoP data only when policy has changed
            //
            dwResult = ComparePolicyState( lpGPOInfo, &bLinkChanged, &bStateChanged, &bNoState );
            if ( dwResult != ERROR_SUCCESS )
            {
                DebugMsg((DM_WARNING, L"ProcessGPOs: ComparePolicyState failed %d, assuming policy changed.", dwResult ));
            }

            //
            // bStateChanged is TRUE if dwResult is not kosher
            //

            if ( bStateChanged || bNoState || bLinkChanged || (lpGPOInfo->dwFlags & GP_FORCED_REFRESH) ||
                 lpGPOInfo->bMemChanged || lpGPOInfo->bUserLocalMemChanged ) {

                //
                // Any changes get the wmi interface
                //

                lpGPOInfo->bRsopLogging = 
                            GetWbemServices( lpGPOInfo, RSOP_NS_DIAG_ROOT, FALSE, &(lpGPOInfo->bRsopCreated), &(lpGPOInfo->pWbemServices) );

                if (!lpGPOInfo->bRsopLogging)
                {
                    CEvents ev(TRUE, EVENT_FAILED_WBEM_SERVICES); ev.Report();
                }
                else 
                {
                    //
                    // all changes except link changes
                    //

                    if ( bStateChanged || bNoState || (lpGPOInfo->dwFlags & GP_FORCED_REFRESH) )
                    {
                        //
                        // treat no state as newly created
                        //

                        lpGPOInfo->bRsopCreated = (lpGPOInfo->bRsopCreated || bNoState);

                        lpGPOInfo->bRsopLogging = LogExtSessionStatus(  lpGPOInfo->pWbemServices,
                                                                        0,
                                                                        TRUE,
                                                                        lpGPOInfo->bRsopCreated || (lpGPOInfo->dwFlags & GP_FORCED_REFRESH)
                                                                        /* log the event sources only if the namespace is newly created or force refresh */
                                                                     );

                        if (!lpGPOInfo->bRsopLogging)
                        {
                            CEvents ev(TRUE, EVENT_FAILED_RSOPCORE_SESSION_STATUS); ev.AddArgWin32Error(GetLastError()); ev.Report();
                        }
                        else
                        {   
                            bResult = LogRsopData( lpGPOInfo, &rsopSessionData );

                            if (!bResult)
                            {
                                CEvents ev(TRUE, EVENT_RSOP_FAILED); ev.Report();

                                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Error when logging Rsop data. Continuing.")));
                                lpGPOInfo->bRsopLogging = FALSE;
                            }
                            else
                            {
                                DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Logged Rsop Data successfully.")));            
                                //
                                // save state only when policy has changed and RSoP logging is successful
                                //
                                dwResult = SavePolicyState( lpGPOInfo );
                                if ( dwResult != ERROR_SUCCESS )
                                {
                                    DebugMsg((DM_WARNING, L"ProcessGPOs: SavePolicyState failed %d.", dwResult ));
                                }
                            }
                        }
                    }
                    else if ( bLinkChanged || lpGPOInfo->bMemChanged || lpGPOInfo->bUserLocalMemChanged )
                    {
                        bResult = LogSessionData( lpGPOInfo, &rsopSessionData );
                        if (!bResult)
                        {
                            CEvents ev(TRUE, EVENT_RSOP_FAILED); ev.Report();

                            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Error when logging Rsop session. Continuing.")));
                            lpGPOInfo->bRsopLogging = FALSE;
                        }
                        else
                        {
                            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Logged Rsop Session successfully.")));            
                            //
                            // save state only when policy has changed and RSoP logging is successful
                            //
                            dwResult = SaveLinkState( lpGPOInfo );
                            if ( dwResult != ERROR_SUCCESS )
                            {
                                DebugMsg((DM_WARNING, L"ProcessGPOs: SaveLinkState failed %d.", dwResult ));
                            }
                        }
                    }
                }
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Error querying for targetname. not logging Gpos.Error = %d"), GetLastError()));
        }
    }


    DebugPrintGPOList( lpGPOInfo );

    //================================================================
    //
    // Now walk through the list of extensions
    //
    //================================================================

    EnterCriticalSection( &g_GPOCS );

    pGPHandle = (LPGPINFOHANDLE) LocalAlloc( LPTR, sizeof(GPINFOHANDLE) );

    //
    // Continue even if pGPHandle is 0, because all it means is that async completions (if any)
    // will fail. Remove old asynch completion context.
    //

    if ( pGPHandle )
        pGPHandle->pGPOInfo = lpGPOInfo;

    if ( lpGPOInfo->dwFlags & GP_MACHINE ) {
        if ( g_pMachGPInfo )
            LocalFree( g_pMachGPInfo );

        g_pMachGPInfo = pGPHandle;
    } else {
        if ( g_pUserGPInfo )
            LocalFree( g_pUserGPInfo );

        g_pUserGPInfo = pGPHandle;
    }

    LeaveCriticalSection( &g_GPOCS );

    pAsyncHandle = (ASYNCCOMPLETIONHANDLE) pGPHandle;

    dwCurrentTime = GetCurTime();

    lpExt = lpGPOInfo->lpExtensions;

    //
    // Before going in, get the thread token and reset the thread token in case
    // one of the extensions hit an exception.
    //

    if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ,
                          TRUE, &hOldToken)) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: OpenThreadToken failed with error %d, assuming thread is not impersonating"), GetLastError()));
        hOldToken = NULL;
    }

    while ( lpExt )
    {
        BOOL bProcessGPOs, bNoChanges, bUsePerUserLocalSetting;
        PGROUP_POLICY_OBJECT pDeletedGPOList;
        DWORD dwRet;
        HRESULT hrCSERsopStatus = S_OK;
        GPEXTSTATUS  gpExtStatus;

        //
        // Check for early shutdown or user logoff
        //
        if ( (lpGPOInfo->dwFlags & GP_MACHINE) && g_bStopMachGPOProcessing
             || !(lpGPOInfo->dwFlags & GP_MACHINE) && g_bStopUserGPOProcessing ) {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Aborting GPO processing due to machine shutdown or logoff")));
            CEvents ev(TRUE, EVENT_GPO_PROC_STOPPED); ev.Report();
            break;

        }

        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: -----------------------")));
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Processing extension %s"),
                 lpExt->lpDisplayName));

        //
        // The extension has not gotten skipped at this point
        //
        bUsePerUserLocalSetting = lpExt->dwUserLocalSetting && !(lpGPOInfo->dwFlags & GP_MACHINE);

        //
        // read the CSEs status
        //
        ReadStatus( lpExt->lpKeyName,
                    lpGPOInfo,
                    bUsePerUserLocalSetting ? lpGPOInfo->lpwszSidUser : 0,
                    &gpExtStatus );


        //
        // Reset lpGPOInfo->lpGPOList based on extension filter list. If the extension
        // is being called to do delete processing on the history then the current GpoList
        // is null.
        //

        if ( lpExt->bHistoryProcessing )
        {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Extension %s is being called to do delete processing on cached history."),
                      lpExt->lpDisplayName));
            lpGPOInfo->lpGPOList = NULL;
        }
        else
            FilterGPOs( lpExt, lpGPOInfo );

        DebugPrintGPOList( lpGPOInfo );

        if ( !CheckGPOs( lpExt, lpGPOInfo, dwCurrentTime,
                         &bProcessGPOs, &bNoChanges, &pDeletedGPOList ) )
        {
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: CheckGPOs failed.")));
            lpExt = lpExt->pNext;
            continue;
        }

        if ( lpExt->dwNoBackgroundPolicy && ( lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD ) )
        {
            if ( bProcessGPOs && ( pDeletedGPOList || lpGPOInfo->lpGPOList || lpExt->bRsopTransition ) )
            {
                info.mode = GP_ModeSyncForeground;
                info.reason = GP_ReasonCSERequiresSync;
            }
        }

        if ( lpExt->bSkipped )
        {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Extension %s skipped with flags 0x%x."),
                      lpExt->lpDisplayName, lpGPOInfo->dwFlags));
            if (lpGPOInfo->dwFlags & GP_VERBOSE)
            {
                CEvents ev(FALSE, EVENT_EXT_SKIPPED);
                ev.AddArg(lpExt->lpDisplayName); ev.AddArgHex(lpGPOInfo->dwFlags); ev.Report();
            }

            lpExt = lpExt->pNext;
            continue;
        }

        if ( bProcessGPOs )
        {
            if ( !pDeletedGPOList && !lpGPOInfo->lpGPOList && !lpExt->bRsopTransition )
            {
                DebugMsg((DM_VERBOSE,
                         TEXT("ProcessGPOs: Extension %s skipped because both deleted and changed GPO lists are empty."),
                         lpExt->lpDisplayName ));
                if (lpGPOInfo->dwFlags & GP_VERBOSE)
                {
                    CEvents ev(FALSE, EVENT_EXT_HAS_EMPTY_LISTS);
                    ev.AddArg(lpExt->lpDisplayName); ev.Report();
                }

                lpExt = lpExt->pNext;
                continue;
            }

            if ( !(lpExt->bForcedRefreshNextFG) )
            {
                if ( lpExt->dwEnableAsynch )
                {
                    //
                    // Save now to shadow area to avoid race between thread that returns from
                    // ProcessGPOList and the thread that does ProcessGroupPolicyCompleted and
                    // reads from shadow area.
                    //
                    SaveGPOList( lpExt->lpKeyName, lpGPOInfo,
                                 HKEY_LOCAL_MACHINE,
                                 bUsePerUserLocalSetting ? lpGPOInfo->lpwszSidUser : NULL,
                                 TRUE, lpGPOInfo->lpGPOList );
                }

                dwRet = E_FAIL;

                __try
                {
                    dwRet = ProcessGPOList( lpExt, lpGPOInfo, pDeletedGPOList,
                                            lpGPOInfo->lpGPOList, bNoChanges, pAsyncHandle, &hrCSERsopStatus );
                }
                __except( GPOExceptionFilter( GetExceptionInformation() ) )
                {

                    SetThreadToken(NULL, hOldToken);

                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Extension %s ProcessGroupPolicy threw unhandled exception 0x%x."),
                                lpExt->lpDisplayName, GetExceptionCode() ));

                    CEvents ev(TRUE, EVENT_CAUGHT_EXCEPTION);
                    ev.AddArg(lpExt->lpDisplayName); ev.AddArgHex(GetExceptionCode()); ev.Report();
                }

                SetThreadToken(NULL, hOldToken);

                FreeGPOList( pDeletedGPOList );
                pDeletedGPOList = NULL;


                if ( dwRet == ERROR_SUCCESS || dwRet == ERROR_OVERRIDE_NOCHANGES )
                {
                    //
                    // ERROR_OVERRIDE_NOCHANGES means that extension processed the list and so the cached list
                    // must be updated, but the extension will be called the next time even if there are
                    // no changes. Duplicate the saved data in the PerUserLocalSetting case to allow for deleted
                    // GPO information to be generated from a combination of HKCU and HKLM\{sid-user} data.
                    //

                    SaveGPOList( lpExt->lpKeyName, lpGPOInfo,
                                 HKEY_LOCAL_MACHINE,
                                 NULL,
                                 FALSE, lpGPOInfo->lpGPOList );

                    if ( bUsePerUserLocalSetting )
                    {
                        SaveGPOList( lpExt->lpKeyName, lpGPOInfo,
                                     HKEY_LOCAL_MACHINE,
                                     lpGPOInfo->lpwszSidUser,
                                     FALSE, lpGPOInfo->lpGPOList );
                    }
                    uExtensionCount++;

                    //
                    // the CSE required sync foreground previously and now returned ERROR_OVERRIDE_NOCHANGES,
                    // maintain the require sync foreground refresh flag
                    //
                    if ( gpExtStatus.dwStatus == ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED &&
                            dwRet == ERROR_OVERRIDE_NOCHANGES )
                    {
                        info.mode = GP_ModeSyncForeground;
                        info.reason = GP_ReasonCSESyncError;
                    }
                }
                else if ( dwRet == E_PENDING )
                {
                    DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Extension %s ProcessGroupPolicy returned e_pending."),
                              lpExt->lpDisplayName));
                }
                else if ( dwRet == ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED )
                {
                    //
                    // a CSE returned ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED.
                    // Raise a flag to sync foreground refresh.
                    //
                    info.mode = GP_ModeSyncForeground;
                    info.reason = GP_ReasonCSERequiresSync;
                    DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Extension %s ProcessGroupPolicy returned sync_foreground."),
                              lpExt->lpDisplayName));
                    if ( lpGPOInfo->dwFlags & GP_FORCED_REFRESH )
                    {
                        bForceNeedFG = TRUE;
                    }
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Extension %s ProcessGroupPolicy failed, status 0x%x."),
                              lpExt->lpDisplayName, dwRet));
                    if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                        CEvents ev(FALSE, EVENT_CHANGES_FAILED);
                        ev.AddArg(lpExt->lpDisplayName); ev.AddArgWin32Error(dwRet); ev.Report();
                    }

                    //
                    // the CSE required foreground previously and now returned an error,
                    // maintain the require sync foreground refresh flag
                    //
                    if ( gpExtStatus.dwStatus == ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED )
                    {
                        info.mode = GP_ModeSyncForeground;
                        info.reason = GP_ReasonCSESyncError;
                    }
                }

                //
                // Fill up the status data.
                //
                ZeroMemory( &gpExtStatus, sizeof(gpExtStatus) );
                gpExtStatus.dwSlowLink = (lpGPOInfo->dwFlags & GP_SLOW_LINK) != 0;
                gpExtStatus.dwRsopLogging = lpGPOInfo->bRsopLogging;
                gpExtStatus.dwStatus = dwRet;
                gpExtStatus.dwTime = dwCurrentTime;
                gpExtStatus.bForceRefresh = bForceNeedFG;
                gpExtStatus.dwRsopStatus = hrCSERsopStatus;

                WriteStatus(lpExt->lpKeyName,
                            lpGPOInfo,
                            bUsePerUserLocalSetting ? lpGPOInfo->lpwszSidUser : NULL,
                            &gpExtStatus);
            }
            else
            {
                //
                // if it is force refresh next time around, all we need to do is readstatus and 
                // writestatus back with forcerefresh value set.
                //
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Extensions %s needs to run in ForeGround. Skipping after setting forceflag."),
                          lpExt->lpDisplayName));
                          
                if ( gpExtStatus.bStatus )
                {
                    gpExtStatus.bForceRefresh = TRUE;
                    
                    WriteStatus( lpExt->lpKeyName, lpGPOInfo, 
                                bUsePerUserLocalSetting ? lpGPOInfo->lpwszSidUser : NULL, 
                                &gpExtStatus );
                        
                }
                else
                {
                    //
                    // We can ignore this because absence of a status automatically means processing
                    //
                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Couldn't read status data for %s. Error %d. ignoring.. "),
                              lpExt->lpDisplayName, GetLastError()));
                }

                //
                // There is a policy that can only be force refreshed in foreground
                //
                bForceNeedFG = TRUE;
            }
        }
                
        //
        // Process next extension
        //
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: -----------------------")));
        lpExt = lpExt->pNext;
    }

    if ( hOldToken )
    {
       CloseHandle(hOldToken);
    }

    //================================================================
    //
    // Success
    //
    //================================================================
    bRetVal = TRUE;

Exit:
    //
    // change engine modes only if there is no error
    //
    if ( bRetVal )
    {
        //
        // if policy sez sync. mark it sync
        //
        if ( GetFgPolicySetting( HKEY_LOCAL_MACHINE ) )
        {
            info.mode = GP_ModeSyncForeground;
            info.reason = GP_ReasonSyncPolicy;
        }

        //
        // async only on Pro
        //
        OSVERSIONINFOEXW version;
        version.dwOSVersionInfoSize = sizeof(version);
        if ( !GetVersionEx( (LPOSVERSIONINFO) &version ) )
        {
            //
            // conservatively assume non Pro SKU
            //
            info.mode = GP_ModeSyncForeground;
            info.reason = GP_ReasonSKU;
        }
        else
        {
            if ( version.wProductType != VER_NT_WORKSTATION )
            {
                //
                // force sync refresh on non Pro SKU
                //
                info.mode = GP_ModeSyncForeground;
                info.reason = GP_ReasonSKU;
            }
        }

        if ( !( lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD ) || ( lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND ) )
        {
            //
            // set the previous info only in the foreground refreshes
            //
            LPWSTR szSid = lpGPOInfo->dwFlags & GP_MACHINE ? 0 : lpGPOInfo->lpwszSidUser;
            FgPolicyRefreshInfo curInfo = { GP_ReasonUnknown, GP_ModeUnknown };
            if ( GetCurrentFgPolicyRefreshInfo( szSid, &curInfo ) != ERROR_SUCCESS )
            {
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: GetCurrentFgPolicyRefreshInfo failed.")));
            }
            else
            {
                if (  lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND )
                {
                    curInfo.mode = GP_ModeAsyncForeground;
                }
                else
                {
                    curInfo.mode = GP_ModeSyncForeground;
                }

                if ( SetPreviousFgPolicyRefreshInfo( szSid, curInfo ) != ERROR_SUCCESS )
                {
                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: SetPreviousFgPolicyRefreshInfo failed.") ));
                }
            }
        }

        if ( info.mode == GP_ModeSyncForeground )
        {
            //
            // need sync foreground, set in all refreshes
            //
            LPWSTR szSid = lpGPOInfo->dwFlags & GP_MACHINE ? 0 : lpGPOInfo->lpwszSidUser;
            if ( SetNextFgPolicyRefreshInfo( szSid, info ) != ERROR_SUCCESS )
            {
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: SetNextFgPolicyRefreshInfo failed.")));
            }
        }
        else if ( info.mode == GP_ModeAsyncForeground )
        {
            //
            // sync foreground policy successfully applied, nobody needs sync foreground,
            // reset the GP_ModeSyncForeground only in the async foreground and background
            // refreshes
            //
            LPWSTR szSid = lpGPOInfo->dwFlags & GP_MACHINE ? 0 : lpGPOInfo->lpwszSidUser;
            if ( !( lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD ) &&
                    !( lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND ) )
            {
                if ( SetNextFgPolicyRefreshInfo( szSid, info ) != ERROR_SUCCESS )
                {
                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: SetNextFgPolicyRefreshInfo failed.")));
                }
            }
        }
    }
    
    if ( !lpGPOInfo->pWbemServices )
    {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: No WMI logging done in this policy cycle.")));
    }

    if (!bRetVal)
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Processing failed with error %d."), (DWORD)(xe)));

    GetSystemTimeAsFileTime(&gpCoreStatus.ftEndTime);
    gpCoreStatus.bValid = TRUE;
    gpCoreStatus.dwStatus = bRetVal ? 
                               ERROR_SUCCESS: 
                               ((xe ==ERROR_SUCCESS) ? E_FAIL : xe);

    // if rsop logging is not supported gp core status will appear dirty
    gpCoreStatus.dwLoggingStatus = RsopLoggingEnabled() ? ((lpGPOInfo->bRsopLogging) ? S_OK : E_FAIL) : HRESULT_FROM_WIN32(ERROR_CANCELLED);

    
    // No point in checking for error code here. 
    // The namespace is marked dirty. Diagnostic mode provider should expect all
    // values here or mark the namespace dirty.

    
    if ((lpGPOInfo->dwFlags & GP_MACHINE) || (lpGPOInfo->lpwszSidUser)) {

        SaveLoggingStatus(
                          (lpGPOInfo->dwFlags & GP_MACHINE) ? NULL : (lpGPOInfo->lpwszSidUser),
                          NULL, &gpCoreStatus);
    }
        
    //
    // Unload the Group Policy Extensions
    //

    UnloadGPExtensions (lpGPOInfo);

    FreeLists( lpGPOInfo );

    lpGPOInfo->lpGPOList = NULL;
    lpGPOInfo->lpExtFilterList = NULL;

    if (szNetworkName) {
        LocalFree (szNetworkName );
        szNetworkName = NULL;
    }

    FreeSOMList( lpGPOInfo->lpSOMList );
    FreeSOMList( lpGPOInfo->lpLoopbackSOMList );
    FreeGpContainerList( lpGPOInfo->lpGpContainerList );
    FreeGpContainerList( lpGPOInfo->lpLoopbackGpContainerList );

    if ( lpGPOInfo->szSiteName )
    {
        pNetAPI32->pfnNetApiBufferFree(lpGPOInfo->szSiteName);
        lpGPOInfo->szSiteName = 0;
    }

    lpGPOInfo->lpSOMList = NULL;
    lpGPOInfo->lpLoopbackSOMList = NULL;
    lpGPOInfo->lpGpContainerList = NULL;
    lpGPOInfo->lpLoopbackGpContainerList = NULL;
    lpGPOInfo->bRsopCreated = FALSE; // reset this to false always.
                                     // we will know in the next iteration

    ReleaseWbemServices( lpGPOInfo );

    //
    // Token groups can change only at logon time, so reset to false
    //

    lpGPOInfo->bMemChanged = FALSE;
    lpGPOInfo->bUserLocalMemChanged = FALSE;

    //
    // We migrate the policy data from old sid only at logon time.
    // reset it to false.
    //

    lpGPOInfo->bSidChanged = FALSE;

    if (pDCI) {
        pNetAPI32->pfnNetApiBufferFree(pDCI);
    }

    lpGPOInfo->lpDNName = 0;
    if (lpName) {
        LocalFree (lpName);
    }

    if (lpDomain) {
        LocalFree (lpDomain);
    }

    if (pTokenGroups) {
        LocalFree(pTokenGroups);
        pTokenGroups = NULL;
    }

    //
    // Release the critical section
    //

    if (lpGPOInfo->hCritSection) {
        LeaveCriticalPolicySection (lpGPOInfo->hCritSection);
        lpGPOInfo->hCritSection = NULL;
    }


    //
    // Announce that policies have changed
    //

    if (bRetVal) {

        //
        // This needs to be set before NotifyEvent
        //

        if (bForceNeedFG)
        {
            info.reason = GP_ReasonSyncForced;
            info.mode = GP_ModeSyncForeground;
            LPWSTR szSid = lpGPOInfo->dwFlags & GP_MACHINE ? 0 : lpGPOInfo->lpwszSidUser;
            if ( SetNextFgPolicyRefreshInfo( szSid, info ) != ERROR_SUCCESS )
            {
                DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: SetNextFgPolicyRefreshInfo failed.")));
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Forced option changed policy mode.")));
            }

            DmAssert(lpGPOInfo->dwFlags & GP_FORCED_REFRESH);
            SetEvent(lpGPOInfo->hNeedFGEvent);
        }

        if (uExtensionCount) {

            //
            // First, update User with new colors, bitmaps, etc.
            //

            if (lpGPOInfo->dwFlags & GP_REGPOLICY_CPANEL) {

                //
                // Something has changed in the control panel section
                // Start control.exe with the /policy switch so the
                // display is refreshed.
                //

                RefreshDisplay (lpGPOInfo);
            }


            //
            // Notify anyone waiting on an event handle
            //

            if (lpGPOInfo->hNotifyEvent) {
                PulseEvent (lpGPOInfo->hNotifyEvent);
            }            
        

            //
            // Create a thread to broadcast the WM_SETTINGCHANGE message
            //

            // copy the data to another structure so that this thread can safely free its structures

            LPPOLICYCHANGEDINFO   lpPolicyChangedInfo;

            lpPolicyChangedInfo = (LPPOLICYCHANGEDINFO)LocalAlloc(LPTR, sizeof(POLICYCHANGEDINFO));

            if (lpPolicyChangedInfo)
            {
                HANDLE  hProc;
                BOOL    bDupSucceeded = TRUE;

                lpPolicyChangedInfo->bMachine = (lpGPOInfo->dwFlags & GP_MACHINE) ? 1 : 0;

                if (!(lpPolicyChangedInfo->bMachine))
                {
                    hProc = GetCurrentProcess();

                    if( hProc == NULL ) {
                        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to get process handle with error (%d)."), GetLastError()));
                        bDupSucceeded = FALSE;
                    }

                    if (bDupSucceeded && 
                        (!DuplicateHandle(
                                      hProc,                        // Source of the handle 
                                      lpGPOInfo->hToken,            // Source handle
                                      hProc,                        // Target of the handle
                                      &(lpPolicyChangedInfo->hToken),  // Target handle
                                      0,                            // ignored since  DUPLICATE_SAME_ACCESS is set
                                      FALSE,                        // no inherit on the handle
                                      DUPLICATE_SAME_ACCESS
                                      ))) {
                        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to open duplicate token handle with error (%d)."), GetLastError()));
                        bDupSucceeded = FALSE;
                    }
                }

                if (bDupSucceeded) {
                    hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE) PolicyChangedThread,
                                            (LPVOID) lpPolicyChangedInfo,
                                            CREATE_SUSPENDED, &dwThreadID);

                    if (hThread) {
                        SetThreadPriority (hThread, THREAD_PRIORITY_IDLE);
                        ResumeThread (hThread);
                        CloseHandle (hThread);

                    } else {
                        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to create background thread (%d)."),
                                 GetLastError()));

                        // free the resources if the thread didn't get launched
                        if (!(lpPolicyChangedInfo->bMachine)) {
                            if (lpPolicyChangedInfo->hToken) {
                                CloseHandle(lpPolicyChangedInfo->hToken);
                                lpPolicyChangedInfo->hToken = NULL;
                            }
                        }

                        LocalFree(lpPolicyChangedInfo);
                    }
                }
                else {
                    LocalFree(lpPolicyChangedInfo);
                }
            }
            else {
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to allocate memory for policy changed structure with %d."), GetLastError()));
            }
        }
    }

    if (lpGPOInfo->dwFlags & GP_VERBOSE) {
        if (lpGPOInfo->dwFlags & GP_MACHINE) {
            CEvents ev(FALSE, EVENT_MACHINE_POLICY_APPLIED); ev.Report();
        } else {
            CEvents ev(FALSE, EVENT_USER_POLICY_APPLIED); ev.Report();
        }
    }

    if (lpGPOInfo->hDoneEvent) {
        PulseEvent (lpGPOInfo->hDoneEvent);
    }            
    
    if (lpGPOInfo->dwFlags & GP_MACHINE) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Computer Group Policy has been applied.")));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: User Group Policy has been applied.")));
    }

    DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Leaving with %d."), bRetVal));

    return bRetVal;
}

//*************************************************************
//
//  PolicyChangedThread()
//
//  Purpose:    Sends the WM_SETTINGCHANGE message announcing
//              that policy has changed.  This is done on a
//              separate thread because this could take many
//              seconds to succeed if an application is hung
//
//  Parameters: lpPolicyChangedInfo - GPO info
//
//  Return:     0
//
//*************************************************************

DWORD WINAPI PolicyChangedThread (LPPOLICYCHANGEDINFO lpPolicyChangedInfo)
{
    HINSTANCE hInst;
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    HANDLE hOldToken = NULL;
    XLastError  xe;


    hInst = LoadLibrary (TEXT("userenv.dll"));       

    DebugMsg((DM_VERBOSE, TEXT("PolicyChangedThread: Calling UpdateUser with %d."), lpPolicyChangedInfo->bMachine));

    // impersonate and update system parameter if it is not machine
    if (!(lpPolicyChangedInfo->bMachine)) {
        if (!ImpersonateUser(lpPolicyChangedInfo->hToken, &hOldToken))
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("PolicyChangedThread: Failed to impersonate user")));
            goto Exit;
        }

        if (!UpdatePerUserSystemParameters(NULL, UPUSP_POLICYCHANGE)) {
            DebugMsg((DM_WARNING, TEXT("PolicyChangedThread: UpdateUser failed with %d."), GetLastError()));
            // ignoring error and continuing the next notifications
        }

        if (!RevertToUser(&hOldToken)) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("PolicyChangedThread: Failed to revert user")));
            goto Exit;
        }
    }


    DebugMsg((DM_VERBOSE, TEXT("PolicyChangedThread: Broadcast message for %d."), lpPolicyChangedInfo->bMachine));

    //
    // Broadcast the WM_SETTINGCHANGE message
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    if ( NT_SUCCESS(Status) )
    {
        DWORD dwBSM = BSM_ALLDESKTOPS | BSM_APPLICATIONS;

        BroadcastSystemMessage (BSF_IGNORECURRENTTASK | BSF_FORCEIFHUNG,
                                &dwBSM,
                                WM_SETTINGCHANGE,
                                lpPolicyChangedInfo->bMachine, (LPARAM) TEXT("Policy"));

        RtlAdjustPrivilege(SE_TCB_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
    }

    DebugMsg((DM_VERBOSE, TEXT("PolicyChangedThread: Leaving")));

Exit:
    if (!(lpPolicyChangedInfo->bMachine)) {
        if (lpPolicyChangedInfo->hToken) {
            CloseHandle(lpPolicyChangedInfo->hToken);
            lpPolicyChangedInfo->hToken = NULL;
        }
    }

    LocalFree(lpPolicyChangedInfo);

    FreeLibraryAndExitThread (hInst, 0);

    return 0;
}


//*************************************************************
//
//  GetCurTime()
//
//  Purpose:    Returns current time in minutes, or 0 if there
//              is a failure
//
//*************************************************************

DWORD GetCurTime()
{
    DWORD dwCurTime = 0;
    LARGE_INTEGER liCurTime;

    if ( NT_SUCCESS( NtQuerySystemTime( &liCurTime) ) ) {

        if ( RtlTimeToSecondsSince1980 ( &liCurTime, &dwCurTime) ) {

            dwCurTime /= 60;   // seconds to minutes
        }
    }

    return dwCurTime;
}



//*************************************************************
//
//  LoadGPExtension()
//
//  Purpose:    Loads a GP extension.
//
//  Parameters: lpExt -- GP extension
//              bRsopPlanningMode -- Is this during Rsop planning mode ?
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL LoadGPExtension( LPGPEXT lpExt, BOOL bRsopPlanningMode )
{
    XLastError xe;

    if ( !lpExt->bRegistryExt && lpExt->hInstance == NULL )
    {
        lpExt->hInstance = LoadLibrary( lpExt->lpDllName );
        if ( lpExt->hInstance )
        {
            if ( lpExt->bNewInterface )
            {
                lpExt->pEntryPointEx = (PFNPROCESSGROUPPOLICYEX)GetProcAddress(lpExt->hInstance,
                                                                               lpExt->lpFunctionName);
                if ( lpExt->pEntryPointEx == NULL )
                {
                    xe = GetLastError();
                    DebugMsg((DM_WARNING,
                              TEXT("LoadGPExtension: Failed to query ProcessGroupPolicyEx function entry point in dll <%s> with %d"),
                              lpExt->lpDllName, GetLastError()));
                    CEvents ev(TRUE, EVENT_EXT_FUNCEX_FAIL);
                    ev.AddArg(lpExt->lpDllName); ev.Report();

                    return FALSE;
                }
            }
            else
            {
                lpExt->pEntryPoint = (PFNPROCESSGROUPPOLICY)GetProcAddress(lpExt->hInstance,
                                                                           lpExt->lpFunctionName);
                if ( lpExt->pEntryPoint == NULL )
                {
                    xe = GetLastError();
                    DebugMsg((DM_WARNING,
                              TEXT("LoadGPExtension: Failed to query ProcessGroupPolicy function entry point in dll <%s> with %d"),
                              lpExt->lpDllName, GetLastError()));
                    CEvents ev(TRUE, EVENT_EXT_FUNC_FAIL);
                    ev.AddArg(lpExt->lpDllName); ev.Report();

                    return FALSE;
                }
            }

            if ( bRsopPlanningMode ) {

                if ( lpExt->lpRsopFunctionName ) {

                    lpExt->pRsopEntryPoint = (PFNGENERATEGROUPPOLICY)GetProcAddress(lpExt->hInstance,
                                                                                    lpExt->lpRsopFunctionName);
                    if ( lpExt->pRsopEntryPoint == NULL )
                    {
                        xe = GetLastError();
                        DebugMsg((DM_WARNING,
                                  TEXT("LoadGPExtension: Failed to query GenerateGroupPolicy function entry point in dll <%s> with %d"),
                                  lpExt->lpDllName, GetLastError()));
                        
                        CEvents ev(TRUE, EVENT_EXT_FUNCRSOP_FAIL);
                        ev.AddArg(lpExt->lpDisplayName); ev.AddArg(lpExt->lpDllName); ev.Report();

                        return FALSE;
                    }

                } else {

                    xe = ERROR_PROC_NOT_FOUND;
                    DebugMsg((DM_WARNING,
                              TEXT("LoadGPExtension: Failed to find Rsop entry point in dll <%s>"), lpExt->lpDllName ));
                    return FALSE;
                }
            }
        }
        else
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LoadGPExtension: Failed to load dll <%s> with %d"),
                      lpExt->lpDllName, GetLastError()));
            CEvents ev(TRUE, EVENT_EXT_LOAD_FAIL);
            ev.AddArg(lpExt->lpDllName); ev.AddArgWin32Error(GetLastError()); ev.Report();

            return FALSE;
        }
    }

    return TRUE;
}

//*************************************************************
//
//  UnloadGPExtensions()
//
//  Purpose:    Unloads the Group Policy extension dlls
//
//  Parameters: lpGPOInfo   -   GP Information
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL UnloadGPExtensions (LPGPOINFO lpGPOInfo)
{
    if ( !lpGPOInfo )
    {
        return TRUE;
    }

    LPGPEXT lpExt, lpTemp;
    lpExt = lpGPOInfo->lpExtensions;

    while ( lpExt )
    {
        lpTemp = lpExt->pNext;

        if ( lpExt->hInstance )
        {
            FreeLibrary( lpExt->hInstance );
        }
        
        if ( lpExt->szEventLogSources )
        {
            LocalFree( lpExt->szEventLogSources );
        }
        if (lpExt->lpPrevStatus)
        {
            LocalFree(lpExt->lpPrevStatus);
        }

        LocalFree( lpExt );
        lpExt = lpTemp;
    }

    lpGPOInfo->lpExtensions = 0;

    return TRUE;
}

//*************************************************************
//
//  ProcessGPOList()
//
//  Purpose:    Calls client side extensions to process gpos
//
//  Parameters: lpExt           - GP extension
//              lpGPOInfo       - GPT Information
//              pDeletedGPOList - Deleted GPOs
//              pChangedGPOList - New/changed GPOs
//              bNoChanges      - True if there are no GPO changes
//                                  and GPO processing is forced
//              pAsyncHandle    - Context for async completion
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

DWORD ProcessGPOList (LPGPEXT lpExt,
                      LPGPOINFO lpGPOInfo,
                      PGROUP_POLICY_OBJECT pDeletedGPOList,
                      PGROUP_POLICY_OBJECT pChangedGPOList,
                      BOOL bNoChanges, ASYNCCOMPLETIONHANDLE pAsyncHandle,
                      HRESULT *phrRsopStatus )
{
    LPTSTR lpGPTPath, lpDSPath;
    INT iStrLen;
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwFlags = 0;
    PGROUP_POLICY_OBJECT lpGPO;
    TCHAR szStatusFormat[50];
    TCHAR szVerbose[100];
    DWORD dwSlowLinkCur = (lpGPOInfo->dwFlags & GP_SLOW_LINK) != 0;
    IWbemServices *pLocalWbemServices;
    HRESULT        hr2 = S_OK;

    *phrRsopStatus=S_OK;


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: Entering for extension %s"), lpExt->lpDisplayName));

    if (lpGPOInfo->pStatusCallback) {
        LoadString (g_hDllInstance, IDS_CALLEXTENSION, szStatusFormat, ARRAYSIZE(szStatusFormat));
        wsprintf (szVerbose, szStatusFormat, lpExt->lpDisplayName);
        lpGPOInfo->pStatusCallback(TRUE, szVerbose);
    }

    if (lpGPOInfo->dwFlags & GP_MACHINE) {
        dwFlags |= GPO_INFO_FLAG_MACHINE;
    }

    if (lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD)
    {
        dwFlags |= GPO_INFO_FLAG_BACKGROUND;
    }

    if ( lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND )
    {
        dwFlags |= GPO_INFO_FLAG_ASYNC_FOREGROUND;
    }

    if (lpGPOInfo->dwFlags & GP_SLOW_LINK) {
        dwFlags |= GPO_INFO_FLAG_SLOWLINK;
    }

    if ( dwSlowLinkCur != lpExt->lpPrevStatus->dwSlowLink ) {
        dwFlags |= GPO_INFO_FLAG_LINKTRANSITION;
    }

    if (lpGPOInfo->dwFlags & GP_VERBOSE) {
        dwFlags |= GPO_INFO_FLAG_VERBOSE;
    }

    if ( bNoChanges ) {
        dwFlags |= GPO_INFO_FLAG_NOCHANGES;
    }

    //
    // flag safe mode boot to CSE so that they can made a decision
    // whether or not to apply policy
    //
    if ( GetSystemMetrics( SM_CLEANBOOT ) )
    {
        dwFlags |= GPO_INFO_FLAG_SAFEMODE_BOOT;
    }

    if (lpExt->bRsopTransition) {
        dwFlags |= GPO_INFO_FLAG_LOGRSOP_TRANSITION;
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: Passing in the rsop transition flag to Extension %s"),
                  lpExt->lpDisplayName));
    }


    if ( (lpGPOInfo->dwFlags & GP_FORCED_REFRESH) || 
           ((!(lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD)) && (lpExt->lpPrevStatus->bForceRefresh))) {

        dwFlags |= GPO_INFO_FLAG_FORCED_REFRESH;
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: Passing in the force refresh flag to Extension %s"),
                  lpExt->lpDisplayName));
    }   

    //
    // if it is rsop transition or changes case get the intf ptr
    //

    if ( (lpGPOInfo->bRsopLogging) && 
         ((lpExt->bRsopTransition) || (!bNoChanges) || (dwFlags & GPO_INFO_FLAG_FORCED_REFRESH)) ) {
        
        if (!(lpGPOInfo->pWbemServices) ) {
            BOOL    bCreated;

            //
            // Note that this code shouldn't be creating a namespace ever..
            //

            if (!GetWbemServices(lpGPOInfo, RSOP_NS_DIAG_ROOT, FALSE, NULL, &(lpGPOInfo->pWbemServices))) {
                DebugMsg((DM_WARNING, TEXT("ProcessGPOList: Couldn't get the wbemservices intf pointer")));
                lpGPOInfo->bRsopLogging = FALSE;
                hr2 = *phrRsopStatus = E_FAIL;
            }
        }
        
        pLocalWbemServices = lpGPOInfo->pWbemServices;
    }
    else {
        pLocalWbemServices = NULL;
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: No changes. CSE will not be passed in the IwbemServices intf ptr")));
    }
    
    dwRet = ERROR_SUCCESS;

    if ( lpExt->bRegistryExt )
    {
        //
        // Registry pseudo extension.
        //


        //
        // Log the extension specific status
        //
        
        if (pLocalWbemServices) {
            lpGPOInfo->bRsopLogging = LogExtSessionStatus(  pLocalWbemServices,
                                                            lpExt,
                                                            TRUE,
                                                            (lpExt->bRsopTransition || (dwFlags & GPO_INFO_FLAG_FORCED_REFRESH)
                                                            || (!bNoChanges)));        


            if (!lpGPOInfo->bRsopLogging) {
                hr2 = E_FAIL;
            }
        }

        if (!ProcessGPORegistryPolicy (lpGPOInfo, pChangedGPOList, phrRsopStatus)) {
            DebugMsg((DM_WARNING, TEXT("ProcessGPOList: ProcessGPORegistryPolicy failed.")));
            dwRet = E_FAIL;
        }

    } else {    // if lpExt->bRegistryExt

        //
        // Regular extension
        //

        BOOL *pbAbort;
        ASYNCCOMPLETIONHANDLE pAsyncHandleTemp;

        if ( lpExt->dwRequireRegistry ) {

            GPEXTSTATUS gpExtStatus;

            ReadStatus( c_szRegistryExtName, lpGPOInfo, NULL, &gpExtStatus );

            if ( !gpExtStatus.bStatus || gpExtStatus.dwStatus != ERROR_SUCCESS ) {

                DebugMsg((DM_VERBOSE,
                          TEXT("ProcessGPOList: Skipping extension %s due to failed Registry extension."),
                          lpExt->lpDisplayName));
                if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                    CEvents ev(FALSE, EVENT_EXT_SKIPPED_DUETO_FAILED_REG);
                    ev.AddArg(lpExt->lpDisplayName); ev.Report();
                }

                dwRet = E_FAIL;

                goto Exit;

            }
        }
        

        //
        // Log the extension specific status
        //
        
        if (pLocalWbemServices)
        {
            lpGPOInfo->bRsopLogging = LogExtSessionStatus(  pLocalWbemServices,
                                                            lpExt,
                                                            lpExt->bNewInterface,
                                                            (lpExt->bRsopTransition || (dwFlags & GPO_INFO_FLAG_FORCED_REFRESH) 
                                                            || (!bNoChanges)));        
            if (!lpGPOInfo->bRsopLogging) {
                hr2 = E_FAIL;
            }
        }

        if ( !LoadGPExtension( lpExt, FALSE ) ) {
            DebugMsg((DM_WARNING, TEXT("ProcessGPOList: LoadGPExtension %s failed."), lpExt->lpDisplayName));

            dwRet = E_FAIL;
            goto Exit;
        }

        if ( lpGPOInfo->dwFlags & GP_MACHINE )
            pbAbort = &g_bStopMachGPOProcessing;
        else
            pbAbort = &g_bStopUserGPOProcessing;

        //
        // Check if asynchronous processing is enabled
        //

        if ( lpExt->dwEnableAsynch )
            pAsyncHandleTemp = pAsyncHandle;
        else
            pAsyncHandleTemp = 0;

        if ( lpExt->bNewInterface ) {
            dwRet = lpExt->pEntryPointEx( dwFlags,
                                          lpGPOInfo->hToken,
                                          lpGPOInfo->hKeyRoot,
                                          pDeletedGPOList,
                                          pChangedGPOList,
                                          pAsyncHandleTemp,
                                          pbAbort,
                                          lpGPOInfo->pStatusCallback,
                                          pLocalWbemServices,
                                          phrRsopStatus);
        } else {
            dwRet = lpExt->pEntryPoint( dwFlags,
                                        lpGPOInfo->hToken,
                                        lpGPOInfo->hKeyRoot,
                                        pDeletedGPOList,
                                        pChangedGPOList,
                                        pAsyncHandleTemp,
                                        pbAbort,
                                        lpGPOInfo->pStatusCallback );
        }

        RevertToSelf();

        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: Extension %s returned 0x%x."),
                  lpExt->lpDisplayName, dwRet));

        if ( dwRet != ERROR_SUCCESS &&
                dwRet != ERROR_OVERRIDE_NOCHANGES &&
                    dwRet != E_PENDING &&
                        dwRet != ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED )
        {
            CEvents ev(TRUE, EVENT_EXT_FAILED);
            ev.AddArg(lpExt->lpDisplayName); ev.Report();
        }

    }   // else of if lpext->bregistryext


    if (pLocalWbemServices) {
        if ((dwRet != E_PENDING) && (SUCCEEDED(*phrRsopStatus)) && (lpExt->bNewInterface)) {

            //
            // for the legacy extensions it will be marked clean
            //

            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: Extension %s was able to log data. RsopStatus = 0x%x, dwRet = %d, Clearing the dirty bit"),
                      lpExt->lpDisplayName, *phrRsopStatus, dwRet));

            UpdateExtSessionStatus(pLocalWbemServices, lpExt->lpKeyName, FALSE, dwRet);        
        }
        else {

            if (!lpExt->bNewInterface) {
                DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: Extension %s doesn't support rsop logging"),
                          lpExt->lpDisplayName));

                UpdateExtSessionStatus(pLocalWbemServices, lpExt->lpKeyName, TRUE, dwRet);        
            }
            else if (FAILED(*phrRsopStatus)) {
                DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: Extension %s was not able to log data. Error = 0x%x, dwRet = %d,leaving the log dirty"),
                          lpExt->lpDisplayName, *phrRsopStatus, dwRet ));

                CEvents ev(TRUE, EVENT_EXT_RSOP_FAILED);
                ev.AddArg(lpExt->lpDisplayName); ev.Report();

                UpdateExtSessionStatus(pLocalWbemServices, lpExt->lpKeyName, TRUE, dwRet);        

            }
        }
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: Extension %s status was not updated because there was no changes and no transition or rsop wasn't enabled"),
                  lpExt->lpDisplayName));
    }

    //
    // if any of the things provider is supposed to log fails, log it as an error
    // so that provider tries to log it again next time
    //

    *phrRsopStatus = (SUCCEEDED(*phrRsopStatus)) && (FAILED(hr2)) ? hr2 : *phrRsopStatus;
    *phrRsopStatus = (!lpExt->bNewInterface) ? HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) : *phrRsopStatus;


Exit:

    return dwRet;
}


//*************************************************************
//
//  RefreshDisplay()
//
//  Purpose:    Starts control.exe
//
//  Parameters: lpGPOInfo   -   GPT information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL RefreshDisplay (LPGPOINFO lpGPOInfo)
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    TCHAR szCmdLine[50];
    BOOL Result;
    HANDLE hOldToken;



    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("RefreshDisplay: Starting control.exe")));


    //
    // Initialize process startup info
    //

    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpTitle = NULL;
    si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
    si.dwFlags = 0;
    si.wShowWindow = SW_HIDE;
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;
    si.lpDesktop = TEXT("");


    //
    // Impersonate the user so we get access checked correctly on
    // the file we're trying to execute
    //

    if (!ImpersonateUser(lpGPOInfo->hToken, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("RefreshDisplay: Failed to impersonate user")));
        return FALSE;
    }


    //
    // Create the app
    //

    lstrcpy (szCmdLine, TEXT("control /policy"));

    Result = CreateProcessAsUser(lpGPOInfo->hToken, NULL, szCmdLine, NULL,
                                 NULL, FALSE, 0, NULL, NULL, &si, &pi);


    //
    // Revert to being 'ourself'
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("RefreshDisplay: Failed to revert to self")));
    }


    if (Result) {
        WaitForSingleObject (pi.hProcess, 120000);
        CloseHandle (pi.hThread);
        CloseHandle (pi.hProcess);

    } else {
        DebugMsg((DM_WARNING, TEXT("RefreshDisplay: Failed to start control.exe with %d"), GetLastError()));
    }

    return(Result);

}


//*************************************************************
//
//  RefreshPolicy()
//
//  Purpose:    External api that causes policy to be refreshed now
//
//  Parameters: bMachine -   Machine policy vs user policy
//
//  Return:     TRUE if successful
//              FALSE if not
//
//*************************************************************

BOOL WINAPI RefreshPolicy (BOOL bMachine)
{
    HANDLE hEvent;

    DebugMsg((DM_VERBOSE, TEXT("RefreshPolicy: Entering with %d"), bMachine));

    hEvent = OpenEvent (EVENT_MODIFY_STATE, FALSE,
                        bMachine ? MACHINE_POLICY_REFRESH_EVENT : USER_POLICY_REFRESH_EVENT);

    if (hEvent) {
        BOOL bRet = SetEvent (hEvent);

        CloseHandle (hEvent);
        
        if (!bRet) {
            DebugMsg((DM_WARNING, TEXT("RefreshPolicy: Failed to set event with %d"), GetLastError()));
            return FALSE;
        }
    } else {
        DebugMsg((DM_WARNING, TEXT("RefreshPolicy: Failed to open event with %d"), GetLastError()));
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("RefreshPolicy: Leaving.")));

    return TRUE;
}



//*************************************************************
//
//  RefreshPolicyEx()
//
//  Purpose:    External api that causes policy to be refreshed now
//
//  Parameters: bMachine -   Machine policy vs user policy.
//              This API is synchronous and waits for the refresh to
//              finish.
//
//  Return:     TRUE if successful
//              FALSE if not
//
//*************************************************************

BOOL WINAPI RefreshPolicyEx (BOOL bMachine, DWORD dwOption)
{
    XHandle xhEvent;

    if (!dwOption)
        return RefreshPolicy(bMachine);
    
    if (dwOption == RP_FORCE) {
        DebugMsg((DM_VERBOSE, TEXT("RefreshPolicyEx: Entering with force refresh %d"), bMachine));

        xhEvent = OpenEvent (EVENT_MODIFY_STATE, FALSE,
                            bMachine ? MACHINE_POLICY_FORCE_REFRESH_EVENT : USER_POLICY_FORCE_REFRESH_EVENT);
                            
    }                            
    else {
        DebugMsg((DM_WARNING, TEXT("RefreshPolicyEx: Invalid option")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    
    if (!xhEvent) {
        DebugMsg((DM_WARNING, TEXT("RefreshPolicyEx: Failed to open event with %d"), GetLastError()));
        return FALSE;
    }


    if (!SetEvent (xhEvent)) {
        DebugMsg((DM_WARNING, TEXT("RefreshPolicyEx: Failed to set event with %d"), GetLastError()));
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("RefreshPolicyEx: Leaving.")));

    return TRUE;
}



//*************************************************************
//
//  EnterCriticalPolicySection()
//
//  Purpose:    External api that causes policy to pause
//              This allows an application to pause policy
//              so that values don't change while it reads
//              the settings.
//
//  Parameters: bMachine -   Pause machine policy or user policy
//              dwTimeOut-   Amount of time to wait for the policy handle
//              dwFlags  -   Various flags. Look at the defn.
//
//  Return:     TRUE if successful
//              FALSE if not
//
//*************************************************************

HANDLE WINAPI EnterCriticalPolicySectionEx (BOOL bMachine, DWORD dwTimeOut, DWORD dwFlags )
{
    HANDLE hSection;
    DWORD  dwRet;

    //
    // Open the mutex
    //

    hSection = OpenMutex (SYNCHRONIZE, FALSE,
                           (bMachine ? MACHINE_POLICY_MUTEX : USER_POLICY_MUTEX));

    if (!hSection) {
        DebugMsg((DM_WARNING, TEXT("EnterCriticalPolicySection: Failed to open mutex with %d"),
                 GetLastError()));
        return NULL;
    }



    //
    // Claim the mutex
    //

    dwRet = WaitForSingleObject (hSection, dwTimeOut);
    
    if ( dwRet == WAIT_FAILED) {
        DebugMsg((DM_WARNING, TEXT("EnterCriticalPolicySection: Failed to wait on the mutex.  Error = %d."),
                  GetLastError()));
        CloseHandle( hSection );
        return NULL;
    }

    if ( (dwFlags & ECP_FAIL_ON_WAIT_TIMEOUT) && (dwRet == WAIT_TIMEOUT) ) {
        DebugMsg((DM_WARNING, TEXT("EnterCriticalPolicySection: Wait timed out on the mutex.")));
        CloseHandle( hSection );
        SetLastError(dwRet);
        return NULL;
    }

    DebugMsg((DM_VERBOSE, TEXT("EnterCriticalPolicySection: %s critical section has been claimed.  Handle = 0x%x"),
             (bMachine ? TEXT("Machine") : TEXT("User")), hSection));

    return hSection;
}


//*************************************************************
//
//  LeaveCriticalPolicySection()
//
//  Purpose:    External api that causes policy to resume
//              This api assumes the app has called
//              EnterCriticalPolicySection first
//
//  Parameters: hSection - mutex handle
//
//  Return:     TRUE if successful
//              FALSE if not
//
//*************************************************************

BOOL WINAPI LeaveCriticalPolicySection (HANDLE hSection)
{

    if (!hSection) {
        DebugMsg((DM_WARNING, TEXT("LeaveCriticalPolicySection: null mutex handle.")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ReleaseMutex (hSection);
    CloseHandle (hSection);

    DebugMsg((DM_VERBOSE, TEXT("LeaveCriticalPolicySection: Critical section 0x%x has been released."),
             hSection));

    return TRUE;
}



//*************************************************************
//
//  EnterCriticalPolicySection()
//
//  Purpose:    External api that causes policy to pause
//              This allows an application to pause policy
//              so that values don't change while it reads
//              the settings.
//
//  Parameters: bMachine -   Pause machine policy or user policy
//
//  Return:     TRUE if successful
//              FALSE if not
//
//*************************************************************

HANDLE WINAPI EnterCriticalPolicySection (BOOL bMachine)
{
    return EnterCriticalPolicySectionEx(bMachine, 600000, 0);
}

//*************************************************************
//
//  FreeGpoInfo()
//
//  Purpose:    Deletes an LPGPOINFO struct
//
//  Parameters: pGpoInfo - Gpo info to free
//
//*************************************************************

BOOL FreeGpoInfo( LPGPOINFO pGpoInfo )
{
    if ( pGpoInfo == NULL )
        return TRUE;

    FreeLists( pGpoInfo );
    FreeSOMList( pGpoInfo->lpSOMList );
    FreeSOMList( pGpoInfo->lpLoopbackSOMList );
    FreeGpContainerList( pGpoInfo->lpGpContainerList );
    FreeGpContainerList( pGpoInfo->lpLoopbackGpContainerList );

    LocalFree( pGpoInfo->lpDNName );
    RsopDeleteToken( pGpoInfo->pRsopToken );
    ReleaseWbemServices( pGpoInfo );

    LocalFree( pGpoInfo );

    return TRUE;
}


//*************************************************************
//
//  FreeGPOList()
//
//  Purpose:    Free's the link list of GPOs
//
//  Parameters: pGPOList - Pointer to the head of the list
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL WINAPI FreeGPOList (PGROUP_POLICY_OBJECT pGPOList)
{
    PGROUP_POLICY_OBJECT pGPOTemp;

    while (pGPOList) {
        pGPOTemp = pGPOList->pNext;
        LocalFree (pGPOList);
        pGPOList = pGPOTemp;
    }

    return TRUE;
}


//*************************************************************
//
//  FreeLists()
//
//  Purpose:    Free's the lpExtFilterList and/or lpGPOList
//
//  Parameters: lpGPOInfo - GPO info
//
//*************************************************************

void FreeLists( LPGPOINFO lpGPOInfo )
{
    LPEXTFILTERLIST pExtFilterList = lpGPOInfo->lpExtFilterList;

    //
    // If bXferToExtList is True then it means that lpGPOInfo->lpExtFilterList
    // owns the list of GPOs. Otherwise lpGPOInfo->lpGPOList owns the list
    // of GPOs.
    //

    while ( pExtFilterList ) {

        LPEXTFILTERLIST pTemp = pExtFilterList->pNext;

        FreeExtList( pExtFilterList->lpExtList );

        if ( lpGPOInfo->bXferToExtList )
            LocalFree( pExtFilterList->lpGPO );

        LocalFree( pExtFilterList );
        pExtFilterList = pTemp;
    }

    if ( !lpGPOInfo->bXferToExtList )
        FreeGPOList( lpGPOInfo->lpGPOList );
}


//*************************************************************
//
//  FreeExtList()
//
//  Purpose:    Free's the lpExtList
//
//  Parameters: pExtList - Extensions list
//
//*************************************************************

void FreeExtList( LPEXTLIST pExtList )
{
    while (pExtList) {

        LPEXTLIST pTemp = pExtList->pNext;
        LocalFree( pExtList );
        pExtList = pTemp;
    }
}


//*************************************************************
//
//  ShutdownGPOProcessing()
//
//  Purpose:    Begins aborting GPO processing
//
//  Parameters: bMachine    -  Shutdown machine or user processing ?
//
//*************************************************************

void WINAPI ShutdownGPOProcessing( BOOL bMachine )
{
    if ( bMachine )
        g_bStopMachGPOProcessing = TRUE;
    else
        g_bStopUserGPOProcessing = TRUE;
}


//*************************************************************
//
//  InitializeGPOCriticalSection, CloseGPOCriticalSection
//
//  Purpose:   Initialization and cleanup routines for critical sections
//
//*************************************************************

void InitializeGPOCriticalSection()
{
    InitializeCriticalSection( &g_GPOCS );
    InitializeCriticalSection( &g_StatusCallbackCS );
}


void CloseGPOCriticalSection()
{
    DeleteCriticalSection( &g_StatusCallbackCS );
    DeleteCriticalSection( &g_GPOCS );
}


//*************************************************************
//
//  ProcessGroupPolicyCompletedEx()
//
//  Purpose:    Callback for asynchronous completion of an extension
//
//  Parameters: refExtensionId    -  Unique guid of extension
//              pAsyncHandle      -  Completion context
//              dwStatus          -  Asynchronous completion status
//              hrRsopStatus      -  Rsop Logging Status 
//
//  Returns:    Win32 error code
//
//*************************************************************

DWORD ProcessGroupPolicyCompletedEx( REFGPEXTENSIONID extensionGuid,
                                   ASYNCCOMPLETIONHANDLE pAsyncHandle,
                                   DWORD dwStatus, HRESULT hrRsopStatus )
{
    DWORD dwRet = E_FAIL;
    TCHAR szExtension[64];
    PGROUP_POLICY_OBJECT pGPOList = NULL;
    LPGPOINFO lpGPOInfo = NULL;
    BOOL bUsePerUserLocalSetting = FALSE;
    DWORD dwCurrentTime = GetCurTime();

    LPGPINFOHANDLE pGPHandle = (LPGPINFOHANDLE) pAsyncHandle;

    if ( extensionGuid == 0 )
        return ERROR_INVALID_PARAMETER;

    GuidToString( extensionGuid, szExtension );

    DebugMsg((DM_VERBOSE, TEXT("ProcessGroupPolicyCompleted: Entering. Extension = %s, dwStatus = 0x%x"),
              szExtension, dwStatus));

    EnterCriticalSection( &g_GPOCS );

    if ( !(pGPHandle == g_pMachGPInfo || pGPHandle == g_pUserGPInfo) ) {
        DebugMsg((DM_WARNING, TEXT("Extension %s asynchronous completion is stale"),
                  szExtension));
        goto Exit;
    }

    DmAssert( pGPHandle->pGPOInfo != NULL );

    if ( pGPHandle->pGPOInfo == NULL ) {
        DebugMsg((DM_WARNING, TEXT("Extension %s asynchronous completion has invalid pGPHandle->pGPOInfo"),
                  szExtension));
        goto Exit;
    }

    lpGPOInfo = pGPHandle->pGPOInfo;

    if ( (lpGPOInfo->dwFlags & GP_MACHINE) && g_bStopMachGPOProcessing
         || !(lpGPOInfo->dwFlags & GP_MACHINE) && g_bStopUserGPOProcessing ) {

        DebugMsg((DM_WARNING, TEXT("Extension %s asynchronous completion, aborting due to machine shutdown or logoff"),
                  szExtension));
        CEvents ev(TRUE, EVENT_GPO_PROC_STOPPED); ev.Report();
        goto Exit;

    }

    if ( dwStatus != ERROR_SUCCESS ) {

        //
        // Extension returned error code, so no need to update history
        //

        dwRet = ERROR_SUCCESS;
        goto Exit;
    }

    if ( pGPHandle == 0 ) {
         DebugMsg((DM_WARNING, TEXT("Extension %s is using 0 as asynchronous completion handle"),
                   szExtension));
         goto Exit;
    }

    bUsePerUserLocalSetting = !(lpGPOInfo->dwFlags & GP_MACHINE)
                              && ExtensionHasPerUserLocalSetting( szExtension, HKEY_LOCAL_MACHINE );

    if ( ReadGPOList( szExtension, lpGPOInfo->hKeyRoot,
                      HKEY_LOCAL_MACHINE,
                      lpGPOInfo->lpwszSidUser,
                      TRUE, &pGPOList ) ) {

        if ( SaveGPOList( szExtension, lpGPOInfo,
                          HKEY_LOCAL_MACHINE,
                          NULL,
                          FALSE, pGPOList ) ) {

            if ( bUsePerUserLocalSetting ) {

                if ( SaveGPOList( szExtension, lpGPOInfo,
                                  HKEY_LOCAL_MACHINE,
                                  lpGPOInfo->lpwszSidUser,
                                  FALSE, pGPOList ) ) {
                     dwRet = ERROR_SUCCESS;
                } else {
                    DebugMsg((DM_WARNING, TEXT("Extension %s asynchronous completion, failed to save GPOList"),
                              szExtension));
                }

            } else
                dwRet = ERROR_SUCCESS;

        } else {
            DebugMsg((DM_WARNING, TEXT("Extension %s asynchronous completion, failed to save GPOList"),
                      szExtension));
        }
    } else {
        DebugMsg((DM_WARNING, TEXT("Extension %s asynchronous completion, failed to read shadow GPOList"),
                  szExtension));
    }

Exit:
    
    FgPolicyRefreshInfo info = { GP_ReasonUnknown, GP_ModeAsyncForeground };
    LPWSTR szSid = lpGPOInfo->dwFlags & GP_MACHINE ? 0 : lpGPOInfo->lpwszSidUser;
    DWORD dwError;
    if ( dwStatus == ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED )
    {
        FgPolicyRefreshInfo curInfo = { GP_ReasonUnknown, GP_ModeUnknown };
        GetCurrentFgPolicyRefreshInfo( szSid, &curInfo );
        SetPreviousFgPolicyRefreshInfo( szSid, curInfo );

        info.mode = GP_ModeSyncForeground;
        info.reason = GP_ReasonCSERequiresSync;
        dwError = SetNextFgPolicyRefreshInfo(   szSid,
                                                info );
        if ( dwError != ERROR_SUCCESS )
        {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGroupPolicyCompletedEx: SetNextFgPolicyRefreshInfo failed, %x."), dwError ));
        }
    }
    
    if ( dwRet == ERROR_SUCCESS )
    {
        //
        // clear E_PENDING status code with status returned
        //
        BOOL bUsePerUserLocalSetting = !(lpGPOInfo->dwFlags & GP_MACHINE) && lpGPOInfo->lpwszSidUser != NULL;
        GPEXTSTATUS  gpExtStatus;

        gpExtStatus.dwSlowLink = (lpGPOInfo->dwFlags & GP_SLOW_LINK) != 0;
        gpExtStatus.dwRsopLogging = lpGPOInfo->bRsopLogging;
        gpExtStatus.dwStatus = dwStatus;
        gpExtStatus.dwTime = dwCurrentTime;
        gpExtStatus.bForceRefresh = FALSE;

        WriteStatus( szExtension, lpGPOInfo,
                     bUsePerUserLocalSetting ? lpGPOInfo->lpwszSidUser : NULL,
                     &gpExtStatus);

        //
        // Building up a dummy gpExt structure so that we can log the info required.
        //

        GPEXT        gpExt;
        TCHAR        szSubKey[MAX_PATH]; // same as the path in readgpextensions
        HKEY         hKey;
        TCHAR        szDisplayName[MAX_PATH];
        DWORD        dwSize, dwType;
        CHAR         szFunctionName[100];

        gpExt.lpKeyName = szExtension;

        lstrcpy(szSubKey, GP_EXTENSIONS);
        CheckSlash(szSubKey);
        lstrcat(szSubKey, szExtension);


        //
        // Read the displayname so that we can log it..
        //

        szDisplayName[0] = TEXT('\0');

        if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                          szSubKey,
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            dwSize = sizeof(szDisplayName);
            if (RegQueryValueEx (hKey, NULL, NULL,
                                 &dwType, (LPBYTE) szDisplayName,
                                 &dwSize) != ERROR_SUCCESS) {
                lstrcpyn (szDisplayName, szExtension, ARRAYSIZE(szDisplayName));
            }


            dwSize = sizeof(szFunctionName);
            if ( RegQueryValueExA (hKey, "ProcessGroupPolicyEx", NULL,
                                   &dwType, (LPBYTE) szFunctionName,
                                   &dwSize) == ERROR_SUCCESS ) {
                 gpExt.bNewInterface = TRUE;
            }
            
            RegCloseKey(hKey);
        }

        gpExt.lpDisplayName = szDisplayName;

        if ((lpGPOInfo->bRsopLogging)) {

            XInterface<IWbemServices> xWbemServices;

            GetWbemServices( lpGPOInfo, RSOP_NS_DIAG_ROOT, TRUE, FALSE, &xWbemServices);
            
            if (xWbemServices) {

                if (!gpExt.bNewInterface) {
                    DebugMsg((DM_VERBOSE, TEXT("ProcessGroupPolicyCompletedEx: Extension %s doesn't support rsop logging."),
                                          szExtension));

                    UpdateExtSessionStatus(xWbemServices, szExtension, TRUE, dwRet);        
                }
                else if (SUCCEEDED(hrRsopStatus)) {
                    DebugMsg((DM_VERBOSE, TEXT("ProcessGroupPolicyCompletedEx: Extension %s was able to log data. Error = 0x%x, dwRet = %d. Clearing the dirty bit"),
                                          szExtension, hrRsopStatus, dwStatus));

                    UpdateExtSessionStatus(xWbemServices, szExtension, FALSE, dwRet);        
                }
                else {
                    DebugMsg((DM_VERBOSE, TEXT("ProcessroupPolicyCompletedEx: Extension %s was not able to log data. Error = 0x%x, dwRet = %d. leaving the log dirty"),
                          szExtension, hrRsopStatus, dwStatus));

                    CEvents ev(TRUE, EVENT_EXT_RSOP_FAILED);
                    ev.AddArg(gpExt.lpDisplayName); ev.Report();

                    UpdateExtSessionStatus(xWbemServices, szExtension, TRUE, dwRet);        
                }
            }
        }
    }


    LeaveCriticalSection( &g_GPOCS );

    DebugMsg((DM_VERBOSE, TEXT("ProcessGroupPolicyCompleted: Leaving. Extension = %s, Return status dwRet = 0x%x"),
              szExtension, dwRet));

    return dwRet;
}

//*************************************************************
//
//  ProcessGroupPolicyCompleted()
//
//  Purpose:    Callback for asynchronous completion of an extension
//
//  Parameters: refExtensionId    -  Unique guid of extension
//              pAsyncHandle      -  Completion context
//              dwStatus          -  Asynchronous completion status
//
//  Returns:    Win32 error code
//
//*************************************************************

DWORD ProcessGroupPolicyCompleted( REFGPEXTENSIONID extensionGuid,
                                   ASYNCCOMPLETIONHANDLE pAsyncHandle,
                                   DWORD dwStatus )
{
    //
    // Mark RSOP data as clean for legacy extensions
    //

    return ProcessGroupPolicyCompletedEx(extensionGuid, pAsyncHandle, dwStatus, 
                                       HRESULT_FROM_WIN32(S_OK));
}



//*************************************************************
//
//  DebugPrintGPOList()
//
//  Purpose:    Prints GPO list
//
//  Parameters: lpGPOInfo    -  GPO Info
//
//*************************************************************

void DebugPrintGPOList( LPGPOINFO lpGPOInfo )
{
    //
    // If we are in verbose mode, put the list of GPOs in the event log
    //

    PGROUP_POLICY_OBJECT lpGPO = NULL;
    DWORD dwSize;

#if DBG
    if (TRUE) {
#else
    if (lpGPOInfo->dwFlags & GP_VERBOSE) {
#endif
        LPTSTR lpTempList;

        dwSize = 10;
        lpGPO = lpGPOInfo->lpGPOList;
        while (lpGPO) {
            if (lpGPO->lpDisplayName) {
                dwSize += (lstrlen (lpGPO->lpDisplayName) + 4);
            }
            lpGPO = lpGPO->pNext;
        }

        lpTempList = (LPWSTR) LocalAlloc (LPTR, (dwSize * sizeof(TCHAR)));

        if (lpTempList) {

            lstrcpy (lpTempList, TEXT(""));

            lpGPO = lpGPOInfo->lpGPOList;
            while (lpGPO) {
                if (lpGPO->lpDisplayName) {
                    lstrcat (lpTempList, TEXT("\""));
                    lstrcat (lpTempList, lpGPO->lpDisplayName);
                    lstrcat (lpTempList, TEXT("\" "));
                }
                lpGPO = lpGPO->pNext;
            }

            if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                CEvents ev(FALSE, EVENT_GPO_LIST);
                ev.AddArg(lpTempList); ev.Report();
            }

            DebugMsg((DM_VERBOSE, TEXT("DebugPrintGPOList: List of GPO(s) to process: %s"),
                     lpTempList));

            LocalFree (lpTempList);
        }
    }
}




//*************************************************************
//
//  UserPolicyCallback()
//
//  Purpose:    Callback function for status UI messages
//
//  Parameters: bVerbose  - Verbose message or not
//              lpMessage - Message text
//
//  Return:     ERROR_SUCCESS if successful
//              Win32 error code if an error occurs
//
//*************************************************************

DWORD UserPolicyCallback (BOOL bVerbose, LPWSTR lpMessage)
{
    WCHAR szMsg[100];
    LPWSTR lpMsg;
    DWORD dwResult = ERROR_INVALID_FUNCTION;


    if (lpMessage) {
        lpMsg = lpMessage;
    } else {
        LoadString (g_hDllInstance, IDS_USER_SETTINGS, szMsg, 100);
        lpMsg = szMsg;
    }

    DebugMsg((DM_VERBOSE, TEXT("UserPolicyCallback: Setting status UI to %s"), lpMsg));

    EnterCriticalSection (&g_StatusCallbackCS);

    if (g_pStatusMessageCallback) {
        dwResult = g_pStatusMessageCallback(bVerbose, lpMsg);
    } else {
        DebugMsg((DM_VERBOSE, TEXT("UserPolicyCallback: Extension requested status UI when status UI is not available.")));
    }

    LeaveCriticalSection (&g_StatusCallbackCS);

    return dwResult;
}

//*************************************************************
//
//  MachinePolicyCallback()
//
//  Purpose:    Callback function for status UI messages
//
//  Parameters: bVerbose  - Verbose message or not
//              lpMessage - Message text
//
//  Return:     ERROR_SUCCESS if successful
//              Win32 error code if an error occurs
//
//*************************************************************

DWORD MachinePolicyCallback (BOOL bVerbose, LPWSTR lpMessage)
{
    WCHAR szMsg[100];
    LPWSTR lpMsg;
    DWORD dwResult = ERROR_INVALID_FUNCTION;


    if (lpMessage) {
        lpMsg = lpMessage;
    } else {
        LoadString (g_hDllInstance, IDS_COMPUTER_SETTINGS, szMsg, 100);
        lpMsg = szMsg;
    }

    DebugMsg((DM_VERBOSE, TEXT("MachinePolicyCallback: Setting status UI to %s"), lpMsg));

    EnterCriticalSection (&g_StatusCallbackCS);

    if (g_pStatusMessageCallback) {
        dwResult = g_pStatusMessageCallback(bVerbose, lpMsg);
    } else {
        DebugMsg((DM_VERBOSE, TEXT("MachinePolicyCallback: Extension requested status UI when status UI is not available.")));
    }

    LeaveCriticalSection (&g_StatusCallbackCS);

    return dwResult;
}



//*************************************************************
//
//  CallDFS()
//
//  Purpose:    Calls DFS to initialize the domain / DC name
//
//  Parameters:  lpDomainName  - Domain name
//               lpDCName      - DC name
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

//
// Once upon a time when this file was a C file,
// the definition of POINTER_TO_OFFSET looked like this,
//
// #define POINTER_TO_OFFSET(field, buffer)  \
//     ( ((PCHAR)field) -= ((ULONG_PTR)buffer) )
//
// Now, that we have decided to end antiquity and made this a C++ file,
// the new definition is,
//

#define POINTER_TO_OFFSET(field, buffer)  \
    ( field = (LPWSTR) ( (PCHAR)field -(ULONG_PTR)buffer ) )

NTSTATUS CallDFS(LPWSTR lpDomainName, LPWSTR lpDCName)
{
    HANDLE DfsDeviceHandle = NULL;
    PDFS_SPC_REFRESH_INFO DfsInfo;
    ULONG lpDomainNameLen, lpDCNameLen, sizeNeeded;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status;
    UNICODE_STRING unicodeServerName;


    lpDomainNameLen = (wcslen(lpDomainName) + 1) * sizeof(WCHAR);
    lpDCNameLen = (wcslen(lpDCName) + 1) * sizeof(WCHAR);

    sizeNeeded = sizeof(DFS_SPC_REFRESH_INFO) + lpDomainNameLen + lpDCNameLen;

    DfsInfo = (PDFS_SPC_REFRESH_INFO)LocalAlloc(LPTR, sizeNeeded);

    if (DfsInfo == NULL) {
        DebugMsg((DM_WARNING, TEXT("CallDFS:  LocalAlloc failed with %d"), GetLastError()));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DfsInfo->DomainName = (WCHAR *)((PCHAR)DfsInfo + sizeof(DFS_SPC_REFRESH_INFO));
    DfsInfo->DCName = (WCHAR *)((PCHAR)DfsInfo->DomainName + lpDomainNameLen);


    RtlCopyMemory(DfsInfo->DomainName,
                  lpDomainName,
                  lpDomainNameLen);

    RtlCopyMemory(DfsInfo->DCName,
                  lpDCName,
                  lpDCNameLen);

    POINTER_TO_OFFSET(DfsInfo->DomainName, DfsInfo);
    POINTER_TO_OFFSET(DfsInfo->DCName, DfsInfo);

    RtlInitUnicodeString( &unicodeServerName, L"\\Dfs");

    InitializeObjectAttributes(
          &objectAttributes,
          &unicodeServerName,
          OBJ_CASE_INSENSITIVE,
          NULL,
          NULL
          );

    status = NtOpenFile(
                &DfsDeviceHandle,
                SYNCHRONIZE | FILE_WRITE_DATA,
                &objectAttributes,
                &ioStatusBlock,
                0,
                FILE_SYNCHRONOUS_IO_NONALERT
                );



    if (!NT_SUCCESS(status) ) {
        DebugMsg((DM_WARNING, TEXT("CallDFS:  NtOpenFile failed with 0x%x"), status));
        LocalFree(DfsInfo);
        return status;
    }

    status = NtFsControlFile(
                DfsDeviceHandle,
                NULL,
                NULL,
                NULL,
                &ioStatusBlock,
                FSCTL_DFS_SPC_REFRESH,
                DfsInfo, sizeNeeded,
                NULL, 0);

    if (!NT_SUCCESS(status) ) {
        DebugMsg((DM_WARNING, TEXT("CallDFS:  NtFsControlFile failed with 0x%x"), status));
    }


    LocalFree(DfsInfo);
    NtClose(DfsDeviceHandle);
    return status;
}




//*************************************************************
//
//  InitializePolicyProcessing
//
//  Purpose:    Initialises mutexes corresponding to user and machine
//
//  Parameters: bMachine - Whether it is machine or user
//
//  Return:
//
//  Comments:
//      These events/Mutexes need to be initialised right at the beginning
// because the ACls on these needs to be set before ApplyGroupPolicy can
// be called..
// 
//*************************************************************

BOOL InitializePolicyProcessing(BOOL bMachine)
{
    HANDLE hSection, hEvent;
    XPtrLF<SECURITY_DESCRIPTOR> xsd;
    SECURITY_ATTRIBUTES sa;
    CSecDesc Csd;
    XLastError xe;


    Csd.AddLocalSystem();
    Csd.AddAdministrators();
    Csd.AddEveryOne(SYNCHRONIZE);

    xsd = Csd.MakeSD();

    if (!xsd) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("InitializePolicyProcessing: Failed to create Security Descriptor with %d"),
                 GetLastError()));
        // since this is happening in dll load we cannot log an event at this point..
        return FALSE;
    }


    sa.lpSecurityDescriptor = (SECURITY_DESCRIPTOR *)xsd;
    sa.bInheritHandle = FALSE;
    sa.nLength = sizeof(sa);


    //
    // Synch mutex for group policies
    //

    hSection = CreateMutex (&sa, FALSE,
                       (bMachine ? MACHINE_POLICY_MUTEX : USER_POLICY_MUTEX));

    if (!hSection) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("InitializePolicyProcessing: Failed to create mutex with %d"),
                 GetLastError()));
        return FALSE;
    }

    if (bMachine)
        g_hPolicyCritMutexMach = hSection;
    else
        g_hPolicyCritMutexUser = hSection;



    //
    // Group Policy Notification events
    //


    //
    // Create the changed notification event
    //

    hEvent = CreateEvent (&sa, TRUE, FALSE,
                               (bMachine) ? MACHINE_POLICY_APPLIED_EVENT : USER_POLICY_APPLIED_EVENT);


    if (!hEvent) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("InitializePolicyProcessing: Failed to create NotifyEvent with %d"),
                 GetLastError()));
        return FALSE;
    }

    if (bMachine)
        g_hPolicyNotifyEventMach = hEvent;
    else
        g_hPolicyNotifyEventUser = hEvent;

    //
    // Create the needfg event
    //

    hEvent = CreateEvent (&sa, FALSE, FALSE,
                                (bMachine) ? MACHINE_POLICY_REFRESH_NEEDFG_EVENT : USER_POLICY_REFRESH_NEEDFG_EVENT);

    if (!hEvent) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("InitializePolicyProcessing: Failed to create NeedFGEvent with %d"),
                    GetLastError()));
        return FALSE;
    }

    if (bMachine)
        g_hPolicyNeedFGEventMach = hEvent;
    else
        g_hPolicyNeedFGEventUser = hEvent;
    
    
    //
    // Create the done event 
    //
    hEvent = CreateEvent (&sa, TRUE, FALSE,
                                (bMachine) ? MACHINE_POLICY_DONE_EVENT : USER_POLICY_DONE_EVENT);
    if (!hEvent) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("InitializePolicyProcessing: Failed to create hNotifyDoneEvent with %d"),
                    GetLastError()));
        return FALSE;
    }

    if (bMachine)
        g_hPolicyDoneEventMach = hEvent;
    else
        g_hPolicyDoneEventUser = hEvent;

    //
    // Create the machine policy - user policy sync event 
    //
    if ( bMachine )
    {
        hEvent = CreateEvent(   &sa,
                                TRUE,
                                FALSE,
                                MACH_POLICY_FOREGROUND_DONE_EVENT );
        if ( !hEvent )
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("InitializePolicyProcessing: Failed to create m/c-user policy sync event with %d"),
                        GetLastError()));
            return FALSE;
        }
        else
        {
            g_hPolicyForegroundDoneEventMach = hEvent;
        }
    }
    else
    {
        hEvent = CreateEvent(   &sa,
                                TRUE,
                                FALSE,
                                USER_POLICY_FOREGROUND_DONE_EVENT );
        if ( !hEvent )
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("InitializePolicyProcessing: Failed to create user policy/logon script sync event with %d"),
                        GetLastError()));
            return FALSE;
        }
        else
        {
            g_hPolicyForegroundDoneEventUser = hEvent;
        }
    }
        
    DebugMsg((DM_VERBOSE, TEXT("InitializePolicyProcessing: Initialised %s Mutex/Events"),
             bMachine ? TEXT("Machine"): TEXT("User")));

    return TRUE;
}

USERENVAPI
DWORD
WINAPI
WaitForUserPolicyForegroundProcessing()
{
    DWORD dwError = ERROR_SUCCESS;
    HANDLE hEvent = OpenEvent( SYNCHRONIZE, FALSE, USER_POLICY_FOREGROUND_DONE_EVENT );

    if ( hEvent )
    {
        if ( WaitForSingleObject( hEvent, INFINITE ) == WAIT_FAILED )
        {
            dwError = GetLastError();
            DebugMsg((DM_VERBOSE, TEXT("WaitForUserPolicyForegroundProcessing: Failed, %x"), dwError ));
        }
        CloseHandle( hEvent );
    }
    else
    {
        dwError = GetLastError();
        DebugMsg((DM_VERBOSE, TEXT("WaitForUserPolicyForegroundProcessing: Failed, %x"), dwError ));
    }
    return dwError;
}

USERENVAPI
DWORD
WINAPI
WaitForMachinePolicyForegroundProcessing()
{
    DWORD dwError = ERROR_SUCCESS;
    HANDLE hEvent = OpenEvent( SYNCHRONIZE, FALSE, MACH_POLICY_FOREGROUND_DONE_EVENT );

    if ( hEvent )
    {
        if ( WaitForSingleObject( hEvent, INFINITE ) == WAIT_FAILED )
        {
            dwError = GetLastError();
            DebugMsg((DM_VERBOSE, TEXT("WaitForMachinePolicyForegroundProcessing: Failed, %x"), dwError ));
        }
        CloseHandle( hEvent );
    }
    else
    {
        dwError = GetLastError();
        DebugMsg((DM_VERBOSE, TEXT("WaitForMachinePolicyForegroundProcessing: Failed, %x"), dwError ));
    }
    return dwError;
}

extern "C" DWORD
SignalUserPolicyForegroundProcessingDone()
{
    DWORD dwError = ERROR_SUCCESS;
    if ( !SetEvent( g_hPolicyForegroundDoneEventUser ) )
    {
        dwError = GetLastError();
        DebugMsg((DM_VERBOSE, TEXT("SignalUserPolicyForegroundProcessingDone: Failed, %x"), dwError ));
    }
    return dwError;
}

extern "C" DWORD
SignalMachinePolicyForegroundProcessingDone()
{
    DWORD dwError = ERROR_SUCCESS;
    if ( !SetEvent( g_hPolicyForegroundDoneEventMach ) )
    {
        dwError = GetLastError();
        DebugMsg((DM_VERBOSE, TEXT("SignalForMachinePolicyForegroundProcessingDone: Failed, %x"), dwError ));
    }
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\policy\gpt.h ===
//*************************************************************
//
//  Group Policy Processing
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//  History:    28-Oct-98   SitaramR    Created
//
//*************************************************************


#ifdef __cplusplus
extern "C" {
#endif

void InitializeGPOCriticalSection();
void CloseGPOCriticalSection();
BOOL InitializePolicyProcessing(BOOL bMachine);

#define ECP_FAIL_ON_WAIT_TIMEOUT        1

HANDLE WINAPI EnterCriticalPolicySectionEx (BOOL bMachine, DWORD dwTimeOut, DWORD dwFlags );

#ifdef __cplusplus
}
#endif

//
// These keys are used in gpt.c. The per user per machine keys will
// be deleted when profile gets deleted. Changes in the following keys
// should be reflected in the prefixes as well...
//

#define GP_SHADOW_KEY         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Shadow\\%ws")
#define GP_HISTORY_KEY        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History\\%ws")
#define GP_STATE_KEY          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\State\\%ws")
#define GP_STATE_ROOT_KEY     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\State")

#define GP_SHADOW_SID_KEY     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws\\Shadow\\%ws")
#define GP_HISTORY_SID_KEY    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws\\History\\%ws")

#define GP_EXTENSIONS_KEY     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\%ws")
#define GP_EXTENSIONS_SID_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\%ws\\GPExtensions\\%ws")

#define GP_HISTORY_SID_ROOT_KEY    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws\\History")
#define GP_MEMBERSHIP_KEY          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws\\GroupMembership")
#define GP_EXTENSIONS_SID_ROOT_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\%ws\\GPExtensions")

#define GP_POLICY_SID_KEY     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws")
#define GP_LOGON_SID_KEY      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\%ws")

#define GPCORE_GUID           TEXT("{00000000-0000-0000-0000-000000000000}")


//
// Comon prefix for both history and shadow
//

#define GP_XXX_SID_PREFIX           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy")
#define GP_EXTENSIONS_SID_PREFIX    TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")



//
// Structures
//

//
// Structure used to represent GP status from the previous policy run.
//

typedef struct _GPEXTSTATUS {
   DWORD          dwSlowLink;               // Slow link when policy applied previously ?
   DWORD          dwRsopLogging;            // Rsop Logging when policy applied previously ?
   DWORD          dwStatus;                 // Status returned previously
   HRESULT        dwRsopStatus;             // Rsop Status returned previously
   DWORD          dwTime;                   // Time when the policy was applied previously
   BOOL           bStatus;                  // If we failed to read the per ext status data
   BOOL           bForceRefresh;            // force refresh in this foreground prcessing..
} GPEXTSTATUS, *LPGPEXTSTATUS;


typedef struct _GPEXT {
    LPTSTR         lpDisplayName;            // Display name
    LPTSTR         lpKeyName;                // Extension name
    LPTSTR         lpDllName;                // Dll name
    LPSTR          lpFunctionName;           // Entry point name
    LPSTR          lpRsopFunctionName;       // Rsop entry point name
    HMODULE        hInstance;                // Handle to dll
    PFNPROCESSGROUPPOLICY   pEntryPoint;     // Entry point for ProcessGPO
    PFNPROCESSGROUPPOLICYEX pEntryPointEx;   // Diagnostic mode or Ex entry point
    PFNGENERATEGROUPPOLICY pRsopEntryPoint;  // Entry point for Rsop planning mode
    BOOL           bNewInterface;            // Are we using the new Ex entry point interface ?
    DWORD          dwNoMachPolicy;           // Mach policy setting
    DWORD          dwNoUserPolicy;           // User policy setting
    DWORD          dwNoSlowLink;             // Slow link setting
    DWORD          dwNoBackgroundPolicy;     // Background policy setting
    DWORD          dwNoGPOChanges;           // GPO changes setting
    DWORD          dwUserLocalSetting;       // Per user per machine setting
    DWORD          dwRequireRegistry;        // RequireSuccReg setting
    DWORD          dwEnableAsynch;           // Enable asynchronous processing setting
    DWORD          dwLinkTransition;         // Link speed transition setting
    DWORD          dwMaxChangesInterval;     // Max interval (mins) for which NoGpoChanges is adhered to
    BOOL           bRegistryExt;             // Is this the psuedo reg extension ?
    BOOL           bSkipped;                 // Should processing be skipped for this extension ?
    BOOL           bHistoryProcessing;       // Is processing needed to clean up cached Gpos ?
    BOOL           bForcedRefreshNextFG;     // Forced refresh next time it is processed in foreground.
    BOOL           bRsopTransition;          // Rsop Transition ?
    GUID           guid;                     // Guid of extension
    LPGPEXTSTATUS  lpPrevStatus;             // Previous Status
    LPTSTR         szEventLogSources;        // "(userenv,Application)\0(print,System)\0....\0"
    struct _GPEXT *pNext;                    // Singly linked list pointer
} GPEXT, *LPGPEXT;


typedef struct _GPOPROCDATA {                // Data that is needed while processing the data
    BOOL        bProcessGPO;                 // Actually add the GPOs to the processing list
    PLDAP       pLdapHandle;                 // LDAP handle corresponding to the query
} GPOPROCDATA, *LPGPOPROCDATA;


typedef struct _EXTLIST {
    GUID             guid;                   // Extension guid
    struct _EXTLIST *pNext;                  // Singly linked list pointer
} EXTLIST, *LPEXTLIST;



typedef struct _EXTFILTERLIST {
    PGROUP_POLICY_OBJECT   lpGPO;            // GPO
    LPEXTLIST              lpExtList;        // List of extension guids that apply to lpGPO
    BOOL                   bLogged;          // Is this link logged to RSoP db ?
    struct _EXTFILTERLIST *pNext;            // Singly linked list pointer
} EXTFILTERLIST, *LPEXTFILTERLIST;


typedef struct _GPLINK {
    LPWSTR                   pwszGPO;             // DS path to Gpo
    BOOL                     bEnabled;            // Is this link disabled ?
    BOOL                     bNoOverride;         // Is Gpo enforced ?
    struct _GPLINK          *pNext;               // Gpo linked in SOM order
} GPLINK, *LPGPLINK;


typedef struct _SCOPEOFMGMT {
    LPWSTR                   pwszSOMId;            // Dn name of SOM
    DWORD                    dwType;               // Type of SOM
    BOOL                     bBlocking;            // Does SOM have policies blocked from above ?
    BOOL                     bBlocked;             // This SOM is blocked by a SOM below ?
    LPGPLINK                 pGpLinkList;          // List of GPOs linked to this SOM
    struct _SCOPEOFMGMT     *pNext;
} SCOPEOFMGMT, *LPSCOPEOFMGMT;


typedef struct _GPCONTAINER {
    LPWSTR                   pwszDSPath;           // DS path to Gpo
    LPWSTR                   pwszGPOName;          // Guid from of Gpo name
    LPWSTR                   pwszDisplayName;      // Friendly name
    LPWSTR                   pwszFileSysPath;      // Sysvol path to Gpo
    BOOL                     bFound;               // Gpo found ?
    BOOL                     bAccessDenied;        // Access denied ?
    BOOL                     bUserDisabled;        // Disabled for user policy ?
    BOOL                     bMachDisabled;        // Disabled for machine policy ?
    DWORD                    dwUserVersion;        // Version # for user policy
    DWORD                    dwMachVersion;        // Version # for machine policy
    PSECURITY_DESCRIPTOR     pSD;                  // ACL on Gpo
    DWORD                    cbSDLen;              // Length of security descriptor in bytes
    BOOL                     bFilterAllowed;       // Does Gpo pass filter check ?
    WCHAR                   *pwszFilterId;         // Filter id
    LPWSTR                   szSOM;                // SOM that this GPO is linked to
    DWORD                    dwOptions;            // GPO options
    struct _GPCONTAINER     *pNext;                // Linked list ptr
} GPCONTAINER, *LPGPCONTAINER;


typedef struct _GPOINFO {
    DWORD                    dwFlags;
    INT                      iMachineRole;
    HANDLE                   hToken;
    PRSOPTOKEN               pRsopToken;
    WCHAR *                  lpDNName;
    HANDLE                   hEvent;
    HKEY                     hKeyRoot;
    BOOL                     bXferToExtList;     // Has the ownership been transferred from lpGPOList to lpExtFilterList ?
    LPEXTFILTERLIST          lpExtFilterList;    // List of extensions to be filtered, cardinality is same as GetGPOList's list
    PGROUP_POLICY_OBJECT     lpGPOList;          // Filtered GPO List, can vary from one extension to next
    LPTSTR                   lpwszSidUser;       // Sid of user in string form
    HANDLE                   hTriggerEvent;
    HANDLE                   hForceTriggerEvent; // force trigger event
    HANDLE                   hNotifyEvent;
    HANDLE                   hNeedFGEvent;
    HANDLE                   hDoneEvent;
    HANDLE                   hCritSection;
    LPGPEXT                  lpExtensions;
    BOOL                     bMemChanged;          // Has security group membership has changed ?
    BOOL                     bUserLocalMemChanged; // Has membership changed on per user local basis ?
    BOOL                     bSidChanged;          // Has the Sid changed since the last policy run?
    PFNSTATUSMESSAGECALLBACK pStatusCallback;
    LPSCOPEOFMGMT            lpSOMList;            // LSDOU list
    LPGPCONTAINER            lpGpContainerList;    // GP container list for Rsop logging
    LPSCOPEOFMGMT            lpLoopbackSOMList;    // Loopback LSDOU list
    LPGPCONTAINER            lpLoopbackGpContainerList;    // Loopback container list for Rsop logging
    BOOL                     bFGCoInitialized;     // CoInitialize called on foreground thread ?
    BOOL                     bBGCoInitialized;     // CoInitialize called on background thread ?
    IWbemServices *          pWbemServices;        // Namespace pointer for Rsop logging
    LPTSTR                   szName;               // Full Name of the User/Computer
    LPTSTR                   szTargetName;         // Rsop TargetName
    BOOL                     bRsopLogging;         // Is Rsop Logging turned on ?
    BOOL                     bRsopCreated;         // Rsop Name Space was created now ?
    LPWSTR                   szSiteName;           // site name of the target
} GPOINFO, *LPGPOINFO;


typedef struct _ADMFILEINFO {
    WCHAR *               pwszFile;            // Adm file path
    WCHAR *               pwszGPO;             // Gpo that the adm file is in
    FILETIME              ftWrite;             // Last write time of Adm file
    struct _ADMFILEINFO * pNext;               // Singly linked list pointer
} ADMFILEINFO;


typedef struct _RSOPSESSIONDATA {
    WCHAR *               pwszTargetName;               // Target user or computer
    WCHAR *               pwszSOM;                      // New group of target
    PTOKEN_GROUPS         pSecurityGroups;              // Security IDs of the new groups for target
    BOOL                  bLogSecurityGroup;            // Log the security groups
    WCHAR *               pwszSite;                     // Site of target
    BOOL                  bMachine;                     // Machine or user policy processing ?
    BOOL                  bSlowLink;                    // policy applied over slow link?
} RSOPSESSIONDATA, *LPRSOPSESSIONDATA;


typedef struct _RSOPEXTSTATUS {
    FILETIME              ftStartTime;                  // times between which the associated
    FILETIME              ftEndTime;                    // extension was processed
    DWORD                 dwStatus;                     // Processing status
    DWORD                 dwLoggingStatus;              // Logging Status
    BOOL                  bValid;                       // this struct is valid and can be used              
} RSOPEXTSTATUS, *LPRSOPEXTSTATUS;
                          


BOOL RsopDeleteUserNameSpace(LPTSTR szComputer, LPTSTR lpSid);

DWORD SaveLoggingStatus(LPWSTR szSid, LPGPEXT lpExt, RSOPEXTSTATUS *lpRsopExtStatus);
DWORD ReadLoggingStatus(LPWSTR szSid, LPWSTR szExtId, RSOPEXTSTATUS *lpRsopExtStatus);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\policy\plgpt.cpp ===
//*************************************************************
//
//  Group Policy Support for planning mode
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//*************************************************************

#include "gphdr.h"


DWORD GenerateRegistryPolicy( DWORD dwFlags,
                              BOOL *pbAbort,
                              WCHAR *pwszSite,
                              PRSOP_TARGET pComputerTarget,
                              PRSOP_TARGET pUserTarget );

BOOL GenerateGpoInfo( WCHAR *pwszDomain, WCHAR *pwszDomainDns, WCHAR *pwszAccount,
                      WCHAR *pwszNewSOM, SAFEARRAY *psaSecGroups,
                      DWORD dwFlags, BOOL bMachine, WCHAR *pwszSite, CGpoFilter *pGpoFilter, CLocator *pLocator, 
                       WCHAR *pwszMachAccount, WCHAR *pwszNewMachSOM, LPGPOINFO pGpoInfo, PNETAPI32_API pNetAPI32 );


BOOL GetCategory( WCHAR *pwszDomain, WCHAR *pwszAccount, WCHAR **ppwszDNName );

DWORD ProcessMachAndUserGpoList( LPGPEXT lpExtMach, LPGPEXT lpExtUser, DWORD dwFlags, WCHAR *pwszSite,
                 WCHAR *pwszMach, WCHAR *pwszNewComputerOU, SAFEARRAY *psaComputerSecurityGroups, LPGPOINFO pGpoInfoMach,
                 WCHAR *pwszUser, WCHAR *pwszNewUserOU, SAFEARRAY *psaUserSecurityGroups, LPGPOINFO pGpoInfoUser );


BOOL ProcessRegistryFiles(PRSOP_TARGET pTarget, REGHASHTABLE *pHashTable);
BOOL ProcessRegistryValue ( void* pUnused,
                            LPTSTR lpKeyName,
                            LPTSTR lpValueName,
                            DWORD dwType,
                            DWORD dwDataLength,
                            LPBYTE lpData,
                            WCHAR *pwszGPO,
                            WCHAR *pwszSOM,
                            REGHASHTABLE *pHashTable);
BOOL ProcessAdmData( PRSOP_TARGET pTarget, BOOL bUser );



//*************************************************************
//
//  GenerateRsopPolicy()
//
//  Purpose:    Generates planning mode Rsop policy for specified target
//
//  Parameters: dwFlags          - Processing flags
//              bstrMachName     - Target computer name
//              bstrNewMachSOM   - New machine domain or OU
//              psaMachSecGroups - New machine security groups
//              bstrUserName     - Target user name
//              psaUserSecGroups - New user security groups
//              bstrSite         - Site of target computer
//              pwszNameSpace    - Namespace to write Rsop data
//              pvProgress       - Progress indicator class
//              pvGpoFilter       - GPO filter class
//
//  Return:     True if successful, False otherwise
//
//  Notes:      If a new SOM is specified then that is used instead of
//              the SOM the target belongs to. Similarly, if new
//              security groups are specified then that is used instead of
//              the security groups that the target belongs to. If
//              target name is null and both new SOM and new security
//              groups are non-null, then we simulate a dummy target; otherwise
//              we skip generating planning mode info for the target.
//
//*************************************************************

BOOL GenerateRsopPolicy( DWORD dwFlags, BSTR bstrMachName,
                         BSTR bstrNewMachSOM, SAFEARRAY *psaMachSecGroups,
                         BSTR bstrUserName, BSTR bstrNewUserSOM,
                         SAFEARRAY *psaUserSecGroups,
                         BSTR bstrSite,
                         WCHAR *pwszNameSpace,
                         LPVOID pvProgress,
                         LPVOID pvMachGpoFilter,
                         LPVOID pvUserGpoFilter )
{
    LPGPOINFO pGpoInfoMach = NULL;
    LPGPOINFO pGpoInfoUser = NULL;
    PNETAPI32_API pNetAPI32 = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDsInfo = NULL;
    BOOL bDC = FALSE;
    DWORD dwResult;
    LPWSTR pwszDomain = NULL;
    LPWSTR pwszMachDns = NULL;
    LPWSTR pwszDomainDns = NULL;
    DWORD dwSize = 0;
    BOOL bResult = FALSE;
    LPGPEXT lpExtMach = NULL;
    LPGPEXT lpExtUser = NULL;
    LPGPEXT lpExt,lpTemp = NULL;
    WCHAR *pwszMach = (WCHAR *) bstrMachName;
    WCHAR *pwszUser = (WCHAR *) bstrUserName;
    DWORD   dwExtCount = 1;
    DWORD   dwIncrPercent;
    CProgressIndicator* pProgress = (CProgressIndicator*) pvProgress;
    CGpoFilter *pMachGpoFilter = (CGpoFilter *) pvMachGpoFilter;
    CGpoFilter *pUserGpoFilter = (CGpoFilter *) pvUserGpoFilter;
    RSOPSESSIONDATA rsopSessionData;
    LPRSOPSESSIONDATA  lprsopSessionData;
    BOOL bDummyMach = pwszMach == NULL && bstrNewMachSOM != NULL;
    BOOL bDummyUser  = pwszUser == NULL && bstrNewUserSOM != NULL;
    DWORD dwUserGPCoreError = ERROR_SUCCESS;
    DWORD dwMachGPCoreError = ERROR_SUCCESS;
    CLocator locator;
    HRESULT hr = S_OK;
    XLastError xe; 

    //
    // Allow debugging level to be changed dynamically
    //

    InitDebugSupport( FALSE );


    if ( pwszUser == NULL && pwszMach == NULL && !bDummyUser && !bDummyMach ) {
        DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Both user and machine names cannot be NULL.")));
        xe = ERROR_INVALID_PARAMETER;
        return FALSE;
    }

    pNetAPI32 = LoadNetAPI32();

    if (!pNetAPI32) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy:  Failed to load netapi32 with %d."),
                 GetLastError()));
        // error logged in LoadNetAPI32
        goto Exit;
    }

    //
    // Get the role of this computer
    //

    dwResult = pNetAPI32->pfnDsRoleGetPrimaryDomainInformation( NULL, DsRolePrimaryDomainInfoBasic,
                                                               (PBYTE *)&pDsInfo );

    if (dwResult != ERROR_SUCCESS) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: DsRoleGetPrimaryDomainInformation failed with %d."), dwResult));
        goto Exit;
    }

    if ( pDsInfo->MachineRole == DsRole_RoleBackupDomainController
         || pDsInfo->MachineRole == DsRole_RolePrimaryDomainController ) {
        bDC = TRUE;
    }

    if ( !bDC ) {
        xe = ERROR_ACCESS_DENIED;
        DebugMsg((DM_WARNING, TEXT("GeneratRsopPolicy: Rsop data can be generated on a DC only")));
        goto Exit;
    }

    pwszDomain = pDsInfo->DomainNameFlat;

    //
    // Get the machine name in dns format, so that ldap_bind can be done to this specific DC.
    //

    dwSize = 0;
    GetComputerNameEx( ComputerNameDnsFullyQualified, pwszMachDns, &dwSize );

    if ( dwSize > 0 ) {

        pwszMachDns = (WCHAR *) LocalAlloc (LPTR, dwSize * sizeof(WCHAR) );
        if ( pwszMachDns == NULL ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Failed to allocate memory")));
            goto Exit;
        }

    } else {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: GetComputerNameEx failed")));
        goto Exit;
    }

    bResult = GetComputerNameEx( ComputerNameDnsFullyQualified, pwszMachDns, &dwSize );
    if ( !bResult ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: GetComputerNameEx failed")));
        goto Exit;
    }

    pwszDomainDns = pwszMachDns;

    //
    //  5% of the task is done
    //
    pProgress->IncrementBy( 5 );

    //
    // Setup computer target info, if any
    //

    bResult = FALSE;

    if ( pwszMach || bDummyMach ) {

        pGpoInfoMach = (LPGPOINFO) LocalAlloc (LPTR, sizeof(GPOINFO));

        if (!pGpoInfoMach) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: Failed to alloc lpGPOInfo (%d)."),
                      GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_ALLOCATION);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            goto Exit;
        }

        pGpoInfoMach->dwFlags = GP_PLANMODE | GP_MACHINE;


        bResult = GetWbemServices( pGpoInfoMach, pwszNameSpace, TRUE, NULL, &(pGpoInfoMach->pWbemServices) );
        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Error when getting Wbemservices.")));
            goto Exit;
        }

        //
        // First set dirty to be true
        //

        bResult = LogExtSessionStatus(pGpoInfoMach->pWbemServices, NULL, TRUE);        
        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Error when logging user Session data.")));
            goto Exit;
        }

        if ( ! GenerateGpoInfo( pwszDomain, pwszDomainDns, pwszMach,
                                (WCHAR *) bstrNewMachSOM, psaMachSecGroups, dwFlags, TRUE,
                                (WCHAR *) bstrSite, pMachGpoFilter, &locator, NULL, NULL, pGpoInfoMach, pNetAPI32 ) ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: GenerateGpoInfo failed with %d."), xe));
            dwMachGPCoreError = (xe) ? xe : E_FAIL;
        }
        else {
            dwMachGPCoreError = ERROR_SUCCESS;
        }

    }

    //
    //  10% of the task is done
    //
    pProgress->IncrementBy( 5 );

    //
    // Setup user target info, if any
    //

    if ( pwszUser || bDummyUser ) {
        pGpoInfoUser = (LPGPOINFO) LocalAlloc (LPTR, sizeof(GPOINFO));

        if (!pGpoInfoUser) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: Failed to alloc lpGPOInfo (%d)."),
                      GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_ALLOCATION);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            goto Exit;
        }

        pGpoInfoUser->dwFlags = GP_PLANMODE;


        bResult = GetWbemServices( pGpoInfoUser, pwszNameSpace, TRUE, NULL, &(pGpoInfoUser->pWbemServices));
        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Error when getting Wbemservices.")));
            goto Exit;
        }

        //
        // First set dirty to be true
        //

        bResult = LogExtSessionStatus(pGpoInfoUser->pWbemServices, NULL, TRUE);        
        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Error when logging user Session data.")));
            goto Exit;
        }


        if ( ! GenerateGpoInfo( pwszDomain, pwszDomainDns, pwszUser,
                                (WCHAR *) bstrNewUserSOM, psaUserSecGroups, dwFlags, FALSE, (WCHAR *) bstrSite,
                                pUserGpoFilter, &locator, pwszMach, (WCHAR *) bstrNewMachSOM, pGpoInfoUser, pNetAPI32 ) ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: GenerateGpoInfo failed with %d."), xe));
            dwUserGPCoreError = (xe) ? xe : E_FAIL;
        }
        else {
            dwUserGPCoreError = ERROR_SUCCESS;
        }
    }

    //
    // Log Gpo info to WMI's database
    //


    lprsopSessionData = &rsopSessionData;

    if ( pwszMach || bDummyMach ) {
        
        XPtrLF<TOKEN_GROUPS> xGrps;

        hr = RsopSidsFromToken(pGpoInfoMach->pRsopToken, &xGrps);

        if (FAILED(hr)) {
            xe = HRESULT_CODE(hr);
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: RsopSidsFromToken failed with error 0x%x."), hr));
            goto Exit;

        }

        //
        // Fill up the rsop Session Data (Machine Specific)
        //

        lprsopSessionData->pwszTargetName = pwszMach;
        lprsopSessionData->pwszSOM = GetSomPath(bstrNewMachSOM ? bstrNewMachSOM : pGpoInfoMach->lpDNName);
        lprsopSessionData->pSecurityGroups = (PTOKEN_GROUPS)xGrps;
        lprsopSessionData->bLogSecurityGroup = TRUE;
        lprsopSessionData->pwszSite =  (WCHAR *) bstrSite;
        lprsopSessionData->bMachine = TRUE;


        bResult = LogRsopData( pGpoInfoMach, lprsopSessionData );
        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Error when logging machine Rsop data.")));
            goto Exit;
        }

        pGpoInfoMach->bRsopLogging = TRUE;
    }

    if ( pwszUser || bDummyUser ) {
        
        XPtrLF<TOKEN_GROUPS> xGrps;

        hr = RsopSidsFromToken(pGpoInfoUser->pRsopToken, &xGrps);

        if (FAILED(hr)) {
            xe = HRESULT_CODE(hr);
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: RsopSidsFromToken failed with error 0x%x."), hr));
            goto Exit;

        }


        //
        // Fill up the rsop Session Data (User Specific)
        //

        lprsopSessionData->pwszTargetName = pwszUser;
        lprsopSessionData->pwszSOM = GetSomPath(bstrNewUserSOM ? bstrNewUserSOM : pGpoInfoUser->lpDNName);
        lprsopSessionData->pSecurityGroups = (PTOKEN_GROUPS)xGrps;
        lprsopSessionData->bLogSecurityGroup = TRUE;
        lprsopSessionData->pwszSite =  (WCHAR *) bstrSite;
        lprsopSessionData->bMachine = FALSE;

        bResult = LogRsopData( pGpoInfoUser, lprsopSessionData );
        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Error when logging user Rsop data.")));
            goto Exit;
        }
        
        pGpoInfoUser->bRsopLogging = TRUE;
    }

    if ( ( dwUserGPCoreError != ERROR_SUCCESS) || ( dwMachGPCoreError != ERROR_SUCCESS) ){
        DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Couldn't fetch the user/computer GPO list. Exitting provider.")));
        // note that at this point bResult can be true and we want to actually return that
        // since this error will be part of the GP Core error...
        goto Exit;
    }

    //
    //  15% of the task is done
    //
    pProgress->IncrementBy( 5 );

    if ( dwFlags & FLAG_NO_CSE_INVOKE )
    {
        bResult = TRUE;
        goto Exit;
    }

    //
    // By this time, pGPOInfoMach should be defined if
    // we needed data for mach and pGPOInfoUser should be
    // defined if we needed the data for user.
    //
    // Assumption: lpExt is the same for both user and Machine
    //

    if (pGpoInfoMach) 
        lpExt = lpExtMach = pGpoInfoMach->lpExtensions;

    if (pGpoInfoUser)
        lpExt = lpExtUser = pGpoInfoUser->lpExtensions;


    //
    // count the number of extensions
    //

    DmAssert(lpExt);

    lpTemp = lpExt;

    while ( lpExt )
    {
        dwExtCount++;
        lpExt = lpExt->pNext;
    }

    lpExt = lpTemp;

    dwIncrPercent = ( pProgress->MaxProgress() - pProgress->CurrentProgress() ) / dwExtCount;

    //
    // Loop through registered extensions, asking them to generate planning mode info
    //

    while ( lpExt ) {

        //
        // Add check here for cancellation of policy generation
        //


        DebugMsg((DM_VERBOSE, TEXT("GenerateRsopPolicy: -----------------------")));
        DebugMsg((DM_VERBOSE, TEXT("GenerateRsopPolicy: Processing extension %s"), lpExt->lpDisplayName));

        if (lpExtMach) 
            FilterGPOs( lpExtMach, pGpoInfoMach );

        if (lpExtUser)
            FilterGPOs( lpExtUser, pGpoInfoUser );

        __try {

                dwResult = ProcessMachAndUserGpoList( lpExtMach, lpExtUser, dwFlags, (WCHAR *) bstrSite,
                                                      pwszMach, (WCHAR *) bstrNewMachSOM, psaMachSecGroups, pGpoInfoMach,
                                                      pwszUser, (WCHAR *) bstrNewUserSOM, psaUserSecGroups, pGpoInfoUser );
                pProgress->IncrementBy( dwIncrPercent );

        }
        __except( GPOExceptionFilter( GetExceptionInformation() ) ) {

            RevertToSelf();

            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Extension %s ProcessGroupPolicy threw unhandled exception 0x%x."),
                      lpExt->lpDisplayName, GetExceptionCode() ));

            CEvents ev(TRUE, EVENT_CAUGHT_EXCEPTION);
            ev.AddArg(lpExt->lpDisplayName); ev.AddArgHex(GetExceptionCode()); ev.Report();
        }

        DebugMsg((DM_VERBOSE, TEXT("GenerateRsopPolicy: -----------------------")));

        if (lpExtMach) 
            lpExtMach = lpExtMach->pNext;

        if (lpExtUser)
            lpExtUser = lpExtUser->pNext;

        lpExt = lpExt->pNext;
    }

    bResult = TRUE;

Exit:

    //
    // if all logging was successful
    //
    
    if ((pGpoInfoUser) && (pGpoInfoUser->bRsopLogging)) {
        bResult = UpdateExtSessionStatus(pGpoInfoUser->pWbemServices, NULL, (!bResult), dwUserGPCoreError );        
    }            

    
    if ((pGpoInfoMach) && (pGpoInfoMach->bRsopLogging)) {
        bResult = UpdateExtSessionStatus(pGpoInfoMach->pWbemServices, NULL, (!bResult), dwMachGPCoreError);        
    }            
    

    UnloadGPExtensions( pGpoInfoMach );
    UnloadGPExtensions( pGpoInfoUser );  // Frees lpExtensions field

    if ( pDsInfo ) {
        pNetAPI32->pfnDsRoleFreeMemory (pDsInfo);
    }

    LocalFree( pwszMachDns );

    FreeGpoInfo( pGpoInfoUser );
    FreeGpoInfo( pGpoInfoMach );

    return bResult;
}



//*************************************************************
//
//  GenerateGpoInfo()
//
//  Purpose:    Allocates and fills in pGpoInfo for specified target
//
//  Parameters: pwszDomain      - Domain name
//              pwszDomainDns   - Dns name of machine for ldap binding
//              pwszAccount     - User or machine account name
//              pwszNewSOM      - New SOM of target
//              psaSecGroups    - New security groups of target
//              dwFlags         - Processing flags
//              bMachine        - Is this machine processing
//              pwszSite        - Site name
//              pGpoFilter      - Gpo filter
//              pLocator        - Wbem interface class
//              pwszMachAccount - Machine account
//              pwszNewMachSOM  - Machine SOM       (abv 2 are applicable only for loopback)
//              ppGpoInfo       - Gpo info returned here
//              pNetApi32       - Delay loaded netap32.dll
//
//  Return:     True if successful, False otherwise
//
//*************************************************************

BOOL GenerateGpoInfo( WCHAR *pwszDomain, WCHAR *pwszDomainDns, WCHAR *pwszAccount,
                      WCHAR *pwszNewSOM, SAFEARRAY *psaSecGroups,
                      DWORD dwFlags, BOOL bMachine, WCHAR *pwszSite, CGpoFilter *pGpoFilter, CLocator *pLocator,
                      WCHAR *pwszMachAccount, WCHAR *pwszNewMachSOM, LPGPOINFO pGpoInfo, PNETAPI32_API pNetAPI32 )
{
    HRESULT hr;
    BOOL bResult = FALSE;
    XPtrLF<WCHAR> xszXlatName;
    PSECUR32_API pSecur32;
    XLastError xe; 
    DWORD dwError = ERROR_SUCCESS;
    XPtrLF<WCHAR> xwszTargetDomain;
    DWORD         dwUserPolicyMode = 0;
    DWORD         dwLocFlags;



    if (!bMachine) {
        if (dwFlags & FLAG_LOOPBACK_MERGE ) {
            dwUserPolicyMode = 1;
        }
        else if (dwFlags & FLAG_LOOPBACK_REPLACE ) {
            dwUserPolicyMode = 2;
        }
    }

    dwLocFlags = GP_PLANMODE | (dwFlags & FLAG_ASSUME_COMP_WQLFILTER_TRUE) | (dwFlags & FLAG_ASSUME_USER_WQLFILTER_TRUE);

    //
    // Load secur32.dll
    //

    pSecur32 = LoadSecur32();

    if (!pSecur32) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo:  Failed to load Secur32.")));
        return NULL;
    }


    if ( pwszAccount == NULL ) {
        if ( pwszNewSOM == NULL ) {

            //
            // When dummy user is specified then both SOM and security groups
            // must be specified.
            //

            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: Incorrect SOM or security specification for dummy target"),
                  GetLastError()));
            goto Exit;
        }
    }

    if ( bMachine )
        dwFlags |= GP_MACHINE;

    dwFlags |= GP_PLANMODE; // mark the processing as planning mode processing

    pGpoInfo->dwFlags = dwFlags;

    //
    // caller can force slow link in planning mode
    //
    if ( dwFlags & FLAG_ASSUME_SLOW_LINK )
    {
        pGpoInfo->dwFlags |= GP_SLOW_LINK;
    }
    else
    {
        pGpoInfo->dwFlags &= ~GP_SLOW_LINK;
    }

    if ( pwszAccount ) {
        if ( !GetCategory( pwszDomain, pwszAccount, &pGpoInfo->lpDNName ) ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo - getCategory failed with error - %d"), GetLastError()));
            goto Exit;
        }
    }


    //
    // TranslateName to SamCompatible so that the rest of the functions work correctly
    // for any of the various name formats
    //

    if ( pwszAccount ) {
        DWORD dwSize = MAX_PATH+1;

        xszXlatName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*dwSize);

        if (!xszXlatName) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo - Couldn't allocate memory for Name...")));
            goto Exit;
        }

        if (!pSecur32->pfnTranslateName(  pwszAccount,
                                        NameUnknown,
                                        NameSamCompatible,
                                        xszXlatName,
                                        &dwSize )) {

            BOOL bOk = FALSE;

            if (dwSize >  (MAX_PATH+1)) {

                xszXlatName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*dwSize);

                if (!xszXlatName) {
                    xe = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo - Couldn't allocate memory for Name...")));
                    goto Exit;
                }

                bOk = pSecur32->pfnTranslateName(  pwszAccount,
                                                NameUnknown,
                                                NameSamCompatible,
                                                xszXlatName,
                                                &dwSize );

            }          

            if (!bOk) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo - TranslateName failed with error %d"), GetLastError()));
                goto Exit;
            }
        }
        
        DebugMsg((DM_VERBOSE, TEXT("GenerateGpoInfo: RsopCreateToken  for Account Name <%s>"), (LPWSTR)xszXlatName));
    }

    hr = RsopCreateToken( xszXlatName, psaSecGroups, &pGpoInfo->pRsopToken );
    if ( FAILED(hr) ) {
        xe = HRESULT_CODE(hr);
        DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: Failed to create Rsop token. Error - %d"), HRESULT_CODE(hr)));
        goto Exit;
    }


    dwError = GetDomain(pwszNewSOM ? pwszNewSOM : pGpoInfo->lpDNName, &xwszTargetDomain);

    if (dwError != ERROR_SUCCESS) {
        xe = dwError;
        DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: Failed to Get domain. Error - %d"), dwError));
        goto Exit;
    }


    //
    // Query for the GPO list based upon the mode
    //
    // 0 is normal
    // 1 is merge.  Merge user list + machine list
    // 2 is replace.  use machine list instead of user list
    //

    
    if (dwUserPolicyMode == 0) {
        DebugMsg((DM_VERBOSE, TEXT("GenerateGpoInfo: Calling GetGPOInfo for normal policy mode")));

        bResult = GetGPOInfo( dwLocFlags | ((pGpoInfo->dwFlags & GP_MACHINE) ? GPO_LIST_FLAG_MACHINE : 0),
                              xwszTargetDomain,
                              pwszNewSOM ? pwszNewSOM : pGpoInfo->lpDNName,
                              NULL,
                              &pGpoInfo->lpGPOList,
                              &pGpoInfo->lpSOMList, &pGpoInfo->lpGpContainerList,
                              pNetAPI32, FALSE, pGpoInfo->pRsopToken, pwszSite, pGpoFilter, pLocator );
    
        
        if ( !bResult ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: GetGPOInfo failed.")));
            CEvents ev( TRUE, EVENT_GPO_QUERY_FAILED ); ev.Report();
            goto Exit;
        }
    } else if (dwUserPolicyMode == 2) {
        
        XPtrLF<TCHAR> xMachDNName;
        XPtrLF<TCHAR> xwszMachDomain;


        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Calling GetGPOInfo for replacement user policy mode")));

        if ( pwszMachAccount ) {
            if ( !GetCategory( pwszDomain, pwszMachAccount, &xMachDNName ) ) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo - getCategory failed with error - %d"), GetLastError()));
                goto Exit;
            }
        }

        dwError = GetDomain(pwszNewMachSOM ? pwszNewMachSOM : xMachDNName, &xwszMachDomain);

        if (dwError != ERROR_SUCCESS) {
            xe = dwError;
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: Failed to Get domain. Error - %d"), dwError));
            goto Exit;
        }

        bResult = GetGPOInfo( dwLocFlags | 0,
                              xwszMachDomain,
                              pwszNewMachSOM ? pwszNewMachSOM : xMachDNName,
                              NULL,
                              &pGpoInfo->lpGPOList,
                              &pGpoInfo->lpLoopbackSOMList, 
                              &pGpoInfo->lpLoopbackGpContainerList,
                              pNetAPI32, FALSE, pGpoInfo->pRsopToken, pwszSite, pGpoFilter, pLocator );
        
        if ( !bResult ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: GetGPOInfo failed.")));
            CEvents ev( TRUE, EVENT_GPO_QUERY_FAILED ); ev.Report();
            goto Exit;
        }
    }
    else {
        XPtrLF<TCHAR> xMachDNName;
        XPtrLF<TCHAR> xwszMachDomain;
        PGROUP_POLICY_OBJECT lpGPO = NULL;
        PGROUP_POLICY_OBJECT lpGPOTemp;


        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Calling GetGPOInfo for merging user policy mode")));
        
        bResult = GetGPOInfo( dwLocFlags | ((pGpoInfo->dwFlags & GP_MACHINE) ? GPO_LIST_FLAG_MACHINE : 0),
                              xwszTargetDomain,
                              pwszNewSOM ? pwszNewSOM : pGpoInfo->lpDNName,
                              NULL,
                              &pGpoInfo->lpGPOList,
                              &pGpoInfo->lpSOMList, &pGpoInfo->lpGpContainerList,
                              pNetAPI32, FALSE, pGpoInfo->pRsopToken, pwszSite, pGpoFilter, pLocator );
    
        
        if ( !bResult ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: GetGPOInfo failed.")));
            CEvents ev( TRUE, EVENT_GPO_QUERY_FAILED ); ev.Report();
            goto Exit;
        }


        if ( pwszMachAccount ) {
            if ( !GetCategory( pwszDomain, pwszMachAccount, &xMachDNName ) ) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo - getCategory failed with error - %d"), GetLastError()));
                goto Exit;
            }
        }

        dwError = GetDomain(pwszNewMachSOM ? pwszNewMachSOM : xMachDNName, &xwszMachDomain);

        if (dwError != ERROR_SUCCESS) {
            xe = dwError;
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: Failed to Get domain. Error - %d"), dwError));
            goto Exit;
        }

        bResult = GetGPOInfo( 0 | dwLocFlags,
                              xwszMachDomain,
                              pwszNewMachSOM ? pwszNewMachSOM : xMachDNName,
                              NULL,
                              &lpGPO,
                              &pGpoInfo->lpLoopbackSOMList, 
                              &pGpoInfo->lpLoopbackGpContainerList,
                              pNetAPI32, FALSE, pGpoInfo->pRsopToken, pwszSite, pGpoFilter, pLocator );
        
        if ( !bResult ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: GetGPOInfo failed.")));
            CEvents ev( TRUE, EVENT_GPO_QUERY_FAILED ); ev.Report();
            goto Exit;
        }

        if (pGpoInfo->lpGPOList && lpGPO) {

            DebugMsg((DM_VERBOSE, TEXT("GenerateGpoInfo: Both user and machine lists are defined.  Merging them together.")));

            //
            // Need to merge the lists together
            //

            lpGPOTemp = pGpoInfo->lpGPOList;

            while (lpGPOTemp->pNext) {
                lpGPOTemp = lpGPOTemp->pNext;
            }

            lpGPOTemp->pNext = lpGPO;

        } else if (!pGpoInfo->lpGPOList && lpGPO) {

            DebugMsg((DM_VERBOSE, TEXT("GenerateGpoInfo: Only machine list is defined.")));
            pGpoInfo->lpGPOList = lpGPO;

        } else {

            DebugMsg((DM_VERBOSE, TEXT("GenerateGpoInfo: Only user list is defined.")));
        }
    }



    if ( !ReadGPExtensions( pGpoInfo ) ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: ReadGPExtensions failed.")));
        CEvents ev( TRUE, EVENT_READ_EXT_FAILED ); ev.Report();
        goto Exit;
    }

    if ( !CheckForSkippedExtensions( pGpoInfo, TRUE ) ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: Checking extensions for skipping failed")));
        goto Exit;
    }

    bResult = SetupGPOFilter( pGpoInfo );

    if ( !bResult ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: SetupGPOFilter failed.")));
        CEvents ev(TRUE, EVENT_SETUP_GPOFILTER_FAILED); ev.Report();
        goto Exit;
    }

Exit:

    return bResult;
}



//*************************************************************
//
//  GetCategory()
//
//  Purpose:    Gets the fully qualified domain name
//
//  Parameters: pwszDomain  -  Domain name
//              pwszAccount -  User or machine account name
//              pwszDNName  -  Fully qualified domain name returned here
//
//  Return:     True if successful, False otherwise
//
//*************************************************************

BOOL GetCategory( WCHAR *pwszDomain, WCHAR *pwszAccount, WCHAR **ppwszDNName  )
{
    PSECUR32_API pSecur32Api;
    BOOL bResult = FALSE;
    ULONG ulSize = 512;
    XLastError xe; 

    *ppwszDNName = NULL;

    *ppwszDNName = (WCHAR *) LocalAlloc (LPTR, ulSize * sizeof(WCHAR) );
    if ( *ppwszDNName == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetCategory: Memory allocation failed.")));
        goto Exit;
    }

    pSecur32Api = LoadSecur32();

    if (!pSecur32Api) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetCategory:  Failed to load secur32 api.")));
        goto Exit;
    }

    bResult = pSecur32Api->pfnTranslateName( pwszAccount, NameUnknown, NameFullyQualifiedDN,
                                             *ppwszDNName, &ulSize );

    if ( !bResult && ulSize > 0 ) {

        LocalFree( *ppwszDNName );
        *ppwszDNName = (WCHAR *) LocalAlloc (LPTR, ulSize * sizeof(WCHAR) );
        if ( *ppwszDNName == NULL ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetCategory: Memory allocation failed.")));
            goto Exit;
        }

        bResult = pSecur32Api->pfnTranslateName( pwszAccount, NameUnknown, NameFullyQualifiedDN,
                                                 *ppwszDNName, &ulSize );

        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetCategory: TranslateName failed with error %d."), GetLastError()));
        }
    }
    else {
        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetCategory: TranslateName failed with error %d."), GetLastError()));
        }
    }

Exit:

    if ( !bResult ) {
        LocalFree( *ppwszDNName );
        *ppwszDNName = NULL;
    }

    return bResult;
}


//*************************************************************
//
//  ProcessMachAndUserGpoList()
//
//  Purpose:    Calls the various extensions to do the planning
//              mode logging
//
//  Parameters: lpExtMach          -  Machine extension struct
//              lpExtUser          -  User extension struct
//              dwFlags            -  Processing flags
//              pwszSite           -  Site name
//              pwszNewComputerSOM -  New computer scope of management
//              psaCompSecGroups   -  New computer security groups
//              pGpoInfoMach       -  Machine Gpo info
//              ...                -  Similarly for user account
//
//  Return:     True if successful, False otherwise
//
//*************************************************************

DWORD ProcessMachAndUserGpoList( LPGPEXT lpExtMach, LPGPEXT lpExtUser, DWORD dwFlags, WCHAR *pwszSite,
                                 WCHAR *pwszMach, WCHAR *pwszNewComputerSOM, SAFEARRAY *psaComputerSecurityGroups, LPGPOINFO pGpoInfoMach,
                                 WCHAR *pwszUser, WCHAR *pwszNewUserSOM, SAFEARRAY *psaUserSecurityGroups, LPGPOINFO pGpoInfoUser )
{
    BOOL bAbort = FALSE;
    DWORD dwResult;

    RSOP_TARGET computerTarget, userTarget;
    PRSOP_TARGET pComputerTarget = NULL;
    PRSOP_TARGET pUserTarget = NULL;
    BOOL         bPlanningSupported = TRUE;
    LPGPEXT      lpExt;



    lpExt = (lpExtMach != NULL) ? lpExtMach : lpExtUser;

    if (!lpExt) {
        DebugMsg((DM_WARNING, TEXT("ProcessMachAndUserGpoList: Both user and computer exts are null, returning.")));
        return TRUE;
    }

    bPlanningSupported = lpExt->bRegistryExt || (lpExt->lpRsopFunctionName ? TRUE : FALSE);


    if ( lpExtMach && !lpExtMach->bSkipped && pGpoInfoMach->lpGPOList ) {

        //
        // Computer target is non-null
        //

        pComputerTarget = &computerTarget;
        pComputerTarget->pwszAccountName = pwszMach;
        pComputerTarget->pwszNewSOM = pwszNewComputerSOM;
        pComputerTarget->psaSecurityGroups = psaComputerSecurityGroups;
        pComputerTarget->pRsopToken = pGpoInfoMach->pRsopToken;
        pComputerTarget->pGPOList = pGpoInfoMach->lpGPOList;
        pComputerTarget->pWbemServices = pGpoInfoMach->pWbemServices;


        if (pGpoInfoMach->bRsopLogging) {
            pGpoInfoMach->bRsopLogging = LogExtSessionStatus(pGpoInfoMach->pWbemServices, lpExtMach, 
                                                             bPlanningSupported);        
            if (!pGpoInfoMach->bRsopLogging) {
                DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Error when logging user Session data.")));
            }
        }
    }



    if ( lpExtUser && !lpExtUser->bSkipped && pGpoInfoUser->lpGPOList ) {

        //
        // User target is non-null
        //

        pUserTarget = &userTarget;
        pUserTarget->pwszAccountName = pwszUser;
        pUserTarget->pwszNewSOM = pwszNewUserSOM;
        pUserTarget->psaSecurityGroups = psaUserSecurityGroups;
        pUserTarget->pRsopToken = pGpoInfoUser->pRsopToken;
        pUserTarget->pGPOList = pGpoInfoUser->lpGPOList;
        pUserTarget->pWbemServices = pGpoInfoUser->pWbemServices;


        if (pGpoInfoUser->bRsopLogging) {
            pGpoInfoUser->bRsopLogging = LogExtSessionStatus(pGpoInfoUser->pWbemServices, lpExtUser, 
                                                             bPlanningSupported);        
            if (!pGpoInfoUser->bRsopLogging) {
                DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Error when logging user Session data.")));
            }
        }
    }
    


    if ( pComputerTarget == NULL && pUserTarget == NULL ) {
        DebugMsg((DM_WARNING, TEXT("ProcessMachAndUserGpoList: Both user and computer targets are null, returning.")));
        return TRUE;
    }



    if ( lpExt->bRegistryExt ) {

        //
        // Registry pseudo extension
        //

        dwResult = GenerateRegistryPolicy( dwFlags,
                                           &bAbort,
                                           pwszSite,
                                           pComputerTarget,
                                           pUserTarget );

    } else {

        if ( LoadGPExtension( lpExt, TRUE ) ) {
            dwResult = lpExt->pRsopEntryPoint( dwFlags,
                                               &bAbort,
                                               pwszSite,
                                               pComputerTarget,
                                               pUserTarget );

        }
        else {
            dwResult = GetLastError();
        }
        
    }


    if ( lpExtUser && !lpExtUser->bSkipped && pGpoInfoUser->bRsopLogging) {
        if ( !bPlanningSupported ) 
            UpdateExtSessionStatus(pGpoInfoUser->pWbemServices, lpExtUser->lpKeyName, TRUE, ERROR_SUCCESS);        
        else if (dwResult != ERROR_SUCCESS) 
            UpdateExtSessionStatus(pGpoInfoUser->pWbemServices, lpExtUser->lpKeyName, TRUE, dwResult);        
        else 
            UpdateExtSessionStatus(pGpoInfoUser->pWbemServices, lpExtUser->lpKeyName, FALSE, dwResult);        
    }


    if ( lpExtMach && !lpExtMach->bSkipped && pGpoInfoMach->bRsopLogging) {
        if ( !bPlanningSupported ) 
            UpdateExtSessionStatus(pGpoInfoMach->pWbemServices, lpExtMach->lpKeyName, TRUE, ERROR_SUCCESS);        
        else if (dwResult != ERROR_SUCCESS) 
            UpdateExtSessionStatus(pGpoInfoMach->pWbemServices, lpExtMach->lpKeyName, TRUE, dwResult);        
        else 
            UpdateExtSessionStatus(pGpoInfoMach->pWbemServices, lpExtMach->lpKeyName, FALSE, dwResult);        
    }


    return dwResult;
}


//*********************************************************************
// * Planning mode registry stuff
//*********************************************************************


//*************************************************************
//
//  ProcessRegistryFiles()
//
//  Purpose: Called from GenerateRegsitryPolicy to process registry data from
//                  the registry files associated with a policy target.
//
//  Parameters:
//                  pTarget -     Policy for which registry policy is to be processed.
//                  pHashTable  - Hash table to keep registry policy information.
//
//  Return:     On success, TRUE. Otherwise, FALSE.
//
//*************************************************************

BOOL ProcessRegistryFiles(PRSOP_TARGET pTarget, REGHASHTABLE *pHashTable)
{
    PGROUP_POLICY_OBJECT lpGPO;
    TCHAR szRegistry[MAX_PATH];
    LPTSTR lpEnd;
    HRESULT hr;
    DWORD dwGrantedAccessMask;
    BOOL bAccess;

    //
    // Check parameters
    //

    DmAssert(pHashTable);

    if(!pHashTable) {
            DebugMsg((DM_WARNING, TEXT("ProcessRegistryFiles: Invalid parameter.")));
            return FALSE;
    }

    //
    // Spin through GPOs in the list.
    //

    lpGPO = pTarget->pGPOList;

    while ( lpGPO ) {

        //
        // Build the path to Registry.pol
        //

        DmAssert( lstrlen(lpGPO->lpFileSysPath) + lstrlen(c_szRegistryPol) + 1 < MAX_PATH );
        if(lstrlen(lpGPO->lpFileSysPath) + lstrlen(c_szRegistryPol) + 1 >= MAX_PATH) {
            DebugMsg((DM_WARNING, TEXT("ProcessRegistryFiles: Length of path to registry.pol exceeded MAX_PATH.")));
            return FALSE;
        }

        lstrcpy (szRegistry, lpGPO->lpFileSysPath);
        lpEnd = CheckSlash (szRegistry);
        lstrcpy (lpEnd, c_szRegistryPol);


        //
        // Check if the RsopToken has access to this file.
        //

        hr = RsopFileAccessCheck(szRegistry, pTarget->pRsopToken, GENERIC_READ, &dwGrantedAccessMask, &bAccess);
        if(FAILED(hr)) {
            DebugMsg((DM_VERBOSE, TEXT("ProcessRegistryFiles: RsopFileAccessCheck failed.")));
            return FALSE;
        }

        if(!bAccess) {
            DebugMsg((DM_VERBOSE, TEXT("ProcessRegistryFiles: The RsopToken does not have access to file %s. Continuing...."), szRegistry));
            lpGPO = lpGPO->pNext;
            continue;
        }


        //
        // Process registry data for this particular file.
        //

        if (!ParseRegistryFile (NULL, szRegistry, (PFNREGFILECALLBACK)ProcessRegistryValue, NULL,
                                        lpGPO->lpDSPath, lpGPO->lpLink,pHashTable, TRUE)) {
            DebugMsg((DM_WARNING, TEXT("ProcessRegistryFiles: ProcessRegistryFile failed.")));
            return FALSE;
        }

        lpGPO = lpGPO->pNext;
    }

    return TRUE;
}

//*************************************************************
//
//  ProcessAdmData()
//
//  Purpose: Called from GenerateRegistryPolicy in order to process Admin templates
//                  data associated with a registry policy target.
//
//  Parameters: pTarget - Target for which data is to be processed
//              bUser   - Is this for user or machine policy ?
//
//  Return:     On success, TRUE. Otherwise, FALSE.
//
//*************************************************************

BOOL ProcessAdmData( PRSOP_TARGET pTarget, BOOL bUser )
{
    PGROUP_POLICY_OBJECT lpGPO;

    WIN32_FIND_DATA findData;
    ADMFILEINFO *pAdmFileCache = 0;
    TCHAR szRegistry[MAX_PATH];
    LPTSTR lpEnd;

    HANDLE hFindFile;
    WIN32_FILE_ATTRIBUTE_DATA attrData;
    DWORD dwFilePathSize;
    DWORD dwSize;

    WCHAR *pwszEnd;
    WCHAR *pwszFile;

    HRESULT hr;
    DWORD dwGrantedAccessMask;
    BOOL bAccess;

    //
    // Check parameters
    //
    if(pTarget == NULL ) {
        DebugMsg((DM_WARNING, TEXT("ProcessAdmData: Invalid paramter.")));
        return FALSE;
    }

    lpGPO = pTarget->pGPOList;

    while(lpGPO) {

        //
        // Log Adm data
        //

        dwFilePathSize = lstrlen( lpGPO->lpFileSysPath );
        dwSize = dwFilePathSize + MAX_PATH;

        pwszFile = (WCHAR *) LocalAlloc( LPTR, dwSize * sizeof(WCHAR) );

        if ( pwszFile == 0 ) {
            DebugMsg((DM_WARNING, TEXT("ProcessAdmData: Failed to allocate memory.")));
            FreeAdmFileCache( pAdmFileCache );
            return FALSE;
        }

        lstrcpy( pwszFile, lpGPO->lpFileSysPath );

        //
        // Strip off trailing 'machine' or 'user'
        //

        pwszEnd = pwszFile + lstrlen( pwszFile );

        if ( !bUser )
            pwszEnd -= 7;   // length of "machine"
        else
            pwszEnd -= 4;   // length of "user"

        lstrcpy( pwszEnd, L"Adm\\*.adm");

        //
        // Remember end point so that the actual Adm filename can be
        // easily concatenated.
        //

        pwszEnd = pwszEnd + lstrlen( L"Adm\\" );

        //
        // Enumerate all Adm files
        //

        hFindFile = FindFirstFile( pwszFile, &findData);

        if ( hFindFile != INVALID_HANDLE_VALUE )
        {
            do
            {
                if ( !(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
                {
                    DmAssert( dwFilePathSize + lstrlen(findData.cFileName) + lstrlen( L"\\Adm\\" ) < dwSize );

                    lstrcpy( pwszEnd, findData.cFileName);

                    ZeroMemory (&attrData, sizeof(attrData));

                    //
                    // Check if the RsopToken has access to this file.
                    //

                    hr = RsopFileAccessCheck(pwszFile, pTarget->pRsopToken, GENERIC_READ, &dwGrantedAccessMask, &bAccess);
                    if(FAILED(hr)) {
                        DebugMsg((DM_VERBOSE, TEXT("ProcessAdmData: RsopFileAccessCheck failed.")));
                        FreeAdmFileCache( pAdmFileCache );
                        return FALSE;
                    }

                    if(!bAccess) {
                        DebugMsg((DM_VERBOSE, TEXT("ProcessAdmData: The RsopToken does not have access to file %s. Continuing..."), findData.cFileName));
                        continue;
                    }

                    if ( GetFileAttributesEx (pwszFile, GetFileExInfoStandard, &attrData ) != 0 ) {

                        if ( !AddAdmFile( pwszFile, lpGPO->lpDSPath,
                                          &attrData.ftLastWriteTime, NULL, &pAdmFileCache ) ) {
                            DebugMsg((DM_WARNING, TEXT("ProcessAdmData: NewAdmData failed.")));
                        }

                    }
                }   // if findData & file_attr_dir
            }  while ( FindNextFile(hFindFile, &findData) );//  do

            FindClose(hFindFile);

        }   // if hfindfile

        LocalFree( pwszFile );

        lpGPO = lpGPO->pNext;
    }

    if ( ! LogAdmRsopData( pAdmFileCache, pTarget->pWbemServices ) ) {
        DebugMsg((DM_WARNING, TEXT("ProcessAdmData: Error when logging Adm Rsop data. Continuing.")));
    }

    FreeAdmFileCache( pAdmFileCache );

    return TRUE;
}


//*************************************************************
//
//  GenerateRegistryPolicy()
//
//  Purpose: Implementation of Planning mode regsitry pseudo-extension
//
//  Parameters: dwFlags  - Flags
//              pbAbort  - Abort processing
//              pwszSite - Site of target
//              pComputerTarget - Computer target specification
//              pUserTarget     - User target specification
//
//  Return:     On success, S_OK. Otherwise, E_FAIL.
//
//*************************************************************

DWORD GenerateRegistryPolicy( DWORD dwFlags,
                              BOOL *pbAbort,
                              WCHAR *pwszSite,
                              PRSOP_TARGET pComputerTarget,
                              PRSOP_TARGET pUserTarget )
{
    REGHASHTABLE *pHashTable = NULL;
    BOOL bUser;

    if(pComputerTarget && pComputerTarget->pGPOList) {

        //
        // Setup computer hash table
        //

        pHashTable = AllocHashTable();
        if ( pHashTable == NULL ) {
            DebugMsg((DM_WARNING, TEXT("GenerateRegistryPolicy: AllocHashTable failed.")));
            return E_FAIL;
        }

        //
        // Process computer GPO list
        //


        if(!ProcessRegistryFiles(pComputerTarget, pHashTable)) {
            DebugMsg((DM_WARNING, TEXT("GenerateRegistryPolicy: ProcessRegistryFiles failed.")));
            FreeHashTable( pHashTable );
            return E_FAIL;
        }


        //
        // Log computer registry data to Cimom database
        //
        if ( ! LogRegistryRsopData( GP_MACHINE, pHashTable, pComputerTarget->pWbemServices ) )  {
            DebugMsg((DM_WARNING, TEXT("GenerateRegistryPolicy: LogRegistryRsopData failed.")));
            FreeHashTable( pHashTable );
            return E_FAIL;
        }
        FreeHashTable( pHashTable );
        pHashTable = NULL;

        //
        // Process ADM data
        //

        bUser = FALSE;
        if (pComputerTarget && !ProcessAdmData( pComputerTarget, bUser ) ) {
            DebugMsg((DM_WARNING, TEXT("GenerateRegistryPolicy: ProcessAdmData failed.")));
            return E_FAIL;
        }

    }

    //
    // Process user GPO list
    //

    if(pUserTarget && pUserTarget->pGPOList) {

        //
        // Setup user hash table
        //

        pHashTable = AllocHashTable();
        if ( pHashTable == NULL ) {
            DebugMsg((DM_WARNING, TEXT("GenerateRegistryPolicy: AllocHashTable failed.")));
            return E_FAIL;
        }


        if(!ProcessRegistryFiles(pUserTarget, pHashTable)) {
            DebugMsg((DM_WARNING, TEXT("GenerateRegistryPolicy: ProcessRegistryFiles failed.")));
            FreeHashTable( pHashTable );
            return E_FAIL;
        }

        //
        // Log user registry data to Cimom database
        //

        if ( ! LogRegistryRsopData( 0, pHashTable, pUserTarget->pWbemServices ) )  {
            DebugMsg((DM_WARNING, TEXT("GenerateRegistryPolicy: LogRegistryRsopData failed.")));
            FreeHashTable( pHashTable );
            return E_FAIL;
        }
        FreeHashTable( pHashTable );
        pHashTable = NULL;

        //
        // Process ADM data
        //

        bUser = TRUE;
        if (pUserTarget && !ProcessAdmData( pUserTarget, bUser ) ) {
            DebugMsg((DM_WARNING, TEXT("GenerateRegistryPolicy: ProcessAdmData failed.")));
            return E_FAIL;
        }

    }


    return S_OK;
}


//*************************************************************
//
//  CheckOUAccess()
//
//  Purpose:    Determines if the user / machine has read access to
//              the OU.
//
//  Parameters: pld             -  LDAP connection
//              pLDAP           -  LDAP function table pointer
//              pMessage        -  LDAP message
//              pRsopToken      -  RSOP token of the user or machine
//              pSD             -  Security descriptor returned here
//              pcbSDLen        -  Length of security descriptor returned here
//              pbAccessGranted -  Receives the final yes / no status
//
//  Return:     TRUE if successful
//              FALSE if an error occurs.
//
//*************************************************************

BOOL CheckOUAccess( PLDAP_API pLDAP,
                    PLDAP pld,
                    PLDAPMessage    pMessage,
                    PRSOPTOKEN pRsopToken,
                    BOOL *pbAccessGranted )
{
    BOOL bResult = FALSE;
    TCHAR szSDProperty[] = TEXT("nTSecurityDescriptor");
    PWSTR *ppwszValues;

    *pbAccessGranted = FALSE;

    //
    // Get the security descriptor value
    //
    ppwszValues = pLDAP->pfnldap_get_values( pld, pMessage, szSDProperty );

    if (!ppwszValues)
    {
        if (pld->ld_errno == LDAP_NO_SUCH_ATTRIBUTE)
        {
            DebugMsg((DM_VERBOSE, TEXT("CheckOUAccess:  Object can not be accessed.")));
            bResult = TRUE;
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CheckOUAccess:  ldap_get_values failed with 0x%x"),
                 pld->ld_errno));
        }
    }
    else
    {
        PLDAP_BERVAL *pSize;
        //
        // Get the length of the security descriptor
        //
        pSize = pLDAP->pfnldap_get_values_len(pld, pMessage, szSDProperty);

        if (!pSize)
        {
            DebugMsg((DM_WARNING, TEXT("CheckOUAccess:  ldap_get_values_len failed with 0x%x"),
                     pld->ld_errno));
        }
        else
        {
            //
            // Allocate the memory for the security descriptor
            //
            PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, (*pSize)->bv_len);

            if ( pSD == NULL )
            {
                DebugMsg((DM_WARNING, TEXT("CheckOUAccess:  Failed to allocate memory for SD with  %d"),
                         GetLastError()));
            }
            else
            {
                //
                // OU {bf967aa8-0de6-11d0-a285-00aa003049e2}
                //
                GUID OrganizationalUnit = { 0xbf967aa5, 0x0de6, 0x11d0, 0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2 };

                //
                // gPOptions {f30e3bbf-9ff0-11d1-b603-0000f80367c1}
                //
                GUID gPOptionsGuid = {  0xf30e3bbf, 0x9ff0, 0x11d1, 0xb6, 0x03, 0x00, 0x00, 0xf8, 0x03, 0x67, 0xc1 };

                //
                // gPLink {f30e3bbe-9ff0-11d1-b603-0000f80367c1}
                //
                GUID gPLinkGuid = { 0xf30e3bbe, 0x9ff0, 0x11d1, 0xb6, 0x03, 0x00, 0x00, 0xf8, 0x03, 0x67, 0xc1 };

                OBJECT_TYPE_LIST ObjType[] = {  { ACCESS_OBJECT_GUID, 0, &OrganizationalUnit },
                                                { ACCESS_PROPERTY_SET_GUID, 0, &gPLinkGuid },
                                                { ACCESS_PROPERTY_SET_GUID, 0, &gPOptionsGuid } };
                HRESULT hr;
                PRIVILEGE_SET PrivSet;
                DWORD PrivSetLength = sizeof(PRIVILEGE_SET);
                DWORD dwGrantedAccess;
                BOOL bAccessStatus = TRUE;
                GENERIC_MAPPING DS_GENERIC_MAPPING = {  DS_GENERIC_READ,
                                                        DS_GENERIC_WRITE,
                                                        DS_GENERIC_EXECUTE,
                                                        DS_GENERIC_ALL };

                //
                // Copy the security descriptor
                //
                CopyMemory( pSD, (PBYTE)(*pSize)->bv_val, (*pSize)->bv_len);

                //
                // Now we use RsopAccessCheckByType to determine if the user / machine
                // should have this GPO applied to them
                //

                hr = RsopAccessCheckByType(pSD,
                                           0,
                                           pRsopToken,
                                           ACTRL_DS_READ_PROP,
                                           ObjType,
                                           ARRAYSIZE(ObjType),
                                           &DS_GENERIC_MAPPING,
                                           &PrivSet,
                                           &PrivSetLength,
                                           &dwGrantedAccess,
                                           &bAccessStatus );
                if ( FAILED( hr ) )
                {
                    DebugMsg((DM_WARNING, TEXT("CheckOUAccess:  RsopAccessCheckByType failed with  %d"), GetLastError()));
                }
                else
                {
                    *pbAccessGranted = bAccessStatus;
                    bResult = TRUE;
                }

                LocalFree( pSD );
            }

            pLDAP->pfnldap_value_free_len(pSize);
        }

        pLDAP->pfnldap_value_free(ppwszValues);
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\policy\policy.c ===
//*************************************************************
//
//  Functions to apply policy
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include <regstr.h>
#include <winnetwk.h>
#include <lm.h>

//
// Update mode constants
//

#define UM_OFF                  0
#define UM_AUTOMATIC            1
#define UM_MANUAL               2


//
// Prefix constants for value names
//

#define NUM_PREFIX              3
#define PREFIX_UNKNOWN          0
#define PREFIX_DELETE           1
#define PREFIX_SOFT             2
#define PREFIX_DELVALS          3


//
// Max size of a value's data
//

#define MAX_VALUE_DATA       4096

//
// Default group size
//

#define DEFAULT_GROUP_SIZE   8192


//
// Registry value names
//

TCHAR g_szUpdateModeValue[] = TEXT("UpdateMode");
TCHAR g_szNetPathValue[] = TEXT("NetworkPath");
TCHAR g_szLogonKey[] = WINLOGON_KEY;
CHAR  g_szPolicyHandler[] = "PolicyHandler";  // This needs to be ANSI
TCHAR g_szTmpKeyName[] = TEXT("AdminConfigData");
TCHAR g_szPrefixDel[] = TEXT("**del.");
TCHAR g_szPrefixSoft[] = TEXT("**soft.");
TCHAR g_szPrefixDelvals[] = TEXT("**delvals.");


//
// Function proto-types
//

HKEY OpenUserKey(HKEY hkeyRoot, LPCTSTR pszName, BOOL * pfFoundSpecific);
UINT MergeRegistryData(HKEY hkeySrc, HKEY hkeyDst, LPTSTR pszKeyNameBuffer,
                       UINT cbKeyNameBuffer);
UINT CopyKeyValues(HKEY hkeySrc,HKEY hkeyDst);
BOOL HasSpecialPrefix(LPTSTR szValueName, DWORD * pdwPrefix,
        LPTSTR szStrippedValueName);
BOOL GetGroupProcessingOrder(HKEY hkeyHiveRoot,LPTSTR * pGroupBuffer, DWORD * pdwGroupSize);
BOOL FindGroupInList(LPTSTR pszGroupName, LPTSTR pszGroupList);
LPTSTR GetUserGroups (LPCTSTR lpServerName, LPCTSTR lpUserName, HANDLE hToken, DWORD * puEntriesRead);


//*************************************************************
//
//  ApplySystemPolicy()
//
//  Purpose:    Entry point for Windows NT4 System Policy.
//
//  Parameters: dwFlags         - Flags
//              hToken          - User's token
//              hKeyCurrentUser - Registry to the root of the user's hive
//              lpUserName      - User's name
//              lpPolicyPath    - Path to the policy file (ntconfig.pol). Can be NULL.
//              lpServerName    - Domain controller name used for group
//                                membership look up.  Can be NULL.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//  Comments:
//
//  History:    Date        Author     Comment
//              05/30/95    ericflo    Created
//              10/12/98    ericflo    Update for NT5
//
//*************************************************************

BOOL WINAPI ApplySystemPolicy (DWORD dwFlags, HANDLE hToken, HKEY hKeyCurrentUser,
                               LPCTSTR lpUserName, LPCTSTR lpPolicyPath,
                               LPCTSTR lpServerName)
{
    LONG lResult;
    BOOL bResult = FALSE;
    BOOL fFoundUser=FALSE;
    HKEY hkeyMain=NULL, hkeyRoot=NULL, hkeyUser, hkeyLogon;
    DWORD dwUpdateMode=UM_AUTOMATIC;
    DWORD dwData, dwSize;
    TCHAR szFilePath[MAX_PATH];
    TCHAR szLocalPath[MAX_PATH];
    TCHAR szTempDir[MAX_PATH];
    TCHAR szTempKey[100];
    CHAR szHandler[MAX_PATH+50];  // This needs to be ANSI
    TCHAR szComputerName[MAX_PATH];
    TCHAR szBuffer[MAX_PATH+1];
    WIN32_FILE_ATTRIBUTE_DATA fad;
    LPTSTR lpEnd;
    HANDLE hOldToken;


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy: Entering")));



    //
    // Initialize szFilePath
    //

    szFilePath[0] = TEXT('\0');


    //
    // Check the registry to see if update is specified and get update path
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            REGSTR_PATH_UPDATE,
                            0,
                            KEY_READ,
                            &hkeyMain);


    if (lResult == ERROR_SUCCESS) {


        //
        // Look for the update mode.
        //

        dwSize=sizeof(dwUpdateMode);
        if (RegQueryValueEx(hkeyMain,g_szUpdateModeValue,NULL,NULL,
                (LPBYTE) &dwUpdateMode,&dwSize) != ERROR_SUCCESS) {
                dwUpdateMode = UM_OFF;
        }


        //
        // if manual update is specified, also get the path to update from
        // (UNC path or path with drive letter)
        //


        if (dwUpdateMode==UM_MANUAL) {

            dwSize=sizeof(szTempDir);

            lResult = RegQueryValueEx(hkeyMain, g_szNetPathValue, NULL, NULL,
                                      (LPBYTE) szTempDir, &dwSize);

            if (lResult != ERROR_SUCCESS) {
                TCHAR szErr[MAX_PATH];

                RegCloseKey(hkeyMain);
                ReportError(hToken, PI_NOUI, 1, EVENT_MISSINGPOLICYFILEENTRY, GetErrString(lResult, szErr));
                return FALSE;
            }

            ExpandEnvironmentStrings (szTempDir, szFilePath, MAX_PATH);
        }

        RegCloseKey(hkeyMain);
    }


    //
    // If this machine has policy turned off, then we can exit now.
    //

    if (dwUpdateMode == UM_OFF) {
        DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  Policy is turned off on this machine.")));
        return TRUE;
    }


    //
    // If we are running in automatic mode, use the supplied
    // policy file.
    //

    if (dwUpdateMode == UM_AUTOMATIC) {

        if (lpPolicyPath && *lpPolicyPath) {
            lstrcpy (szFilePath, lpPolicyPath);
        }
    }


    //
    // If we don't have a policy file, then we can exit now.
    //

    if (szFilePath[0] == TEXT('\0')) {
        DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  No Policy file.  Leaving.")));
        return TRUE;
    }

    DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  PolicyPath is: <%s>."), szFilePath));


    //
    // Impersonate the user
    //

    if (!ImpersonateUser(hToken, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy: Failed to impersonate user")));
        return FALSE;
    }


    //
    // Test if the policy file exists
    //

    if (!GetFileAttributesEx (szFilePath, GetFileExInfoStandard, &fad)) {

        lResult = GetLastError();

        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy: Failed to revert to self")));
        }


        if ( (lResult == ERROR_FILE_NOT_FOUND) ||
             (lResult == ERROR_PATH_NOT_FOUND) ) {

            DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  No policy file.")));
            return TRUE;

        } else {
            DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  Failed to query for policy file with error %d."), lResult));
            return FALSE;
        }
    }


    //
    //  Create a temporary file name
    //

    dwSize = ARRAYSIZE(szBuffer);

    if (!GetUserProfileDirectory(hToken, szBuffer, &dwSize)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to query user profile directory with error %d."), GetLastError()));
        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy: Failed to revert to self")));
        }
        return FALSE;
    }


    if (!GetTempFileName (szBuffer, TEXT("prf"), 0, szLocalPath)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to create temporary filename with error %d."), GetLastError()));
        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy: Failed to revert to self")));
        }
        return FALSE;
    }


    //
    // Copy the policy hive
    //

    if (!CopyFile(szFilePath, szLocalPath, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to copy policy file with error %d."), GetLastError()));
        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy: Failed to revert to self")));
        }
        goto Exit;
    }


    //
    // Revert to being 'ourself'
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy: Failed to revert to self")));
    }


    DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  Local PolicyPath is: <%s>."), szLocalPath));


    //
    // Query for the computer name
    //

    dwSize = ARRAYSIZE(szComputerName);
    if (!GetComputerName(szComputerName, &dwSize)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  GetComputerName failed.")));
        goto Exit;
    }



    //
    // Check to see if an installable policy handler has been added.  If
    // so, call it and let it do the work.
    //

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           g_szLogonKey,
                           0,
                           KEY_READ,
                           &hkeyLogon);


    if (lResult == ERROR_SUCCESS) {
        HANDLE hDLL = NULL;
        BOOL fRet;
        PFNPROCESSPOLICIES pfn;


        dwSize = ARRAYSIZE(szHandler);
        lResult = RegQueryValueExA(hkeyLogon,
                                   g_szPolicyHandler,
                                   NULL, NULL,
                                   (LPBYTE) szHandler,
                                   &dwSize);


        RegCloseKey(hkeyLogon);

        if (lResult == ERROR_SUCCESS) {
            LPSTR lpEntryPoint = szHandler;

            DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  Machine has a custom Policy Handler of:  %S."), szHandler));

            //
            // Search for the ,
            //

            while (*lpEntryPoint && *lpEntryPoint != TEXT(',')) {
                lpEntryPoint++;
            }


            //
            // Check if we found the ,
            //

            if (*lpEntryPoint) {

                *lpEntryPoint = TEXT('\0');
                lpEntryPoint++;


                hDLL = LoadLibraryA(szHandler);

                if (hDLL) {

                    pfn = (PFNPROCESSPOLICIES) GetProcAddress(hDLL, lpEntryPoint);

                    if (pfn != NULL) {

                        //
                        // Call the function.
                        // Note that the parameters are UNICODE.
                        //

                        fRet = (*pfn) (NULL,
                                       szLocalPath,
                                       lpUserName,
                                       szComputerName,
                                       0);


                        //
                        // if callout policy downloader returns FALSE, then we don't
                        // do any processing on our own.  If it returns TRUE then we
                        // go ahead and process policies normally, in addition to whatever
                        // he may have done.
                        //

                        if (!fRet) {
                            FreeLibrary(hDLL);
                            bResult = TRUE;
                            goto Exit;
                        }

                    } else {
                       DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to find entry point %S in policy dll.  Error %d."),
                                lpEntryPoint, GetLastError()));
                    }

                    FreeLibrary(hDLL);

                } else {
                   DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to load %S with error %d."),
                            szHandler, GetLastError()));
                }
            }
        }
    }


    //
    // Load the policy hive into registry
    //

    wsprintf (szTempKey, TEXT("%s (%d)"), g_szTmpKeyName, GetTickCount());

    lResult = MyRegLoadKey(HKEY_USERS, szTempKey, szLocalPath);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to load policy hive.  Error = %d"), lResult));
        goto Exit;
    }

    //
    // Open the policy hive.
    //

    lResult = RegOpenKeyEx (HKEY_USERS,
                            szTempKey,
                            0,
                            KEY_READ,
                            &hkeyMain);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to open policy hive.  Error = %d"), lResult));
        MyRegUnLoadKey(HKEY_USERS, szTempKey);
        goto Exit;
    }


    //
    // For user and machine policies, see if there is an appropriate entry
    // in policy file (either a key with user/computer name,
    // or a default user or workstation entry).  If there is, then merge
    // information under that key into registry.  (If there isn't, it's
    // not an error-- just nothing to do.)
    //

    if (dwFlags & SP_FLAG_APPLY_USER_POLICY) {

        //
        // Merge user-specific policies if user name was specified
        //

        if (RegOpenKeyEx(hkeyMain,
                         REGSTR_KEY_POL_USERS,
                         0,
                         KEY_READ,
                         &hkeyRoot) == ERROR_SUCCESS) {


            DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  Looking for user specific policy.")));

            hkeyUser = OpenUserKey(hkeyRoot, lpUserName, &fFoundUser);

            if (hkeyUser) {
                MergeRegistryData(hkeyUser,hKeyCurrentUser,szBuffer, ARRAYSIZE(szBuffer));
                RegCloseKey(hkeyUser);
            }

            RegCloseKey(hkeyRoot);
        }



        //
        // Merge group specific policies if user name specified, and we
        // *didn't* find a specific user entry above
        //

        if (!fFoundUser && lpServerName && *lpServerName) {
            HKEY hkeyGroups, hkeyGroup;
            LPTSTR GroupBuffer, ApiBuf;
            DWORD dwGroupSize = DEFAULT_GROUP_SIZE;
            DWORD uEntriesRead;


            DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  Processing group(s) policy.")));

            GroupBuffer = GlobalAlloc(GPTR, DEFAULT_GROUP_SIZE * sizeof(TCHAR));

            if (GroupBuffer) {

                //
                // if there is a group processing order specified in policy hive,
                // then process groups
                //

                if (RegOpenKeyEx(hkeyMain,
                                 REGSTR_KEY_POL_USERGROUPS,
                                 0,
                                 KEY_READ,
                                 &hkeyGroups) == ERROR_SUCCESS) {


                    if (GetGroupProcessingOrder(hkeyMain, &GroupBuffer, &dwGroupSize)) {

                        //
                        // Enumerate the groups that this user belongs to
                        //

                        ApiBuf = GetUserGroups (lpServerName, lpUserName, hToken, &uEntriesRead);

                        if (ApiBuf) {

                            DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  User belongs to %d groups."), uEntriesRead));

                            if (uEntriesRead) {

                                //
                                // Walk through the list of groups (ordered lowest priority
                                // to highest priority).  for each group, if the user belongs
                                // to it then download policies for that group.
                                //

                                LPTSTR pszGroup = GroupBuffer;
                                TCHAR szKeyNameBuffer[MAX_PATH+1];

                                while (*pszGroup) {

                                    //
                                    // Does user belong to this group?
                                    //

                                    if (FindGroupInList(pszGroup, ApiBuf)) {

                                        //
                                        // Open the key in the hive for this group
                                        //

                                        if (RegOpenKeyEx (hkeyGroups,
                                                          pszGroup,
                                                          0,
                                                          KEY_READ,
                                                          &hkeyGroup) == ERROR_SUCCESS) {


                                            //
                                            // Merge group policies
                                            //

                                            MergeRegistryData(hkeyGroup,
                                                              hKeyCurrentUser,
                                                              szKeyNameBuffer,
                                                              ARRAYSIZE(szKeyNameBuffer));

                                            RegCloseKey (hkeyGroup);
                                        }
                                    }

                                    pszGroup += lstrlen(pszGroup) + 1;
                                }
                            }

                            GlobalFree (ApiBuf);

                        } else {
                           DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to get user's groups.")));
                        }

                    } else {
                        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to get group processing order.")));
                    }

                    RegCloseKey(hkeyGroups);

                } else {
                    DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to allocate memory for group policy.  Error = %d"), GetLastError()));
                }

                GlobalFree (GroupBuffer);

            } else {
                DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to allocate memory for group policy.  Error = %d"), GetLastError()));
            }
        }
    }


    if (dwFlags & SP_FLAG_APPLY_MACHINE_POLICY) {

        //
        // Merge machine-specific policies if computer name was specified
        //

        if (RegOpenKeyEx(hkeyMain,
                         REGSTR_KEY_POL_COMPUTERS,
                         0,
                         KEY_READ,
                         &hkeyRoot) == ERROR_SUCCESS) {

            DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  Looking for machine specific policy.")));

            hkeyUser = OpenUserKey(hkeyRoot, szComputerName, &fFoundUser);

            if (hkeyUser) {
                MergeRegistryData(hkeyUser, HKEY_LOCAL_MACHINE, szBuffer, ARRAYSIZE(szBuffer));
                RegCloseKey(hkeyUser);
            }

            RegCloseKey(hkeyRoot);
        }
    }



    //
    // Close the policy key
    //

    RegCloseKey(hkeyMain);


    //
    // Unload the policy hive.
    //

    if (!MyRegUnLoadKey(HKEY_USERS, szTempKey)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to unload policy hive.  Error = %d"), lResult));
        goto Exit;
    }


    //
    // Success
    //

    bResult = TRUE;

Exit:

    //
    // Delete the policy files
    //

    if (!DeleteFile (szLocalPath)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to delete policy file <%s>.  Error %d"),
                 szLocalPath, GetLastError()));
    }

    lstrcat (szLocalPath, c_szLog);
    if (!DeleteFile (szLocalPath)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to delete policy log file <%s>.  Error %d"),
                 szLocalPath, GetLastError()));
    }


    DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  Leaving with %d"), bResult));

    return bResult;
}


//*************************************************************
//
//  OpenUserKey()
//
//  Purpose:    Attempts to open the user specific key, or the
//              .default key.
//
//  Parameters: hkeyRoot       -   Root key
//              pszName        -   User name
//              fFoundSpecific -   Found the requested key
//
//  Return:     hkey if successful
//              NULL if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/13/95     ericflo    Ported
//
//*************************************************************

HKEY OpenUserKey(HKEY hkeyRoot,LPCTSTR pszName, BOOL *pfFoundSpecific)
{
    HKEY hkeyTest;
    *pfFoundSpecific = FALSE;

    //
    // See if there is a subkey under the specified key with the given
    // user name
    //

    if ((RegOpenKeyEx(hkeyRoot,
                      pszName,
                      0,
                      KEY_READ,
                      &hkeyTest)) == ERROR_SUCCESS) {

        *pfFoundSpecific = TRUE;
        DebugMsg((DM_VERBOSE, TEXT("OpenUserKey:  Found specific entry for %s ignoring .Default."), pszName));
        return hkeyTest;
    }

    //
    // If not, see if there is a default key
    //

    if ((RegOpenKeyEx(hkeyRoot,
                      REGSTR_KEY_POL_DEFAULT,
                      0,
                      KEY_READ,
                      &hkeyTest)) == ERROR_SUCCESS) {

        DebugMsg((DM_VERBOSE, TEXT("OpenUserKey:  No entry for %s, using .Default instead."), pszName));
        return hkeyTest;
    }


    //
    // No entry for this name in policy file
    //

    DebugMsg((DM_VERBOSE, TEXT("OpenUserKey:  No user/machine specific policy and no .Default policy.")));
    return NULL;
}


//*************************************************************
//
//  MergeRegistryData()
//
//  Purpose:    Merges hkeySrc and subkeys into hkeyDst.
//
//  Parameters: hkeySrc          -   Source
//              hkeyDst          -   Destination
//              pszKeyNameBuffer - Key name
//              cbKeyNameBuffer  - Size of key name buffer
//      
//
//  Return:     ERROR_SUCCESS if successful
//              otherwise an error value
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/13/95     ericflo    Ported
//
//*************************************************************

UINT MergeRegistryData(HKEY hkeySrc, HKEY hkeyDst, LPTSTR pszKeyNameBuffer,
                       UINT cbKeyNameBuffer)
{
    UINT nIndex = 0,uRet=ERROR_SUCCESS;

    //
    // Look for any subkeys of the source key
    //

    while ((uRet=RegEnumKey(hkeySrc,nIndex,pszKeyNameBuffer,
        cbKeyNameBuffer)) == ERROR_SUCCESS) {

        HKEY hkeySubkeySrc,hkeySubkeyDst;


        //
        // Create the subkey under the destination key
        //

        if ((uRet=RegCreateKey(hkeyDst,pszKeyNameBuffer,
                &hkeySubkeyDst)) != ERROR_SUCCESS)
                return uRet;

        if ((uRet=RegOpenKey(hkeySrc, pszKeyNameBuffer,
                &hkeySubkeySrc)) != ERROR_SUCCESS) {
                RegCloseKey(hkeySubkeyDst);
                return uRet;
        }


        //
        // Copy the key values from source subkey to destination subkey
        //

        uRet=CopyKeyValues(hkeySubkeySrc,hkeySubkeyDst);

        if (uRet == ERROR_SUCCESS) {

             //
             // Merge recursively on subkeys of these keys, if any
             //

             uRet = MergeRegistryData(hkeySubkeySrc,hkeySubkeyDst,pszKeyNameBuffer,
                     cbKeyNameBuffer);
        }

        RegCloseKey(hkeySubkeySrc);
        RegCloseKey(hkeySubkeyDst);

        if (uRet != ERROR_SUCCESS) {
            return uRet;
        }

        nIndex ++;
    }


    if (uRet == ERROR_NO_MORE_ITEMS) {
        uRet=ERROR_SUCCESS;
    }

    return uRet;
}

//*************************************************************
//
//  CopyKeyValues()
//
//  Purpose:    Copies all key values from hkeySrc to hkeyDst
//
//  Parameters: hkeySrc -   Source
//              hkeyDst -   destination
//
//  Return:     Error code
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/14/95     ericflo    Ported
//
//*************************************************************

UINT CopyKeyValues(HKEY hkeySrc, HKEY hkeyDst)
{
    DWORD dwSubkeyCount,dwMaxSubkeyNameLen,dwMaxClassNameLen,dwValueCount,
          dwMaxValueNameLen,dwMaxValueDataLen,dwDescriptorLen,dwClassNameLen;
    FILETIME ftLastWriteTime;
    UINT uRet=ERROR_SUCCESS;
    TCHAR szClassName[255];

    //
    // Do RegQueryInfoKey to find out if there are values for the source key,
    // and the size of value name and value data buffes to alloc
    //

    dwClassNameLen = ARRAYSIZE(szClassName);

    uRet=RegQueryInfoKey(hkeySrc,szClassName,&dwClassNameLen,NULL,&dwSubkeyCount,
            &dwMaxSubkeyNameLen,&dwMaxClassNameLen,&dwValueCount,&dwMaxValueNameLen,
            &dwMaxValueDataLen,&dwDescriptorLen,&ftLastWriteTime);

    if (uRet != ERROR_SUCCESS) {
        return uRet;
    }


    //
    // If there are values...
    //


    if (dwValueCount) {
        TCHAR  ValueName[MAX_PATH];
        LPBYTE ValueData;
        DWORD  dwType,dwValueNameSize,dwValueDataSize;
        UINT nIndex = 0;


        ValueData = GlobalAlloc (GPTR, MAX_VALUE_DATA);

        if (!ValueData) {
            return GetLastError();
        }

        //
        // the "**delvals" control code is special, must be processed
        // first; look for it now and if it exists delete all existing
        // values under this key in destination registry
        //

        if (RegQueryValueEx(hkeySrc,g_szPrefixDelvals,NULL,NULL,NULL,NULL) == ERROR_SUCCESS) {

            DeleteAllValues(hkeyDst);
        }

        //
        // Enumerate the values of the source key, and create each value
        // under the destination key
        //

        do  {
            dwValueNameSize = MAX_PATH;
            dwValueDataSize = MAX_VALUE_DATA;

            if ((uRet=RegEnumValue(hkeySrc,nIndex, ValueName,
                    &dwValueNameSize,NULL,&dwType, ValueData,
                    &dwValueDataSize)) == ERROR_SUCCESS) {

                 DWORD dwPrefix;

                 //
                 // Look for special prefixes which indicate we should treat
                 // these values specially
                 //

                 if (HasSpecialPrefix(ValueName, &dwPrefix, ValueName)) {

                     //
                     // ValueName now contains real value name stripped
                     // of prefix, filled in above by HasSpecialPrefix().
                     // Adjust value name size, the value name will shorten
                     // because the prefix has been removed.
                     //

                     dwValueNameSize = lstrlen (ValueName) + 1;

                     switch (dwPrefix) {

                         case PREFIX_DELETE:

                             //
                             // Delete this value in destination
                             //

                             RegDeleteValue(hkeyDst, ValueName);
                             uRet = ERROR_SUCCESS;
                             DebugMsg((DM_VERBOSE, TEXT("Deleted value: %s"), ValueName));
                             break;

                         case PREFIX_SOFT:

                             //
                             // "soft" value, only set this if it doesn't already
                             // exist in destination
                             //

                             {

                             TCHAR TmpValueData[MAX_PATH+1];
                             DWORD dwSize=sizeof(TmpValueData);

                             if (RegQueryValueEx(hkeyDst, ValueName,
                                     NULL,NULL,(LPBYTE) TmpValueData,
                                     &dwSize) != ERROR_SUCCESS) {

                                 //
                                 // The value doesn't exist, set the value.
                                 //

                                 uRet=RegSetValueEx(hkeyDst, ValueName, 0,
                                                    dwType, ValueData,
                                                    dwValueDataSize);

                             } else {

                                 //
                                 // Value already exists, nothing to do
                                 //

                                 uRet = ERROR_SUCCESS;
                             }

                             }

                             break;

                         case PREFIX_DELVALS:
                             // processed early on above, fall through and ignore

                         default:

                             //
                             // Got some prefix that we don't understand... presumably,
                             // from a future version.  Ignore this value, rather than
                             // propagating it into the registry, prefix and all.
                             // This will give us less backward compatibility headaches
                             // down the road.
                             //

                             uRet = ERROR_SUCCESS;   // nothing to do

                             break;
                     }
                 } else {

                     //
                     // Copy the value normally to destination key
                     //

                     uRet=RegSetValueEx(hkeyDst,ValueName,0,
                             dwType,ValueData,dwValueDataSize);

#if DBG
                     if (uRet == ERROR_SUCCESS) {

                        switch (dwType) {
                            case REG_SZ:
                            case REG_EXPAND_SZ:
                                DebugMsg((DM_VERBOSE, TEXT("CopyKeyValues: %s => %s  [OK]"),
                                         ValueName, (LPTSTR)ValueData));
                                break;

                            case REG_DWORD:
                                DebugMsg((DM_VERBOSE, TEXT("CopyKeyValues: %s => %d  [OK]"),
                                         ValueName, (DWORD)*ValueData));
                                break;

                            default:
                                DebugMsg((DM_VERBOSE, TEXT("CopyKeyValues: %s was set successfully"),
                                         ValueName));
                        }

                     } else {
                         DebugMsg((DM_WARNING, TEXT("CopyKeyValues: Failed to set %s with error %d."),
                                  ValueName, uRet));
                     }
#endif

                 }
            }

            nIndex++;

        } while (uRet == ERROR_SUCCESS);


        if (uRet == ERROR_NO_MORE_ITEMS) {
            uRet=ERROR_SUCCESS;
        }

        GlobalFree (ValueData);
    }

    return uRet;
}


//*************************************************************
//
//  HasSpecialPrefix()
//
//  Purpose:    Checks to see if szValueName has a special prefix (a la
//              "**<something>."  Returns TRUE if it does, FALSE otherwise.
//              if TRUE, returns the numerical index of the prefix in *pdwPrefix,
//              and copies the rest of value name (after the ".") into
//              szStrippedValueName.  Buffer for szStrippedValueName must be at
//              least as large as szValueName.  It is safe to pass the same
//              buffer to szValueName and szStrippedValueName and have the name
//              modified in place.
//
//  Parameters: szValueName         -   Value Name
//              pdwPrefix           -   Index of the prefix
//              szStrippedValueName -   Value name without the **
//      
//
//  Return:     TRUE if value name has a prefix
//              FALSE if it does not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/14/95     ericflo    Ported
//
//*************************************************************

typedef struct tagPREFIXMAP {
    const LPTSTR pszPrefix;
    DWORD dwPrefixIndex;
} PREFIXMAP;



BOOL HasSpecialPrefix(LPTSTR szValueName, DWORD * pdwPrefix,
                      LPTSTR szStrippedValueName)
{

    PREFIXMAP PrefixMap[] = {
            {g_szPrefixDel, PREFIX_DELETE},
            {g_szPrefixSoft, PREFIX_SOFT},
            {g_szPrefixDelvals, PREFIX_DELVALS}
    };
    UINT nCount,nLen;


    //
    // Does the value name begin with "**"?
    //

    if (!szValueName || (lstrlen(szValueName) < 2) ||
         szValueName[0] != TEXT('*') || szValueName[1] != TEXT('*'))

        return FALSE;   // not a special prefix


    //
    // Try all the prefixes we know to try to find a match
    //

    for (nCount = 0; nCount < ARRAYSIZE(PrefixMap); nCount++) {
         nLen = lstrlen (PrefixMap[nCount].pszPrefix);

         if (CompareString (LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                            szValueName, nLen,
                            PrefixMap[nCount].pszPrefix, nLen) == 2) {

             *pdwPrefix = PrefixMap[nCount].dwPrefixIndex;

             //
             // make a copy of the value name, sans prefix, into
             // the stripped value name buffer
             //

             lstrcpy (szStrippedValueName,szValueName + nLen);
             return TRUE;
         }
    }

    //
    // this is a prefix, but not one we know.
    //

    *pdwPrefix = PREFIX_UNKNOWN;
    lstrcpy (szStrippedValueName,szValueName);
    return TRUE;
}

//*************************************************************
//
//  GetGroupProcessingOrder()
//
//  Purpose:    Gets the list of groups in order
//
//  Parameters: hkeyHiveRoot    -   Registry key
//              GroupBuffer     -   Pointer to group buffer
//              pdwBufferSize   -   Buffer size
//
//  Return:     Number of entries if successful
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/14/95     ericflo    Ported
//
//*************************************************************

BOOL GetGroupProcessingOrder(HKEY hkeyHiveRoot, LPTSTR * pGroupBuffer,
                             DWORD * pdwGroupSize)
{
    DWORD cEntries,cMaxValueName,cMaxData;
    HKEY hkeyGroupData;
    UINT uRet;
    LPTSTR GroupBuffer = *pGroupBuffer;
    LPTSTR lpTemp;
    DWORD dwGroupSize = *pdwGroupSize;
    TCHAR szValueName[10], szGroupName[48+1]; // netware groups can be up to 48 chars
    DWORD dwUsed = 0, dwSize;       // amount of buffer used
    UINT nLen,nRead=0;


    //
    // Open the group data key
    //

    uRet = RegOpenKeyEx(hkeyHiveRoot,
                        REGSTR_KEY_POL_USERGROUPDATA,
                        0,
                        KEY_READ,
                        &hkeyGroupData);

    if (uRet != ERROR_SUCCESS) {

        //
        // Group data key doesn't exist (most likely), no downloading to do
        //

        return FALSE;
    }


    //
    // Find out the number of values in group data key
    //

    if ((RegQueryInfoKey (hkeyGroupData,NULL,NULL,NULL,NULL,NULL,
            NULL,&cEntries,&cMaxValueName,&cMaxData,NULL,NULL ) != ERROR_SUCCESS) ||
            !cEntries) {

        RegCloseKey(hkeyGroupData);
        return FALSE;
    }


    //
    // The values are stored as "1"="<group name>", "2"="<group name>", etc.
    // where 1 is most important.  we will pack the names into a buffer lowest
    // priority to highest.  So if we have n values, start with value name "<n>"
    // and work down to "1".
    //

    while (cEntries) {

       wsprintf(szValueName, TEXT("%lu"), cEntries);

       dwSize = ARRAYSIZE(szGroupName);

       if (RegQueryValueEx(hkeyGroupData,szValueName,NULL,NULL,
               (LPBYTE) szGroupName,&dwSize) == ERROR_SUCCESS) {

               nLen = lstrlen(szGroupName) + 1;

               //
               // Resize buffer if neccessary (add 1 for extra terminating null)
               //

               if (nLen + dwUsed + 1 > dwGroupSize) {

                   //
                   // add a little extra so we don't realloc on every item
                   //

                   dwGroupSize = dwGroupSize + nLen + 256;

                   lpTemp = GlobalReAlloc(GroupBuffer,
                                          (dwGroupSize * sizeof(TCHAR)),
                                          GMEM_MOVEABLE);

                   if (!lpTemp) {

                       RegCloseKey(hkeyGroupData);
                       return FALSE;
                   }

                   GroupBuffer = lpTemp;
               }

               lstrcpy(GroupBuffer + dwUsed, szGroupName);
               dwUsed += nLen;
               nRead++;
       }

       cEntries --;
    }

    //
    // Doubly null-terminate buffer
    //

    *(GroupBuffer + dwUsed) = TEXT('\0');

    RegCloseKey(hkeyGroupData);

    *pGroupBuffer = GroupBuffer;
    *pdwGroupSize = dwGroupSize;

    return (nRead > 0);
}

//*************************************************************
//
//  FindGroupInList()
//
//  Purpose:    Determines if the requested group
//              is in the list of groups
//
//  Parameters: pszGroupName    -   Group looking for
//              pszGroupList    -   List of groups null seperated
//
//  Return:     TRUE if found
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/15/95     ericflo    Ported
//
//*************************************************************

BOOL FindGroupInList(LPTSTR pszGroupName, LPTSTR pszGroupList)
{

    while (*pszGroupList) {

        if (!lstrcmpi(pszGroupList,pszGroupName)) {
            DebugMsg((DM_VERBOSE, TEXT("FindGroupInList:  User is a member of the %s group."), pszGroupName));
            return TRUE;
        }

        pszGroupList += lstrlen(pszGroupList) + 1;
    }

    DebugMsg((DM_VERBOSE, TEXT("FindGroupInList:  User is NOT a member of the %s group."), pszGroupName));
    return FALSE;
}

//*************************************************************
//
//  GetUserGroups()
//
//  Purpose:    Retrieves a list of groups this user belongs to
//
//  Parameters: lpServerName   -  Server name
//              lpUserName     -  User name
//              hToken         -  User's token
//              puEntriesRead  -  Number of groups
//
//  Return:     Pointer to list if successful
//              Null if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/15/95     ericflo    Created
//
//*************************************************************

LPTSTR GetUserGroups (LPCTSTR lpServerName, LPCTSTR lpUserName,
                      HANDLE hToken, DWORD * puEntriesRead)
{
    UINT nIndex;
    NET_API_STATUS status;
    LPBYTE lpGroups, lpTemp;
    PGROUP_INFO_0  pgi0;
    DWORD dwEntriesRead, dwTotalEntries;
    DWORD cchSizeNeeded;
    LPTSTR lpGroupNames, lpName;
    PNETAPI32_API pNetAPI32;
    HANDLE hOldToken;


    //
    // Load netapi32
    //

    pNetAPI32 = LoadNetAPI32();
    
    if (!pNetAPI32) {
        DebugMsg((DM_WARNING, TEXT("GetUserGroups:  Failed to load netapi32 with %d."),
                 GetLastError()));
        return NULL;
    }


    //
    // Impersonate the user
    //

    if (!ImpersonateUser(hToken, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("GetUserGroups: Failed to impersonate user")));
        return NULL;
    }


    //
    // Query for the groups
    //

    status = pNetAPI32->pfnNetUserGetGroups (lpServerName, lpUserName,
                                           0, &lpGroups, 0xFFFFFFFF, &dwEntriesRead,
                                           &dwTotalEntries);

    if (status == NERR_Success) {

        //
        // NetUserGetGroups opens a named pipe to the server.  To close
        // it, we need to call NetUserGetInfo on the local machine
        //

        if (pNetAPI32->pfnNetUserGetInfo (NULL, lpUserName,
                                        0, &lpTemp) == NERR_Success) {
            pNetAPI32->pfnNetApiBufferFree (lpTemp);
        }


    } else {
        DebugMsg((DM_VERBOSE, TEXT("GetUserGroups: NetUserGetGroups failed with %d"), status));
        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("GetUserGroups: Failed to revert to self")));
        }
        return NULL;
    }


    //
    // Revert to self
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("GetUserGroups: Failed to revert to self")));
    }


    //
    // NetUserGetGroups returns names packed in structures with fixed-length
    // fields.  Need to copy that into caller's buffer packed with the names
    // packed end-to-end.
    //
    // Count the total buffer size we need, which will be smaller than the
    // API buffer to NetUserGetGroups because we're not using fixed-length
    // fields
    //

    cchSizeNeeded = 1;
    pgi0 = (PGROUP_INFO_0) lpGroups;

    for (nIndex=0; nIndex < dwEntriesRead; nIndex++) {

         cchSizeNeeded += lstrlen(pgi0->grpi0_name) + 1;
         pgi0++;
    }

    *puEntriesRead = dwEntriesRead;

    //
    // Build the list of group names
    //

    lpGroupNames = GlobalAlloc (GPTR, cchSizeNeeded * sizeof (TCHAR));

    if (!lpGroupNames) {
        pNetAPI32->pfnNetApiBufferFree (lpGroups);
        return NULL;
    }

    DebugMsg((DM_VERBOSE, TEXT("GetUserGroups: User is a member of the following global groups:")));

    lpName = lpGroupNames;
    pgi0 = (PGROUP_INFO_0) lpGroups;

    for (nIndex=0; nIndex < dwEntriesRead; nIndex++) {

         DebugMsg((DM_VERBOSE, TEXT("GetUserGroups:     %s"), pgi0->grpi0_name));
         lstrcpy (lpName, pgi0->grpi0_name);
         lpName += lstrlen(pgi0->grpi0_name) + 1;
         pgi0++;
    }

    //
    // Free the memory allocated by NetUserGetGroups
    //

    pNetAPI32->pfnNetApiBufferFree (lpGroups);

    return lpGroupNames;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\policy\policy.h ===
//*************************************************************
//
//  Policy functions header file
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

BOOL ApplyPolicy (LPPROFILE lpProfile);

typedef struct _ADTTHREADINFO {
    LPPROFILE lpProfile;
    HDESK     hDesktop;
    FILETIME  ftPolicyFile;
    LPTSTR    lpADTPath;
} ADTTHREADINFO, *LPADTTHREADINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\profile\copydir.c ===
//*************************************************************
//
//  Functions to copy the profile directory
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"


//
// Local function proto-types
//

BOOL RecurseDirectory (HANDLE hTokenUser, LPTSTR lpSrcDir, LPTSTR lpDestDir, DWORD dwFlags,
                       LPFILEINFO *llSrcDirs, LPFILEINFO *llSrcFiles,
                       BOOL bSkipNtUser, LPTSTR lpExcludeList, BOOL bRecurseDest);
BOOL AddFileInfoNode (LPFILEINFO *lpFileInfo, LPTSTR lpSrcFile,
                      LPTSTR lpDestFile, LPFILETIME ftLastWrite, LPFILETIME ftCreate,
                      DWORD dwFileSize, DWORD dwFileAttribs, BOOL bHive);
BOOL FreeFileInfoList (LPFILEINFO lpFileInfo);
BOOL SyncItems (LPFILEINFO lpSrcItems, LPFILEINFO lpDestItems,
                BOOL bFile, LPFILETIME ftDelRefTime);
void CopyFileFunc (LPTHREADINFO lpThreadInfo);
LPTSTR ConvertExclusionList (LPCTSTR lpSourceDir, LPCTSTR lpExclusionList);
DWORD FindDirectorySize(LPTSTR lpDir, LPFILEINFO lpFiles, DWORD dwFlags, DWORD* pdwLargestHiveFile, DWORD* pdwTotalFiles);
DWORD FindTotalDiskSpaceNeeded(DWORD        dwTotalSrcFiles,
                               DWORD        dwTotalDestFiles,
                               DWORD        dwLargestHiveFile,
                               LPFILEINFO   lpSrcFiles,
                               DWORD        dwFlags);
DWORD FindTotalNMaxFileSize(LPFILEINFO lpSrcFiles, DWORD dwNumOfFiles);
BOOL ReconcileDirectory(LPTSTR lpSrcDir, LPTSTR lpDestDir, 
                        DWORD dwFlags, DWORD dwSrcAttribs);

//*************************************************************
//
//  CopyProfileDirectoryEx()
//
//  Purpose:    Copies the profile directory from the source
//              to the destination
//
//
//  Parameters: LPCTSTR     lpSourceDir     -  Source directory
//              LPCTSTR     lpDestDir       -  Destination directory
//              DWORD       dwFlags         -  Flags
//              LPFILETIME  ftDelRefTime    -  Delete file reference time
//              LPCTSTR     lpExclusionList -  List of directories to exclude
//
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//
//  Comments:   Called after impersonating the user.
//
//
//  History:    Date        Author     Comment
//              5/24/95     ericflo    Created
//              4/09/98     ericflo    Converted to CopyProfileDirectoryEx
//              9/28/98     ushaji     Modified to check for free space
//              3/14/00     weiruc     Modified to copy hive file even if
//                                     hive is still loaded and ignore copy
//                                     hive file errors.
//
//*************************************************************

BOOL CopyProfileDirectoryEx (LPCTSTR lpSourceDir,
                             LPCTSTR lpDestinationDir,
                             DWORD dwFlags,
                             LPFILETIME ftDelRefTime,
                             LPCTSTR lpExclusionList)
{
    LPTSTR lpSrcDir = NULL, lpDestDir = NULL;
    LPTSTR lpSrcEnd, lpDestEnd;
    LPTSTR lpExcludeListSrc = NULL;
    LPTSTR lpExcludeListDest = NULL;
    LPFILEINFO lpSrcFiles = NULL, lpDestFiles = NULL;
    LPFILEINFO lpSrcDirs = NULL, lpDestDirs = NULL;
    LPFILEINFO lpTemp;
    THREADINFO ThreadInfo = {0, NULL, NULL, 0, NULL, NULL, NULL, NULL};
    DWORD dwThreadId;
    HANDLE hThreads[NUM_COPY_THREADS];
    HANDLE hStatusThread = 0;
    DWORD dwThreadCount = 0;
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    BOOL bResult = FALSE;
    BOOL bSynchronize = FALSE;
    UINT i;
    DWORD dwTotalSrcFiles = 0;
    DWORD dwTotalDestFiles = 0;
    DWORD dwLargestHiveFile;
    DWORD dwTotalDiskSpaceNeeded;
    ULARGE_INTEGER ulFreeBytesAvailableToCaller, ulTotalNumberOfBytes, ulTotalNumberOfFreeBytes;   
    DWORD dwErr, dwErr1=0;
    TCHAR szErr[MAX_PATH];
    TCHAR szTmpHive[MAX_PATH];
    BOOL bReconcileHiveSucceeded;
    HKEY hkCurrentUser = NULL;
    HANDLE hTokenUser = NULL;

    dwErr = GetLastError();

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Entering, lpSourceDir = <%s>, lpDestinationDir = <%s>, dwFlags = 0x%x"),
             lpSourceDir, lpDestinationDir, dwFlags));

    //
    // Validate parameters
    //

    if (!lpSourceDir || !lpDestinationDir) {
        DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: received NULL pointer")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // Get the caller's token
    //

    if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_DUPLICATE, TRUE, &hTokenUser)) {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_DUPLICATE, &hTokenUser)) {
            DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Fail to get process token with error %d."), GetLastError()));
            return FALSE;
        }
    }

    //
    // If there is an exclusion list, convert it into an array of null
    // terminate strings (double null at the end) based upon the source
    // directory
    //

    if ((dwFlags & CPD_USEEXCLUSIONLIST) && lpExclusionList) {

        DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: lpExclusionList = <%s>"),
                 lpExclusionList));

        lpExcludeListSrc = ConvertExclusionList (lpSourceDir, lpExclusionList);

        if (!lpExcludeListSrc) {
            DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx:  Failed to convert exclusion list for source")));
            goto Exit;
        }

        if (!(dwFlags & CPD_DELDESTEXCLUSIONS)) {
            lpExcludeListDest = ConvertExclusionList (lpDestinationDir, lpExclusionList);

            if (!lpExcludeListDest) {
                DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx:  Failed to convert exclusion list for destination")));
                dwErr = ERROR_INVALID_DATA;
                goto Exit;
            }
        }
    }


    //
    // Get the desktop handle
    //

    ThreadInfo.hDesktop = GetThreadDesktop(GetCurrentThreadId());

    //
    // Is this a full sync copy (delete extra files / directories in dest).
    //

    if (dwFlags & CPD_SYNCHRONIZE) {
        bSynchronize = TRUE;
    }


    //
    // Test / Create the destination directory
    //

    if (!CreateNestedDirectory(lpDestinationDir, NULL)) {

        DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Failed to create the destination directory.  Error = %d"),
                  GetLastError()));
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // Create and set up the directory buffers
    //

    lpSrcDir = LocalAlloc(LPTR, (2 * MAX_PATH) * sizeof(TCHAR));
    lpDestDir = LocalAlloc(LPTR, (2 * MAX_PATH) * sizeof(TCHAR));

    if (!lpSrcDir || !lpDestDir) {
        DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Failed to allocate memory for working directories")));
        dwErr = GetLastError();
        goto Exit;
    }


    lstrcpy (lpSrcDir, lpSourceDir);
    lstrcpy (lpDestDir, lpDestinationDir);


    //
    // Setup ending pointers
    //

    lpSrcEnd = CheckSlash (lpSrcDir);
    lpDestEnd = CheckSlash (lpDestDir);

    //
    // Recurse through the folders gathering info
    //

    if (!(dwFlags & CPD_COPYHIVEONLY)) {


        //
        // Recurse the source directory
        //

        if (!RecurseDirectory(hTokenUser, lpSrcDir, lpDestDir, dwFlags,
                              &lpSrcDirs, &lpSrcFiles, TRUE, lpExcludeListSrc, FALSE)) {
            DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: RecurseDirectory returned FALSE")));
            dwErr = GetLastError();
            goto Exit;
        }


        if (bSynchronize) {

            //
            // Recurse the destination directory
            //

            if (!RecurseDirectory(hTokenUser, lpDestDir, lpSrcDir, dwFlags,
                                  &lpDestDirs, &lpDestFiles, TRUE, lpExcludeListDest, TRUE)) {
                DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: RecurseDirectory returned FALSE")));
                dwErr = GetLastError();
                goto Exit;
            }
        }
    }


    //
    // determine the source and destination sizes
    //

    if(FindDirectorySize(lpSrcDir, lpSrcFiles, dwFlags, &dwLargestHiveFile, &dwTotalSrcFiles) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("FindDirectorySize: Error = %08x"), GetLastError()));
        dwErr = GetLastError();
        goto Exit;
    }
    if(FindDirectorySize(lpDestDir, lpDestFiles, dwFlags, NULL, &dwTotalDestFiles)) {
        DebugMsg((DM_WARNING, TEXT("FindDirectorySize: Error = %08x"), GetLastError()));
        dwErr = GetLastError();
        goto Exit;
    }


    // 
    // determine the disk space needed
    //

    dwTotalDiskSpaceNeeded = FindTotalDiskSpaceNeeded(dwTotalSrcFiles,
                                                      dwTotalDestFiles,
                                                      dwLargestHiveFile,
                                                      lpSrcFiles,
                                                      dwFlags);


    //
    // CopyProfileDirectoryEx is called with impersonation on
    //

    if (!GetDiskFreeSpaceEx(lpDestDir,  &ulFreeBytesAvailableToCaller, &ulTotalNumberOfBytes, &ulTotalNumberOfFreeBytes)) {
        DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Failed to get the Free Disk Space <%s>.  Error = %d"),
                         lpDestDir, GetLastError()));
        dwErr = GetLastError();
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("Available\t\t%d"), ulFreeBytesAvailableToCaller.QuadPart));
    DebugMsg((DM_VERBOSE, TEXT("Needed\t\t%d"), dwTotalDiskSpaceNeeded));
    DebugMsg((DM_VERBOSE, TEXT("Src size\t\t%d"), dwTotalSrcFiles));
    DebugMsg((DM_VERBOSE, TEXT("Dest size\t\t%d"), dwTotalDestFiles));
    DebugMsg((DM_VERBOSE, TEXT("Largest hive file\t\t%d"), dwLargestHiveFile));

    if(dwTotalDiskSpaceNeeded > ulFreeBytesAvailableToCaller.QuadPart) {
        DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Not enough disk space on <%s>"), lpDestDir));

        dwErr = ERROR_DISK_FULL;
        goto Exit;
    }
        
    //
    // Synchronize the directories and files if appropriate
    //

    if (bSynchronize) {

        //
        //  Files first...
        //

        SyncItems (lpSrcFiles, lpDestFiles, TRUE,
                   (dwFlags & CPD_USEDELREFTIME) ? ftDelRefTime : NULL);

        //
        //  Now the directories...
        //

        SyncItems (lpSrcDirs, lpDestDirs, FALSE,
                   (dwFlags & CPD_USEDELREFTIME) ? ftDelRefTime : NULL);
    }


    //
    // Copy the actual hive, log, ini files first
    //

    if (!(dwFlags & CPD_IGNOREHIVE)) {


        //
        // Search for all user hives
        //

        if (dwFlags & CPD_WIN95HIVE) {

            lstrcpy (lpSrcEnd, c_szUserStar);

        } else {

            lstrcpy (lpSrcEnd, c_szNTUserStar);

        }


        //
        // Enumerate
        //

        hFile = FindFirstFile(lpSrcDir, &fd);

        if (hFile != INVALID_HANDLE_VALUE) {

            do  {

                //
                // Setup the filename
                //

                if((dwFlags & CPD_USETMPHIVEFILE) &&
                    (lstrcmpi(fd.cFileName, c_szNTUserMan) == 0 ||
                     lstrcmpi(fd.cFileName, c_szNTUserDat) == 0)) {

                    DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Hive is still loaded, use temporary hive file")));

                    //
                    // Use temporary hive file because unloading hive failed.
                    //

                    lstrcpy(lpSrcEnd, c_szNTUserTmp);
                    
                }
                else {
                    lstrcpy (lpSrcEnd, fd.cFileName);
                }
                lstrcpy (lpDestEnd, fd.cFileName);


                //
                // Do not reconcile the log file if we are using the tmp hive
                // file. Skip it.
                //

                if((dwFlags & CPD_USETMPHIVEFILE) &&
                    lstrcmpi(fd.cFileName + lstrlen(fd.cFileName) - lstrlen(c_szLog), c_szLog) == 0) {
                    DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Log file %s skipped"), lpDestDir));
                    continue;
                }

                //
                // Skip the temporary hive file here. Will deal with it when
                // we find an actual hive file.
                //

                if(lstrcmpi(fd.cFileName, c_szNTUserTmp) == 0) {
                    DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: %s skipped"), fd.cFileName));
                    continue;
                }

                DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Found hive file %s"), fd.cFileName));
                    
                if(!ReconcileFile(lpSrcDir, lpDestDir, dwFlags, NULL,
                                  fd.nFileSizeLow, TRUE)) {
                    dwErr1 = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: ReconcileFile failed with error = %d"), dwErr1));
                    if (!(dwFlags & CPD_IGNORECOPYERRORS)) {
                        dwErr = dwErr1;
                        ReportError(hTokenUser,
                                    PI_NOUI,
                                    3,
                                    EVENT_COPYERROR,
                                    lpSrcDir,
                                    lpDestDir,
                                    GetErrString(dwErr, szErr));
                        FindClose(hFile);
                        goto Exit;
                    }
                    else {
                        ReportError(hTokenUser,
                                    PI_NOUI | EVENT_WARNING_TYPE,
                                    3,
                                    EVENT_COPYERROR,
                                    lpSrcDir,
                                    lpDestDir,
                                    GetErrString(dwErr1, szErr));
                    }
                }

                
            //
            // Find the next entry
            //

            } while (FindNextFile(hFile, &fd));

            FindClose(hFile);

            dwErr = ERROR_SUCCESS;

        } else {
            dwErr = GetLastError();
            DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: FindFirstFile failed to find a hive!.  Error = %d"),
                     dwErr));
        }
    }


    //
    //  Create all the directories
    //

    if (!(dwFlags & CPD_COPYHIVEONLY)) {

        DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Calling ReconcileDirectory for all Directories")));

        lpTemp = lpSrcDirs;

        while (lpTemp) {

            if (!ReconcileDirectory(lpTemp->szSrc, lpTemp->szDest, dwFlags, lpTemp->dwFileAttribs)) {
                dwErr1 = GetLastError();

                DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Failed to create the destination directory <%s>.  Error = %d"),
                         lpTemp->szDest, GetLastError()));

                if (!(dwFlags & CPD_IGNORECOPYERRORS)) {
                    //
                    // Show the error UI and bail out.
                    //

                    ReportError(hTokenUser, ((dwFlags & CPD_NOERRORUI)? PI_NOUI:0), 3, EVENT_COPYERROR, 
                                lpTemp->szSrc, lpTemp->szDest, GetErrString(dwErr1, szErr));

                    dwErr = dwErr1;
                    goto Exit;
                }
                else {
                    ReportError(hTokenUser, PI_NOUI | EVENT_WARNING_TYPE, 3, EVENT_COPYERROR, 
                                lpTemp->szSrc, lpTemp->szDest, GetErrString(dwErr1, szErr));

                }
            }

            lpTemp = lpTemp->pNext;
        }

        DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Reconcile Directory Done for all Directories")));

        //
        // Copy the files
        //

        if (dwFlags & CPD_SLOWCOPY) {

            //
            // Copy the files one at a time...
            //

            lpTemp = lpSrcFiles;

            while (lpTemp) {

                if (lpTemp->bHive) {

                    //
                    // Hive files have already been copied..
                    //

                    lpTemp = lpTemp->pNext;
                    continue;
                }

                if (!ReconcileFile (lpTemp->szSrc, lpTemp->szDest, dwFlags,
                                    &lpTemp->ftLastWrite, 
                                    lpTemp->dwFileSize, FALSE)) {

                    dwErr1 = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Failed to copy the file <%s> to <%s> due to error = %d"),
                             lpTemp->szSrc, lpTemp->szDest, GetLastError()));

                    if (!(dwFlags & CPD_IGNORECOPYERRORS)) {

                        //
                        // Show the error UI and since the user picks to abort
                        // then we leave now.
                        //

                        ReportError(hTokenUser, ((dwFlags & CPD_NOERRORUI)? PI_NOUI:0), 3, EVENT_COPYERROR, 
                                    lpTemp->szSrc, lpTemp->szDest, GetErrString(dwErr1, szErr));

                        dwErr = dwErr1;
                        goto Exit;
                    }
                    else {
                        ReportError(hTokenUser, PI_NOUI | EVENT_WARNING_TYPE, 3, EVENT_COPYERROR, 
                                    lpTemp->szSrc, lpTemp->szDest, GetErrString(dwErr1, szErr));
                    }
                }

                lpTemp = lpTemp->pNext;
            }

        } else {

            if (lpSrcFiles) {

                HANDLE hThreadToken=NULL;


                if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_DUPLICATE,
                                 TRUE, &hThreadToken)) {
                    DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Failed to get token with %d. This is ok if thread is not impersonating"),
                             GetLastError()));
                }


                //
                // Multi-threaded copy
                //

                // Null sd, auto set, initially signalled, unnamed..

                if (!(ThreadInfo.hCopyEvent = CreateEvent(NULL, FALSE, TRUE, NULL))) {
                    DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: CreateEvent for CopyEvent failed with error %d"), GetLastError()));
                    dwErr = GetLastError();
                    goto Exit;
                }

                ThreadInfo.dwFlags = dwFlags;
                ThreadInfo.lpSrcFiles = lpSrcFiles;
                ThreadInfo.hTokenUser = hTokenUser;

                //
                // Required for PrivCopyFileEx to work, threads should be created using the
                // process token
                //
                
                RevertToSelf();

                //
                // Create the file copy threads
                //

                for (i = 0; i < NUM_COPY_THREADS; i++) {

                    if (hThreads[dwThreadCount] = CreateThread (NULL,
                                                    0,
                                                    (LPTHREAD_START_ROUTINE) CopyFileFunc,
                                                    (LPVOID) &ThreadInfo,
                                                    CREATE_SUSPENDED,
                                                    &dwThreadId)) {
                        dwThreadCount++;
                    }
                }


                //
                // Put the token back.
                //

                if (!SetThreadToken(NULL, hThreadToken)) {
                    DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Impersonation failed with error %d"), GetLastError()));
                    dwErr = GetLastError();       

                    // terminate and close handles for all the threads 
                    for (i = 0; i < dwThreadCount; i++) {
                        TerminateThread (hThreads[i], 1);
                        CloseHandle (hThreads[i]);                        
                    }

                    if (hThreadToken)
                        CloseHandle (hThreadToken);

                    goto Exit;
                }


                for (i = 0; i < dwThreadCount; i++) {
                    if (!SetThreadToken(&hThreads[i], hThreadToken) || !ResumeThread (hThreads[i])) {
                        TerminateThread(hThreads[i], 1);
                    }
                }

                //
                // Wait for the threads to finish
                //

                if (WaitForMultipleObjects (dwThreadCount, hThreads, TRUE, INFINITE) == WAIT_FAILED) {
                    ThreadInfo.dwError = GetLastError();
                }

                //
                // Clean up
                //

                if (hThreadToken)
                    CloseHandle (hThreadToken);

                for (i = 0; i < dwThreadCount; i++) {
                    CloseHandle (hThreads[i]);
                }


                if (ThreadInfo.dwError) {
                    dwErr = ThreadInfo.dwError;
                    goto Exit;
                }
            }
        }
    }


    //
    // Restore the time on the directories to be the same as from Src.
    // This is required because the times on directory have been modified by 
    // creation and deletion of files above.
    //

    DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Setting Directory TimeStamps all Directories")));

    lpTemp = lpSrcDirs;

    while (lpTemp) {

        HANDLE hFile;

        SetFileAttributes (lpTemp->szDest, FILE_ATTRIBUTE_NORMAL);

        hFile = CreateFile(lpTemp->szDest, GENERIC_WRITE,
                            FILE_SHARE_DELETE | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);

        if (hFile != INVALID_HANDLE_VALUE) {
            if (!SetFileTime(hFile, NULL, NULL, &(lpTemp->ftLastWrite))) {
                DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Failed to set the write time on the directory <%s>.  Error = %d"),
                             lpTemp->szDest, GetLastError()));
            }

            CloseHandle(hFile);
        }
        else {
            DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: CreateFile failed for directory %s with error %d"), lpTemp->szDest, 
                                      GetLastError()));
        }

        SetFileAttributes (lpTemp->szDest, lpTemp->dwFileAttribs);

        lpTemp = lpTemp->pNext;
    }

    DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Set times on all directories")));

    //
    // Success
    //

    bResult = TRUE;


Exit:

    if (ThreadInfo.hCopyEvent) {
        CloseHandle (ThreadInfo.hCopyEvent);
    }

    if ( ThreadInfo.hDesktop ) {
        CloseDesktop( ThreadInfo.hDesktop );
    }

    //
    // Free the memory allocated above
    //

    if (hTokenUser) {
        CloseHandle(hTokenUser);
    }

    if (lpSrcDir) {
        LocalFree(lpSrcDir);
    }

    if (lpDestDir) {
        LocalFree(lpDestDir);
    }

    if (lpExcludeListSrc) {
        LocalFree (lpExcludeListSrc);
    }

    if (lpExcludeListDest) {
        LocalFree (lpExcludeListDest);
    }

    if (lpSrcFiles) {
        FreeFileInfoList(lpSrcFiles);
    }

    if (lpDestFiles) {
        FreeFileInfoList(lpDestFiles);
    }

    if (lpSrcDirs) {
        FreeFileInfoList(lpSrcDirs);
    }

    if (lpDestDirs) {
        FreeFileInfoList(lpDestDirs);
    }

    SetLastError(dwErr);

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Leaving with a return value of %d"), bResult));

    return bResult;
}

//*************************************************************
//
//  RecurseDirectory()
//
//  Purpose:    Recurses through the subdirectory coping files.
//
//  Parameters: hTokenUser    -   User's token
//              lpSrcDir      -   Source directory working buffer
//              lpDestDir     -   Destination directory working buffer
//              dwFlags       -   dwFlags
//              llSrcDirs     -   Link list of directories
//              llSrcFiles    -   Link list of files
//              bSkipNtUser   -   Skip ntuser.* files
//              lpExcludeList -   List of directories to exclude
//              bRecurseDest  -   The destination Dir is being recursed
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   1)  The source and dest directories will already have
//                  the trailing backslash when entering this function.
//              2)  The current working directory is the source directory.
//
//
// Notes:
//      CPD_SYSTEMDIRSONLY  Do not keep track of anything unless the dir is
//                          marked with system bit.
//      CPD_SYSTEMFILES     Only Systemfiles
//      CPD_NONENCRYPTEDONLY Only Non EncryptedFile/Directory.
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

BOOL RecurseDirectory (HANDLE hTokenUser, LPTSTR lpSrcDir, LPTSTR lpDestDir, DWORD dwFlags,
                       LPFILEINFO *llSrcDirs, LPFILEINFO *llSrcFiles,
                       BOOL bMarkNtUser, LPTSTR lpExcludeList, BOOL bRecurseDest)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fd;
    LPTSTR lpSrcEnd, lpDestEnd, lpTemp;
    BOOL bResult = TRUE;
    BOOL bSkip;
    DWORD dwErr, dwErr1 = 0;
    TCHAR szErr[MAX_PATH];
    BOOL  bHive;

    dwErr = GetLastError();


    //
    // Setup the ending pointers
    //

    lpSrcEnd = CheckSlash (lpSrcDir);
    lpDestEnd = CheckSlash (lpDestDir);


    //
    // Append *.* to the source directory
    //

    lstrcpy(lpSrcEnd, c_szStarDotStar);



    //
    // Search through the source directory
    //

    hFile = FindFirstFile(lpSrcDir, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

        if ( (GetLastError() == ERROR_FILE_NOT_FOUND) ||
             (GetLastError() == ERROR_PATH_NOT_FOUND) ) {

            //
            // bResult is already initialized to TRUE, so
            // just fall through.
            //

        } else {
            dwErr1 = GetLastError();
            DebugMsg((DM_WARNING, TEXT("RecurseDirectory: FindFirstFile failed.  Error = %d"),
                     dwErr1));

            *lpSrcEnd = TEXT('\0');
            *lpDestEnd = TEXT('\0');

            if (!(dwFlags & CPD_IGNORECOPYERRORS)) {

                if (!bRecurseDest) {
                    ReportError(hTokenUser, ((dwFlags & CPD_NOERRORUI)? PI_NOUI:0), 3, EVENT_COPYERROR, 
                                lpSrcDir, lpDestDir, GetErrString(dwErr1, szErr));
                }
                else {
                    ReportError(hTokenUser, ((dwFlags & CPD_NOERRORUI)? PI_NOUI:0), 3, EVENT_COPYERROR, 
                                lpDestDir, lpSrcDir, GetErrString(dwErr1, szErr));
                }
            
                dwErr = dwErr1;
                bResult = FALSE;
            }
        }

        goto RecurseDir_Exit;
    }


    do {

        bHive = FALSE;

        //
        // Check whether we have enough space in our buffers
        //

        *lpSrcEnd = TEXT('\0');
        *lpDestEnd = TEXT('\0');

        if ((lstrlen(lpSrcDir)+lstrlen(fd.cFileName) >= MAX_PATH) ||
            (lstrlen(lpDestDir)+lstrlen(fd.cFileName) >= MAX_PATH)) {

            LPTSTR lpErrSrc=NULL, lpErrDest=NULL;
            BOOL bRet;

            DebugMsg((DM_WARNING, TEXT("RecurseDirectory: %s is too long. src = %s, dest = %s"), fd.cFileName, lpSrcDir, lpDestDir));

            if (dwFlags & CPD_IGNORELONGFILENAMES) 
                continue;

            //
            // Allocate a buffer to show the file names
            //
            
            lpErrSrc = LocalAlloc(LPTR, (lstrlen(lpSrcDir)+lstrlen(fd.cFileName)+1)*sizeof(TCHAR));
            lpErrDest = LocalAlloc(LPTR, (lstrlen(lpDestDir)+lstrlen(fd.cFileName)+1)*sizeof(TCHAR));
            
            //
            // Show the UI
            //
            
            if ((!lpErrSrc) || (!lpErrDest)) {
            
                if (!bRecurseDest) {
                
                    ReportError(hTokenUser, ((dwFlags & CPD_NOERRORUI)? PI_NOUI:0), 3, EVENT_COPYERROR, 
                            lpSrcDir, lpDestDir, GetErrString(ERROR_FILENAME_EXCED_RANGE, szErr));
                } else {
                
                    ReportError(hTokenUser, ((dwFlags & CPD_NOERRORUI)? PI_NOUI:0), 3, EVENT_COPYERROR, 
                            lpDestDir, lpSrcDir, GetErrString(ERROR_FILENAME_EXCED_RANGE, szErr));
                }
            }
            else {
                
                lstrcpy(lpErrSrc, lpSrcDir); 
                lstrcpy(lpErrSrc+lstrlen(lpErrSrc), fd.cFileName);
                
                lstrcpy(lpErrDest, lpDestDir);
                lstrcpy(lpErrDest+lstrlen(lpErrDest), fd.cFileName);
                
                if (!bRecurseDest) {
                
                    ReportError(hTokenUser, ((dwFlags & CPD_NOERRORUI)? PI_NOUI:0), 3, EVENT_COPYERROR, 
                            lpErrSrc, lpErrDest, GetErrString(ERROR_FILENAME_EXCED_RANGE, szErr));
                } else {
                
                    ReportError(hTokenUser, ((dwFlags & CPD_NOERRORUI)? PI_NOUI:0), 3, EVENT_COPYERROR, 
                            lpErrDest, lpErrSrc, GetErrString(ERROR_FILENAME_EXCED_RANGE, szErr));
                }
            }
            
            if (lpErrSrc)
                LocalFree(lpErrSrc);
            if (lpErrDest)
                LocalFree(lpErrDest);
            
               
            //
            // Set the error and quit.
            //
                
            dwErr = ERROR_FILENAME_EXCED_RANGE;
            bResult = FALSE;
            goto RecurseDir_Exit;
            
        }

        //
        // Append the file / directory name to the working buffers
        //

        lstrcpy (lpSrcEnd, fd.cFileName);
        lstrcpy (lpDestEnd, fd.cFileName);


        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Check for "." and ".."
            //

            if (!lstrcmpi(fd.cFileName, c_szDot)) {
                continue;
            }

            if (!lstrcmpi(fd.cFileName, c_szDotDot)) {
                continue;
            }

            //
            // Check for reparse point
            //

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
            {
                DebugMsg((DM_WARNING, TEXT("RecurseDirectory: Found a reparse point <%s>,  skip it!"), lpSrcDir));
                continue;
            }

            //
            // Check if this directory should be excluded
            //

            if (lpExcludeList) {

                bSkip = FALSE;
                lpTemp = lpExcludeList;

                while (*lpTemp) {

                    if (lstrcmpi (lpTemp, lpSrcDir) == 0) {
                        bSkip = TRUE;
                        break;
                    }

                    lpTemp += lstrlen (lpTemp) + 1;
                }

                if (bSkip) {
                    DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Skipping <%s> due to exclusion list."),
                             lpSrcDir));
                    continue;
               }
            }


            //
            // Found a directory.
            //
            // 1)  Change into that subdirectory on the source drive.
            // 2)  Recurse down that tree.
            // 3)  Back up one level.
            //

            //
            // Add to the list of directories
            //

            if (dwFlags & CPD_SYSTEMDIRSONLY) {

                //
                // if it is encrypted, don't recurse into it
                //

                if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {

                    DWORD dwNewFlags = dwFlags;

                    //
                    // Add to the list of directories only if marked as system, o/w just recurse through
                    //

                    if (fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) {
                        if (!AddFileInfoNode (llSrcDirs, lpSrcDir, lpDestDir, &fd.ftLastWriteTime,
                                              &fd.ftCreationTime, 0, fd.dwFileAttributes, bHive)) {
                            DebugMsg((DM_WARNING, TEXT("RecurseDirectory: AddFileInfoNode failed")));
                            dwErr = GetLastError();
                            goto RecurseDir_Exit;
                        }

                        dwNewFlags ^= CPD_SYSTEMDIRSONLY;
                        DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Adding %s to the list of directories because system bit is on"), lpSrcDir));
                    }

                    //
                    // Recurse the subdirectory
                    //

                    if (!RecurseDirectory(hTokenUser, lpSrcDir, lpDestDir, dwNewFlags,
                                          llSrcDirs, llSrcFiles, FALSE, lpExcludeList, bRecurseDest)) {
                        DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: RecurseDirectory returned FALSE")));
                        bResult = FALSE;
                        dwErr = GetLastError();
                        goto RecurseDir_Exit;
                    }

                } else {
                    DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Skipping <%s> since the encrypted attribute is set."),
                             lpSrcDir));
                }

                continue;
            }

            //
            // Popup time
            //

            if (dwFlags & CPD_NONENCRYPTEDONLY) {
                if (fd.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {

                    DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Detected Encrypted file %s, Aborting.."), lpSrcDir));
                    dwErr = ERROR_FILE_ENCRYPTED;
                    bResult = FALSE;
                    goto RecurseDir_Exit;
               }
            }

            //
            // Ignore encrypted file
            //

            if (dwFlags & CPD_IGNOREENCRYPTEDFILES) {
                if (fd.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                    DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Skipping <%s> since the encrypted attribute is set..."),
                             lpSrcDir));
                    continue;
               }
            }

            //
            // Add it to the list
            //

            if (!AddFileInfoNode (llSrcDirs, lpSrcDir, lpDestDir, &fd.ftLastWriteTime,
                &fd.ftCreationTime, 0, fd.dwFileAttributes, bHive)) {
                DebugMsg((DM_WARNING, TEXT("RecurseDirectory: AddFileInfoNode failed")));
                dwErr = GetLastError();
                goto RecurseDir_Exit;
            }
            
            //
            // Recurse the subdirectory
            //
            
            if (!RecurseDirectory(hTokenUser, lpSrcDir, lpDestDir, dwFlags,
                llSrcDirs, llSrcFiles, FALSE, lpExcludeList, bRecurseDest)) {
                DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: RecurseDirectory returned FALSE")));
                bResult = FALSE;
                dwErr = GetLastError();
                goto RecurseDir_Exit;
            }
            
            DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Adding %s to the list of directories"), lpSrcDir));

        } else {

            //
            // if the directories only bit is set, don't copy anything else
            //

            if (dwFlags & CPD_SYSTEMDIRSONLY) {
                DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Skipping <%s> since the system directories only attribute is set."),
                             lpSrcDir));
                continue;
            }

            //
            // If the filename found starts with "ntuser", then ignore
            // it because the hive will be copied below (if appropriate).
            //


            if (bMarkNtUser && lstrlen(fd.cFileName) >= 6) {
                if (CompareString (LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                                   fd.cFileName, 6,
                                   TEXT("ntuser"), 6) == CSTR_EQUAL) {
                    bHive = TRUE;
                }
            }

            //
            // Check if this file should be excluded
            //

            if (dwFlags & CPD_SYSTEMFILES) {
                if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)) {
                    DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Skipping <%s> since the system attribute is not set."),
                             lpSrcDir));
                    continue;
               }
            }

            //
            // if it is systemfile, it can not be encrypted. 
            //

            if (dwFlags & CPD_NONENCRYPTEDONLY) {
                
                if (fd.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {

                    DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Detected Encrypted file %s, Aborting..."), lpSrcDir));
                    dwErr = ERROR_FILE_ENCRYPTED;
                    bResult = FALSE;
                    goto RecurseDir_Exit;
               }
            }


            if (dwFlags & CPD_IGNOREENCRYPTEDFILES) {
                if (fd.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                    DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Skipping <%s> since the encrypted attribute is set."),
                             lpSrcDir));
                    continue;
               }
            }


            //
            // We found a file.  Add it to the list.
            //

            if (!AddFileInfoNode (llSrcFiles, lpSrcDir, lpDestDir,
                                  &fd.ftLastWriteTime, &fd.ftCreationTime,
                                  fd.nFileSizeLow, fd.dwFileAttributes, bHive)) {
                DebugMsg((DM_WARNING, TEXT("RecurseDirectory: AddFileInfoNode failed")));
                dwErr = GetLastError();
                goto RecurseDir_Exit;
            }

        }


        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, &fd));


RecurseDir_Exit:

    //
    // Remove the file / directory name appended above
    //

    *lpSrcEnd = TEXT('\0');
    *lpDestEnd = TEXT('\0');


    //
    // Close the search handle
    //

    if (hFile != INVALID_HANDLE_VALUE) {
        FindClose(hFile);
    }

    SetLastError(dwErr);
    return bResult;
}

//*************************************************************
//
//  CopyProgressRoutine()
//
//  Purpose:    Callback function for CopyFileEx
//
//  Parameters:  See doc's.
//
//  Return:     PROGRESS_CONTINUE
//
//*************************************************************

DWORD WINAPI CopyProgressRoutine(LARGE_INTEGER TotalFileSize,
                                 LARGE_INTEGER TotalBytesTransferred,
                                 LARGE_INTEGER StreamSize,
                                 LARGE_INTEGER StreamBytesTransferred,
                                 DWORD dwStreamNumber,
                                 DWORD dwCallbackReason,
                                 HANDLE hSourceFile,
                                 HANDLE hDestinationFile,
                                 LPVOID lpData)
{
    switch (dwCallbackReason)
    {
    case PRIVCALLBACK_ENCRYPTION_FAILED:
    case PRIVCALLBACK_COMPRESSION_FAILED:
    case PRIVCALLBACK_SPARSE_FAILED:
    case PRIVCALLBACK_OWNER_GROUP_FAILED:
    case PRIVCALLBACK_DACL_ACCESS_DENIED:
    case PRIVCALLBACK_SACL_ACCESS_DENIED:
    case PRIVCALLBACK_OWNER_GROUP_ACCESS_DENIED:
        return PROGRESS_CANCEL;
    default:
        return PROGRESS_CONTINUE;   //all other conditions can be safely ignored
    }
}

//*************************************************************
//
//  ReconcileDirectory()
//
//  Purpose:     Compares the source and destination file.
//               If the source is newer, then it is copied
//               over the destination.
//
//  Parameters:  lpSrcDir   -   source filename
//               lpDestDir  -   destination filename
//               dwFlags    -   flags
//               dwSrcAttribs   Source Attributes for decompression,
//                              decryption later on.
//
//
//  Return:     1 if successful (no file copied)
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/26/99     ushaji     Created
//
//*************************************************************

BOOL ReconcileDirectory(LPTSTR lpSrcDir, LPTSTR lpDestDir, 
                        DWORD dwFlags, DWORD dwSrcAttribs)
{
    
    DWORD  dwCopyFlags=0, dwErr;
    BOOL   bCancel = FALSE;
    
    //
    // Clear any existing attributes
    //

    SetFileAttributes (lpDestDir, FILE_ATTRIBUTE_NORMAL);

    if (!CreateNestedDirectory(lpDestDir, NULL)) {        
        DebugMsg((DM_WARNING, TEXT("ReconcileDirectory: Failed to create the destination directory <%s>.  Error = %d"),
            lpDestDir, GetLastError()));
        return FALSE;
    }

    // 
    // Set up the copy flags to copy the encryption/compression on dirs over.
    //
    
    if (!(dwFlags & CPD_IGNORESECURITY))
        dwCopyFlags = PRIVCOPY_FILE_METADATA | PRIVCOPY_FILE_SKIP_DACL;

     dwCopyFlags |= PRIVCOPY_FILE_DIRECTORY | PRIVCOPY_FILE_SUPERSEDE;


    if (!PrivCopyFileExW(lpSrcDir, lpDestDir,
                         (LPPROGRESS_ROUTINE) CopyProgressRoutine,
                         NULL, &bCancel, dwCopyFlags)) {
        
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ReconcileDirectory: Failed to copy over the attributes src <%s> to destination directory <%s>.  Error = %d"),
            lpSrcDir, lpDestDir, dwErr));
        RemoveDirectory(lpDestDir);
        SetLastError(dwErr);
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  ReconcileFile()
//
//  Purpose:     Compares the source and destination file.
//               If the source is newer, then it is copied
//               over the destination.
//
//  Parameters:  lpSrcFile  -   source filename
//               lpDestFile -   destination filename
//               dwFlags    -   flags
//               ftSrcTime  -   Src file time (can be NULL)
//               dwFileSize -   File size
//               bHiveFile  -   Flag to indicate hive file
//
//
//  Return:     1 if successful (no file copied)
//              2 if successful (and a file was copied)
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//              7/20/00     santanuc   added flag bHiveFile
//
//*************************************************************

INT ReconcileFile (LPCTSTR lpSrcFile, LPCTSTR lpDestFile,
                     DWORD dwFlags, LPFILETIME ftSrcTime,
                     DWORD dwFileSize, BOOL bHiveFile)
{
    WIN32_FILE_ATTRIBUTE_DATA fad;
    FILETIME ftWriteSrc, ftWriteDest;
    INT iCopyFile = 0;
    DWORD dwErr = ERROR_SUCCESS, dwErr1 = 0;

    //
    // If the flags have CPD_FORCECOPY, then skip to the
    // copy file call without checking the timestamps.
    //

    if (!(dwFlags & CPD_FORCECOPY)) {


        //
        // If we were given a source file time, use that
        //

        if (ftSrcTime) {
            ftWriteSrc.dwLowDateTime = ftSrcTime->dwLowDateTime;
            ftWriteSrc.dwHighDateTime = ftSrcTime->dwHighDateTime;

        } else {


            //
            // Query for the source file time
            //

            if (!GetFileAttributesEx (lpSrcFile, GetFileExInfoStandard, &fad)) {
                dwErr = GetLastError();
                DebugMsg((DM_WARNING, TEXT("ReconcileFile: GetFileAttributes on the source failed with error = %d"),
                         dwErr));
                goto Exit;
            }

            ftWriteSrc.dwLowDateTime = fad.ftLastWriteTime.dwLowDateTime;
            ftWriteSrc.dwHighDateTime = fad.ftLastWriteTime.dwHighDateTime;
        }


        //
        // Attempt to open the destination file
        //

        if (!GetFileAttributesEx (lpDestFile, GetFileExInfoStandard, &fad)) {
            DWORD dwError;

            //
            // GetFileAttributesEx failed to query the destination
            // file.  If the last error is file not found
            // then we automaticaly will copy the file.
            //

            dwError = GetLastError();

            if (dwError == ERROR_FILE_NOT_FOUND) {

                iCopyFile = 1;

            } else {

                //
                // GetFileAttributesEx failed with some other error
                //

                DebugMsg((DM_WARNING, TEXT("ReconcileFile: GetFileAttributesEx on the destination failed with error = %d"),
                         dwError));
                dwErr = dwError;
                goto Exit;
            }

        } else {

            ftWriteDest.dwLowDateTime = fad.ftLastWriteTime.dwLowDateTime;
            ftWriteDest.dwHighDateTime = fad.ftLastWriteTime.dwHighDateTime;
        }

    } else {

        //
        // The CPD_FORCECOPY flag is turned on, set iCopyFile to 1.
        //

        iCopyFile = 1;
    }


    //
    // If iCopyFile is still zero, then we need to compare
    // the last write time stamps.
    //

    if (!iCopyFile) {
        LONG lResult;

        //
        // If the source is later than the destination
        // we need to copy the file.
        //

        lResult = CompareFileTime(&ftWriteSrc, &ftWriteDest);

        if (lResult == 1) {
            iCopyFile = 1;
        }

        if ( (dwFlags & CPD_COPYIFDIFFERENT) && (lResult == -1) ) {
            iCopyFile = 1;
        }
    }


    //
    // Copy the file if appropriate
    //

    if (iCopyFile) {
        BOOL bCancel = FALSE;
        TCHAR szTempFile[MAX_PATH + 1];
        TCHAR szTempDir[MAX_PATH + 1];
        LPTSTR lpTemp;
        DWORD  dwCopyFlags;

        //
        // Clear any existing attributes
        //

        SetFileAttributes (lpDestFile, FILE_ATTRIBUTE_NORMAL);
    
        if (!(dwFlags & CPD_IGNORESECURITY))
            dwCopyFlags = PRIVCOPY_FILE_METADATA | PRIVCOPY_FILE_SKIP_DACL;
        else
            dwCopyFlags = 0;

        dwCopyFlags |= PRIVCOPY_FILE_SUPERSEDE;

        //
        // Figure out what the destination directory is
        //

        lstrcpy (szTempDir, lpDestFile);
        lpTemp = szTempDir + lstrlen (szTempDir);

        while ((lpTemp > szTempDir) && (*lpTemp != TEXT('\\'))) {
            lpTemp--;
        }

        if (lpTemp == szTempDir) {
            lstrcpy (szTempDir, TEXT("."));
        } else {
            *lpTemp = TEXT('\0');
        }


        //
        // Generate a temporary file name
        //

        if (GetTempFileName (szTempDir, TEXT("prf"), 0, szTempFile)) {


            //
            // Copy the file to the temp file name
            //

            if (PrivCopyFileExW(lpSrcFile, szTempFile,
                                (LPPROGRESS_ROUTINE) CopyProgressRoutine,
                                NULL, &bCancel, dwCopyFlags)) {

                // If it is hive file then open the temporary file, flush and close it to make it more transacted

                if (bHiveFile) {
                    HANDLE hTempFile;

                    hTempFile = CreateFile(szTempFile, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                    if ( hTempFile != INVALID_HANDLE_VALUE ) {
                        if ( !FlushFileBuffers(hTempFile) ) 
                            DebugMsg((DM_WARNING, TEXT("ReconcileFile: Unable to flush temporary file")));

                        if ( !CloseHandle(hTempFile) ) 
                            DebugMsg((DM_WARNING, TEXT("ReconcileFile: Unable to close temporary file handle")));
                    }
                    else
                        DebugMsg((DM_WARNING, TEXT("ReconcileFile: Unable to open temporary file")));
                }
                        

                //
                // Delete the original file
                //

                if (!DeleteFile (lpDestFile)) {
                    if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                        dwErr1 = GetLastError();
                        DebugMsg((DM_WARNING, TEXT("ReconcileFile: Failed to delete file <%s> with error = %d"),
                                 lpDestFile, dwErr1));

                        DeleteFile(szTempFile);
                        goto CopyError;
                    }
                }


                //
                // Rename the temp file to the original file name
                //

                if (!MoveFile (szTempFile, lpDestFile)) {
                    DWORD dwError = ERROR_SUCCESS;   //isolate MoveFile error from other below
                    dwErr1 = GetLastError();

                    //
                    // If we get access denied, let's try to remove the READ ONLY attribute (can't rename files
                    // with +r attribute on a Netware Server) from the temp file, do the rename and restore the
                    // attributes
                    //
                    if ( dwErr1 == ERROR_ACCESS_DENIED ) {
                        if (!GetFileAttributesEx (szTempFile, GetFileExInfoStandard, &fad)) {
                            dwError = GetLastError();
                            DebugMsg((DM_WARNING, TEXT("ReconcileFile: GetFileAttributes on file <%s> failed with error = %d\n"),
                                     szTempFile,dwError));
                        } else {
                            if ( fad.dwFileAttributes & FILE_ATTRIBUTE_READONLY ) {
                                dwErr1 = ERROR_SUCCESS ;
                                if (!SetFileAttributes (szTempFile, fad.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY)) {
                                    dwError = GetLastError();
                                    DebugMsg((DM_WARNING, TEXT("ReconcileFile: SetFileAttributes on file <%s> failed with error = %d\n"),
                                             szTempFile,dwError));
                                } else {
                                    if (!MoveFile (szTempFile,lpDestFile)) {
                                        // Debug message displayed below
                                        dwErr1 = GetLastError();
                                    } else {
                                        if ( !SetFileAttributes (lpDestFile,fad.dwFileAttributes) ) {
                                            dwError = GetLastError();
                                            DebugMsg((DM_WARNING, TEXT("ReconcileFile: SetFileAttributes on file <%s> failed with error = %d\n"),
                                                     szTempFile,dwError));
                                        }
                                    }
                                }
                            }
                        }
                    }   // End of ERROR_ACCESS_DENIED test

                    if (dwErr1 != ERROR_SUCCESS || dwError != ERROR_SUCCESS) {
                        DebugMsg((DM_WARNING, TEXT("ReconcileFile: Failed to rename file <%s> to <%s> with error = %d"),
                                 szTempFile, lpDestFile, dwErr1));

                        // do not remove it in this case.
                        goto CopyError;
                    }
                }

                DebugMsg((DM_VERBOSE, TEXT("ReconcileFile: %s ==> %s  [OK]"),
                         lpSrcFile, lpDestFile));
                iCopyFile = 2;

            } else {
                dwErr1 = GetLastError();
                DeleteFile(szTempFile);

                DebugMsg((DM_WARNING, TEXT("ReconcileFile: %s ==> %s  [FAILED!!!]"),
                         lpSrcFile, szTempFile));

                DebugMsg((DM_WARNING, TEXT("ReconcileFile: CopyFile failed with error = %d"),
                         dwErr1));

                goto CopyError;
            }

        } else {
            dwErr1 = GetLastError();

            DebugMsg((DM_WARNING, TEXT("ReconcileFile: GetTempFileName failed with %d"),
                     dwErr1));

            goto CopyError;
        }

    } else {

        //
        // No need to copy the file since the time stamps are the same
        // Set iCopyFile to 1 so the return value is success without
        // copying a file.
        //

        iCopyFile = 1;
    }
    goto Exit;

CopyError:
    iCopyFile = 0;
    dwErr = dwErr1;

Exit:

    SetLastError(dwErr);
    return iCopyFile;
}


//*************************************************************
//
//  AddFileInfoNode()
//
//  Purpose:    Adds a node to the linklist of files
//
//  Parameters: lpFileInfo     -   Link list to add to
//              lpSrcFile      -   Source filename
//              lpDestFile     -   Destination filename
//              ftLastWrite    -   Last write time stamp
//              ftCreationTime -   File creation time
//              dwFileSize     -   Size of the file
//              dwFileAttribs  - File attributes
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/28/95     ericflo    Created
//
//*************************************************************

BOOL AddFileInfoNode (LPFILEINFO *lpFileInfo, LPTSTR lpSrcFile,
                      LPTSTR lpDestFile, LPFILETIME ftLastWrite,
                      LPFILETIME ftCreationTime, DWORD dwFileSize,
                      DWORD dwFileAttribs, BOOL bHive)
{
    LPFILEINFO lpNode;


    lpNode = (LPFILEINFO) LocalAlloc(LPTR, sizeof(FILEINFO));

    if (!lpNode) {
        return FALSE;
    }


    lstrcpy (lpNode->szSrc, lpSrcFile);
    lstrcpy (lpNode->szDest, lpDestFile);

    lpNode->ftLastWrite.dwLowDateTime = ftLastWrite->dwLowDateTime;
    lpNode->ftLastWrite.dwHighDateTime = ftLastWrite->dwHighDateTime;

    lpNode->ftCreationTime.dwLowDateTime = ftCreationTime->dwLowDateTime;
    lpNode->ftCreationTime.dwHighDateTime = ftCreationTime->dwHighDateTime;

    lpNode->dwFileSize = dwFileSize;
    lpNode->bHive = bHive;
    lpNode->dwFileAttribs = (dwFileAttribs & ~FILE_ATTRIBUTE_DIRECTORY);

    lpNode->pNext = *lpFileInfo;

    *lpFileInfo = lpNode;

    return TRUE;

}

//*************************************************************
//
//  FreeFileInfoList()
//
//  Purpose:    Free's a file info link list
//
//  Parameters: lpFileInfo  -   List to be freed
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/28/95     ericflo    Created
//
//*************************************************************

BOOL FreeFileInfoList (LPFILEINFO lpFileInfo)
{
    LPFILEINFO lpNext;


    if (!lpFileInfo) {
        return TRUE;
    }


    lpNext = lpFileInfo->pNext;

    while (lpFileInfo) {
        LocalFree (lpFileInfo);
        lpFileInfo = lpNext;

        if (lpFileInfo) {
            lpNext = lpFileInfo->pNext;
        }
    }

    return TRUE;
}

//*************************************************************
//
//  SyncItems()
//
//  Purpose:    Removes unnecessary items from the destination
//              directory tree
//
//  Parameters: lpSrcItems  -   Link list of source items
//              lpDestItems -   Link list of dest items
//              bFile       -   File or directory list
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//  Comments:
//
//  History:    Date        Author     Comment
//              9/28/95     ericflo    Created
//
//*************************************************************

BOOL SyncItems (LPFILEINFO lpSrcItems, LPFILEINFO lpDestItems,
                BOOL bFile, LPFILETIME ftDelRefTime)
{
    LPFILEINFO lpTempSrc, lpTempDest;


    //
    // Check for NULL pointers
    //

#ifdef DBG
    if (ftDelRefTime)
    {
        SYSTEMTIME SystemTime;
        FileTimeToSystemTime(ftDelRefTime, &SystemTime); 
        DebugMsg((DM_VERBOSE, TEXT("SyncItems: DelRefTime. Year: %d, Month %d, Day %d, Hour %d, Minute %d"), SystemTime.wYear, 
                                SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute));                
    }
#endif                 

    if (!lpSrcItems || !lpDestItems) {
        return TRUE;
    }


    //
    // Loop through everyitem in lpDestItems to see if it
    // is in lpSrcItems.  If not, delete it.
    //

    lpTempDest = lpDestItems;

    while (lpTempDest) {

        lpTempSrc = lpSrcItems;

        while (lpTempSrc) {

            if (lstrcmpi(lpTempDest->szSrc, lpTempSrc->szDest) == 0) {
                break;
            }

            lpTempSrc = lpTempSrc->pNext;
        }

        //
        // If lpTempSrc is NULL, then this file / directory is a candidate
        // for being deleted
        //

        if (!lpTempSrc) {
            BOOL bDelete = TRUE;


            //
            // If a delete reference time was offered, compare the
            // source time with the ref time and only delete files
            // which have a source time older than the ref time
            //

            if (ftDelRefTime) {

                if (CompareFileTime (&lpTempDest->ftLastWrite, ftDelRefTime) == 1) {                    
                    bDelete = FALSE;
                }
                else if (CompareFileTime (&lpTempDest->ftCreationTime, ftDelRefTime) == 1) {
                    bDelete = FALSE;
                }
            }


            if (bDelete) {

                //
                // Delete the file / directory
                //

                DebugMsg((DM_VERBOSE, TEXT("SyncItems: removing <%s>"),
                         lpTempDest->szSrc));


                if (bFile) {
                   SetFileAttributes(lpTempDest->szSrc, FILE_ATTRIBUTE_NORMAL);
                   if (!DeleteFile (lpTempDest->szSrc)) {
                       DebugMsg((DM_WARNING, TEXT("SyncItems: Failed to delete <%s>.  Error = %d."),
                                lpTempDest->szSrc, GetLastError()));
                   }

                } else {
                   SetFileAttributes(lpTempDest->szSrc, FILE_ATTRIBUTE_NORMAL);
                   if (!RemoveDirectory (lpTempDest->szSrc)) {
                       DebugMsg((DM_WARNING, TEXT("SyncItems: Failed to remove <%s>.  Error = %d"),
                                lpTempDest->szSrc, GetLastError()));
                   }

                }
            }
            else
            {
                    DebugMsg((DM_VERBOSE, TEXT("SyncItems: New file or directory <%s> in destination since this profile was loaded.  This will NOT be deleted."),
                              lpTempDest->szSrc));
#ifdef DBG
                    {
                        SYSTEMTIME SystemTime;
                        FileTimeToSystemTime(&lpTempDest->ftLastWrite, &SystemTime); 
                        DebugMsg((DM_VERBOSE, TEXT("SyncItems: File WriteTime. Year: %d, Month %d, Day %d, Hour %d, Minute %d"), SystemTime.wYear, 
                                                                     SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute));                
                        FileTimeToSystemTime(&lpTempDest->ftCreationTime, &SystemTime); 
                        DebugMsg((DM_VERBOSE, TEXT("SyncItems: File CreationTime. Year: %d, Month %d, Day %d, Hour %d, Minute %d"), SystemTime.wYear, 
                                                                     SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute));                
                    }
#endif                 
            }
        }

        lpTempDest = lpTempDest->pNext;
    }

    return TRUE;
}

//*************************************************************
//
//  CopyFileFunc()
//
//  Purpose:    Copies files
//
//  Parameters: lpThreadInfo    -   Thread information
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/23/96     ericflo    Created
//
//*************************************************************

void CopyFileFunc (LPTHREADINFO lpThreadInfo)
{
    HANDLE      hInstDll;
    LPFILEINFO  lpSrcFile;
    BOOL        bRetVal = TRUE;
    DWORD       dwError;
    TCHAR       szErr[MAX_PATH];

    hInstDll = LoadLibrary (TEXT("userenv.dll"));

    SetThreadDesktop (lpThreadInfo->hDesktop);

    while (TRUE) {

        if (lpThreadInfo->dwError) {
            break;
        }

        //
        // Query for the next file to copy..
        // ignore the hive file since it is already copied..
        //

        WaitForSingleObject(lpThreadInfo->hCopyEvent, INFINITE);

        do {
            lpSrcFile = lpThreadInfo->lpSrcFiles;
            if (lpSrcFile)
                lpThreadInfo->lpSrcFiles = lpThreadInfo->lpSrcFiles->pNext;

        } while (lpSrcFile && (lpSrcFile->bHive));


        SetEvent(lpThreadInfo->hCopyEvent);


        //
        // If NULL, then we're finished.
        //

        if (!lpSrcFile || lpThreadInfo->dwError) {
            break;
        }


        //
        // Copy the file
        //

        if (!ReconcileFile (lpSrcFile->szSrc, lpSrcFile->szDest,
                            lpThreadInfo->dwFlags, &lpSrcFile->ftLastWrite,
                            lpSrcFile->dwFileSize, FALSE)) {

            if (!(lpThreadInfo->dwFlags & CPD_IGNORECOPYERRORS)) {

                WaitForSingleObject(lpThreadInfo->hCopyEvent, INFINITE);
                
                if (!(lpThreadInfo->dwError)) {
                    dwError = GetLastError();

                    ReportError(lpThreadInfo->hTokenUser, ((lpThreadInfo->dwFlags & CPD_NOERRORUI) ? PI_NOUI:0), 3, EVENT_COPYERROR, 
                            lpSrcFile->szSrc, lpSrcFile->szDest, GetErrString(dwError, szErr));

                    lpThreadInfo->dwError = dwError;
                    bRetVal = FALSE;
                }

                SetEvent(lpThreadInfo->hCopyEvent);
                break;
            }
            else {
                dwError = GetLastError();
                ReportError(lpThreadInfo->hTokenUser, PI_NOUI | EVENT_WARNING_TYPE, 3, EVENT_COPYERROR, 
                            lpSrcFile->szSrc, lpSrcFile->szDest, GetErrString(dwError, szErr));
            }
        }
    }
    
    //
    // Clean up
    //

    if (hInstDll) {
        FreeLibraryAndExitThread(hInstDll, bRetVal);
    } else {
        ExitThread (bRetVal);
    }
}


//*************************************************************
//
//  ConvertExclusionList()
//
//  Purpose:    Converts the semi-colon profile relative exclusion
//              list to fully qualified null terminated exclusion
//              list
//
//  Parameters: lpSourceDir     -  Profile root directory
//              lpExclusionList -  List of directories to exclude
//
//  Return:     List if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR ConvertExclusionList (LPCTSTR lpSourceDir, LPCTSTR lpExclusionList)
{
    LPTSTR lpExcludeList = NULL, lpInsert, lpEnd, lpTempList;
    LPCTSTR lpTemp, lpDir;
    TCHAR szTemp[MAX_PATH];
    DWORD dwSize = 2;  // double null terminator
    DWORD dwStrLen;


    //
    // Setup a temp buffer to work with
    //

    lstrcpy (szTemp, lpSourceDir);
    lpEnd = CheckSlash (szTemp);


    //
    // Loop through the list
    //

    lpTemp = lpDir = lpExclusionList;

    while (*lpTemp) {

        //
        // Look for the semicolon separator
        //

        while (*lpTemp && ((*lpTemp) != TEXT(';'))) {
            lpTemp++;
        }


        //
        // Remove any leading spaces
        //

        while (*lpDir == TEXT(' ')) {
            lpDir++;
        }

        //
        // Note: 
        // Empty Spaces will not make the whole profile dir excluded
        // in RecurseDirectory.
        //

        //
        // Put the directory name on the temp buffer
        //

        lstrcpyn (lpEnd, lpDir, (int)(lpTemp - lpDir + 1));
        DebugMsg((DM_VERBOSE, TEXT("ConvertExclusionList: Adding %s to ExclusionList"), szTemp));

        //
        // Add the string to the exclusion list
        //

        if (lpExcludeList) {

            dwStrLen = lstrlen (szTemp) + 1;
            dwSize += dwStrLen;

            lpTempList = LocalReAlloc (lpExcludeList, dwSize * sizeof(TCHAR),
                                       LMEM_MOVEABLE | LMEM_ZEROINIT);

            if (!lpTempList) {
                DebugMsg((DM_WARNING, TEXT("ConvertExclusionList: Failed to realloc memory with %d"), GetLastError()));
                LocalFree (lpExcludeList);
                lpExcludeList = NULL;
                goto Exit;
            }

            lpExcludeList = lpTempList;

            lpInsert = lpExcludeList + dwSize - dwStrLen - 1;
            lstrcpy (lpInsert, szTemp);

        } else {

            dwSize += lstrlen (szTemp);
            lpExcludeList = LocalAlloc (LPTR, dwSize * sizeof(TCHAR));

            if (!lpExcludeList) {
                DebugMsg((DM_WARNING, TEXT("ConvertExclusionList: Failed to alloc memory with %d"), GetLastError()));
                goto Exit;
            }

            lstrcpy (lpExcludeList, szTemp);
        }


        //
        // If we are at the end of the exclusion list, we're done
        //

        if (!(*lpTemp)) {
            goto Exit;
        }


        //
        // Prep for the next entry
        //

        lpTemp++;
        lpDir = lpTemp;
    }

Exit:

    return lpExcludeList;
}

//*************************************************************
//
//  FindDirectorySize()
//
//  Purpose:    Takes the Directory Name and the list of files
//              returned by RecurseDir and gets the total size.
//
//  Parameters: lpDir          -  '\' terminated Source Directory 
//              lpFiles        -  List of files to be copied
//              dwFlags        -  Flags
//              pdwLargestHiveFile  - optional parameter that
//                                    returns the largest hive
//                                    file size.
//              pdwTotalFiles  - the size of the directory
//
//  Return:     Win32 error code.
//
//*************************************************************

DWORD FindDirectorySize(LPTSTR lpDir, LPFILEINFO lpFiles, DWORD dwFlags, DWORD* pdwLargestHiveFile, DWORD* pdwTotalFiles)
{
    LPFILEINFO      lpTemp = NULL;

    if(pdwLargestHiveFile) {
        *pdwLargestHiveFile = 0;
    }
    if(!pdwTotalFiles) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }
    else {
        *pdwTotalFiles = 0;
    }

    lpTemp = lpFiles;

    while (lpTemp) {
        if (lpTemp->bHive) {
            if (!(dwFlags & CPD_IGNOREHIVE)) {
                if(pdwLargestHiveFile && (*pdwLargestHiveFile < lpTemp->dwFileSize)) {
                    *pdwLargestHiveFile = lpTemp->dwFileSize;
                }
                
                *pdwTotalFiles += lpTemp->dwFileSize;
            }
        }
        else {
            *pdwTotalFiles += lpTemp->dwFileSize;
        }

        lpTemp = lpTemp->pNext;
    }
    
    return ERROR_SUCCESS;
}


//*************************************************************
//
//  FindTotalDiskSpaceNeeded()
//
//  Purpose:    Calculate the maximum amount of disk space on the
//              destination drive that is needed to reconcile the
//              source and the destination directories. The
//              algorithm is as follows:
//                  max(source size, destination size) +
//                  NUM_COPY_THREADS * size of the largest file in source dir -
//                  destination size
//              The reason for this algorithm is that the copy
//              operation is done by NUM_COPY_THREADS threads.
//              They copy the files to a temp file and then delete
//              the destination file and rename the temp file.
//
//  Parameters: dwTotalSrcFiles   total size of the source files 
//              dwTotalDestFiles  total size of the destination files
//              dwLargestHiveFile largest hive file                   
//              lpSrcFiles        List of source files
//              dwFlags        -  Flags
//
//  Return:     Disk space needed.
//
//  History:    Created     WeiruC      2/10/2000
//
//*************************************************************

DWORD FindTotalDiskSpaceNeeded(DWORD        dwTotalSrcFiles,
                               DWORD        dwTotalDestFiles,
                               DWORD        dwLargestHiveFile,
                               LPFILEINFO   lpSrcFiles,
                               DWORD        dwFlags)
{
    DWORD       dwNumOfCopyThreads = NUM_COPY_THREADS;
    DWORD       dwDiskSpaceNeeded = 0;
    LPFILEINFO  lpCur = lpSrcFiles;
    DWORD       i, j;          // loop counters


    //
    // Check for empty file list.
    //

    if(!lpSrcFiles) {
        return dwLargestHiveFile;
    }


    //
    // How many copy threads are there actually?
    //

    if(dwFlags & CPD_SLOWCOPY) {
        dwNumOfCopyThreads = 1;
    }


    //
    // Find the size of the largest file in the source file list. The hive
    // files are not in this file list, be careful not to forget them. Hive
    // files have to be treated very carefully because they are always copied
    // over before we create those copy threads.
    //

    dwDiskSpaceNeeded = FindTotalNMaxFileSize(lpSrcFiles, dwNumOfCopyThreads);

    DebugMsg((DM_VERBOSE, TEXT("FindTotalDiskSpaceNeeded: Largest %d file size is %d"), dwNumOfCopyThreads, dwDiskSpaceNeeded)); 


    //
    // The actual disk space needed.
    //

    if(dwDiskSpaceNeeded < dwLargestHiveFile) {
        dwDiskSpaceNeeded = dwLargestHiveFile;
    }

    if(dwTotalSrcFiles > dwTotalDestFiles) {
        dwDiskSpaceNeeded += dwTotalSrcFiles - dwTotalDestFiles;
    }

    //
    // It is too much of a pain to actually figure out cluster size impact.
    // We'll just add an extra 10% of the disk space needed.
    //

    dwDiskSpaceNeeded += dwDiskSpaceNeeded / 10;

    return dwDiskSpaceNeeded;
}

//*************************************************************
//
//  FindTotalNMaxFileSize()
//
//  Purpose:    Calculates the total size for dwNumOfFiles
//              number of largest files. 
//
//  Parameters: lpSrcFiles     -  List of source files
//              dwNumOfFiles   -  Number of files. 
//                                dwNumOfFiles <= NUM_COPY_THREADS
//
//  Return:     Disk space needed for n largest files.
//
//  History:    Created     santanuc      10/03/2000
//
//*************************************************************
DWORD FindTotalNMaxFileSize(LPFILEINFO lpSrcFiles, DWORD dwNumOfFiles) 
{
    DWORD      pdwNMaxVal[NUM_COPY_THREADS], dwIndex;
    LPFILEINFO lpCur;
    DWORD      dwTotalSize = 0, dwTmp;

    if (!lpSrcFiles)
        return 0;

    for(dwIndex = 0; dwIndex < dwNumOfFiles; dwIndex++) {
        pdwNMaxVal[dwIndex] = 0;
    }

    for(lpCur = lpSrcFiles; lpCur; lpCur = lpCur->pNext) {
        if (!lpCur->bHive) {
            dwIndex = dwNumOfFiles-1;
            if (lpCur->dwFileSize > pdwNMaxVal[dwIndex]) {
                pdwNMaxVal[dwIndex] = lpCur->dwFileSize;

                while (dwIndex > 0 && pdwNMaxVal[dwIndex] > pdwNMaxVal[dwIndex-1]) {
                    dwTmp = pdwNMaxVal[dwIndex-1];
                    pdwNMaxVal[dwIndex-1] = pdwNMaxVal[dwIndex];
                    pdwNMaxVal[dwIndex] = dwTmp;
                    dwIndex--;
                }
            }
        }
    }

    for(dwIndex = 0; dwIndex < dwNumOfFiles; dwIndex++) {
        dwTotalSize += pdwNMaxVal[dwIndex];
    }

    return dwTotalSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\profile\copydir.h ===
//*************************************************************
//
//  Header file for copydir.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************


//
// File copy structure
//

typedef struct _FILEINFO {
    TCHAR            szSrc[MAX_PATH];
    TCHAR            szDest[MAX_PATH];
    FILETIME         ftLastWrite;
    FILETIME         ftCreationTime;
    DWORD            dwFileSize;
    DWORD            dwFileAttribs;
    BOOL             bHive;
    struct _FILEINFO *pNext;
} FILEINFO, * LPFILEINFO;


#define NUM_COPY_THREADS        7

//
// ThreadInfo structure
//

typedef struct _THREADINFO {
    DWORD              dwFlags;
    HANDLE             hCopyEvent;
    LPFILEINFO         lpSrcFiles;
    DWORD              dwError;
    HWND               hStatusDlg;
    HANDLE             hStatusInitEvent;
    HANDLE             hStatusTermEvent;
    HDESK              hDesktop;
    HANDLE             hTokenUser;
} THREADINFO, * LPTHREADINFO;


//
// Error dialog structure
//

typedef struct _COPYERRORINFO {
    LPTSTR     lpSrc;
    LPTSTR     lpDest;
    DWORD      dwError;
    DWORD      dwTimeout;
} COPYERRORINFO, * LPCOPYERRORINFO;



INT ReconcileFile (LPCTSTR lpSrcFile, LPCTSTR lpDestFile,
                   DWORD dwFlags, LPFILETIME ftSrcTime,
                   DWORD dwFileSize, BOOL bHiveFile);

INT_PTR APIENTRY CopyStatusDlgProc (HWND hDlg, UINT uMsg,
                                 WPARAM wParam, LPARAM lParam);

INT_PTR APIENTRY CopyErrorDlgProc (HWND hDlg, UINT uMsg,
                                WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\profile\envvar.c ===
//*************************************************************
//  File name: envvar.c
//
//  Description:  Contains the environment variable functions
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1996
//  All rights reserved
//
//*************************************************************

#include "uenv.h"

//
// Max environment variable length
//

#define MAX_VALUE_LEN              1024

//
// Environment variables
//

#define COMPUTERNAME_VARIABLE      TEXT("COMPUTERNAME")
#define HOMEDRIVE_VARIABLE         TEXT("HOMEDRIVE")
#define HOMESHARE_VARIABLE         TEXT("HOMESHARE")
#define HOMEPATH_VARIABLE          TEXT("HOMEPATH")
#define SYSTEMDRIVE_VARIABLE       TEXT("SystemDrive")
#define SYSTEMROOT_VARIABLE        TEXT("SystemRoot")
#define USERNAME_VARIABLE          TEXT("USERNAME")
#define USERDOMAIN_VARIABLE        TEXT("USERDOMAIN")
#define USERDNSDOMAIN_VARIABLE     TEXT("USERDNSDOMAIN")
#define USERPROFILE_VARIABLE       TEXT("USERPROFILE")
#define ALLUSERSPROFILE_VARIABLE   TEXT("ALLUSERSPROFILE")
#define PATH_VARIABLE              TEXT("Path")
#define LIBPATH_VARIABLE           TEXT("LibPath")
#define OS2LIBPATH_VARIABLE        TEXT("Os2LibPath")
#define PROGRAMFILES_VARIABLE      TEXT("ProgramFiles")
#define COMMONPROGRAMFILES_VARIABLE TEXT("CommonProgramFiles")
#if defined(WX86) || defined(_WIN64)
#define PROGRAMFILESX86_VARIABLE   TEXT("ProgramFiles(x86)")
#define COMMONPROGRAMFILESX86_VARIABLE TEXT("CommonProgramFiles(x86)")
#endif
#define USER_ENV_SUBKEY            TEXT("Environment")
#define USER_VOLATILE_ENV_SUBKEY   TEXT("Volatile Environment")

//
// Parsing information for autoexec.bat
//
#define AUTOEXECPATH_VARIABLE      TEXT("AutoexecPath")
#define PARSE_AUTOEXEC_KEY         TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define PARSE_AUTOEXEC_ENTRY       TEXT("ParseAutoexec")
#define PARSE_AUTOEXEC_DEFAULT     TEXT("1")
#define MAX_PARSE_AUTOEXEC_BUFFER  2


#define SYS_ENVVARS                TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Environment")

BOOL UpdateSystemEnvironment(PVOID *pEnv);
BOOL GetUserNameAndDomain(HANDLE hToken, LPTSTR *UserName, LPTSTR *UserDomain);
BOOL GetUserNameAndDomainSlowly(HANDLE hToken, LPTSTR *UserName, LPTSTR *UserDomain);
LPTSTR GetUserDNSDomainName(LPTSTR lpDomain, HANDLE hUserToken);
LONG GetHKeyCU(HANDLE hToken, HKEY *hKeyCU);
BOOL ProcessAutoexec(PVOID *pEnv);
BOOL AppendNTPathWithAutoexecPath(PVOID *pEnv, LPTSTR lpPathVariable, LPTSTR lpAutoexecPath);
BOOL SetEnvironmentVariables(PVOID *pEnv, LPTSTR lpRegSubKey, HKEY hKeyCU);
#ifdef _X86_
BOOL IsPathIncludeRemovable(LPTSTR lpValue);
#endif


//*************************************************************
//
//  CreateEnvironmentBlock()
//
//  Purpose:    Creates the environment variables for the
//              specificed hToken.  If hToken is NULL, the
//              environment block will only contain system
//              variables.
//
//  Parameters: pEnv            -   Receives the environment block
//              hToken          -   User's token or NULL
//              bInherit        -   Inherit the current process environment
//
//  Return:     TRUE if successful
//              FALSE if not
//
//  Comments:   The pEnv value must be destroyed by
//              calling DestroyEnvironmentBlock
//
//  History:    Date        Author     Comment
//              6/19/96     ericflo    Created
//
//*************************************************************

BOOL WINAPI CreateEnvironmentBlock (LPVOID *pEnv, HANDLE  hToken, BOOL bInherit)
{
    LPTSTR szBuffer = NULL;
    LPTSTR szValue = NULL;
    LPTSTR szExpValue = NULL;
    DWORD dwBufferSize = MAX_PATH+1;
    NTSTATUS Status;
    LPTSTR UserName = NULL;
    LPTSTR UserDomain = NULL;
    LPTSTR UserDNSDomain = NULL;
    HKEY  hKey, hKeyCU;
    DWORD dwDisp, dwType, dwSize;
    TCHAR szParseAutoexec[MAX_PARSE_AUTOEXEC_BUFFER];
    LONG  dwError;
    BOOL  bRetVal = FALSE;


    //
    // Arg check
    //

    if (!pEnv) {
        SetLastError (ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    Status = RtlCreateEnvironment((BOOLEAN)bInherit, pEnv);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    // 
    // Allocate memory for Local variables to avoid stack overflow
    //

    szBuffer = (LPTSTR)LocalAlloc(LPTR, (MAX_PATH+1)*sizeof(TCHAR));
    if (!szBuffer) {
        DebugMsg((DM_WARNING, TEXT("CreateEnvironmentBlock: Out of memory")));
        goto Exit;
    }

    szValue = (LPTSTR)LocalAlloc(LPTR, (MAX_VALUE_LEN+1)*sizeof(TCHAR));
    if (!szValue) {
        DebugMsg((DM_WARNING, TEXT("CreateEnvironmentBlock: Out of memory")));
        goto Exit;
    }

    szExpValue = (LPTSTR)LocalAlloc(LPTR, (MAX_VALUE_LEN+1)*sizeof(TCHAR));
    if (!szExpValue) {
        DebugMsg((DM_WARNING, TEXT("CreateEnvironmentBlock: Out of memory")));
        goto Exit;
    }


    //
    // First start by getting the systemroot and systemdrive values and
    // setting it in the new environment.
    //

    if ( GetEnvironmentVariable(SYSTEMROOT_VARIABLE, szBuffer, dwBufferSize) )
    {
        SetEnvironmentVariableInBlock(pEnv, SYSTEMROOT_VARIABLE, szBuffer, TRUE);
    }

    if ( GetEnvironmentVariable(SYSTEMDRIVE_VARIABLE, szBuffer, dwBufferSize) )
    {
        SetEnvironmentVariableInBlock(pEnv, SYSTEMDRIVE_VARIABLE, szBuffer, TRUE);
    }


    //
    // Set the all users profile location.
    //

    dwBufferSize = MAX_PATH+1;
    if (GetAllUsersProfileDirectory(szBuffer, &dwBufferSize)) {
        SetEnvironmentVariableInBlock(pEnv, ALLUSERSPROFILE_VARIABLE, szBuffer, TRUE);
    }


    //
    // We must examine the registry directly to pull out
    // the system environment variables, because they
    // may have changed since the system was booted.
    //

    if (!UpdateSystemEnvironment(pEnv)) {
        RtlDestroyEnvironment(*pEnv);
        goto Exit;
    }


    //
    // Set the computername
    //

    dwBufferSize = MAX_PATH+1;
    if (GetComputerName (szBuffer, &dwBufferSize)) {
        SetEnvironmentVariableInBlock(pEnv, COMPUTERNAME_VARIABLE, szBuffer, TRUE);
    }


    //
    // Set the default user profile location
    //

    dwBufferSize = MAX_PATH+1;
    if (GetDefaultUserProfileDirectory(szBuffer, &dwBufferSize)) {
        SetEnvironmentVariableInBlock(pEnv, USERPROFILE_VARIABLE, szBuffer, TRUE);
    }


    //
    // Set the Program Files environment variable
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = (MAX_VALUE_LEN+1)*sizeof(TCHAR);
        if (RegQueryValueEx (hKey, TEXT("ProgramFilesDir"), NULL, &dwType,
                             (LPBYTE) szValue, &dwSize) == ERROR_SUCCESS) {

            ExpandEnvironmentStrings (szValue, szExpValue, (MAX_VALUE_LEN+1));
            SetEnvironmentVariableInBlock(pEnv, PROGRAMFILES_VARIABLE, szExpValue, TRUE);
        }

        dwSize = (MAX_VALUE_LEN+1)*sizeof(TCHAR);
        if (RegQueryValueEx (hKey, TEXT("CommonFilesDir"), NULL, &dwType,
                             (LPBYTE) szValue, &dwSize) == ERROR_SUCCESS) {

            ExpandEnvironmentStrings (szValue, szExpValue, (MAX_VALUE_LEN+1));
            SetEnvironmentVariableInBlock(pEnv, COMMONPROGRAMFILES_VARIABLE, szExpValue, TRUE);
        }

#if defined(WX86) || defined(_WIN64)
        dwSize = (MAX_VALUE_LEN+1)*sizeof(TCHAR);
        if (RegQueryValueEx (hKey, TEXT("ProgramFilesDir (x86)"), NULL, &dwType,
                             (LPBYTE) szValue, &dwSize) == ERROR_SUCCESS) {

            ExpandEnvironmentStrings (szValue, szExpValue, (MAX_VALUE_LEN+1));
            SetEnvironmentVariableInBlock(pEnv, PROGRAMFILESX86_VARIABLE, szExpValue, TRUE);
        }

        dwSize = (MAX_VALUE_LEN+1)*sizeof(TCHAR);
        if (RegQueryValueEx (hKey, TEXT("CommonFilesDir (x86)"), NULL, &dwType,
                             (LPBYTE) szValue, &dwSize) == ERROR_SUCCESS) {

            ExpandEnvironmentStrings (szValue, szExpValue, (MAX_VALUE_LEN+1));
            SetEnvironmentVariableInBlock(pEnv, COMMONPROGRAMFILESX86_VARIABLE, szExpValue, TRUE);
        }
#endif

        RegCloseKey (hKey);
    }


    //
    // If hToken is NULL, we can exit now since the caller only wants
    // system environment variables.
    //

    if (!hToken) {
        bRetVal = TRUE;
        goto Exit;
    }


    //
    // Open the HKEY_CURRENT_USER for this token.
    //

    dwError = GetHKeyCU(hToken, &hKeyCU);

    //
    // if the hive is not found assume that the caller just needs the system attribute.
    //

    if ((!hKeyCU) && (dwError == ERROR_FILE_NOT_FOUND)) {
        bRetVal = TRUE;
        goto Exit;
    }

    if (!hKeyCU) {
        RtlDestroyEnvironment(*pEnv);
        DebugMsg((DM_WARNING, TEXT("CreateEnvironmentBlock:  Failed to open HKEY_CURRENT_USER, error = %d"), dwError));
        goto Exit;
    }


    //
    // Set the user's name and domain.
    //

    if (!GetUserNameAndDomain(hToken, &UserName, &UserDomain)) {
        GetUserNameAndDomainSlowly(hToken, &UserName, &UserDomain);
    }
    UserDNSDomain = GetUserDNSDomainName(UserDomain, hToken);
    SetEnvironmentVariableInBlock( pEnv, USERNAME_VARIABLE, UserName, TRUE);
    SetEnvironmentVariableInBlock( pEnv, USERDOMAIN_VARIABLE, UserDomain, TRUE);
    SetEnvironmentVariableInBlock( pEnv, USERDNSDOMAIN_VARIABLE, UserDNSDomain, TRUE);
    LocalFree(UserName);
    LocalFree(UserDomain);
    LocalFree(UserDNSDomain);


    //
    // Set the user's profile location.
    //

    dwBufferSize = MAX_PATH+1;
    if (GetUserProfileDirectory(hToken, szBuffer, &dwBufferSize)) {
        SetEnvironmentVariableInBlock(pEnv, USERPROFILE_VARIABLE, szBuffer, TRUE);
    }


    //
    // Process autoexec.bat
    //

    lstrcpy (szParseAutoexec, PARSE_AUTOEXEC_DEFAULT);

    if (RegCreateKeyEx (hKeyCU, PARSE_AUTOEXEC_KEY, 0, 0,
                    REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                    NULL, &hKey, &dwDisp) == ERROR_SUCCESS) {


        //
        // Query the current value.  If it doesn't exist, then add
        // the entry for next time.
        //

        dwBufferSize = sizeof (TCHAR) * MAX_PARSE_AUTOEXEC_BUFFER;
        if (RegQueryValueEx (hKey, PARSE_AUTOEXEC_ENTRY, NULL, &dwType,
                        (LPBYTE) szParseAutoexec, &dwBufferSize)
                         != ERROR_SUCCESS) {

            //
            // Set the default value
            //

            RegSetValueEx (hKey, PARSE_AUTOEXEC_ENTRY, 0, REG_SZ,
                           (LPBYTE) szParseAutoexec,
                           sizeof (TCHAR) * lstrlen (szParseAutoexec) + 1);
        }

        //
        // Close key
        //

        RegCloseKey (hKey);
     }


    //
    // Process autoexec if appropriate
    //

    if (szParseAutoexec[0] == TEXT('1')) {
        ProcessAutoexec(pEnv);
    }


    //
    // Set User environment variables.
    //
    SetEnvironmentVariables(pEnv, USER_ENV_SUBKEY, hKeyCU);


    //
    // Set User volatile environment variables.
    //
    SetEnvironmentVariables(pEnv, USER_VOLATILE_ENV_SUBKEY, hKeyCU);


    //
    // Merge the paths
    //

    AppendNTPathWithAutoexecPath(pEnv, PATH_VARIABLE, AUTOEXECPATH_VARIABLE);


    RegCloseKey (hKeyCU);

    bRetVal = TRUE;

Exit:

    if (szBuffer) {
        LocalFree(szBuffer);
    }

    if (szValue) {
        LocalFree(szValue);
    }

    if (szExpValue) {
        LocalFree(szExpValue);
    }
 
    return bRetVal;
}


//*************************************************************
//
//  DestroyEnvironmentBlock()
//
//  Purpose:    Frees the environment block created by
//              CreateEnvironmentBlock
//
//  Parameters: lpEnvironment   -   Pointer to variables
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/96     ericflo    Created
//
//*************************************************************

BOOL WINAPI DestroyEnvironmentBlock (LPVOID lpEnvironment)
{

    if (!lpEnvironment) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RtlDestroyEnvironment(lpEnvironment);

    return TRUE;
}


//*************************************************************
//
//  UpdateSystemEnvironment()
//
//  Purpose:    Reads the system environment variables from the
//              registry.
//
//  Parameters: pEnv    -   Environment block pointer
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Ported
//
//*************************************************************

BOOL UpdateSystemEnvironment(PVOID *pEnv)
{

    HKEY KeyHandle;
    DWORD Result;
    DWORD ValueNameLength;
    DWORD Type;
    DWORD DataLength;
    DWORD cValues;          /* address of buffer for number of value identifiers    */
    DWORD chMaxValueName;   /* address of buffer for longest value name length      */
    DWORD cbMaxValueData;   /* address of buffer for longest value data length      */
    DWORD junk;
    FILETIME FileTime;
    PTCHAR ValueName;
    PTCHAR  ValueData;
    DWORD i;
    BOOL Bool;
    PTCHAR ExpandedValue;
    BOOL rc = TRUE;

    DWORD ClassStringSize = MAX_PATH + 1;
    TCHAR Class[MAX_PATH + 1];

    Result = RegOpenKeyEx (
                 HKEY_LOCAL_MACHINE,
                 SYS_ENVVARS,
                 0,
                 KEY_QUERY_VALUE,
                 &KeyHandle
                 );

    if ( Result != ERROR_SUCCESS ) {

        DebugMsg((DM_WARNING, TEXT("UpdateSystemEnvironment:  RegOpenKeyEx failed, error = %d"),Result));
        return( TRUE );
    }

    Result = RegQueryInfoKey(
                 KeyHandle,
                 Class,              /* address of buffer for class string */
                 &ClassStringSize,   /* address of size of class string buffer */
                 NULL,               /* reserved */
                 &junk,              /* address of buffer for number of subkeys */
                 &junk,              /* address of buffer for longest subkey */
                 &junk,              /* address of buffer for longest class string length */
                 &cValues,           /* address of buffer for number of value identifiers */
                 &chMaxValueName,    /* address of buffer for longest value name length */
                 &cbMaxValueData,    /* address of buffer for longest value data length */
                 &junk,              /* address of buffer for descriptor length */
                 &FileTime           /* address of buffer for last write time */
                 );

    if ( Result != NO_ERROR && Result != ERROR_MORE_DATA ) {
        DebugMsg((DM_WARNING, TEXT("UpdateSystemEnvironment:  RegQueryInfoKey failed, error = %d"),Result));
        RegCloseKey(KeyHandle);
        return( TRUE );
    }

    //
    // No need to adjust the datalength for TCHAR issues
    //

    ValueData = LocalAlloc(LPTR, cbMaxValueData);

    if ( ValueData == NULL ) {
        RegCloseKey(KeyHandle);
        return( FALSE );
    }

    //
    // The maximum value name length comes back in characters, convert to bytes
    // before allocating storage.  Allow for trailing NULL also.
    //

    ValueName = LocalAlloc(LPTR, (++chMaxValueName) * sizeof( TCHAR ) );

    if ( ValueName == NULL ) {

        RegCloseKey(KeyHandle);
        LocalFree( ValueData );
        return( FALSE );
    }

    //
    // To exit from here on, set rc and jump to Cleanup
    //

    for (i=0; i<cValues ; i++) {

        ValueNameLength = chMaxValueName;
        DataLength      = cbMaxValueData;

        Result = RegEnumValue (
                     KeyHandle,
                     i,
                     ValueName,
                     &ValueNameLength,    // Size in TCHARs
                     NULL,
                     &Type,
                     (LPBYTE)ValueData,
                     &DataLength          // Size in bytes
                     );

        if ( Result != ERROR_SUCCESS ) {

            //
            // Problem getting the value.  We can either try
            // the rest or punt completely.
            //

            goto Cleanup;
        }

        //
        // If the buffer size is greater than the max allowed,
        // terminate the string at MAX_VALUE_LEN - 1.
        //

        if (DataLength >= (MAX_VALUE_LEN * sizeof(TCHAR))) {
            ValueData[MAX_VALUE_LEN-1] = TEXT('\0');
        }

        switch ( Type ) {
            case REG_SZ:
                {

                    Bool = SetEnvironmentVariableInBlock(
                               pEnv,
                               ValueName,
                               ValueData,
                               TRUE
                               );

                    if ( !Bool ) {
                        DebugMsg((DM_WARNING, TEXT("UpdateSystemEnvironment: Failed to set environment variable <%s> to <%s> with %d."),
                                 ValueName, ValueData, GetLastError()));
                    }

                    break;
                }
            default:
                {
                    continue;
                }
        }
    }

    //
    // To exit from here on, set rc and jump to Cleanup
    //

    for (i=0; i<cValues ; i++) {

        ValueNameLength = chMaxValueName;
        DataLength      = cbMaxValueData;

        Result = RegEnumValue (
                     KeyHandle,
                     i,
                     ValueName,
                     &ValueNameLength,    // Size in TCHARs
                     NULL,
                     &Type,
                     (LPBYTE)ValueData,
                     &DataLength          // Size in bytes
                     );

        if ( Result != ERROR_SUCCESS ) {

            //
            // Problem getting the value.  We can either try
            // the rest or punt completely.
            //

            goto Cleanup;
        }

        //
        // If the buffer size is greater than the max allowed,
        // terminate the string at MAX_VALUE_LEN - 1.
        //

        if (DataLength >= (MAX_VALUE_LEN * sizeof(TCHAR))) {
            ValueData[MAX_VALUE_LEN-1] = TEXT('\0');
        }

        switch ( Type ) {
            case REG_EXPAND_SZ:
                {

                    ExpandedValue =  AllocAndExpandEnvironmentStrings( ValueData );

                    Bool = SetEnvironmentVariableInBlock(
                               pEnv,
                               ValueName,
                               ExpandedValue,
                               TRUE
                               );

                    LocalFree( ExpandedValue );

                    if ( !Bool ) {
                        DebugMsg((DM_WARNING, TEXT("UpdateSystemEnvironment: Failed to set environment variable <%s> to <%s> with %d."),
                                 ValueName, ValueData, GetLastError()));
                    }

                    break;
                }
            default:
                {
                    continue;
                }
        }
    }


Cleanup:

    RegCloseKey(KeyHandle);

    LocalFree( ValueName );
    LocalFree( ValueData );

    return( rc );
}

//*************************************************************
//
//  GetUserNameAndDomain()
//
//  Purpose:    Gets the user's name and domain
//
//  Parameters: hToken      -   User's token
//              UserName    -   Receives pointer to user's name
//              UserDomain  -   Receives pointer to user's domain
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Ported
//
//*************************************************************

BOOL GetUserNameAndDomain(HANDLE hToken, LPTSTR *UserName, LPTSTR *UserDomain)
{
    BOOL bResult = FALSE;
    LPTSTR lpTemp, lpDomain = NULL;
    LPTSTR lpUserName, lpUserDomain;
    HANDLE hOldToken;


    //
    // Impersonate the user
    //

    if (!ImpersonateUser(hToken, &hOldToken)) {
        DebugMsg((DM_VERBOSE, TEXT("GetUserNameAndDomain Failed to impersonate user")));
        goto Exit;
    }


    //
    // Get the username in NT4 format
    //

    lpDomain = MyGetUserNameEx (NameSamCompatible);

    RevertToUser(&hOldToken);

    if (!lpDomain) {
        DebugMsg((DM_WARNING, TEXT("GetUserNameAndDomain:  MyGetUserNameEx failed for NT4 style name with %d"),
                 GetLastError()));
        goto Exit;
    }


    //
    // Look for the \ between the domain and username and replace
    // it with a NULL
    //

    lpTemp = lpDomain;

    while (*lpTemp && ((*lpTemp) != TEXT('\\')))
        lpTemp++;


    if (*lpTemp != TEXT('\\')) {
        DebugMsg((DM_WARNING, TEXT("GetUserNameAndDomain  Failed to find slash in NT4 style name:  <%s>"),
                 lpDomain));
        goto Exit;
    }

    *lpTemp = TEXT('\0');
    lpTemp++;


    //
    // Allocate space for the results
    //

    lpUserName = LocalAlloc (LPTR, (lstrlen(lpTemp) + 1) * sizeof(TCHAR));

    if (!lpUserName) {
        DebugMsg((DM_WARNING, TEXT("GetUserNameAndDomain  Failed to allocate memory with %d"),
                 GetLastError()));
        goto Exit;
    }

    lstrcpy (lpUserName, lpTemp);


    lpUserDomain = LocalAlloc (LPTR, (lstrlen(lpDomain) + 1) * sizeof(TCHAR));

    if (!lpUserDomain) {
        DebugMsg((DM_WARNING, TEXT("GetUserNameAndDomain  Failed to allocate memory with %d"),
                 GetLastError()));
        LocalFree (lpUserName);
        goto Exit;
    }

    lstrcpy (lpUserDomain, lpDomain);


    //
    // Save the results in the outbound arguments
    //

    *UserName = lpUserName;
    *UserDomain = lpUserDomain;


    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (lpDomain) {
        LocalFree (lpDomain);
    }

    return(bResult);
}

//*************************************************************
//
//  GetUserNameAndDomainSlowly()
//
//  Purpose:    Gets the user's name and domain from a DC
//
//  Parameters: hToken      -   User's token
//              UserName    -   Receives pointer to user's name
//              UserDomain  -   Receives pointer to user's domain
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Ported
//
//*************************************************************

BOOL GetUserNameAndDomainSlowly(HANDLE hToken, LPTSTR *UserName, LPTSTR *UserDomain)
{
    LPTSTR lpUserName = NULL;
    LPTSTR lpUserDomain = NULL;
    DWORD cbAccountName = 0;
    DWORD cbUserDomain = 0;
    SID_NAME_USE SidNameUse;
    BOOL bRet = FALSE;
    PSID pSid;


    //
    // Get the user's sid
    //

    pSid = GetUserSid (hToken);

    if (!pSid) {
        return FALSE;
    }


    //
    // Get the space needed for the User name and the Domain name
    //
    if (!LookupAccountSid(NULL,
                         pSid,
                         NULL, &cbAccountName,
                         NULL, &cbUserDomain,
                         &SidNameUse
                         ) ) {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto Error;
        }
    }

    lpUserName = (LPTSTR)LocalAlloc(LPTR, cbAccountName*sizeof(TCHAR));
    if (!lpUserName) {
        goto Error;
    }

    lpUserDomain = (LPTSTR)LocalAlloc(LPTR, cbUserDomain*sizeof(WCHAR));
    if (!lpUserDomain) {
        LocalFree(lpUserName);
        goto Error;
    }

    //
    // Now get the user name and domain name
    //
    if (!LookupAccountSid(NULL,
                         pSid,
                         lpUserName, &cbAccountName,
                         lpUserDomain, &cbUserDomain,
                         &SidNameUse
                         ) ) {

        LocalFree(lpUserName);
        LocalFree(lpUserDomain);
        goto Error;
    }

    *UserName = lpUserName;
    *UserDomain = lpUserDomain;
    bRet = TRUE;

Error:
    DeleteUserSid (pSid);

    return(bRet);
}

//*************************************************************
//
//  GetUserDNSDomainName()
//
//  Purpose:    Gets the DNS domain name for the user
//
//  Parameters: lpDomain   - User's flat domain name
//              hUserToken - User's token
//
//
//  Return:     DNS domain name if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR GetUserDNSDomainName(LPTSTR lpDomain, HANDLE hUserToken)
{
    LPTSTR  lpDnsDomain = NULL, lpTemp = NULL;
    DWORD   dwBufferSize;
    TCHAR   szBuffer[MAX_PATH];
    INT     iRole;
    HANDLE  hOldToken;
    BOOL    bResult = FALSE;


    //
    // Check if this machine is running standalone, if so, there won't be
    // a DNS domain name
    //

    if (!GetMachineRole (&iRole)) {
        DebugMsg((DM_WARNING, TEXT("GetUserDNSDomainName:  Failed to get the role of the computer.")));
        return NULL;
    }

    if (iRole == 0) {
        DebugMsg((DM_VERBOSE, TEXT("GetUserDNSDomainName:  Computer is running standalone.  No DNS domain name available.")));
        return NULL;
    }


    //
    // Get the computer name to see if the user logged on locally
    //

    dwBufferSize = ARRAYSIZE(szBuffer);

    if (GetComputerName (szBuffer, &dwBufferSize)) {
        if (!lstrcmpi(lpDomain, szBuffer)) {
            DebugMsg((DM_VERBOSE, TEXT("GetUserDNSDomainName:  Local user account.  No DNS domain name available.")));
            return NULL;
        }
    }

    if (LoadString (g_hDllInstance, IDS_NT_AUTHORITY, szBuffer, ARRAYSIZE(szBuffer))) {
        if (!lstrcmpi(lpDomain, szBuffer)) {
            DebugMsg((DM_VERBOSE, TEXT("GetUserDNSDomainName:  Domain name is NT Authority.  No DNS domain name available.")));
            return NULL;
        }
    }

    if (LoadString (g_hDllInstance, IDS_BUILTIN, szBuffer, ARRAYSIZE(szBuffer))) {
        if (!lstrcmpi(lpDomain, szBuffer)) {
            DebugMsg((DM_VERBOSE, TEXT("GetUserDNSDomainName:  Domain name is BuiltIn.  No DNS domain name available.")));
            return NULL;
        }
    }

    //
    // Impersonate the user
    //

    if (!ImpersonateUser(hUserToken, &hOldToken)) {
        DebugMsg((DM_VERBOSE, TEXT("GetUserDNSDomainName: Failed to impersonate user")));
        goto Exit;
    }


    //
    // Get the username in DnsDomainName format
    //

    lpDnsDomain = MyGetUserNameEx (NameDnsDomain);

    RevertToUser(&hOldToken);

    if (!lpDnsDomain) {
        DebugMsg((DM_WARNING, TEXT("GetUserDNSDomainName:  MyGetUserNameEx failed for NameDnsDomain style name with %d"),
                 GetLastError()));
        goto Exit;
    }


    //
    // Look for the \ between the domain and username and replace
    // it with a NULL
    //

    lpTemp = lpDnsDomain;

    while (*lpTemp && (*lpTemp != TEXT('\\')))
        lpTemp++;


    if (*lpTemp != TEXT('\\')) {
        DebugMsg((DM_WARNING, TEXT("GetUserDNSDomainName:  Failed to find slash in NameDnsDomain style name: <%s>"),
                 lpDnsDomain));
        goto Exit;
    }

    *lpTemp = TEXT('\0');
    bResult = TRUE;

Exit:

    if (!bResult && lpDnsDomain) {
        LocalFree(lpDnsDomain);
        lpDnsDomain = NULL;
    }

    return lpDnsDomain;
}

//*************************************************************
//
//  GetHKeyCU()
//
//  Purpose:    Get HKEY_CURRENT_USER for the given hToken
//
//  Parameters: hToken  -   token handle
//
//  Return:     hKey if successful
//              NULL if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Created
//
//*************************************************************

LONG GetHKeyCU(HANDLE hToken, HKEY *hKeyCU)
{
    LPTSTR lpSidString;
    LONG    dwError;


    *hKeyCU = NULL;

    lpSidString = GetSidString (hToken);

    if (!lpSidString) {
        return GetLastError();
    }

    dwError = RegOpenKeyEx (HKEY_USERS, lpSidString, 0, KEY_READ, hKeyCU);

    if (!(*hKeyCU))
        DebugMsg((DM_VERBOSE, TEXT("GetHkeyCU: RegOpenKey failed with error %d"), dwError));

    DeleteSidString(lpSidString);

    return dwError;
}

/***************************************************************************\
* ProcessAutoexecPath
*
* Creates AutoexecPath environment variable using autoexec.bat
* LpValue may be freed by this routine.
*
* History:
* 06-02-92  Johannec     Created.
*
\***************************************************************************/
LPTSTR ProcessAutoexecPath(PVOID pEnv, LPTSTR lpValue, DWORD cb)
{
    LPTSTR lpt;
    LPTSTR lpStart;
    LPTSTR lpPath;
    DWORD cbt;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    BOOL bPrevAutoexecPath;
    WCHAR ch;
    DWORD dwTemp, dwCount = 0;

    cbt = 1024;
    lpt = (LPTSTR)LocalAlloc(LPTR, cbt*sizeof(WCHAR));
    if (!lpt) {
        return(lpValue);
    }
    *lpt = 0;
    lpStart = lpValue;

    RtlInitUnicodeString(&Name, AUTOEXECPATH_VARIABLE);
    Value.Buffer = (PWCHAR)LocalAlloc(LPTR, cbt*sizeof(WCHAR));
    if (!Value.Buffer) {
        goto Fail;
    }

    while (NULL != (lpPath = wcsstr (lpValue, TEXT("%")))) {
        if (!_wcsnicmp(lpPath+1, TEXT("PATH%"), 5)) {
            //
            // check if we have an autoexecpath already set, if not just remove
            // the %path%
            //
            Value.Length = (USHORT)cbt;
            Value.MaximumLength = (USHORT)cbt;
            bPrevAutoexecPath = (BOOL)!RtlQueryEnvironmentVariable_U(pEnv, &Name, &Value);

            *lpPath = 0;
            dwTemp = dwCount + lstrlen (lpValue);
            if (dwTemp < cbt) {
               lstrcat(lpt, lpValue);
               dwCount = dwTemp;
            }
            if (bPrevAutoexecPath) {
                dwTemp = dwCount + lstrlen (Value.Buffer);
                if (dwTemp < cbt) {
                    lstrcat(lpt, Value.Buffer);
                    dwCount = dwTemp;
                }
            }

            *lpPath++ = TEXT('%');
            lpPath += 5;  // go passed %path%
            lpValue = lpPath;
        }
        else {
            lpPath = wcsstr(lpPath+1, TEXT("%"));
            if (!lpPath) {
                lpStart = NULL;
                goto Fail;
            }
            lpPath++;
            ch = *lpPath;
            *lpPath = 0;
            dwTemp = dwCount + lstrlen (lpValue);
            if (dwTemp < cbt) {
                lstrcat(lpt, lpValue);
                dwCount = dwTemp;
            }
            *lpPath = ch;
            lpValue = lpPath;
        }
    }

    if (*lpValue) {
       dwTemp = dwCount + lstrlen (lpValue);
       if (dwTemp < cbt) {
           lstrcat(lpt, lpValue);
           dwCount = dwTemp;
       }
    }

    LocalFree(Value.Buffer);
    LocalFree(lpStart);

    return(lpt);
Fail:
    LocalFree(lpt);
    return(lpStart);
}

/***************************************************************************\
* ProcessCommand
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL ProcessCommand(LPSTR lpStart, PVOID *pEnv)
{
    LPTSTR lpt, lptt;
    LPTSTR lpVariable;
    LPTSTR lpValue;
    LPTSTR lpExpandedValue = NULL;
    WCHAR c;
    DWORD cb, cbNeeded;
    LPTSTR lpu;

    //
    // convert to Unicode
    //
    lpu = (LPTSTR)LocalAlloc(LPTR, (cb=lstrlenA(lpStart)+1)*sizeof(WCHAR));

    if (!lpu) {
        return FALSE;
    }

    MultiByteToWideChar(CP_OEMCP, 0, lpStart, -1, lpu, cb);

    //
    // Find environment variable.
    //
    for (lpt = lpu; *lpt && *lpt == TEXT(' '); lpt++) //skip spaces
        ;

    if (!*lpt) {
        LocalFree (lpu);
        return(FALSE);
    }


    lptt = lpt;
    for (; *lpt && *lpt != TEXT(' ') && *lpt != TEXT('='); lpt++) //find end of variable name
        ;

    c = *lpt;
    *lpt = 0;
    lpVariable = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lptt) + 1)*sizeof(WCHAR));
    if (!lpVariable) {
        LocalFree (lpu);
        return(FALSE);
    }

    lstrcpy(lpVariable, lptt);
    *lpt = c;

    //
    // Find environment variable value.
    //
    for (; *lpt && (*lpt == TEXT(' ') || *lpt == TEXT('=')); lpt++)
        ;

    if (!*lpt) {
       // if we have a blank path statement in the autoexec file,
       // then we don't want to pass "PATH" as the environment
       // variable because it trashes the system's PATH.  Instead
       // we want to change the variable AutoexecPath.  This would have
       // be handled below if a value had been assigned to the
       // environment variable.
       if (lstrcmpi(lpVariable, PATH_VARIABLE) == 0)
          {
          SetEnvironmentVariableInBlock(pEnv, AUTOEXECPATH_VARIABLE, TEXT(""), TRUE);
          }
       else
          {
          SetEnvironmentVariableInBlock(pEnv, lpVariable, TEXT(""), TRUE);
          }
        LocalFree (lpVariable);
        LocalFree (lpu);
        return(FALSE);
    }

    lptt = lpt;
    for (; *lpt; lpt++)  //find end of varaible value
        ;

    c = *lpt;
    *lpt = 0;
    lpValue = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lptt) + 1)*sizeof(WCHAR));
    if (!lpValue) {
        LocalFree (lpu);
        LocalFree(lpVariable);
        return(FALSE);
    }

    lstrcpy(lpValue, lptt);
    *lpt = c;

#ifdef _X86_
    // NEC98
    //
    // If the path includes removable drive,
    //  it is assumed that the drive assignment has changed from DOS.
    //
    if (IsNEC_98 && (lstrcmpi(lpVariable, PATH_VARIABLE) == 0) && IsPathIncludeRemovable(lpValue)) {
        LocalFree (lpu);
        LocalFree(lpVariable);
        LocalFree(lpValue);
        return(FALSE);
    }
#endif

    cb = 1024;
    lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
    if (lpExpandedValue) {
        if (!lstrcmpi(lpVariable, PATH_VARIABLE)) {
            lpValue = ProcessAutoexecPath(*pEnv, lpValue, (lstrlen(lpValue)+1)*sizeof(WCHAR));
        }
        cbNeeded = ExpandUserEnvironmentStrings(*pEnv, lpValue, lpExpandedValue, cb);
        if (cbNeeded > cb) {
            LocalFree(lpExpandedValue);
            cb = cbNeeded;
            lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
            if (lpExpandedValue) {
                ExpandUserEnvironmentStrings(*pEnv, lpValue, lpExpandedValue, cb);
            }
        }
    }

    if (!lpExpandedValue) {
        lpExpandedValue = lpValue;
    }
    if (lstrcmpi(lpVariable, PATH_VARIABLE)) {
        SetEnvironmentVariableInBlock(pEnv, lpVariable, lpExpandedValue, FALSE);
    }
    else {
        SetEnvironmentVariableInBlock(pEnv, AUTOEXECPATH_VARIABLE, lpExpandedValue, TRUE);

    }

    if (lpExpandedValue != lpValue) {
        LocalFree(lpExpandedValue);
    }
    LocalFree(lpVariable);
    LocalFree(lpValue);
    LocalFree (lpu);

    return(TRUE);
}

/***************************************************************************\
* ProcessSetCommand
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL ProcessSetCommand(LPSTR lpStart, PVOID *pEnv)
{
    LPSTR lpt;

    //
    // Find environment variable.
    //
    for (lpt = lpStart; *lpt && *lpt != TEXT(' '); lpt++)
        ;

    if (!*lpt)
       return(FALSE);

    return (ProcessCommand(lpt, pEnv));

}

/***************************************************************************\
* ProcessAutoexec
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL
ProcessAutoexec(
    PVOID *pEnv
    )
{
    HANDLE fh = NULL;
    DWORD dwFileSize;
    DWORD dwBytesRead;
    CHAR *lpBuffer = NULL;
    CHAR *token;
    CHAR Seps[] = "&\n\r";   // Seperators for tokenizing autoexec.bat
    BOOL Status = FALSE;
    TCHAR szAutoExecBat [] = TEXT("c:\\autoexec.bat");
#ifdef _X86_
    TCHAR szTemp[3];
#endif
    UINT uiErrMode;


    // There is a case where the OS might not be booting from drive
    // C, so we can not assume that the autoexec.bat file is on c:\.
    // Set the error mode so the user doesn't see the critical error
    // popup and attempt to open the file on c:\.

    uiErrMode = SetErrorMode (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

#ifdef _X86_
    if (IsNEC_98) {
        if (GetEnvironmentVariable (TEXT("SystemDrive"), szTemp, 3)) {
	    szAutoExecBat[0] = szTemp[0];
	}
    }
#endif

    // if autoexec.bat is encrypted then ignore it as it creates cyclic-dependency 
    // and don't allow any user to logon

    if (GetFileAttributes(szAutoExecBat) & FILE_ATTRIBUTE_ENCRYPTED) {
        goto Exit;
    }

    fh = CreateFile (szAutoExecBat, GENERIC_READ, FILE_SHARE_READ,
                     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    SetErrorMode (uiErrMode);

    if (fh ==  INVALID_HANDLE_VALUE) {
        return(FALSE);  //could not open autoexec.bat file, we're done.
    }
    dwFileSize = GetFileSize(fh, NULL);
    if (dwFileSize == -1) {
        goto Exit;      // can't read the file size
    }

    lpBuffer = (PCHAR)LocalAlloc(LPTR, dwFileSize+1);
    if (!lpBuffer) {
        goto Exit;
    }

    Status = ReadFile(fh, lpBuffer, dwFileSize, &dwBytesRead, NULL);
    if (!Status) {
        goto Exit;      // error reading file
    }

    //
    // Zero terminate the buffer so we don't walk off the end
    //

    ASSERT(dwBytesRead <= dwFileSize);
    lpBuffer[dwBytesRead] = 0;

    //
    // Search for SET and PATH commands
    //

    token = strtok(lpBuffer, Seps);
    while (token != NULL) {
        for (;*token && *token == ' ';token++) //skip spaces
            ;
        if (*token == TEXT('@'))
            token++;
        for (;*token && *token == ' ';token++) //skip spaces
            ;
        if (!_strnicmp(token, "Path", 4)) {
            ProcessCommand(token, pEnv);
        }
        if (!_strnicmp(token, "SET", 3)) {
            ProcessSetCommand(token, pEnv);
        }
        token = strtok(NULL, Seps);
    }
Exit:
    if (fh) {
        CloseHandle(fh);
    }
    if (lpBuffer) {
        LocalFree(lpBuffer);
    }
    if (!Status) {
        DebugMsg((DM_WARNING, TEXT("ProcessAutoexec: Cannot process autoexec.bat.")));
    }
    return(Status);
}

/***************************************************************************\
* BuildEnvironmentPath
*
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL BuildEnvironmentPath(PVOID *pEnv,
                          LPTSTR lpPathVariable,
                          LPTSTR lpPathValue)
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    WCHAR lpTemp[1025];
    DWORD cb;


    if (!*pEnv) {
        return(FALSE);
    }
    RtlInitUnicodeString(&Name, lpPathVariable);
    cb = 1024;
    Value.Buffer = (PWCHAR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
    if (!Value.Buffer) {
        return(FALSE);
    }
    Value.Length = (USHORT)(sizeof(WCHAR) * cb);
    Value.MaximumLength = (USHORT)(sizeof(WCHAR) * cb);
    Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
    if (!NT_SUCCESS(Status)) {
        LocalFree(Value.Buffer);
        Value.Length = 0;
        *lpTemp = 0;
    }
    if (Value.Length) {
        lstrcpy(lpTemp, Value.Buffer);
        if ( *( lpTemp + lstrlen(lpTemp) - 1) != TEXT(';') ) {
            lstrcat(lpTemp, TEXT(";"));
        }
        LocalFree(Value.Buffer);
    }
    if (lpPathValue && ((lstrlen(lpTemp) + lstrlen(lpPathValue) + 1) < (INT)cb)) {
        lstrcat(lpTemp, lpPathValue);

        RtlInitUnicodeString(&Value, lpTemp);

        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    if (NT_SUCCESS(Status)) {
        return(TRUE);
    }
    return(FALSE);
}

/***************************************************************************\
* AppendNTPathWithAutoexecPath
*
* Gets the AutoexecPath created in ProcessAutoexec, and appends it to
* the NT path.
*
* History:
* 05-28-92  Johannec     Created.
*
\***************************************************************************/
BOOL
AppendNTPathWithAutoexecPath(
    PVOID *pEnv,
    LPTSTR lpPathVariable,
    LPTSTR lpAutoexecPath
    )
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    WCHAR AutoexecPathValue[1024];
    DWORD cb;
    BOOL Success;

    if (!*pEnv) {
        return(FALSE);
    }

    RtlInitUnicodeString(&Name, lpAutoexecPath);
    cb = 1024;
    Value.Buffer = (PWCHAR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
    if (!Value.Buffer) {
        return(FALSE);
    }

    Value.Length = (USHORT)cb;
    Value.MaximumLength = (USHORT)cb;
    Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
    if (!NT_SUCCESS(Status)) {
        LocalFree(Value.Buffer);
        return(FALSE);
    }

    if (Value.Length) {
        lstrcpy(AutoexecPathValue, Value.Buffer);
    }

    LocalFree(Value.Buffer);

    Success = BuildEnvironmentPath(pEnv, lpPathVariable, AutoexecPathValue);
    RtlSetEnvironmentVariable( pEnv, &Name, NULL);

    return(Success);
}

/***************************************************************************\
* SetEnvironmentVariables
*
* Reads the user-defined environment variables from the user registry
* and adds them to the environment block at pEnv.
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL
SetEnvironmentVariables(
    PVOID *pEnv,
    LPTSTR lpRegSubKey,
    HKEY hKeyCU
    )
{
    WCHAR lpValueName[MAX_PATH];
    LPBYTE  lpDataBuffer;
    DWORD cbDataBuffer;
    LPBYTE  lpData;
    LPTSTR lpExpandedValue = NULL;
    DWORD cbValueName = MAX_PATH;
    DWORD cbData;
    DWORD dwType;
    DWORD dwIndex = 0;
    HKEY hkey;
    BOOL bResult;

    if (RegOpenKeyExW(hKeyCU, lpRegSubKey, 0, KEY_READ, &hkey)) {
        return(FALSE);
    }

    cbDataBuffer = 4096;
    lpDataBuffer = (LPBYTE)LocalAlloc(LPTR, cbDataBuffer*sizeof(WCHAR));
    if (lpDataBuffer == NULL) {
        RegCloseKey(hkey);
        return(FALSE);
    }
    lpData = lpDataBuffer;
    cbData = cbDataBuffer;
    bResult = TRUE;
    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cbValueName, 0, &dwType,
                         lpData, &cbData)) {
        if (cbValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_SZ) {
                //
                // The path variables PATH, LIBPATH and OS2LIBPATH must have
                // their values apppended to the system path.
                //

                if ( !lstrcmpi(lpValueName, PATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, LIBPATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, OS2LIBPATH_VARIABLE) ) {

                    BuildEnvironmentPath(pEnv, lpValueName, (LPTSTR)lpData);
                }
                else {

                    //
                    // the other environment variables are just set.
                    //

                    SetEnvironmentVariableInBlock(pEnv, lpValueName, (LPTSTR)lpData, TRUE);
                }
            }
        }
        dwIndex++;
        cbData = cbDataBuffer;
        cbValueName = MAX_PATH;
    }

    dwIndex = 0;
    cbData = cbDataBuffer;
    cbValueName = MAX_PATH;


    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cbValueName, 0, &dwType,
                         lpData, &cbData)) {
        if (cbValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_EXPAND_SZ) {
                DWORD cb, cbNeeded;

                cb = 1024;
                lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
                if (lpExpandedValue) {
                    cbNeeded = ExpandUserEnvironmentStrings(*pEnv, (LPTSTR)lpData, lpExpandedValue, cb);
                    if (cbNeeded > cb) {
                        LocalFree(lpExpandedValue);
                        cb = cbNeeded;
                        lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
                        if (lpExpandedValue) {
                            ExpandUserEnvironmentStrings(*pEnv, (LPTSTR)lpData, lpExpandedValue, cb);
                        }
                    }
                }

                if (lpExpandedValue == NULL) {
                    bResult = FALSE;
                    break;
                }


                //
                // The path variables PATH, LIBPATH and OS2LIBPATH must have
                // their values apppended to the system path.
                //

                if ( !lstrcmpi(lpValueName, PATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, LIBPATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, OS2LIBPATH_VARIABLE) ) {

                    BuildEnvironmentPath(pEnv, lpValueName, (LPTSTR)lpExpandedValue);
                }
                else {

                    //
                    // the other environment variables are just set.
                    //

                    SetEnvironmentVariableInBlock(pEnv, lpValueName, (LPTSTR)lpExpandedValue, TRUE);
                }

                LocalFree(lpExpandedValue);

            }

        }
        dwIndex++;
        cbData = cbDataBuffer;
        cbValueName = MAX_PATH;
    }



    LocalFree(lpDataBuffer);
    RegCloseKey(hkey);

    return(bResult);
}

//*************************************************************
//
//  ExpandEnvironmentStringsForUser()
//
// Purpose:  Expands the source string using the environment block for the
//           specified user.  If hToken is null, the system environment block
//           will be used (no user environment variables).
//
//  Parameters: hToken  -  User's token (or null for system env vars)
//              lpSrc   -  String to be expanded
//              lpDest  -  Buffer to receive string
//              dwSize  -  Size of dest buffer
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL WINAPI ExpandEnvironmentStringsForUser(HANDLE hToken, LPCTSTR lpSrc,
                                            LPTSTR lpDest, DWORD dwSize)
{
    LPVOID pEnv;
    DWORD  dwNeeded;
    BOOL bResult = FALSE;


    //
    // Arg check
    //
    
    if ( !lpDest || !lpSrc )
    {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    
    //
    // Get the user's environment block
    //

    if (!CreateEnvironmentBlock (&pEnv, hToken, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("ExpandEnvironmentStringsForUser:  CreateEnvironmentBlock failed with = %d"),
                 GetLastError()));
        return FALSE;
    }


    //
    // Expand the string
    //

    dwNeeded = ExpandUserEnvironmentStrings(pEnv, lpSrc, lpDest, dwSize);

    if (dwNeeded && (dwNeeded < dwSize)) {
        bResult = TRUE;
    } else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER );
    }


    //
    // Free the environment block
    //

    DestroyEnvironmentBlock (pEnv);


    return bResult;
}

//*************************************************************
//
//  GetSystemTempDirectory()
//
//  Purpose:    Gets the system temp directory in short form
//
//  Parameters: lpDir     - Receives the directory
//              lpcchSize - Size of the lpDir buffer
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL WINAPI GetSystemTempDirectory(LPTSTR lpDir, LPDWORD lpcchSize)
{
    TCHAR  szTemp[MAX_PATH];
    TCHAR  szDirectory[MAX_PATH];
    DWORD  dwLength;
    HKEY   hKey;
    LONG   lResult;
    DWORD  dwSize, dwType;
    BOOL   bRetVal = FALSE;
    WIN32_FILE_ATTRIBUTE_DATA fad;


    szTemp[0] = TEXT('\0');
    szDirectory[0] = TEXT('\0');

    //
    // Look in the system environment variables
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, SYS_ENVVARS, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for TEMP
        //

        dwSize = sizeof(szTemp);

        if (RegQueryValueEx (hKey, TEXT("TEMP"), NULL, &dwType,
                             (LPBYTE) szTemp, &dwSize) == ERROR_SUCCESS) {
            RegCloseKey (hKey);
            goto FoundTemp;
        }


        //
        // Check for TMP
        //

        dwSize = sizeof(szTemp);

        if (RegQueryValueEx (hKey, TEXT("TMP"), NULL, &dwType,
                             (LPBYTE) szTemp, &dwSize) == ERROR_SUCCESS) {
            RegCloseKey (hKey);
            goto FoundTemp;
        }


        RegCloseKey (hKey);
    }


    //
    // Check if %SystemRoot%\Temp exists
    //

    lstrcpy (szDirectory, TEXT("%SystemRoot%\\Temp"));
    ExpandEnvironmentStrings (szDirectory, szTemp, ARRAYSIZE (szTemp));

    if (GetFileAttributesEx (szTemp, GetFileExInfoStandard, &fad) &&
        fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        goto FoundTemp;
    }


    //
    // Check if %SystemDrive%\Temp exists
    //

    lstrcpy (szDirectory, TEXT("%SystemDrive%\\Temp"));
    ExpandEnvironmentStrings (szDirectory, szTemp, ARRAYSIZE (szTemp));

    if (GetFileAttributesEx (szTemp, GetFileExInfoStandard, &fad) &&
        fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        goto FoundTemp;
    }


    //
    // Last resort is %SystemRoot%
    //

    lstrcpy (szTemp, TEXT("%SystemRoot%"));



FoundTemp:

    ExpandEnvironmentStrings (szTemp, szDirectory, ARRAYSIZE (szDirectory));
    GetShortPathName (szDirectory, szTemp, ARRAYSIZE(szTemp));

    dwLength = lstrlen(szTemp) + 1;

    if (lpDir) {

        if (*lpcchSize >= dwLength) {
            lstrcpy (lpDir, szTemp);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    } else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }


    *lpcchSize = dwLength;

    return bRetVal;
}

#ifdef _X86_
BOOL
IsPathIncludeRemovable(LPTSTR lpValue)
{
    LPTSTR      lpt, tmp;
    BOOL        ret = FALSE;
    WCHAR       c;

    tmp = LocalAlloc(LPTR, (lstrlen(lpValue) + 1) * sizeof(WCHAR));
    if (!tmp) {
        DebugMsg((DM_WARNING, TEXT("IsPathIncludeRemovable : Failed to LocalAlloc (%d)"), GetLastError()));
    }
    else {
	lstrcpy(tmp, lpValue);

	lpt = tmp;
	while (*lpt) {
	    // skip spaces
	    for ( ; *lpt && *lpt == TEXT(' '); lpt++)
		;

	    // check if the drive is removable
	    if (lpt[0] && lpt[1] && lpt[1] == TEXT(':') && lpt[2]) {        // ex) "A:\"
		c = lpt[3];
		lpt[3] = 0;
		if (GetDriveType(lpt) == DRIVE_REMOVABLE) {
		    lpt[3] = c;
		    ret = TRUE;
		    break;
		}
		lpt[3] = c;
	    }

	    // skip to the next path
	    for ( ; *lpt && *lpt != TEXT(';'); lpt++)
		;
	    if (*lpt)
		lpt++;
	}
	LocalFree(tmp);
    }
    return(ret);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\profile\prof_guid.cpp ===
//*************************************************************
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//*************************************************************

#define INITGUID

#include <ole2.h>

// {eb7428f5-ab1f-4322-a4cc-1f1a9b2c5e98}
DEFINE_GUID(CLSID_CUserProfile, 
0xeb7428f5, 0xab1f, 0x4322, 0xa4, 0xcc, 0x1f, 0x1a, 0x9b, 0x2c, 0x5e, 0x98);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\profile\profile.h ===
//*************************************************************
//
//  Header file for Profile.cpp
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

//
// Internal flags
//

#define PROFILE_MANDATORY       0x00000001
#define PROFILE_USE_CACHE       0x00000002
#define PROFILE_NEW_LOCAL       0x00000004
#define PROFILE_NEW_CENTRAL     0x00000008
#define PROFILE_UPDATE_CENTRAL  0x00000010
#define PROFILE_DELETE_CACHE    0x00000020
// do not define bit 40 because NT4 has this defined as Run_SyncApps.
#define PROFILE_GUEST_USER      0x00000080
#define PROFILE_ADMIN_USER      0x00000100
#define DEFAULT_NET_READY       0x00000200
#define PROFILE_SLOW_LINK       0x00000400
#define PROFILE_TEMP_ASSIGNED   0x00000800
// do not define bit 1000, this was used briefly 2009, 2010 before
#define PROFILE_PARTLY_LOADED   0x00002000
#define PROFILE_BACKUP_EXISTS   0x00004000
#define PROFILE_THIS_IS_BAK     0x00008000
#define PROFILE_READONLY        0x00010000
#define PROFILE_LOCALMANDATORY  0x00020000

//
// Registry key names
//

#define USER_CLASSES_HIVE_SUFFIX   TEXT("_Classes")
#define USER_KEY_PREFIX            TEXT("\\Registry\\User\\")

//
// Local system name
//

#define LOCAL_SYSTEM_NAME          L"NT AUTHORITY\\SYSTEM"

//
// User Preference values
//

#define USERINFO_LOCAL                   0
#define USERINFO_FLOATING                1
#define USERINFO_MANDATORY               2
#define USERINFO_BACKUP                  3
#define USERINFO_TEMP                    4
#define USERINFO_UNDEFINED              99

#define PROFILEERRORACTION_TEMP          0
#define PROFILEERRORACTION_LOGOFF        1

typedef struct _PROFILE {
    DWORD       dwFlags;
    DWORD       dwInternalFlags;
    DWORD       dwUserPreference;
    HANDLE      hTokenUser;
    HANDLE      hTokenClient;
    LPTSTR      lpUserName;
    LPTSTR      lpProfilePath;
    LPTSTR      lpRoamingProfile;
    LPTSTR      lpDefaultProfile;
    LPTSTR      lpLocalProfile;
    LPTSTR      lpPolicyPath;
    LPTSTR      lpServerName;
    HKEY        hKeyCurrentUser;
    FILETIME    ftProfileLoad;
    FILETIME    ftProfileUnload;
    LPTSTR      lpExclusionList;
} USERPROFILE, *LPPROFILE;

typedef struct _SLOWLINKDLGINFO {
    DWORD       dwTimeout;
    BOOL        bSyncDefault;
} SLOWLINKDLGINFO, FAR *LPSLOWLINKDLGINFO;

static LPWSTR cszRPCProtocol = L"ncalrpc";
static LPWSTR cszRPCEndPoint = L"IUserProfile";
static DWORD  cdwMaxRpcCalls = 1000000;

// structure used to store client context
typedef struct _CLIENTINFO 
{
    HANDLE         hClientToken;
    LPPROFILEINFO  pProfileInfo;
}CLIENTINFO, *PCLIENTINFO;

#if defined(__cplusplus)
extern "C"{
#endif
LONG MyRegLoadKey(HKEY hKey, LPTSTR lpSubKey, LPTSTR lpFile);
BOOL MyRegUnLoadKey(HKEY hKey, LPTSTR lpSubKey);
BOOL SetupNewHive(LPPROFILE lpProfile, LPTSTR lpSidString, PSID pSid);
BOOL DeleteProfileEx (LPCTSTR lpSidString, LPTSTR lpLocalProfile, DWORD dwDeleteFlags, HKEY hKeyLM, LPCTSTR szComputerName);
BOOL ComputeLocalProfileName (LPPROFILE lpProfile, LPCTSTR lpUserName,
                              LPTSTR lpProfileImage, DWORD  cchMaxProfileImage,
                              LPTSTR lpExpProfileImage, DWORD  cchMaxExpProfileImage,
                              PSID pSid, BOOL bWin9xUpg);
BOOL SetDefaultUserHiveSecurity(LPPROFILE lpProfile, PSID pSid, HKEY RootKey);
LONG LoadUserClasses( LPPROFILE lpProfile, LPTSTR SidString, BOOL bNewlyIssued);
BOOL UnloadClasses(LPTSTR lpSidString);
BOOL CreateSecureDirectory (LPPROFILE lpProfile, LPTSTR lpDirectory, PSID pSid, BOOL fRestricted);
#if defined(__cplusplus)
}
#endif

#define DP_BACKUP       1
#define DP_BACKUPEXISTS 2
#define DP_DELBACKUP    4

BOOL MoveUserProfiles (LPCTSTR lpSrcDir, LPCTSTR lpDestDir);
LPTSTR GetProfileSidString(HANDLE hToken);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\profile\hive.cpp ===
//*************************************************************
//
//  HKCR management routines
//
//  hkcr.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997
//  All rights reserved
//
//*************************************************************

/*++

Abstract:

    This module contains the code executed at logon for 
    creating a user classes hive and mapping it into the standard
    user hive.  The user classes hive and its machine classes
    counterpart make up the registry subtree known as 
    HKEY_CLASSES_ROOT.

Author:

    Zeke Odins-Lucas    (zekel)   18-Oct-2000
        changed from hkcr.c to hive.cpp
    Adam P. Edwards     (adamed)  10-Oct-1997
    Gregory Jensenworth (gregjen) 1-Jul-1997

Key Functions:

    LoadUserHives
    UnloadUserHives

Notes:

    Starting with NT5, the HKEY_CLASSES_ROOT key is per-user
    instead of per-machine -- previously, HKCR was an alias for 
    HKLM\Software\Classes.  

    The per-user HKCR combines machine classes stored it the 
    traditional HKLM\Software\Classes location with classes
    stored in HKCU\Software\Classes.

    Certain keys, such as CLSID, will have subkeys that come
    from both the machine and user locations.  When there is a conflict
    in key names, the user oriented key overrides the other one --
    only the user key is seen in that case.

    Originally, the code in this module was responsible for 
    creating this combined view.  That responsibility has moved
    to the win32 registry api's, so the main responsibility of 
    this module is the mapping of the user-specific classes into
    the registry.

    It should be noted that HKCU\Software\Classes is not the true
    location of the user-only class data.  If it were, all the class
    data would be in ntuser.dat, which roams with the user.  Since
    class data can get very large, installation of a few apps
    would cause HKCU (ntuser.dat) to grow from a few hundred thousand K
    to several megabytes.  Since user-only class data comes from
    the directory, it does not need to roam and therefore it was
    separated from HKCU (ntuser.dat) and stored in another hive
    mounted under HKEY_USERS.

    It is still desirable to allow access to this hive through
    HKCU\Software\Classes, so we use some trickery (symlinks) to
    make it seem as if the user class data exists there.


--*/

#include "uenv.h"
#include <malloc.h>

#define USER_CLASSES_HIVE_NAME     TEXT("\\UsrClass.dat")
#define CLASSES_SUBTREE            TEXT("Software\\Classes\\")

#define TEMPHIVE_FILENAME          TEXT("TempClassesHive.dat")

#define CLASSES_CLSID_SUBTREE      TEXT("Software\\Classes\\Clsid\\")
#define EXPLORER_CLASSES_SUBTREE   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Clsid\\")
#define LENGTH(x)                  (sizeof(x) - sizeof(WCHAR))
#define INIT_SPECIALKEY(x)         x

typedef WCHAR* SpecialKey;

SpecialKey SpecialSubtrees[]= {
    INIT_SPECIALKEY(L"*"),
    INIT_SPECIALKEY(L"*\\shellex"),
    INIT_SPECIALKEY(L"*\\shellex\\ContextMenuHandlers"),
    INIT_SPECIALKEY(L"*\\shellex\\PropertyShellHandlers"),
    INIT_SPECIALKEY(L"AppID"),
    INIT_SPECIALKEY(L"ClsID"), 
    INIT_SPECIALKEY(L"Component Categories"),
    INIT_SPECIALKEY(L"Drive"),
    INIT_SPECIALKEY(L"Drive\\shellex"),
    INIT_SPECIALKEY(L"Drive\\shellex\\ContextMenuHandlers"),
    INIT_SPECIALKEY(L"Drive\\shellex\\PropertyShellHandlers"),
    INIT_SPECIALKEY(L"FileType"),
    INIT_SPECIALKEY(L"Folder"),
    INIT_SPECIALKEY(L"Folder\\shellex"),
    INIT_SPECIALKEY(L"Folder\\shellex\\ColumnHandler"),
    INIT_SPECIALKEY(L"Folder\\shellex\\ContextMenuHandlers"), 
    INIT_SPECIALKEY(L"Folder\\shellex\\ExtShellFolderViews"),
    INIT_SPECIALKEY(L"Folder\\shellex\\PropertySheetHandlers"),
    INIT_SPECIALKEY(L"Installer\\Components"),
    INIT_SPECIALKEY(L"Installer\\Features"),
    INIT_SPECIALKEY(L"Installer\\Products"),
    INIT_SPECIALKEY(L"Interface"),
    INIT_SPECIALKEY(L"Mime"),
    INIT_SPECIALKEY(L"Mime\\Database"), 
    INIT_SPECIALKEY(L"Mime\\Database\\Charset"),
    INIT_SPECIALKEY(L"Mime\\Database\\Codepage"),
    INIT_SPECIALKEY(L"Mime\\Database\\Content Type"),
    INIT_SPECIALKEY(L"Typelib")
};
    
#define NUM_SPECIAL_SUBTREES    (sizeof(SpecialSubtrees)/sizeof(*SpecialSubtrees))

//*************************************************************
//
//  MoveUserClassesBeforeMerge
//
//  Purpose:    move HKCU\Software\Classes before
//              MapUserClassesIntoUserHive() deletes it.
//
//  Parameters: lpProfile -   Profile information
//              lpcszLocalHiveDir - Temp Hive location
//
//  Return:     ERROR_SUCCESS if successful,
//              other error if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/6/99      vtan       Created
//
//*************************************************************
LONG MoveUserClassesBeforeMerge(
    LPPROFILE lpProfile,
    LPCTSTR lpcszLocalHiveDir)
{
    LONG    res;
    HKEY    hKeySource;

    // Open HKCU\Software\Classes and see if there is a subkey.
    // No subkeys would indicate that the move has already been
    // done or there is no data to move.

    res = RegOpenKeyEx(lpProfile->hKeyCurrentUser, CLASSES_CLSID_SUBTREE, 0, KEY_ALL_ACCESS, &hKeySource);
    if (ERROR_SUCCESS == res)
    {
        DWORD   dwSubKeyCount;

        if ((ERROR_SUCCESS == RegQueryInfoKey(hKeySource, NULL, NULL, NULL, &dwSubKeyCount, NULL, NULL, NULL, NULL, NULL, NULL, NULL)) &&
            (dwSubKeyCount > 0))
        {
            LPTSTR  pszLocalTempHive;

            // Allocate enough space for the local hive directory and the temp hive filename.

            pszLocalTempHive = (LPTSTR) alloca((lstrlen(lpcszLocalHiveDir) * sizeof(TCHAR)) + 
                                      sizeof(TEMPHIVE_FILENAME) +
                                      (sizeof('\0') * sizeof(TCHAR)));

            // Get a path to a file to save HKCU\Software\Classes into.

            if (pszLocalTempHive != NULL)
            {
                HANDLE  hToken = NULL;
                BOOL    bAdjustPriv = FALSE;

                lstrcpy(pszLocalTempHive, lpcszLocalHiveDir);
                lstrcat(pszLocalTempHive, TEMPHIVE_FILENAME);

                // RegSaveKey() fails if the file exists so delete it first.

                DeleteFile(pszLocalTempHive);

                //
                // Check to see if we are impersonating.
                //

                if(!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken) || hToken == NULL) {
                    bAdjustPriv = TRUE;
                }
                else {
                    CloseHandle(hToken);
                }

                if(!bAdjustPriv) {

                    DWORD   dwDisposition;
                    HKEY    hKeyTarget;
                    BOOL    fSavedHive;

                    // Save HKCU\Software\Classes into the temp hive
                    // and restore the state of SE_BACKUP_NAME privilege

                    res = RegSaveKey(hKeySource, pszLocalTempHive, NULL);
                    
                    if (ERROR_SUCCESS == res)
                    {
                        res = RegCreateKeyEx(lpProfile->hKeyCurrentUser, EXPLORER_CLASSES_SUBTREE, 0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyTarget, &dwDisposition);
                        if (ERROR_SUCCESS == res)
                        {

                            // Restore temp hive to a new location at
                            // HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer
                            // This performs the upgrade from NT4 to NT5.

                            res = RegRestoreKey(hKeyTarget, pszLocalTempHive, 0);
                            if (ERROR_SUCCESS != res)
                            {
                                DebugMsg((DM_WARNING, TEXT("RegRestoreKey failed with error %d"), res));
                            }
                            RegCloseKey(hKeyTarget);
                        }
                        else
                        {
                            DebugMsg((DM_WARNING, TEXT("RegCreateKeyEx failed to create key %s with error %d"), EXPLORER_CLASSES_SUBTREE, res));
                        }
                    }
                    else
                    {
                        DebugMsg((DM_WARNING, TEXT("RegSaveKey failed with error %d"), res));
                    }
                }
                else {
                    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
                    {
                        DWORD               dwReturnTokenPrivilegesSize;
                        TOKEN_PRIVILEGES    oldTokenPrivileges, newTokenPrivileges;

                        // Enable SE_BACKUP_NAME privilege

                        if (LookupPrivilegeValue(NULL, SE_BACKUP_NAME, &newTokenPrivileges.Privileges[0].Luid))
                        {
                            newTokenPrivileges.PrivilegeCount = 1;
                            newTokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
                            if (AdjustTokenPrivileges(hToken, FALSE, &newTokenPrivileges, sizeof(newTokenPrivileges), &oldTokenPrivileges, &dwReturnTokenPrivilegesSize))
                            {
                                BOOL    fSavedHive;

                                // Save HKCU\Software\Classes into the temp hive
                                // and restore the state of SE_BACKUP_NAME privilege

                                res = RegSaveKey(hKeySource, pszLocalTempHive, NULL);
                                if (!AdjustTokenPrivileges(hToken, FALSE, &oldTokenPrivileges, 0, NULL, NULL))
                                {
                                    DebugMsg((DM_WARNING, TEXT("AdjustTokenPrivileges failed to restore old privileges with error %d"), GetLastError()));
                                }
                                if (ERROR_SUCCESS == res)
                                {

                                    // Enable SE_RESTORE_NAME privilege.

                                    if (LookupPrivilegeValue(NULL, SE_RESTORE_NAME, &newTokenPrivileges.Privileges[0].Luid))
                                    {
                                        newTokenPrivileges.PrivilegeCount = 1;
                                        newTokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
                                        if (AdjustTokenPrivileges(hToken, FALSE, &newTokenPrivileges, sizeof(newTokenPrivileges), &oldTokenPrivileges, &dwReturnTokenPrivilegesSize))
                                        {
                                            DWORD   dwDisposition;
                                            HKEY    hKeyTarget;

                                            res = RegCreateKeyEx(lpProfile->hKeyCurrentUser, EXPLORER_CLASSES_SUBTREE, 0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyTarget, &dwDisposition);
                                            if (ERROR_SUCCESS == res)
                                            {

                                                // Restore temp hive to a new location at
                                                // HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer
                                                // This performs the upgrade from NT4 to NT5.

                                                res = RegRestoreKey(hKeyTarget, pszLocalTempHive, 0);
                                                if (ERROR_SUCCESS != res)
                                                {
                                                    DebugMsg((DM_WARNING, TEXT("RegRestoreKey failed with error %d"), res));
                                                }
                                                RegCloseKey(hKeyTarget);
                                            }
                                            else
                                            {
                                                DebugMsg((DM_WARNING, TEXT("RegCreateKeyEx failed to create key %s with error %d"), EXPLORER_CLASSES_SUBTREE, res));
                                            }
                                            if (!AdjustTokenPrivileges(hToken, FALSE, &oldTokenPrivileges, 0, NULL, NULL))
                                            {
                                                DebugMsg((DM_WARNING, TEXT("AdjustTokenPrivileges failed to restore old privileges with error %d"), GetLastError()));
                                            }
                                        }
                                        else
                                        {
                                            res = GetLastError();
                                            DebugMsg((DM_WARNING, TEXT("AdjustTokenPrivileges failed with error %d"), res));
                                        }
                                    }
                                    else
                                    {
                                        res = GetLastError();
                                        DebugMsg((DM_WARNING, TEXT("LookupPrivilegeValue failed with error %d"), res));
                                    }
                                }
                                else
                                {
                                    DebugMsg((DM_WARNING, TEXT("RegSaveKey failed with error %d"), res));
                                }
                            }
                            else
                            {
                                res = GetLastError();
                                DebugMsg((DM_WARNING, TEXT("AdjustTokenPrivileges failed with error %d"), res));
                            }
                        }
                        else
                        {
                            res = GetLastError();
                            DebugMsg((DM_WARNING, TEXT("LookupPrivilegeValue failed with error %d"), res));
                        }
                        CloseHandle(hToken);
                    }
                    else
                    {
                        res = GetLastError();
                        DebugMsg((DM_WARNING, TEXT("OpenProcessToken failed to get token with error %d"), res));
                    }
                } // if(!bAdjustPriv) else

                // Delete local temporary hive file.

                DeleteFile(pszLocalTempHive);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("alloca failed to allocate temp hive path buffer")));
            }
        }
        RegCloseKey(hKeySource);
    }
    else if (ERROR_FILE_NOT_FOUND == res)
    {
        res = ERROR_SUCCESS;
    }
    return res;
}

//*************************************************************
//
//  CreateRegLink()
//
//  Purpose:    Create a link from the hkDest + SubKeyName
//              pointing to lpSourceRootName
//
//              if the key (link) already exists, do nothing
//
//  Parameters: hkDest            - root of destination
//              SubKeyName        - subkey of destination
//              lpSourceName      - target of link
//
//  Return:     ERROR_SUCCESS if successful
//              other NTSTATUS if an error occurs
//
//*************************************************************/

LONG CreateRegLink(HKEY hkDest,
                   LPCTSTR SubKeyName,
                   LPCTSTR lpSourceName)
{
    NTSTATUS Status;
    UNICODE_STRING  LinkTarget;
    UNICODE_STRING  SubKey;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE hkInternal;
    UNICODE_STRING  SymbolicLinkValueName;

    //
    // Initialize special key value used to make symbolic links
    //
    RtlInitUnicodeString(&SymbolicLinkValueName, L"SymbolicLinkValue");

    //
    // Initialize unicode string for our in params
    //
    RtlInitUnicodeString(&LinkTarget, lpSourceName);
    RtlInitUnicodeString(&SubKey, SubKeyName);

    //
    // See if this link already exists -- this is necessary because
    // NtCreateKey fails with STATUS_OBJECT_NAME_COLLISION if a link
    // already exists and will not return a handle to the existing
    // link.
    //
    InitializeObjectAttributes(&Attributes,
                               &SubKey,
                               OBJ_CASE_INSENSITIVE | OBJ_OPENLINK,
                               hkDest,
                               NULL);

    //
    // If this call succeeds, we get a handle to the existing link
    //
    Status = NtOpenKey( &hkInternal,
                        MAXIMUM_ALLOWED,
                        &Attributes );

    if (STATUS_OBJECT_NAME_NOT_FOUND == Status) {

        //
        // There is no existing link, so use NtCreateKey to make a new one
        //
        Status = NtCreateKey( &hkInternal,
                              KEY_CREATE_LINK | KEY_SET_VALUE,
                              &Attributes,
                              0,
                              NULL,
                              REG_OPTION_VOLATILE | REG_OPTION_CREATE_LINK,
                              NULL);
    }

    //
    // Whether the link existed already or not, we should still set
    // the value which determines the link target
    //
    if (NT_SUCCESS(Status)) {

        Status = NtSetValueKey( hkInternal,
                                &SymbolicLinkValueName,
                                0,
                                REG_LINK,
                                LinkTarget.Buffer,
                                LinkTarget.Length);
        NtClose(hkInternal);
    }

    return RtlNtStatusToDosError(Status);
}


//*************************************************************
//
//  DeleteRegLink()
//
//  Purpose:    Deletes a registry key (or link) without
//              using the advapi32 registry apis
//
//
//  Parameters: hkRoot          -   parent key
//              lpSubKey        -   subkey to delete
//
//  Return:     ERROR_SUCCESS if successful
//              other error if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/6/98      adamed     Created
//
//*************************************************************

LONG DeleteRegLink(HKEY hkRoot, LPCTSTR lpSubKey)
{
    OBJECT_ATTRIBUTES Attributes;
    HANDLE            hKey;
    NTSTATUS          Status;
    UNICODE_STRING    Subtree;

    //
    // Initialize string for lpSubKey param
    //
    RtlInitUnicodeString(&Subtree, lpSubKey);

    InitializeObjectAttributes(&Attributes,
                               &Subtree,
                               OBJ_CASE_INSENSITIVE | OBJ_OPENLINK,
                               hkRoot,
                               NULL);

    //
    // Open the link
    //
    Status = NtOpenKey( &hKey,
                        MAXIMUM_ALLOWED,
                        &Attributes );

    //
    // If we succeeded in opening it, delete it
    //
    if (NT_SUCCESS(Status)) {

        Status = NtDeleteKey(hKey);
        NtClose(hKey);
    }

    return RtlNtStatusToDosError(Status);
}

#define HIVEENTRY(h, i, f, l, t)  {h, i, f, l, t}
//  table of hives to load
typedef struct
{
    LPCTSTR pszHive;
    int csidl;
    LPCTSTR pszFile;
    LPCTSTR pszLink;
    LPCTSTR pszTargetSubkey;
} USERHIVE;

static USERHIVE s_hives[] =
{
    HIVEENTRY(
        USER_CLASSES_HIVE_SUFFIX, 
        CSIDL_LOCAL_APPDATA, 
        USER_CLASSES_HIVE_NAME, 
        CLASSES_SUBTREE, 
        NULL),
        
    HIVEENTRY(
        TEXT("_Windows_Local"), 
        CSIDL_LOCAL_APPDATA, 
        TEXT("UserWin.dat"), 
        TEXT("Software\\Microsoft\\Windows\\ShellNoRoam\\"), 
        TEXT("\\ShellNoRoam")),
        
    HIVEENTRY(
        TEXT("_Windows"), 
        CSIDL_APPDATA, 
        TEXT("UserWin.dat"), 
        TEXT("Software\\Microsoft\\Windows\\Shell\\"), 
        TEXT("\\Shell")),
};

#define CCH_TARGETHIVE      MAX_PATH - (sizeof(USER_KEY_PREFIX) / sizeof(TCHAR)) + 1


class CUserHives
{
public:
    CUserHives() : _pszFile(0) {}
    ~CUserHives();
    LONG LoadHives(LPPROFILE pProfile, LPTSTR pszSid);
    BOOL UnloadHives(LPCTSTR pszSid);

protected:      //  methods
    BOOL _Init(USERPROFILE *pProfile, LPCTSTR pszSid);
    LONG _LoadHive(USERHIVE *phive);
    BOOL _UnloadHive(LPCTSTR pszHive);
    BOOL _CreateHiveFolder(USERHIVE *phive);
    BOOL _MakeTargetHive(LPCTSTR pszHive);
    LONG _CreateUserHive(USERHIVE *phive);
    LONG _PreLoadKey(BOOL fNewHive, LPCTSTR pszSub);
    LONG _CreateHiveFile(HKEY hk);
    LONG _PostLoadKey(BOOL fNewHive);
    LONG _CreateLink(USERHIVE *phive);
    LONG _DeleteLink(HKEY hk, LPCTSTR pszLink);
    
protected:      //  members
    USERPROFILE *_pup;
    LPCTSTR _sid;
    LPTSTR _pszFile;  // MAX_PATH;
    LPTSTR _pszTargetObject;
    LPTSTR _pszTargetHive;  //  points inside of _pszTargetObject;
};

BOOL _StrCatSafe(LPTSTR pszDest, LPCTSTR pszSrc, int cchDestBuffSize)
{
    LPWSTR psz = pszDest;

    // we walk forward till we find the end of pszDest, subtracting
    // from cchDestBuffSize as we go.
    while (*psz)
    {
        psz++;
        cchDestBuffSize--;
    }

    if (cchDestBuffSize > 0)
    {
        lstrcpyn(psz, pszSrc, cchDestBuffSize);
        return TRUE;
    }
    return FALSE;
}


LONG CUserHives::_DeleteLink(HKEY hk, LPCTSTR pszLink)
{
    //  delete the existing link
    LONG Error = DeleteRegLink(hk, pszLink);
    
    //
    // It's ok if the deletion fails because the classes key, link or nonlink,
    // doesn't exist.  It's also ok if it fails because the key exists but is not
    // a link and has children -- in this case, the key and its children will
    // be eliminated by a subsequent call to RegDelNode.
    //
    if (ERROR_SUCCESS != Error) {
        if ((ERROR_FILE_NOT_FOUND != Error) && (ERROR_ACCESS_DENIED != Error)) {
            return Error;
        }
    }
    //
    // Just to be safe, destroy any existing HKCU\Software\Classes and children.
    // This key may exist from previous unreleased versions of NT5, or from
    // someone playing around with hive files and adding bogus keys
    //
    if (!RegDelnode (hk, (LPTSTR)pszLink)) {

        Error = GetLastError();

        //
        // It's ok if this fails because the key doesn't exist, since
        // nonexistence is our goal.
        //
        if (ERROR_FILE_NOT_FOUND != Error) {
            return Error;
        }
    }

    return ERROR_SUCCESS;
}

LONG CUserHives::_CreateLink(USERHIVE *phive)
{
    LONG error = _DeleteLink(_pup->hKeyCurrentUser, phive->pszLink);

    if (error == ERROR_SUCCESS)
    {
        //
        // At this point, we know that no HKCU\Software\Classes exists, so we should
        // be able to make a link there which points to the hive with the user class
        // data.
        // 
        if (!phive->pszTargetSubkey || _StrCatSafe(_pszTargetObject, phive->pszTargetSubkey, MAX_PATH))
            error = CreateRegLink(_pup->hKeyCurrentUser, phive->pszLink, _pszTargetObject);
        else
            error = ERROR_NOT_ENOUGH_MEMORY;
    }   
    return error;
}

//*************************************************************
//
//  CreateClassesFolder()
//
//  Purpose:    Create the directory for the classes hives
//
//
//  Parameters:
//              pProfile       - pointer to profile struct
//              szLocalHiveDir - out param for location of
//                               classes hive folder.
//
//  Return:     ERROR_SUCCESS if successful
//              other error if an error occurs
//
//
//*************************************************************
BOOL CUserHives::_CreateHiveFolder(USERHIVE *phive)
{
    BOOL fRet = FALSE;

    //
    // Find out the correct shell location for our subdir --
    // this call will create it if it doesn't exist.
    // This is a subdir of the user profile which does not 
    // roam.
    //

    //
    // Need to do this to fix up a localisation prob. in NT4
    //
    
    PatchLocalAppData(_pup->hTokenUser);
    if (GetFolderPath(phive->csidl, _pup->hTokenUser, _pszFile))
    {
        //  append our appdata sub-dir 
        _StrCatSafe(_pszFile, TEXT("\\Microsoft\\Windows\\"), MAX_PATH);
        //
        // We will now create our own subdir, CLASSES_SUBDIRECTORY,
        // inside the local appdata subdir we just received above.
        //
        fRet = CreateNestedDirectory(_pszFile, NULL);
    }
    else
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return fRet;
}


LONG CUserHives::_PostLoadKey(BOOL fNewHive)
{
    HKEY hk;
    LONG err = RegOpenKeyEx(HKEY_USERS, _pszTargetHive, 0,
                            WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                            &hk);

    if (ERROR_SUCCESS == err) 
    {
        if (fNewHive) 
        {

            DebugMsg((DM_VERBOSE, TEXT("CreateClassHive: existing user classes hive not found")));

            //
            // An existing hive was not found before we created this hive, so we need
            // to set security on the new hive
            //

            if (SetDefaultUserHiveSecurity(_pup, NULL, hk)) 
            {
                if (!SetFileAttributes (_pszFile, FILE_ATTRIBUTE_HIDDEN)) 
                {
                    DebugMsg((DM_WARNING, TEXT("CreateClassHive: unable to set file attributes")
                              TEXT(" on classes hive %s with error %x"), _pszFile, GetLastError()));
                }
            }
            else
                err = GetLastError();
        }
        RegCloseKey(hk);
    }

    return err;
}

LONG CUserHives::_CreateHiveFile(HKEY hk)
{
    LONG err = ERROR_PRIVILEGE_NOT_HELD;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN fEnabled;
    BOOL fAdjusted = FALSE;
    HANDLE hToken;
    if(!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken) 
    || hToken == NULL) 
    {
        fAdjusted = TRUE;
        status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, TRUE, FALSE, &fEnabled);
    }
    else 
    {
        CloseHandle(hToken);
    }

    if (NT_SUCCESS(status)) 
    {
        err = RegSaveKeyEx(hk, _pszFile, NULL, REG_LATEST_FORMAT);

        if(fAdjusted) 
        {
            RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, fEnabled, FALSE, &fEnabled);
        }
    }
    return err;
}

LONG CUserHives::_PreLoadKey(BOOL fNewHive, LPCTSTR pszSub)
{
    LONG err = ERROR_SUCCESS;
    if (fNewHive)
    {
        //  we need to create it using REG_LATEST_FORMAT
        HKEY hk;
        err = RegCreateKeyEx(_pup->hKeyCurrentUser, TEXT("UserTempHive"), 0, NULL, 
                REG_OPTION_NON_VOLATILE, 
                MAXIMUM_ALLOWED, NULL, 
                &hk, NULL);
        if (ERROR_SUCCESS == err)
        {
            if (pszSub)
            {
                HKEY hkSub;
                err = RegCreateKeyEx(hk, pszSub + 1, 0, NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        MAXIMUM_ALLOWED, NULL, 
                        &hkSub, NULL);
                if (ERROR_SUCCESS == err)
                {
                    RegCloseKey(hkSub);
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("CUserHives::_PreLoadKey() failed to create %s"), pszSub + 1));
                }
            }

            RegFlushKey(hk);

            if (ERROR_SUCCESS == err)
            {
                err = _CreateHiveFile(hk);
            }

            RegCloseKey(hk);
            RegDelnode(_pup->hKeyCurrentUser, TEXT("UserTempHive"));
        }
    }
    return err;
}


BOOL CUserHives::_MakeTargetHive(LPCTSTR pszHive)
{
    // construct the hive name by appending the suffix to the sid
    lstrcpyn(_pszTargetHive, _sid, CCH_TARGETHIVE);
    return _StrCatSafe(_pszTargetHive, pszHive, CCH_TARGETHIVE);
}

LONG CUserHives::_CreateUserHive(USERHIVE *phive)
{
    //  need to do something special if it doesnt already exist
    BOOL  fNewHive = (-1 == GetFileAttributes(_pszFile));
    LONG err = _PreLoadKey(fNewHive, phive->pszTargetSubkey);
    // mount the hive
    if (ERROR_SUCCESS == err) 
    {
        err = MyRegLoadKey(HKEY_USERS, _pszTargetHive, _pszFile);
        if (ERROR_SUCCESS == err) 
        {
            err = _PostLoadKey(fNewHive);

            if (ERROR_SUCCESS == err) 
            {
                err = _CreateLink(phive);
            }
        } 
        else 
        {
            DebugMsg((DM_VERBOSE, TEXT("CreateClassHive: existing user classes hive found")));
        }
    }
    return err;
}

LONG CUserHives::_LoadHive(USERHIVE *phive)
{
    // create the directory for the user-specific classes hive
    LONG error = ERROR_NOT_ENOUGH_MEMORY;
    if (_CreateHiveFolder(phive) && _MakeTargetHive(phive->pszHive))
    {
        if (0 == lstrcmp(phive->pszHive, USER_CLASSES_HIVE_SUFFIX))
        {
            // Move HKCU\Software\Classes before merging the two
            // branches. Ignore any errors here as this branch is
            // about to be deleted by the merge anyway.
            // The reason for this move is because NT4 stores customized
            // shell icons in HKCU\Software\Classes\CLSID\{CLSID_x} and
            // NT5 stores this at HKCU\Software\Microsoft\Windows\
            // CurrentVersion\Explorer\CLSID\{CLSID_x} and must be moved
            // now before being deleted.

            LONG error = MoveUserClassesBeforeMerge(_pup, _pszFile);
            if (ERROR_SUCCESS != error) 
            {
                DebugMsg((DM_WARNING, TEXT("MoveUserClassesBeforeMerge: Failed unexpectedly (%d)."),
                         error));
            }
        }
        
        //  append the file name to load/save to
        if (_StrCatSafe(_pszFile, phive->pszFile, MAX_PATH))
        {
            error = _CreateUserHive(phive);

            if (ERROR_SUCCESS != error) 
            {
                DebugMsg((DM_WARNING, TEXT("LoadUserClasses: Failed to create user classes hive (%d)."), error));
            }
        }
    }
    else
        error = GetLastError();

    return error;
}

CUserHives::~CUserHives()
{
    if (_pszFile)
        LocalFree(_pszFile);
}

BOOL CUserHives::_Init(USERPROFILE *pProfile, LPCTSTR pszSid)
{
    //  unref'd vars!!!
    _pup = pProfile;
    _sid = pszSid;

    _pszFile = (LPTSTR) LocalAlloc(LPTR, (MAX_PATH * sizeof(TCHAR)) * 2);

    if (_pszFile)
    {
        //
        //  WARNING - we are being a little clever here
        //  we only allocate one buffer (_pszFile) that is MAX_PATH * 2
        //  we then split it up into two buffers of MAX_PATH (_pszFile & _pszTargetObject)
        //  _pszTargetObject has a constant prefix of USER_KEY_PREFIX ("\Registry\User\")
        //  we later append the key name that we will load under HKU.
        //  _pszTargetHive points to that value.
        //
        //  ie  _pszTargetObject    = "\Registry\User\{SID}_Windows" 
        //      _pszTargetHive      = "{SID}_Windows"
        //
        _pszTargetObject = _pszFile + MAX_PATH;
        lstrcpy(_pszTargetObject, USER_KEY_PREFIX);
        _pszTargetHive = _pszTargetObject + sizeof(USER_KEY_PREFIX) / sizeof(TCHAR) - 1;
        return TRUE;
    }
    return FALSE;
}

LONG CUserHives::LoadHives(USERPROFILE *pProfile, LPTSTR pszSid)
{
    LONG error;
    if (_Init(pProfile, pszSid))
    {
        //  load each of the hives in turn
        for (int i = 0; i < ARRAYSIZE(s_hives); i++)
        {
            error = _LoadHive(&s_hives[i]);
            if (error != ERROR_SUCCESS)
                break;
        }
    }
    else
        error = ERROR_NOT_ENOUGH_MEMORY;

    return error;
}

LONG LoadUserHives(LPPROFILE pProfile, LPTSTR pszSid)
{
    CUserHives hives;
    return hives.LoadHives(pProfile, pszSid);
}

BOOL CUserHives::_UnloadHive(LPCTSTR pszHive)
{
    if (_MakeTargetHive(pszHive))
    {
        HKEY hKey;
        OBJECT_ATTRIBUTES oa;
        UNICODE_STRING usTargetObject;

        //
        // Initialize string for lpSubKey param
        //
        RtlInitUnicodeString(&usTargetObject, _pszTargetObject);
        
        InitializeObjectAttributes(&oa,
                                   &usTargetObject,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        NTSTATUS Status = NtOpenKey((PHANDLE)&hKey,
                            KEY_READ,
                            &oa);

        if (NT_SUCCESS(Status)) 
        {

            //
            // Make sure the hive is persisted properly
            //
            RegFlushKey(hKey);
            RegCloseKey(hKey);

            //
            // Unmount the hive -- this should only fail if
            // someone has a subkey of the hive open -- this 
            // should not normally happen and probably means there's a service
            // that is leaking keys.
            //
            return MyRegUnLoadKey(HKEY_USERS, _pszTargetHive);
        }
    }

    DebugMsg((DM_WARNING, TEXT("UnLoadClassHive: failed to unload user hive %s"), pszHive));
    return  FALSE;
}

BOOL CUserHives::UnloadHives(LPCTSTR pszSid)
{
    if (_Init(NULL, pszSid))
    {
        //  load each of the hives in turn
        for (int i = 0; i < ARRAYSIZE(s_hives); i++)
        {
            if (!_UnloadHive(s_hives[i].pszHive))
                return FALSE;
        }
    }
    return TRUE;
}


BOOL UnloadUserHives(LPTSTR pszSid)
{
    CUserHives hives;
    // remove the implicit reference held by this process
    RegCloseKey(HKEY_CLASSES_ROOT);
   return hives.UnloadHives(pszSid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\profile\hkcr.c ===
//*************************************************************
//
//  HKCR management routines
//
//  hkcr.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997
//  All rights reserved
//
//*************************************************************

/*++

Abstract:

    This module contains the code executed at logon for 
    creating a user classes hive and mapping it into the standard
    user hive.  The user classes hive and its machine classes
    counterpart make up the registry subtree known as 
    HKEY_CLASSES_ROOT.

Author:

    Adam P. Edwards     (adamed)  10-Oct-1997
    Gregory Jensenworth (gregjen) 1-Jul-1997

Key Functions:

    LoadUserClasses
    UnloadClasses

Notes:

    Starting with NT5, the HKEY_CLASSES_ROOT key is per-user
    instead of per-machine -- previously, HKCR was an alias for 
    HKLM\Software\Classes.  

    The per-user HKCR combines machine classes stored it the 
    traditional HKLM\Software\Classes location with classes
    stored in HKCU\Software\Classes.

    Certain keys, such as CLSID, will have subkeys that come
    from both the machine and user locations.  When there is a conflict
    in key names, the user oriented key overrides the other one --
    only the user key is seen in that case.

    Originally, the code in this module was responsible for 
    creating this combined view.  That responsibility has moved
    to the win32 registry api's, so the main responsibility of 
    this module is the mapping of the user-specific classes into
    the registry.

    It should be noted that HKCU\Software\Classes is not the true
    location of the user-only class data.  If it were, all the class
    data would be in ntuser.dat, which roams with the user.  Since
    class data can get very large, installation of a few apps
    would cause HKCU (ntuser.dat) to grow from a few hundred thousand K
    to several megabytes.  Since user-only class data comes from
    the directory, it does not need to roam and therefore it was
    separated from HKCU (ntuser.dat) and stored in another hive
    mounted under HKEY_USERS.

    It is still desirable to allow access to this hive through
    HKCU\Software\Classes, so we use some trickery (symlinks) to
    make it seem as if the user class data exists there.


--*/

#include "uenv.h"
#include <malloc.h>

#define USER_CLASSES_HIVE_NAME     TEXT("\\UsrClass.dat")
#define CLASSES_SUBTREE            TEXT("Software\\Classes\\")

#define CLASSES_SUBDIRECTORY       TEXT("\\Microsoft\\Windows\\")
#define MAX_HIVE_DIR_CCH           (MAX_PATH + 1 + sizeof(CLASSES_SUBDIRECTORY))

#define TEMPHIVE_FILENAME          TEXT("TempClassesHive.dat")

#define CLASSES_CLSID_SUBTREE      TEXT("Software\\Classes\\Clsid\\")
#define EXPLORER_CLASSES_SUBTREE   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Clsid\\")
#define LENGTH(x)                  (sizeof(x) - sizeof(WCHAR))
#define INIT_SPECIALKEY(x)         x

typedef WCHAR* SpecialKey;

SpecialKey SpecialSubtrees[]= {
    INIT_SPECIALKEY(L"*"),
    INIT_SPECIALKEY(L"*\\shellex"),
    INIT_SPECIALKEY(L"*\\shellex\\ContextMenuHandlers"),
    INIT_SPECIALKEY(L"*\\shellex\\PropertyShellHandlers"),
    INIT_SPECIALKEY(L"AppID"),
    INIT_SPECIALKEY(L"ClsID"), 
    INIT_SPECIALKEY(L"Component Categories"),
    INIT_SPECIALKEY(L"Drive"),
    INIT_SPECIALKEY(L"Drive\\shellex"),
    INIT_SPECIALKEY(L"Drive\\shellex\\ContextMenuHandlers"),
    INIT_SPECIALKEY(L"Drive\\shellex\\PropertyShellHandlers"),
    INIT_SPECIALKEY(L"FileType"),
    INIT_SPECIALKEY(L"Folder"),
    INIT_SPECIALKEY(L"Folder\\shellex"),
    INIT_SPECIALKEY(L"Folder\\shellex\\ColumnHandler"),
    INIT_SPECIALKEY(L"Folder\\shellex\\ContextMenuHandlers"), 
    INIT_SPECIALKEY(L"Folder\\shellex\\ExtShellFolderViews"),
    INIT_SPECIALKEY(L"Folder\\shellex\\PropertySheetHandlers"),
    INIT_SPECIALKEY(L"Installer\\Components"),
    INIT_SPECIALKEY(L"Installer\\Features"),
    INIT_SPECIALKEY(L"Installer\\Products"),
    INIT_SPECIALKEY(L"Interface"),
    INIT_SPECIALKEY(L"Mime"),
    INIT_SPECIALKEY(L"Mime\\Database"), 
    INIT_SPECIALKEY(L"Mime\\Database\\Charset"),
    INIT_SPECIALKEY(L"Mime\\Database\\Codepage"),
    INIT_SPECIALKEY(L"Mime\\Database\\Content Type"),
    INIT_SPECIALKEY(L"Typelib")
};
    
#define NUM_SPECIAL_SUBTREES    (sizeof(SpecialSubtrees)/sizeof(*SpecialSubtrees))


//*************************************************************
//
//  CreateRegLink()
//
//  Purpose:    Create a link from the hkDest + SubKeyName
//              pointing to lpSourceRootName
//
//              if the key (link) already exists, do nothing
//
//  Parameters: hkDest            - root of destination
//              SubKeyName        - subkey of destination
//              lpSourceName      - target of link
//
//  Return:     ERROR_SUCCESS if successful
//              other NTSTATUS if an error occurs
//
//*************************************************************/

LONG CreateRegLink(HKEY hkDest,
                   LPTSTR SubKeyName,
                   LPTSTR lpSourceName)
{
    NTSTATUS Status;
    UNICODE_STRING  LinkTarget;
    UNICODE_STRING  SubKey;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE hkInternal;
    UNICODE_STRING  SymbolicLinkValueName;

    //
    // Initialize special key value used to make symbolic links
    //
    RtlInitUnicodeString(&SymbolicLinkValueName, L"SymbolicLinkValue");

    //
    // Initialize unicode string for our in params
    //
    RtlInitUnicodeString(&LinkTarget, lpSourceName);
    RtlInitUnicodeString(&SubKey, SubKeyName);

    //
    // See if this link already exists -- this is necessary because
    // NtCreateKey fails with STATUS_OBJECT_NAME_COLLISION if a link
    // already exists and will not return a handle to the existing
    // link.
    //
    InitializeObjectAttributes(&Attributes,
                               &SubKey,
                               OBJ_CASE_INSENSITIVE | OBJ_OPENLINK,
                               hkDest,
                               NULL);

    //
    // If this call succeeds, we get a handle to the existing link
    //
    Status = NtOpenKey( &hkInternal,
                        MAXIMUM_ALLOWED,
                        &Attributes );

    if (STATUS_OBJECT_NAME_NOT_FOUND == Status) {

        //
        // There is no existing link, so use NtCreateKey to make a new one
        //
        Status = NtCreateKey( &hkInternal,
                              KEY_CREATE_LINK | KEY_SET_VALUE,
                              &Attributes,
                              0,
                              NULL,
                              REG_OPTION_VOLATILE | REG_OPTION_CREATE_LINK,
                              NULL);
    }

    //
    // Whether the link existed already or not, we should still set
    // the value which determines the link target
    //
    if (NT_SUCCESS(Status)) {

        Status = NtSetValueKey( hkInternal,
                                &SymbolicLinkValueName,
                                0,
                                REG_LINK,
                                LinkTarget.Buffer,
                                LinkTarget.Length);
        NtClose(hkInternal);
    }

    return RtlNtStatusToDosError(Status);
}


//*************************************************************
//
//  DeleteRegLink()
//
//  Purpose:    Deletes a registry key (or link) without
//              using the advapi32 registry apis
//
//
//  Parameters: hkRoot          -   parent key
//              lpSubKey        -   subkey to delete
//
//  Return:     ERROR_SUCCESS if successful
//              other error if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/6/98      adamed     Created
//
//*************************************************************

LONG DeleteRegLink(HKEY hkRoot, LPTSTR lpSubKey)
{
    OBJECT_ATTRIBUTES Attributes;
    HKEY              hKey;
    NTSTATUS          Status;
    UNICODE_STRING    Subtree;

    //
    // Initialize string for lpSubKey param
    //
    RtlInitUnicodeString(&Subtree, lpSubKey);

    InitializeObjectAttributes(&Attributes,
                               &Subtree,
                               OBJ_CASE_INSENSITIVE | OBJ_OPENLINK,
                               hkRoot,
                               NULL);

    //
    // Open the link
    //
    Status = NtOpenKey( &hKey,
                        MAXIMUM_ALLOWED,
                        &Attributes );

    //
    // If we succeeded in opening it, delete it
    //
    if (NT_SUCCESS(Status)) {

        Status = NtDeleteKey(hKey);
        NtClose(hKey);
    }

    return RtlNtStatusToDosError(Status);
}


//*************************************************************
//
//  MapUserClassesIntoUserHive()
//
//  Purpose:    Makes HKCU\\Software\\Classes point to
//              the user classes hive. This is done by using
//              a symbolic link, a feature of the kernel's
//              object manager.  We use this to make 
//              HKCU\Software\Classes poing to another hive
//              where the classes exist physically.
//              If there is an existing HKCU\\Software\\Classes,
//              it is deleted along with everything below it.
//
//
//  Parameters: lpProfile       -   user's profile
//              lpSidString     -   string representing user's sid
//
//  Return:     ERROR_SUCCESS if successful
//              other error if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/6/98      adamed     Created
//
//*************************************************************
LONG MapUserClassesIntoUserHive(
    LPPROFILE lpProfile,
    LPTSTR lpSidString)
{
    LONG   Error;
    LPTSTR lpClassesKeyName;

    //
    // get memory for user classes keyname
    //
    lpClassesKeyName = alloca( lstrlen(lpSidString) * sizeof(TCHAR)
                         + sizeof( USER_CLASSES_HIVE_SUFFIX )
                         + sizeof( USER_KEY_PREFIX )
                         + sizeof(TCHAR) );

    //
    // Can't continue if no memory;
    //
    if ( !lpClassesKeyName ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // concoct user classes keyname
    //
    lstrcpy( lpClassesKeyName, USER_KEY_PREFIX);
    lstrcat( lpClassesKeyName, lpSidString );
    lstrcat( lpClassesKeyName, USER_CLASSES_HIVE_SUFFIX);

    //
    // Eliminate any existing form of HKCU\Software\Classes
    //
    
    //
    // First, delete existing link
    //
    Error = DeleteRegLink(lpProfile->hKeyCurrentUser, CLASSES_SUBTREE);

    //
    // It's ok if the deletion fails because the classes key, link or nonlink,
    // doesn't exist.  It's also ok if it fails because the key exists but is not
    // a link and has children -- in this case, the key and its children will
    // be eliminated by a subsequent call to RegDelNode.
    //
    if (ERROR_SUCCESS != Error) {
        if ((ERROR_FILE_NOT_FOUND != Error) && (ERROR_ACCESS_DENIED != Error)) {
            return Error;
        }
    }

    //
    // Just to be safe, destroy any existing HKCU\Software\Classes and children.
    // This key may exist from previous unreleased versions of NT5, or from
    // someone playing around with hive files and adding bogus keys
    //
    if (!RegDelnode (lpProfile->hKeyCurrentUser, CLASSES_SUBTREE)) {

        Error = GetLastError();

        //
        // It's ok if this fails because the key doesn't exist, since
        // nonexistence is our goal.
        //
        if (ERROR_FILE_NOT_FOUND != Error) {
            return Error;
        }
    }

    //
    // At this point, we know that no HKCU\Software\Classes exists, so we should
    // be able to make a link there which points to the hive with the user class
    // data.
    // 
    Error = CreateRegLink(lpProfile->hKeyCurrentUser,
                         CLASSES_SUBTREE,
                         lpClassesKeyName);

    return Error;
}


//*************************************************************
//
//  CreateClassesFolder()
//
//  Purpose:    Create the directory for the classes hives
//
//
//  Parameters:
//              pProfile       - pointer to profile struct
//              szLocalHiveDir - out param for location of
//                               classes hive folder.
//
//  Return:     ERROR_SUCCESS if successful
//              other error if an error occurs
//
//
//*************************************************************
LONG CreateClassesFolder(LPPROFILE pProfile, LPTSTR szLocalHiveDir)
{
    BOOL   fGotLocalData;
    BOOL   fCreatedSubdirectory;

    //
    // Find out the correct shell location for our subdir --
    // this call will create it if it doesn't exist.
    // This is a subdir of the user profile which does not 
    // roam.
    //

    //
    // Need to do this to fix up a localisation prob. in NT4
    //

    
    PatchLocalAppData(pProfile->hTokenUser);
    
    fGotLocalData = GetFolderPath (
        CSIDL_LOCAL_APPDATA,
        pProfile->hTokenUser,
        szLocalHiveDir);

    if (!fGotLocalData) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    //
    // append the terminating pathsep so we can
    // add more paths to the newly retrieved subdir
    //
    lstrcat(szLocalHiveDir, CLASSES_SUBDIRECTORY);

    //
    // We will now create our own subdir, CLASSES_SUBDIRECTORY,
    // inside the local appdata subdir we just received above.
    //
    fCreatedSubdirectory = CreateNestedDirectory(szLocalHiveDir, NULL);

    if (fCreatedSubdirectory) {
        return ERROR_SUCCESS;
    }

    return GetLastError();
}


//*************************************************************
//
//  UnloadClassHive()
//
//  Purpose:    unmounts a classes hive
//
//  Parameters: lpSidString     -   string representing user's
//                                  sid
//              lpSuffix        -   hive name suffix
//
//  Return:     ERROR_SUCCESS if successful,
//              other error if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/6/98      adamed     Created
//
//*************************************************************
LONG UnloadClassHive(
    LPTSTR lpSidString,
    LPTSTR lpSuffix)
{
    LPTSTR lpHiveName;
    LONG error;
    OBJECT_ATTRIBUTES Attributes;
    NTSTATUS Status;
    HKEY hKey;
    UNICODE_STRING ClassesFullPath;

    //
    // Get memory for the combined hive key name 
    //
    lpHiveName = alloca( lstrlen(lpSidString) * sizeof(TCHAR)
                         + sizeof(USER_KEY_PREFIX)
                         + (lstrlen(lpSuffix) + 1) *sizeof( TCHAR )
                         + sizeof(TCHAR) );


    //
    // build the key name of the combined hive
    //
    lstrcpy( lpHiveName, USER_KEY_PREFIX );
    lstrcat( lpHiveName, lpSidString );
    lstrcat( lpHiveName, lpSuffix);

    //
    // Prepare to open the root of the classes hive
    // 
    RtlInitUnicodeString(&ClassesFullPath, lpHiveName);

    InitializeObjectAttributes(&Attributes,
                               &ClassesFullPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey( &hKey,
                        KEY_READ,
                        &Attributes );

    if (NT_SUCCESS(Status)) {

        //
        // Make sure the hive is persisted properly
        //
        RegFlushKey(hKey);
        RegCloseKey(hKey);

        //
        // Unmount the hive -- this should only fail if
        // someone has a subkey of the hive open -- this 
        // should not normally happen and probably means there's a service
        // that is leaking keys.
        //
        if (MyRegUnLoadKey(HKEY_USERS,
                           lpHiveName + ((sizeof(USER_KEY_PREFIX) / sizeof(TCHAR))-1))) {
            error = ERROR_SUCCESS;
        } else {
            error = GetLastError();
        }

    } else {

        error = RtlNtStatusToDosError(Status);
    }


    if (error != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("UnLoadClassHive: failed to unload classes key with %x"), error));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("UnLoadClassHive: Successfully unmounted %s%s"), lpSidString, lpSuffix));
    }


    return  error;
}

//*************************************************************
//
//  UnloadClasses()
//
//  Purpose:    Free the special combined hive
//
//  Parameters: lpProfile -   Profile information
//              SidString -   User's Sid as a string
//
//  Return:     TRUE if successful
//              FALSE if not
//
//*************************************************************
BOOL UnloadClasses(
    LPTSTR lpSidString)
{
    LONG Error;
  
    // remove the implicit reference held by this process
    RegCloseKey(HKEY_CLASSES_ROOT);

    // unload user classes hive
    Error = UnloadClassHive(
        lpSidString,
        USER_CLASSES_HIVE_SUFFIX);

    return ERROR_SUCCESS == Error;
}


//*************************************************************
//
//  CreateUserClasses()
//
//  Purpose:    Creates necessary hives for user classes
//
//  Parameters: lpProfile   -   Profile information
//              lpSidString -   User's Sid as a string
//              lpSuffix    -   Suffix to follow the user's sid
//                              when naming the hive
//              lpHiveFileName - full path for backing hive file
//                               of user classes
//              phkResult      - root of created hive on
//                               success
//
//  Return:     ERROR_SUCCESS if successful
//              other NTSTATUS if an error occurs
//
//*************************************************************
LONG CreateClassHive(
    LPPROFILE lpProfile,
    LPTSTR    lpSidString,
    LPTSTR    lpSuffix,
    LPTSTR    lpHiveFilename,
    BOOL      bNewlyIssued)
{
    LONG                      res;
    LPTSTR                    lpHiveKeyName;
    WIN32_FILE_ATTRIBUTE_DATA fd;
    BOOL                      fHiveExists;
    HKEY                      hkRoot;

    hkRoot = NULL;

    //
    // allocate a space big enough for the hive name
    //
    lpHiveKeyName = alloca( lstrlen(lpSidString) * sizeof(TCHAR) +
                            (lstrlen(lpSuffix) + 1) * sizeof(TCHAR)
                            + sizeof(TCHAR) );

    if ( !lpHiveKeyName ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // construct the hive name by appending the suffix
    // to the sid
    //
    lstrcpy(lpHiveKeyName, lpSidString);
    lstrcat(lpHiveKeyName, lpSuffix);
   
    //
    // First, see if this hive already exists. We need to do this rather than just letting
    // RegLoadKey create or load the existing hive because if the hive is new,
    // we need to apply security. 
    //
    fHiveExists = GetFileAttributesEx(
        lpHiveFilename,
        GetFileExInfoStandard,
        &fd );

    //
    // mount the hive
    //
    res = MyRegLoadKey(HKEY_USERS, lpHiveKeyName, lpHiveFilename);

    if (ERROR_SUCCESS != res) {
        return res;
    } 

    //
    // If we succeeded, open the root
    //

    res = RegOpenKeyEx( HKEY_USERS,
                        lpHiveKeyName,
                        0,
                        WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                        &hkRoot);

    if (ERROR_SUCCESS != res) {
        MyRegUnLoadKey(HKEY_USERS, lpHiveKeyName);
        DebugMsg((DM_WARNING, TEXT("CreateClassHive: fail to open classes hive. Error %d"),res));
        return res;
    }

    if (!fHiveExists || bNewlyIssued) {

        if (!fHiveExists) {
            DebugMsg((DM_VERBOSE, TEXT("CreateClassHive: existing user classes hive not found")));
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("CreateClassHive: user classes hive copied from Default User")));
        }

        //
        // This hive is newly issued i.e. either created fresh or copied from
        // "Default User" profile, so we need to set security on the new hive
        //

        //
        // set security on this hive
        //
        if (!SetDefaultUserHiveSecurity(lpProfile, NULL, hkRoot)) {
            res = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CreateClassHive: Fail to assign proper security on new classes hive")));
        }
        
        //
        // If we succeed, set the hidden attribute on the backing hive file
        //
        if (ERROR_SUCCESS == res) {

            if (!SetFileAttributes (lpHiveFilename, FILE_ATTRIBUTE_HIDDEN)) {
                DebugMsg((DM_WARNING, TEXT("CreateClassHive: unable to set file attributes")
                          TEXT(" on classes hive %s with error %x"), lpHiveFilename, GetLastError()));
            }
        }

    } else {
        DebugMsg((DM_VERBOSE, TEXT("CreateClassHive: existing user classes hive found")));
    }

    if (hkRoot) {
        RegCloseKey(hkRoot);
    }
    

    return res;
}


//*************************************************************
//
//  CreateUserClassesHive()
//
//  Purpose:    create the user-specific classes hive
//
//  Parameters: lpProfile -   Profile information
//              SidString -   User's Sid as a string
//              szLocalHiveDir - directory in userprofile 
//                               where hive should be located
//
//  Return:     ERROR_SUCCESS if successful,
//              other error if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/6/98      adamed     Created
//
//*************************************************************
LONG CreateUserClassesHive(
    LPPROFILE lpProfile,
    LPTSTR SidString,
    LPTSTR szLocalHiveDir,
    BOOL   bNewlyIssued)
{
    LPTSTR  lpHiveFilename;
    LONG    res;

    // allocate a space big enough for the hive filename (including trailing null)
    lpHiveFilename = alloca( lstrlen(szLocalHiveDir) * sizeof(TCHAR)
                             + sizeof( USER_CLASSES_HIVE_NAME )
                             + sizeof(TCHAR) * 2);

    if ( !lpHiveFilename ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    lstrcpy( lpHiveFilename, szLocalHiveDir);
    lstrcat( lpHiveFilename, USER_CLASSES_HIVE_NAME);

    res = CreateClassHive(
        lpProfile,
        SidString,
        USER_CLASSES_HIVE_SUFFIX,
        lpHiveFilename,
        bNewlyIssued);

    if (ERROR_SUCCESS != res) {
        return res;
    }

    res = MapUserClassesIntoUserHive(lpProfile, SidString);

    return res;
}


//*************************************************************
//
//  MoveUserClassesBeforeMerge
//
//  Purpose:    move HKCU\Software\Classes before
//              MapUserClassesIntoUserHive() deletes it.
//
//  Parameters: lpProfile -   Profile information
//              lpcszLocalHiveDir - Temp Hive location
//
//  Return:     ERROR_SUCCESS if successful,
//              other error if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/6/99      vtan       Created
//
//*************************************************************
LONG MoveUserClassesBeforeMerge(
    LPPROFILE lpProfile,
    LPCTSTR lpcszLocalHiveDir)
{
    LONG    res;
    HKEY    hKeySource;

    // Open HKCU\Software\Classes and see if there is a subkey.
    // No subkeys would indicate that the move has already been
    // done or there is no data to move.

    res = RegOpenKeyEx(lpProfile->hKeyCurrentUser, CLASSES_CLSID_SUBTREE, 0, KEY_ALL_ACCESS, &hKeySource);
    if (ERROR_SUCCESS == res)
    {
        DWORD   dwSubKeyCount;

        if ((ERROR_SUCCESS == RegQueryInfoKey(hKeySource, NULL, NULL, NULL, &dwSubKeyCount, NULL, NULL, NULL, NULL, NULL, NULL, NULL)) &&
            (dwSubKeyCount > 0))
        {
            LPTSTR  pszLocalTempHive;

            // Allocate enough space for the local hive directory and the temp hive filename.

            pszLocalTempHive = alloca((lstrlen(lpcszLocalHiveDir) * sizeof(TCHAR)) + 
                                      sizeof(TEMPHIVE_FILENAME) +
                                      (sizeof('\0') * sizeof(TCHAR)));

            // Get a path to a file to save HKCU\Software\Classes into.

            if (pszLocalTempHive != NULL)
            {
                HANDLE  hToken = NULL;
                BOOL    bAdjustPriv = FALSE;

                lstrcpy(pszLocalTempHive, lpcszLocalHiveDir);
                lstrcat(pszLocalTempHive, TEMPHIVE_FILENAME);

                // RegSaveKey() fails if the file exists so delete it first.

                DeleteFile(pszLocalTempHive);

                //
                // Check to see if we are impersonating.
                //

                if(!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken) || hToken == NULL) {
                    bAdjustPriv = TRUE;
                }
                else {
                    CloseHandle(hToken);
                }

                if(!bAdjustPriv) {

                    DWORD   dwDisposition;
                    HKEY    hKeyTarget;
                    BOOL    fSavedHive;

                    // Save HKCU\Software\Classes into the temp hive
                    // and restore the state of SE_BACKUP_NAME privilege

                    res = RegSaveKey(hKeySource, pszLocalTempHive, NULL);
                    
                    if (ERROR_SUCCESS == res)
                    {
                        res = RegCreateKeyEx(lpProfile->hKeyCurrentUser, EXPLORER_CLASSES_SUBTREE, 0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyTarget, &dwDisposition);
                        if (ERROR_SUCCESS == res)
                        {

                            // Restore temp hive to a new location at
                            // HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer
                            // This performs the upgrade from NT4 to NT5.

                            res = RegRestoreKey(hKeyTarget, pszLocalTempHive, 0);
                            if (ERROR_SUCCESS != res)
                            {
                                DebugMsg((DM_WARNING, TEXT("RegRestoreKey failed with error %d"), res));
                            }
                            RegCloseKey(hKeyTarget);
                        }
                        else
                        {
                            DebugMsg((DM_WARNING, TEXT("RegCreateKeyEx failed to create key %s with error %d"), EXPLORER_CLASSES_SUBTREE, res));
                        }
                    }
                    else
                    {
                        DebugMsg((DM_WARNING, TEXT("RegSaveKey failed with error %d"), res));
                    }
                }
                else {
                    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
                    {
                        DWORD               dwReturnTokenPrivilegesSize;
                        TOKEN_PRIVILEGES    oldTokenPrivileges, newTokenPrivileges;

                        // Enable SE_BACKUP_NAME privilege

                        if (LookupPrivilegeValue(NULL, SE_BACKUP_NAME, &newTokenPrivileges.Privileges[0].Luid))
                        {
                            newTokenPrivileges.PrivilegeCount = 1;
                            newTokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
                            if (AdjustTokenPrivileges(hToken, FALSE, &newTokenPrivileges, sizeof(newTokenPrivileges), &oldTokenPrivileges, &dwReturnTokenPrivilegesSize))
                            {
                                BOOL    fSavedHive;

                                // Save HKCU\Software\Classes into the temp hive
                                // and restore the state of SE_BACKUP_NAME privilege

                                res = RegSaveKey(hKeySource, pszLocalTempHive, NULL);
                                if (!AdjustTokenPrivileges(hToken, FALSE, &oldTokenPrivileges, 0, NULL, NULL))
                                {
                                    DebugMsg((DM_WARNING, TEXT("AdjustTokenPrivileges failed to restore old privileges with error %d"), GetLastError()));
                                }
                                if (ERROR_SUCCESS == res)
                                {

                                    // Enable SE_RESTORE_NAME privilege.

                                    if (LookupPrivilegeValue(NULL, SE_RESTORE_NAME, &newTokenPrivileges.Privileges[0].Luid))
                                    {
                                        newTokenPrivileges.PrivilegeCount = 1;
                                        newTokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
                                        if (AdjustTokenPrivileges(hToken, FALSE, &newTokenPrivileges, sizeof(newTokenPrivileges), &oldTokenPrivileges, &dwReturnTokenPrivilegesSize))
                                        {
                                            DWORD   dwDisposition;
                                            HKEY    hKeyTarget;

                                            res = RegCreateKeyEx(lpProfile->hKeyCurrentUser, EXPLORER_CLASSES_SUBTREE, 0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyTarget, &dwDisposition);
                                            if (ERROR_SUCCESS == res)
                                            {

                                                // Restore temp hive to a new location at
                                                // HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer
                                                // This performs the upgrade from NT4 to NT5.

                                                res = RegRestoreKey(hKeyTarget, pszLocalTempHive, 0);
                                                if (ERROR_SUCCESS != res)
                                                {
                                                    DebugMsg((DM_WARNING, TEXT("RegRestoreKey failed with error %d"), res));
                                                }
                                                RegCloseKey(hKeyTarget);
                                            }
                                            else
                                            {
                                                DebugMsg((DM_WARNING, TEXT("RegCreateKeyEx failed to create key %s with error %d"), EXPLORER_CLASSES_SUBTREE, res));
                                            }
                                            if (!AdjustTokenPrivileges(hToken, FALSE, &oldTokenPrivileges, 0, NULL, NULL))
                                            {
                                                DebugMsg((DM_WARNING, TEXT("AdjustTokenPrivileges failed to restore old privileges with error %d"), GetLastError()));
                                            }
                                        }
                                        else
                                        {
                                            res = GetLastError();
                                            DebugMsg((DM_WARNING, TEXT("AdjustTokenPrivileges failed with error %d"), res));
                                        }
                                    }
                                    else
                                    {
                                        res = GetLastError();
                                        DebugMsg((DM_WARNING, TEXT("LookupPrivilegeValue failed with error %d"), res));
                                    }
                                }
                                else
                                {
                                    DebugMsg((DM_WARNING, TEXT("RegSaveKey failed with error %d"), res));
                                }
                            }
                            else
                            {
                                res = GetLastError();
                                DebugMsg((DM_WARNING, TEXT("AdjustTokenPrivileges failed with error %d"), res));
                            }
                        }
                        else
                        {
                            res = GetLastError();
                            DebugMsg((DM_WARNING, TEXT("LookupPrivilegeValue failed with error %d"), res));
                        }
                        CloseHandle(hToken);
                    }
                    else
                    {
                        res = GetLastError();
                        DebugMsg((DM_WARNING, TEXT("OpenProcessToken failed to get token with error %d"), res));
                    }
                } // if(!bAdjustPriv) else

                // Delete local temporary hive file.

                DeleteFile(pszLocalTempHive);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("alloca failed to allocate temp hive path buffer")));
            }
        }
        RegCloseKey(hKeySource);
    }
    else if (ERROR_FILE_NOT_FOUND == res)
    {
        res = ERROR_SUCCESS;
    }
    return res;
}


//*************************************************************
//
//  LoadUserClasses()
//
//  Purpose:    Combines the HKLM\Software\Classes subtree with the
//              HKCU\Software\Classes subtree
//
//  Parameters: lpProfile -   Profile information
//              SidString -   User's Sid as a string
//
//  Return:     ERROR_SUCCESS if successful
//              other NTSTATUS if an error occurs
//
//*************************************************************
LONG LoadUserClasses( LPPROFILE lpProfile, LPTSTR SidString, BOOL bNewlyIssued)
{
    LONG   error;
    LPTSTR szLocalHiveDir;

    error = ERROR_SUCCESS;

    //
    // first, we will create a directory for the user-specific
    // classes hive -- we need memory for it:
    //
    szLocalHiveDir = (LPTSTR) alloca(MAX_HIVE_DIR_CCH);

    if (!szLocalHiveDir) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // create the directory for the user-specific classes hive
    //
    error = CreateClassesFolder(lpProfile, szLocalHiveDir);

    if (ERROR_SUCCESS != error) {
        DebugMsg((DM_WARNING, TEXT("LoadUserClasses: Failed to create folder for combined hive (%d)."),
                 error));
        return error;
    }

    // Move HKCU\Software\Classes before merging the two
    // branches. Ignore any errors here as this branch is
    // about to be deleted by the merge anyway.
    // The reason for this move is because NT4 stores customized
    // shell icons in HKCU\Software\Classes\CLSID\{CLSID_x} and
    // NT5 stores this at HKCU\Software\Microsoft\Windows\
    // CurrentVersion\Explorer\CLSID\{CLSID_x} and must be moved
    // now before being deleted.

    error = MoveUserClassesBeforeMerge(lpProfile, szLocalHiveDir);
    if (ERROR_SUCCESS != error) {
        DebugMsg((DM_WARNING, TEXT("MoveUserClassesBeforeMerge: Failed unexpectedly (%d)."),
                 error));
    }

    //
    // Now create the user classes hive
    //
    error = CreateUserClassesHive( lpProfile, SidString, szLocalHiveDir, bNewlyIssued);

    if (ERROR_SUCCESS != error) {
        DebugMsg((DM_WARNING, TEXT("LoadUserClasses: Failed to create user classes hive (%d)."),
                 error));
    }

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\profile\setup.c ===
//*************************************************************
//
//  SETUP.C  -    API's used by setup to create groups/items
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include <uenv.h>
#include <sddl.h>   // ConvertStringSecurityDescriptorToSecurityDescriptor


// See ConvertStringSecurityDescriptorToSecurityDescriptor documentation
// for a description of the string security descriptor format.
//
// These ACLs are setup to allow
//      System, Administrators, Creator-Owner: Full Control
//      Power  Users: Modify (RWXD)
//      Users: Read (RX)
//      Users: Write (folders only)
//
// The combination of "Users: Write (folders only)" and the Creator-Owner ACE
// means that restricted users can create subfolders and files, and have full
// control to files that they create, but they cannot modify or delete files
// created by someone else.

const TCHAR c_szCommonDocumentsACL[] = TEXT("D:P(A;CIOI;GA;;;SY)(A;CIOI;GA;;;BA)(A;CIOIIO;GA;;;CO)(A;CIOI;GRGWGXSD;;;PU)(A;CIOI;GRGX;;;BU)(A;CI;0x116;;;BU)");
const TCHAR c_szCommonAppDataACL[]   = TEXT("D:P(A;CIOI;GA;;;SY)(A;CIOI;GA;;;BA)(A;CIOIIO;GA;;;CO)(A;CIOI;GRGWGXSD;;;PU)(A;CIOI;GRGX;;;BU)(A;CI;0x116;;;BU)");


BOOL PrependPath(LPCTSTR szFile, LPTSTR szResult);
BOOL CheckProfile (LPTSTR lpProfilesDir, LPTSTR lpProfileValue,
                   LPTSTR lpProfileName);
void HideSpecialProfiles(void);
void SetAclForSystemProfile(PSID pSidSystem, LPTSTR szExpandedProfilePath);

//*************************************************************
//
//  CreateGroup()
//
//  Purpose:    Creates a program group (sub-directory)
//
//  Parameters: lpGroupName     -   Name of group
//              bCommonGroup    -   Common or Personal group
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/08/95     ericflo    Created
//              3/29/00     AlexArm    Split into CreateGroup
//                                     and CreateGroupEx
//
//*************************************************************

BOOL WINAPI CreateGroup(LPCTSTR lpGroupName, BOOL bCommonGroup)
{
    //
    // Call CreateGroupEx with no name.
    //
    return CreateGroupEx( lpGroupName, bCommonGroup, NULL, 0 );
}

//*************************************************************
//
//  CreateGroupEx()
//
//  Purpose:    Creates a program group (sub-directory) and sets
//              the localized name for the program group
//
//  Parameters: lpGroupName     -   Name of group
//              bCommonGroup    -   Common or Personal group
//              lpResourceModuleName - Name of the resource module.
//              uResourceID     - Resource ID for the MUI display name.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/08/95     ericflo    Created
//              3/29/00     AlexArm    Split into CreateGroup
//                                     and CreateGroupEx
//
//*************************************************************

BOOL WINAPI CreateGroupEx(LPCWSTR lpGroupName, BOOL bCommonGroup,
                          LPCWSTR lpResourceModuleName, UINT uResourceID)
{
    TCHAR        szDirectory[MAX_PATH];
    LPTSTR       lpEnd;
    LPTSTR       lpAdjustedGroupName;
    int          csidl;
    PSHELL32_API pShell32Api;
    DWORD        dwResult;

    //
    // Validate parameters
    //

    if (!lpGroupName || !(*lpGroupName)) {
        DebugMsg((DM_WARNING, TEXT("CreateGroupEx:  Failing due to NULL group name.")));
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("CreateGroupEx:  Entering with <%s>."), lpGroupName));


    if ( ERROR_SUCCESS !=  LoadShell32Api( &pShell32Api ) ) {
        return FALSE;
    }

    //
    // Extract the CSIDL (if any) from lpGroupName
    //

    csidl = ExtractCSIDL(lpGroupName, &lpAdjustedGroupName);

    if (-1 != csidl)
    {
        //
        // Use this csidl
        // WARNING: if a CSIDL is provided, the bCommonGroup flag is meaningless
        //

        DebugMsg((DM_VERBOSE,
            TEXT("CreateGroupEx:  CSIDL = <0x%x> contained in lpGroupName replaces csidl."),
            csidl));
    }
    else
    {
        //
        // Default to CSIDL_..._PROGRAMS
        //
        csidl = bCommonGroup ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS;
    }

    //
    // Get the programs directory
    //

    if (!GetSpecialFolderPath (csidl, szDirectory)) {
        return FALSE;
    }


    //
    // Now append the requested directory
    //

    lpEnd = CheckSlash (szDirectory);
    lstrcpy (lpEnd, lpAdjustedGroupName);


    //
    // Create the group (directory)
    //
    DebugMsg((DM_VERBOSE, TEXT("CreateGroupEx:  Calling CreatedNestedDirectory with <%s>"),
        szDirectory));

    if (!CreateNestedDirectory(szDirectory, NULL)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateGroupEx:  CreatedNestedDirectory failed.")));
        return FALSE;
    }

    //
    // If the localized name is specified, set it.
    //
    if (lpResourceModuleName != NULL) {
        DebugMsg((DM_VERBOSE, TEXT("CreateGroupEx:  Calling SHSetLocalizedName.")));
        dwResult = pShell32Api->pfnShSetLocalizedName(szDirectory,
            lpResourceModuleName, uResourceID);
        if (dwResult != ERROR_SUCCESS) {
            DebugMsg((DM_VERBOSE, TEXT("CreateGroupEx:  SHSetLocalizedName failed <0x%x>."),
                     dwResult));
            return FALSE;
        }
    }

    //
    // Success
    //

    pShell32Api->pfnShChangeNotify (SHCNE_MKDIR, SHCNF_PATH, szDirectory, NULL);

    DebugMsg((DM_VERBOSE, TEXT("CreateGroupEx:  Leaving successfully.")));

    return TRUE;
}


//*************************************************************
//
//  DeleteGroup()
//
//  Purpose:    Deletes a program group (sub-directory)
//
//  Parameters: lpGroupName     -   Name of group
//              bCommonGroup    -   Common or Personal group
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/10/95     ericflo    Created
//
//*************************************************************

BOOL WINAPI DeleteGroup(LPCTSTR lpGroupName, BOOL bCommonGroup)
{
    TCHAR     szDirectory[MAX_PATH];
    LPTSTR    lpEnd;
    LPTSTR    lpAdjustedGroupName;
    int       csidl;
    PSHELL32_API pShell32Api;

    //
    // Validate parameters
    //

    if (!lpGroupName || !(*lpGroupName)) {
        DebugMsg((DM_WARNING, TEXT("DeleteGroup:  Failing due to NULL group name.")));
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("DeleteGroup:  Entering with <%s>."), lpGroupName));

    if (ERROR_SUCCESS !=  LoadShell32Api( &pShell32Api ) ) {
        return FALSE;
    }

    //
    // Extract the CSIDL (if any) from lpGroupName
    //

    csidl = ExtractCSIDL(lpGroupName, &lpAdjustedGroupName);

    if (-1 != csidl)
    {
        //
        // Use this csidl
        // WARNING: if a CSIDL is provided, the bCommonGroup flag is meaningless
        //

        DebugMsg((DM_VERBOSE,
            TEXT("DeleteGroup:  CSIDL = <0x%x> contained in lpGroupName replaces csidl."),
            csidl));
    }
    else
    {
        //
        // Default to CSIDL_..._PROGRAMS
        //

        csidl = bCommonGroup ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS;
    }

    //
    // Get the programs directory
    //

    if (!GetSpecialFolderPath (csidl, szDirectory)) {
        return FALSE;
    }


    //
    // Now append the requested directory
    //

    lpEnd = CheckSlash (szDirectory);
    lstrcpy (lpEnd, lpAdjustedGroupName);


    //
    // Delete the group (directory)
    //

    if (!Delnode(szDirectory)) {
        DebugMsg((DM_VERBOSE, TEXT("DeleteGroup:  Delnode failed.")));
        return FALSE;
    }


    //
    // Success
    //
    pShell32Api->pfnShChangeNotify (SHCNE_RMDIR, SHCNF_PATH, szDirectory, NULL);

    DebugMsg((DM_VERBOSE, TEXT("DeleteGroup:  Leaving successfully.")));

    return TRUE;
}

//*************************************************************
//
//  CreateLinkFile()
//
//  Purpose:    Creates a link file in the specified directory
//
//  Parameters: cidl            -   CSIDL_ of a special folder
//              lpSubDirectory  -   Subdirectory of special folder
//              lpFileName      -   File name of item
//              lpCommandLine   -   Command line (including args)
//              lpIconPath      -   Icon path (can be NULL)
//              iIconIndex      -   Index of icon in icon path
//              lpWorkingDir    -   Working directory
//              wHotKey         -   Hot key
//              iShowCmd        -   ShowWindow flag
//              lpDescription   -   Description of the item
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/26/98     ericflo    Created
//
//*************************************************************

BOOL WINAPI CreateLinkFile(INT     csidl,              LPCTSTR lpSubDirectory,
                           LPCTSTR lpFileName,         LPCTSTR lpCommandLine,
                           LPCTSTR lpIconPath,         int iIconIndex,
                           LPCTSTR lpWorkingDirectory, WORD wHotKey,
                           int     iShowCmd,           LPCTSTR lpDescription)
{
    return CreateLinkFileEx(csidl, lpSubDirectory, lpFileName, lpCommandLine,
                            lpIconPath, iIconIndex, lpWorkingDirectory, wHotKey,
                            iShowCmd, lpDescription, NULL, 0);
}
//*************************************************************
//
//  CreateLinkFileEx()
//
//  Purpose:    Creates a link file in the specified directory
//
//  Parameters: cidl            -   CSIDL_ of a special folder
//              lpSubDirectory  -   Subdirectory of special folder
//              lpFileName      -   File name of item
//              lpCommandLine   -   Command line (including args)
//              lpIconPath      -   Icon path (can be NULL)
//              iIconIndex      -   Index of icon in icon path
//              lpWorkingDir    -   Working directory
//              wHotKey         -   Hot key
//              iShowCmd        -   ShowWindow flag
//              lpDescription   -   Description of the item
//              lpResourceModuleName - Name of the resource module.
//              uResourceID     - Resource ID for the MUI display name.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/26/98     ericflo    Created
//
//*************************************************************


BOOL WINAPI CreateLinkFileEx(INT     csidl,                LPCTSTR lpSubDirectory,
                             LPCTSTR lpFileName,           LPCTSTR lpCommandLine,
                             LPCTSTR lpIconPath,           int iIconIndex,
                             LPCTSTR lpWorkingDirectory,   WORD wHotKey,
                             int     iShowCmd,             LPCTSTR lpDescription,
                             LPCWSTR lpResourceModuleName, UINT uResourceID)
{
    TCHAR                szItem[MAX_PATH];
    TCHAR                szArgs[MAX_PATH];
    TCHAR                szLinkName[MAX_PATH];
    TCHAR                szPath[MAX_PATH];
    LPTSTR               lpArgs, lpEnd;
    IShellLink          *psl;
    IPersistFile        *ppf;
    BOOL                 bRetVal = FALSE;
    HINSTANCE            hInstOLE32 = NULL;
    PFNCOCREATEINSTANCE  pfnCoCreateInstance;
    PFNCOINITIALIZE      pfnCoInitialize;
    PFNCOUNINITIALIZE    pfnCoUninitialize;
    LPTSTR               lpAdjustedSubDir = NULL;
    PSHELL32_API         pShell32Api;
    PSHLWAPI_API         pShlwapiApi;
    DWORD                dwResult;

    //
    // Verbose output
    //

#if DBG
    DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  Entering.")));
    DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  csidl = <0x%x>."), csidl));
    if (lpSubDirectory && *lpSubDirectory) {
        DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  lpSubDirectory = <%s>."), lpSubDirectory));
    }
    DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  lpFileName = <%s>."), lpFileName));
    DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  lpCommandLine = <%s>."), lpCommandLine));

    if (lpIconPath) {
       DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  lpIconPath = <%s>."), lpIconPath));
       DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  iIconIndex = <%d>."), iIconIndex));
    }

    if (lpWorkingDirectory) {
        DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  lpWorkingDirectory = <%s>."), lpWorkingDirectory));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  Null working directory.  Setting to %%HOMEDRIVE%%%%HOMEPATH%%")));
    }

    DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  wHotKey = <%d>."), wHotKey));
    DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  iShowCmd = <%d>."), iShowCmd));

    if (lpDescription) {
        DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  lpDescription = <%s>."), lpDescription));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  Null description.")));
    }
#endif

    //
    // Load a few functions we need
    //

    hInstOLE32 = LoadLibrary (TEXT("ole32.dll"));

    if (!hInstOLE32) {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  Failed to load ole32 with %d."),
                 GetLastError()));
        goto ExitNoFree;
    }


    pfnCoCreateInstance = (PFNCOCREATEINSTANCE)GetProcAddress (hInstOLE32,
                                        "CoCreateInstance");

    if (!pfnCoCreateInstance) {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  Failed to find CoCreateInstance with %d."),
                 GetLastError()));
        goto ExitNoFree;
    }

    pfnCoInitialize = (PFNCOINITIALIZE)GetProcAddress (hInstOLE32,
                                                       "CoInitialize");

    if (!pfnCoInitialize) {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  Failed to find CoInitialize with %d."),
                 GetLastError()));
        goto ExitNoFree;
    }

    pfnCoUninitialize = (PFNCOUNINITIALIZE)GetProcAddress (hInstOLE32,
                                                          "CoUninitialize");

    if (!pfnCoUninitialize) {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  Failed to find CoUninitialize with %d."),
                 GetLastError()));
        goto ExitNoFree;
    }

    if (ERROR_SUCCESS != LoadShell32Api( &pShell32Api ) ) {
        goto ExitNoFree;
    }


    pShlwapiApi = LoadShlwapiApi();

    if ( !pShlwapiApi ) {
        goto ExitNoFree;
    }

    //
    // Get the special folder directory
    // First check if there is a CSIDL in the subdirectory
    //

    if (lpSubDirectory && *lpSubDirectory) {

        int csidl2 = ExtractCSIDL(lpSubDirectory, &lpAdjustedSubDir);

        if (-1 != csidl2)
        {
            csidl = csidl2;
            DebugMsg((DM_VERBOSE,
                TEXT("CreateLinkFileEx:  CSIDL = <0x%x> contained in lpSubDirectory replaces csidl."),
                csidl));
        }
    }

    szLinkName[0] = TEXT('\0');
    if (csidl && !GetSpecialFolderPath (csidl, szLinkName)) {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  Failed to get profiles directory.")));
        goto ExitNoFree;
    }


    if (lpAdjustedSubDir && *lpAdjustedSubDir) {

        if (szLinkName[0] != TEXT('\0')) {
            lpEnd = CheckSlash (szLinkName);

        } else {
            lpEnd = szLinkName;
        }

        lstrcpy (lpEnd, lpAdjustedSubDir);
    }


    //
    // Create the target directory
    //

    if (!CreateNestedDirectory(szLinkName, NULL)) {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  Failed to create subdirectory <%s> with %d"),
                 szLinkName, GetLastError()));
        goto ExitNoFree;
    }


    //
    // Now tack on the filename and extension.
    //

    lpEnd = CheckSlash (szLinkName);
    lstrcpy (lpEnd, lpFileName);
    lstrcat (lpEnd, c_szLNK);


    //
    // Split the command line into the executable name
    // and arguments.
    //

    lstrcpy (szItem, lpCommandLine);

    lpArgs = pShlwapiApi->pfnPathGetArgs(szItem);

    if (*lpArgs) {
        lstrcpy (szArgs, lpArgs);

        lpArgs--;
        while (*lpArgs == TEXT(' ')) {
            lpArgs--;
        }
        lpArgs++;
        *lpArgs = TEXT('\0');
    } else {
        szArgs[0] = TEXT('\0');
    }

    pShlwapiApi->pfnPathUnquoteSpaces (szItem);


    //
    // Create an IShellLink object
    //

    pfnCoInitialize(NULL);

    if (FAILED(pfnCoCreateInstance(&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                              &IID_IShellLink, (LPVOID*)&psl)))
    {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  Could not create instance of IShellLink .")));
        goto ExitNoFree;
    }


    //
    // Query for IPersistFile
    //

    if (FAILED(psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf)))
    {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  QueryInterface of IShellLink failed.")));
        goto ExitFreePSL;
    }

    //
    // Set the item information
    //

    if (lpDescription) {
        psl->lpVtbl->SetDescription(psl, lpDescription);
    }

    PrependPath(szItem, szPath);
    psl->lpVtbl->SetPath(psl, szPath);


    psl->lpVtbl->SetArguments(psl, szArgs);
    if (lpWorkingDirectory) {
        psl->lpVtbl->SetWorkingDirectory(psl, lpWorkingDirectory);
    } else {
        psl->lpVtbl->SetWorkingDirectory(psl, TEXT("%HOMEDRIVE%%HOMEPATH%"));
    }

    PrependPath(lpIconPath, szPath);
    psl->lpVtbl->SetIconLocation(psl, szPath, iIconIndex);

    psl->lpVtbl->SetHotkey(psl, wHotKey);
    psl->lpVtbl->SetShowCmd(psl, iShowCmd);


    //
    // If the localized name is specified, set it.
    //

    if (lpResourceModuleName != NULL) {
        DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  Calling SHSetLocalizedName on link <%s>."), szLinkName));
        ppf->lpVtbl->Save(ppf, szLinkName, TRUE);
        dwResult = pShell32Api->pfnShSetLocalizedName(szLinkName,
                                                    lpResourceModuleName, uResourceID);
        if (dwResult != ERROR_SUCCESS) {
            DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  SHSetLocalizedName failed <0x%x>."),
                     dwResult));
            goto ExitFreePSL;
        }
    }

    //
    // Save the item to disk
    //

    bRetVal = SUCCEEDED(ppf->lpVtbl->Save(ppf, szLinkName, TRUE));

    if (bRetVal) {
        pShell32Api->pfnShChangeNotify (SHCNE_CREATE, SHCNF_PATH, szLinkName, NULL);
    }

    //
    // Release the IPersistFile object
    //

    ppf->lpVtbl->Release(ppf);


ExitFreePSL:

    //
    // Release the IShellLink object
    //

    psl->lpVtbl->Release(psl);

    pfnCoUninitialize();

ExitNoFree:

    if (hInstOLE32) {
        FreeLibrary (hInstOLE32);
    }

    //
    // Finished.
    //

    DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  Leaving with status of %d."), bRetVal));

    return bRetVal;
}


//*************************************************************
//
//  DeleteLinkFile()
//
//  Purpose:    Deletes the specified link file
//
//  Parameters: csidl               -   CSIDL of a special folder
//              lpSubDirectory      -   Subdirectory of special folder
//              lpFileName          -   File name of item
//              bDeleteSubDirectory -   Delete the subdirectory if possible
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/26/98     ericflo    Created
//
//*************************************************************

BOOL WINAPI DeleteLinkFile(INT csidl, LPCTSTR lpSubDirectory,
                           LPCTSTR lpFileName, BOOL bDeleteSubDirectory)
{
    TCHAR   szLinkName[MAX_PATH];
    LPTSTR  lpEnd;
    LPTSTR  lpAdjustedSubDir = NULL;
    PSHELL32_API pShell32Api;

    //
    // Verbose output
    //

#if DBG

    DebugMsg((DM_VERBOSE, TEXT("DeleteLinkFile:  Entering.")));
    DebugMsg((DM_VERBOSE, TEXT("DeleteLinkFile:  csidl = 0x%x."), csidl));
    if (lpSubDirectory && *lpSubDirectory) {
        DebugMsg((DM_VERBOSE, TEXT("DeleteLinkFile:  lpSubDirectory = <%s>."), lpSubDirectory));
    }
    DebugMsg((DM_VERBOSE, TEXT("DeleteLinkFile:  lpFileName = <%s>."), lpFileName));
    DebugMsg((DM_VERBOSE, TEXT("DeleteLinkFile:  bDeleteSubDirectory = %d."), bDeleteSubDirectory));

#endif

    if (ERROR_SUCCESS != LoadShell32Api( &pShell32Api ) ) {
        return FALSE;
    }

    //
    // Get the special folder directory
    // First check if there is a CSIDL in the subdirectory
    //

    if (lpSubDirectory && *lpSubDirectory) {

        int csidl2 = ExtractCSIDL(lpSubDirectory, &lpAdjustedSubDir);

        if (-1 != csidl2)
        {
            csidl = csidl2;
            DebugMsg((DM_VERBOSE,
                TEXT("CreateLinkFile:  CSIDL = <0x%x> contained in lpSubDirectory replaces csidl."),
                csidl));
        }
    }

    szLinkName[0] = TEXT('\0');
    if (csidl && !GetSpecialFolderPath (csidl, szLinkName)) {
        return FALSE;
    }

    if (lpAdjustedSubDir && *lpAdjustedSubDir) {
        if (szLinkName[0] != TEXT('\0')) {
            lpEnd = CheckSlash (szLinkName);
        } else {
            lpEnd = szLinkName;
        }

        lstrcpy (lpEnd, lpAdjustedSubDir);
    }

    //
    // Now tack on the filename and extension.
    //

    lpEnd = CheckSlash (szLinkName);
    lstrcpy (lpEnd, lpFileName);
    lstrcat (lpEnd, c_szLNK);

    //
    // Delete the file
    //

    if (!DeleteFile (szLinkName)) {
        DebugMsg((DM_VERBOSE, TEXT("DeleteLinkFile: Failed to delete <%s>.  Error = %d"),
                szLinkName, GetLastError()));
        return FALSE;
    }

    pShell32Api->pfnShChangeNotify (SHCNE_DELETE, SHCNF_PATH, szLinkName, NULL);

    //
    // Delete the subdirectory if appropriate (and possible).
    //

    if (bDeleteSubDirectory) {
        *(lpEnd-1) = TEXT('\0');
        if (RemoveDirectory(szLinkName)) {
            pShell32Api->pfnShChangeNotify (SHCNE_RMDIR, SHCNF_PATH, szLinkName, NULL);
        }
    }

    //
    // Success
    //

    DebugMsg((DM_VERBOSE, TEXT("DeleteLinkFile:  Leaving successfully.")));

    return TRUE;
}

//*************************************************************
//
//  PrependPath()
//
//  Purpose:    Expands the given filename to have %systemroot%
//              if appropriate
//
//  Parameters: lpFile   -  File to check
//              lpResult -  Result buffer (MAX_PATH chars in size)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/11/95    ericflo    Created
//
//*************************************************************

BOOL PrependPath(LPCTSTR lpFile, LPTSTR lpResult)
{
    TCHAR szReturn [MAX_PATH];
    TCHAR szSysRoot[MAX_PATH];
    LPTSTR lpFileName;
    DWORD dwSysLen;


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("PrependPath: Entering with <%s>"),
             lpFile ? lpFile : TEXT("NULL")));


    if (!lpFile || !*lpFile) {
        DebugMsg((DM_VERBOSE, TEXT("PrependPath: lpFile is NULL, setting lpResult to a null string")));
        *lpResult = TEXT('\0');
        return TRUE;
    }


    //
    // Call SearchPath to find the filename
    //

    if (!SearchPath (NULL, lpFile, TEXT(".exe"), MAX_PATH, szReturn, &lpFileName)) {
        DebugMsg((DM_VERBOSE, TEXT("PrependPath: SearchPath failed with error %d.  Using input string"), GetLastError()));
        lstrcpy (lpResult, lpFile);
        return TRUE;
    }


    UnExpandSysRoot(szReturn, lpResult);

    DebugMsg((DM_VERBOSE, TEXT("PrependPath: Leaving with <%s>"), lpResult));

    return TRUE;
}


//*************************************************************
//
//  SetFilePermissions()
//
//  Purpose:    Sets the given permissions on a file or directory
//
//  Parameters: lpFile  -   File to set security on
//              pszSD   -   String security descriptor
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              01/25/2001  jeffreys   Created
//
//*************************************************************

BOOL SetFilePermissions(LPCTSTR lpFile, LPCTSTR pszSD)
{
    PSECURITY_DESCRIPTOR pSD;
    BOOL bRetVal = FALSE;

    if (ConvertStringSecurityDescriptorToSecurityDescriptor(pszSD, SDDL_REVISION, &pSD, NULL))
    {
        //
        // Set the security
        //
        if (SetFileSecurity (lpFile, DACL_SECURITY_INFORMATION, pSD))
        {
            bRetVal = TRUE;
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("SetFilePermissions: SetFileSecurity failed.  Error = %d"), GetLastError()));
        }

        LocalFree(pSD);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("SetFilePermissions: ConvertStringSDToSD failed.  Error = %d"), GetLastError()));
    }

    return bRetVal;
}


//*************************************************************
//
//  ConvertCommonGroups()
//
//  Purpose:    Calls grpconv.exe to convert progman common groups
//              to Explorer common groups, and create floppy links.
//
//              NT 4 appended " (Common)" to the common groups.  For
//              NT 5, we are going to remove this tag.
//
//  Parameters: none
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//  Comments:
//
//  History:    Date        Author     Comment
//              10/1/95     ericflo    Created
//              12/5/96     ericflo    Remove common tag
//
//*************************************************************

BOOL ConvertCommonGroups (void)
{
    STARTUPINFO si;
    PROCESS_INFORMATION ProcessInformation;
    BOOL Result;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szBuffer2[MAX_PATH];
    DWORD dwType, dwSize, dwConvert;
    BOOL bRunGrpConv = TRUE;
    LONG lResult;
    HKEY hKey;
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    TCHAR szCommon[30] = {0};
    UINT cchCommon, cchFileName;
    LPTSTR lpTag, lpEnd, lpEnd2;


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ConvertCommonGroups:  Entering.")));


    //
    // Check if we have run grpconv before.
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            TEXT("Software\\Program Groups"),
                            0,
                            KEY_ALL_ACCESS,
                            &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwConvert);

        lResult = RegQueryValueEx (hKey,
                                   TEXT("ConvertedToLinks"),
                                   NULL,
                                   &dwType,
                                   (LPBYTE)&dwConvert,
                                   &dwSize);

        if (lResult == ERROR_SUCCESS) {

            //
            // If dwConvert is 1, then grpconv has run before.
            // Don't run it again.
            //

            if (dwConvert) {
                bRunGrpConv = FALSE;
            }
        }

        //
        // Now set the value to prevent grpconv from running in the future
        //

        dwConvert = 1;
        RegSetValueEx (hKey,
                       TEXT("ConvertedToLinks"),
                       0,
                       REG_DWORD,
                       (LPBYTE) &dwConvert,
                       sizeof(dwConvert));


        RegCloseKey (hKey);
    }


    if (bRunGrpConv) {

        //
        // Initialize process startup info
        //

        si.cb = sizeof(STARTUPINFO);
        si.lpReserved = NULL;
        si.lpDesktop = NULL;
        si.lpTitle = NULL;
        si.dwFlags = 0;
        si.lpReserved2 = NULL;
        si.cbReserved2 = 0;


        //
        // Spawn grpconv
        //

        lstrcpy (szBuffer, TEXT("grpconv -n"));

        Result = CreateProcess(
                          NULL,
                          szBuffer,
                          NULL,
                          NULL,
                          FALSE,
                          NORMAL_PRIORITY_CLASS,
                          NULL,
                          NULL,
                          &si,
                          &ProcessInformation
                          );

        if (!Result) {
            DebugMsg((DM_WARNING, TEXT("ConvertCommonGroups:  grpconv failed to start due to error %d."), GetLastError()));
            return FALSE;

        } else {

            //
            // Wait for up to 2 minutes
            //

            WaitForSingleObject(ProcessInformation.hProcess, 120000);

            //
            // Close our handles to the process and thread
            //

            CloseHandle(ProcessInformation.hProcess);
            CloseHandle(ProcessInformation.hThread);

        }
    }


    //
    //  Loop through all the program groups in the All Users profile
    //  and remove the " (Common)" tag.
    //

    LoadString (g_hDllInstance, IDS_COMMON, szCommon, 30);
    cchCommon = lstrlen (szCommon);

    if (!GetSpecialFolderPath (CSIDL_COMMON_PROGRAMS, szBuffer2)) {
        return FALSE;
    }
    lstrcpy (szBuffer, szBuffer2);

    lpEnd = CheckSlash (szBuffer);
    lpEnd2 = CheckSlash (szBuffer2);

    lstrcpy (lpEnd, c_szStarDotStar);

    hFile = FindFirstFile (szBuffer, &fd);

    if (hFile != INVALID_HANDLE_VALUE) {

        do  {

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                cchFileName = lstrlen (fd.cFileName);

                if (cchFileName > cchCommon) {
                    lpTag = fd.cFileName + cchFileName - cchCommon;

                    if (!lstrcmpi(lpTag, szCommon)) {

                        lstrcpy (lpEnd, fd.cFileName);
                        *lpTag = TEXT('\0');
                        lstrcpy (lpEnd2, fd.cFileName);

                        if (MoveFileEx (szBuffer, szBuffer2, MOVEFILE_REPLACE_EXISTING)) {

                            DebugMsg((DM_VERBOSE, TEXT("ConvertCommonGroups:  Successfully changed group name:")));
                            DebugMsg((DM_VERBOSE, TEXT("ConvertCommonGroups:      Orginial:  %s"), szBuffer));
                            DebugMsg((DM_VERBOSE, TEXT("ConvertCommonGroups:      New:       %s"), szBuffer2));

                        } else {
                            DebugMsg((DM_VERBOSE, TEXT("ConvertCommonGroups:  Failed to change group name with error %d."), GetLastError()));
                            DebugMsg((DM_VERBOSE, TEXT("ConvertCommonGroups:      Orginial:  %s"), szBuffer));
                            DebugMsg((DM_VERBOSE, TEXT("ConvertCommonGroups:      New:       %s"), szBuffer2));
                        }
                    }
                }
            }

        } while (FindNextFile(hFile, &fd));

        FindClose (hFile);
    }


    //
    // Success
    //

    DebugMsg((DM_VERBOSE, TEXT("ConvertCommonGroups:  Leaving Successfully.")));

    return TRUE;
}

//*************************************************************
//
//  DetermineProfilesLocation()
//
//  Purpose:    Determines if the profiles directory
//              should be in the old NT4 location or
//              the new NT5 location
//
//  Parameters: none
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL WINAPI DetermineProfilesLocation (BOOL bCleanInstall)
{
    TCHAR szDirectory[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    PTSTR szCurDest;
    PCTSTR szLookAhead;
    WIN32_FILE_ATTRIBUTE_DATA fad;
    DWORD dwSize, dwDisp;
    HKEY hKey;
    LPTSTR lpEnd;


    //
    // Check for an unattended entry first
    //

    if (bCleanInstall) {

        if (!ExpandEnvironmentStrings (TEXT("%SystemRoot%\\System32\\$winnt$.inf"), szDirectory,
                                       ARRAYSIZE(szDirectory))) {

            DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  ExpandEnvironmentStrings failed with error %d"), GetLastError()));
            return FALSE;
        }

        szDest[0] = TEXT('\0');
        GetPrivateProfileString (TEXT("guiunattended"), TEXT("profilesdir"), TEXT(""),
                                 szDest, MAX_PATH, szDirectory);

        if (szDest[0] != TEXT('\0')) {

            //
            // Since $winnt$.inf is an INF, we must strip out %% pairs
            //

            szCurDest = szDest;
            szLookAhead = szDest;

#ifdef UNICODE
            while (*szLookAhead) {
                if (szLookAhead[0] == L'%' && szLookAhead[1] == L'%') {
                    szLookAhead++;                      // pair of %%; skip one char
                }

                *szCurDest++ = *szLookAhead++;
            }
#else
            //
            // This code path is not compiled so it has not been tested
            //

#error Code written but not tested!

            while (*szLookAhead) {

                if (IsDbcsLeadByte (*szLookAhead)) {

                    *szCurDest++ = *szLookAhead++;      // copy first half of byte pair

                } else if (*szLookAhead == '%') {

                    if (!IsDbcsLeadByte (szLookAhead[1]) && szLookAhead[1] == '%') {
                        szLookAhead++;                  // pair of %%; skip one char
                    }
                }

                *szCurDest++ = *szLookAhead++;
            }

#endif

            *szCurDest = 0;

            //
            // The unattend profile directory exists.  We need to set this
            // path in the registry
            //

            if (RegCreateKeyEx (HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH,
                                0, NULL, REG_OPTION_NON_VOLATILE,
                                KEY_WRITE, NULL, &hKey,
                                &dwDisp) == ERROR_SUCCESS) {

                if (RegSetValueEx (hKey, PROFILES_DIRECTORY,
                                   0, REG_EXPAND_SZ, (LPBYTE) szDest,
                                   ((lstrlen(szDest) + 1) * sizeof(TCHAR))) == ERROR_SUCCESS) {

                    DebugMsg((DM_VERBOSE, TEXT("DetermineProfilesLocation:  Using unattend location %s for user profiles"), szDest));
                }

                RegCloseKey (hKey);
            }
        }

    } else {

        //
        // By default, the OS will try to use the new location for
        // user profiles, but if we are doing an upgrade of a machine
        // with profiles in the NT4 location, we want to continue
        // to use that location.
        //
        // Build a test path to the old All Users directory on NT4
        // to determine which location to use.
        //

        if (!ExpandEnvironmentStrings (NT4_PROFILES_DIRECTORY, szDirectory,
                                       ARRAYSIZE(szDirectory))) {

            DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  ExpandEnvironmentStrings failed with error %d, setting the dir unexpanded"), GetLastError()));
            return FALSE;
        }

        lpEnd = CheckSlash (szDirectory);
        lstrcpy (lpEnd, ALL_USERS);

        if (GetFileAttributesEx (szDirectory, GetFileExInfoStandard, &fad)) {

            //
            // An app was found that creates an "All Users" directory under NT4 profiles directory
            // Check for Default User as well.
            //

            lstrcpy (lpEnd, DEFAULT_USER);

            if (GetFileAttributesEx (szDirectory, GetFileExInfoStandard, &fad)) {

                //
                // The old profiles directory exists.  We need to set this
                // path in the registry
                //

                if (RegCreateKeyEx (HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH,
                                    0, NULL, REG_OPTION_NON_VOLATILE,
                                    KEY_WRITE, NULL, &hKey,
                                    &dwDisp) == ERROR_SUCCESS) {

                    if (RegSetValueEx (hKey, PROFILES_DIRECTORY,
                                       0, REG_EXPAND_SZ, (LPBYTE) NT4_PROFILES_DIRECTORY,
                                       ((lstrlen(NT4_PROFILES_DIRECTORY) + 1) * sizeof(TCHAR))) == ERROR_SUCCESS) {

                        DebugMsg((DM_VERBOSE, TEXT("DetermineProfilesLocation:  Using NT4 location for user profiles")));
                    }

                    RegCloseKey (hKey);
                }
            }
        }
    }


    //
    // Check if the profiles directory exists.
    //

    dwSize = ARRAYSIZE(szDirectory);
    if (!GetProfilesDirectoryEx(szDirectory, &dwSize, TRUE)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to query profiles directory root.")));
        return FALSE;
    }

    if (!CreateSecureAdminDirectory(szDirectory, OTHERSIDS_EVERYONE)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to create profiles subdirectory <%s>.  Error = %d."),
                 szDirectory, GetLastError()));
        return FALSE;
    }


    //
    // Decide where the Default User profile should be
    //

    if (!CheckProfile (szDirectory, DEFAULT_USER_PROFILE, DEFAULT_USER)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to check default user profile  Error = %d."),
                 GetLastError()));
        return FALSE;
    }


    //
    // Check if the profiles\Default User directory exists
    //

    dwSize = ARRAYSIZE(szDirectory);
    if (!GetDefaultUserProfileDirectoryEx(szDirectory, &dwSize, TRUE)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to query default user profile directory.")));
        return FALSE;
    }

    if (!CreateSecureAdminDirectory (szDirectory, OTHERSIDS_EVERYONE)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to create Default User subdirectory <%s>.  Error = %d."),
                 szDirectory, GetLastError()));
        return FALSE;
    }

    SetFileAttributes (szDirectory, FILE_ATTRIBUTE_HIDDEN);


    //
    // Decide where the All Users profile should be
    //

    dwSize = ARRAYSIZE(szDirectory);
    if (!GetProfilesDirectoryEx(szDirectory, &dwSize, TRUE)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to query profiles directory root.")));
        return FALSE;
    }

    if (!CheckProfile (szDirectory, ALL_USERS_PROFILE, ALL_USERS)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to check all users profile  Error = %d."),
                 GetLastError()));
        return FALSE;
    }


    //
    // Check if the profiles\All Users directory exists
    //

    dwSize = ARRAYSIZE(szDirectory);
    if (!GetAllUsersProfileDirectoryEx(szDirectory, &dwSize, TRUE)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to query all users profile directory.")));
        return FALSE;
    }

    //
    // Give additional permissions for power users/everyone
    //

    if (!CreateSecureAdminDirectory (szDirectory, OTHERSIDS_POWERUSERS | OTHERSIDS_EVERYONE)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to create All Users subdirectory <%s>.  Error = %d."),
                 szDirectory, GetLastError()));
        return FALSE;
    }

    //
    // Hide some special profiles like NetworkService etc.
    //

    if (!bCleanInstall) {
        HideSpecialProfiles();
    }


    return TRUE;
}

//*************************************************************
//
//  InitializeProfiles()
//
//  Purpose:    Confirms / Creates the profile, Default User,
//              and All Users directories, and converts any
//              existing common groups.
//
//  Parameters:
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   This should only be called by GUI mode setup!
//
//  History:    Date        Author     Comment
//              8/08/95     ericflo    Created
//
//*************************************************************

BOOL WINAPI InitializeProfiles (BOOL bGuiModeSetup)
{
    TCHAR               szDirectory[MAX_PATH];
    TCHAR               szSystemProfile[MAX_PATH];
    TCHAR               szTemp[MAX_PATH];
    TCHAR               szTemp2[MAX_PATH];
    DWORD               dwSize;
    DWORD               dwDisp;
    LPTSTR              lpEnd;
    DWORD               i;
    HKEY                hKey;
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    BOOL                bRetVal = FALSE;
    DWORD               dwErr;
    PSHELL32_API        pShell32Api;

    dwErr = GetLastError();

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("InitializeProfiles:  Entering.")));



    //
    // Create a named mutex that represents GUI mode setup running.
    // This allows other processes that load userenv to detect that
    // setup is running.
    //

    InitializeSecurityDescriptor( &sd, SECURITY_DESCRIPTOR_REVISION );

    SetSecurityDescriptorDacl (
                    &sd,
                    TRUE,                           // Dacl present
                    NULL,                           // NULL Dacl
                    FALSE                           // Not defaulted
                    );

    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;
    sa.nLength = sizeof(sa);

    if (!bGuiModeSetup) {

        //
        // block loading user profile
        //

        if (g_hProfileSetup) {
            ResetEvent (g_hProfileSetup);
        }
    }


    dwErr = LoadShell32Api( &pShell32Api );

    if ( dwErr != ERROR_SUCCESS ) {
        goto Exit;
    }

    //
    // Set the USERPROFILE environment variable
    //

    ExpandEnvironmentStrings(SYSTEM_PROFILE_LOCATION, szSystemProfile, MAX_PATH);

    //
    // Requery for the default user profile directory (expanded version)
    //

    dwSize = ARRAYSIZE(szDirectory);
    if (!GetDefaultUserProfileDirectoryEx(szDirectory, &dwSize, TRUE)) {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to query default user profile directory.")));
        dwErr = GetLastError();
        goto Exit;
    }

    //
    // Set the USERPROFILE environment variable
    //

    SetEnvironmentVariable (TEXT("USERPROFILE"), szDirectory);

    //
    // Create all the folders under Default User
    //

    lpEnd = CheckSlash (szDirectory);


    //
    // Loop through the shell folders
    //

    for (i=0; i < g_dwNumShellFolders; i++) {

        lstrcpy (lpEnd,  c_ShellFolders[i].szFolderLocation);

        if (!CreateNestedDirectory(szDirectory, NULL)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("InitializeProfiles: Failed to create the destination directory <%s>.  Error = %d"),
                     szDirectory, dwErr));
            goto Exit;
        }

        if (c_ShellFolders[i].iFolderResourceID != 0) {
            //  NOTE this returns an HRESULT
            dwErr = pShell32Api->pfnShSetLocalizedName( szDirectory,
                                        c_ShellFolders[i].lpFolderResourceDLL,
                                        c_ShellFolders[i].iFolderResourceID );
            if (FAILED(dwErr)) {
                DebugMsg((DM_WARNING, TEXT("InitializeProfiles: SHSetLocalizedName failed for directory <%s>.  Error = %d"),
                         szDirectory, dwErr));
                goto Exit;
            }
        }

        if (c_ShellFolders[i].bHidden) {
            SetFileAttributes(szDirectory, GetFileAttributes(szDirectory) | FILE_ATTRIBUTE_HIDDEN);
        }
    }


    //
    // Remove the %USERPROFILE%\Personal directory if it exists.
    // Windows NT 4.0 had a Personal folder in the root of the
    // user's profile.  NT 5.0 renames this folder to My Documents
    //

    if (LoadString (g_hDllInstance, IDS_SH_PERSONAL2, szTemp, ARRAYSIZE(szTemp))) {
        lstrcpy (lpEnd,  szTemp);
        RemoveDirectory(szDirectory);
    }


    //
    // Migrate the Template Directory if it exists. Copy it from %systemroot%\shellnew
    // to Templates directory under default user. Do the same for existing profiles.
    //

    if ((LoadString (g_hDllInstance, IDS_SH_TEMPLATES2, szTemp, ARRAYSIZE(szTemp))) &&
            (ExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2))) &&
            (LoadString (g_hDllInstance, IDS_SH_TEMPLATES, szTemp, ARRAYSIZE(szTemp)))) {

        //
        // if all of the above succeeded
        //

        lstrcpy (lpEnd, szTemp);
        DebugMsg((DM_VERBOSE, TEXT("InitializeProfiles: Copying <%s> to %s.  Error = %d"), szTemp2, szDirectory));
        CopyProfileDirectory(szTemp2, szDirectory, CPD_IGNORECOPYERRORS | CPD_IGNOREHIVE);
    }


    //
    // Remove %USERPROFILE%\Temp if it exists.  The Temp directory
    // will now be in the Local Settings folder
    //

    lstrcpy (lpEnd, TEXT("Temp"));
    Delnode(szDirectory);


    //
    // Remove %USERPROFILE%\Temporary Internet Files if it exists.  The
    // Temporary Internet Files directory will now be in the Local Settings
    // folder
    //

    if (LoadString (g_hDllInstance, IDS_TEMPINTERNETFILES, szTemp, ARRAYSIZE(szTemp))) {
        lstrcpy (lpEnd,  szTemp);
        Delnode(szDirectory);
    }


    //
    // Remove %USERPROFILE%\History if it exists.  The History
    // directory will now be in the Local Settings folder
    //

    if (LoadString (g_hDllInstance, IDS_HISTORY, szTemp, ARRAYSIZE(szTemp))) {
        lstrcpy (lpEnd,  szTemp);
        Delnode(szDirectory);
    }


    //
    // Set the User Shell Folder paths in the registry
    //

    lstrcpy (szTemp, TEXT(".Default"));
    lpEnd = CheckSlash (szTemp);
    lstrcpy(lpEnd, USER_SHELL_FOLDERS);

    lstrcpy (szDirectory, TEXT("%USERPROFILE%"));
    lpEnd = CheckSlash (szDirectory);

    if (RegCreateKeyEx (HKEY_USERS, szTemp,
                        0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwDisp) == ERROR_SUCCESS) {

        for (i=0; i < g_dwNumShellFolders; i++) {

            if (c_ShellFolders[i].bAddCSIDL) {
                lstrcpy (lpEnd, c_ShellFolders[i].szFolderLocation);

                RegSetValueEx (hKey, c_ShellFolders[i].lpFolderName,
                             0, REG_EXPAND_SZ, (LPBYTE) szDirectory,
                             ((lstrlen(szDirectory) + 1) * sizeof(TCHAR)));
            }
        }

        RegCloseKey (hKey);
    }


    //
    // Set the Shell Folder paths in the registry
    //

    lstrcpy (szTemp, TEXT(".Default"));
    lpEnd = CheckSlash (szTemp);
    lstrcpy(lpEnd, SHELL_FOLDERS);

    dwSize = ARRAYSIZE(szDirectory);
    if (!GetDefaultUserProfileDirectoryEx(szDirectory, &dwSize, TRUE)) {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to query default user profile directory.")));
        dwErr = GetLastError();
        goto Exit;
    }

    lpEnd = CheckSlash (szDirectory);

    if (RegCreateKeyEx (HKEY_USERS, szTemp,
                        0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwDisp) == ERROR_SUCCESS) {

        for (i=0; i < g_dwNumShellFolders; i++) {

            if (c_ShellFolders[i].bAddCSIDL) {
                lstrcpy (lpEnd, c_ShellFolders[i].szFolderLocation);

                RegSetValueEx (hKey, c_ShellFolders[i].lpFolderName,
                             0, REG_SZ, (LPBYTE) szDirectory,
                             ((lstrlen(szDirectory) + 1) * sizeof(TCHAR)));
            }
        }

        RegCloseKey (hKey);
    }

    //
    // Set the per user TEMP and TMP environment variables
    //

    if (LoadString (g_hDllInstance, IDS_SH_TEMP,
                    szTemp, ARRAYSIZE(szTemp))) {

        lstrcpy (szDirectory, TEXT("%USERPROFILE%"));
        lpEnd = CheckSlash (szDirectory);

        LoadString (g_hDllInstance, IDS_SH_LOCALSETTINGS,
                    lpEnd, ARRAYSIZE(szTemp)-(lstrlen(szDirectory)));

        lpEnd = CheckSlash (szDirectory);
        lstrcpy (lpEnd,  szTemp);


        if (RegCreateKeyEx (HKEY_USERS, TEXT(".Default\\Environment"),
                            0, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_WRITE, NULL, &hKey,
                            &dwDisp) == ERROR_SUCCESS) {

            RegSetValueEx (hKey, TEXT("TEMP"),
                           0, REG_EXPAND_SZ, (LPBYTE) szDirectory,
                           ((lstrlen(szDirectory) + 1) * sizeof(TCHAR)));

            RegSetValueEx (hKey, TEXT("TMP"),
                           0, REG_EXPAND_SZ, (LPBYTE) szDirectory,
                           ((lstrlen(szDirectory) + 1) * sizeof(TCHAR)));

            RegCloseKey (hKey);
        }
    }


    //
    // Set the user preference exclusion list.  This will
    // prevent the Local Settings folder from roaming
    //

    if (LoadString (g_hDllInstance, IDS_EXCLUSIONLIST,
                    szDirectory, ARRAYSIZE(szDirectory))) {

        lstrcpy (szTemp, TEXT(".Default"));
        lpEnd = CheckSlash (szTemp);
        lstrcpy(lpEnd, WINLOGON_KEY);

        if (RegCreateKeyEx (HKEY_USERS, szTemp,
                            0, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE, NULL, &hKey,
                            &dwDisp) == ERROR_SUCCESS) {

            RegSetValueEx (hKey, TEXT("ExcludeProfileDirs"),
                           0, REG_SZ, (LPBYTE) szDirectory,
                           ((lstrlen(szDirectory) + 1) * sizeof(TCHAR)));

            RegCloseKey (hKey);
        }
    }


    //
    // Requery for the all users profile directory (expanded version)
    //

    dwSize = ARRAYSIZE(szDirectory);
    if (!GetAllUsersProfileDirectoryEx(szDirectory, &dwSize, TRUE)) {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to query all users profile directory.")));
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // Set the ALLUSERSPROFILE environment variable
    //

    SetEnvironmentVariable (TEXT("ALLUSERSPROFILE"), szDirectory);


    //
    // Create all the folders under All Users
    //


    lpEnd = CheckSlash (szDirectory);


    //
    // Loop through the shell folders
    //

    for (i=0; i < g_dwNumCommonShellFolders; i++) {

        lstrcpy (lpEnd,  c_CommonShellFolders[i].szFolderLocation);

        if (!CreateNestedDirectory(szDirectory, NULL)) {
            DebugMsg((DM_WARNING, TEXT("InitializeProfiles: Failed to create the destination directory <%s>.  Error = %d"),
                     szDirectory, GetLastError()));
            dwErr = GetLastError();
            goto Exit;
        }

        if (c_CommonShellFolders[i].iFolderResourceID != 0) {
            //  NOTE this returns an HRESULT
            dwErr = pShell32Api->pfnShSetLocalizedName( szDirectory,
                                        c_CommonShellFolders[i].lpFolderResourceDLL,
                                        c_CommonShellFolders[i].iFolderResourceID );
            if (FAILED(dwErr)) {
                DebugMsg((DM_WARNING, TEXT("InitializeProfiles: SHSetLocalizedName failed for directory <%s>.  Error = %d"),
                         szDirectory, dwErr));
                goto Exit;
            }
        }

        if (c_CommonShellFolders[i].bHidden) {
            SetFileAttributes(szDirectory, GetFileAttributes(szDirectory) | FILE_ATTRIBUTE_HIDDEN);
        }
    }


    //
    // Unsecure the Documents and App Data folders in the All Users profile
    //

    if (LoadString (g_hDllInstance, IDS_SH_SHAREDDOCS, szTemp, ARRAYSIZE(szTemp))) {
        lstrcpy (lpEnd,  szTemp);
        SetFilePermissions(szDirectory, c_szCommonDocumentsACL);
    }

    if (LoadString (g_hDllInstance, IDS_SH_APPDATA, szTemp, ARRAYSIZE(szTemp))) {
        lstrcpy (lpEnd,  szTemp);
        SetFilePermissions(szDirectory, c_szCommonAppDataACL);
    }


    //
    // Set the User Shell Folder paths in the registry
    //

    lstrcpy (szDirectory, TEXT("%ALLUSERSPROFILE%"));
    lpEnd = CheckSlash (szDirectory);

    if (RegCreateKeyEx (HKEY_LOCAL_MACHINE, USER_SHELL_FOLDERS,
                        0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwDisp) == ERROR_SUCCESS) {

        for (i=0; i < g_dwNumCommonShellFolders; i++) {

            if (c_ShellFolders[i].bAddCSIDL) {
                lstrcpy (lpEnd, c_CommonShellFolders[i].szFolderLocation);

                RegSetValueEx (hKey, c_CommonShellFolders[i].lpFolderName,
                             0, REG_EXPAND_SZ, (LPBYTE) szDirectory,
                             ((lstrlen(szDirectory) + 1) * sizeof(TCHAR)));
            }
        }

        RegCloseKey (hKey);
    }

#if defined(_WIN64)
    //
    // On 64-bit NT, we need to create the user shell folders in
    // the 32-bit view of the registry so that 32-bit app calls
    // to SHGetFolderPath(...CSIDL_COMMON_APPDATA...) would succeed.
    //
    if (RegCreateKeyEx (HKEY_LOCAL_MACHINE, USER_SHELL_FOLDERS32,
                        0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwDisp) == ERROR_SUCCESS) {

        for (i=0; i < g_dwNumCommonShellFolders; i++) {

            if (c_ShellFolders[i].bAddCSIDL) {
                lstrcpy (lpEnd, c_CommonShellFolders[i].szFolderLocation);

                RegSetValueEx (hKey, c_CommonShellFolders[i].lpFolderName,
                             0, REG_EXPAND_SZ, (LPBYTE) szDirectory,
                             ((lstrlen(szDirectory) + 1) * sizeof(TCHAR)));
            }
        }

        RegCloseKey (hKey);
    }
#endif

    //
    // Convert any Program Manager common groups
    //

    if (!ConvertCommonGroups()) {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles: ConvertCommonGroups failed.")));
    }


    //
    // Success
    //

    DebugMsg((DM_VERBOSE, TEXT("InitializeProfiles:  Leaving successfully.")));

    bRetVal = TRUE;

Exit:

    if ((!bGuiModeSetup) && (g_hProfileSetup)) {
        SetEvent (g_hProfileSetup);
    }

    SetLastError(dwErr);
    return bRetVal;
}

//*************************************************************
//
//  CheckProfile()
//
//  Purpose:    Checks and creates a storage location for either
//              the Default User or All Users profile
//
//  Parameters: LPTSTR lpProfilesDir  - Root of the profiles
//              LPTSTR lpProfileValue - Profile registry value name
//              LPTSTR lpProfileName  - Default profile name
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL CheckProfile (LPTSTR lpProfilesDir, LPTSTR lpProfileValue,
                   LPTSTR lpProfileName)
{
    TCHAR szTemp[MAX_PATH];
    TCHAR szTemp2[MAX_PATH];
    TCHAR szName[MAX_PATH];
    TCHAR szFormat[30];
    DWORD dwSize, dwDisp, dwType;
    LPTSTR lpEnd;
    LONG lResult;
    HKEY hKey;
    INT iStrLen;
    WIN32_FILE_ATTRIBUTE_DATA fad;


    //
    // Open the ProfileList key
    //

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH,
                              0, NULL, REG_OPTION_NON_VOLATILE,
                              KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CheckProfile:  Failed to open profile list key with %d."),
                 lResult));
        return FALSE;
    }


    //
    // Check the registry to see if this folder is defined already
    //

    dwSize = sizeof(szTemp);
    if (RegQueryValueEx (hKey, lpProfileValue, NULL, &dwType,
                         (LPBYTE) szTemp, &dwSize) == ERROR_SUCCESS) {
        RegCloseKey (hKey);
        return TRUE;
    }


    //
    // Generate the default name
    //

    lstrcpy (szTemp, lpProfilesDir);
    lpEnd = CheckSlash (szTemp);
    lstrcpy (lpEnd, lpProfileName);
    lstrcpy (szName, lpProfileName);


    //
    //  Check if this directory exists
    //

    ExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2));

    if (GetFileAttributesEx (szTemp2, GetFileExInfoStandard, &fad)) {

        if (fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {


            //
            // Check if this directory is under the system root.
            // If so, this is ok, we don't need to generate a unique
            // name for this.
            //

            ExpandEnvironmentStrings (TEXT("%SystemRoot%"), szTemp,
                                      ARRAYSIZE(szTemp));

            iStrLen = lstrlen (szTemp);

            if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                               szTemp, iStrLen, szTemp2, iStrLen) != CSTR_EQUAL) {


                //
                // The directory exists already.  Use a new name of
                // Profile Name (SystemDirectory)
                //
                // eg:  Default User (WINNT)
                //

                lpEnd = szTemp + lstrlen(szTemp) - 1;

                while ((lpEnd > szTemp) && ((*lpEnd) != TEXT('\\')))
                    lpEnd--;

                if (*lpEnd == TEXT('\\')) {
                    lpEnd++;
                }

                LoadString (g_hDllInstance, IDS_PROFILE_FORMAT, szFormat,
                            ARRAYSIZE(szFormat));
                wsprintf (szName, szFormat, lpProfileName, lpEnd);

                //
                // To prevent reusing the directories, delete it first..
                //

                lstrcpy (szTemp, lpProfilesDir);
                lpEnd = CheckSlash (szTemp);
                lstrcpy (lpEnd, szName);

                if (ExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2))) {
                    DebugMsg((DM_VERBOSE, TEXT("InitializeProfiles:  Delnoding directory.. %s"), szTemp2));
                    Delnode(szTemp2);
                }
            }
        }
    }


    //
    // Save the profile name in the registry
    //

    RegSetValueEx (hKey, lpProfileValue,
                 0, REG_SZ, (LPBYTE) szName,
                 ((lstrlen(szName) + 1) * sizeof(TCHAR)));

    RegCloseKey (hKey);


    DebugMsg((DM_VERBOSE, TEXT("InitializeProfiles:  The %s profile is mapped to %s"),
             lpProfileName, szName));

    return TRUE;
}


//*************************************************************
//
//  CreateUserProfile()
//
//  Purpose:    Creates a new user profile, but does not load
//              the hive.
//
//  Parameters: pSid         -   SID pointer
//              lpUserName   -   User name
//              lpUserHive   -   Optional user hive
//              lpProfileDir -   Receives the new profile directory
//              dwDirSize    -   Size of lpProfileDir
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If a user hive isn't specified the default user
//              hive will be used.
//
//  History:    Date        Author     Comment
//              9/12/95     ericflo    Created
//
//*************************************************************

BOOL WINAPI CreateUserProfile (PSID pSid, LPCTSTR lpUserName, LPCTSTR lpUserHive,
                                 LPTSTR lpProfileDir, DWORD dwDirSize)
{
    return CreateUserProfileEx(pSid, lpUserName, lpUserHive, lpProfileDir, dwDirSize, TRUE);
}

//*************************************************************
//
//  CreateUserProfileEx()
//
//  Purpose:    Creates a new user profile, but does not load
//              the hive.
//
//  Parameters: pSid         -   SID pointer
//              lpUserName   -   User name
//              lpUserHive   -   Optional user hive
//              lpProfileDir -   Receives the new profile directory
//              dwDirSize    -   Size of lpProfileDir
//              bWin9xUpg    -   Flag to say whether it is win9x upgrade
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If a user hive isn't specified the default user
//              hive will be used.
//
//  History:    Date        Author     Comment
//              9/12/95     ericflo    Created
//
//*************************************************************

BOOL WINAPI CreateUserProfileEx (PSID pSid, LPCTSTR lpUserName, LPCTSTR lpUserHive,
                                 LPTSTR lpProfileDir, DWORD dwDirSize, BOOL bWin9xUpg)
{
    TCHAR szProfileDir[MAX_PATH];
    TCHAR szExpProfileDir[MAX_PATH] = {0};
    TCHAR szDirectory[MAX_PATH];
    TCHAR LocalProfileKey[MAX_PATH];
    UNICODE_STRING UnicodeString;
    LPTSTR lpSidString, lpEnd, lpSave;
    NTSTATUS NtStatus;
    LONG lResult;
    DWORD dwDisp;
    DWORD dwError;
    DWORD dwSize;
    DWORD dwType;
    HKEY hKey;



    //
    // Check parameters
    //

    if (!lpUserName || !lpUserName[0]) {
        DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  Null username.")));
        return FALSE;
    }

    if (!pSid) {
        DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  Null SID.")));
        return FALSE;
    }

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("CreateUserProfile:  Entering with <%s>."), lpUserName));
    DebugMsg((DM_VERBOSE, TEXT("CreateUserProfile:  Entering with user hive of <%s>."),
             lpUserHive ? lpUserHive : TEXT("NULL")));


    //
    // Convert the sid into text format
    //

    NtStatus = RtlConvertSidToUnicodeString(&UnicodeString, pSid, (BOOLEAN)TRUE);

    if (!NT_SUCCESS(NtStatus)) {
        DebugMsg((DM_WARNING, TEXT("CreateUserProfile: RtlConvertSidToUnicodeString failed, status = 0x%x"),
                 NtStatus));
        return FALSE;
    }

    lpSidString = UnicodeString.Buffer;


    //
    // Check if this user's profile exists already
    //

    lstrcpy(LocalProfileKey, PROFILE_LIST_PATH);
    lstrcat(LocalProfileKey, TEXT("\\"));
    lstrcat(LocalProfileKey, lpSidString);

    szProfileDir[0] = TEXT('\0');

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, LocalProfileKey,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(szProfileDir);
        RegQueryValueEx (hKey, PROFILE_IMAGE_VALUE_NAME, NULL,
                         &dwType, (LPBYTE) szProfileDir, &dwSize);

        RegCloseKey (hKey);
    }


    if (szProfileDir[0] == TEXT('\0')) {

        //
        // Make the user's directory
        //

        dwSize = ARRAYSIZE(szProfileDir);
        if (!GetProfilesDirectoryEx(szProfileDir, &dwSize, FALSE)) {
            DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  Failed to get profile root directory.")));
            RtlFreeUnicodeString(&UnicodeString);
            return FALSE;
        }

        if (!ComputeLocalProfileName (NULL, lpUserName, szProfileDir, ARRAYSIZE(szProfileDir),
                                      szExpProfileDir, ARRAYSIZE(szExpProfileDir), pSid, bWin9xUpg)) {
            DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  Failed to create directory.")));
            RtlFreeUnicodeString(&UnicodeString);
            return FALSE;
        }


        //
        // Copy the default user profile into this directory
        //

        dwSize = ARRAYSIZE(szDirectory);
        if (!GetDefaultUserProfileDirectoryEx(szDirectory, &dwSize, TRUE)) {
            DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  Failed to get default user profile.")));
            RtlFreeUnicodeString(&UnicodeString);
            return FALSE;
        }


        if (lpUserHive) {

            //
            // Copy the default user profile without the hive.
            //

            if (!CopyProfileDirectory (szDirectory, szExpProfileDir, CPD_IGNORECOPYERRORS | CPD_IGNOREHIVE | CPD_IGNORELONGFILENAMES)) {
                DebugMsg((DM_WARNING, TEXT("CreateUserProfile:   CopyProfileDirectory failed with error %d."), GetLastError()));
                RtlFreeUnicodeString(&UnicodeString);
                return FALSE;
            }

            //
            // Now copy the hive
            //

            lstrcpy (szDirectory, szExpProfileDir);
            lpEnd = CheckSlash (szDirectory);
            lstrcpy (lpEnd, c_szNTUserDat);

            if (lstrcmpi (lpUserHive, szDirectory)) {

                if (!CopyFile (lpUserHive, szDirectory, FALSE)) {
                    DebugMsg((DM_WARNING, TEXT("CreateUserProfile:   Failed to copy user hive with error %d."), GetLastError()));
                    DebugMsg((DM_WARNING, TEXT("CreateUserProfile:   Source:  %s."), lpUserHive));
                    DebugMsg((DM_WARNING, TEXT("CreateUserProfile:   Destination:  %s."), szDirectory));
                    RtlFreeUnicodeString(&UnicodeString);
                    return FALSE;
                }
            }

        } else {

            //
            // Copy the default user profile and the hive.
            //

            if (!CopyProfileDirectory (szDirectory, szExpProfileDir, CPD_IGNORECOPYERRORS | CPD_IGNORELONGFILENAMES)) {
                DebugMsg((DM_WARNING, TEXT("CreateUserProfile:   CopyProfileDirectory failed with error %d."), GetLastError()));
                RtlFreeUnicodeString(&UnicodeString);
                return FALSE;
            }
        }


        //
        // Save the user's profile in the registry.
        //

        lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, LocalProfileKey, 0, 0, 0,
                                KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {

           DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  Failed trying to create the local profile key <%s>, error = %d."), LocalProfileKey, lResult));
           RtlFreeUnicodeString(&UnicodeString);
           return FALSE;
        }



        //
        // Add the profile directory
        //

        lResult = RegSetValueEx(hKey, PROFILE_IMAGE_VALUE_NAME, 0,
                            REG_EXPAND_SZ,
                            (LPBYTE)szProfileDir,
                            sizeof(TCHAR)*(lstrlen(szProfileDir) + 1));


        if (lResult != ERROR_SUCCESS) {

           DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  First RegSetValueEx failed, error = %d."), lResult));
           RegCloseKey (hKey);
           RtlFreeUnicodeString(&UnicodeString);
           return FALSE;
        }


        //
        // Add the users's SID
        //

        lResult = RegSetValueEx(hKey, TEXT("Sid"), 0,
                            REG_BINARY, pSid, RtlLengthSid(pSid));


        if (lResult != ERROR_SUCCESS) {

           DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  Second RegSetValueEx failed, error = %d."), lResult));
        }


        //
        // Close the registry key
        //

        RegCloseKey (hKey);

    } else {

        //
        // The user already has a profile, so just copy the hive if
        // appropriate.
        //

        ExpandEnvironmentStrings (szProfileDir, szExpProfileDir,
                                  ARRAYSIZE(szExpProfileDir));

        if (lpUserHive) {

            //
            // Copy the hive
            //

            lstrcpy (szDirectory, szExpProfileDir);
            lpEnd = CheckSlash (szDirectory);
            lstrcpy (lpEnd, c_szNTUserDat);

            SetFileAttributes (szDirectory, FILE_ATTRIBUTE_NORMAL);

            if (lstrcmpi (lpUserHive, szDirectory)) {
                if (!CopyFile (lpUserHive, szDirectory, FALSE)) {
                    DebugMsg((DM_WARNING, TEXT("CreateUserProfile:   Failed to copy user hive with error %d."), GetLastError()));
                    DebugMsg((DM_WARNING, TEXT("CreateUserProfile:   Source:  %s."), lpUserHive));
                    DebugMsg((DM_WARNING, TEXT("CreateUserProfile:   Destination:  %s."), szDirectory));
                    RtlFreeUnicodeString(&UnicodeString);
                    return FALSE;
                }
            }

        }
    }


    //
    // Now load the hive temporary so the security can be fixed
    //

    lpEnd = CheckSlash (szExpProfileDir);
    lpSave = lpEnd - 1;
    lstrcpy (lpEnd, c_szNTUserDat);

    lResult = MyRegLoadKey(HKEY_USERS, lpSidString, szExpProfileDir);

    *lpSave = TEXT('\0');

    if (lResult != ERROR_SUCCESS) {

        DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  Failed to load hive, error = %d."), lResult));
        dwError = GetLastError();
        DeleteProfileEx (lpSidString, szExpProfileDir, FALSE, HKEY_LOCAL_MACHINE, NULL);
        RtlFreeUnicodeString(&UnicodeString);
        SetLastError(dwError);
        return FALSE;
    }

    if (!SetupNewHive(NULL, lpSidString, pSid)) {

        DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  SetupNewHive failed.")));
        dwError = GetLastError();
        MyRegUnLoadKey(HKEY_USERS, lpSidString);
        DeleteProfileEx (lpSidString, szExpProfileDir, FALSE, HKEY_LOCAL_MACHINE, NULL);
        RtlFreeUnicodeString(&UnicodeString);
        SetLastError(dwError);
        return FALSE;

    }


    //
    // Unload the hive
    //

    MyRegUnLoadKey(HKEY_USERS, lpSidString);


    //
    // Free the sid string
    //

    RtlFreeUnicodeString(&UnicodeString);


    //
    // Save the profile path if appropriate
    //

    if (lpProfileDir) {

        if ((DWORD)lstrlen(szExpProfileDir) < dwDirSize) {
            lstrcpy (lpProfileDir, szExpProfileDir);
        }
    }


    //
    // Success
    //

    DebugMsg((DM_VERBOSE, TEXT("CreateUserProfile:  Leaving successfully.")));

    return TRUE;

}


//*************************************************************************
//
// SecureUserProfiles()
//
// Routine Description :
//          This function secures user profiles during FAT->NTFS conversion.
//          The function loops through all profiles registered under current
//          OS and sets the security for the corresponding profile directory
//          and  nested subdirs. Assumption is the  function will be called
//          only during FAT->NTFS conversion.
//
// Arguments :
//          None.
//
// Return Value :
//          None.
//
// History:    Date        Author     Comment
//             8/8/00      santanuc   Created
//
//*************************************************************************

void WINAPI SecureUserProfiles(void)
{
    SECURITY_DESCRIPTOR DirSd, FileSd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pDirAcl = NULL, pFileAcl = NULL;
    PSID  pSidOwner=NULL, pSidAdmin = NULL, pSidSystem = NULL;
    DWORD cbAcl, aceIndex;
    HKEY hKeyProfilesList, hKeyProfile = NULL;
    TCHAR szSIDName[MAX_PATH], szProfilePath[MAX_PATH], szExpandedProfilePath[MAX_PATH];
    DWORD dwSIDNameSize, dwSize;
    DWORD dwIndex;
    LONG lResult;
    FILETIME ft;


    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &pSidSystem)) {
        DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to initialize system sid.  Error = %d"), GetLastError()));
        goto Exit;
    }

    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &pSidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to initialize admin sid.  Error = %d"), GetLastError()));
        goto Exit;
    }

    //
    // Open the ProfileList key
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      PROFILE_LIST_PATH,
                      0, KEY_READ, &hKeyProfilesList) != ERROR_SUCCESS) {

        DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to open ProfileList key")));
        goto Exit;
    }


    //
    // Enumerate the profiles
    //

    dwIndex = 0;
    dwSIDNameSize = ARRAYSIZE(szSIDName);
    lResult = RegEnumKeyEx(hKeyProfilesList,
                           dwIndex,
                           szSIDName,
                           &dwSIDNameSize,
                           NULL, NULL, NULL, &ft);


    while (lResult == ERROR_SUCCESS) {

        if (RegOpenKeyEx (hKeyProfilesList,
                          szSIDName,
                          0, KEY_READ, &hKeyProfile) == ERROR_SUCCESS) {

            dwSize = sizeof(szProfilePath);
            if (RegQueryValueEx (hKeyProfile,
                                 PROFILE_IMAGE_VALUE_NAME,
                                 NULL, NULL,
                                 (LPBYTE) szProfilePath,
                                 &dwSize) != ERROR_SUCCESS) {
                goto NextProfile;
            }

            //
            // Expand the profile image filename
            //

            ExpandEnvironmentStrings(szProfilePath, szExpandedProfilePath, MAX_PATH);

            //
            // Create the acl for the user profile dir
            //

            //
            // Get the owner sid
            //

            if (AllocateAndInitSidFromString(szSIDName, &pSidOwner) != STATUS_SUCCESS) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to create owner sid."), GetLastError()));
                goto IssueError;
            }

            //
            // Allocate space for the Dir object ACL
            //

            cbAcl = (2 * GetLengthSid (pSidOwner)) +
                    (2 * GetLengthSid (pSidSystem)) +
                    (2 * GetLengthSid (pSidAdmin))  +
                    sizeof(ACL) +
                    (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


            pDirAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
            if (!pDirAcl) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to allocate memory for acl.  Error = %d"), GetLastError()));
                goto IssueError;
            }

            if (!InitializeAcl(pDirAcl, cbAcl, ACL_REVISION)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to initialize acl.  Error = %d"), GetLastError()));
                goto IssueError;
            }


            //
            // Allocate space for File object ACL
            //

            cbAcl = (GetLengthSid (pSidOwner)) +
                    (GetLengthSid (pSidSystem)) +
                    (GetLengthSid (pSidAdmin))  +
                    sizeof(ACL) +
                    (3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


            pFileAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
            if (!pFileAcl) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to allocate memory for acl.  Error = %d"), GetLastError()));
                goto IssueError;
            }

            if (!InitializeAcl(pFileAcl, cbAcl, ACL_REVISION)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to initialize acl.  Error = %d"), GetLastError()));
                goto IssueError;
            }


            //
            // Add Aces.  Non-inheritable ACEs first
            //

            aceIndex = 0;
            if (!AddAccessAllowedAce(pDirAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidOwner)) {
                 DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add owner ace.  Error = %d"), GetLastError()));
                 goto IssueError;
            }
            if (!AddAccessAllowedAce(pFileAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidOwner)) {
                 DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add owner ace.  Error = %d"), GetLastError()));
                 goto IssueError;
            }

            aceIndex++;
            if (!AddAccessAllowedAce(pDirAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidSystem)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add system ace.  Error = %d"), GetLastError()));
                goto IssueError;
            }
            if (!AddAccessAllowedAce(pFileAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidSystem)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add system ace.  Error = %d"), GetLastError()));
                goto IssueError;
            }

            aceIndex++;
            if (!AddAccessAllowedAce(pDirAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidAdmin)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add builtin admin ace.  Error = %d"), GetLastError()));
                goto IssueError;
            }
            if (!AddAccessAllowedAce(pFileAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidAdmin)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add builtin admin ace.  Error = %d"), GetLastError()));
                goto IssueError;
            }

            //
            // Now the Inheritable Aces.
            //

            aceIndex++;
            if (!AddAccessAllowedAceEx(pDirAcl, ACL_REVISION, OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE, GENERIC_ALL, pSidOwner)) {
                 DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add owner ace.  Error = %d"), GetLastError()));
                 goto IssueError;
            }

            aceIndex++;
            if (!AddAccessAllowedAceEx(pDirAcl, ACL_REVISION, OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE, GENERIC_ALL, pSidSystem)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add system ace.  Error = %d"), GetLastError()));
                goto IssueError;
            }

            aceIndex++;
            if (!AddAccessAllowedAceEx(pDirAcl, ACL_REVISION, OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE, GENERIC_ALL, pSidAdmin)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add builtin admin ace.  Error = %d"), GetLastError()));
                goto IssueError;
            }


            //
            // Put together the security descriptor
            //

            if (!InitializeSecurityDescriptor(&DirSd, SECURITY_DESCRIPTOR_REVISION)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
                goto IssueError;
            }


            if (!SetSecurityDescriptorDacl(&DirSd, TRUE, pDirAcl, FALSE)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
                goto IssueError;
            }

            if (!InitializeSecurityDescriptor(&FileSd, SECURITY_DESCRIPTOR_REVISION)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
                goto IssueError;
            }


            if (!SetSecurityDescriptorDacl(&FileSd, TRUE, pFileAcl, FALSE)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
                goto IssueError;
            }

            //
            // Pass the profile path to SecureProfile for securing
            // the profile dir and nested subdirs and files.
            //

            if (!SecureNestedDir (szExpandedProfilePath, &DirSd, &FileSd)) {
                goto IssueError;
            }

            goto NextProfile;

IssueError:
            DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to secure %s Profile directory"), szExpandedProfilePath));

        }

NextProfile:

        // Free the allocated stuffs

        if (hKeyProfile) {
            RegCloseKey(hKeyProfile);
            hKeyProfile = NULL;
        }

        if (pSidOwner) {
            FreeSid(pSidOwner);
            pSidOwner = NULL;
        }

        if (pDirAcl) {
            GlobalFree (pDirAcl);
            pDirAcl = NULL;
        }

        if (pFileAcl) {
            GlobalFree (pFileAcl);
            pFileAcl = NULL;
        }

        //
        // Reset for the next loop
        //

        dwIndex++;
        dwSIDNameSize = ARRAYSIZE(szSIDName);
        lResult = RegEnumKeyEx(hKeyProfilesList,
                               dwIndex,
                               szSIDName,
                               &dwSIDNameSize,
                               NULL, NULL, NULL, &ft);
    }

    RegCloseKey(hKeyProfilesList);

Exit:

    if (pSidSystem) {
        FreeSid(pSidSystem);
    }

    if (pSidAdmin) {
        FreeSid(pSidAdmin);
    }

}


//*************************************************************************
//
// HideSpecialProfiles()
//
// Routine Description :
//          This function secures special profiles for which PI_HIDEPROFILE
//          flag is specifed, e.g. LocalService, NetworkService etc. except
//          system account profile. This mark the profile dir as super hidden.
//
// Arguments :
//          None.
//
// Return Value :
//          None.
//
// History:    Date        Author     Comment
//             8/8/00      santanuc   Created
//
//*************************************************************************

void HideSpecialProfiles(void)
{
    HKEY hKeyProfilesList, hKeyProfile = NULL;
    TCHAR szSIDName[MAX_PATH], szProfilePath[MAX_PATH], szExpandedProfilePath[MAX_PATH];
    DWORD dwSIDNameSize, dwSize;
    DWORD dwIndex, dwFlags;
    LONG lResult;
    FILETIME ft;


    //
    // Open the ProfileList key
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      PROFILE_LIST_PATH,
                      0, KEY_READ, &hKeyProfilesList) != ERROR_SUCCESS) {

        DebugMsg((DM_WARNING, TEXT("HideSpecialProfiles: Failed to open ProfileList key")));
        return;
    }


    //
    // Enumerate the profiles
    //

    dwIndex = 0;
    dwSIDNameSize = ARRAYSIZE(szSIDName);
    lResult = RegEnumKeyEx(hKeyProfilesList,
                           dwIndex,
                           szSIDName,
                           &dwSIDNameSize,
                           NULL, NULL, NULL, &ft);


    while (lResult == ERROR_SUCCESS) {

        if (RegOpenKeyEx (hKeyProfilesList,
                          szSIDName,
                          0, KEY_READ, &hKeyProfile) == ERROR_SUCCESS) {

            //
            // Process only if PI_HIDEPROFILE flag is set
            //

            dwSize = sizeof(DWORD);
            if (RegQueryValueEx (hKeyProfile,
                                 PROFILE_FLAGS,
                                 NULL, NULL,
                                 (LPBYTE) &dwFlags,
                                 &dwSize) != ERROR_SUCCESS) {
                goto NextProfile;
            }

            if (!(dwFlags & PI_HIDEPROFILE)) {
                goto NextProfile;
            }

            dwSize = sizeof(szProfilePath);
            if (RegQueryValueEx (hKeyProfile,
                                 PROFILE_IMAGE_VALUE_NAME,
                                 NULL, NULL,
                                 (LPBYTE) szProfilePath,
                                 &dwSize) != ERROR_SUCCESS) {
                goto NextProfile;
            }

            // Ignore profile for system account

            if (lstrcmp(szProfilePath, SYSTEM_PROFILE_LOCATION) == 0) {
                goto NextProfile;
            }

            //
            // Expand the profile image filename
            //

            ExpandEnvironmentStrings(szProfilePath, szExpandedProfilePath, MAX_PATH);

            // Mark the profile hidden
            SetFileAttributes(szExpandedProfilePath,
                              FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM |
                              GetFileAttributes(szExpandedProfilePath));

        }

NextProfile:

        // Free the allocated stuffs

        if (hKeyProfile) {
            RegCloseKey(hKeyProfile);
            hKeyProfile = NULL;
        }

        //
        // Reset for the next loop
        //

        dwIndex++;
        dwSIDNameSize = ARRAYSIZE(szSIDName);
        lResult = RegEnumKeyEx(hKeyProfilesList,
                               dwIndex,
                               szSIDName,
                               &dwSIDNameSize,
                               NULL, NULL, NULL, &ft);
    }

    RegCloseKey(hKeyProfilesList);

}


//*************************************************************
//
//  CopySystemProfile()
//
//  Purpose:    Create the system profile information under
//              ProfileList entry.
//              In case of upgrade copy system profile from older
//              location to new location and delete the old system
//              profile
//
//  Parameters:
//
//  Return:     TRUE if successful
//              FALSE if an error occurs. Call GetLastError()
//
//  Comments:   This should only be called by GUI mode setup!
//
//  History:    Date        Author     Comment
//              03/13/01    santanuc   Created
//
//*************************************************************

BOOL WINAPI CopySystemProfile(BOOL bCleanInstall)
{
    HANDLE  hToken = NULL;
    LPTSTR  SidString = NULL, lpEnd;
    TCHAR   szLocalProfileKey[MAX_PATH], szBuffer[MAX_PATH];
    TCHAR   szSrc[MAX_PATH], szDest[MAX_PATH];
    LONG    lResult;
    HKEY    hKey = NULL, hKeyShellFolders;
    DWORD   dwFlags, dwInternalFlags, dwRefCount;
    DWORD   dwDisp, dwSize, dwType, i;
    BOOL    bCopySystemProfile = TRUE, bCopyFromDefault = TRUE;
    PSID    pSystemSid = NULL;
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Set the Profile information for system account i.e sid s-1-5-18
    //

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_IMPERSONATE |
                          TOKEN_QUERY | TOKEN_DUPLICATE, &hToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Fail to open system token. Error %d"), dwErr));
        goto Exit;
    }

    //
    // Get the Sid string
    //

    SidString = GetSidString(hToken);
    if (!SidString) {
        dwErr = ERROR_ACCESS_DENIED;
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to get sid string for system account")));
        goto Exit;
    }

    pSystemSid = GetUserSid(hToken);
    if (!pSystemSid) {
        dwErr = ERROR_ACCESS_DENIED;
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to get sid for system account")));
        goto Exit;
    }


    //
    // Open the profile mapping
    //

    lstrcpy(szLocalProfileKey, PROFILE_LIST_PATH);
    lpEnd = CheckSlash (szLocalProfileKey);
    lstrcpy(lpEnd, SidString);

    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szLocalProfileKey, 0, 0, 0,
                             KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to open profile mapping key. Error %d"), lResult));
        dwErr = lResult;
        goto Exit;
    }

    //
    // Save the flags
    //

    dwFlags = PI_LITELOAD | PI_HIDEPROFILE;
    lResult = RegSetValueEx (hKey,
                             PROFILE_FLAGS,
                             0,
                             REG_DWORD,
                             (LPBYTE) &dwFlags,
                             sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to save profile flags. Error %d"), lResult));
    }

    //
    // Save the internal flags
    //

    dwInternalFlags = 0;
    lResult = RegSetValueEx (hKey,
                             PROFILE_STATE,
                             0,
                             REG_DWORD,
                             (LPBYTE) &dwInternalFlags,
                             sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to save internal flags. Error %d"), lResult));
    }

    //
    // Save the ref count
    //

    dwRefCount = 1;
    lResult = RegSetValueEx (hKey,
                             PROFILE_REF_COUNT,
                             0,
                             REG_DWORD,
                             (LPBYTE) &dwRefCount,
                             sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to save profile ref count. Error %d"), lResult));
    }

    //
    // Save the sid
    //

    lResult = RegSetValueEx (hKey,
                             TEXT("Sid"),
                             0,
                             REG_BINARY,
                             (LPBYTE) pSystemSid,
                             RtlLengthSid(pSystemSid));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to save profile system sid. Error %d"), lResult));
    }


    //
    // Figure out whether any existing system profile exist or not
    // in upgrade scenario
    //

    lstrcpy(szBuffer, SYSTEM_PROFILE_LOCATION);
    ExpandEnvironmentStrings(szBuffer, szDest, MAX_PATH);

    if (!bCleanInstall) {
        dwSize = ARRAYSIZE(szBuffer) * sizeof(TCHAR);
        lResult = RegQueryValueEx(hKey,
                                  PROFILE_IMAGE_VALUE_NAME,
                                  NULL,
                                  &dwType,
                                  (LPBYTE) szBuffer,
                                  &dwSize);
        if (ERROR_SUCCESS == lResult) {
            if (lstrcmp(szBuffer, SYSTEM_PROFILE_LOCATION) == 0) {
                bCopySystemProfile = FALSE;
            }
            else {
                ExpandEnvironmentStrings(szBuffer, szSrc, MAX_PATH);
                bCopyFromDefault = FALSE;
            }
        }
    }

    if (bCopySystemProfile) {

        if (!CreateSecureDirectory(NULL, szDest, pSystemSid, FALSE)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Fail to create SystemProfile dir. Error %d"), dwErr));
            goto Exit;
        }


        if (bCopyFromDefault) {
            dwSize = ARRAYSIZE(szSrc);
            if (!GetDefaultUserProfileDirectoryEx(szSrc, &dwSize, TRUE)) {
                dwErr = GetLastError();
                DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to get default user profile. Error %d"), dwErr));
                goto Exit;
            }
        }

        //
        // Copy the existing or Default user profile in System profile location
        //

        if (!CopyProfileDirectoryEx(szSrc, szDest, CPD_IGNOREHIVE | CPD_FORCECOPY | CPD_IGNORECOPYERRORS,
                                    NULL, NULL)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to copy system profile. Error %d"), dwErr));
            goto Exit;
        }

        if (!bCopyFromDefault) {
            Delnode(szSrc);
        }
    }

    SetAclForSystemProfile(pSystemSid, szDest);

    //
    // Save local profile path
    //

    lstrcpy(szBuffer, SYSTEM_PROFILE_LOCATION);
    lResult = RegSetValueEx (hKey,
                             PROFILE_IMAGE_VALUE_NAME,
                             0,
                             REG_EXPAND_SZ,
                             (LPBYTE) szBuffer,
                             ((lstrlen(szBuffer) + 1) * sizeof(TCHAR)));

    if (lResult != ERROR_SUCCESS) {
        dwErr = lResult;
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to save profile image path with error %d"), lResult));
        goto Exit;
    }

    //
    // Set the Shell Folder paths in the registry for system account
    //

    lstrcpy (szBuffer, TEXT(".Default"));
    lpEnd = CheckSlash (szBuffer);
    lstrcpy(lpEnd, SHELL_FOLDERS);

    lpEnd = CheckSlash (szDest);

    if (RegCreateKeyEx (HKEY_USERS, szBuffer,
                        0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKeyShellFolders,
                        &dwDisp) == ERROR_SUCCESS) {

        for (i=0; i < g_dwNumShellFolders; i++) {

            if (c_ShellFolders[i].bAddCSIDL) {
                lstrcpy (lpEnd, c_ShellFolders[i].szFolderLocation);

                RegSetValueEx (hKeyShellFolders, c_ShellFolders[i].lpFolderName,
                             0, REG_SZ, (LPBYTE) szDest,
                             ((lstrlen(szDest) + 1) * sizeof(TCHAR)));
            }
        }

        RegCloseKey (hKeyShellFolders);
    }

Exit:

    if (hToken) {
        CloseHandle(hToken);
    }

    if (SidString) {
        DeleteSidString(SidString);
    }

    if (pSystemSid) {
        DeleteUserSid(pSystemSid);
    }

    if (hKey) {
        RegCloseKey (hKey);
    }

    SetLastError(dwErr);

    return(dwErr == ERROR_SUCCESS ? TRUE : FALSE);
}



//*************************************************************************
//
// SetAclForSystemProfile()
//
// Routine Description :
//          This function secures dir/files of system profile i.e.
//          %windir%\system32\config\systemprofile
//
// Arguments :
//          pSidSystem            - System sid
//          szExpandedProfilePath - Expanded system profile location
//
// Return Value :
//          None.
//
// History:    Date        Author     Comment
//             04/06/01    santanuc   Created
//
//*************************************************************************

void SetAclForSystemProfile(PSID pSidSystem, LPTSTR szExpandedProfilePath)
{
    SECURITY_DESCRIPTOR DirSd, FileSd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pDirAcl = NULL, pFileAcl = NULL;
    PSID  pSidAdmin = NULL;
    DWORD cbAcl, aceIndex;


    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &pSidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to initialize admin sid.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Allocate space for the Dir object ACL
    //

    cbAcl = (2 * GetLengthSid (pSidSystem)) +
            (2 * GetLengthSid (pSidAdmin))  +
            sizeof(ACL) +
            (4 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pDirAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pDirAcl) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to allocate memory for acl.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!InitializeAcl(pDirAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Allocate space for File object ACL
    //

    cbAcl = (GetLengthSid (pSidSystem)) +
            (GetLengthSid (pSidAdmin))  +
            sizeof(ACL) +
            (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pFileAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pFileAcl) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to allocate memory for acl.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!InitializeAcl(pFileAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Add Aces.  Non-inheritable ACEs first
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pDirAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidSystem)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to add system ace.  Error = %d"), GetLastError()));
        goto Exit;
    }
    if (!AddAccessAllowedAce(pFileAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidSystem)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to add system ace.  Error = %d"), GetLastError()));
        goto Exit;
    }

    aceIndex++;
    if (!AddAccessAllowedAce(pDirAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to add builtin admin ace.  Error = %d"), GetLastError()));
        goto Exit;
    }
    if (!AddAccessAllowedAce(pFileAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to add builtin admin ace.  Error = %d"), GetLastError()));
        goto Exit;
    }

    //
    // Now the Inheritable Aces.
    //

    aceIndex++;
    if (!AddAccessAllowedAceEx(pDirAcl, ACL_REVISION, OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE, GENERIC_ALL, pSidSystem)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to add system ace.  Error = %d"), GetLastError()));
        goto Exit;
    }

    aceIndex++;
    if (!AddAccessAllowedAceEx(pDirAcl, ACL_REVISION, OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE, GENERIC_ALL, pSidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to add builtin admin ace.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&DirSd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&DirSd, TRUE, pDirAcl, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!InitializeSecurityDescriptor(&FileSd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&FileSd, TRUE, pFileAcl, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }

    //
    // Pass the profile path to SecureProfile for securing
    // the profile dir and nested subdirs and files.
    //

    if (!SecureNestedDir (szExpandedProfilePath, &DirSd, &FileSd)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to secure %s Profile directory"), szExpandedProfilePath));
    }

Exit:

    if (pDirAcl) {
        GlobalFree (pDirAcl);
        pDirAcl = NULL;
    }

    if (pFileAcl) {
        GlobalFree (pFileAcl);
        pFileAcl = NULL;
    }

    if (pSidAdmin) {
        FreeSid(pSidAdmin);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\profile\migrate.c ===
//*************************************************************
//
//  User Profile migration routines
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//*************************************************************

#include "uenv.h"

UINT CountItems (LPTSTR lpDirectory);

BOOL SearchAndReplaceIEHistory(LPTSTR szIEHistKeyRoot, LPTSTR szHistOld, LPTSTR szHistNew);


//*************************************************************
//
//  DetermineLocalSettingsLocation()
//
//  Purpose:    Determines where to put the local settings
//
//  Parameters: none
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
// Look at all the shell folders and see which of them are expected to go to
// local settings on nt5. Some of them might already be moved to random
// locations based on the localisations. We should figure out where it is
// pointing to by looking at these locations and make a call
//*************************************************************


BOOL DetermineLocalSettingsLocation(LPTSTR szLocalSettings)
{
    TCHAR  szPath[MAX_PATH];
    LPTSTR lpEnd, lpBgn;
    HKEY hKey, hKeyRoot;
    DWORD dwDisp, dwSize, dwType, i;

    if (RegOpenCurrentUser(KEY_READ | KEY_WRITE, &hKeyRoot) == ERROR_SUCCESS) {

        if (RegOpenKeyEx(hKeyRoot, USER_SHELL_FOLDERS,
                            0, KEY_READ, &hKey) == ERROR_SUCCESS) {


            for (i=0; i < g_dwNumShellFolders; i++) {
                if (c_ShellFolders[i].bNewNT5 && c_ShellFolders[i].bLocalSettings) {

                    dwSize = sizeof(szPath);

                    if (RegQueryValueEx(hKey, c_ShellFolders[i].lpFolderName,
                                        0, &dwType, (LPBYTE)szPath, &dwSize) == ERROR_SUCCESS) {

                        if (lstrlen(szPath) > lstrlen(TEXT("%userprofile%"))) {

                            DebugMsg((DM_VERBOSE, TEXT("DetermineLocalSettingsLocation: Considering shell folder %s"), szPath));

                            //
                            // Move the pointer upto the next slash
                            //

                            lpBgn = szPath + lstrlen(TEXT("%userprofile%"))+1;
                            lpEnd = lpBgn;

                            for (;(*lpEnd != TEXT('\0'));lpEnd++) {

                                //
                                // we have found a shellfolder of the form %userprofile%\subdir\xxx
                                // assume this subdir as the localsettings path
                                //

                                if (( (*lpEnd) == TEXT('\\') ) && ( (*(lpEnd+1)) != TEXT('\0')) )
                                    break;
                            }


                            if ((*lpEnd == TEXT('\\')) && (*(lpEnd+1) != TEXT('\0'))) {
                                *lpEnd = TEXT('\0');
                                lstrcpy(szLocalSettings, lpBgn);

                                DebugMsg((DM_VERBOSE, TEXT("DetermineLocalSettingsLocation: Assuming %s to be the local settings directory"), lpBgn));
                                RegCloseKey(hKey);
                                RegCloseKey(hKeyRoot);
                                return TRUE;
                            }

                        }
                    }
                }
            }

            RegCloseKey(hKey);
        }

        RegCloseKey(hKeyRoot);
    }

    //
    // otherwise load it from the rc file
    //

    LoadString (g_hDllInstance, IDS_SH_LOCALSETTINGS, szLocalSettings, MAX_FOLDER_SIZE);
    DebugMsg((DM_VERBOSE, TEXT("DetermineLocalSettingsLocation: No Local Settings was found, using %s"), szLocalSettings));

    return TRUE;
}


//*************************************************************
//
//  MigrateNT4ToNT5()
//
//  Purpose:    Migrates a user profile from NT4 to NT5
//
//  Parameters: none
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL WINAPI MigrateNT4ToNT5 (void)
{
    TCHAR szTemp[MAX_PATH];
    TCHAR szTemp2[MAX_PATH];
    TCHAR szTemp3[MAX_PATH];
    TCHAR szLocalSettings[MAX_PATH];
    LPTSTR lpEnd, lpEnd1, lpBgn=NULL;
    HKEY hKey = NULL, hKeyRoot = NULL;
    DWORD dwDisp, dwSize, dwType, i;
    BOOL bSetTemp = TRUE;
    BOOL bCleanUpTemp = FALSE;
    WIN32_FILE_ATTRIBUTE_DATA fad;
    const LPTSTR szUserProfile = TEXT("%USERPROFILE%\\");
    DWORD dwUserProfile = lstrlen(szUserProfile);
    DWORD dwString = 0;
    int StringLen;

    //
    // Get the root registry key handle
    //

    if (RegOpenCurrentUser(KEY_READ | KEY_WRITE, &hKeyRoot) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("MigrateNT4ToNT5: Failed to get root registry key with %d"),
                 GetLastError()));
    }


    //
    // Convert Personal to My Documents
    //
    // We have to be careful with this directory.  We'll rename
    // Personal to My Documents only if the Personal directory
    // is empty.  After this, we'll fix up the registry special folder
    // location only if it is still pointing at the default Personal location.
    //

    lstrcpy (szTemp, szUserProfile);

    if ( LoadString (g_hDllInstance, IDS_SH_PERSONAL2, szTemp2, ARRAYSIZE(szTemp2)) )
    {
        lstrcpyn (szTemp + dwUserProfile, szTemp2, ARRAYSIZE(szTemp) - dwUserProfile);

        ExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2));


        //
        // Check if the personal directory exists
        //

        if (GetFileAttributesEx (szTemp2, GetFileExInfoStandard, &fad)) {

            //
            // Check if the personal directory is empty
            //

            if (!CountItems (szTemp2)) {

                //
                // The directory is empty, so rename it to My Documents
                //

                LoadString (g_hDllInstance, IDS_SH_PERSONAL, szTemp3, ARRAYSIZE(szTemp3));
                lstrcpy (szTemp, szUserProfile);
                lstrcpyn (szTemp + dwUserProfile, szTemp3, ARRAYSIZE(szTemp) - dwUserProfile);
                ExpandEnvironmentStrings (szTemp, szTemp3, ARRAYSIZE(szTemp3));

                if (MoveFileEx(szTemp2, szTemp3, 0)) {

                    //
                    // Now we need to fix up the registry value if it is still set
                    // to the default of %USERPROFILE%\Personal
                    //

                    if (RegOpenKeyEx (hKeyRoot, USER_SHELL_FOLDERS,
                                  0, KEY_READ | KEY_WRITE, &hKey) == ERROR_SUCCESS) {

                        dwSize = sizeof(szTemp3);
                        szTemp3[0] = TEXT('\0');
                        if (RegQueryValueEx (hKey, TEXT("Personal"), NULL, &dwType,
                                         (LPBYTE) szTemp3, &dwSize) == ERROR_SUCCESS) {

                            LoadString (g_hDllInstance, IDS_SH_PERSONAL2, szTemp2, ARRAYSIZE(szTemp2));
                            lstrcpy (szTemp, szUserProfile);
                            lstrcpyn (szTemp + dwUserProfile, szTemp2, ARRAYSIZE(szTemp) - dwUserProfile);

                            if (lstrcmpi(szTemp, szTemp3) == 0) {

                                LoadString (g_hDllInstance, IDS_SH_PERSONAL, szTemp3, ARRAYSIZE(szTemp3));
                                lstrcpy (szTemp, szUserProfile);
                                lstrcpyn (szTemp + dwUserProfile, szTemp3, ARRAYSIZE(szTemp) - dwUserProfile);

                                RegSetValueEx (hKey, TEXT("Personal"), 0, REG_EXPAND_SZ,
                                            (LPBYTE) szTemp, (lstrlen(szTemp) + 1) * sizeof(TCHAR));


                                //
                                // We need to reinitialize the global variables now because
                                // the path to the My Documents and My Pictures folder has changed.
                                //

                                InitializeGlobals(g_hDllInstance);
                            }
                        }

                        RegCloseKey (hKey);
                        hKey = NULL;
                    }
                }
            }
        }
    }


    //
    // Get the user profile directory
    //

    dwString = GetEnvironmentVariable (TEXT("USERPROFILE"), szTemp, ARRAYSIZE (szTemp));

    DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Upgrading <%s> from NT4 to NT5"),
             szTemp));


    //
    // Hide ntuser.dat and ntuser.dat.log
    //

    if(dwString < ARRAYSIZE(szTemp) - 1) {
        lpEnd = CheckSlash (szTemp);
        lstrcpyn (lpEnd, TEXT("ntuser.dat"), (int)(ARRAYSIZE (szTemp) + szTemp - lpEnd));
    }
    else {
        goto Exit;
    }
    SetFileAttributes (szTemp, FILE_ATTRIBUTE_HIDDEN);

    lstrcpyn (lpEnd, TEXT("ntuser.dat.log"), (int)(ARRAYSIZE (szTemp) + szTemp - lpEnd));
    SetFileAttributes (szTemp, FILE_ATTRIBUTE_HIDDEN);


    DetermineLocalSettingsLocation(szLocalSettings);


    //
    // Check if Temporary Internet Files exists in the root of the
    // user's profile.  If so, move it to the new location
    //
    // migrate these stuff before we nuke the old User_shell_folders
    //

    if (RegOpenKeyEx(hKeyRoot, USER_SHELL_FOLDERS,
                        0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(szTemp);

        if (RegQueryValueEx(hKey, TEXT("Cache"), 0, &dwType, (LPBYTE)szTemp, &dwSize) != ERROR_SUCCESS) {

            //
            // if this value is not there go by the default location from the
            // resources
            //

            LoadString (g_hDllInstance, IDS_TEMPINTERNETFILES, szTemp2, ARRAYSIZE(szTemp2));

            lstrcpy (szTemp, szUserProfile);
            lstrcpyn (szTemp + dwUserProfile, szTemp2, ARRAYSIZE (szTemp) - dwUserProfile);
        }


        ExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2));

        if (GetFileAttributesEx (szTemp2, GetFileExInfoStandard, &fad)) {

            LoadString (g_hDllInstance, IDS_SH_CACHE, szTemp3, ARRAYSIZE(szTemp3));
            lstrcpy (szTemp, szUserProfile);

            //
            // append the newly found localsettings
            //

            lstrcpyn (szTemp + dwUserProfile, szLocalSettings, ARRAYSIZE(szTemp) - dwUserProfile);
            if(lstrlen(szTemp) < ARRAYSIZE(szTemp) - 1) {
                lpEnd = CheckSlash(szTemp);
                lstrcpyn (lpEnd, szTemp3, (int)(ARRAYSIZE (szTemp) + szTemp - lpEnd));
            }
            else {
                goto Exit;
            }
            ExpandEnvironmentStrings (szTemp, szTemp3, ARRAYSIZE(szTemp3));


            DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: New temp int files folder (expand path) %s"), szTemp3));
            DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Old temp int files folder (expand path) %s"), szTemp2));

            if (lstrcmpi(szTemp2, szTemp3) != 0) {
                if (CopyProfileDirectory (szTemp2, szTemp3, CPD_IGNOREHIVE)) {
                    Delnode (szTemp2);
                }
            }
        }


        //
        // Check if History exists in the root of the user's profile.
        // If so, move it to the new location
        //

        dwSize = sizeof(szTemp);

        if (RegQueryValueEx(hKey, TEXT("History"), 0, &dwType, (LPBYTE)szTemp, &dwSize) != ERROR_SUCCESS) {

            //
            // if this value is not there go by the default location from the
            // resources
            //

            LoadString (g_hDllInstance, IDS_HISTORY, szTemp2, ARRAYSIZE(szTemp2));

            lstrcpy (szTemp, szUserProfile);
            lstrcpyn (szTemp + dwUserProfile, szTemp2, ARRAYSIZE (szTemp) - dwUserProfile);
        }


        ExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2));

        if (GetFileAttributesEx (szTemp2, GetFileExInfoStandard, &fad)) {

            LoadString (g_hDllInstance, IDS_SH_HISTORY, szTemp3, ARRAYSIZE(szTemp3));
            lstrcpy (szTemp, szUserProfile);

            //
            // append the newly found localsettings
            //

            lstrcpyn (szTemp + dwUserProfile, szLocalSettings, ARRAYSIZE(szTemp) - dwUserProfile);
            if(lstrlen(szTemp) < ARRAYSIZE(szTemp) - 1) {
                lpEnd = CheckSlash(szTemp);
            }
            else {
                goto Exit;
            }


            lstrcpyn (lpEnd, szTemp3, (int)(ARRAYSIZE (szTemp) + szTemp - lpEnd));
            ExpandEnvironmentStrings (szTemp, szTemp3, ARRAYSIZE(szTemp3));

            DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: New histroy folder (expand path) %s"), szTemp3));
            DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Old histroy folder (expand path) %s"), szTemp2));


            if (lstrcmpi(szTemp2, szTemp3) != 0) {
                if (CopyProfileDirectory (szTemp2, szTemp3, CPD_IGNOREHIVE)) {
                    Delnode (szTemp2);
                    SearchAndReplaceIEHistory(IE4_CACHE_KEY, szTemp2, szTemp3);
                    SearchAndReplaceIEHistory(IE5_CACHE_KEY, szTemp2, szTemp3);
                }
            }
        }

        RegCloseKey(hKey);
        hKey = NULL;
    }


    //
    // Update the local settings key with the new value
    //

    lstrcpy (szTemp, szUserProfile);
    if(lstrlen(szTemp) < ARRAYSIZE(szTemp) - 1) {
        lpEnd = CheckSlash (szTemp);
    }
    else {
        goto Exit;
    }

    if (RegCreateKeyEx (hKeyRoot, USER_SHELL_FOLDERS,
                        0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwDisp) == ERROR_SUCCESS) {

        lstrcpyn(lpEnd, szLocalSettings, (int)(ARRAYSIZE(szTemp) + szTemp - lpEnd));

        RegSetValueEx (hKey, TEXT("Local Settings"),
                     0, REG_EXPAND_SZ, (LPBYTE) szTemp,
                     ((lstrlen(szTemp) + 1) * sizeof(TCHAR)));

        RegCloseKey (hKey);
        hKey = NULL;
    }

    DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Update the local settings folder with %s"), szTemp));


    //
    // Globals needs to reinitialised because LocalSettings might be different from
    // the one specified in the rc file
    //

    InitializeGlobals(g_hDllInstance);


    //
    // Get the user profile directory
    //

    dwString = GetEnvironmentVariable (TEXT("USERPROFILE"), szTemp, ARRAYSIZE (szTemp));

    DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Upgrading <%s> from NT4 to NT5"),
             szTemp));

    if(dwString < ARRAYSIZE(szTemp) - 1) {
        lpEnd = CheckSlash (szTemp);
    }
    else {
        goto Exit;
    }


    //
    // Create the new special folders
    //

    for (i=0; i < g_dwNumShellFolders; i++) {

        if (c_ShellFolders[i].bNewNT5) {

            lstrcpyn (lpEnd, c_ShellFolders[i].szFolderLocation, (int)(ARRAYSIZE(szTemp) + szTemp - lpEnd));

            if (!CreateNestedDirectory(szTemp, NULL)) {
                DebugMsg((DM_WARNING, TEXT("MigrateNT4ToNT5: Failed to create the destination directory <%s>.  Error = %d"),
                         szTemp, GetLastError()));
            }

            if (c_ShellFolders[i].bHidden) {
                SetFileAttributes(szTemp, FILE_ATTRIBUTE_HIDDEN);
            } else {
                SetFileAttributes(szTemp, FILE_ATTRIBUTE_NORMAL);
            }
        }
    }


    //
    // Set the new special folders in the User Shell Folder registry key
    //

    lstrcpy (szTemp, szUserProfile);
    if(lstrlen(szTemp) < ARRAYSIZE(szTemp) - 1) {
        lpEnd = CheckSlash (szTemp);
    }
    else {
        goto Exit;
    }

    if (RegCreateKeyEx (hKeyRoot, USER_SHELL_FOLDERS,
                        0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwDisp) == ERROR_SUCCESS) {

        for (i=0; i < g_dwNumShellFolders; i++) {

            if (c_ShellFolders[i].bNewNT5 && c_ShellFolders[i].bAddCSIDL) {
                lstrcpyn (lpEnd, c_ShellFolders[i].szFolderLocation, (int)(ARRAYSIZE(szTemp) + szTemp - lpEnd));

                RegSetValueEx (hKey, c_ShellFolders[i].lpFolderName,
                             0, REG_EXPAND_SZ, (LPBYTE) szTemp,
                             ((lstrlen(szTemp) + 1) * sizeof(TCHAR)));
            }
        }

        RegCloseKey (hKey);
        hKey = NULL;
    }



    //
    // Query the user's environment for a TEMP environment variable.
    //

    if (RegCreateKeyEx (hKeyRoot, TEXT("Environment"), 0,
                        NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwDisp) == ERROR_SUCCESS) {


        szTemp2[0] = TEXT('\0');
        dwSize = sizeof(szTemp2);
        RegQueryValueEx (hKey, TEXT("TEMP"), NULL, &dwType,
                         (LPBYTE) szTemp2, &dwSize);


        //
        // Decide if we should set the temp and tmp environment variables.
        // We need to be careful to not blast someone's custom temp variable
        // if it already exists, but at the same time it's ok to remap this if
        // temp is still set to the NT4 default of %SystemDrive%\TEMP.
        //

        if (szTemp2[0] != TEXT('\0')) {
            if (lstrcmpi (szTemp2, TEXT("%SystemDrive%\\TEMP")) != 0) {
                bSetTemp = FALSE;
            }

            if (lstrcmpi (szTemp2, TEXT("%USERPROFILE%\\TEMP")) == 0) {
                bSetTemp = TRUE;
                bCleanUpTemp = TRUE;
            }
        }


        if (bSetTemp) {
            LoadString (g_hDllInstance, IDS_SH_TEMP, szTemp2, ARRAYSIZE(szTemp2));
            lstrcpyn(lpEnd, szLocalSettings, (int)(ARRAYSIZE(szTemp) + szTemp - lpEnd));
            if(lstrlen(szTemp) < ARRAYSIZE(szTemp) - 1) {
                lpEnd = CheckSlash(lpEnd);
                lstrcpyn (lpEnd, szTemp2, (int)(ARRAYSIZE(szTemp) + szTemp - lpEnd));
            }
            else {
                goto Exit;
            }

            DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Setting the Temp directory to <%s>"), szTemp));


            RegSetValueEx (hKey, TEXT("TEMP"), 0, REG_EXPAND_SZ,
                           (LPBYTE) szTemp, (lstrlen (szTemp) + 1) * sizeof(TCHAR));

            RegSetValueEx (hKey, TEXT("TMP"), 0, REG_EXPAND_SZ,
                           (LPBYTE) szTemp, (lstrlen (szTemp) + 1) * sizeof(TCHAR));
        }

        if (bCleanUpTemp) {
            ExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2));
            ExpandEnvironmentStrings (TEXT("%USERPROFILE%\\TEMP"), szTemp, ARRAYSIZE(szTemp));

            if (CopyProfileDirectory (szTemp, szTemp2, CPD_IGNOREHIVE)) {
                Delnode (szTemp);
            }
        }

        RegCloseKey (hKey);
        hKey = NULL;
    }


    //
    // Migrate the Template Directory if it exists. Copy it from %systemroot%\shellnew
    // to Templates directory userprofile..
    //

    if ((LoadString (g_hDllInstance, IDS_SH_TEMPLATES2, szTemp2, ARRAYSIZE(szTemp2))) &&
            (ExpandEnvironmentStrings (szTemp2, szTemp3, ARRAYSIZE(szTemp3))) &&
            (LoadString (g_hDllInstance, IDS_SH_TEMPLATES, szTemp2, ARRAYSIZE(szTemp2)))) {

        //
        // if all of the above succeeded
        // szTemp3 will have the full path for the old templates dir..
        //

        lstrcpy (szTemp, szUserProfile);
        lstrcpyn (szTemp + dwUserProfile, szTemp2, ARRAYSIZE(szTemp) - dwUserProfile);

        ExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2));

        if (GetFileAttributesEx (szTemp3, GetFileExInfoStandard, &fad)) {
            DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Copying Template files from %s to %s"), szTemp3, szTemp2));
            CopyProfileDirectory(szTemp3, szTemp2, CPD_IGNORECOPYERRORS | CPD_IGNOREHIVE);
        }
    }


    //
    // Set the user preference exclusion list.  This will
    // prevent the Local Settings folder from roaming
    //

    if (LoadString (g_hDllInstance, IDS_EXCLUSIONLIST,
                    szTemp, ARRAYSIZE(szTemp))) {

        if (RegCreateKeyEx (hKeyRoot, WINLOGON_KEY,
                            0, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE, NULL, &hKey,
                            &dwDisp) == ERROR_SUCCESS) {


            dwSize = sizeof(szTemp);

            RegQueryValueEx (hKey, TEXT("ExcludeProfileDirs"),
                                 NULL, &dwType, (LPBYTE) szTemp,
                                 &dwSize);

            //
            // Read in the value of the local settings
            //

            LoadString (g_hDllInstance, IDS_SH_LOCALSETTINGS,
                    szTemp2, ARRAYSIZE(szTemp2));


            //
            // Loop through the list
            //

            lpBgn = lpEnd = szTemp;
            *szTemp3 = TEXT('\0');

            while (*lpEnd) {

                //
                // Look for the semicolon separator
                //

                while (*lpEnd && ((*lpEnd) != TEXT(';'))) {
                    lpEnd++;
                }


                //
                // Remove any leading spaces
                //

                while (*lpBgn == TEXT(' ')) {
                    lpBgn++;
                }


                //
                // if it has come here we are going to attach something
                // to the end of szTmp3
                //

                StringLen = (int)(lpEnd - lpBgn);

                if (*szTemp3)
                    lstrcpyn(szTemp3 + lstrlen(szTemp3), TEXT(";"), ARRAYSIZE(szTemp3) - lstrlen(szTemp3));

                if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                   lpBgn, StringLen, szTemp2, lstrlen(szTemp2)) != CSTR_EQUAL) {

                    int sz = MIN((int)(ARRAYSIZE(szTemp3) - lstrlen(szTemp3)), (StringLen+1));

                    lstrcpyn(szTemp3+lstrlen(szTemp3), lpBgn, sz);
                }
                else {
                    lstrcpyn(szTemp3 + lstrlen(szTemp3), szLocalSettings, ARRAYSIZE(szTemp3) - lstrlen(szTemp3));
                }


                //
                // If we are at the end of the exclusion list, we're done
                //

                if (!(*lpEnd)) {
                    break;
                }


                //
                // Prep for the next entry
                //

                lpEnd++;
                lpBgn = lpEnd;
            }


            RegSetValueEx (hKey, TEXT("ExcludeProfileDirs"),
                           0, REG_SZ, (LPBYTE) szTemp3,
                           ((lstrlen(szTemp3) + 1) * sizeof(TCHAR)));

            DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Set the exclusionlist value to default")));

            RegCloseKey (hKey);
            hKey = NULL;
        }
    }


    //
    // Make sure the hidden bit is set correctly for each special folder
    //

    if (RegOpenKeyEx (hKeyRoot, USER_SHELL_FOLDERS,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        for (i=0; i < g_dwNumShellFolders; i++) {

            dwSize = sizeof(szTemp);
            szTemp[0] = TEXT('\0');

            if (RegQueryValueEx (hKey, c_ShellFolders[i].lpFolderName,
                                 NULL, &dwType, (LPBYTE) szTemp,
                                  &dwSize) == ERROR_SUCCESS) {

                ExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2));

                if (c_ShellFolders[i].bHidden) {
                    SetFileAttributes(szTemp2, FILE_ATTRIBUTE_HIDDEN);
                } else {
                    SetFileAttributes(szTemp2, FILE_ATTRIBUTE_NORMAL);
                }
            }
        }

        RegCloseKey (hKey);
        hKey = NULL;
    }


Exit:


    if(hKey != NULL) {
        RegCloseKey(hKey);
    }


    if (hKeyRoot != NULL) {
        RegCloseKey (hKeyRoot);
    }


    DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Finished.")));

    return TRUE;
}

//*************************************************************
//
//  ResetUserSpecialFolderPaths()
//
//  Purpose:    Sets all of the user special folder paths back
//              to their defaults
//
//  Parameters: none
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL WINAPI ResetUserSpecialFolderPaths(void)
{
    TCHAR szDirectory [MAX_PATH];
    HKEY hKey, hKeyRoot;
    DWORD dwDisp, i;
    LPTSTR lpEnd;


    //
    // Set the User Shell Folder paths in the registry
    //

    lstrcpy (szDirectory, TEXT("%USERPROFILE%"));
    lpEnd = CheckSlash (szDirectory);

    if (RegOpenCurrentUser(KEY_WRITE, &hKeyRoot) == ERROR_SUCCESS) {

        if (RegCreateKeyEx (hKeyRoot, USER_SHELL_FOLDERS,
                            0, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE, NULL, &hKey,
                            &dwDisp) == ERROR_SUCCESS) {

            for (i=0; i < g_dwNumShellFolders; i++) {

                if (c_ShellFolders[i].bAddCSIDL) {
                    lstrcpy (lpEnd, c_ShellFolders[i].szFolderLocation);

                    RegSetValueEx (hKey, c_ShellFolders[i].lpFolderName,
                                 0, REG_EXPAND_SZ, (LPBYTE) szDirectory,
                                 ((lstrlen(szDirectory) + 1) * sizeof(TCHAR)));
                }
            }

            RegCloseKey (hKey);
        }
        RegCloseKey (hKeyRoot);
    }

    return TRUE;
}

//*************************************************************
//
//  CountItems()
//
//  Purpose:    Counts the number of files and subdirectories
//              in the given subdirectory
//
//  Parameters: lpDirectory - parent directory
//
//  Return:     Item count
//
//*************************************************************

UINT CountItems (LPTSTR lpDirectory)
{
    TCHAR szDirectory[MAX_PATH];
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    UINT uiCount = 0;


    //
    // Search through the directory
    //

    lstrcpy (szDirectory, lpDirectory);
    lstrcat (szDirectory, TEXT("\\*.*"));

    hFile = FindFirstFile(szDirectory, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {
        return uiCount;
    }


    do {

        //
        // Check for "." and ".."
        //

        if (!lstrcmpi(fd.cFileName, TEXT("."))) {
            continue;
        }

        if (!lstrcmpi(fd.cFileName, TEXT(".."))) {
            continue;
        }

        uiCount++;

        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, &fd));


    FindClose(hFile);

    return uiCount;
}


//*************************************************************
//
//  SearchAndReplaceIEHistory()
//
//  Purpose:    Searches and Replaces the registry kesy pointing to
//              the old location in IE Cahe to point to New Location
//
//  Parameters:
//          szIEHistKeyRoot     - Root of the history key
//          szHistOld           - Old History Key
//          szHistNew           - New Location of History Key
//
//  Return:     TRUE if success, else False
//
//  Created:
//
// Notes:
//      Change the "HKCU\S\M\W\CV\Internet Settings\Cache\Extensible Cache\"MSHist***\CachePath" and
//      Change the "HKCU\S\M\W\CV\Internet Settings\5.0\Cache\Extensible Cache\MSHis***\CachePath"
//      value to the new place
//*************************************************************

BOOL SearchAndReplaceIEHistory(LPTSTR szIEHistKeyRoot, LPTSTR szHistOld, LPTSTR szHistNew)
{
    DWORD dwIndex = 0, dwMsHistLen, dwLen;
    TCHAR szSubKey[MAX_PATH+1], szSubKey1[MAX_PATH+1];
    TCHAR szCachePath[MAX_PATH];
    TCHAR szCachePath1[MAX_PATH];
    FILETIME ftWrite;
    HKEY hIECacheKey, hKey;

    DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Fixing up the IE Registry keys")));

    if (RegOpenKeyEx(HKEY_CURRENT_USER, szIEHistKeyRoot, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {


        DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Enumerating the keys under %s"), szIEHistKeyRoot));

        dwMsHistLen = lstrlen(IE_CACHEKEY_PREFIX);

        dwLen = ARRAYSIZE(szSubKey);

        while (RegEnumKeyEx(hKey, dwIndex, szSubKey, &dwLen, NULL, NULL, NULL, &ftWrite) == ERROR_SUCCESS) {

            DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Testing Key %s"), szSubKey));

            lstrcpy(szSubKey1, szSubKey);
            szSubKey1[dwMsHistLen] = TEXT('\0');

            //
            // if the key name starts with MSHist
            //


            if (lstrcmpi(szSubKey1, IE_CACHEKEY_PREFIX) == 0) {

                if (RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hIECacheKey) == ERROR_SUCCESS) {
                    DWORD dwLen1;

                    //
                    // Get the current value
                    //


                    dwLen1 = sizeof(szCachePath);
                    if (RegQueryValueEx(hIECacheKey, TEXT("CachePath"), 0, NULL, (LPBYTE)szCachePath, &dwLen1) == ERROR_SUCCESS) {

                        //
                        // Replace the szHistOld prefix with szHistNew value
                        //

                        lstrcpy(szCachePath1, szHistNew);

                        lstrcpy(szSubKey1, szCachePath);
                        szSubKey1[lstrlen(szHistOld)] = TEXT('\0');

                        if (lstrcmpi(szSubKey1, szHistOld) == 0) {


                            lstrcat(szCachePath1, szCachePath+lstrlen(szHistOld));

                            RegSetValueEx(hIECacheKey, TEXT("CachePath"), 0, REG_SZ, (LPBYTE)szCachePath1, (lstrlen(szCachePath1)+1)*sizeof(TCHAR));

                            DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Finally,  under %s Replacing %s with %s"), szSubKey, szCachePath, szCachePath1));

                        }
                        else {
                            DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Existing CachePath %s doesn't have %s, skipping.."), szCachePath, szHistOld));
                        }
                    }
                    else {
                        DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Could not open CachePath value")));
                    }

                    RegCloseKey(hIECacheKey);
                }
                else {
                    DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Could not open %s subkey"), szSubKey));
                }
           }
           else {
               DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: %s subkey does not have %s prefix"), szSubKey, IE_CACHEKEY_PREFIX));
           }

           dwIndex++;
           dwLen = ARRAYSIZE(szSubKey);

          DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Getting %d subkey next.."), dwIndex+1));

        }

        //
        // Close if the open succeeded
        //

        RegCloseKey(hKey);
    }
    else {
          DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Failed to open the root of the key %s"), szIEHistKeyRoot));
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\profile\stubs.c ===
//*************************************************************
//
//  Contains the A/W api stubs
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI LoadUserProfileA (HANDLE hToken, LPPROFILEINFOA lpProfileInfoA)
{
     PROFILEINFOW ProfileInfoW;
     BOOL bResult;

    //
    //  Check Parameters
    //

    if (!lpProfileInfoA) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfileA: NULL lpProfileInfo")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (lpProfileInfoA->dwSize != sizeof(PROFILEINFO)) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfileA: lpProfileInfo->dwSize != sizeof(PROFILEINFO)")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


     //
     // Thunk ProfileInfoA to ProfileInfoW
     //

     memset(&ProfileInfoW, 0, sizeof(PROFILEINFOW));
     ProfileInfoW.dwSize = sizeof(PROFILEINFOW);
     ProfileInfoW.dwFlags = lpProfileInfoA->dwFlags;
     ProfileInfoW.lpUserName = ProduceWFromA (lpProfileInfoA->lpUserName);
     ProfileInfoW.lpProfilePath = ProduceWFromA (lpProfileInfoA->lpProfilePath);
     ProfileInfoW.lpDefaultPath = ProduceWFromA (lpProfileInfoA->lpDefaultPath);
     ProfileInfoW.lpServerName = ProduceWFromA (lpProfileInfoA->lpServerName);
     if (ProfileInfoW.dwFlags & PI_APPLYPOLICY) {
         ProfileInfoW.lpPolicyPath = ProduceWFromA (lpProfileInfoA->lpPolicyPath);
     }


     //
     // Now call the real LoadUserProfile function.
     //

     bResult = LoadUserProfileW (hToken, &ProfileInfoW);


     //
     // Free memory allocated above and save the return
     // values.
     //

     FreeProducedString (ProfileInfoW.lpUserName);
     FreeProducedString (ProfileInfoW.lpProfilePath);
     FreeProducedString (ProfileInfoW.lpDefaultPath);
     FreeProducedString (ProfileInfoW.lpServerName);
     if (ProfileInfoW.dwFlags & PI_APPLYPOLICY) {
         FreeProducedString (ProfileInfoW.lpPolicyPath);
     }

     lpProfileInfoA->hProfile = ProfileInfoW.hProfile;

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI LoadUserProfileW (HANDLE hToken, LPPROFILEINFOW lpProfileInfoW)
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI CreateGroupA (LPCSTR lpGroupName, BOOL bCommonGroup)
{
     LPWSTR lpGroupNameW;
     BOOL bResult;

     //
     // Convert the ANSI string to Unicode and call
     // the real function.
     //

     if (!(lpGroupNameW = ProduceWFromA (lpGroupName))) {
        return FALSE;
     }

     bResult = CreateGroupW (lpGroupNameW, bCommonGroup);

     FreeProducedString (lpGroupNameW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI CreateGroupW (LPCWSTR lpGroupName, BOOL bCommonGroup)
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI CreateGroupExA(LPCSTR lpGroupName, BOOL bCommonGroup,
                           LPCSTR lpResourceModuleName, UINT iResourceID)
{
     LPWSTR lpGroupNameW;
     LPWSTR lpResourceModuleNameW;
     BOOL bResult;

     //
     // Convert the ANSI string to Unicode and call
     // the real function.
     //

     if (!(lpGroupNameW = ProduceWFromA (lpGroupName))) {
        return FALSE;
     }
     if (!(lpResourceModuleNameW = ProduceWFromA (lpResourceModuleName))) {
        return FALSE;
     }

     bResult = CreateGroupExW (lpGroupNameW, bCommonGroup,
                               lpResourceModuleNameW, iResourceID);

     FreeProducedString (lpGroupNameW);
     FreeProducedString (lpResourceModuleNameW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI CreateGroupExW(LPCWSTR lpGroupName, BOOL bCommonGroup,
                           LPCWSTR lpResourceModuleName, UINT iResourceID)
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************


#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI DeleteGroupA (LPCSTR lpGroupName, BOOL bCommonGroup)
{
     LPWSTR lpGroupNameW;
     BOOL bResult;

     //
     // Convert the ANSI string to Unicode and call
     // the real function.
     //

     if (!(lpGroupNameW = ProduceWFromA (lpGroupName))) {
        return FALSE;
     }

     bResult = DeleteGroupW (lpGroupNameW, bCommonGroup);

     FreeProducedString (lpGroupNameW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI DeleteGroupW (LPCWSTR lpGroupName, BOOL bCommonGroup)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************


BOOL WINAPI AddItemA (LPCSTR lpGroupName,        BOOL bCommonGroup,
                      LPCSTR lpFileName,         LPCSTR lpCommandLine,
                      LPCSTR lpIconPath,         INT iIconIndex,
                      LPCSTR lpWorkingDirectory, WORD wHotKey,
                      INT    iShowCmd)
{

    return CreateLinkFileA (bCommonGroup ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS,
                            lpGroupName, lpFileName, lpCommandLine,
                            lpIconPath, iIconIndex, lpWorkingDirectory,
                            wHotKey, iShowCmd, NULL);
}

BOOL WINAPI AddItemW (LPCWSTR lpGroupName,        BOOL bCommonGroup,
                      LPCWSTR lpFileName,         LPCWSTR lpCommandLine,
                      LPCWSTR lpIconPath,         int iIconIndex,
                      LPCWSTR lpWorkingDirectory, WORD wHotKey,
                      int     iShowCmd)
{

    return CreateLinkFileW (bCommonGroup ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS,
                            lpGroupName, lpFileName, lpCommandLine,
                            lpIconPath, iIconIndex, lpWorkingDirectory,
                            wHotKey, iShowCmd, NULL);
}


//*************************************************************

BOOL WINAPI DeleteItemA (LPCSTR lpGroupName, BOOL bCommonGroup,
                         LPCSTR lpFileName, BOOL bDeleteGroup)
{

    return DeleteLinkFileA (bCommonGroup ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS,
                            lpGroupName, lpFileName, bDeleteGroup);
}

BOOL WINAPI DeleteItemW (LPCWSTR lpGroupName, BOOL bCommonGroup,
                         LPCWSTR lpFileName, BOOL bDeleteGroup)
{
    return DeleteLinkFileW (bCommonGroup ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS,
                            lpGroupName, lpFileName, bDeleteGroup);
}


//*************************************************************

BOOL WINAPI AddDesktopItemA (BOOL bCommonItem,
                             LPCSTR lpFileName,         LPCSTR lpCommandLine,
                             LPCSTR lpIconPath,         INT iIconIndex,
                             LPCSTR lpWorkingDirectory, WORD wHotKey,
                             INT    iShowCmd)

{

    return CreateLinkFileA (bCommonItem ? CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY,
                            NULL, lpFileName, lpCommandLine,
                            lpIconPath, iIconIndex, lpWorkingDirectory,
                            wHotKey, iShowCmd, NULL);
}

BOOL WINAPI AddDesktopItemW (BOOL bCommonItem,
                             LPCWSTR lpFileName,         LPCWSTR lpCommandLine,
                             LPCWSTR lpIconPath,         int iIconIndex,
                             LPCWSTR lpWorkingDirectory, WORD wHotKey,
                             int     iShowCmd)

{

    return CreateLinkFileW (bCommonItem ? CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY,
                            NULL, lpFileName, lpCommandLine,
                            lpIconPath, iIconIndex, lpWorkingDirectory,
                            wHotKey, iShowCmd, NULL);
}

//*************************************************************

BOOL WINAPI DeleteDesktopItemA (BOOL bCommonItem, LPCSTR lpFileName)
{
    return DeleteLinkFileA (bCommonItem ? CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY,
                            NULL, lpFileName, FALSE);
}


BOOL WINAPI DeleteDesktopItemW (BOOL bCommonItem, LPCWSTR lpFileName)
{
    return DeleteLinkFileW (bCommonItem ? CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY,
                            NULL, lpFileName, FALSE);
}

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI CreateLinkFileA (INT    csidl,              LPCSTR lpSubDirectory,
                             LPCSTR lpFileName,         LPCSTR lpCommandLine,
                             LPCSTR lpIconPath,         INT iIconIndex,
                             LPCSTR lpWorkingDirectory, WORD wHotKey,
                             INT    iShowCmd,           LPCSTR lpDescription)
{
     LPWSTR lpSubDirectoryW, lpFileNameW, lpCommandLineW;
     LPWSTR lpIconPathW, lpWorkingDirectoryW, lpDescriptionW;
     BOOL bResult;

     //
     // Convert the ANSI strings to Unicode and call
     // the real function.
     //

     lpSubDirectoryW = ProduceWFromA(lpSubDirectory);

     if (!(lpFileNameW = ProduceWFromA(lpFileName))) {
        FreeProducedString(lpSubDirectoryW);
        return FALSE;
     }

     if (!(lpCommandLineW = ProduceWFromA(lpCommandLine))) {
        FreeProducedString(lpSubDirectoryW);
        FreeProducedString(lpFileNameW);
        return FALSE;
     }

     lpIconPathW = ProduceWFromA(lpIconPath);

     lpWorkingDirectoryW = ProduceWFromA(lpWorkingDirectory);

     lpDescriptionW = ProduceWFromA(lpDescription);

     bResult = CreateLinkFileW(csidl, lpSubDirectoryW, lpFileNameW,
                               lpCommandLineW, lpIconPathW, iIconIndex,
                               lpWorkingDirectoryW, wHotKey, iShowCmd,
                               lpDescriptionW);


     FreeProducedString(lpSubDirectoryW);
     FreeProducedString(lpFileNameW);
     FreeProducedString(lpCommandLineW);
     FreeProducedString(lpIconPathW);
     FreeProducedString(lpWorkingDirectoryW);
     FreeProducedString(lpDescriptionW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI CreateLinkFileW (INT     csidl,              LPCWSTR lpSubDirectory,
                             LPCWSTR lpFileName,         LPCWSTR lpCommandLine,
                             LPCWSTR lpIconPath,         INT iIconIndex,
                             LPCWSTR lpWorkingDirectory, WORD wHotKey,
                             INT     iShowCmd,           LPCWSTR lpDescription)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI CreateLinkFileExA (INT    csidl,              LPCSTR lpSubDirectory,
                               LPCSTR lpFileName,         LPCSTR lpCommandLine,
                               LPCSTR lpIconPath,         INT iIconIndex,
                               LPCSTR lpWorkingDirectory, WORD wHotKey,
                               INT    iShowCmd,           LPCSTR lpDescription,
                               LPCSTR lpResourceModuleName, UINT iResourceID)
{
     LPWSTR lpSubDirectoryW, lpFileNameW, lpCommandLineW;
     LPWSTR lpIconPathW, lpWorkingDirectoryW, lpDescriptionW;
     LPWSTR lpResourceModuleNameW;
     BOOL bResult;

     //
     // Convert the ANSI strings to Unicode and call
     // the real function.
     //

     lpSubDirectoryW = ProduceWFromA(lpSubDirectory);

     if (!(lpFileNameW = ProduceWFromA(lpFileName))) {
        FreeProducedString(lpSubDirectoryW);
        return FALSE;
     }

     if (!(lpCommandLineW = ProduceWFromA(lpCommandLine))) {
        FreeProducedString(lpSubDirectoryW);
        FreeProducedString(lpFileNameW);
        return FALSE;
     }

     lpIconPathW = ProduceWFromA(lpIconPath);

     lpWorkingDirectoryW = ProduceWFromA(lpWorkingDirectory);

     lpDescriptionW = ProduceWFromA(lpDescription);

     lpResourceModuleNameW = ProduceWFromA(lpResourceModuleName);

     bResult = CreateLinkFileExW(csidl, lpSubDirectoryW, lpFileNameW,
                               lpCommandLineW, lpIconPathW, iIconIndex,
                               lpWorkingDirectoryW, wHotKey, iShowCmd,
                               lpDescriptionW, lpResourceModuleNameW, iResourceID);


     FreeProducedString(lpResourceModuleNameW);
     FreeProducedString(lpSubDirectoryW);
     FreeProducedString(lpFileNameW);
     FreeProducedString(lpCommandLineW);
     FreeProducedString(lpIconPathW);
     FreeProducedString(lpWorkingDirectoryW);
     FreeProducedString(lpDescriptionW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI CreateLinkFileExW (INT     csidl,              LPCWSTR lpSubDirectory,
                               LPCWSTR lpFileName,         LPCWSTR lpCommandLine,
                               LPCWSTR lpIconPath,         INT iIconIndex,
                               LPCWSTR lpWorkingDirectory, WORD wHotKey,
                               INT     iShowCmd,           LPCWSTR lpDescription,
                               LPCSTR lpResourceModuleName, UINT iResourceID)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI DeleteLinkFileA (INT csidl, LPCSTR lpSubDirectory,
                             LPCSTR lpFileName, BOOL bDeleteSubDirectory)
{
     LPWSTR lpSubDirectoryW, lpFileNameW;
     BOOL bResult;

     //
     // Convert the ANSI strings to Unicode and call
     // the real function.
     //

     lpSubDirectoryW = ProduceWFromA(lpSubDirectory);

     if (!(lpFileNameW = ProduceWFromA(lpFileName))) {
        FreeProducedString(lpSubDirectoryW);
        return FALSE;
     }

     bResult = DeleteLinkFileW(csidl, lpSubDirectoryW, lpFileNameW, bDeleteSubDirectory);


     FreeProducedString(lpSubDirectoryW);
     FreeProducedString(lpFileNameW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI DeleteLinkFileW (INT csidl, LPCWSTR lpSubDirectory,
                             LPCWSTR lpFileName, BOOL bDeleteSubDirectory)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI CreateUserProfileA (PSID pSid, LPCSTR lpUserNameA, LPCSTR lpUserHiveA,
                                LPSTR lpProfileDirA, DWORD dwDirSize)
{
     LPWSTR lpUserNameW, lpUserHiveW, lpProfileDirW = NULL;
     BOOL bResult;

     //
     // Convert the ANSI string to Unicode and call
     // the real function.
     //

     if (!(lpUserNameW = ProduceWFromA(lpUserNameA))) {
        return FALSE;
     }

     if (lpProfileDirA) {
         lpProfileDirW = (LPWSTR) LocalAlloc (LPTR, dwDirSize * sizeof(WCHAR));

         if (!lpProfileDirW) {
            FreeProducedString(lpUserNameW);
            return FALSE;
         }
     }

     lpUserHiveW = ProduceWFromA(lpUserHiveA);

     bResult = CreateUserProfileW(pSid, lpUserNameW, lpUserHiveW,
                                  lpProfileDirW, dwDirSize);

     FreeProducedString(lpUserNameW);
     FreeProducedString(lpUserHiveW);

     if (lpProfileDirW) {

        if (bResult) {

            WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                dwDirSize, NULL, NULL);
        }

        LocalFree (lpProfileDirW);
     }

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI CreateUserProfileW (PSID pSid, LPCWSTR lpUserNameW, LPCWSTR lpUserHiveW,
                                LPWSTR lpProfileDirW, DWORD dwDirSize)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI CreateUserProfileExA (PSID pSid, LPCSTR lpUserNameA, LPCSTR lpUserHiveA,
                                  LPSTR lpProfileDirA, DWORD dwDirSize, BOOL bWin9xUpg)
{
     LPWSTR lpUserNameW, lpUserHiveW, lpProfileDirW = NULL;
     BOOL bResult;

     //
     // Convert the ANSI string to Unicode and call
     // the real function.
     //

     if (!(lpUserNameW = ProduceWFromA(lpUserNameA))) {
        return FALSE;
     }

     if (lpProfileDirA) {
         lpProfileDirW = (LPWSTR) LocalAlloc (LPTR, dwDirSize * sizeof(WCHAR));

         if (!lpProfileDirW) {
            FreeProducedString(lpUserNameW);
            return FALSE;
         }
     }

     lpUserHiveW = ProduceWFromA(lpUserHiveA);

     bResult = CreateUserProfileExW(pSid, lpUserNameW, lpUserHiveW,
                                  lpProfileDirW, dwDirSize, bWin9xUpg);

     FreeProducedString(lpUserNameW);
     FreeProducedString(lpUserHiveW);

     if (lpProfileDirW) {

        if (bResult) {

            WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                dwDirSize, NULL, NULL);
        }

        LocalFree (lpProfileDirW);
     }

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI CreateUserProfileExW (PSID pSid, LPCWSTR lpUserNameW, LPCWSTR lpUserHiveW,
                                  LPSTR lpProfileDirW, DWORD dwDirSize, BOOL bWin9xUpg)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************

//
// Stubs for CopyProfileDirectoryA/W
//

BOOL WINAPI CopyProfileDirectoryA (LPCSTR lpSrcDir, LPCSTR lpDstDir, DWORD dwFlags)
{
     return CopyProfileDirectoryExA (lpSrcDir, lpDstDir, dwFlags, NULL, NULL);
}

BOOL WINAPI CopyProfileDirectoryW (LPCWSTR lpSrcDir, LPCWSTR lpDstDir, DWORD dwFlags)
{
    return CopyProfileDirectoryExW (lpSrcDir, lpDstDir, dwFlags, NULL, NULL);
}


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI CopyProfileDirectoryExA (LPCSTR lpSrcDirA, LPCSTR lpDstDirA,
                                     DWORD dwFlags, LPFILETIME ftDelRefTime,
                                     LPCSTR lpExclusionListA)
{
     LPWSTR lpSrcDirW, lpDstDirW, lpExclusionListW = NULL;
     BOOL bResult;

     //
     // Convert the ANSI strings to Unicode and call
     // the real function.
     //

     if (!(lpSrcDirW = ProduceWFromA(lpSrcDirA))) {
        return FALSE;
     }

     if (!(lpDstDirW = ProduceWFromA(lpDstDirA))) {
        FreeProducedString(lpSrcDirW);
        return FALSE;
     }

     if (dwFlags & CPD_USEEXCLUSIONLIST) {
         lpExclusionListW = ProduceWFromA(lpExclusionListA);
     }

     bResult = CopyProfileDirectoryExW(lpSrcDirW, lpDstDirW, dwFlags, ftDelRefTime,
                                       lpExclusionListW);


     FreeProducedString(lpSrcDirW);
     FreeProducedString(lpDstDirW);
     FreeProducedString(lpExclusionListW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI CopyProfileDirectoryExW (LPCWSTR lpSrcDirW, LPCWSTR lpDstDirW,
                                     DWORD dwFlags, LPFILETIME ftDelRefTime,
                                     LPCWSTR lpExclusionListW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI GetProfilesDirectoryA (LPSTR lpProfilesDirA, LPDWORD lpcchSize)
{
     LPWSTR lpProfilesDirW;
     BOOL bResult;
     DWORD cchOrgSize, cchReq;

    if (!lpProfilesDirA) {
        DebugMsg((DM_WARNING, TEXT("GetProfilesDirectoryA : lpProfilesDirA is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!lpcchSize) {
        DebugMsg((DM_WARNING, TEXT("GetProfilesDirectoryA : lpcchSize is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

     //
     // Allocate a buffer to match the ANSI buffer
     //

     if (!(lpProfilesDirW = GlobalAlloc(GPTR, (*lpcchSize) * sizeof(TCHAR)))) {
        return FALSE;
     }

     cchOrgSize = *lpcchSize;  // Store the original size passed to the function
     bResult = GetProfilesDirectoryW(lpProfilesDirW, lpcchSize);


     if (bResult) {
         cchReq = WideCharToMultiByte(CP_ACP, 0, lpProfilesDirW, -1, lpProfilesDirA,
                                      0, NULL, NULL);
         *lpcchSize = cchReq;
         if (cchReq > cchOrgSize) {
             bResult = FALSE;
         }
         else {
             bResult = WideCharToMultiByte(CP_ACP, 0, lpProfilesDirW, -1, lpProfilesDirA,
                                           *lpcchSize, NULL, NULL);
         }
     }


     GlobalFree(lpProfilesDirW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI GetProfilesDirectoryW (LPWSTR lpProfilesDirW, LPDWORD lpcchSize)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI GetDefaultUserProfileDirectoryA (LPSTR lpProfileDirA, LPDWORD lpcchSize)
{
     LPWSTR lpProfileDirW;
     BOOL bResult;
     DWORD cchOrgSize, cchReq;


    if (!lpProfileDirA) {
        DebugMsg((DM_WARNING, TEXT("GetDefaultUserProfileDirectoryA : lpProfileDirA is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!lpcchSize) {
        DebugMsg((DM_WARNING, TEXT("GetDefaultUserProfileDirectoryA : lpcchSize is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
     // Allocate a buffer to match the ANSI buffer
     //

     if (!(lpProfileDirW = GlobalAlloc(GPTR, (*lpcchSize) * sizeof(TCHAR)))) {
        return FALSE;
     }

     cchOrgSize = *lpcchSize;  // Store the original size passed to the function
     bResult = GetDefaultUserProfileDirectoryW(lpProfileDirW, lpcchSize);


     if (bResult) {
         cchReq = WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                      0, NULL, NULL);
         *lpcchSize = cchReq;
         if (cchReq > cchOrgSize) {
             bResult = FALSE;
         }
         else {
             bResult = WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                           *lpcchSize, NULL, NULL);
         }
     }


     GlobalFree(lpProfileDirW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI GetDefaultUserProfileDirectoryW (LPWSTR lpProfileDirW, LPDWORD lpcchSize)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI GetAllUsersProfileDirectoryA (LPSTR lpProfileDirA, LPDWORD lpcchSize)
{
     LPWSTR lpProfileDirW;
     BOOL bResult;
     DWORD cchOrgSize, cchReq;

     if (!lpProfileDirA) {
         DebugMsg((DM_WARNING, TEXT("GetAllUsersProfileDirectoryA : lpProfileDirA is null")));
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }

     if (!lpcchSize) {
         DebugMsg((DM_WARNING, TEXT("GetAllUsersProfileDirectoryA : lpcchSize is null")));
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }

     //
     // Allocate a buffer to match the ANSI buffer
     //

     if (!(lpProfileDirW = GlobalAlloc(GPTR, (*lpcchSize) * sizeof(TCHAR)))) {
        return FALSE;
     }

     cchOrgSize = *lpcchSize;  // Store the original size passed to the function
     bResult = GetAllUsersProfileDirectoryW(lpProfileDirW, lpcchSize);


     if (bResult) {
         cchReq = WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                      0, NULL, NULL);
         *lpcchSize = cchReq;
         if (cchReq > cchOrgSize) {
             bResult = FALSE;
         }
         else {
             bResult = WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                           *lpcchSize, NULL, NULL);
         }
     }


     GlobalFree(lpProfileDirW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI GetAllUsersProfileDirectoryW (LPWSTR lpProfileDirW, LPDWORD lpcchSize)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE



//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI GetUserProfileDirectoryA (HANDLE hToken, LPSTR lpProfileDirA, LPDWORD lpcchSize)
{
     LPWSTR lpProfileDirW;
     BOOL bResult;
     DWORD cchOrgSize, cchReq;

    if (!lpProfileDirA) {
        DebugMsg((DM_WARNING, TEXT("GetUserProfileDirectoryA : lpProfileDirA is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

     if (!lpcchSize) {
         DebugMsg((DM_WARNING, TEXT("GetUserProfileDirectoryA : lpcchSize is null")));
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }

     //
     // Allocate a buffer to match the ANSI buffer
     //

     if (!(lpProfileDirW = GlobalAlloc(GPTR, (*lpcchSize) * sizeof(TCHAR)))) {
        return FALSE;
     }

     cchOrgSize = *lpcchSize;  // Store the original size passed to the function
     bResult = GetUserProfileDirectoryW(hToken, lpProfileDirW, lpcchSize);


     if (bResult) {
         cchReq = WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                      0, NULL, NULL);
         *lpcchSize = cchReq;
         if (cchReq > cchOrgSize) {
             bResult = FALSE;
         }
         else {
             bResult = WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                           *lpcchSize, NULL, NULL);
         }
     }


     GlobalFree(lpProfileDirW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI GetUserProfileDirectoryW (HANDLE hToken, LPWSTR lpProfileDirW, LPDWORD lpcchSize)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI GetUserProfileDirFromSidA (PSID pSid, LPSTR lpProfileDirA, LPDWORD lpcchSize)
{
     LPWSTR lpProfileDirW;
     BOOL bResult;
     DWORD cchOrgSize, cchReq;

    if (!lpProfileDirA) {
        DebugMsg((DM_WARNING, TEXT("GetUserProfileDirFromSidA : lpProfileDirA is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

     if (!lpcchSize) {
         DebugMsg((DM_WARNING, TEXT("GetUserProfileDirFromSidA : lpcchSize is null")));
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }

     //
     // Allocate a buffer to match the ANSI buffer
     //

     if (!(lpProfileDirW = GlobalAlloc(GPTR, (*lpcchSize) * sizeof(TCHAR)))) {
        return FALSE;
     }

     cchOrgSize = *lpcchSize;  // Store the original size passed to the function
     bResult = GetUserProfileDirFromSidW(pSid, lpProfileDirW, lpcchSize);


     if (bResult) {
         cchReq = WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                      0, NULL, NULL);
         *lpcchSize = cchReq;
         if (cchReq > cchOrgSize) {
             bResult = FALSE;
         }
         else {
             bResult = WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                           *lpcchSize, NULL, NULL);
         }
     }


     GlobalFree(lpProfileDirW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI GetUserProfileDirFromSidW (PSID pSid, LPWSTR lpProfileDirW, LPDWORD lpcchSize)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI ExpandEnvironmentStringsForUserA (HANDLE hToken, LPCSTR lpSrcA, LPSTR lpDestA, DWORD dwSize)
{
     LPWSTR lpSrcW, lpDestW;
     BOOL bResult;

    if (!lpDestA) {
        DebugMsg((DM_WARNING, TEXT("ExpandEnvironmentStringsForUserA : lpDestA is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

     //
     // Convert the ANSI strings to Unicode and call
     // the real function.
     //

     if (!(lpSrcW = ProduceWFromA(lpSrcA))) {
         DebugMsg((DM_WARNING, TEXT("ExpandEnvircallonmentStringsForUserA : lpSrcA is null")));
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }

     //
     // Allocate a buffer to match the ANSI buffer
     //

     if (!(lpDestW = GlobalAlloc(GPTR, dwSize * sizeof(TCHAR)))) {
         FreeProducedString(lpSrcW);
         return FALSE;
     }

     bResult = ExpandEnvironmentStringsForUserW(hToken, lpSrcW, lpDestW, dwSize);


     if (bResult) {
         bResult = WideCharToMultiByte(CP_ACP, 0, lpDestW, -1, lpDestA,
                             dwSize, NULL, NULL);
     }


     GlobalFree(lpDestW);
     FreeProducedString(lpSrcW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI ExpandEnvironmentStringsForUserW (HANDLE hToken, LPCWSTR lpSrcW, LPWSTR lpDestW, DWORD dwSize)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI GetSystemTempDirectoryA (LPSTR lpDirA, LPDWORD lpcchSize)
{
     LPWSTR lpDirW;
     BOOL bResult;
     DWORD cchOrgSize, cchReq;

     if (!lpcchSize) {
         DebugMsg((DM_WARNING, TEXT("GetSystemTempDirectoryA : lpcchSize is null")));
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }

     //
     // Allocate a buffer to match the ANSI buffer
     //

     if (!(lpDirW = GlobalAlloc (GPTR, (*lpcchSize) * sizeof(TCHAR)))) {
        return FALSE;
     }

     cchOrgSize = *lpcchSize;  // Store the original size passed to the function
     bResult = GetSystemTempDirectoryW (lpDirW, lpcchSize);


     if (bResult) {
         cchReq = WideCharToMultiByte(CP_ACP, 0, lpDirW, -1, lpDirA,
                                      0, NULL, NULL);
         *lpcchSize = cchReq;
         if (cchReq > cchOrgSize) {
             bResult = FALSE;
         }
         else {
             WideCharToMultiByte (CP_ACP, 0, lpDirW, -1, lpDirA,
                                  *lpcchSize, NULL, NULL);
         }
     }


     GlobalFree (lpDirW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI GetSystemTempDirectoryW (LPWSTR lpDirW, LPDWORD lpcchSize)
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI ConvertGPOListWToA( PGROUP_POLICY_OBJECTW  pGPOListW,
                                PGROUP_POLICY_OBJECTA *pGPOListA )
{
    LPSTR lpDSPathA, lpFileSysPathA, lpDisplayNameA, lpExtensionsA, lpLinkA;
    DWORD dwSize;
    PGROUP_POLICY_OBJECTA pGPOTempA = NULL, pNew, pTemp;
    PGROUP_POLICY_OBJECTW pGPO = pGPOListW;

    while (pGPO) {

        //
        // Build an ANSI structure for this entry
        //

        lpDSPathA = ProduceAFromW(pGPO->lpDSPath);
        lpFileSysPathA = ProduceAFromW(pGPO->lpFileSysPath);
        lpDisplayNameA = ProduceAFromW(pGPO->lpDisplayName);
        lpExtensionsA = ProduceAFromW( pGPO->lpExtensions );
        lpLinkA = ProduceAFromW( pGPO->lpLink );

        //
        // Calculate the size of the new GPO item
        //

        dwSize = sizeof (GROUP_POLICY_OBJECTA);

        if (lpDSPathA) {
            dwSize += (lstrlenA(lpDSPathA) + 1);
        }

        if (lpFileSysPathA) {
            dwSize += (lstrlenA(lpFileSysPathA) + 1);
        }

        if (lpDisplayNameA) {
            dwSize += (lstrlenA(lpDisplayNameA) + 1);
        }

        if (lpExtensionsA) {
            dwSize += (lstrlenA(lpExtensionsA) + 1);
        }

        if (lpLinkA) {
            dwSize += (lstrlenA(lpLinkA) + 1);
        }

        //
        // Allocate space for it
        //

        pNew = (PGROUP_POLICY_OBJECTA) LocalAlloc (LPTR, dwSize);

        if (!pNew) {
            DebugMsg((DM_WARNING, TEXT("ConvertGPOListWToA: Failed to allocate memory with %d"),
                     GetLastError()));
            FreeProducedString(lpDSPathA);
            FreeProducedString(lpFileSysPathA);
            FreeProducedString(lpDisplayNameA);
            FreeProducedString(lpExtensionsA);
            FreeProducedString(lpLinkA);
            FreeGPOListW (pGPOListW);
            return FALSE;
        }


        //
        // Fill in item
        //

        pNew->dwOptions = pGPO->dwOptions;
        pNew->dwVersion = pGPO->dwVersion;

        if (lpDSPathA) {
            pNew->lpDSPath = (LPSTR)(((LPBYTE)pNew) + sizeof(GROUP_POLICY_OBJECTA));
            lstrcpyA (pNew->lpDSPath, lpDSPathA);
        }

        if (lpFileSysPathA) {
            if (lpDSPathA) {
                pNew->lpFileSysPath = pNew->lpDSPath + lstrlenA (pNew->lpDSPath) + 1;
            } else {
                pNew->lpFileSysPath = (LPSTR)(((LPBYTE)pNew) + sizeof(GROUP_POLICY_OBJECTA));
            }

            lstrcpyA (pNew->lpFileSysPath, lpFileSysPathA);
        }


        if (lpDisplayNameA) {
            if (lpFileSysPathA) {
                pNew->lpDisplayName = pNew->lpFileSysPath + lstrlenA (pNew->lpFileSysPath) + 1;
            } else {

                if (lpDSPathA)
                {
                    pNew->lpDisplayName = pNew->lpDSPath + lstrlenA (pNew->lpDSPath) + 1;
                }
                else
                {
                    pNew->lpDisplayName = (LPSTR)(((LPBYTE)pNew) + sizeof(GROUP_POLICY_OBJECTA));
                }
            }

            lstrcpyA (pNew->lpDisplayName, lpDisplayNameA);
        }

        if (lpExtensionsA) {
            if (lpDisplayNameA) {
                pNew->lpExtensions = pNew->lpDisplayName + lstrlenA(pNew->lpDisplayName) + 1;
            } else {

                if (lpFileSysPathA) {
                    pNew->lpExtensions = pNew->lpFileSysPath + lstrlenA(pNew->lpFileSysPath) + 1;
                } else {

                    if (lpDSPathA) {
                        pNew->lpExtensions = pNew->lpDSPath + lstrlenA(pNew->lpDSPath) + 1;
                    } else {
                        pNew->lpExtensions = (LPSTR)(((LPBYTE)pNew) + sizeof(GROUP_POLICY_OBJECTA));
                    }

                }
            }

            lstrcpyA( pNew->lpExtensions, lpExtensionsA );
        }

        if (lpLinkA) {

            if (lpExtensionsA) {
                pNew->lpLink = pNew->lpExtensions + lstrlenA(pNew->lpExtensions) + 1;
            } else {

                if (lpDisplayNameA) {
                    pNew->lpLink = pNew->lpDisplayName + lstrlenA(pNew->lpDisplayName) + 1;
                } else {

                    if (lpFileSysPathA) {
                        pNew->lpLink = pNew->lpFileSysPath + lstrlenA(pNew->lpFileSysPath) + 1;
                    } else {

                        if (lpDSPathA) {
                            pNew->lpLink = pNew->lpDSPath + lstrlenA(pNew->lpDSPath) + 1;
                        } else {
                            pNew->lpLink = (LPSTR)(((LPBYTE)pNew) + sizeof(GROUP_POLICY_OBJECTA));
                        }
                    }
                }
            }

            lstrcpyA( pNew->lpLink, lpLinkA );
        }


        WideCharToMultiByte(CP_ACP, 0, pGPO->szGPOName, -1, pNew->szGPOName, 50, NULL, NULL);

        pNew->GPOLink = pGPO->GPOLink;
        pNew->lParam = pGPO->lParam;


        //
        // Add it to the ANSI link list
        //

        if (pGPOTempA) {

            pTemp = pGPOTempA;

            while (pTemp->pNext != NULL) {
                pTemp = pTemp->pNext;
            }

            pTemp->pNext = pNew;
            pNew->pPrev = pTemp;

        } else {

            pGPOTempA = pNew;
        }

        FreeProducedString(lpDSPathA);
        FreeProducedString(lpFileSysPathA);
        FreeProducedString(lpDisplayNameA);
        FreeProducedString(lpExtensionsA);
        FreeProducedString(lpLinkA);

        pGPO = pGPO->pNext;
    }

    *pGPOListA = pGPOTempA;

    FreeGPOListW (pGPOListW);

    return TRUE;
}

BOOL WINAPI GetGPOListA (HANDLE hToken, LPCSTR lpNameA, LPCSTR lpHostNameA,
                         LPCSTR lpComputerNameA, DWORD dwFlags,
                         PGROUP_POLICY_OBJECTA *pGPOListA)
{
     LPWSTR lpNameW, lpHostNameW, lpComputerNameW;
     PGROUP_POLICY_OBJECTW pGPOListW;
     BOOL bResult;


     if (!pGPOListA) {
         DebugMsg((DM_WARNING, TEXT("GetGPOListA: pGPOList is null")));
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }


     lpNameW = ProduceWFromA(lpNameA);
     lpHostNameW = ProduceWFromA(lpHostNameA);
     lpComputerNameW = ProduceWFromA(lpComputerNameA);

     bResult = GetGPOListW (hToken, lpNameW, lpHostNameW, lpComputerNameW,
                            dwFlags, &pGPOListW);


     FreeProducedString(lpNameW);
     FreeProducedString(lpHostNameW);
     FreeProducedString(lpComputerNameW);

     if (bResult) {
         bResult = ConvertGPOListWToA( pGPOListW, pGPOListA );
     }

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI GetGPOListW (HANDLE hToken, LPCWSTR lpNameW, LPCWSTR lpHostNameW,
                         LPCWSTR lpComputerNameW, DWORD dwFlags,
                         PGROUP_POLICY_OBJECTW *pGPOListW)
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI FreeGPOListA (PGROUP_POLICY_OBJECTA pGPOListA)
{
    PGROUP_POLICY_OBJECTA pGPOTemp;

    while (pGPOListA) {
        pGPOTemp = pGPOListA->pNext;
        LocalFree (pGPOListA);
        pGPOListA = pGPOTemp;
    }

    return TRUE;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI FreeGPOListW (PGROUP_POLICY_OBJECTW pGPOListW)
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI ApplySystemPolicyA (DWORD dwFlags, HANDLE hToken, HKEY hKeyCurrentUser,
                                LPCSTR lpUserNameA, LPCSTR lpPolicyPathA,
                                LPCSTR lpServerNameA)
{
    LPWSTR lpUserNameW, lpPolicyPathW, lpServerNameW;
    BOOL bResult;


    //
    // Convert the ANSI strings to Unicode and call
    // the real function.
    //

    if (!(lpUserNameW = ProduceWFromA(lpUserNameA))) {
       return FALSE;
    }

    lpPolicyPathW = ProduceWFromA(lpPolicyPathA);
    lpServerNameW = ProduceWFromA(lpServerNameA);


    bResult = ApplySystemPolicyW(dwFlags, hToken, hKeyCurrentUser, lpUserNameW,
                                 lpPolicyPathW, lpServerNameW);


    FreeProducedString(lpServerNameW);
    FreeProducedString(lpPolicyPathW);
    FreeProducedString(lpUserNameW);

    return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI ApplySystemPolicyW (DWORD dwFlags, HANDLE hToken, HKEY hKeyCurrentUser,
                                LPCWSTR lpUserNameW, LPCWSTR lpPolicyPathW,
                                LPCWSTR lpServerNameW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE



//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

DWORD WINAPI GetAppliedGPOListA ( DWORD dwFlags,
                                  LPCSTR pMachineNameA,
                                  PSID pSidUser,
                                  GUID *pGuidExtension,
                                  PGROUP_POLICY_OBJECTA *pGPOListA)
{
    PGROUP_POLICY_OBJECTW pGPOListW;
    DWORD dwRet;
    LPWSTR pMachineNameW;

    if (!pGPOListA || !pGuidExtension) {
        DebugMsg((DM_WARNING, TEXT("GetAppliedGPOListA: pGPOList or pGuidExtension is null")));
        return ERROR_INVALID_PARAMETER;
    }

    pMachineNameW = ProduceWFromA(pMachineNameA);

    dwRet = GetAppliedGPOListW ( dwFlags, pMachineNameW, pSidUser, pGuidExtension, &pGPOListW);

    FreeProducedString(pMachineNameW);

    if ( dwRet == ERROR_SUCCESS ) {
        BOOL bResult = ConvertGPOListWToA( pGPOListW, pGPOListA );
        dwRet = bResult ? ERROR_SUCCESS : E_FAIL;
    }

    return dwRet;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

DWORD WINAPI GetAppliedGPOListW ( DWORD dwFlags,
                                  GUID *pGuidExtension,
                                  PGROUP_POLICY_OBJECTW *pGPOListW)
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

#endif // UNICODE


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI DeleteProfileA ( LPCSTR lpSidStringA,
                                 LPCSTR lpProfilePathA,
                                 LPCSTR lpComputerNameA)
{
    LPWSTR pSidStringW;
    LPWSTR pProfilePathW;
    LPWSTR pComputerNameW;
    BOOL dwRet;

    if (!lpSidStringA) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfileA: lpSidString is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!(pSidStringW = ProduceWFromA(lpSidStringA))) {
        return FALSE;
    }

    if (lpProfilePathA) {
        if (!(pProfilePathW = ProduceWFromA(lpProfilePathA))) {
            FreeProducedString(pSidStringW);
            return FALSE;
        }
    }
    else {
        pProfilePathW = NULL;
    }

    if (lpComputerNameA) {
        if (!(pComputerNameW = ProduceWFromA(lpComputerNameA))) {
            FreeProducedString(pSidStringW);
            FreeProducedString(pProfilePathW);
            return FALSE;
        }
    }
    else {
        pComputerNameW = NULL;
    }


    dwRet = DeleteProfileW ( pSidStringW, pProfilePathW, pComputerNameW);

    FreeProducedString(pSidStringW);

    if (pProfilePathW)
        FreeProducedString(pProfilePathW);

    if (pComputerNameW)
        FreeProducedString(pComputerNameW);

    return dwRet;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI DeleteProfileW ( LPWSTR lpSidStringW,
                                 LPWSTR lpProfilePathW,
                                 HKEY   hKeyLM)
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

#endif // UNICODE
//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

DWORD WINAPI GetUserAppDataPathA (HANDLE hToken, LPSTR lpFolderPathA)
{
    LPWSTR lpFolderPathW;
    BOOL bResult;
    DWORD dwError = ERROR_SUCCESS, cchReq;


    if (!lpFolderPathA) {
        DebugMsg((DM_WARNING, TEXT("GetUserAppDataPathA : lpFolderPathA is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }
    else {
        *lpFolderPathA = TEXT('\0');
    }

    //
    // Allocate a buffer to match the ANSI buffer
    //

    if (!(lpFolderPathW = GlobalAlloc(GPTR, (MAX_PATH) * sizeof(TCHAR)))) {
        SetLastError(ERROR_OUTOFMEMORY);
        return ERROR_OUTOFMEMORY;
    }

    dwError = GetUserAppDataPathW(hToken, lpFolderPathW);


    if (dwError == ERROR_SUCCESS) {
        cchReq = WideCharToMultiByte(CP_ACP, 0, lpFolderPathW, -1, lpFolderPathA,
                                     0, NULL, NULL);
        if (cchReq > MAX_PATH) {
            dwError = ERROR_INSUFFICIENT_BUFFER;
        }
        else {
            bResult = WideCharToMultiByte(CP_ACP, 0, lpFolderPathW, -1, lpFolderPathA,
                                          MAX_PATH, NULL, NULL);
        }
    }


    GlobalFree(lpFolderPathW);

    SetLastError(dwError);
    return dwError;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI GetUserAppDataPathW (HANDLE hToken, LPWSTR lpFolderPathW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return ERROR_CALL_NOT_IMPLEMENTED;
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\profile\profile.cpp ===
//*************************************************************
//
//  Profile management routines. Implements IUserProfile.
//  The organization of this file is as follows:
//      Implementation of CUserProfile object
//      Implementation of CUserProfile2 object
//      LoadUserProfile
//      UnloadUserProfile
//      All other global functions
//      Implementation of various other objects and data structures
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************


#include "uenv.h"
#include <wincred.h>
#include <credp.h>
#include <wow64reg.h>
#include <tchar.h>
#include <stdio.h>
#include <sddl.h>
#include "profmgr.hxx"

//
//  XPSP1 specific
//
#include "xpsp1res.h"

//
// Length of const strings.
//

DWORD   USER_KEY_PREFIX_LEN = lstrlen(USER_KEY_PREFIX);
DWORD   USER_CLASSES_HIVE_SUFFIX_LEN = lstrlen(USER_CLASSES_HIVE_SUFFIX);


//
// Tells us if we are loaded by winlogon or not.
//

extern "C" DWORD       g_dwLoadFlags = 0;


//
// The user profile manager. There's only one instance of this object,
// it resides in console winlogon.
//

CUserProfile      cUserProfileManager;

//
// Local function proto-types
//

LPTSTR  AllocAndExpandProfilePath(LPPROFILEINFO lpProfileInfo);
DWORD   ApplySecurityToRegistryTree(HKEY RootKey, PSECURITY_DESCRIPTOR pSD);
BOOL    CheckForSlowLink(LPPROFILE lpProfile, DWORD dwTime, LPTSTR lpPath, BOOL bDlgLogin);
BOOL    CheckNetDefaultProfile(LPPROFILE lpProfile);
BOOL    APIENTRY ChooseProfileDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                      LPARAM lParam);
BOOL    CompareProfileInfo(LPPROFILEINFO pProfileInfo1, LPPROFILEINFO pProfileInfo2);
LPPROFILEINFO   CopyProfileInfo(LPPROFILEINFO pProfileInfo);
BOOL    CreateLocalProfileImage(LPPROFILE lpProfile, LPTSTR lpBaseName);
BOOL    CreateLocalProfileKey(LPPROFILE lpProfile, PHKEY phKey, BOOL *bKeyExists);
DWORD   DecrementProfileRefCount(LPPROFILE lpProfile);
DWORD   DeletePolicyState(LPCWSTR szSid );
void    DeleteProfileInfo(LPPROFILEINFO pProfileInfo);
void    DumpOpenRegistryHandle(LPTSTR lpkeyName);
BOOL    GetExistingLocalProfileImage(LPPROFILE lpProfile);
void    ReleaseClientContext_s(PPCONTEXT_HANDLE pphContext);
BOOL    GetUserDomainName(LPPROFILE lpProfile, LPTSTR lpDomainName,
                          LPDWORD lpDomainNameSize);
DWORD   GetUserPreferenceValue(HANDLE hToken);
DWORD   IncrementProfileRefCount(LPPROFILE lpProfile, BOOL bInitialize);
BOOL    IsCacheDeleted();
BOOL    IsCentralProfileReachable(LPPROFILE lpProfile, BOOL *bCreateCentralProfile,
                                  BOOL *bMandatory, BOOL* bOwnerOK);
BOOL    IssueDefaultProfile(LPPROFILE lpProfile, LPTSTR lpDefaultProfile,
                            LPTSTR lpLocalProfile, LPTSTR lpSidString,
                            BOOL bMandatory);
BOOL    IsTempProfileAllowed();
LPPROFILE LoadProfileInfo(HANDLE hTokenClient, HANDLE hTokenUser, HKEY hKeyCurrentUser);
BOOL    ParseProfilePath(LPPROFILE lpProfile, LPTSTR lpProfilePath, BOOL *bpCSCBypassed, TCHAR *cpDrive);
BOOL    PatchNewProfileIfRequired(HANDLE hToken);
BOOL    IsGuiSetupInProgress();
BOOL    PrepareProfileForUse(LPPROFILE lpProfile, LPVOID pEnv);
BOOL    RestoreUserProfile(LPPROFILE lpProfile);
BOOL    SaveProfileInfo(LPPROFILE lpProfile);
BOOL    SetNtUserIniAttributes(LPTSTR szDir);
BOOL    SetProfileTime(LPPROFILE lpProfile);
BOOL    TestIfUserProfileLoaded(HANDLE hUserToken, LPPROFILEINFO lpProfileInfo);
DWORD   ThreadMain(PMAP pThreadMap);
BOOL    UpgradeCentralProfile(LPPROFILE lpProfile, LPTSTR lpOldProfile);
BOOL    UpgradeProfile(LPPROFILE lpProfile, LPVOID pEnv);
BOOL    IsProfileInUse (LPCTSTR szComputer, LPCTSTR lpSid);
BOOL    IsUIRequired(HANDLE hToken);
void    CheckRUPShare(LPTSTR lpProfilePath);
INT_PTR APIENTRY LoginSlowLinkDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY LogoffSlowLinkDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL    RegisterDialogInterface(LPTSTR szRPCEndPoint);
BOOL    UnRegisterDialogInterface(void);
BOOL    IsPartialRoamingProfile(LPPROFILE lpProfile);
void    TouchLocalHive(LPPROFILE lpProfile);
HRESULT CheckRoamingShareOwnership(LPTSTR lpDir, HANDLE hTokenUser);

#define USERNAME_VARIABLE          TEXT("USERNAME")


//*************************************************************
//
//  LoadUserProfile()
//
//  Purpose:    Loads the user's profile, if unable to load
//              use the cached profile or issue the default profile.
//
//  Parameters: hToken          -   User's token
//              lpProfileInfo   -   Profile Information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   This is a wrapper around IUserProfile::LoadUserProfile
//              and LoadUserProfileP.
//
//  History:    Date        Author     Comment
//              6/6/95      ericflo    Created
//              6/14/00     weiruc     changed to be a wrapper for
//                                     IUserProfile->LoadUserProfileP.
//
//*************************************************************

BOOL WINAPI LoadUserProfile(HANDLE hToken, LPPROFILEINFO lpProfileInfo)
{
    BOOL            bResult = FALSE;        // Return value
    HANDLE          hOldToken = NULL;
    NTSTATUS        status;
    BOOLEAN         bRestoreWasEnabled;
    BOOLEAN         bBackupWasEnabled;
    BOOL            bRestoreEnabled = FALSE;
    BOOL            bBackupEnabled = FALSE;
    TCHAR           ProfileDir[MAX_PATH];
    DWORD           dwProfileDirSize = MAX_PATH;
    BOOL            bCoInitialized = FALSE;
    long            lResult;
    LPTSTR          pSid = NULL;
    DWORD           dwErr = ERROR_SUCCESS;
    PCONTEXT_HANDLE phContext = NULL;
    handle_t        hIfUserProfile;
    BOOL            bBindInterface = FALSE;
    TCHAR           szRPCEndPoint[MAX_PATH];
    LPTSTR          lpRPCEndPoint = NULL;

    //
    // Initialize the debug flags.
    //

    InitDebugSupport( FALSE );


    //
    //  Check Parameters
    //

    if (!lpProfileInfo) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: NULL lpProfileInfo")));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    if (lpProfileInfo->dwSize != sizeof(PROFILEINFO)) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: lpProfileInfo->dwSize != sizeof(PROFILEINFO)")));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    if (!lpProfileInfo->lpUserName || !(*lpProfileInfo->lpUserName)) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: received a NULL pointer for lpUserName.")));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // Make sure we can impersonate the user
    //

    if (!ImpersonateUser(hToken, &hOldToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Failed to impersonate user with %d."), dwErr));
        goto Exit;
    }
    
    //
    // Revert to ourselves.
    //

    RevertToUser(&hOldToken);
    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Yes, we can impersonate the user. Running as self")));

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("=========================================================")));

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Entering, hToken = <0x%x>, lpProfileInfo = 0x%x"),
             hToken, lpProfileInfo));

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->dwFlags = <0x%x>"),
             lpProfileInfo->dwFlags));

    if (lpProfileInfo->lpUserName) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpUserName = <%s>"),
                 lpProfileInfo->lpUserName));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL user name!")));
    }

    if (lpProfileInfo->lpProfilePath) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpProfilePath = <%s>"),
                 lpProfileInfo->lpProfilePath));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL central profile path")));
    }

    if (lpProfileInfo->lpDefaultPath) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpDefaultPath = <%s>"),
                 lpProfileInfo->lpDefaultPath));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL default profile path")));
    }

    if (lpProfileInfo->lpServerName) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpServerName = <%s>"),
                 lpProfileInfo->lpServerName));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL server name")));
    }

    if (lpProfileInfo->dwFlags & PI_APPLYPOLICY) {
        if (lpProfileInfo->lpPolicyPath) {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpPolicyPath = <%s>"),
                      lpProfileInfo->lpPolicyPath));
        } else {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL policy path")));
        }
    }

    //
    // If we are in console winlogon process, call
    // IUserProfile::LoadUserProfileP directly. Otherwise get the COM interface
    //

    if(cUserProfileManager.IsConsoleWinlogon()) {
        
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: In console winlogon process")));
        
        //
        // Call the private load user profile function.
        //

        if (!cUserProfileManager.LoadUserProfileP(NULL, hToken, lpProfileInfo, NULL)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: LoadUserProfileP failed with error %d"), dwErr));
            goto Exit;
        }
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: LoadUserProfileP succeeded")));
    }
    else {

        //
        // Enable restore and backup privilege (LoadUserClasses requires both).
        // Winlogon won't be able to enable the privilege for us.
        //

        status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &bRestoreWasEnabled);
        if(!NT_SUCCESS(status)) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Failed to enable the restore privilege. error = %08x"), status));
            dwErr = RtlNtStatusToDosError(status);  
            goto Exit;
        }
        bRestoreEnabled = TRUE;

        status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, TRUE, FALSE, &bBackupWasEnabled);
        if(!NT_SUCCESS(status)) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Failed to enable the backup privilege. error = %08x"), status));
            dwErr = RtlNtStatusToDosError(status);  
            goto Exit;
        }
        bBackupEnabled = TRUE;

        //
        // Get the IUserProfile interface.
        //

        if (!GetInterface(&hIfUserProfile, cszRPCEndPoint)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: GetInterface failed with error %d"), dwErr));
            goto Exit;
        }
        bBindInterface = TRUE;

        //
        // Call IUserProfile->DropClientToken, this will let us drop off our
        // client token and give us back the context.
        //

        RpcTryExcept {
            dwErr = cliDropClientContext(hIfUserProfile, lpProfileInfo, &phContext);            
        }
        RpcExcept(1) {
            dwErr = RpcExceptionCode();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Calling DropClientContext took exception. err = %d"), dwErr));
        }
        RpcEndExcept

        if (dwErr != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Calling DropClientContext failed. err = %d"), dwErr));
            goto Exit;
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Calling DropClientToken (as self) succeeded")));
        }

        //
        // Register the dialog interface
        //
       
        if (!(lpProfileInfo->dwFlags & (PI_NOUI | PI_LITELOAD))) {
            
            _snwprintf(szRPCEndPoint, MAX_PATH, L"IProfileDialog_%d", GetCurrentProcessId());
            if (!RegisterDialogInterface(szRPCEndPoint)) {
                DebugMsg((DM_WARNING, TEXT("LoadUserProfile: RegisterDialogInterface fails.")));
                lpRPCEndPoint = NULL;
            }
            else {
                lpRPCEndPoint = szRPCEndPoint;
            }
        }              

        //
        // Impersonate the user and call IUserProfile->LoadUserProfileI().
        //

        if(!ImpersonateUser(hToken, &hOldToken)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: ImpersonateUser failed. err = %d"), dwErr));
            goto Exit;
        }

        RpcTryExcept {
            dwErr = cliLoadUserProfileI(hIfUserProfile, lpProfileInfo, phContext, lpRPCEndPoint);
        }
        RpcExcept(1) {
            dwErr = RpcExceptionCode();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Calling LoadUserProfileI took exception. err = %d"), dwErr));
        }
        RpcEndExcept

        RevertToUser(&hOldToken);
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Running as self")));

        if (dwErr != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Calling LoadUserProfileI failed. err = %d"), dwErr));
            goto Exit;
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Calling LoadUserProfileI (as user) succeeded")));
        }


        //
        // Open the user's hive.
        //

        pSid = GetSidString(hToken);
        if(pSid == NULL) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile:  GetSidString failed, err = %d"), dwErr));
            goto Exit;
        }
        lResult = RegOpenKeyEx(HKEY_USERS, pSid, 0, KEY_ALL_ACCESS,
                               (PHKEY)&lpProfileInfo->hProfile);
        if(lResult != ERROR_SUCCESS) {
            dwErr = lResult;
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile:  Failed to open current user <%s> key. Error = %d"), pSid, lResult));
            DeleteSidString(pSid);
            goto Exit;
        }
        DeleteSidString(pSid);
        
    } // Is console winlogon?

    //
    // Set the USERPROFILE environment variable just so that there's no change
    // of behavior with the old in process LoadUserProfile API. Callers
    // expecting this env to be set is under the risk that while
    // SetEnvironmentVariable is per process but LoadUserProfile can be called
    // on multiple threads.
    //

    if(!GetUserProfileDirectory(hToken, ProfileDir, &dwProfileDirSize)) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: GetUserProfileDirectory failed with %08x"), GetLastError()));
    }
    else {
        SetEnvironmentVariable (TEXT("USERPROFILE"), ProfileDir);
    }

    bResult = TRUE;

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile:  Returning success.  Final Information follows:")));
    DebugMsg((DM_VERBOSE, TEXT("lpProfileInfo->UserName = <%s>"), lpProfileInfo->lpUserName));
    DebugMsg((DM_VERBOSE, TEXT("lpProfileInfo->lpProfilePath = <%s>"), lpProfileInfo->lpProfilePath));
    DebugMsg((DM_VERBOSE, TEXT("lpProfileInfo->dwFlags = 0x%x"), lpProfileInfo->dwFlags));

Exit:

    //
    // Restore the previous privileges.
    //

    if(bRestoreEnabled && !bRestoreWasEnabled) {
        status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, bRestoreWasEnabled, FALSE, &bRestoreWasEnabled);
        if(!NT_SUCCESS(status)) {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Failed to restore the original restore privilege setting. error = %08x"), status));
        }
    }
    
    if(bBackupEnabled && !bBackupWasEnabled) {
        status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, bBackupWasEnabled, FALSE, &bBackupWasEnabled);
        if(!NT_SUCCESS(status)) {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Failed to restore the original backup privilege setting. error = %08x"), status));
        }
    }
    
    //
    // Unregister the Dialog interface
    //

    if (lpRPCEndPoint && !UnRegisterDialogInterface()) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: UnRegisterDialogInterface fails.")));
    }        

    //
    // Release the context handle
    //

    if (phContext) {
        RpcTryExcept {
            cliReleaseClientContext(hIfUserProfile, &phContext);
        }
        RpcExcept(1) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: ReleaseClientContext took exception."), RpcExceptionCode()));
        }
        RpcEndExcept
    }

    //
    // Release the interface
    //

    if (bBindInterface) {
        if (!ReleaseInterface(&hIfUserProfile)) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: ReleaseInterface failed.")));
        }
    }

    //
    // Release the tokens.
    //

    if(hOldToken) {
        CloseHandle(hOldToken);
    }

    if(bResult) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Returning TRUE. hProfile = <0x%x>"), lpProfileInfo->hProfile));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Returning FALSE. Error = %d"), dwErr));
    }

    //
    // Set the last error to win32 error code.
    //

    SetLastError(dwErr);

    //
    // Return.
    //

    return bResult;
}


//*************************************************************
//
//  UnloadUserProfile()
//
//  Purpose:    Unloads the user's profile.
//
//  Parameters: hToken    -   User's token
//              hProfile  -   Profile handle created in LoadUserProfile
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/7/95      ericflo    Created
//              6/15/00     weiruc     Modified to wrap
//                                     IUserProfile->UnloadUserProfileP.
//
//*************************************************************

BOOL WINAPI UnloadUserProfile(HANDLE hToken, HANDLE hProfile)
{
    HANDLE          hOldToken = NULL;
    BOOL            bResult = FALSE;
    NTSTATUS        status;
    BOOLEAN         bWasBackupEnabled, bWasRestoreEnabled;
    BOOL            bBackupEnabled = FALSE, bRestoreEnabled = FALSE;
    BOOL            bCoInitialized = FALSE;
    DWORD           dwErr = ERROR_SUCCESS;
    PCONTEXT_HANDLE phContext = NULL;
    handle_t        hIfUserProfile;
    BOOL            bBindInterface = FALSE;
    TCHAR           szRPCEndPoint[MAX_PATH];
    LPTSTR          lpRPCEndPoint = NULL;


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfile: Entering, hProfile = <0x%x>"), hProfile));

    //
    // Check Parameters
    //

    if (!hProfile || hProfile == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: received a NULL hProfile.")));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    if(!hToken || hToken == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: received a NULL hToken.")));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // Make sure we can impersonate the user
    //

    if (!ImpersonateUser(hToken, &hOldToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: Failed to impersonate user with %d."), dwErr));
        goto Exit;
    }

    //
    // Revert to ourselves.
    //

    RevertToUser(&hOldToken);

    //
    // If we are in console winlogon process, call
    // IUserProfile::UnloadUserProfileP directly. Otherwise get the COM interface
    //

    if(cUserProfileManager.IsConsoleWinlogon()) {
        
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfile: In console winlogon process")));
        
        //
        // Call the private UnloadUserProfile function.
        //

        if(!cUserProfileManager.UnloadUserProfileP(NULL, hToken, (HKEY)hProfile, NULL)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: UnloadUserProfileP failed with %d"), dwErr));
            goto Exit;
        }
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfile: UnloadUserProfileP succeeded")));
    }
    else {

        //
        // Close the hProfile key user passed in.
        //

        RegCloseKey((HKEY)hProfile);
    
        //
        // Enable the restore & backup privilege before calling over to winlogon.
        // Winlogon won't be able to enable the privilege for us.
        //

        status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &bWasRestoreEnabled);
        if(!NT_SUCCESS(status)) {
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: Failed to enable the restore privilege. error = %08x"), status));
            dwErr = RtlNtStatusToDosError(status); 
            goto Exit;
        }
        bRestoreEnabled = TRUE;

        status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, TRUE, FALSE, &bWasBackupEnabled);
        if(!NT_SUCCESS(status)) {
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: Failed to enable the backup privilege. error = %08x"), status));
            dwErr = RtlNtStatusToDosError(status);  
            goto Exit;
        }
        bBackupEnabled = TRUE;

        //
        // Get the IUserProfile interface.
        //

        if(!GetInterface(&hIfUserProfile, cszRPCEndPoint)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: GetInterface failed with error %d"), dwErr));
            goto Exit;
        }
        bBindInterface = TRUE;

        //
        // Call IUserProfile->DropClientToken, this will let us drop off our
        // client token and give us back the context.
        //

        RpcTryExcept {
            dwErr = cliDropClientContext(hIfUserProfile, NULL, &phContext);
        }
        RpcExcept(1) {
            dwErr = RpcExceptionCode();
            DebugMsg((DM_WARNING, TEXT("UnLoadUserProfile: Calling DropClientToken took exception. error %d"), dwErr));
        }
        RpcEndExcept

        if (dwErr != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("UnLoadUserProfile: Calling DropClientContext failed. err = %d"), dwErr));
            goto Exit;
        }
        else {           
            DebugMsg((DM_VERBOSE, TEXT("UnLoadUserProfile: Calling DropClientToken (as self) succeeded")));
        }

        //
        // Register the dialog interface if req
        //
       
        if (IsUIRequired(hToken)) {
            
            _snwprintf(szRPCEndPoint, MAX_PATH, L"IProfileDialog_%d", GetCurrentProcessId());
            if (!RegisterDialogInterface(szRPCEndPoint)) {
                DebugMsg((DM_WARNING, TEXT("LoadUserProfile: RegisterDialogInterface fails.")));
                lpRPCEndPoint = NULL;
            }
            else {
                lpRPCEndPoint = szRPCEndPoint;
            }
        }              

        //
        // Impersonate the user and call IUserProfile->UnloadUserProfileI().
        //

        if (!ImpersonateUser(hToken, &hOldToken)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: ImpersonateUser failed. err = %d"), dwErr));
            goto Exit;
        }

        RpcTryExcept {
            dwErr = cliUnloadUserProfileI(hIfUserProfile, phContext, lpRPCEndPoint);
        }
        RpcExcept(1) {
            dwErr = RpcExceptionCode();
            DebugMsg((DM_WARNING, TEXT("UnLoadUserProfile: Calling UnLoadUserProfileI took exception. err = %d"), dwErr));
        }
        RpcEndExcept

        //
        // Revert back.
        //

        RevertToUser(&hOldToken);

        if (dwErr != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("UnLoadUserProfile: Calling UnLoadUserProfileI failed. err = %d"), dwErr));
            goto Exit;
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfile: Calling UnloadUserProfileI succeeded")));
        }

    } // Is console winlogon?

    bResult = TRUE;

Exit:

    //
    // Restore the previous privilege.
    //

    if(bRestoreEnabled && !bWasRestoreEnabled) {
        status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, bWasRestoreEnabled, FALSE, &bWasRestoreEnabled);
        if(!NT_SUCCESS(status)) {
            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfile: Failed to restore the original restore privilege setting. error = %08x"), status));
        }
    }
    
    if(bBackupEnabled && !bWasBackupEnabled) {
        status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, bWasBackupEnabled, FALSE, &bWasBackupEnabled);
        if(!NT_SUCCESS(status)) {
            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfile: Failed to restore the original backup privilege setting. error = %08x"), status));
        }
    }
    
    //
    // Unregister the Dialog interface
    //

    if (lpRPCEndPoint && !UnRegisterDialogInterface()) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: UnRegisterDialogInterface fails.")));
    }        

    //
    // Release the context handle
    //

    if (phContext) {
        RpcTryExcept {
            cliReleaseClientContext(hIfUserProfile, &phContext);
        }
        RpcExcept(1) {
            DebugMsg((DM_WARNING, TEXT("UnLoadUserProfile: ReleaseClientContext took exception."), RpcExceptionCode()));
        }
        RpcEndExcept
    }

    //
    // Release the interface
    //

    if (bBindInterface) {
        if (!ReleaseInterface(&hIfUserProfile)) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: ReleaseInterface failed.")));
        }
    }

    //
    // Release the tokens.
    //

    if(hOldToken) {
        CloseHandle(hOldToken);
    }

    //
    // Set the last error to win32 error code.
    //

    SetLastError(dwErr);

    //
    // Return.
    //

    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfile: returning %d"), bResult));
    return bResult;
}


//*************************************************************
//
//  CUserProfile::Initialize()
//
//      Initializes the class. Called by and only by console winlogon.
//
//  Return value:
//
//      This function does not return a value.
//
//  History:
//
//      Created         weiruc          2/29/2000
//
//*************************************************************

void CUserProfile::Initialize()
{
    LONG        lResult;
    HKEY        hkProfileList = NULL;
    DWORD       i = 0;
    TCHAR       tszSubKeyName[MAX_PATH];
    DWORD       dwcSubKeyName = MAX_PATH;
    FILETIME    ftLWT;      // last write time.
    HRESULT     hres;
    BOOL        bCSInitialized = FALSE;
    RPC_STATUS  status;
    

    DebugMsg((DM_VERBOSE, TEXT("Entering CUserProfile::Initialize ...")));


    //
    // If the caller is not winlogon, do nothing and return.
    //

    if(g_dwLoadFlags != WINLOGON_LOAD) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize called by non-winlogon process, %d"), g_dwLoadFlags));
        goto Exit;
    }
    bConsoleWinlogon = TRUE;

    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::Initialize called by winlogon")));


    //
    // If this function is already called, do nothing but return.
    //

    if(bInitialized) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize already called")));
        goto Exit;
    }

    //
    // Initialize the critical section that protects the map.
    //

    __try {
        if(!InitializeCriticalSectionAndSpinCount(&csMap, 0x80000000)) {
            DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize: InitializeCriticalSectionAndSpinCount failed with %08x"), GetLastError()));
            goto Exit;
        }
        bCSInitialized = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize: InitializeCriticalSection failed")));
        goto Exit;
    }
    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::Initialize: critical section initialized")));


    //
    // Initialize the whrc data
    //

    pMap = NULL;
    cTable.Initialize();
    
    
    //
    // Initialize the sync manager.
    //

    if(!cSyncMgr.Initialize()) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize: Initialize sync manager failed")));
        goto Exit;
    }


    //
    // Clean up the unloaded hives and undeleted profiles that we didn't handle
    // before last shutdown.
    //

    //
    // Open the profile list key.
    //

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           PROFILE_LIST_PATH,
                           0,
                           KEY_READ,
                           &hkProfileList);
    if(lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize:  Failed to open profile list key with error %d"), lResult));
        goto Exit;
    }
    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::Initialize: registry key %s opened"), PROFILE_LIST_PATH));

    //
    // Enumerate users.
    //

    i = 0;
    while((lResult = RegEnumKeyEx(hkProfileList,
                                  i,
                                  tszSubKeyName,
                                  &dwcSubKeyName,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &ftLWT)) == ERROR_SUCCESS) {
        
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::Initialize: Proccessing %s"), tszSubKeyName));
        CleanupUserProfile(tszSubKeyName, &hkProfileList);
        
        dwcSubKeyName = MAX_PATH;
        i++;
    }


    if(lResult != ERROR_SUCCESS && lResult != ERROR_NO_MORE_ITEMS) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize: RegEnumKeyEx returned %08x"), lResult));
    }

    //
    // Specify to use the local rpc protocol sequence 
    //

    status = RpcServerUseProtseqEp(cszRPCProtocol,                  // ncalrpc prot seq
                                   cdwMaxRpcCalls,                  // max concurrent calls
                                   cszRPCEndPoint,
                                   NULL);                           // Security descriptor
    if (status != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize: RpcServerUseProtseqEp fails with error %ld"), status));
        goto Exit;
    }
 
    //
    // Register the IUserProfile interface
    //

    status = RpcServerRegisterIfEx(IUserProfile_v1_0_s_ifspec,        // interface to register
                                   NULL,                              // MgrTypeUuid
                                   NULL,                              // MgrEpv; null means use default
                                   RPC_IF_AUTOLISTEN,                 // auto-listen interface
                                   cdwMaxRpcCalls,                    // max concurrent calls
                                   NULL);                             // no callback
    if (status != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize: RpcServerRegisterIfEx fails with error %ld"), status));
        goto Exit;
    }
 
    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::Initialize: RpcServerRegisterIfEx successful")));

    bInitialized = TRUE;

Exit:

    if(bInitialized == FALSE && bCSInitialized == TRUE) {
        DeleteCriticalSection(&csMap);
    }

    if(hkProfileList != NULL) {
        RegCloseKey(hkProfileList);
    }

    if(bInitialized == TRUE) {
        DebugMsg((DM_VERBOSE, TEXT("Exiting CUserProfile::Initialize, successful")));
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("Exiting CUserProfile::Initialize, unsuccessful")));
    }
}

//*************************************************************
//
//  CUserProfile::LoadUserProfileP()
//
//  Purpose:    Loads the user's profile, if unable to load
//              use the cached profile or issue the default profile.
//
//  Parameters: hTokenClient    -   the client who's trying to load the
//                                  user's profile. A NULL value indicate
//                                  that this is a in-proccess call.
//              hTokenUser      -   the user who's profile is being loaded.
//              lpProfileInfo   -   Profile Information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/6/95      ericflo    Created
//              6/27/00     weiruc     Made a private function called
//                                     by the win32 API LoadUserProfile to do
//                                     the actual work.
//
//*************************************************************

BOOL CUserProfile::LoadUserProfileP(HANDLE hTokenClient, HANDLE hTokenUser, LPPROFILEINFO lpProfileInfo, LPTSTR lpRPCEndPoint)
{
    LPPROFILE           lpProfile = NULL;
    BOOL                bResult = FALSE, bNewProfileLoaded = FALSE;
    HANDLE              hOldToken = NULL;
    HANDLE              hTmpToken = NULL;
    DWORD               dwRef, dwErr = ERROR_SUCCESS;
    LPTSTR              SidString = NULL;
    LPVOID              pEnv = NULL;
    NTSTATUS            status;
    BOOL                bInCS = FALSE;
    BOOL                bCSCBypassed = FALSE;
    TCHAR               cDrive;


    //
    // Initialize the debug flags.
    //

    InitDebugSupport( FALSE );
    
    DebugMsg((DM_VERBOSE, TEXT("In LoadUserProfileP")));

    if(hTokenClient && hTokenClient != INVALID_HANDLE_VALUE) {

        //
        // Check the client's identity
        //

        if (!IsUserAnAdminMember(hTokenClient) && !IsUserALocalSystemMember(hTokenClient)) {
            dwErr = ERROR_ACCESS_DENIED;
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Unable to load profile for client %08x. Not enough permission. Error %d."), hTokenClient, dwErr));
            goto Exit;
        }
        
        //
        // Run under the client's identity rather than winlogon's.
        //

        if(!ImpersonateUser(hTokenClient, &hTmpToken)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: ImpersonateUser <%08x> failed with %08x"), hTokenClient, dwErr));
            goto Exit;
        }
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Running as client")));
    }
    
    //
    //  Check Parameters
    //

    if (!lpProfileInfo) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: NULL lpProfileInfo")));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }


    if (!lpProfileInfo->lpUserName || !(*lpProfileInfo->lpUserName)) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: received a NULL pointer for lpUserName.")));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // if the profile path or default path is greater than MAX_PATH, ignore them.
    //

    if ((lpProfileInfo->lpProfilePath) && (lstrlen(lpProfileInfo->lpProfilePath) >= MAX_PATH)) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: long profile path name %s. ignoring"), lpProfileInfo->lpProfilePath));
        ReportError(hTokenUser, PI_NOUI, 1, EVENT_PROFILE_PATH_TOOLONG, lpProfileInfo->lpProfilePath);
        (lpProfileInfo->lpProfilePath)[0] = TEXT('\0');
    }

    if ((lpProfileInfo->lpDefaultPath) && (lstrlen(lpProfileInfo->lpDefaultPath) >= MAX_PATH)) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: long default profile path name %s. ignoring"), lpProfileInfo->lpDefaultPath));
        (lpProfileInfo->lpDefaultPath)[0] = TEXT('\0');
    }

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("=========================================================")));

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Entering, hToken = <0x%x>, lpProfileInfo = 0x%x"),
             hTokenUser, lpProfileInfo));

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->dwFlags = <0x%x>"),
             lpProfileInfo->dwFlags));

    if (lpProfileInfo->lpUserName) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpUserName = <%s>"),
                 lpProfileInfo->lpUserName));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL user name!")));
    }

    if (lpProfileInfo->lpProfilePath) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpProfilePath = <%s>"),
                 lpProfileInfo->lpProfilePath));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL central profile path")));
    }

    if (lpProfileInfo->lpDefaultPath) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpDefaultPath = <%s>"),
                 lpProfileInfo->lpDefaultPath));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL default profile path")));
    }

    if (lpProfileInfo->lpServerName) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpServerName = <%s>"),
                 lpProfileInfo->lpServerName));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL server name")));
    }

    if (lpProfileInfo->dwFlags & PI_APPLYPOLICY) {
        if (lpProfileInfo->lpPolicyPath) {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpPolicyPath = <%s>"),
                      lpProfileInfo->lpPolicyPath));
        } else {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL policy path")));
        }
    }


    //
    // Make sure someone isn't loading a profile during
    // GUI mode setup (eg: mapi)
    //

    if (IsGuiSetupInProgress()) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: LoadUserProfile can not be called during GUI mode setup.")));
        dwErr = ERROR_NOT_READY;
        goto Exit;
    }


    //
    // Wait for the profile setup event to be signalled
    //

    if (g_hProfileSetup) {
        if ((WaitForSingleObject (g_hProfileSetup, 600000) != WAIT_OBJECT_0)) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Failed to wait on the profile setup event.  Error = %d."),
                      GetLastError()));
            dwErr = GetLastError();
            goto Exit;
        }
    }

    //
    // Get the user's sid in string form
    //

    SidString = GetSidString(hTokenUser);

    if (!SidString) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile:  Failed to get sid string for user")));
        goto Exit;
    }
    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: User sid: %s"), SidString));

    //
    // Enter the critical section.
    //

    if(!cSyncMgr.EnterLock(SidString, lpRPCEndPoint)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile:: Failed to get the user profile lock")));
        goto Exit;
    }
    bInCS = TRUE;
    

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Wait succeeded. In critical section.")));


    //-------------------  BEGIN CRITICAL SECTION ------------------------
    //
    // We are in the critical section at this point, no doddling now...
    //

    //
    // Check if the profile is loaded already.
    //

    if (TestIfUserProfileLoaded(hTokenUser, lpProfileInfo)) {
        DWORD  dwFlags = lpProfileInfo->dwFlags;

        //
        // This profile is already loaded.  Grab the info from the registry
        // and add the missing chunks.
        //

        lpProfile = LoadProfileInfo(hTokenClient, hTokenUser, (HKEY)lpProfileInfo->hProfile);

        if (!lpProfile) {
            RegCloseKey ((HKEY)lpProfileInfo->hProfile);
            lpProfileInfo->hProfile = NULL;
            dwErr = GetLastError();
            goto Exit;
        }

        //
        // LoadProfileInfo will overwrite the dwFlags field with the
        // value from the previous profile loading.  Restore the flags.
        //

        lpProfile->dwFlags = dwFlags;

        if (lpProfile->dwFlags & PI_LITELOAD) {
            lpProfile->dwFlags |= PI_NOUI;
        }


        //
        // LoadProfileInfo doesn't restore username, servername, policypath so
        // special case these.
        //

        lpProfile->lpUserName = (LPTSTR)LocalAlloc (LPTR, (lstrlen(lpProfileInfo->lpUserName) + 1) * sizeof(TCHAR));

        if (!lpProfile->lpUserName) {
            RegCloseKey ((HKEY)lpProfileInfo->hProfile);
            dwErr = GetLastError();
            goto Exit;
        }

        lstrcpy (lpProfile->lpUserName, lpProfileInfo->lpUserName);

        if (lpProfileInfo->lpServerName) {
            lpProfile->lpServerName = (LPTSTR)LocalAlloc (LPTR, (lstrlen(lpProfileInfo->lpServerName) + 1) * sizeof(TCHAR));

            if (lpProfile->lpServerName) {
                lstrcpy (lpProfile->lpServerName, lpProfileInfo->lpServerName);
            }
        }

        if (lpProfileInfo->dwFlags & PI_APPLYPOLICY) {
            if (lpProfileInfo->lpPolicyPath) {
                lpProfile->lpPolicyPath = (LPTSTR)LocalAlloc (LPTR, (lstrlen(lpProfileInfo->lpPolicyPath) + 1) * sizeof(TCHAR));

                if (lpProfile->lpPolicyPath) {
                    lstrcpy (lpProfile->lpPolicyPath, lpProfileInfo->lpPolicyPath);
                }
            }
        }

        //
        // If the profile is already loaded because it was leaked,
        // then the classes root may not be loaded.  Insure that it
        // is loaded.
        //

        if (!(lpProfile->dwFlags & PI_LITELOAD)) {
            dwErr = LoadUserClasses( lpProfile, SidString, FALSE );

            if (dwErr != ERROR_SUCCESS) {

                LPTSTR szErr = NULL;

                szErr = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
                if (!szErr) {
                    dwErr = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("LoadUserProfileP: Out of memory")));
                    goto Exit;
                }

                //
                // If the user is an Admin, then let him/her log on with
                // either the .default profile, or an empty profile.
                //

                if (IsUserAnAdminMember(lpProfile->hTokenUser)) {
                    ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_ADMIN_OVERRIDE, GetErrString(dwErr, szErr));

                    dwErr = ERROR_SUCCESS;
                    LocalFree(szErr);
                } 
                else {
                    DebugMsg((DM_WARNING, TEXT("LoadUserProfileP: Could not load the user class hive. Error = %d"), dwErr));
                    ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_FAILED_LOAD_PROFILE, GetErrString(dwErr, szErr));

                    RegCloseKey ((HKEY)lpProfileInfo->hProfile);
                    lpProfileInfo->hProfile = NULL;
                    LocalFree(szErr);
                    goto Exit;
                }
            }

        }

        //
        // Jump to the end of the profile loading code.
        //

        goto ProfileLoaded;
    }


    //
    // If we are here, the profile isn't loaded yet, so we are
    // starting from scratch.
    //

    //
    // Clone the process's environment block. This is passed to CreateProcess
    // by userdiff and system policy because they rely on the USERPROFILE
    // environment variable, but setting USERPROFILE for the whole process
    // is not thread safe.
    //
    
    status = RtlCreateEnvironment(TRUE, &pEnv);
    if(!NT_SUCCESS(status)) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: RtlCreateEnvironment returned %08x"), status));
        dwErr = status;
        goto Exit;
    }

    //
    // Allocate an internal Profile structure to work with.
    //

    lpProfile = (LPPROFILE) LocalAlloc (LPTR, sizeof(USERPROFILE));

    if (!lpProfile) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Failed to allocate memory")));
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // Save the data passed in.
    //

    lpProfile->dwFlags = lpProfileInfo->dwFlags;

    //
    // No UI in case of Lite_Load
    //

    if (lpProfile->dwFlags & PI_LITELOAD) {
        lpProfile->dwFlags |= PI_NOUI;
    }

    lpProfile->dwUserPreference = GetUserPreferenceValue(hTokenUser);
    lpProfile->hTokenUser = hTokenUser;
    lpProfile->hTokenClient = hTokenClient;

    lpProfile->lpUserName = (LPTSTR)LocalAlloc (LPTR, (lstrlen(lpProfileInfo->lpUserName) + 1) * sizeof(TCHAR));

    if (!lpProfile->lpUserName) {
        dwErr = GetLastError();
        goto Exit;
    }

    lstrcpy (lpProfile->lpUserName, lpProfileInfo->lpUserName);

    if (lpProfileInfo->lpDefaultPath) {

        lpProfile->lpDefaultProfile = (LPTSTR)LocalAlloc (LPTR, (lstrlen(lpProfileInfo->lpDefaultPath) + 1) * sizeof(TCHAR));

        if (lpProfile->lpDefaultProfile) {
            lstrcpy (lpProfile->lpDefaultProfile, lpProfileInfo->lpDefaultPath);
        }
    }

    if (lpProfileInfo->lpProfilePath) {
        lpProfile->lpProfilePath = AllocAndExpandProfilePath (lpProfileInfo);
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Expanded profile path is %s"),
                  lpProfile->lpProfilePath?lpProfile->lpProfilePath:TEXT("NULL")));
    }

    if (lpProfileInfo->lpServerName) {
        lpProfile->lpServerName = (LPTSTR)LocalAlloc (LPTR, (lstrlen(lpProfileInfo->lpServerName) + 1) * sizeof(TCHAR));

        if (lpProfile->lpServerName) {
            lstrcpy (lpProfile->lpServerName, lpProfileInfo->lpServerName);
        }
    }

    if (lpProfileInfo->dwFlags & PI_APPLYPOLICY) {
        if (lpProfileInfo->lpPolicyPath) {
            lpProfile->lpPolicyPath = (LPTSTR)LocalAlloc (LPTR, (lstrlen(lpProfileInfo->lpPolicyPath) + 1) * sizeof(TCHAR));

            if (lpProfile->lpPolicyPath) {
                lstrcpy (lpProfile->lpPolicyPath, lpProfileInfo->lpPolicyPath);
            }
        }
    }

    lpProfile->lpLocalProfile = (LPTSTR)LocalAlloc (LPTR, MAX_PATH * sizeof(TCHAR));

    if (!lpProfile->lpLocalProfile) {
        dwErr = GetLastError();
        goto Exit;
    }

    lpProfile->lpRoamingProfile = (LPTSTR)LocalAlloc (LPTR, MAX_PATH * sizeof(TCHAR));

    if (!lpProfile->lpRoamingProfile) {
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // If there is a central profile, check for 3.x or 4.0 format.
    //

    if (lpProfileInfo->lpProfilePath && (*lpProfileInfo->lpProfilePath)) {

        //
        // Call ParseProfilePath to work some magic on it
        //

        if (!ParseProfilePath(lpProfile, lpProfile->lpProfilePath, &bCSCBypassed, &cDrive)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: ParseProfilePath returned FALSE")));
            goto Exit;
        }

        //
        // The real central profile directory is...
        //

        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: ParseProfilePath returned a directory of <%s>"),
                  lpProfile->lpRoamingProfile));
    }

    //
    // Load the user's profile
    //

    if (!RestoreUserProfile(lpProfile)) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: RestoreUserProfile returned FALSE")));
        dwErr = GetLastError();
        goto Exit;
    }

    GetSystemTimeAsFileTime (&lpProfile->ftProfileLoad);

    //
    // Save the profile information in the registry
    //

    SaveProfileInfo (lpProfile);

    //
    // Set the USERPROFILE environment variable into the block.
    // This allows ExpandEnvironmentStrings to be used
    // in the userdiff processing.
    //

    if(pEnv) {
        SetEnvironmentVariableInBlock(&pEnv, TEXT("USERPROFILE"), lpProfile->lpLocalProfile, TRUE);
    }

    //
    // Flush the special folder pidls stored in shell32.dll
    //

    FlushSpecialFolderCache();

    //
    // Set attributes on ntuser.ini
    //

    SetNtUserIniAttributes(lpProfile->lpLocalProfile);


    //
    // Upgrade the profile if appropriate.
    //

    if (!(lpProfileInfo->dwFlags & PI_LITELOAD)) {
        if(pEnv) {
            if (!UpgradeProfile(lpProfile, pEnv)) {
                DebugMsg((DM_WARNING, TEXT("LoadUserProfile: UpgradeProfile returned FALSE")));
            }
        }
        else {
            if (!UpgradeProfile(lpProfile, GetEnvironmentStrings())) {
                DebugMsg((DM_WARNING, TEXT("LoadUserProfile: UpgradeProfile returned FALSE")));
            }
        }
    }


    //
    // Prepare the profile for use on this machine
    //

    PrepareProfileForUse (lpProfile, pEnv);

    bNewProfileLoaded = TRUE;


ProfileLoaded:

    //
    // Increment the profile Ref count
    //

    dwRef = IncrementProfileRefCount(lpProfile, bNewProfileLoaded);

    if (!bNewProfileLoaded && (dwRef <= 1)) {
        DebugMsg((DM_WARNING, TEXT("Profile was loaded but the Ref Count is %d !!!"), dwRef));
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("Profile Ref Count is %d"), dwRef));
    }

    //
    // This will leave the critical section so other threads/process can
    // continue.
    //

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Leaving critical Section.")));
    if(cSyncMgr.LeaveLock(SidString)) {
        bInCS = FALSE;
    }
    else {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: User profile lock not released %08x"), GetLastError()));
    }


    //
    // Notify LSA that the profile has loaded 
    //

    if (!ImpersonateUser(hTokenUser, &hOldToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Failed to impersonate user with %d."), dwErr ));
        goto Exit;
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Impersonated user: %08x, %08x"), hTokenUser, hOldToken));
    }

    if (!CredProfileLoaded()) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Failed to notify LSA that profile loaded %d."), dwErr ));
        RevertToUser(&hOldToken);
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Reverted to user: %08x"), hOldToken));
        goto Exit;
    }

    RevertToUser(&hOldToken);
    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Reverted to user: %08x"), hOldToken));

    
    //
    // The critical section is now released so we can do slower things like
    // apply policy...
    //
    //-------------------  END MUTEX SECTION ------------------------


    //
    // Apply Policy
    //

    if (lpProfile->dwFlags & PI_APPLYPOLICY) {
        //
        // Group Policy does not run on personal
        //
        OSVERSIONINFOEXW version;
        version.dwOSVersionInfoSize = sizeof(version);
        if ( !GetVersionEx( (LPOSVERSIONINFO) &version ) )
        {
            return ERROR_SUCCESS;
        }
        else
        {
            if ( ( version.wSuiteMask & VER_SUITE_PERSONAL ) != 0 )
            {
                return ERROR_SUCCESS;
            }
        }

        if (!ApplySystemPolicy((SP_FLAG_APPLY_MACHINE_POLICY | SP_FLAG_APPLY_USER_POLICY),
                               lpProfile->hTokenUser, lpProfile->hKeyCurrentUser,
                               lpProfile->lpUserName, lpProfile->lpPolicyPath,
                               lpProfile->lpServerName)) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: ApplySystemPolicy returned FALSE")));
        }
    }

    //
    // Save the outgoing parameters
    //

    lpProfileInfo->hProfile = (HANDLE) lpProfile->hKeyCurrentUser;

    //
    // Success!
    //

    bResult = TRUE;
    
Exit:

    if (bCSCBypassed) {
        CancelCSCBypassedConnection(lpProfile->hTokenUser, cDrive);
    }

    if(bInCS) {
        cSyncMgr.LeaveLock(SidString);
    }


    if(SidString) {
        DeleteSidString(SidString);
    }


    //
    // Free the structure
    //

    if (lpProfile) {

        if (lpProfile->lpUserName) {
            LocalFree (lpProfile->lpUserName);
        }

        if (lpProfile->lpDefaultProfile) {
            LocalFree (lpProfile->lpDefaultProfile);
        }

        if (lpProfile->lpProfilePath) {
            LocalFree (lpProfile->lpProfilePath);
        }

        if (lpProfile->lpServerName) {
            LocalFree (lpProfile->lpServerName);
        }

        if (lpProfile->lpPolicyPath) {
            LocalFree (lpProfile->lpPolicyPath);
        }

        if (lpProfile->lpLocalProfile) {
            LocalFree (lpProfile->lpLocalProfile);
        }

        if (lpProfile->lpRoamingProfile) {
            LocalFree (lpProfile->lpRoamingProfile);
        }

        if (lpProfile->lpExclusionList) {
            LocalFree (lpProfile->lpExclusionList);
        }

        //
        // Caller will release these handles.
        //

        lpProfile->hTokenClient = NULL;
        lpProfile->hTokenUser = NULL;

        LocalFree (lpProfile);
    }

    //
    // Free the cloned environment block.
    //

    if (pEnv) {
        RtlDestroyEnvironment(pEnv);
    }

    //
    // Revert to ourselves
    //

    if(hTokenClient && hTokenClient != INVALID_HANDLE_VALUE) {
        RevertToUser(&hTmpToken);
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Reverted back to user <%08x>"), hTmpToken));
    }

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Leaving with a value of %d."), bResult));

    DebugMsg((DM_VERBOSE, TEXT("=========================================================")));

    SetLastError(dwErr);
    return bResult;
}

//*************************************************************
//
//  CUserProfile::UnloadUserProfileP()
//
//  Purpose:    Unloads the user's profile.
//
//  Parameters: hTokenClient    -   The client who's trying to load
//                                  the user's profile.
//              hTokenUser      -   User's token
//              hProfile        -   Profile handle
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/7/95      ericflo    Created
//              6/27/00     weiruc     Modified to be a private function
//                                     called by UnloadUserProfile to do
//                                     the actual work.
//
//*************************************************************

BOOL CUserProfile::UnloadUserProfileP(HANDLE hTokenClient, HANDLE hTokenUser, HKEY hProfile, LPTSTR lpRPCEndPoint)
{
    LPPROFILE lpProfile=NULL;
    LPTSTR lpSidString = NULL, lpEnd, SidStringTemp = NULL;
    LONG err, IgnoreError, lResult;
    BOOL bProfileCopied = FALSE, bRetVal = FALSE, bDeleteCache, bRoaming = FALSE;
    HKEY hKey;
    DWORD dwSize, dwType, dwDisp;
    LPTSTR szExcludeList1 = NULL;
    LPTSTR szExcludeList2 = NULL;
    LPTSTR szExcludeList = NULL;
    LPTSTR szBuffer = NULL;
    DWORD dwFlags, dwRef = 0;
    HANDLE hOldToken = NULL;
    HANDLE hTmpToken = NULL;
    DWORD dwErr=0, dwErr1 = ERROR_SUCCESS, dwCSCErr;  // dwErr1 is what gets set in SetLastError()
    LPTSTR szErr = NULL;
    LPTSTR szKeyName = NULL;
    DWORD dwCopyTmpHive = 0;
    DWORD dwWatchHiveFlags = 0;
    LPTSTR tszTmpHiveFile = NULL;
    BOOL bUnloadHiveSucceeded = TRUE;
    BOOL bInCS = FALSE;
    BOOL bCSCBypassed = FALSE;
    LPTSTR lpCscBypassedPath = NULL;
    TCHAR  cDrive;
    
    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Entering, hProfile = <0x%x>"), hProfile));

    //
    // Run under the client's identity rather than winlogon's.
    //

    if(hTokenClient && hTokenClient != INVALID_HANDLE_VALUE) {
        if(!ImpersonateUser(hTokenClient, &hTmpToken)) {
            dwErr1 = GetLastError();
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP: ImpersonateUser <%08x> failed with %08x"), hTokenClient, dwErr1));
            RegCloseKey((HKEY)hProfile);
            goto Exit;
        }
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: ImpersonateUser <%08x>, old token is <%08x>"), hTokenClient, hTmpToken));
    }
    
    //
    // Get the Sid string for the current user
    //

    lpSidString = GetProfileSidString(hTokenUser);

    if (!lpSidString) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP: Failed to get sid string for user %08x"), dwErr1));
        RegCloseKey((HKEY)hProfile);
        goto Exit;
    }

    //
    // Load profile information
    //

    lpProfile = LoadProfileInfo(hTokenClient, hTokenUser, (HKEY)hProfile);

    if (!lpProfile) {
        dwErr1 = GetLastError();
        RegCloseKey((HKEY)hProfile);
        goto Exit;
    }

    //
    // Get the user's sid in string form
    //

    SidStringTemp = GetSidString(hTokenUser);

    if (!SidStringTemp) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  Failed to get sid string for user")));
        RegCloseKey(lpProfile->hKeyCurrentUser);
        goto Exit;
    }

    // 
    // Allocate memory for Local variables to avoid stack overflow
    //

    szKeyName = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szKeyName) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnLoadUserProfileP: Out of memory")));
        goto Exit;
    }

    szErr = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szErr) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnLoadUserProfileP: Out of memory")));
        goto Exit;
    }

    szBuffer = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szBuffer) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnLoadUserProfileP: Out of memory")));
        goto Exit;
    }

    // Store the actual roaming profile path before mapping it to drive

    lpProfile->lpProfilePath = lpProfile->lpRoamingProfile;

    // 
    // Try to bypass CSC to avoid conflicts in syncing files between roaming share & local profile
    //

    if (IsUNCPath(lpProfile->lpRoamingProfile)) {
        if ((dwCSCErr = AbleToBypassCSC(hTokenUser, lpProfile->lpRoamingProfile, &lpCscBypassedPath, &cDrive)) == ERROR_SUCCESS) {
            bCSCBypassed = TRUE;
            lpProfile->lpRoamingProfile = lpCscBypassedPath;
            DebugMsg((DM_VERBOSE, TEXT("UnLoadUserProfileP: CSC bypassed.")));
        }
        else {
            if (dwCSCErr == WN_BAD_LOCALNAME || dwCSCErr == WN_ALREADY_CONNECTED || dwCSCErr == ERROR_BAD_PROVIDER) {
                DebugMsg((DM_VERBOSE, TEXT("UnLoadUserProfileP: CSC bypassed failed. Profile path %s"), lpProfile->lpRoamingProfile));
            }
            else {
                // Share is not up. So we do not need to do any further check
                lpProfile->lpRoamingProfile = NULL;
                DebugMsg((DM_VERBOSE, TEXT("UnLoadUserProfileP: CSC bypassed failed. Ignoring Roaming profile path")));
            }
        }    
    }

    //
    // Check for a list of directories to exclude both user preferences
    // and user policy
    //

    szExcludeList1 = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szExcludeList1) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnLoadUserProfileP: Out of memory")));
        goto Exit;
    }

    szExcludeList2 = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szExcludeList2) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnLoadUserProfileP: Out of memory")));
        goto Exit;
    }

    szExcludeList = (LPTSTR)LocalAlloc(LPTR, 2*MAX_PATH*sizeof(TCHAR));
    if (!szExcludeList) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnLoadUserProfileP: Out of memory")));
        goto Exit;
    }

    szExcludeList1[0] = TEXT('\0');
    if (RegOpenKeyEx (lpProfile->hKeyCurrentUser,
                      WINLOGON_KEY,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = MAX_PATH*sizeof(TCHAR);
        RegQueryValueEx (hKey,
                         TEXT("ExcludeProfileDirs"),
                         NULL,
                         &dwType,
                         (LPBYTE) szExcludeList1,
                         &dwSize);

        RegCloseKey (hKey);
    }

    szExcludeList2[0] = TEXT('\0');
    if (RegOpenKeyEx (lpProfile->hKeyCurrentUser,
                      SYSTEM_POLICIES_KEY,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = MAX_PATH*sizeof(TCHAR);
        RegQueryValueEx (hKey,
                         TEXT("ExcludeProfileDirs"),
                         NULL,
                         &dwType,
                         (LPBYTE) szExcludeList2,
                         &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Merge the user preferences and policy together
    //

    szExcludeList[0] = TEXT('\0');

    if (szExcludeList1[0] != TEXT('\0')) {
        CheckSemicolon(szExcludeList1);
        lstrcpy (szExcludeList, szExcludeList1);
    }

    if (szExcludeList2[0] != TEXT('\0')) {
        lstrcat (szExcludeList, szExcludeList2);
    }

    //
    // Check if the cached copy of the profile should be deleted
    //

    bDeleteCache = IsCacheDeleted();


    //
    // Enter the critical section.
    //

    if(!cSyncMgr.EnterLock(SidStringTemp, lpRPCEndPoint)) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:: Failed to get the user profile lock %08x"), dwErr1));
        goto Exit;
    }
    bInCS = TRUE;
    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Wait succeeded.  In critical section.")));

    //
    // Flush out the profile which will also sync the log.
    //

    err = RegFlushKey(lpProfile->hKeyCurrentUser);
    if (err != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  Failed to flush the current user key, error = %d"), err));
    }


    //
    // Close the current user key that was opened in LoadUserProfile.
    //

    err = RegCloseKey(lpProfile->hKeyCurrentUser);
    if (err != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  Failed to close the current user key, error = %d"), err));
    }


    dwRef = DecrementProfileRefCount(lpProfile);

    if (dwRef != 0) {
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP:  Didn't unload user profile, Ref Count is %d"), dwRef));
        bRetVal = TRUE;
        goto Exit;
    }


    //
    //  Unload the user profile
    //

    err = MyRegUnLoadKey(HKEY_USERS, lpSidString);

    if (!err) {

        if((dwErr1 = GetLastError()) == ERROR_ACCESS_DENIED) {

            //
            // We failed to unload the hive due to leaked reg keys.
            //

            dwWatchHiveFlags |= WHRC_UNLOAD_HIVE;

            if (!(lpProfile->dwFlags & PI_LITELOAD)) {

                //
                // Call Special Registry APIs to dump handles
                // only if it is not called through Lite_load
                // there are known problems with liteLoad loading because
                // of which eventlog can get full during stress
                //

                lstrcpy(szKeyName, TEXT("\\Registry\\User\\"));
                lstrcat(szKeyName, lpSidString);
                DumpOpenRegistryHandle(szKeyName);
            }        
        }

        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP: Didn't unload user profile <err = %d>"), GetLastError()));

        //
        // Only in the case of reg leak do we want to call WatchHiveRefCount.
        // So use this flag to tell later code the the hive failed to
        // unload, no matter what the reason.
        //

        bUnloadHiveSucceeded = FALSE;
    } else {
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP:  Succesfully unloaded profile")));
    }


    //
    //  Unload HKCU
    //

    if (!(lpProfile->dwFlags & PI_LITELOAD)) {
        
        err = UnloadClasses(lpSidString);

        if (!err) {

            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP:  Didn't unload user classes.")));

            if((dwErr1 = GetLastError()) == ERROR_ACCESS_DENIED) {
            
                //
                // Call Special Registry APIs to dump handles
                //

                lstrcpy(szKeyName, TEXT("\\Registry\\User\\"));
                lstrcat(szKeyName, lpSidString);
                lstrcat(szKeyName, TEXT("_Classes"));

                DumpOpenRegistryHandle(szKeyName);

                ReportError(hTokenUser, PI_NOUI | EVENT_WARNING_TYPE, 0, EVENT_FAILED_CLASS_HIVE_UNLOAD);

                dwWatchHiveFlags = dwWatchHiveFlags | WHRC_UNLOAD_CLASSESROOT;
            }

            bRetVal = TRUE;
        } else {
            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP:  Successfully unloaded user classes")));
        }
    }


    //
    // Figure out if we need to do anything special in the event of registry
    // key leak.
    //

    if(dwWatchHiveFlags != 0 || !bUnloadHiveSucceeded) {
        tszTmpHiveFile = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
        if (!tszTmpHiveFile) {
            dwErr1 = GetLastError();
            DebugMsg((DM_WARNING, TEXT("UnLoadUserProfileP: Out of memory")));
            goto Exit;
        }

        dwErr = HandleRegKeyLeak(lpSidString,
                                 lpProfile,
                                 bUnloadHiveSucceeded,
                                 &dwWatchHiveFlags,
                                 &dwCopyTmpHive,
                                 tszTmpHiveFile);

        //
        // If registry leak is handled successfully, the last error code should
        // be ERROR_SUCCESS. Otherwise, it should be whatever MyRegUnLoadKey
        // returned, which is in dwErr1.
        //
        if(dwErr == ERROR_SUCCESS) {
            dwErr1 = dwErr;
        }
    }

    //
    // If this is a mandatory or a guest profile, unload it now,
    // Guest profiles are always deleted so one guest can't see
    // the profile of a previous guest. Only do this if the user's
    // hive had been successfully unloaded.
    //

    if ((lpProfile->dwInternalFlags & PROFILE_MANDATORY) ||
        (lpProfile->dwInternalFlags & PROFILE_READONLY) ||
        (lpProfile->dwInternalFlags & PROFILE_GUEST_USER)) {

        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP:  flushing HKEY_USERS")));

        IgnoreError = RegFlushKey(HKEY_USERS);
        if (IgnoreError != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  Failed to flush HKEY_USERS, error = %d"), IgnoreError));
        }


        // Don't delete the guest account if machine is in workgroup 
        INT iRole;

        if (bDeleteCache || 
            ((lpProfile->dwInternalFlags & PROFILE_GUEST_USER) && 
             GetMachineRole(&iRole) && (iRole != 0))) {

            //
            // Delete the profile, including all other user related stuff
            //

            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: deleting profile because it is a guest user or cache needs to be deleted")));

            if (!DeleteProfile (lpSidString, NULL, NULL)) {
                DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  DeleteProfileDirectory returned false.  Error = %d"), GetLastError()));
            }
            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Successfully deleted profile because it is a guest/mandatory user")));
        }

        if (err) {
            bRetVal = TRUE;
        }


        if (lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED) {

            //
            // Just delete the user profile, backup should never exist for mandatory profile
            //

            if (!DeleteProfileEx (lpSidString, lpProfile->lpLocalProfile, 0, HKEY_LOCAL_MACHINE, NULL)) {
                DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  DeleteProfileDirectory returned false (2).  Error = %d"), GetLastError()));
            }
        }

        goto Exit;
    }

    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP: Failed to impersonate user")));
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Impersonated user")));
    
    //
    // Copy local profileimage to remote profilepath
    //

    if ( ((lpProfile->dwInternalFlags & PROFILE_UPDATE_CENTRAL) ||
          (lpProfile->dwInternalFlags & PROFILE_NEW_CENTRAL)) &&  
         !(lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED) ) {

        if ((lpProfile->dwUserPreference != USERINFO_LOCAL) &&
            !(lpProfile->dwInternalFlags & PROFILE_SLOW_LINK)) {

            //
            // Copy to the profile path
            //

            if (lpProfile->lpRoamingProfile && *lpProfile->lpRoamingProfile) {
                BOOL bRoamDirectoryExist;

                DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP:  Copying profile back to %s"),
                                lpProfile->lpRoamingProfile));

                bRoaming = TRUE;

                //
                // Check roaming profile directory exist or not. If not exist, try to create it with proper acl's
                //

                bRoamDirectoryExist = TRUE;
                if (GetFileAttributes(lpProfile->lpRoamingProfile) == -1) {

                    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Roaming profile directory does not exist.")));

                    //
                    // Check whether we need to give access to the admin on the RUP share
                    //

                    //
                    // Check for a roaming profile security preference
                    //
 
                    BOOL  bAddAdminGroup = FALSE;

                    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ,
                                     &hKey) == ERROR_SUCCESS) {

                        dwSize = sizeof(bAddAdminGroup);
                        RegQueryValueEx(hKey, ADD_ADMIN_GROUP_TO_RUP, NULL, NULL,
                                        (LPBYTE) &bAddAdminGroup, &dwSize);

                        RegCloseKey(hKey);
                    }


                    //
                    // Check for a roaming profile security policy
                    //

                    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY, 0, KEY_READ,
                                     &hKey) == ERROR_SUCCESS) {

                        dwSize = sizeof(bAddAdminGroup);
                        RegQueryValueEx(hKey, ADD_ADMIN_GROUP_TO_RUP, NULL, NULL,
                                        (LPBYTE) &bAddAdminGroup, &dwSize);

 
                        RegCloseKey(hKey);
                    } 

                    if (!CreateSecureDirectory(lpProfile, lpProfile->lpRoamingProfile, NULL, !bAddAdminGroup) ) {
                    
                        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP: CreateSecureDirectory failed to create roaming profile directory.")));
                        bRoamDirectoryExist = FALSE;
                        bProfileCopied = FALSE;
                    }
                    lpProfile->dwInternalFlags |= PROFILE_NEW_CENTRAL; // Since we created a empty profile now
                }

                
                if (bRoamDirectoryExist) {

                    DWORD dwAttributes, dwStart, dwDelta;

                    //
                    // We have to call GetFileAttributes twice.  The
                    // first call sets up the session so we can call it again and
                    // get accurate timing information for slow link detection.
                    //


                    dwAttributes = GetFileAttributes(lpProfile->lpProfilePath);

                    if (dwAttributes != -1) {
                        //
                        // if it is success, find out whether the profile is
                        // across a slow link.
                        //

                        dwStart = GetTickCount();

                        dwAttributes = GetFileAttributes(lpProfile->lpProfilePath);

                        dwDelta = GetTickCount() - dwStart;

                        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Tick Count = %d"), dwDelta));

                        CheckForSlowLink (lpProfile, dwDelta, lpProfile->lpProfilePath, FALSE);
                        if (lpProfile->dwInternalFlags & PROFILE_SLOW_LINK) {
                            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Profile is across a slow link. Do not sync roaming profile")));
                        }
                    }
                }

                if (!(lpProfile->dwInternalFlags & PROFILE_SLOW_LINK)) {
                    if (bRoamDirectoryExist) {

                        //
                        // Copy the profile
                        //

                        dwFlags = (lpProfile->dwFlags & PI_NOUI) ? CPD_NOERRORUI : 0;
                        dwFlags |= (lpProfile->dwFlags & (PI_LITELOAD | PI_HIDEPROFILE)) ? (CPD_SYSTEMFILES | CPD_SYSTEMDIRSONLY) :
                                                                    (CPD_SYNCHRONIZE | CPD_NONENCRYPTEDONLY);

                        dwFlags |= CPD_USEDELREFTIME |
                                   CPD_USEEXCLUSIONLIST | CPD_DELDESTEXCLUSIONS;

                        bProfileCopied = CopyProfileDirectoryEx (lpProfile->lpLocalProfile,
                                                       lpProfile->lpRoamingProfile,
                                                       dwFlags | dwCopyTmpHive,
                                                       &lpProfile->ftProfileLoad,
                                                       (szExcludeList[0] != TEXT('\0')) ?
                                                       szExcludeList : NULL);

                    }

                    //
                    // Save the exclusion list we used for the profile copy
                    //

                    if (bProfileCopied) {
                        // save it on the roaming profile.
                        lstrcpy (szBuffer, lpProfile->lpRoamingProfile);
                        lpEnd = CheckSlash (szBuffer);
                        lstrcpy (lpEnd, c_szNTUserIni);

                        bProfileCopied = WritePrivateProfileString (PROFILE_GENERAL_SECTION,
                                                   PROFILE_EXCLUSION_LIST,
                                                   (szExcludeList[0] != TEXT('\0')) ?
                                                   szExcludeList : NULL,
                                                   szBuffer);

                        if (lpProfile->dwInternalFlags & PROFILE_NEW_CENTRAL) {
                            bProfileCopied = WritePrivateProfileString (PROFILE_LOAD_TYPE,
                                                       PROFILE_LAST_UPLOAD_STATE,
                                                       (lpProfile->dwFlags & PI_LITELOAD) ?
                                                       PARTIAL_PROFILE : COMPLETE_PROFILE,
                                                       szBuffer);
                        }
                        else if (IsPartialRoamingProfile(lpProfile)) {
                            bProfileCopied = WritePrivateProfileString (PROFILE_LOAD_TYPE,
                                                       PROFILE_LAST_UPLOAD_STATE,
                                                       (lpProfile->dwFlags & PI_LITELOAD) ?
                                                       PARTIAL_PROFILE : COMPLETE_PROFILE,
                                                       szBuffer);
                        }

                        if (!bProfileCopied) {
                            DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP: Failed to write to ntuser.ini on profile server with error 0x%x"), GetLastError()));
                            dwErr = GetLastError();
                        }
                        else {
                            SetFileAttributes (szBuffer, FILE_ATTRIBUTE_HIDDEN);
                        }
                    }
                    else {
                        dwErr = GetLastError();

                        if (dwErr == ERROR_FILE_ENCRYPTED) {
                            ReportError(hTokenUser, lpProfile->dwFlags, 0, EVENT_PROFILEUPDATE_6002);
                        }
                    }

                    //
                    // Check return value
                    //

                    if (bProfileCopied) {
                 
                        //
                        // The profile is copied, now we want to make sure the timestamp on
                        // both the remote profile and the local copy are the same, so we don't
                        // ask the user to update when it's not necessary. In the case we 
                        // save the hive to a temporary file and
                        // upload from the tmp file rather than the actual hive file. Do not
                        // synchronize the profile time in this case because the hive file
                        // will still be in use and there's no point in setting time on the
                        // tmp hive file because it will be deleted after we upload it.
                        //

                        if(bUnloadHiveSucceeded) {
                            SetProfileTime(lpProfile);
                        }
                    } else {
                        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  CopyProfileDirectory returned FALSE for primary profile.  Error = %d"), dwErr));
                        ReportError(hTokenUser, lpProfile->dwFlags, 1, EVENT_CENTRAL_UPDATE_FAILED, GetErrString(dwErr, szErr));
                    }
                }
            }
            else {
                DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  Network share not available.")));
                ReportError(hTokenUser, lpProfile->dwFlags, 1, EVENT_CENTRAL_UPDATE_FAILED, GetErrString(dwCSCErr, szErr));
            }
        }
    }

    //
    // if it is roaming, write only if copy succeeded otherwise write
    //

    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Writing local ini file")));
    if (!bRoaming || bProfileCopied) {

        //
        // Mark the file with system bit before trying to write to it
        //

        SetNtUserIniAttributes(lpProfile->lpLocalProfile);

        // save it locally

        lstrcpy (szBuffer, (lpProfile->lpLocalProfile));
        lpEnd = CheckSlash (szBuffer);
        lstrcpy (lpEnd, c_szNTUserIni);

        err = WritePrivateProfileString (PROFILE_GENERAL_SECTION,
                                        PROFILE_EXCLUSION_LIST,
                                        (szExcludeList[0] != TEXT('\0')) ?
                                        szExcludeList : NULL,
                                        szBuffer);

        if (!err) {
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP: Failed to write to ntuser.ini on client with error 0x%x"), GetLastError()));
            dwErr = GetLastError();
        }
    }


    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP: Failed to revert to self")));
    }

    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Reverting to Self")));

    //
    // Save the profile unload time
    //

    if (bProfileCopied && !bDeleteCache && !(lpProfile->dwFlags & PI_LITELOAD) &&
        !(lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED)) {

        GetSystemTimeAsFileTime (&lpProfile->ftProfileUnload);

        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfile: Got the System Time")));

        lstrcpy(szBuffer, PROFILE_LIST_PATH);
        lpEnd = CheckSlash (szBuffer);
        lstrcpy(lpEnd, lpSidString);

        lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, 0, 0,
                                 KEY_WRITE, NULL, &hKey, &dwDisp);

        if (lResult == ERROR_SUCCESS) {

            lResult = RegSetValueEx (hKey,
                                     PROFILE_UNLOAD_TIME_LOW,
                                     0,
                                     REG_DWORD,
                                     (LPBYTE) &lpProfile->ftProfileUnload.dwLowDateTime,
                                     sizeof(DWORD));

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  Failed to save low profile load time with error %d"), lResult));
            }


            lResult = RegSetValueEx (hKey,
                                     PROFILE_UNLOAD_TIME_HIGH,
                                     0,
                                     REG_DWORD,
                                     (LPBYTE) &lpProfile->ftProfileUnload.dwHighDateTime,
                                     sizeof(DWORD));

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  Failed to save high profile load time with error %d"), lResult));
            }


            RegCloseKey (hKey);

            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Setting the unload Time")));
        }
    }


    if (lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED) {
        DWORD dwDeleteFlags=0;

        //
        // Just delete the user profile
        //

        if (lpProfile->dwInternalFlags & PROFILE_BACKUP_EXISTS) {
            dwDeleteFlags |= DP_BACKUPEXISTS;
        }

        if (!DeleteProfileEx (lpSidString, lpProfile->lpLocalProfile, dwDeleteFlags, HKEY_LOCAL_MACHINE, NULL)) {
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  DeleteProfileDirectory returned false (2).  Error = %d"), GetLastError()));
        }
    }


    if (bUnloadHiveSucceeded && bRoaming && bProfileCopied && bDeleteCache) {

        //
        // Delete the profile and all the related stuff
        //

        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Deleting the cached profile")));
        if (!DeleteProfile (lpSidString, NULL, NULL)) {
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  DeleteProfileDirectory returned false (2).  Error = %d"), GetLastError()));
        }
    }

    if(!(dwWatchHiveFlags & WHRC_UNLOAD_HIVE)) {
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: exitting and cleaning up")));
        bRetVal = TRUE;
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: exitting without cleaning up due to hive unloading failure")));
    }

Exit:

    if(hTokenClient) {
    
        //
        // Revert to ourselves.
        //

        RevertToUser(&hTmpToken);
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Reverted back to user <%08x>"), hTmpToken));
    }

    //
    // Leave the critical section.
    //

    if(bInCS) {
        cSyncMgr.LeaveLock(SidStringTemp);
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Leave critical section.")));
    }

    //
    // Delete the tmp hive file.
    //

    if (dwCopyTmpHive & CPD_USETMPHIVEFILE) {
        DeleteFile(tszTmpHiveFile);
    }

    if (bCSCBypassed) {
        CancelCSCBypassedConnection(hTokenUser, cDrive);
    }

    if(SidStringTemp) {
        DeleteSidString(SidStringTemp);
    }

    if (lpSidString) {
        DeleteSidString(lpSidString);
    }

    if (lpProfile) {

        if (lpProfile->lpLocalProfile) {
            LocalFree (lpProfile->lpLocalProfile);
        }

        if (lpProfile->lpRoamingProfile) {
            if (lpProfile->lpProfilePath && (lpProfile->lpProfilePath != lpProfile->lpRoamingProfile)) {
                LocalFree (lpProfile->lpProfilePath);
            }

            LocalFree (lpProfile->lpRoamingProfile);
            lpProfile->lpProfilePath = NULL;
        }

        if (lpProfile->lpProfilePath) {
            LocalFree(lpProfile->lpProfilePath);
        }

        LocalFree (lpProfile);
    }

    if (szExcludeList1) {
        LocalFree(szExcludeList1);
    }

    if (szExcludeList2) {
        LocalFree(szExcludeList2);
    }

    if (szExcludeList) {
        LocalFree(szExcludeList);
    }

    if (tszTmpHiveFile) {
        LocalFree(tszTmpHiveFile);
    }

    if (szKeyName) {
        LocalFree(szKeyName);
    }

    if (szErr) {
        LocalFree(szErr);
    }

    if (szBuffer) {
        LocalFree(szBuffer);
    }

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Leaving with a return value of %d"), bRetVal));

    SetLastError(dwErr1);
    return bRetVal;
}


//*************************************************************
//
//  CUserProfile::EnterUserProfileLockLocal()
//
//  Purpose:
//
//      Get the user profile lock (for winlogon only, other processes use
//      EnterUserProfileLockRemote). This is just a wrapper for
//      CSyncManager::EnterLock.
//
//  Parameters:
//
//      pSid     - User's sid string
//
//  Return:
//
//      TRUE/FALSE
//
//  History:    Date        Author     Comment
//              5/15/00     weiruc     Created
//
//*************************************************************

BOOL CUserProfile::EnterUserProfileLockLocal(LPTSTR pSid)
{
    return cSyncMgr.EnterLock(pSid, NULL);
}


//*************************************************************
//
//  CUserProfile::LeaveUserProfileLockLocal()
//
//  Purpose:
//
//      Release the user profile mutex (winlogon only. Remote processes call
//      LeaveUserProfileLockRemote().
//
//  Parameters:
//
//      pSid    - User's sid string
//
//  Return:
//
//      TRUE/FALSE
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/11/00     weiruc     Created
//
//*************************************************************

BOOL CUserProfile::LeaveUserProfileLockLocal(LPTSTR pSid)
{
    return cSyncMgr.LeaveLock(pSid);
}

//*************************************************************
//
//  CUserProfile::GetRPCEndPoint()
//
//  Purpose:
//
//      Returns the rpc end point associated with client registered
//      interface
//
//  Parameters:
//
//      pSid    - User's sid string
//
//  Return:
//
//      LPTSTR
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/25/00    santanuc   Created
//
//*************************************************************

LPTSTR CUserProfile::GetRPCEndPoint(LPTSTR pSid)
{
    return cSyncMgr.GetRPCEndPoint(pSid);
}


//*************************************************************
//
//  DropClientContext()
//
//  Purpose:    Allows the caller to drop off it's own token.
//
//  Parameters: hBindHandle     - explicit binding handle
//              lpProfileInfo   - Profile Information
//              ppfContext      - server context
//              
//
//  Return:     DWORD
//              ERROR_SUCCESS - If everything ok
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/24/00    santanuc   Created
//
//*************************************************************

DWORD DropClientContext(IN handle_t hBindHandle, IN LPPROFILEINFO lpProfileInfo, OUT PPCONTEXT_HANDLE pphContext)
{
    LPPROFILEINFO   pProfileInfoCopy = NULL;
    HANDLE          hClientToken = NULL;
    PCLIENTINFO     pClientInfo = NULL;
    RPC_STATUS      status;
    DWORD           dwErr = ERROR_ACCESS_DENIED;

    //
    // Initialize the debug flags.
    //

    InitDebugSupport( FALSE );

    if (!pphContext) {
        dwErr = ERROR_INVALID_PARAMETER;
        DebugMsg((DM_WARNING, TEXT("DropClientContext: NULL context %d"), dwErr));
        goto Exit;
    }

    //
    // Make a copy of the PROFILEINFO structure the user passed in.
    //

    if (lpProfileInfo) {
        if(!(pProfileInfoCopy = CopyProfileInfo(lpProfileInfo))) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("DropClientContext: CopyProfileInfo failed with %d"), dwErr));
            goto Exit;
        }
    }

    //
    // Impersonate the client to get it's token.
    //

    if((status = RpcImpersonateClient(0)) != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("DropClientContext: RpcImpersonateClient failed with %ld"), status));
        dwErr = status;
        goto Exit;
    }

    //
    // Get the client's token.
    //

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &hClientToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("DropClientContext: OpenThreadToken failed with %d"), dwErr));
        RpcRevertToSelf();
        goto Exit;
    }
    RpcRevertToSelf();
    DebugMsg((DM_VERBOSE, TEXT("DropClientContext: Got client token")));
    
    //
    // Make the user's load profile object.
    //

    pClientInfo = (PCLIENTINFO)MIDL_user_allocate(sizeof(CLIENTINFO));
    if(!pClientInfo) {
        dwErr = ERROR_OUTOFMEMORY;
        DebugMsg((DM_WARNING, TEXT("DropClientContext: new failed")));
        goto Exit;
    }
    pClientInfo->hClientToken = hClientToken;
    pClientInfo->pProfileInfo = pProfileInfoCopy;
    *pphContext = (PCONTEXT_HANDLE)pClientInfo;
    DebugMsg((DM_VERBOSE, TEXT("DropClientContext: load profile object successfully made")));

    hClientToken = NULL;
    pProfileInfoCopy = NULL;
    dwErr = ERROR_SUCCESS;
    
Exit:

    if(hClientToken) {
        CloseHandle(hClientToken);
    }

    if(pProfileInfoCopy) {
        DeleteProfileInfo(pProfileInfoCopy);
    }

    DebugMsg((DM_VERBOSE, TEXT("DropClientContext: Returning %d"), dwErr));
    return dwErr;
}

//*************************************************************
//
//  ReleaseClientContext()
//
//  Purpose:    Release the client's context handle
//
//  Parameters: hBindHandle     - explicit binding handle
//              ppfContext      - server context
//              
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/24/00    santanuc   Created
//
//*************************************************************

void ReleaseClientContext(IN handle_t hBindHandle, IN OUT PPCONTEXT_HANDLE pphContext)
{
    PCLIENTINFO pClientInfo;

    DebugMsg((DM_VERBOSE, TEXT("ReleaseClientContext: Releasing context")));

    ReleaseClientContext_s(pphContext);
}

//
// This function also called from server rundown routine
//

void ReleaseClientContext_s(PPCONTEXT_HANDLE pphContext)
{
    PCLIENTINFO pClientInfo;

    DebugMsg((DM_VERBOSE, TEXT("ReleaseClientContext_s: Releasing context")));

    if (*pphContext) {
        pClientInfo = (PCLIENTINFO)*pphContext;
        CloseHandle(pClientInfo->hClientToken);
        DeleteProfileInfo(pClientInfo->pProfileInfo);
        MIDL_user_free(pClientInfo);
        *pphContext = NULL;
    }
}


//*************************************************************
//
//  EnterUserProfileLockRemote()
//
//      Get the lock for loading/unloading a user's profile.
//
//  Return value:
//
//      HRESULT
//
//  History:
//
//      Created         weiruc          6/16/2000
//
//*************************************************************
DWORD EnterUserProfileLockRemote(IN handle_t hBindHandle, IN LPTSTR pSid)
{
    DWORD       dwErr = ERROR_ACCESS_DENIED;
    RPC_STATUS  status;
    HANDLE      hToken = NULL;


    //
    // Impersonate the client to get the user's token.
    //

    if((status = RpcImpersonateClient(0)) != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::EnterUserProfileLockRemote: CoImpersonateClient failed with %ld"), status));
        dwErr = status;
        goto Exit;
    }

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ, TRUE, &hToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CUserProfile::EnterUserProfileLockRemote: OpenThreadToken failed with %d"), dwErr));
        RpcRevertToSelf();
        goto Exit;
    }

    RpcRevertToSelf();

    //
    // Only admin users are allowed to lock a user's profile from being loaded/unloaded.
    //

    if(!IsUserAnAdminMember(hToken)) {
        dwErr = ERROR_ACCESS_DENIED;
        DebugMsg((DM_WARNING, TEXT("CUserProfile::EnterUserProfileLockRemote: Non-admin user!!!")));
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::EnterUserProfileLockRemote: Locking user %s"), pSid));

    if(!cUserProfileManager.EnterUserProfileLockLocal(pSid)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CUserProfile::EnterUserProfileLockRemote: Failed with %d"), dwErr));
        goto Exit;
    }

    dwErr = ERROR_SUCCESS;

Exit:

    if(hToken) {
        CloseHandle(hToken);
    }

    return dwErr;
}


//*************************************************************
//
//  LeaveUserProfileLockRemote()
//
//      Release the lock for loading/unloading a user's profile.
//
//  Return value:
//
//      HRESULT
//
//  History:
//
//      Created         weiruc          6/16/2000
//
//*************************************************************

DWORD LeaveUserProfileLockRemote(IN handle_t hBindHandle, IN LPTSTR pSid)
{
    HANDLE      hToken = NULL;
    DWORD       dwErr = ERROR_ACCESS_DENIED;
    RPC_STATUS  status;


    //
    // Impersonate the client to get the user's token.
    //

    if((status = RpcImpersonateClient(0)) != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::LeaveUserProfileLockRemote: CoImpersonateClient failed with %ld"), status));
        dwErr = status;
        goto Exit;
    }
    
    if(!OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ, TRUE, &hToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CUserProfile::LeaveUserProfileLockRemote: OpenThreadToken failed with %d"), dwErr));
        RpcRevertToSelf();
        goto Exit;
    }

    RpcRevertToSelf();
    
    //
    // Only admin users are allowed to lock a user's profile from being loaded/unloaded.
    //

    if(!IsUserAnAdminMember(hToken)) {
        dwErr = ERROR_ACCESS_DENIED;
        DebugMsg((DM_WARNING, TEXT("CUserProfile::LeaveUserProfileLockRemote: Non-admin user!!!")));
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::LeaveUserProfileLockRemote: Unlocking user %s"), pSid));

    if(!cUserProfileManager.LeaveUserProfileLockLocal(pSid)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CUserProfile::LeaveUserProfileLockRemote: Failed with %d"), dwErr));
        goto Exit;
    }

    dwErr = ERROR_SUCCESS;

Exit:

    if(hToken) {
        CloseHandle(hToken);
    }

    return dwErr;
}

//*************************************************************
//
//  CUserProfile::WorkerThreadMain
//
//      Main function for the worker thread
//
//  Parameters:
//
//      pThreadMap            the work queue for this thread
//
//  Return value:
//
//      Always returns ERROR_SUCCESS.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

DWORD CUserProfile::WorkerThreadMain(PMAP pThreadMap)
{
    DWORD           index;
    HKEY            hkProfileList = NULL;
    long            lResult;
    BOOL            bCleanUp;
    LPTSTR          ptszSid, lpTmp;


    DebugMsg((DM_VERBOSE, TEXT("Entering CUserProfile::WorkerThreadMain")));

    while(TRUE) {

        bCleanUp = FALSE;
        ptszSid  = NULL;

        index = WaitForMultipleObjects(pThreadMap->dwItems,
                                       pThreadMap->rghEvents,
                                       FALSE,
                                       INFINITE);
        index = index - WAIT_OBJECT_0;

        EnterCriticalSection(&csMap);
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WorkerThreadMain: In critical section")));


        if(index > 0 && index < pThreadMap->dwItems) {
            LPTSTR  lpUserName;
            
            DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WorkerThreadMain: WaitForMultipleObjects successful")));
            DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WorkerThreadMain: hive %s unloaded"), pThreadMap->rgSids[index]));
            lpUserName = GetUserNameFromSid(pThreadMap->rgSids[index]);
            ReportError(NULL, PI_NOUI | EVENT_INFO_TYPE, 1, EVENT_HIVE_UNLOADED, lpUserName);
            if (lpUserName != pThreadMap->rgSids[index]) {
                LocalFree(lpUserName);
            }
            
            //
            // Save the sid and Delete the work item from the map and the hash
            // table.
            //
            
            ptszSid = pThreadMap->GetSid(index);
            pThreadMap->Delete(index);
            cTable.HashDelete(ptszSid);
            
            // Convert Sid_Classes entry to Sid as CleanupUserProfile takes only Sid
            lpTmp = ptszSid;
            if (lpTmp) {
                while (*lpTmp && (*lpTmp != TEXT('_')))
                    lpTmp++;
                if (*lpTmp) {
                    *lpTmp = TEXT('\0');
                }
            }
        
            //
            // Set the flag to clean up here because we want to do it after
            // we leave the critical section.
            //

            bCleanUp = TRUE;
        } // if waken up because a hive is unloaded

        //
        // Check to see if the map is empty. If it is, delete the map.
        //

        if(pThreadMap->IsEmpty()) {

            PMAP pTmpMap = pMap;

            //
            // We always have at least 1 item left: the thread event, So now
            // we know we don't have any work item anymore. Delete pThreadMap.
            //

            if(pThreadMap == pMap) {
                // pThreadMap is at the beginning of the list.
                pMap = pThreadMap->pNext;
            }
            else {
                for(pTmpMap = pMap; pTmpMap->pNext != pThreadMap; pTmpMap = pTmpMap->pNext);
                pTmpMap->pNext = pThreadMap->pNext;
            }
            pThreadMap->pNext = NULL;

            pThreadMap->Delete(0);
            delete pThreadMap;

            //
            // Leave the critical section.
            //

            LeaveCriticalSection(&csMap);
            DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WorkerThreadMain: Leave critical section")));

            if(bCleanUp) {                

                //
                // Clean up user's profile.
                //

                CleanupUserProfile(ptszSid, &hkProfileList);
                LocalFree(ptszSid);
            }
            
            //
            // Close the profile list key.
            //

            if(hkProfileList) {
                RegCloseKey(hkProfileList);
                hkProfileList = NULL;
            }

            //
            // Exit the thread because we don't have any work items anymore.
            //
        
            DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WorkerThreadMain: No more work items, leave thread")));
            return ERROR_SUCCESS;
        }   // if thread map is empty

        //
        // Leave the critical section.
        //

        LeaveCriticalSection(&csMap);
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WorkerThreadMain: Leave critical section")));

        if(bCleanUp) {
            
            //
            // Clean up user's profile.
            //

            CleanupUserProfile(ptszSid, &hkProfileList);
            LocalFree(ptszSid);
        }

        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WorkerThreadMain: Back to waiting...")));
    }   // while

    
    //
    // Never executed.
    //

    return ERROR_SUCCESS;
}


//*************************************************************
//
//  CUserProfile::WatchHiveRefCount
//
//      Implementation of the interface IWatchHiveRefCount.
//
//  Parameters:
//
//      pctszSid            the user's sid
//      dwWHRCFlags         indicate which hives to unload
//
//  Return value:
//
//      HRESULT error code.
//
//  History:
//
//      Created         weiruc          5/4/2000
//
//*************************************************************

STDMETHODIMP CUserProfile::WatchHiveRefCount(LPCTSTR pSid, DWORD dwWHRCFlags)
{
    LPTSTR                  pSidCopy = NULL;
    NTSTATUS                status;
    OBJECT_ATTRIBUTES       oa;
    TCHAR                   tszHiveName[MAX_PATH], *pTmp;
    UNICODE_STRING          sHiveName;
    BOOLEAN                 bWasEnabled;
    HRESULT                 hres = S_OK, hres1;
    HANDLE                  hEvent = INVALID_HANDLE_VALUE;
    DWORD                   dwSidLen = lstrlen(pSid);
    BOOL                    bInCriticalSection = FALSE;


    DebugMsg((DM_VERBOSE, TEXT("Entering CUserProfile::WatchHiveRefCount: %s, %d"), pSid, dwWHRCFlags));

    //
    // Are we initialized?
    //

    if(!bInitialized) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::WatchHiveRefCount not initialized")));
        return E_FAIL;
    }

    //
    // parameter validation
    //

    if(dwSidLen >= sizeof(tszHiveName) / sizeof(TCHAR) - USER_KEY_PREFIX_LEN - USER_CLASSES_HIVE_SUFFIX_LEN ||
       dwSidLen >= sizeof(tszHiveName) / sizeof(TCHAR) - USER_KEY_PREFIX_LEN ||
       lstrcmpi(DEFAULT_HKU, pSid) == 0) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::WatchHiveRefCount: Invalid parameter")));
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // Setup the hive name to be used by NtUnloadKeyEx.
    //
    
    lstrcpy(tszHiveName, USER_KEY_PREFIX);
    pTmp = tszHiveName + USER_KEY_PREFIX_LEN;
    lstrcpy(pTmp, pSid);
    *pTmp = (TCHAR)_totupper(*pTmp);
    
    //
    // Enable the restore privilege. Don't give up even if fails. In the case
    // of impersonation, this call will fail. But we still might still have
    // the privilege needed.
    //

    status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &bWasEnabled);
    if(!NT_SUCCESS(status)) {
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WatchHiveRefCount: Failed to enable the restore privilege. error = %08x"), status));
    }

    //
    // Enter the critical section.
    //

    EnterCriticalSection(&csMap);
    bInCriticalSection = TRUE;
    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WatchHiveRefCount: In critical section")));

    //
    // Register for the hive to be unloaded.
    //
 
    while (dwWHRCFlags & (WHRC_UNLOAD_HIVE | WHRC_UNLOAD_CLASSESROOT)) {

        if(dwWHRCFlags & WHRC_UNLOAD_HIVE) {
           dwWHRCFlags &= ~WHRC_UNLOAD_HIVE;
        }
        else if (dwWHRCFlags & WHRC_UNLOAD_CLASSESROOT) {
           dwWHRCFlags &= ~WHRC_UNLOAD_CLASSESROOT;
           lstrcat(tszHiveName, USER_CLASSES_HIVE_SUFFIX);
        }

        //
        // First make sure that the item is not already in our work list.
        //

        if(cTable.IsInTable(pTmp)) {
            DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WatchHiveRefCount: %s already in work list"), pTmp));
        }
        else {
            if((hEvent = CreateEvent(NULL,
                                     FALSE,
                                     FALSE,
                                     NULL)) == NULL) {
                hres = HRESULT_FROM_WIN32(GetLastError());
                DebugMsg((DM_WARNING, TEXT("CUserProfile::WatchHiveRefCount: CreateEvent failed. error = %08x"), hres));
                goto Exit;
            }

            //
            // Initialize the object attributes.
            //

            RtlInitUnicodeString(&sHiveName, tszHiveName);
            InitializeObjectAttributes(&oa,
                                       &sHiveName,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            //
            // Unload the hive.
            //

            if(!NT_SUCCESS(status = NtUnloadKeyEx(&oa, hEvent))) {
                hres = HRESULT_FROM_WIN32(status);
                DebugMsg((DM_WARNING, TEXT("CUserProfile::WatchHiveRefCount: NtUnloadKeyEx failed with %08x"), status));
                CloseHandle(hEvent);
                goto Exit;
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WatchHiveRefCount: NtUnloadKeyEx succeeded for %s"), tszHiveName));
            }

            //
            // Add the work item to clean up the profile when the hive is unloaded.
            //

            hres = AddWorkItem(pTmp, hEvent);

            //
            // Do not return error if we fail to add the work item because
            // cleaning up is a best effort. The important thing is that we
            // unloaded the hive successfully, or at least registered
            // successfully to do so.
            //

            if(hres != S_OK) {
                DebugMsg((DM_WARNING, TEXT("CUserProfile::WatchHiveRefCount: AddWorkItem failed with %08x"), hres));
                CloseHandle(hEvent);
                hres = S_OK;
            }
        } // Item not already in list
    } 


Exit:

    if(bInCriticalSection) {
        LeaveCriticalSection(&csMap);
    }

    //
    // Restore the privilege to its previous state.
    //

    status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, bWasEnabled, FALSE, &bWasEnabled);
    if(!bWasEnabled && !NT_SUCCESS(status)) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::WatchHiveRefCount: Failed to restore the privilege. error = %08x"), status));
    }

    return hres;
}


//*************************************************************
//
//  CUserProfile::AddWorkItem
//
//      Add a new work item.
//
//  Parameters:
//
//      pSid               the user's sid
//      hEvent             the event registry will set when hive is unloaded.
//
//  Return value:
//
//      HRESULT error code.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

HRESULT CUserProfile::AddWorkItem(LPCTSTR pSid, HANDLE hEvent)
{
    PMAP                    pThreadMap = NULL;
    HRESULT                 hres = E_FAIL;
    HANDLE                  hThreadEvent = INVALID_HANDLE_VALUE;
    HANDLE                  hThread = INVALID_HANDLE_VALUE;
    BOOL                    bHashDelete = TRUE;
    LPTSTR                  pSidCopy = NULL;


    DebugMsg((DM_VERBOSE, TEXT("Entering CUserProfile::AddWorkItem: %s"), pSid));

    pSidCopy = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pSid) + 1) * sizeof(TCHAR));
    if(!pSidCopy) {
        hres = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg((DM_WARNING, TEXT("CUserProfile::AddWorkItem: Out of memory")));
        goto Exit;
    }
    lstrcpy(pSidCopy, pSid);

    //
    // Make sure the leading 's' is in uppercase.
    //

    *pSidCopy = (TCHAR)_totupper(*pSidCopy);

    //
    // Verify that this sid is not already in our work list.
    //

    if(!cTable.HashAdd(pSidCopy)) {
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::AddWorkItem: sid %s already in work list"), pSidCopy));
        bHashDelete = FALSE;
        goto Exit;
    }


    //
    // Look through the work item thread map list to find a thread that is not
    // fully loaded;
    //

    for(pThreadMap = pMap; pThreadMap != NULL; pThreadMap = pThreadMap->pNext) {
        if(pThreadMap->dwItems < MAXIMUM_WAIT_OBJECTS) {
            break;
        }
    }


    if(!pThreadMap) {

        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::AddWorkItem: No thread available, create a new one.")));

        //
        // Create the thread event.
        //

        pThreadMap = new MAP();
        if(!pThreadMap) {
            hres = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg((DM_WARNING, TEXT("CUserProfile::AddWorkItem: new operator failed. error = %08x"), hres));
            goto Exit;
        }
        if((hThreadEvent = CreateEvent(NULL,
                           FALSE,
                           FALSE,
                           NULL)) == NULL) {
            hres = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg((DM_WARNING, TEXT("CUserProfile::AddWorkItem: CreateEvent failed for thread event. error = %08x"), hres));
            goto Exit;
        }
        pThreadMap->Insert(hThreadEvent, NULL);


        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::AddWorkItem: Signal event item inserted")));

        //
        // Create the thread.
        //

        if((hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)ThreadMain,
                                   pThreadMap,
                                   0,
                                   NULL)) == NULL) {
            hres = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg((DM_WARNING, TEXT("CUserProfile::AddWorkItem: CreateThread failed. error = %08x"), hres));
            
            //
            // Delete the thread signal event item.
            //

            pThreadMap->Delete(0);
            goto Exit;
        }
        else {
            CloseHandle(hThread);
        }
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::AddWorkItem: New thread created")));

        //
        // Successful return. Insert the work item into pThreadMap.
        //

        pThreadMap->Insert(hEvent, pSidCopy);
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::AddWorkItem: Work Item inserted")));
        
        //
        // Insert pThreadMap into the map list.
        //

        pThreadMap->pNext = pMap;
        pMap = pThreadMap;
    }
    else {
    
        //
        // Found an existing thread. Insert the work item into it's map.
        //

        pThreadMap->Insert(hEvent, pSidCopy);

        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::AddWorkItem: Work item inserted")));
    }

    //
    // Wake up the thread. If the thread can not be waken up by setting the
    // event here, then it'll be stuck in sleep state until one day this
    // SetEvent call succeeds. Leave the work item in and continue.
    //

    if(!SetEvent(pThreadMap->rghEvents[0])) {
        hres = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg((DM_WARNING, TEXT("SetEvent failed. error = %08x"), hres));
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::AddWorkItem: thread woken up")));
    }
    
    pThreadMap = NULL;
    hres = S_OK;
    bHashDelete = FALSE;
    pSidCopy = NULL;

Exit:

    if(bHashDelete && pSidCopy) {
        cTable.HashDelete(pSidCopy);
    }

    if(pSidCopy) {
        LocalFree(pSidCopy);
    }
    
    if(pThreadMap) {
        delete pThreadMap;
    }
    
    DebugMsg((DM_VERBOSE, TEXT("Exiting CUserProfile::AddWorkItem with %08x"), hres));
    return hres;
}


//*************************************************************
//
//  CUserProfile::CleanupUserProfile
//
//      Unload the hive and delete the profile directory if necessary.
//
//  Parameters:
//
//      ptszSid         - User's sid string
//      phkProfileList  - in/out parameter. Handle to the profile list key.
//                        if NULL, will fill in the handle. And this handle
//                        has to be closed by the caller.
//
//  Comment:
//
//      Always ignore error and continue because this is a best effort.
//
//*************************************************************

void CUserProfile::CleanupUserProfile(LPTSTR ptszSid, HKEY* phkProfileList)
{
    DWORD   dwInternalFlags = 0;
    DWORD   dwRefCount;
    BOOL    bInCS = FALSE;


    //
    // Enter the critical section.
    //

    if(!EnterUserProfileLockLocal(ptszSid)) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::CleanupUserProfile:: Failed to get the user profile lock for %s"), ptszSid));
        goto Exit;
    }
    bInCS = TRUE;
    
    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::CleanupUserProfile: Enter critical section.")));

    //
    // Get the reference count and the internal flags.
    //

    if(GetRefCountAndFlags(ptszSid, phkProfileList, &dwRefCount, &dwInternalFlags) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::CleanupUserProfile: Can not get ref count and flags")));
        goto Exit;
    }

    //
    // If the ref count is 0, clean up the user's profile. If not, give up.
    //

    if(dwRefCount != 0) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::CleanupUserProfile: Ref Count is not 0")));
        goto Exit;
    }   
    
    //
    // Delete the temporary profile if:
    // guest user profile           or
    // temp profile                 or
    // mandatory profile
    // Profiles that are none of the above will not be cleaned up even if
    // Delete cache bit is set in the registry or the policy says delete
    // cached profiles. This is because even though now we unloaded the
    // hive we don't upload the profile. Deleting the local profile might
    // result in user's data loss.
    //

    // Don't delete the guest account if machine is in workgroup 
    INT iRole;

    if(dwInternalFlags & PROFILE_MANDATORY ||
       dwInternalFlags & PROFILE_TEMP_ASSIGNED ||
       ((dwInternalFlags & PROFILE_GUEST_USER) && GetMachineRole(&iRole) && (iRole != 0))) {
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::CleanupUserProfile: DeleteProfile")));
        if(!DeleteProfile(ptszSid, NULL, NULL)) {
            DebugMsg((DM_WARNING, TEXT("CUserProfile::CleanupUserProfile: DeleteProfile returned FALSE. error = %08x"), GetLastError()));
        }
    }
    
Exit:

    if(bInCS) {
        LeaveUserProfileLockLocal(ptszSid);
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::CleanupUserProfile: Leave critical section")));
    }
}


//*************************************************************
//
//  CUserProfile::GetRefCountAndFlags
//
//      Get the ref count and internal flags from the registry for a user.
//
//  Parameters:
//
//      ptszSid         - User's sid string
//      phkPL           - in/out parameter. Handle to the profile list key.
//                        If NULL, will be filled with an opened key to the
//                        profile list. The caller is responsible for
//                        closing it.
//      dwRefCount      - buffer for the ref count.
//      dwInternalFlags - buffer for the internal flags.
//
//  History:
//
//      Created         weiruc         5/23/2000 
//
//*************************************************************

long CUserProfile::GetRefCountAndFlags(LPCTSTR ptszSid, HKEY* phkPL, DWORD* dwRefCount, DWORD* dwInternalFlags)
{
    HKEY        hkUser = NULL;
    DWORD       dwType, dwSize = sizeof(DWORD);
    long        lResult = ERROR_SUCCESS;

    *dwRefCount = 0;
    *dwInternalFlags = 0;

    if(!*phkPL) {
        
        //
        // Open the profile list if it's not already opened.
        //

        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               PROFILE_LIST_PATH,
                               0,
                               KEY_READ,
                               phkPL);
        if(lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("CUserProfile::GetRefCountAndFlags:  Failed to open profile list key with error %d"), lResult));
            goto Exit;
        }
    }

    //
    // Open the user's key in the profile list.
    //

    if((lResult = RegOpenKeyEx(*phkPL,
                  ptszSid,
                  0,
                  KEY_READ,
                  &hkUser)) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::GetRefCountAndFlags: RegOpenKeyEx failed with error %08x"), lResult));
        goto Exit;
    }


    //
    // Query for the ref count and the internal flags.
    //

    if((lResult = RegQueryValueEx(hkUser,
                                  PROFILE_REF_COUNT,
                                  0,
                                  &dwType,
                                  (LPBYTE)dwRefCount,
                                  &dwSize)) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::GetRefCountAndFlags: RegQueryValueEx failed, key = %s, error = %08x"), ptszSid, lResult));
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    if((lResult = RegQueryValueEx(hkUser,
                                  PROFILE_STATE,
                                  0,
                                  &dwType,
                                  (LPBYTE)dwInternalFlags,
                                  &dwSize)) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::GetRefCountAndFlags: RegQueryValueEx failed, key = %s, error = %08x"), ptszSid, lResult));
        goto Exit;
    }
    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::GetRefCountAndFlags: Ref count is %d, state is %08x"), *dwRefCount, *dwInternalFlags));

Exit:

    if(hkUser) {
        RegCloseKey(hkUser);
    }

    return lResult;
}


//*************************************************************
//
//  LoadUserProfileI()
//
//  Purpose:    Just a wrapper around CUserProfile::LoadUserProfileP
//
//  Parameters: hBindHandle   - server explicit binding handle
//              pProfileInfo  - Profile Information
//              phContext     - server context for client
//              lpRPCEndPoint - RPCEndPoint of the registered IProfileDialog interface 
//
//  Return:     DWORD
//              ERROR_SUCCESS - if everything is ok
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              10/24/00    santanuc   Created
//
//*************************************************************

DWORD LoadUserProfileI(IN handle_t hBindHandle, IN LPPROFILEINFO lpProfileInfo, IN PCONTEXT_HANDLE phContext, IN LPTSTR lpRPCEndPoint)
{
    HANDLE      hUserToken = NULL;
    BOOL        bImpersonatingUser = FALSE;
    PCLIENTINFO pClientInfo;
    DWORD       dwErr = ERROR_ACCESS_DENIED;
    RPC_STATUS  status;

    if (lpRPCEndPoint) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfileI: RPC end point %s"), lpRPCEndPoint));
    }

    //
    // Get the context
    //

    if (!phContext) {
        dwErr = ERROR_INVALID_PARAMETER;
        DebugMsg((DM_WARNING, TEXT("LoadUserProfileI: NULL context")));
        goto Exit;
    }

    pClientInfo = (PCLIENTINFO)phContext;

    //
    // Verify that the PROFILEINFO structure passed in is the same one.
    //

    if(!CompareProfileInfo(lpProfileInfo, pClientInfo->pProfileInfo)) {
        dwErr = ERROR_INVALID_PARAMETER;
        DebugMsg((DM_WARNING, TEXT("LoadUserProfileI: PROFILEINFO structure passed in is different")));
        goto Exit;
    }

    //
    // Impersonate the client to get the user's token.
    //

    if((status = RpcImpersonateClient(0)) != S_OK) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfileI: CoImpersonateClient failed with %ld"), status));
        dwErr = status;
        goto Exit;
    }
    bImpersonatingUser = TRUE;

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &hUserToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadUserProfileI: OpenThreadToken failed with %d"), dwErr));
        goto Exit;
    }

    RpcRevertToSelf();
    bImpersonatingUser = FALSE;

    //
    // Now that we have both the client and the user's token, call
    // LoadUserProfileP to do the work.
    //

    if(!cUserProfileManager.LoadUserProfileP(pClientInfo->hClientToken, hUserToken, pClientInfo->pProfileInfo, lpRPCEndPoint)) {
        dwErr = GetLastError();   
        DebugMsg((DM_WARNING, TEXT("LoadUserProfileI: LoadUserProfileP failed with %d"), dwErr));
        goto Exit;
    }

    //
    // Close the registry handle to the user hive opened by LoadUserProfileP.
    //

    RegCloseKey((HKEY)pClientInfo->pProfileInfo->hProfile);
    dwErr = ERROR_SUCCESS;

Exit:

    if(bImpersonatingUser) {
        RpcRevertToSelf();
    }

    if(hUserToken) {
        CloseHandle(hUserToken);
    }

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfileI: returning %d"), dwErr));
    return dwErr;
}


//*************************************************************
//
//  UnloadUserProfileI()
//
//  Purpose:    Just a wrapper around CUserProfile::UnloadUserProfileP
//
//  Parameters: hBindHandle   - server explicit binding handle
//              phContext     - server context for client
//              lpRPCEndPoint - RPCEndPoint of the registered IProfileDialog interface 
//
//  Return:     DWORD
//              ERROR_SUCCESS - if everything is ok
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              10/24/00    santanuc   Created
//
//*************************************************************

DWORD UnloadUserProfileI(IN handle_t hBindHandle, IN PCONTEXT_HANDLE phContext, IN LPTSTR lpRPCEndPoint)
{
    HANDLE  hUserToken = NULL;
    HKEY    hProfile = NULL;
    BOOL    bImpersonatingUser = FALSE;
    PCLIENTINFO pClientInfo;
    LPTSTR  pSid = NULL;
    long    lResult;
    RPC_STATUS  status;
    DWORD   dwErr = ERROR_ACCESS_DENIED;

    //
    // Get the context
    //

    if (!phContext) {
        dwErr = ERROR_INVALID_PARAMETER;
        DebugMsg((DM_WARNING, TEXT("UnLoadUserProfileI: NULL context")));
        goto Exit;
    }

    pClientInfo = (PCLIENTINFO)phContext;

    //
    // Impersonate the client to get the user's token.
    //

    if((status = RpcImpersonateClient(0)) != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileI: CoImpersonateClient failed with %ld"), status));
        dwErr = status;
        goto Exit;
    }
    bImpersonatingUser = TRUE;

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ, TRUE, &hUserToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileI: OpenThreadToken failed with %d"), dwErr));
        goto Exit;
    }

    RpcRevertToSelf();
    bImpersonatingUser = FALSE;

    //
    // Open the user's registry hive root.
    //

    pSid = GetSidString(hUserToken);
    if((lResult = RegOpenKeyEx(HKEY_USERS, pSid, 0, KEY_ALL_ACCESS, &hProfile)) != ERROR_SUCCESS) {
        dwErr = lResult;
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileI: RegOpenKeyEx failed with %d"), dwErr));
        goto Exit;
    }

    //
    // Now that we have both the client and the user's token, call
    // UnloadUserProfileP to do the work. hProfile gets closed in
    // UnloadUserProfileP so don't close it again.
    //

    if(!cUserProfileManager.UnloadUserProfileP(pClientInfo->hClientToken, hUserToken, hProfile, lpRPCEndPoint)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileI: UnloadUserProfileP failed with %d"), dwErr));
        goto Exit;
    }
    
    dwErr = ERROR_SUCCESS;

Exit:

    if(bImpersonatingUser) {
        RpcRevertToSelf();
    }

    if(hUserToken) {
        CloseHandle(hUserToken);
    }

    if(pSid) {
        DeleteSidString(pSid);
    }

    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileI: returning %d"), dwErr));
    SetLastError(dwErr);
    return dwErr;
}


//*************************************************************
//
//  CompareProfileInfo()
//
//  Purpose:    Compare field by field two PROFILEINFO structures
//              except for the hProfile field.
//
//  Parameters: pInfo1, pInfo2
//
//  Return:     TRUE    -   Same
//              FALSE   -   Not the same
//
//  History:    Date        Author     Comment
//              6/29/00     weiruc     Created
//
//*************************************************************

BOOL CompareProfileInfo(LPPROFILEINFO pInfo1, LPPROFILEINFO pInfo2)
{
    BOOL    bRet = TRUE;


    if(!pInfo1 || !pInfo2) {
        DebugMsg((DM_WARNING, TEXT("CompareProfileInfo: Invalid parameter")));
        return FALSE;
    }

    if(pInfo1->dwSize != pInfo2->dwSize) {
        DebugMsg((DM_WARNING, TEXT("CompareProfileInfo: dwSize %d != %d"), pInfo1->dwSize, pInfo2->dwSize));
        return FALSE;
    }

    if(pInfo1->dwFlags != pInfo2->dwFlags) {
        DebugMsg((DM_WARNING, TEXT("CompareProfileInfo: dwFlags %d != %d"), pInfo1->dwFlags, pInfo2->dwFlags));
        return FALSE;
    }

    if(lstrcmpi(pInfo1->lpUserName, pInfo2->lpUserName)) {
        DebugMsg((DM_WARNING, TEXT("CompareProfileInfo: lpUserName <%s> != <%s>"), pInfo1->lpUserName, pInfo2->lpUserName));
        return FALSE;
    }

    if(lstrcmpi(pInfo1->lpProfilePath, pInfo2->lpProfilePath)) {
        DebugMsg((DM_WARNING, TEXT("CompareProfileInfo: lpProfilePath <%s> != <%s>"), pInfo1->lpProfilePath, pInfo2->lpProfilePath));
        return FALSE;
    }

    if(lstrcmpi(pInfo1->lpDefaultPath, pInfo2->lpDefaultPath)) {
        DebugMsg((DM_WARNING, TEXT("CompareProfileInfo: lpDefaultPath <%s> != <%s>"), pInfo1->lpDefaultPath, pInfo2->lpDefaultPath));
        return FALSE;
    }

    if(lstrcmpi(pInfo1->lpServerName, pInfo2->lpServerName)) {
        DebugMsg((DM_WARNING, TEXT("CompareProfileInfo: lpServerName <%s> != <%s>"), pInfo1->lpServerName, pInfo2->lpServerName));
        return FALSE;
    }

    if(lstrcmpi(pInfo1->lpPolicyPath, pInfo2->lpPolicyPath)) {
        DebugMsg((DM_WARNING, TEXT("CompareProfileInfo: lpPolicyPath <%s> != <%s>"), pInfo1->lpPolicyPath, pInfo2->lpPolicyPath));
        return FALSE;
    }

    return TRUE;
}


//*************************************************************
//
//  CopyProfileInfo()
//
//  Purpose:    Allocate and copy a PROFILEINFO structure.
//
//  Parameters: pProfileInfo    -   To be copied
//
//  Return:     The copy
//
//  History:    Date        Author     Comment
//              6/29/00     weiruc     Created
//
//*************************************************************

LPPROFILEINFO CopyProfileInfo(LPPROFILEINFO pProfileInfo)
{
    LPPROFILEINFO   pInfoCopy = NULL;
    BOOL            bSuccess = FALSE;

    //
    // Allocate and initialize memory for the PROFILEINFO copy.
    //

    pInfoCopy = (LPPROFILEINFO)LocalAlloc(LPTR, sizeof(PROFILEINFO));
    if(!pInfoCopy) {
        goto Exit;
    }

    //
    // Copy field by field.
    //

    pInfoCopy->dwSize = pProfileInfo->dwSize;

    pInfoCopy->dwFlags = pProfileInfo->dwFlags;

    if(pProfileInfo->lpUserName) {
        pInfoCopy->lpUserName = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pProfileInfo->lpUserName) + 1) * sizeof(TCHAR));
        if(!pInfoCopy->lpUserName) {
            goto Exit;
        }
        lstrcpy(pInfoCopy->lpUserName, pProfileInfo->lpUserName);
    }

    if(pProfileInfo->lpProfilePath) {
        pInfoCopy->lpProfilePath = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pProfileInfo->lpProfilePath) + 1) * sizeof(TCHAR));
        if(!pInfoCopy->lpProfilePath) {
            goto Exit;
        }
        lstrcpy(pInfoCopy->lpProfilePath, pProfileInfo->lpProfilePath);
    }

    if(pProfileInfo->lpDefaultPath) {
        pInfoCopy->lpDefaultPath = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pProfileInfo->lpDefaultPath) + 1) * sizeof(TCHAR));
        if(!pInfoCopy->lpDefaultPath) {
            goto Exit;
        }
        lstrcpy(pInfoCopy->lpDefaultPath, pProfileInfo->lpDefaultPath);
    }

    if(pProfileInfo->lpServerName) {
        pInfoCopy->lpServerName = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pProfileInfo->lpServerName) + 1) * sizeof(TCHAR));
        if(!pInfoCopy->lpServerName) {
            goto Exit;
        }
        lstrcpy(pInfoCopy->lpServerName, pProfileInfo->lpServerName);
    }

    if(pProfileInfo->lpPolicyPath) {
        pInfoCopy->lpPolicyPath = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pProfileInfo->lpPolicyPath) + 1) * sizeof(TCHAR));
        if(!pInfoCopy->lpPolicyPath) {
            goto Exit;
        }
        lstrcpy(pInfoCopy->lpPolicyPath, pProfileInfo->lpPolicyPath);
    }

    bSuccess = TRUE;

Exit:

    if(!bSuccess && pInfoCopy) {
        DeleteProfileInfo(pInfoCopy);
        pInfoCopy = NULL;
    }

    return pInfoCopy;
}


//*************************************************************
//
//  DeleteProfileInfo()
//
//  Purpose:    Delete a PROFILEINFO structure
//
//  Parameters: pInfo
//
//  Return:     void
//
//  History:    Date        Author     Comment
//              6/29/00     weiruc     Created
//
//*************************************************************

void DeleteProfileInfo(LPPROFILEINFO pInfo)
{
    if(!pInfo) {
        return;
    }

    if(pInfo->lpUserName) {
        LocalFree(pInfo->lpUserName);
    }

    if(pInfo->lpProfilePath) {
        LocalFree(pInfo->lpProfilePath);
    }

    if(pInfo->lpDefaultPath) {
        LocalFree(pInfo->lpDefaultPath);
    }

    if(pInfo->lpServerName) {
        LocalFree(pInfo->lpServerName);
    }

    if(pInfo->lpPolicyPath) {
        LocalFree(pInfo->lpPolicyPath);
    }

    LocalFree(pInfo);
}


//*************************************************************
//
//  GetInterface()
//
//  Purpose:    Get the rpc binding handle 
//
//  Parameters: phIfHandle    - rpc binding handle to initialize
//              lpRPCEndPoint - RPCEndPoint of interface
//
//  Return:     TRUE if successful.
//
//  History:    Date        Author     Comment
//              10/24/00    santanuc   Created
//
//*************************************************************

BOOL GetInterface(handle_t * phIfHandle, LPTSTR lpRPCEndPoint)
{
    RPC_STATUS              status;
    LPTSTR                  pszStringBinding = NULL;
    BOOL                    bStringBinding = FALSE, bRetVal = FALSE;

    // compose string to pass to binding api

    status = RpcStringBindingCompose(NULL,
                                     cszRPCProtocol,
                                     NULL,
                                     lpRPCEndPoint,
                                     NULL,
                                     &pszStringBinding);
    if (status != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("GetInterface:  RpcStringBindingCompose fails with error %ld"), status));
        goto Exit;
    }
    bStringBinding = TRUE;

    // set the binding handle that will be used to bind to the server.

    status = RpcBindingFromStringBinding(pszStringBinding,
                                         phIfHandle);
    if (status != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("GetInterface:  RpcStringBindingCompose fails with error %ld"), status));
        goto Exit;
    }
   
    bRetVal = TRUE;
    DebugMsg((DM_VERBOSE, TEXT("GetInterface: Returning rpc binding handle")));

Exit:
    // free string

    if (bStringBinding) 
        RpcStringFree(&pszStringBinding);

    return bRetVal;
}

//*************************************************************
//
//  ReleaseInterface()
//
//  Purpose:    Release the rpc binding handle 
//
//  Parameters: phIfHandle    - rpc binding handle to initialize
//
//  Return:     TRUE if successful.
//
//  History:    Date        Author     Comment
//              10/24/00    santanuc   Created
//
//*************************************************************

BOOL ReleaseInterface(handle_t * phIfHandle)
{
    RPC_STATUS    status;

    // free binding handle

    DebugMsg((DM_VERBOSE, TEXT("ReleaseInterface: Releasing rpc binding handle")));
    status = RpcBindingFree(phIfHandle);

    return (status == RPC_S_OK);
}


//*************************************************************
//
// Routine Description:
//
//    This routine determines if we're doing a gui-mode setup.
//
//    This value is retrieved from the following registry location:
//
//    \HKLM\System\Setup\
//
//        SystemSetupInProgress : REG_DWORD : 0x00 (where nonzero
//        means we're doing a gui-setup)
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    TRUE/FALSE
//
// Note:
//
//    This function is courtesy of Andrew Ritz and the Setup API.
//    It's copied over from base\pnp\setupapi\dll.c.
//
//***************************************************************

BOOL IsGuiSetupInProgress()
{
    HKEY hKey;
    DWORD Err, DataType, DataSize = sizeof(DWORD);
    DWORD Value;

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT("System\\Setup"),
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {
        //
        // Attempt to read the the "DriverCachePath" value.
        //
        Err = RegQueryValueEx(
                    hKey,
                    TEXT("SystemSetupInProgress"),
                    NULL,
                    &DataType,
                    (LPBYTE)&Value,
                    &DataSize);

        RegCloseKey(hKey);
    }

    if(Err == NO_ERROR) {
        if(Value) {
            return(TRUE);
        }
    }

    return(FALSE);

}


//*************************************************************
//
//  CheckNetDefaultProfile()
//
//  Purpose:    Checks if a network profile exists
//
//  Parameters: lpProfile   -   Profile information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   This routine assumes we are working
//              in the user's context.
//
//  History:    Date        Author     Comment
//              9/21/95     ericflo    Created
//              4/10/99     ushaji     modified to remove local caching
//
//*************************************************************

BOOL CheckNetDefaultProfile (LPPROFILE lpProfile)
{
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szLocalDir[MAX_PATH];
    DWORD dwSize, dwFlags, dwErr;
    LPTSTR lpEnd;
    BOOL bRetVal = FALSE;
    LPTSTR lpNetPath = lpProfile->lpDefaultProfile;
    HANDLE hOldToken;


    //
    // Get the error at the beginning of the call.
    //

    dwErr = GetLastError();


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile: Entering, lpNetPath = <%s>"),
             (lpNetPath ? lpNetPath : TEXT("NULL"))));


    if (!lpNetPath || !(*lpNetPath)) {
        return bRetVal;
    }

    //
    // Impersonate the user....
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {

        if (lpProfile->lpDefaultProfile) {
            *lpProfile->lpDefaultProfile = TEXT('\0');
        }

        //
        // Last error is set
        //

        return bRetVal;
    }

    //
    // See if network copy exists
    //

    hFile = FindFirstFile (lpNetPath, &fd);

    if (hFile != INVALID_HANDLE_VALUE) {


        //
        // Close the find handle
        //

        FindClose (hFile);


        //
        // We found something.  Is it a directory?
        //

        if ( !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {

            DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile:  FindFirstFile found a file. ignoring Network Defaul profile")));
            dwErr = ERROR_FILE_NOT_FOUND;
            goto Exit;
        }


        //
        // Is there a ntuser.* file in this directory?
        //

        lstrcpy (szBuffer, lpNetPath);
        lpEnd = CheckSlash (szBuffer);
        lstrcpy (lpEnd, c_szNTUserStar);


        hFile = FindFirstFile (szBuffer, &fd);

        if (hFile == INVALID_HANDLE_VALUE) {
            DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile:  FindFirstFile found a directory, but no ntuser files.")));
            dwErr = ERROR_FILE_NOT_FOUND;
            goto Exit;
        }

        FindClose (hFile);


        DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile:  Found a valid network profile.")));

        bRetVal = TRUE;

    }
    else {
        dwErr = ERROR_FILE_NOT_FOUND;
    }

Exit:

    //
    // If we are leaving successfully, then
    // save the local profile directory.
    //

    if (bRetVal) {
        DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile: setting default profile to <%s>"), lpNetPath));

    } else {
        DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile: setting default profile to NULL")));

        //
        // resetting it to NULL in case we didn't see the server directory.
        //

        if (lpProfile->lpDefaultProfile) {
            *lpProfile->lpDefaultProfile = TEXT('\0');
        }
    }


    //
    // Tag the internal flags so we don't do this again.
    //

    lpProfile->dwInternalFlags |= DEFAULT_NET_READY;

    //
    // Now set the last error
    //

    //
    // Revert before trying to delete the local default network profile
    //

    RevertToUser(&hOldToken);

    //
    // We will keep this on always so that we can delete any preexisting
    // default network profile, try to delete it and ignore
    // the failure if it happens

    //
    // Expand the local profile directory
    //


    dwSize = ARRAYSIZE(szLocalDir);
    if (!GetProfilesDirectoryEx(szLocalDir, &dwSize, TRUE)) {
        DebugMsg((DM_WARNING, TEXT("CheckNetDefaultProfile:  Failed to get default user profile.")));
        SetLastError(dwErr);
        return bRetVal;
    }


    lpEnd = CheckSlash (szLocalDir);
    lstrcpy (lpEnd, DEFAULT_USER_NETWORK);


    DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile:  Removing local copy of network default user profile.")));
    Delnode (szLocalDir);


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile:  Leaving with a value of %d."), bRetVal));


    SetLastError(dwErr);

    return bRetVal;
}


//*************************************************************
//
//  ParseProfilePath()
//
//  Purpose:    Parses the profile path to determine if
//              it points at a directory or a filename.
//              In addition it determines whether a profile is
//              acoss a slow link and whether the user has access
//              to the profile.
//
//  Parameters: lpProfile       -   Profile Information
//              lpProfilePath   -   Input path
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/6/95      ericflo    Created
//
//*************************************************************

BOOL ParseProfilePath(LPPROFILE lpProfile, LPTSTR lpProfilePath, BOOL *bpCSCBypassed, TCHAR *cpDrive)
{
    DWORD           dwAttributes;
    LPTSTR          lpEnd;
    BOOL            bRetVal = FALSE;
    BOOL            bMandatory = FALSE;
    DWORD           dwStart, dwDelta, dwErr = ERROR_SUCCESS;
    DWORD           dwStrLen;
    HANDLE          hOldToken;
    TCHAR           szErr[MAX_PATH];
    BOOL            bAddAdminGroup = FALSE;
    BOOL            bReadOnly = FALSE;
    HKEY            hSubKey;
    DWORD           dwSize, dwType;
    BOOL            bImpersonated = FALSE;
    LPTSTR          lpCscBypassedPath = NULL;


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: Entering, lpProfilePath = <%s>"),
             lpProfilePath));


    if (lpProfile->dwUserPreference == USERINFO_LOCAL) {
        DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: User preference is local. Ignoring roaming profile path")));
        goto DisableAndExit;
    }

    //
    // Check for .man extension
    //

    dwStrLen = lstrlen (lpProfilePath);

    if (dwStrLen >= 4) {

        lpEnd = lpProfilePath + dwStrLen - 4;
        if (!lstrcmpi(lpEnd, c_szMAN)) {
            bMandatory = TRUE;
            lpProfile->dwInternalFlags |= PROFILE_MANDATORY;
            DebugMsg((DM_WARNING, TEXT("ParseProfilePath: Mandatory profile (.man extension)")));
        }
    }


    //
    // Check whether we need to give access to the admin on the RUP share
    //

    //
    // Check for a roaming profile security/read only preference
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ,
                     &hSubKey) == ERROR_SUCCESS) {

        dwSize = sizeof(bAddAdminGroup);
        RegQueryValueEx(hSubKey, ADD_ADMIN_GROUP_TO_RUP, NULL, &dwType,
                        (LPBYTE) &bAddAdminGroup, &dwSize);

        dwSize = sizeof(bReadOnly);
        RegQueryValueEx(hSubKey, READONLY_RUP, NULL, &dwType,
                        (LPBYTE) &bReadOnly, &dwSize);

        RegCloseKey(hSubKey);
    }


    //
    // Check for a roaming profile security/read only policy
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY, 0, KEY_READ,
                     &hSubKey) == ERROR_SUCCESS) {

        dwSize = sizeof(bAddAdminGroup);
        RegQueryValueEx(hSubKey, ADD_ADMIN_GROUP_TO_RUP, NULL, &dwType,
                        (LPBYTE) &bAddAdminGroup, &dwSize);

        dwSize = sizeof(bReadOnly);
        RegQueryValueEx(hSubKey, READONLY_RUP, NULL, &dwType,
                        (LPBYTE) &bReadOnly, &dwSize);
        RegCloseKey(hSubKey);
    }


    if (bReadOnly) {
        lpProfile->dwInternalFlags |= PROFILE_READONLY;
    }

    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("ParseProfilePath: Failed to impersonate user")));
        // last error is already set.
        return FALSE;
    }

    bImpersonated = TRUE;

    // Check whether RUP share is CSCed, if it is give a warning.

    CheckRUPShare(lpProfilePath);

    // 
    // Try to bypass CSC to avoid conflicts in syncing files between roaming share & local profile
    //

    if (IsUNCPath(lpProfilePath)) {
        if ((dwErr = AbleToBypassCSC(lpProfile->hTokenUser, lpProfilePath, &lpCscBypassedPath, cpDrive)) == ERROR_SUCCESS) {
            *bpCSCBypassed = TRUE;
            lpProfilePath = lpCscBypassedPath;
            DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: CSC bypassed. Profile path %s"), lpProfilePath));
        }
        else {
            if (dwErr == WN_BAD_LOCALNAME || dwErr == WN_ALREADY_CONNECTED || dwErr == ERROR_BAD_PROVIDER) {
                DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: CSC bypassed failed. Profile path %s"), lpProfilePath));
                dwErr = ERROR_SUCCESS;
            }
            else {
                // Share is not up. So we do not need to do any further check
                DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: CSC bypassed failed. Ignoring Roaming profile path")));
                goto Exit;
            }
        }    
    }

    //
    // Start by calling GetFileAttributes so we have file attributes
    // to work with.  We have to call GetFileAttributes twice.  The
    // first call sets up the session so we can call it again and
    // get accurate timing information for slow link detection.
    //


    dwAttributes = GetFileAttributes(lpProfilePath);

    if (dwAttributes != -1) {
        dwStart = GetTickCount();

        dwAttributes = GetFileAttributes(lpProfilePath);
    
        dwDelta = GetTickCount() - dwStart;

        DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: Tick Count = %d"), dwDelta));

        //
        // if it is success, find out whether the profile is
        // across a slow link.
        //
        // Looks like this is possible at least when a
        // share doesn't exist on a server across a slow link.
        // if this is not possible
        //      then checkforslowlink will have to be moved down to check
        //      after we have found a valid share
        //


        if (!bMandatory && !bReadOnly) {
            CheckForSlowLink (lpProfile, dwDelta, lpProfile->lpProfilePath, TRUE);
            if (lpProfile->dwInternalFlags & PROFILE_SLOW_LINK) {
                DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: Profile is across a slow link. Ignoring roaming profile path")));
                goto DisableAndExit;
            }
        }
    }
    else {
        dwErr = GetLastError(); // get the error now for later use
    }

    //
    // if we have got a valid handle
    //

    if (dwAttributes != -1) {

        //
        // GetFileAttributes found something.
        // look at the file attributes.
        //

        DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: GetFileAttributes found something with attributes <0x%x>"),
                 dwAttributes));

        //
        // If we found a directory, we have a proper profile
        // directory. exit.
        //

        if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: Found a directory")));
            bRetVal = TRUE;
            goto Exit;
        }
        else {

            //
            // We found a file.
            //
            // In 3.51, we used to have a file for the profile.
            //
            // In the migration part of the code, we used to take this file
            // nad migrate to a directory that ends in .pds (for normal profiles)
            // and .pdm for (for mandatory profiles).
            //

            DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: Found a file")));

        }

        dwErr = ERROR_PATH_NOT_FOUND;
        goto Exit;

    }


    //
    // GetFileAttributes failed.  Look at the error to determine why.
    //

    DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: GetFileAttributes failed with error %d"),
              dwErr));


    if (bMandatory) {
        DebugMsg((DM_WARNING, TEXT("ParseProfilePath: Couldn't access mandatory profile <%s> with error %d"), lpProfilePath, GetLastError()));
        goto Exit;
    }


    if (bReadOnly) {
        DebugMsg((DM_WARNING, TEXT("ParseProfilePath: Couldn't access mandatory profile <%s> with error %d"), lpProfilePath, GetLastError()));
        goto Exit;
    }


    //
    // To fix bug #414176, the last error code chk has been added.
    //
    // ERROR_BAD_NET_NAME is the error code that is returned by GetFileAttributes
    // when the profile directory for a user actually points to the root
    // of the share.
    // CreateDirectory should succeed.
    //

    if ( (dwErr == ERROR_FILE_NOT_FOUND) ||
         (dwErr == ERROR_PATH_NOT_FOUND) ||
         (dwErr == ERROR_BAD_NET_NAME) ) {

        //
        // Nothing found with this name.
        //
        // In 3.51, we used to have a file for the profile.
        //
        // In the migration part of the code, we used to take this file
        // nad migrate to a directory that ends in .pds (for normal profiles)
        // and .pdm for (for mandatory profiles).
        //

        if (CreateSecureDirectory(lpProfile, lpProfilePath, NULL, !bAddAdminGroup)) {

            //
            // Successfully created the directory.
            //

            DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: Succesfully created the sub-directory")));
            bRetVal = TRUE;
            goto Exit;

        } else {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ParseProfilePath: Failed to create user sub-directory.  Error = %d"),
                     GetLastError()));
            goto Exit;
        }
    }

    goto Exit;


Exit:

    if (!bRetVal) {


        //
        // We have failed to connect to the profile server for some reason.
        // Now evaluate whether we want to disable profile and log the user in
        // or prevent the user from logging on.
        //
        // In addition give an appropriate popup..
        //


        if (IsUserAnAdminMember(lpProfile->hTokenUser)) {
            if (bMandatory) {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_MANDATORY_NOT_AVAILABLE_DISABLE, GetErrString(dwErr, szErr));
            }
            else if (bReadOnly) {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_READONLY_NOT_AVAILABLE_DISABLE, GetErrString(dwErr, szErr));
            }
            else {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_CENTRAL_NOT_AVAILABLE_DISABLE, GetErrString(dwErr, szErr));
            }

            goto DisableAndExit;
        }
        else {
            if (bMandatory) {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_MANDATORY_NOT_AVAILABLE_ERROR, GetErrString(dwErr, szErr));
            }
            else if (bReadOnly) {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_READONLY_NOT_AVAILABLE_DISABLE, GetErrString(dwErr, szErr));
                goto DisableAndExit;

                // temporary profile decisions will kick in, in restoreuserprofile later on..
             }
            else {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_CENTRAL_NOT_AVAILABLE_DISABLE, GetErrString(dwErr, szErr));
                goto DisableAndExit;

                // temporary profile decisions will kick in, in restoreuserprofile later on..
            }
        }
    }
    else {
        lstrcpy(lpProfile->lpRoamingProfile, lpProfilePath);
    }

    goto CleanupAndExit;


DisableAndExit:

    lpProfile->lpRoamingProfile[0] = TEXT('\0');

    bRetVal = TRUE;


CleanupAndExit:

    //
    // Revert to being 'ourself'
    //

    if(bImpersonated) {
        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("ParseProfilePath: Failed to revert to self")));
        }
    }

    if (lpCscBypassedPath) {
        LocalFree(lpCscBypassedPath);
    }

    if (!bRetVal)
        SetLastError(dwErr);

    return bRetVal;
}


//*************************************************************
//
//  GetExclusionList()
//
//  Purpose:    Get's the exclusion list used at logon
//
//  Parameters: lpProfile   - Profile Information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL GetExclusionList (LPPROFILE lpProfile)
{
    LPTSTR szExcludeListLocal = NULL;
    LPTSTR szExcludeListServer = NULL;
    LPTSTR szNTUserIni = NULL;
    LPTSTR lpEnd;
    HANDLE hOldToken;
    BOOL   bRetVal = FALSE;


    // 
    // Allocate memory for Local variables to avoid stack overflow
    //

    szExcludeListLocal = (LPTSTR)LocalAlloc(LPTR, 2*MAX_PATH*sizeof(TCHAR));
    if (!szExcludeListLocal) {
        DebugMsg((DM_WARNING, TEXT("GetExclusionList: Out of memory")));
        goto Exit;
    }

    szExcludeListServer = (LPTSTR)LocalAlloc(LPTR, 2*MAX_PATH*sizeof(TCHAR));
    if (!szExcludeListServer) {
        DebugMsg((DM_WARNING, TEXT("GetExclusionList: Out of memory")));
        goto Exit;
    }

    szNTUserIni = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szNTUserIni) {
        DebugMsg((DM_WARNING, TEXT("GetExclusionList: Out of memory")));
        goto Exit;
    }

    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("GetExclusionList: Failed to impersonate user")));
        // last error is set
        goto Exit;
    }

    //
    // Get the exclusion list from the server
    //

    szExcludeListServer[0] = TEXT('\0');

    lstrcpy (szNTUserIni, lpProfile->lpRoamingProfile);
    lpEnd = CheckSlash (szNTUserIni);
    lstrcpy(lpEnd, c_szNTUserIni);

    GetPrivateProfileString (PROFILE_GENERAL_SECTION,
                             PROFILE_EXCLUSION_LIST,
                             TEXT(""), szExcludeListServer,
                             2*MAX_PATH,
                             szNTUserIni);


    //
    // Get the exclusion list from the cache
    //

    szExcludeListLocal[0] = TEXT('\0');

    lstrcpy (szNTUserIni, lpProfile->lpLocalProfile);
    lpEnd = CheckSlash (szNTUserIni);
    lstrcpy(lpEnd, c_szNTUserIni);

    GetPrivateProfileString (PROFILE_GENERAL_SECTION,
                             PROFILE_EXCLUSION_LIST,
                             TEXT(""), szExcludeListLocal,
                             2*MAX_PATH,
                             szNTUserIni);


    //
    // Go back to system security context
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("GetExclusionList: Failed to revert to self")));
    }


    //
    // See if the lists are the same
    //

    if (!lstrcmpi (szExcludeListServer, szExcludeListLocal)) {

        if (szExcludeListServer[0] != TEXT('\0')) {

            lpProfile->lpExclusionList = (LPTSTR)LocalAlloc (LPTR, (lstrlen (szExcludeListServer) + 1) * sizeof(TCHAR));

            if (lpProfile->lpExclusionList) {
                lstrcpy (lpProfile->lpExclusionList, szExcludeListServer);

                DebugMsg((DM_VERBOSE, TEXT("GetExclusionList:  The exclusion lists on both server and client are the same.  The list is: <%s>"),
                         szExcludeListServer));
            } else {
                DebugMsg((DM_WARNING, TEXT("GetExclusionList:  Failed to allocate memory for exclusion list with error %d"),
                         GetLastError()));
            }
        } else {
            DebugMsg((DM_VERBOSE, TEXT("GetExclusionList:  The exclusion on both server and client is empty.")));
        }

    } else {
        DebugMsg((DM_VERBOSE, TEXT("GetExclusionList:  The exclusion lists between server and client are different.  Server is <%s> and client is <%s>"),
                 szExcludeListServer, szExcludeListLocal));
    }

    bRetVal = TRUE;

Exit:

    if (szExcludeListLocal) {
        LocalFree(szExcludeListLocal);
    }

    if (szExcludeListServer) {
        LocalFree(szExcludeListServer);
    }

    if (szNTUserIni) {
        LocalFree(szNTUserIni);
    }

    return bRetVal;
}


//*************************************************************
//
//  RestoreUserProfile()
//
//  Purpose:    Downloads the user's profile if possible,
//              otherwise use either cached profile or
//              default profile.
//
//  Parameters: lpProfile   -   Profile information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************

BOOL RestoreUserProfile(LPPROFILE lpProfile)
{
    BOOL  IsCentralReachable = FALSE;
    BOOL  IsLocalReachable = FALSE;
    BOOL  IsMandatory = FALSE;
    BOOL  IsProfilePathNULL = FALSE;
    BOOL  bCreateCentralProfile = FALSE;
    BOOL  bDefaultUsed = FALSE;
    BOOL  bCreateLocalProfile = TRUE;
    LPTSTR lpRoamingProfile = NULL;
    LPTSTR lpLocalProfile;
    BOOL  bProfileLoaded = FALSE;
    BOOL  bDefaultProfileIssued = FALSE;
    BOOL bNewUser = TRUE;
    LPTSTR SidString;
    LONG error = ERROR_SUCCESS;
    LPTSTR szProfile = NULL;
    LPTSTR szDefaultProfile = NULL;
    LPTSTR lpEnd;
    BOOL bRet;
    DWORD dwSize, dwFlags, dwErr=0, dwErr1;
    HANDLE hOldToken;
    LPTSTR szErr = NULL;
    BOOL bOwnerOK = TRUE;
 

    //
    // Get the error at the beginning of the call.
    //

    dwErr1 = GetLastError();

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Entering")));


    //
    // Get the Sid string for the current user
    //

    SidString = GetSidString(lpProfile->hTokenUser);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  Failed to get sid string for user")));
        return FALSE;
    }

    // 
    // Allocate memory for Local variables to avoid stack overflow
    //

    szProfile = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szProfile) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("RestoreUserProfile: Out of memory")));
        goto CleanUp;
    }

    szDefaultProfile = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szDefaultProfile) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("RestoreUserProfile: Out of memory")));
        goto CleanUp;
    }

    szErr = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szErr) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("RestoreUserProfile: Out of memory")));
        goto CleanUp;
    }

    //
    // Test if this user is a guest.
    //

    if (IsUserAGuest(lpProfile->hTokenUser)) {
        lpProfile->dwInternalFlags |= PROFILE_GUEST_USER;
        DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  User is a Guest")));
    }

    //
    // Test if this user is an admin.
    //

    if (IsUserAnAdminMember(lpProfile->hTokenUser)) {
        lpProfile->dwInternalFlags |= PROFILE_ADMIN_USER;
        lpProfile->dwInternalFlags &= ~PROFILE_GUEST_USER;
        DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  User is a Admin")));
    }

    //
    // Decide if the central profilemage is available.
    //

    IsCentralReachable = IsCentralProfileReachable(lpProfile,
                                                   &bCreateCentralProfile,
                                                   &IsMandatory,
                                                   &bOwnerOK);

    if (IsCentralReachable) {

        DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Central Profile is reachable")));

        if (IsMandatory) {
            lpProfile->dwInternalFlags |= PROFILE_MANDATORY;
            DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Central Profile is mandatory")));

        } else {
            lpProfile->dwInternalFlags |= PROFILE_UPDATE_CENTRAL;
            lpProfile->dwInternalFlags |= bCreateCentralProfile ? PROFILE_NEW_CENTRAL : 0;
            DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Central Profile is roaming")));

            if ((lpProfile->dwUserPreference == USERINFO_LOCAL) ||
                (lpProfile->dwInternalFlags & PROFILE_SLOW_LINK)) {
                DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Ignoring central profile due to User Preference of Local only (or slow link).")));
                IsProfilePathNULL = TRUE;
                IsCentralReachable = FALSE;
                goto CheckLocal;
            }
        }

    } else {
        if (*lpProfile->lpRoamingProfile) {
            error = GetLastError();
            DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile: IsCentralProfileReachable returned FALSE. error = %d"),
                     error));

            if (lpProfile->dwInternalFlags & PROFILE_MANDATORY) {
                dwErr = error;
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_MANDATORY_NOT_AVAILABLE_ERROR, GetErrString(error, szErr));
                goto Exit;

            } else if (lpProfile->dwInternalFlags & PROFILE_READONLY) {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_READONLY_NOT_AVAILABLE, GetErrString(error, szErr));
                *lpProfile->lpRoamingProfile = TEXT('\0');
            } else if (!bOwnerOK) {
                ReportError(lpProfile->hTokenUser, EVENT_ERROR_TYPE, 0, EVENT_LOGON_RUP_NOT_SECURE);
                *lpProfile->lpRoamingProfile = TEXT('\0');
            } else {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_CENTRAL_NOT_AVAILABLE, GetErrString(error, szErr));
                *lpProfile->lpRoamingProfile = TEXT('\0');
            }
        }
    }

    //
    // do not create a new profile locally if there is a central profile and
    // it is not reachable and if we do not have slow link or user preferences set 
    // or read only profile.
    //

    if ((lpProfile->lpProfilePath) && (*lpProfile->lpProfilePath)) {
        if ((!IsCentralReachable) &&
            (lpProfile->dwUserPreference != USERINFO_LOCAL) && 
            (!(lpProfile->dwInternalFlags & PROFILE_SLOW_LINK)) &&
            (!(lpProfile->dwInternalFlags & PROFILE_READONLY)))

            bCreateLocalProfile = FALSE;
    }

    lpRoamingProfile = lpProfile->lpRoamingProfile;

    DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Profile path = <%s>"), lpRoamingProfile ? lpRoamingProfile : TEXT("")));
    if (!lpRoamingProfile || !(*lpRoamingProfile)) {
        IsProfilePathNULL = TRUE;
    }


CheckLocal:

    //
    // Determine if the local copy of the profilemage is available.
    //

    IsLocalReachable = GetExistingLocalProfileImage(lpProfile);

    if (IsLocalReachable) {
        DebugMsg((DM_VERBOSE, TEXT("Local Existing Profile Image is reachable")));

        //
        // If we assign a TEMP profile from previous session due to leak
        // then issue a error message
        //
 
        if (lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED) {
            ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_TEMPPROFILEASSIGNED);
        }

    } else {

        bNewUser = FALSE;
        if (bCreateLocalProfile)
        {
            bNewUser = CreateLocalProfileImage(lpProfile, lpProfile->lpUserName);
            if (!bNewUser) {
                DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  CreateLocalProfileImage failed. Unable to create a new profile!")));
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("Creating Local Profile")));
                IsLocalReachable = TRUE;
            }
        }

        if (!bNewUser) {

            if (lpProfile->dwFlags & PI_LITELOAD) {

                //
                // in lite load conditions we do not load a profile if it is not going to be cached on the machine.
                //

                dwErr = GetLastError();
                DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  Profile not loaded because server is unavailable during liteload")));
                goto Exit;
            }

            //
            // if the user is not admin and is not allowed to create temp profile log him out.
            //

            if ((!(lpProfile->dwInternalFlags & PROFILE_ADMIN_USER)) && (!IsTempProfileAllowed())) {
                DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  User being logged off because of no temp profile policy")));

                //
                // We have already lost the error returned from parseprofilepath. PATH_NOT_FOUND sounds quite close.
                // returning this.
                //

                dwErr = ERROR_PATH_NOT_FOUND;
                goto Exit;
            }

            if (!CreateLocalProfileImage(lpProfile, TEMP_PROFILE_NAME_BASE)) {
                dwErr = GetLastError();
                DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  CreateLocalProfileImage with TEMP failed with error %d.  Unable to issue temporary profile!"), dwErr));
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_TEMP_DIR_FAILED, GetErrString(dwErr, szErr));
                goto Exit;
            }
            else {
                lpProfile->dwInternalFlags |= PROFILE_TEMP_ASSIGNED;

                if (!bCreateLocalProfile)
                    ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_TEMPPROFILEASSIGNED);
                else {
                    //
                    // We have failed to create a local profile. So issue a proper error message.
                    //
                    ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_TEMPPROFILEASSIGNED2);
                }
            }
        }

        // clear any partly loaded flag if it exists, since this is a new profile.
        lpProfile->dwInternalFlags &= ~PROFILE_PARTLY_LOADED;
        lpProfile->dwInternalFlags |= PROFILE_NEW_LOCAL;
    }


    lpLocalProfile = lpProfile->lpLocalProfile;

    DebugMsg((DM_VERBOSE, TEXT("Local profile name is <%s>"), lpLocalProfile));

    //
    // If we assign a TEMP profile from previous session due to leak
    // then do not reconcile RUP with TEMP profile
    //

    if ((lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED) && IsCentralReachable) {
        IsCentralReachable = FALSE;
    }


    //
    // We can do a couple of quick checks here to filter out
    // new users.
    //

    if (( (lpProfile->dwInternalFlags & PROFILE_NEW_CENTRAL) &&
          (lpProfile->dwInternalFlags & PROFILE_NEW_LOCAL) ) ||
          (!IsCentralReachable &&
          (lpProfile->dwInternalFlags & PROFILE_NEW_LOCAL) )) {

       DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Working with a new user.  Go straight to issuing a default profile.")));
       goto IssueDefault;
    }


    //
    // If both central and local profileimages exist, reconcile them
    // and load.
    //

    if (IsCentralReachable && IsLocalReachable) {

        DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Reconciling roaming profile with local profile")));

        GetExclusionList (lpProfile);


        //
        // Impersonate the user
        //

        if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
            bProfileLoaded = FALSE;
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile: Failed to impersonate user")));
            goto Exit;
        }


        //
        // Copy the profile
        //

        dwFlags = (lpProfile->dwFlags & PI_NOUI) ? CPD_NOERRORUI : 0;


        //
        // if the roaming profile is empty and the local profile is
        // mandatory, treat the profile as mandatory.
        //
        // Same as Win2k
        //

        if ((lpProfile->dwInternalFlags & PROFILE_NEW_CENTRAL) &&
            (lpProfile->dwInternalFlags & PROFILE_LOCALMANDATORY)) {
            lpProfile->dwInternalFlags |= PROFILE_MANDATORY;
        }


        //
        // This can possibly be a transition from mandatory to non mandatory.
        // In that case, since the local profile is mandatory
        // we wouldn't expect any items from here to be synced with the
        // server yet. Go for a full sync with server but the profile will
        // not be marked mandatory from now on.
        //

        if ((lpProfile->dwInternalFlags & PROFILE_MANDATORY) ||
            (lpProfile->dwInternalFlags & PROFILE_READONLY)  ||
            (lpProfile->dwInternalFlags & PROFILE_LOCALMANDATORY)) {
            dwFlags |= (CPD_COPYIFDIFFERENT | CPD_SYNCHRONIZE);
        }

        if (lpProfile->dwFlags & (PI_LITELOAD | PI_HIDEPROFILE)) {
            dwFlags |= CPD_SYSTEMFILES | CPD_SYSTEMDIRSONLY;
        }
        else
            dwFlags |= CPD_NONENCRYPTEDONLY;

        //
        // Profile unload time does not exist for mandatory, temp and read only profile.
        // But for read only profile we still want to use exclusion list without any ref time
        //

        if (lpProfile->lpExclusionList && *lpProfile->lpExclusionList) {
            if (lpProfile->dwInternalFlags & PROFILE_READONLY) {
                dwFlags |= CPD_USEEXCLUSIONLIST;
            }            
            else if (lpProfile->ftProfileUnload.dwHighDateTime || lpProfile->ftProfileUnload.dwLowDateTime) {
                dwFlags |= (CPD_USEDELREFTIME | CPD_SYNCHRONIZE | CPD_USEEXCLUSIONLIST);
            }
        }

        //
        // If roaming copy is partial (due to LITE upload) then ignore the hive and 
        // synchronize logic as it will end up deleting files from destination - a 
        // massive data loss.
        //

        if (IsPartialRoamingProfile(lpProfile)) {
            dwFlags &= ~CPD_SYNCHRONIZE;
            dwFlags |= CPD_IGNOREHIVE;
        }

        //
        // Check whether in local machine user profile is switching from local to 
        // roaming for first time. If yes and we have a existing hive in RUP share 
        // then always overwrite the local hive with hive in RUP share. This is 
        // to avoid wrong hive usage due to cached login
        //

        TouchLocalHive(lpProfile);

        bRet = CopyProfileDirectoryEx (lpRoamingProfile,
                                       lpLocalProfile,
                                       dwFlags, &lpProfile->ftProfileUnload,
                                       lpProfile->lpExclusionList);


        //
        // Revert to being 'ourself'
        //

        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile: Failed to revert to self")));
        }


        if (!bRet) {
            error = GetLastError();
            if (error == ERROR_DISK_FULL) {
                dwErr = error;
                DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  CopyProfileDirectory failed because of DISK_FULL, Exitting")));
                goto Exit;
            }

            if (error == ERROR_FILE_ENCRYPTED) {
                dwErr = error;
                DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  CopyProfileDirectory returned FALSE.  Error = %d"), error));
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_PROFILEUPDATE_6002);
                lpProfile->dwInternalFlags &= ~PROFILE_UPDATE_CENTRAL;
                // show the popup but exit only in the case if it is a new local profile

                if (lpProfile->dwInternalFlags & PROFILE_NEW_LOCAL)
                    goto IssueDefault;
            }
            else {

                DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  CopyProfileDirectory failed.  Issuing default profile")));
                lpProfile->dwInternalFlags &= ~PROFILE_UPDATE_CENTRAL;
                lpProfile->dwInternalFlags |= PROFILE_DELETE_CACHE;
                goto IssueDefault;
            }
        }

        lstrcpy (szProfile, lpLocalProfile);
        lpEnd = CheckSlash(szProfile);

        //
        // If the central profile is unreachable and the local profile
        // is manatory, treat it as mandatory. This is the same as Win2k
        //
        // We are not copying anything from the server
        //

        if (lpProfile->dwInternalFlags & PROFILE_LOCALMANDATORY) {
            lpProfile->dwInternalFlags |= PROFILE_MANDATORY;
        }


        if (lpProfile->dwInternalFlags & PROFILE_MANDATORY) {
            lstrcpy (lpEnd, c_szNTUserMan);
        } else {
            lstrcpy (lpEnd, c_szNTUserDat);
        }

        error = MyRegLoadKey(HKEY_USERS, SidString, szProfile);
        bProfileLoaded = (error == ERROR_SUCCESS);


        //
        // If we failed to load the central profile for some
        // reason, don't update it when we log off.
        //

        if (bProfileLoaded) {
            goto Exit;

        } else {
            dwErr = error;

            lpProfile->dwInternalFlags &= ~PROFILE_UPDATE_CENTRAL;
            lpProfile->dwInternalFlags |= PROFILE_DELETE_CACHE;

            if (error == ERROR_BADDB) {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_FAILED_LOAD_1009);
                goto IssueDefault;
            } else if (error == ERROR_NO_SYSTEM_RESOURCES) {
                goto Exit;
            }
            else {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_FAILED_LOAD_LOCAL, GetErrString(error, szErr));
                goto IssueDefault;
            }
        }
    }


    //
    // Only a local profile exists so use it.
    //

    if (!IsCentralReachable && IsLocalReachable) {

        DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  No central profile.  Attempting to load local profile.")));

        lstrcpy (szProfile, lpLocalProfile);
        lpEnd = CheckSlash(szProfile);

        //
        // If the central profile is unreachable and the local profile
        // is manatory, treat it as mandatory. This is the same as Win2k
        //
        // We are not copying anything from the server
        //

        if (lpProfile->dwInternalFlags & PROFILE_LOCALMANDATORY) {
            lpProfile->dwInternalFlags |= PROFILE_MANDATORY;
        }
        
        if (lpProfile->dwInternalFlags & PROFILE_MANDATORY) {
            lstrcpy (lpEnd, c_szNTUserMan);
        } else {
            lstrcpy (lpEnd, c_szNTUserDat);
        }

        error = MyRegLoadKey(HKEY_USERS, SidString, szProfile);
        bProfileLoaded = (error == ERROR_SUCCESS);

        if (!bProfileLoaded) {

            DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  MyRegLoadKey returned FALSE.")));
            dwErr = error;

            if (error == ERROR_BADDB) {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_FAILED_LOAD_1009);
                lpProfile->dwInternalFlags |= PROFILE_DELETE_CACHE;
                goto IssueDefault;
            } else if (error == ERROR_NO_SYSTEM_RESOURCES) {
                goto Exit;
            } else {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_FAILED_LOAD_LOCAL, GetErrString(error, szErr));
            }
        }

        if (!bProfileLoaded && IsProfilePathNULL) {
            DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Failed to load local profile and profile path is NULL, going to overwrite local profile")));
            lpProfile->dwInternalFlags |= PROFILE_DELETE_CACHE;
            goto IssueDefault;
        }
        goto Exit;
    }


    //
    // Last combination.  Unable to access a local profile cache,
    // but a central profile exists.  Use the temporary profile.
    //


    if (IsCentralReachable) {

        DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Using temporary cache with central profile")));

        GetExclusionList (lpProfile);

        //
        // Impersonate the user
        //


        if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile: Failed to impersonate user")));
            dwErr = GetLastError();
            goto Exit;
        }

        //
        // Local is not reachable. So Localmandatory will not be set..
        //

        dwFlags = (lpProfile->dwFlags & PI_NOUI) ? CPD_NOERRORUI : 0;
        dwFlags |= CPD_SYNCHRONIZE;

        if ((lpProfile->dwInternalFlags & PROFILE_MANDATORY) ||
            (lpProfile->dwInternalFlags & PROFILE_READONLY)) {
            dwFlags |= CPD_COPYIFDIFFERENT;
        }

        if (lpProfile->dwFlags & (PI_LITELOAD | PI_HIDEPROFILE)) {
            dwFlags |= CPD_SYSTEMFILES | CPD_SYSTEMDIRSONLY;
        }
        else
            dwFlags |= CPD_NONENCRYPTEDONLY;

        //
        // Profile unload time does not exist for mandatory, temp and read only profile.
        // But for read only profile we still want to use exclusion list without any ref time
        //

        if (lpProfile->lpExclusionList && *lpProfile->lpExclusionList) {
            if (lpProfile->dwInternalFlags & PROFILE_READONLY) {
                dwFlags |= CPD_USEEXCLUSIONLIST;
            }            
            else if (lpProfile->ftProfileUnload.dwHighDateTime || lpProfile->ftProfileUnload.dwLowDateTime) {
                dwFlags |= (CPD_USEDELREFTIME | CPD_SYNCHRONIZE | CPD_USEEXCLUSIONLIST);
            }
        }

        bRet = CopyProfileDirectoryEx (lpRoamingProfile,
                                       lpLocalProfile,
                                       dwFlags, &lpProfile->ftProfileUnload,
                                       lpProfile->lpExclusionList);


        //
        // Revert to being 'ourself'
        //

        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile: Failed to revert to self")));
        }


        //
        // Check return value
        //

        if (!bRet) {
            error = GetLastError();

            if (error == ERROR_FILE_ENCRYPTED) {
                dwErr = error;
                DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  CopyProfileDirectory returned FALSE.  Error = %d"), error));

                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_PROFILEUPDATE_6002);
                lpProfile->dwInternalFlags &= ~PROFILE_UPDATE_CENTRAL;

                // show the popup but exit only in the case if it is a new local profile
                if (lpProfile->dwInternalFlags & PROFILE_NEW_LOCAL)
                    goto IssueDefault;

            }
            else {
                DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  CopyProfileDirectory returned FALSE.  Error = %d"), error));
                goto Exit;
            }
        }

        lstrcpy (szProfile, lpLocalProfile);
        lpEnd = CheckSlash(szProfile);

        if (lpProfile->dwInternalFlags & PROFILE_MANDATORY) {
            lstrcpy (lpEnd, c_szNTUserMan);
        } else {
            lstrcpy (lpEnd, c_szNTUserDat);
        }

        error = MyRegLoadKey(HKEY_USERS, SidString, szProfile);

        bProfileLoaded = (error == ERROR_SUCCESS);


        if (bProfileLoaded) {
            goto Exit;
        }

        SetLastError(error);
        dwErr = error;

        if (error == ERROR_BADDB) {
            ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_FAILED_LOAD_1009);
            // fall through
        } else if (error == ERROR_NO_SYSTEM_RESOURCES) {
            goto Exit;
        }

        //
        // we will delete the contents at this point
        //

        lpProfile->dwInternalFlags |= PROFILE_DELETE_CACHE;
    }


IssueDefault:

    DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Issuing default profile")));

    //
    // If a cache exists, delete it, since we will
    // generate a new one below.
    //

    if (lpProfile->dwInternalFlags & PROFILE_DELETE_CACHE) {
        DWORD dwDeleteFlags=0;

        DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  Deleting cached profile directory <%s>."), lpLocalProfile));

        lpProfile->dwInternalFlags &= ~PROFILE_DELETE_CACHE;


        if ((!(lpProfile->dwInternalFlags & PROFILE_ADMIN_USER)) && (!IsTempProfileAllowed())) {

            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  User being logged off because of no temp profile policy and is not an admin")));

            //
            // We should have some error from a prev. operation. depending on that.
            //

            goto Exit;
        }


        if (lpProfile->dwInternalFlags & PROFILE_MANDATORY) {

            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  User being logged off because the profile is mandatory")));

            //
            // We should have some error from a prev. operation. depending on that.
            //

            goto Exit;
        }


        //
        // backup only if we are not using a temp profile already.
        //

        if (!(lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED))
            dwDeleteFlags |= DP_BACKUP | DP_BACKUPEXISTS;

        if ((dwDeleteFlags & DP_BACKUP) && (lpProfile->dwInternalFlags & PROFILE_NEW_LOCAL)) {
            dwDeleteFlags = 0;
        }

        if (!DeleteProfileEx (SidString, lpLocalProfile, dwDeleteFlags, HKEY_LOCAL_MACHINE, NULL)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  DeleteProfileDirectory returned false.  Error = %d"), dwErr));
            goto Exit;
        }
        else {
            if (dwDeleteFlags & DP_BACKUP) {
                lpProfile->dwInternalFlags |= PROFILE_BACKUP_EXISTS;
                ReportError(lpProfile->hTokenUser, PI_NOUI, 0, EVENT_PROFILE_DIR_BACKEDUP);
            }
        }

        if (lpProfile->dwFlags & PI_LITELOAD) {

            //
            // in lite load conditions we do not load a profile if it is not going to be cached on the machine.
            //

            // dwErr should be set before, use the same.

            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  Profile not loaded because server is unavailable during liteload")));
            goto Exit;
        }


        //
        // Create a local profile to work with
        //

        if (!CreateLocalProfileImage(lpProfile, TEMP_PROFILE_NAME_BASE)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  CreateLocalProfile Image with TEMP failed.")));
            ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_TEMP_DIR_FAILED, GetErrString(dwErr, szErr));
            goto Exit;
        }
        else
        {
            lpProfile->dwInternalFlags |= PROFILE_TEMP_ASSIGNED;
            lpProfile->dwInternalFlags |= PROFILE_NEW_LOCAL;
            // clear any partly loaded flag if it exists, since this is a new profile.
            lpProfile->dwInternalFlags &= ~PROFILE_PARTLY_LOADED;

            ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_TEMPPROFILEASSIGNED);
        }
    }


    //
    // If a default profile location was specified, try
    // that first.
    //

    if ( !(lpProfile->dwInternalFlags & DEFAULT_NET_READY) )
    {
        CheckNetDefaultProfile (lpProfile);
    }


    if ( lpProfile->lpDefaultProfile && *lpProfile->lpDefaultProfile) {

          if (IssueDefaultProfile (lpProfile, lpProfile->lpDefaultProfile,
                                    lpLocalProfile, SidString,
                                    (lpProfile->dwInternalFlags & PROFILE_MANDATORY))) {

              DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Successfully setup the specified default.")));
              bProfileLoaded = TRUE;
              goto IssueDefaultExit;
          }

          DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  IssueDefaultProfile failed with specified default.")));
    }

    //
    // IssueLocalDefault
    //

    //
    // Issue the local default profile.
    //

    dwSize = MAX_PATH;
    if (!GetDefaultUserProfileDirectory(szDefaultProfile, &dwSize)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  Failed to get default user profile.")));
        goto Exit;
    }

    if (IssueDefaultProfile (lpProfile, szDefaultProfile,
                              lpLocalProfile, SidString,
                              (lpProfile->dwInternalFlags & PROFILE_MANDATORY))) {

        DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Successfully setup the local default.")));
        bProfileLoaded = TRUE;
        goto IssueDefaultExit;
    }

    DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  IssueDefaultProfile failed with local default.")));
    dwErr = GetLastError();

IssueDefaultExit:

    //
    // If the default profile was successfully issued, then
    // we need to set the security on the hive.
    //

    if (bProfileLoaded) {
        if (!SetupNewHive(lpProfile, SidString, NULL)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  SetupNewHive failed")));
            bProfileLoaded = FALSE;
        }
        else {
            bDefaultProfileIssued = TRUE;
        }


    }


Exit:

    //
    // If the profile was loaded, then save the profile type in the
    // user's hive, and setup the "User Shell Folders" section for
    // Explorer.
    //

    if (bProfileLoaded) {

        //
        // Open the Current User key.  This will be closed in
        // UnloadUserProfile.
        //

        error = RegOpenKeyEx(HKEY_USERS, SidString, 0, KEY_ALL_ACCESS,
                             &lpProfile->hKeyCurrentUser);

        if (error != ERROR_SUCCESS) {
            bProfileLoaded = FALSE;
            dwErr = error;
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  Failed to open current user key. Error = %d"), error));
        }

    }

    if ((bProfileLoaded) && (!(lpProfile->dwFlags & PI_LITELOAD))) {

        //
        // merge the subtrees to create the HKCR tree
        //

        error = LoadUserClasses( lpProfile, SidString, bDefaultProfileIssued );

        if (error != ERROR_SUCCESS) {
            bProfileLoaded = FALSE;
            dwErr = error;
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  Failed to merge classes root. Error = %d"), error));
        }
    }


    if ((!bProfileLoaded) && (!(lpProfile->dwFlags & PI_LITELOAD))) {

        error = dwErr;

        //
        // If the user is an Admin, then let him/her log on with
        // either the .default profile, or an empty profile.
        //

        if (lpProfile->dwInternalFlags & PROFILE_ADMIN_USER) {
            ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_ADMIN_OVERRIDE, GetErrString(error, szErr));

            bProfileLoaded = TRUE;
        } else {
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile: Could not load the user profile. Error = %d"), error));
            ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_FAILED_LOAD_PROFILE, GetErrString(error, szErr));

            if (lpProfile->hKeyCurrentUser) {
                RegCloseKey (lpProfile->hKeyCurrentUser);
            }

            MyRegUnLoadKey(HKEY_USERS, SidString);

            if ((lpProfile->dwInternalFlags & PROFILE_NEW_LOCAL)) {
                if (!DeleteProfileEx (SidString, lpLocalProfile, 0, HKEY_LOCAL_MACHINE, NULL)) {
                    DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  DeleteProfileDirectory returned false.  Error = %d"), GetLastError()));
                }
            }
        }
    }


CleanUp:

    DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  About to Leave.  Final Information follows:")));
    DebugMsg((DM_VERBOSE, TEXT("Profile was %s loaded."), bProfileLoaded ? TEXT("successfully") : TEXT("NOT successfully")));
    DebugMsg((DM_VERBOSE, TEXT("lpProfile->lpRoamingProfile = <%s>"), lpProfile->lpRoamingProfile));
    DebugMsg((DM_VERBOSE, TEXT("lpProfile->lpLocalProfile = <%s>"), lpProfile->lpLocalProfile));
    DebugMsg((DM_VERBOSE, TEXT("lpProfile->dwInternalFlags = 0x%x"), lpProfile->dwInternalFlags));


    //
    // Free up the user's sid string
    //

    DeleteSidString(SidString);

    if (szProfile) {
        LocalFree(szProfile);
    }

    if (szDefaultProfile) {
        LocalFree(szDefaultProfile);
    }

    if (szErr) {
        LocalFree(szErr);
    }

    if (bProfileLoaded) {
        if (!(lpProfile->dwFlags & PI_LITELOAD)) {
            // clear any partly loaded flag if it exists, since this is a new profile.
            lpProfile->dwInternalFlags &= ~PROFILE_PARTLY_LOADED;
        }
        else {
            if (lpProfile->dwInternalFlags & PROFILE_NEW_LOCAL)
               lpProfile->dwInternalFlags |= PROFILE_PARTLY_LOADED;
        }
    }

    if (bProfileLoaded)
        SetLastError(dwErr1);
    else {

        //
        // Make sure that at least some error is returned.
        //

        if (!dwErr) {
            dwErr = ERROR_BAD_ENVIRONMENT;
        }
        SetLastError(dwErr);
    }

 
    DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Leaving.")));

    return bProfileLoaded;
}


//***************************************************************************
//
//  GetProfileSidString
//
//  Purpose:    Allocates and returns a string representing the sid that we should
//              for the profiles
//
//  Parameters: hToken          -   user's token
//
//  Return:     SidString is successful
//              NULL if an error occurs
//
//  Comments:
//              Tries to get the old sid that we used using the profile guid.
//              if it doesn't exist get the sid directly from the token
//
//  History:    Date        Author     Comment
//              11/14/95    ushaji     created
//***************************************************************************

LPTSTR GetProfileSidString(HANDLE hToken)
{
    LPTSTR lpSidString;
    TCHAR LocalProfileKey[MAX_PATH];
    LONG error;
    HKEY hSubKey;

    //
    // First, get the current user's sid and see if we have
    // profile information for them.
    //

    lpSidString = GetSidString(hToken);

    if (lpSidString) {

        lstrcpy(LocalProfileKey, PROFILE_LIST_PATH);
        lstrcat(LocalProfileKey, TEXT("\\"));
        lstrcat(LocalProfileKey, lpSidString);

        error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, LocalProfileKey, 0,
                             KEY_READ, &hSubKey);

        if (error == ERROR_SUCCESS) {
           RegCloseKey(hSubKey);
           return lpSidString;
        }

        lstrcat(LocalProfileKey, c_szBAK);

        error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, LocalProfileKey, 0,
                             KEY_READ, &hSubKey);

        if (ERROR_SUCCESS == error) {
           RegCloseKey(hSubKey);
           return lpSidString;
        }

        DeleteSidString(lpSidString);
    }


    //
    // Check for an old sid string
    //

    lpSidString = GetOldSidString(hToken, PROFILE_GUID_PATH);

    if (!lpSidString) {

        //
        // Last resort, use the user's current sid
        //

        DebugMsg((DM_VERBOSE, TEXT("GetProfileSid: No Guid -> Sid Mapping available")));
        lpSidString = GetSidString(hToken);
    }

    return lpSidString;
}


//*************************************************************
//
//  TestIfUserProfileLoaded()
//
//  Purpose:    Test to see if this user's profile is loaded.
//
//  Parameters: hToken          -   user's token
//              lpProfileInfo   -   Profile information from app
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Ported
//
//*************************************************************

BOOL TestIfUserProfileLoaded(HANDLE hToken, LPPROFILEINFO lpProfileInfo)
{
    LPTSTR SidString;
    DWORD error;
    HKEY hSubKey;
    

    //
    // Get the Sid string for the user
    //

    SidString = GetProfileSidString(hToken);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("TestIfUserProfileLoaded:  Failed to get sid string for user")));
        return FALSE;
    }


    error = RegOpenKeyEx(HKEY_USERS, SidString, 0, KEY_ALL_ACCESS, &hSubKey);


    DeleteSidString(SidString);


    if (error == ERROR_SUCCESS) {

        DebugMsg((DM_VERBOSE, TEXT("TestIfUserProfileLoaded:  Profile already loaded.")));

        //
        // This key will be closed in before IUserProfile->LoadUserProfile
        // returns. It'll be reopened on the client side.
        //

        lpProfileInfo->hProfile = hSubKey;
    }

    
    SetLastError(error);
    return(error == ERROR_SUCCESS);
}


//*************************************************************
//
//  SecureUserKey()
//
//  Purpose:    Sets security on a key in the user's hive
//              so only admin's can change it.
//
//  Parameters: lpProfile       -   Profile Information
//              lpKey           -   Key to secure
//              pSid            -   Sid (used by CreateNewUser)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/20/95     ericflo    Created
//
//*************************************************************

BOOL SecureUserKey(LPPROFILE lpProfile, LPTSTR lpKey, PSID pSid)
{
    DWORD Error, IgnoreError;
    HKEY RootKey;
    SECURITY_DESCRIPTOR sd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidUser = NULL, psidSystem = NULL, psidAdmin = NULL, psidRestricted = NULL;
    DWORD cbAcl, AceIndex, dwDisp;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    BOOL bFreeSid = TRUE;
    DWORD dwFlags = 0;


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("SecureUserKey:  Entering")));


    //
    // Create the security descriptor
    //

    //
    // Give the user access by their real sid so they still have access
    // when they logoff and logon again
    //

    if (pSid) {
        psidUser = pSid;
        bFreeSid = FALSE;
        dwFlags = PI_NOUI;
    } else {
        psidUser = GetUserSid(lpProfile->hTokenUser);
        dwFlags = lpProfile->dwFlags;
    }

    if (!psidUser) {
        DebugMsg((DM_WARNING, TEXT("SecureUserKey:  Failed to get user sid")));
        return FALSE;
    }



    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to initialize system sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to initialize admin sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the restricted sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_RESTRICTED_CODE_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidRestricted)) {
         DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to initialize restricted sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + (2 * GetLengthSid (psidRestricted)) +
            sizeof(ACL) +
            (8 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }



    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    AceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_READ, psidUser)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to add ace for user.  Error = %d"), GetLastError()));
        goto Exit;
    }


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to add ace for system.  Error = %d"), GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to add ace for admin.  Error = %d"), GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_READ, psidRestricted)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to add ace for restricted.  Error = %d"), GetLastError()));
        goto Exit;
    }



    //
    // Now the inheritable ACEs
    //

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ, psidUser)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to add ace for user.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to add ace for system.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to add ace for admin.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ, psidRestricted)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to add ace for restricted.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Open the root of the user's profile
    //

    Error = RegCreateKeyEx(HKEY_USERS,
                         lpKey,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                         NULL,
                         &RootKey,
                         &dwDisp);

    if (Error != ERROR_SUCCESS) {

        DebugMsg((DM_WARNING, TEXT("SecureUserKey: Failed to open root of user registry, error = %d"), Error));

    } else {

        //
        // Set the security descriptor on the key
        //

        Error = ApplySecurityToRegistryTree(RootKey, &sd);


        if (Error == ERROR_SUCCESS) {
            bRetVal = TRUE;

        } else {

            DebugMsg((DM_WARNING, TEXT("SecureUserKey:  Failed to apply security to registry key, error = %d"), Error));
            SetLastError(Error);
        }

        RegCloseKey(RootKey);
    }


Exit:

    //
    // Free the sids and acl
    //

    if (bFreeSid && psidUser) {
        DeleteUserSid (psidUser);
    }

    if (psidRestricted) {
        FreeSid(psidRestricted);
    }

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("SecureUserKey:  Leaving with a return value of %d"), bRetVal));


    return(bRetVal);

}


//*************************************************************
//
//  ApplySecurityToRegistryTree()
//
//  Purpose:    Applies the passed security descriptor to the passed
//              key and all its descendants.  Only the parts of
//              the descriptor inddicated in the security
//              info value are actually applied to each registry key.
//
//  Parameters: RootKey   -     Registry key
//              pSD       -     Security Descriptor
//
//  Return:     ERROR_SUCCESS if successful
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/19/95     ericflo    Created
//
//*************************************************************

DWORD ApplySecurityToRegistryTree(HKEY RootKey, PSECURITY_DESCRIPTOR pSD)

{
    DWORD Error, IgnoreError;
    DWORD SubKeyIndex;
    LPTSTR SubKeyName;
    HKEY SubKey;
    DWORD cchSubKeySize = MAX_PATH + 1;



    //
    // First apply security
    //

    RegSetKeySecurity(RootKey, DACL_SECURITY_INFORMATION, pSD);


    //
    // Open each sub-key and apply security to its sub-tree
    //

    SubKeyIndex = 0;

    SubKeyName = (LPTSTR)GlobalAlloc (GPTR, cchSubKeySize * sizeof(TCHAR));

    if (!SubKeyName) {
        DebugMsg((DM_WARNING, TEXT("ApplySecurityToRegistryTree:  Failed to allocate memory, error = %d"), GetLastError()));
        return GetLastError();
    }

    while (TRUE) {

        //
        // Get the next sub-key name
        //

        Error = RegEnumKey(RootKey, SubKeyIndex, SubKeyName, cchSubKeySize);


        if (Error != ERROR_SUCCESS) {

            if (Error == ERROR_NO_MORE_ITEMS) {

                //
                // Successful end of enumeration
                //

                Error = ERROR_SUCCESS;

            } else {

                DebugMsg((DM_WARNING, TEXT("ApplySecurityToRegistryTree:  Registry enumeration failed with error = %d"), Error));
            }

            break;
        }


        //
        // Open the sub-key
        //

        Error = RegOpenKeyEx(RootKey,
                             SubKeyName,
                             0,
                             WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                             &SubKey);

        if (Error == ERROR_SUCCESS) {

            //
            // Apply security to the sub-tree
            //

            ApplySecurityToRegistryTree(SubKey, pSD);


            //
            // We're finished with the sub-key
            //

            RegCloseKey(SubKey);
        }


        //
        // Go enumerate the next sub-key
        //

        SubKeyIndex ++;
    }


    GlobalFree (SubKeyName);

    return Error;

}


//*************************************************************
//
//  SetDefaultUserHiveSecurity()
//
//  Purpose:    Initializes a user hive with the
//              appropriate acls
//
//  Parameters: lpProfile       -   Profile Information
//              pSid            -   Sid (used by CreateNewUser)
//              RootKey         -   registry handle to hive root
//
//  Return:     ERROR_SUCCESS if successful
//              other error code  if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/18/95     ericflo    Created as part of
//                                       SetupNewHive
//              3/29/98     adamed     Moved out of SetupNewHive
//                                       to this function
//
//*************************************************************

BOOL SetDefaultUserHiveSecurity(LPPROFILE lpProfile, PSID pSid, HKEY RootKey)
{
    DWORD Error;
    SECURITY_DESCRIPTOR sd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidUser = NULL, psidSystem = NULL, psidAdmin = NULL, psidRestricted = NULL;
    DWORD cbAcl, AceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    BOOL bFreeSid = TRUE;
    DWORD dwFlags = 0;


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity:  Entering")));


    //
    // Create the security descriptor that will be applied to each key
    //

    //
    // Give the user access by their real sid so they still have access
    // when they logoff and logon again
    //

    if (pSid) {
        psidUser = pSid;
        bFreeSid = FALSE;
        dwFlags = PI_NOUI;
    } else {
        psidUser = GetUserSid(lpProfile->hTokenUser);
        dwFlags = lpProfile->dwFlags;
    }

    if (!psidUser) {
        DebugMsg((DM_WARNING, TEXT("SetDefaultUserHiveSecurity:  Failed to get user sid")));
        return FALSE;
    }



    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to initialize system sid.  Error = %d"),
                   GetLastError()));
         goto Exit;
    }


    //
    // Get the admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to initialize admin sid.  Error = %d"),
                   GetLastError()));
         goto Exit;
    }

    //
    // Get the Restricted sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_RESTRICTED_CODE_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidRestricted)) {
         DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to initialize restricted sid.  Error = %d"),
                   GetLastError()));
         goto Exit;
    }



    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + (2*GetLengthSid(psidRestricted)) +
            sizeof(ACL) +
            (8 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }



    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    AceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidUser)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to add ace for user.  Error = %d"), GetLastError()));
        goto Exit;
    }


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to add ace for system.  Error = %d"), GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to add ace for admin.  Error = %d"), GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_READ, psidRestricted)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to add ace for Restricted.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Now the inheritable ACEs
    //

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidUser)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to add ace for user.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to add ace for system.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to add ace for admin.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ, psidRestricted)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to add ace for restricted.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }

    //
    // Set the security descriptor on the entire tree
    //

    Error = ApplySecurityToRegistryTree(RootKey, &sd);

    if (ERROR_SUCCESS == Error) {
        bRetVal = TRUE;
    }
    else
        SetLastError(Error);

Exit:

    //
    // Free the sids and acl
    //

    if (bFreeSid && psidUser) {
        DeleteUserSid (psidUser);
    }

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (psidRestricted) {
        FreeSid(psidRestricted);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }

    return bRetVal;
}


//*************************************************************
//
//  SetupNewHive()
//
//  Purpose:    Initializes the new user hive created by copying
//              the default hive.
//
//  Parameters: lpProfile       -   Profile Information
//              lpSidString     -   Sid string
//              pSid            -   Sid (used by CreateNewUser)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/18/95     ericflo    Created
//
//*************************************************************

BOOL SetupNewHive(LPPROFILE lpProfile, LPTSTR lpSidString, PSID pSid)
{
    DWORD Error, IgnoreError;
    HKEY RootKey;
    BOOL bRetVal = FALSE;
    DWORD dwFlags = 0;
    TCHAR szErr[MAX_PATH];


    //
    // Verbose Output
    //

    if (!lpProfile && !pSid) {
        DebugMsg((DM_VERBOSE, TEXT("SetupNewHive:  Invalid parameter")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("SetupNewHive:  Entering")));


    if (pSid) {
        dwFlags = PI_NOUI;
    } else {
        dwFlags = lpProfile->dwFlags;
    }

    //
    // Open the root of the user's profile
    //

    Error = RegOpenKeyEx(HKEY_USERS,
                         lpSidString,
                         0,
                         WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                         &RootKey);

    if (Error != ERROR_SUCCESS) {

        DebugMsg((DM_WARNING, TEXT("SetupNewHive: Failed to open root of user registry, error = %d"), Error));

    } else {

        //
        // First Secure the entire hive -- use security that
        // will be sufficient for most of the hive.
        // After this, we can add special settings to special
        // sections of this hive.
        //

        if (SetDefaultUserHiveSecurity(lpProfile, pSid, RootKey)) {

            TCHAR szSubKey[MAX_PATH];
            LPTSTR lpEnd;

            //
            // Change the security on certain keys in the user's registry
            // so that only Admin's and the OS have write access.
            //

            lstrcpy (szSubKey, lpSidString);
            lpEnd = CheckSlash(szSubKey);
            lstrcpy (lpEnd, WINDOWS_POLICIES_KEY);

            if (!SecureUserKey(lpProfile, szSubKey, pSid)) {
                DebugMsg((DM_WARNING, TEXT("SetupNewHive: Failed to secure windows policies key")));
            }

            lstrcpy (lpEnd, ROOT_POLICIES_KEY);

            if (!SecureUserKey(lpProfile, szSubKey, pSid)) {
                DebugMsg((DM_WARNING, TEXT("SetupNewHive: Failed to secure root policies key")));
            }


            bRetVal = TRUE;

        } else {
            Error = GetLastError();
            DebugMsg((DM_WARNING, TEXT("SetupNewHive:  Failed to apply security to user registry tree, error = %d"), Error));
            ReportError(lpProfile->hTokenUser, dwFlags, 1, EVENT_SECURITY_FAILED, GetErrString(Error, szErr));
        }

        RegFlushKey (RootKey);

        IgnoreError = RegCloseKey(RootKey);
        if (IgnoreError != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("SetupNewHive:  Failed to close reg key, error = %d"), IgnoreError));
        }
    }

    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("SetupNewHive:  Leaving with a return value of %d"), bRetVal));

    if (!bRetVal)
        SetLastError(Error);
    return(bRetVal);

}


//*************************************************************
//
//  IsCentralProfileReachable()
//
//  Purpose:    Checks to see if the user can access the
//              central profile.
//
//  Parameters: lpProfile             - User's token
//              bCreateCentralProfile - Should the central profile be created
//              bMandatory            - Is this a mandatory profile
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/20/95     ericflo    Ported
//
//*************************************************************

BOOL IsCentralProfileReachable(LPPROFILE lpProfile, BOOL *bCreateCentralProfile,
                               BOOL *bMandatory, BOOL* bOwnerOK)
{
    HANDLE  hFile;
    TCHAR   szProfile[MAX_PATH];
    LPTSTR  lpProfilePath, lpEnd;
    BOOL    bRetVal = FALSE;
    DWORD   dwError;
    HANDLE  hOldToken;
    HRESULT hr;


    dwError = GetLastError();

    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Entering")));


    //
    // Setup default values
    //

    *bMandatory = FALSE;
    *bCreateCentralProfile = FALSE;
    *bOwnerOK = TRUE;


    //
    // Check parameters
    //

    if (lpProfile->lpRoamingProfile[0] == TEXT('\0')) {
        DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Null path.  Leaving")));
        return FALSE;
    }


    lpProfilePath = lpProfile->lpRoamingProfile;


    //
    // Make sure we don't overrun our temporary buffer
    //

    if ((lstrlen(lpProfilePath) + 1 + lstrlen(c_szNTUserMan + 1)) > MAX_PATH) {
        DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Failed because temporary buffer is too small.")));
        SetLastError(ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }


    //
    // Copy the profile path to a temporary buffer
    // we can munge it.
    //

    lstrcpy (szProfile, lpProfilePath);


    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("IsCentralProfileReachable: Failed to impersonate user")));
        return FALSE;
    }

    //
    //  Check ownership of the profile
    //

    hr = CheckRoamingShareOwnership(szProfile, lpProfile->hTokenUser);
    
    if (FAILED(hr))
    {
        //
        //  Only set the bOwnerOK to false when we encountered the invalid owner error, 
        //  this would allow us to discover other reasons for failure
        //
        if (hr == HRESULT_FROM_WIN32(ERROR_INVALID_OWNER))
            *bOwnerOK = FALSE;
        DebugMsg((DM_WARNING, TEXT("IsCentralProfileReachable: Ownership check failed with %08X"), hr));
        SetLastError(HRESULT_CODE(hr));
        goto Exit;
    }
    
    //
    // Add the slash if appropriate and then tack on ntuser.man.
    //

    lpEnd = CheckSlash(szProfile);
    lstrcpy(lpEnd, c_szNTUserMan);

    //
    // See if this file exists
    //

    DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Testing <%s>"), szProfile));

    hFile = CreateFile(szProfile, GENERIC_READ, FILE_SHARE_READ, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);


    if (hFile != INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Found a mandatory profile.")));
        CloseHandle(hFile);
        *bMandatory = TRUE;
        bRetVal = TRUE;
        goto Exit;
    }


    dwError = GetLastError();
    DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Profile is not reachable, error = %d"),
                          dwError));


    //
    // If we received an error other than file not
    // found, bail now because we won't be able to
    // access this location.
    //

    if (dwError != ERROR_FILE_NOT_FOUND) {
        DebugMsg((DM_WARNING, TEXT("IsCentralProfileReachable:  Profile path <%s> is not reachable, error = %d"),
                                        szProfile, dwError));
        goto Exit;
    }


    //
    // Now try ntuser.dat
    //

    lstrcpy(lpEnd, c_szNTUserDat);


    //
    // See if this file exists.
    //

    DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Testing <%s>"), szProfile));

    hFile = CreateFile(szProfile, GENERIC_READ, FILE_SHARE_READ, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);


    if (hFile != INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Found a user profile.")));
        CloseHandle(hFile);
        bRetVal = TRUE;
        goto Exit;
    }


    dwError = GetLastError();
    DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Profile is not reachable, error = %d"),
                          dwError));

    //
    // If file not found than central profile is empty. For read
    // only profile ignore the empty central profile.
    //

    if ((dwError == ERROR_FILE_NOT_FOUND) && !(lpProfile->dwInternalFlags & PROFILE_READONLY)) {
        DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Ok to create a user profile.")));
        *bCreateCentralProfile = TRUE;
        bRetVal = TRUE;
        goto Exit;
    }


    DebugMsg((DM_WARNING, TEXT("IsCentralProfileReachable:  Profile path <%s> is not reachable(2), error = %d"),
                                    szProfile, dwError));

Exit:


    //
    // Go back to system security context
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("IsCentralProfileReachable: Failed to revert to self")));
    }

    return bRetVal;
}


//*************************************************************
//
//  MyRegLoadKey()
//
//  Purpose:    Loads a hive into the registry
//
//  Parameters: hKey        -   Key to load the hive into
//              lpSubKey    -   Subkey name
//              lpFile      -   hive filename
//
//  Return:     ERROR_SUCCESS if successful
//              Error number if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/22/95     ericflo    Created
//
//*************************************************************

LONG MyRegLoadKey(HKEY hKey, LPTSTR lpSubKey, LPTSTR lpFile)
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN WasEnabled;
    int error;
    TCHAR szErr[MAX_PATH];
    BOOL bAdjustPriv = FALSE;
    HANDLE hToken = NULL;
    

    //
    // Check to see if we are impersonating.
    //

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken) || hToken == NULL) {
        bAdjustPriv = TRUE;
    }
    else {
        CloseHandle(hToken);
    }

    //
    // Enable the restore privilege
    //

    if(bAdjustPriv) {
        Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    }

    if (NT_SUCCESS(Status)) {

        error = RegLoadKey(hKey, lpSubKey, lpFile);

        //
        // Restore the privilege to its previous state
        //

        if(bAdjustPriv) {
            Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
            if (!NT_SUCCESS(Status)) {
                DebugMsg((DM_WARNING, TEXT("MyRegLoadKey:  Failed to restore RESTORE privilege to previous enabled state")));
            }
        }


        //
        // Check if the hive was loaded
        //

        if (error != ERROR_SUCCESS) {
            ReportError(NULL, PI_NOUI, 2, EVENT_REGLOADKEYFAILED, GetErrString(error, szErr), lpFile);
            DebugMsg((DM_WARNING, TEXT("MyRegLoadKey:  Failed to load subkey <%s>, error =%d"), lpSubKey, error));
        }
#if defined(_WIN64)
        else {
            //
            // Notify Wow64 service that it need to watch this hive if it care to do so
            //
            if ( hKey == HKEY_USERS )
                Wow64RegNotifyLoadHiveUserSid ( lpSubKey );
        }
#endif

    } else {
        error = Status;
        DebugMsg((DM_WARNING, TEXT("MyRegLoadKey:  Failed to enable restore privilege to load registry key, err = %08x"), error));
    }

    DebugMsg((DM_VERBOSE, TEXT("MyRegLoadKey: Returning %08x"), error));

    return error;
}


//*************************************************************
//
//  MyRegUnLoadKey()
//
//  Purpose:    Unloads a registry key
//
//  Parameters: hKey          -  Registry handle
//              lpSubKey      -  Subkey to be unloaded
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Ported
//
//*************************************************************

BOOL MyRegUnLoadKey(HKEY hKey, LPTSTR lpSubKey)
{
    BOOL     bResult = TRUE;
    LONG     error;
    LONG     eTmp;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN  WasEnabled;
    HKEY     hSubKey;
    HANDLE   hToken = NULL;
    BOOL     bAdjustPriv = FALSE;
    

#if defined(_WIN64)
    //
    // Notify wow64 service to release any resources
    //

    if ( hKey == HKEY_USERS )
        Wow64RegNotifyUnloadHiveUserSid ( lpSubKey );
#endif

    //
    // Check to see if we are impersonating.
    //

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken) || hToken == NULL) {
        bAdjustPriv = TRUE;
    }
    else {
        CloseHandle(hToken);
    }

    //
    // Enable the restore privilege
    //

    if (bAdjustPriv) {
        Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    }

    if (NT_SUCCESS(Status)) {

        error = RegUnLoadKey(hKey, lpSubKey);

        //
        // If the key didn't unload, check to see if it exists.
        // If the key doesn't exist, then it was probably cleaned up by
        // WatchHiveRefCount, but it certainly isn't loaded, so this
        // function should succeed.
        //

        if (error != ERROR_SUCCESS) {
            eTmp = RegOpenKeyEx(hKey, lpSubKey, 0, KEY_READ, &hSubKey);
            if (eTmp == ERROR_FILE_NOT_FOUND) {
                error = ERROR_SUCCESS;
            }
            else if (eTmp == ERROR_SUCCESS) {
                RegCloseKey( hSubKey );
            }
        }

        if ( error != ERROR_SUCCESS) {

            //
            // RegUnlodKey returns ERROR_WRITE_PROTECT if hive is already scheduled for unloading
            //

            if (error == ERROR_WRITE_PROTECT) {
                DebugMsg((DM_VERBOSE, TEXT("MyRegUnloadKey: user hive is already scheduled for unloading")));
            }
            else {
                DebugMsg((DM_WARNING, TEXT("MyRegUnLoadKey:  Failed to unmount hive %08x"), error));
            }
            bResult = FALSE;
        }

        //
        // Restore the privilege to its previous state
        //

        if (bAdjustPriv) {
            Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
        
            if (!NT_SUCCESS(Status)) {
                DebugMsg((DM_WARNING, TEXT("MyRegUnLoadKey:  Failed to restore RESTORE privilege to previous enabled state")));
            }
        }

    } else {
        DebugMsg((DM_WARNING, TEXT("MyRegUnLoadKey:  Failed to enable restore privilege to unload registry key")));
        error = Status;
        bResult = FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("MyRegUnLoadKey: Returning %d."), bResult));

    SetLastError(error);
    return bResult;
}


//*************************************************************
//
//  UpgradeLocalProfile()
//
//  Purpose:    Upgrades a local profile from a 3.x profile
//              to a profile directory structure.
//
//  Parameters: lpProfile       -   Profile Information
//              lpOldProfile    -   Previous profile file
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/6/95      ericflo    Created
//
//*************************************************************

BOOL UpgradeLocalProfile (LPPROFILE lpProfile, LPTSTR lpOldProfile)
{
    TCHAR szSrc[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    LPTSTR lpSrcEnd, lpDestEnd;
    BOOL bRetVal = FALSE;
    DWORD dwSize, dwFlags;
    HANDLE hOldToken;
    DWORD dwErr;

    dwErr = GetLastError();

    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("UpgradeLocalProfile:  Entering")));


    //
    // Setup the temporary buffers
    //

    lstrcpy (szSrc, lpOldProfile);
    lstrcpy (szDest, lpProfile->lpLocalProfile);

    lpDestEnd = CheckSlash (szDest);
    lstrcpy (lpDestEnd, c_szNTUserDat);


    //
    // Copy the hive
    //

    if (!CopyFile(szSrc, szDest, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: CopyFile failed to copy hive with error = %d"),
                 GetLastError()));
        return FALSE;
    }


    //
    // Delete the old hive
    //

    DeleteFile (szSrc);



    //
    // Copy log file
    //

    lstrcat (szSrc, c_szLog);
    lstrcat (szDest, c_szLog);


    if (!CopyFile(szSrc, szDest, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: CopyFile failed to copy hive log with error = %d"),
                 GetLastError()));
    }


    //
    // Delete the old hive log
    //

    DeleteFile (szSrc);


    //
    // Copy in the new shell folders from the default
    //

    if ( !(lpProfile->dwInternalFlags & DEFAULT_NET_READY) ) {

        CheckNetDefaultProfile (lpProfile);
    }

    if (lpProfile->lpDefaultProfile && *lpProfile->lpDefaultProfile) {

        ExpandEnvironmentStrings(lpProfile->lpDefaultProfile, szSrc, MAX_PATH);

        if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: Failed to impersonate user")));
            goto IssueLocalDefault;
        }

        dwFlags = (lpProfile->dwFlags & PI_NOUI) ? CPD_NOERRORUI : 0;
        dwFlags |= CPD_IGNOREHIVE | CPD_CREATETITLE;
        dwFlags |= CPD_IGNOREENCRYPTEDFILES | CPD_IGNORELONGFILENAMES;

        if (CopyProfileDirectoryEx (szSrc, lpProfile->lpLocalProfile,
                                    dwFlags,
                                    NULL, NULL)) {

            bRetVal = TRUE;
        }

        //
        // Go back to system security context
        //

        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: Failed to revert to self")));
        }

        if ((!bRetVal) && (GetLastError() == ERROR_DISK_FULL)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: Failed to Copy default profile. Disk is FULL")));
            goto Exit;
        }
    }


IssueLocalDefault:

    if (!bRetVal) {

        dwSize = ARRAYSIZE(szSrc);
        if (!GetDefaultUserProfileDirectory(szSrc, &dwSize)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile:  Failed to get default user profile.")));
            goto Exit;
        }

        if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: Failed to impersonate user")));
            goto Exit;
        }

        dwFlags = (lpProfile->dwFlags & PI_NOUI) ? CPD_NOERRORUI : 0;
        dwFlags |= CPD_IGNOREHIVE | CPD_CREATETITLE;
        dwFlags |= CPD_IGNOREENCRYPTEDFILES | CPD_IGNORELONGFILENAMES;

        bRetVal = CopyProfileDirectoryEx (szSrc,
                                          lpProfile->lpLocalProfile,
                                          dwFlags,
                                          NULL, NULL);

        //
        // Go back to system security context
        //

        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: Failed to revert to self")));
        }
    }

    if (!bRetVal)
        dwErr = GetLastError();

Exit:

    SetLastError(dwErr);

    return bRetVal;
}


//*************************************************************
//
//  UpgradeCentralProfile()
//
//  Purpose:    Upgrades a central profile from a 3.x profile
//              to a profile directory structure.
//
//  Parameters: lpProfile       -   Profile Information
//              lpOldProfile    -   Previous profile file
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/6/95      ericflo    Created
//
//*************************************************************

BOOL UpgradeCentralProfile (LPPROFILE lpProfile, LPTSTR lpOldProfile)
{
    TCHAR szSrc[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    LPTSTR lpSrcEnd, lpDestEnd, lpDot;
    BOOL bRetVal = FALSE;
    BOOL bMandatory = FALSE;
    DWORD dwSize, dwFlags;
    HANDLE hOldToken;
    DWORD dwErr;

    dwErr = GetLastError();


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("UpgradeCentralProfile:  Entering")));


    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("UpgradeCentralProfile: Failed to impersonate user")));
        return FALSE;
    }


    //
    // Setup the source buffer
    //

    lstrcpy (szSrc, lpOldProfile);


    //
    // Determine the profile type
    //

    lpDot = szSrc + lstrlen(szSrc) - 4;

    if (*lpDot == TEXT('.')) {
        if (!lstrcmpi (lpDot, c_szMAN)) {
            bMandatory = TRUE;
        }
    }


    //
    // Setup the destination buffer
    //

    lstrcpy (szDest, lpProfile->lpRoamingProfile);

    lpDestEnd = CheckSlash (szDest);

    if (bMandatory) {
        lstrcpy (lpDestEnd, c_szNTUserMan);
    } else {
        lstrcpy (lpDestEnd, c_szNTUserDat);
    }


    //
    // Copy the hive
    //

    if (!CopyFile(szSrc, szDest, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("UpgradeCentralProfile: CopyFile failed to copy hive with error = %d"),
                 GetLastError()));
        DebugMsg((DM_WARNING, TEXT("UpgradeCentralProfile: Source = <%s>"), szSrc));
        DebugMsg((DM_WARNING, TEXT("UpgradeCentralProfile: Destination = <%s>"), szDest));
        dwErr = GetLastError();
        goto Exit;
    }



    //
    // Copy log file
    //

    lstrcpy (lpDot, c_szLog);
    lstrcat (szDest, c_szLog);


    if (!CopyFile(szSrc, szDest, FALSE)) {
        DebugMsg((DM_VERBOSE, TEXT("UpgradeCentralProfile: CopyFile failed to copy hive log with error = %d"),
                 GetLastError()));
        DebugMsg((DM_VERBOSE, TEXT("UpgradeCentralProfile: Source = <%s>"), szSrc));
        DebugMsg((DM_VERBOSE, TEXT("UpgradeCentralProfile: Destination = <%s>"), szDest));

    }


    //
    // Copy in the new shell folders from the default
    //

    if ( !(lpProfile->dwInternalFlags & DEFAULT_NET_READY) ) {
        CheckNetDefaultProfile (lpProfile);
    }


    if (lpProfile->lpDefaultProfile && *lpProfile->lpDefaultProfile) {

        ExpandEnvironmentStrings(lpProfile->lpDefaultProfile, szSrc, MAX_PATH);

        dwFlags = (lpProfile->dwFlags & PI_NOUI) ? CPD_NOERRORUI : 0;
        dwFlags |= CPD_IGNOREHIVE | CPD_CREATETITLE;
        dwFlags |= CPD_IGNOREENCRYPTEDFILES | CPD_IGNORELONGFILENAMES;

        if (CopyProfileDirectoryEx (szSrc, lpProfile->lpRoamingProfile,
                                    dwFlags,
                                    NULL, NULL)) {

            bRetVal = TRUE;
        }
    }


    if (!bRetVal) {

        dwSize = ARRAYSIZE(szSrc);
        if (!GetDefaultUserProfileDirectory(szSrc, &dwSize)) {
            DebugMsg((DM_WARNING, TEXT("UpgradeCentralProfile:  Failed to get default user profile.")));
            dwErr = GetLastError();
            goto Exit;
        }

        dwFlags = (lpProfile->dwFlags & PI_NOUI) ? CPD_NOERRORUI : 0;
        dwFlags |= CPD_IGNOREHIVE | CPD_CREATETITLE;
        dwFlags |= CPD_IGNOREENCRYPTEDFILES | CPD_IGNORELONGFILENAMES;

        bRetVal = CopyProfileDirectoryEx (szSrc,
                                          lpProfile->lpRoamingProfile,
                                          dwFlags,
                                          NULL, NULL);
    }

    if (!bRetVal)
        dwErr = GetLastError();


Exit:

    //
    // Go back to system security context
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("UpgradeCentralProfile: Failed to revert to self")));
    }


    return bRetVal;
}


//*************************************************************
//
//  CreateSecureDirectory()
//
//  Purpose:    Creates a secure directory that only the user,
//              admin, and system have access to in the normal case
//              and for only the user and system in the restricted case.
//
//
//  Parameters: lpProfile   -   Profile Information
//              lpDirectory -   Directory Name
//              pSid        -   Sid (used by CreateUserProfile)
//              fRestricted -   Flag to set restricted access.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/20/95     ericflo    Created
//              9/30/98     ushaji     added fRestricted flag
//              7/18/00     santanuc   modified to avoid deadlock when Documents and Settings directory is encrypted
//
//*************************************************************

BOOL CreateSecureDirectory (LPPROFILE lpProfile, LPTSTR lpDirectory, PSID pSid, BOOL fRestricted)
{
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidUser = NULL, psidSystem = NULL, psidAdmin = NULL;
    DWORD cbAcl, aceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    BOOL bFreeSid = TRUE;


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Entering with <%s>"), lpDirectory));

 
    if (!lpProfile && !pSid) {

        //
        // Attempt to create the directory
        //

        if (CreateNestedDirectoryEx(lpDirectory, NULL, FALSE)) {
            DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Created the directory <%s>"), lpDirectory));
            bRetVal = TRUE;

        } else {

            DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to created the directory <%s>"), lpDirectory));
        }

        goto Exit;
    }


    //
    // Get the SIDs we'll need for the DACL
    //

    if (pSid) {
        psidUser = pSid;
        bFreeSid = FALSE;
    } else {
        if((psidUser = GetUserSid(lpProfile->hTokenUser)) == NULL) {
            DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: GetUserSid returned NULL. error = %08x"), GetLastError()));
            goto Exit;
        }
    }



    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to initialize system sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the Admin sid only if Frestricted is off
    //

    if (!fRestricted)
    {
        if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
            DebugMsg((DM_VERBOSE, TEXT("SetupNewHive: Failed to initialize admin sid.  Error = %d"), GetLastError()));
            goto Exit;
        }
    }


    //
    // Allocate space for the ACL
    //

    if (!fRestricted)
    {
        cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
                (2 * GetLengthSid (psidAdmin)) + sizeof(ACL) +
                (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));
    }
    else
    {
        cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
                sizeof(ACL) +
                (4 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));
    }


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }



    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidUser)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }



    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidSystem)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }


    if (!fRestricted)
    {
        aceIndex++;
        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidAdmin)) {
            DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
            goto Exit;
        }
    }

    //
    // Now the inheritable ACEs
    //

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidUser)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);



    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    if (!fRestricted)
    {
        aceIndex++;
        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
            DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
            goto Exit;
        }
    }

    if (!GetAce(pAcl, aceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);



    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Add the security descriptor to the sa structure
    //

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;


    //
    // Attempt to create the directory
    //

    if (CreateNestedDirectoryEx(lpDirectory, &sa, FALSE)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Created the directory <%s>"), lpDirectory));
        bRetVal = TRUE;

    } else {

        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to created the directory <%s>"), lpDirectory));
    }



Exit:

    if (bFreeSid && psidUser) {
        DeleteUserSid (psidUser);
    }

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }

    return bRetVal;

}


//*************************************************************
//
//  GetUserDomainName()
//
//  Purpose:    Gets the current user's domain name
//
//  Parameters: lpProfile        - Profile Information
//              lpDomainName     - Receives the user's domain name
//              lpDomainNameSize - Size of the lpDomainName buffer (truncates the name to this size)
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL GetUserDomainName (LPPROFILE lpProfile, LPTSTR lpDomainName, LPDWORD lpDomainNameSize)
{
    BOOL bResult = FALSE;
    LPTSTR lpTemp, lpDomain = NULL;
    HANDLE hOldToken;
    DWORD dwErr;
    TCHAR szErr[MAX_PATH];

    dwErr = GetLastError();


    //
    // if no lpProfile is passed e.g. in setup.c and so just ignore.
    //

    lpDomainName[0] = TEXT('\0');

    if (!lpProfile) {
        DebugMsg((DM_WARNING, TEXT("GetUserDomainName: lpProfile structure is NULL, returning")));
        return FALSE;
    }

    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("GetUserDomainName: Failed to impersonate user")));
        dwErr = GetLastError();
        goto Exit;
    }

    //
    // Get the username in NT4 format
    //

    lpDomain = MyGetUserNameEx (NameSamCompatible);

    RevertToUser(&hOldToken);

    if (!lpDomain) {
        DebugMsg((DM_WARNING, TEXT("GetUserDomainName:  MyGetUserNameEx failed for NT4 style name with %d"),
                 GetLastError()));
        dwErr = GetLastError();
        ReportError (NULL, PI_NOUI, 1, EVENT_FAILED_USERNAME, GetErrString(dwErr, szErr));
        goto Exit;
    }


    //
    // Look for the \ between the domain and username and replace
    // it with a NULL
    //

    lpTemp = lpDomain;

    while (*lpTemp && ((*lpTemp) != TEXT('\\')))
        lpTemp++;


    if (*lpTemp != TEXT('\\')) {
        DebugMsg((DM_WARNING, TEXT("GetUserDomainName:  Failed to find slash in NT4 style name:  <%s>"),
                 lpDomain));
        dwErr = ERROR_INVALID_DATA;
        goto Exit;
    }

    *lpTemp = TEXT('\0');

    lstrcpyn (lpDomainName, lpDomain, (*lpDomainNameSize)-1);


    //
    // Success
    //

    DebugMsg((DM_VERBOSE, TEXT("GetUserDomainName: DomainName = <%s>"), lpDomainName));

    bResult = TRUE;

Exit:

    if (lpDomain) {
        LocalFree (lpDomain);
    }

    SetLastError(dwErr);

    return bResult;
}


//*************************************************************
//
//  ComputeLocalProfileName()
//
//  Purpose:    Constructs the pathname of the local profile
//              for this user.  It will attempt to create
//              a directory of the username, and then if
//              unsccessful it will try the username.xxx
//              where xxx is a three digit number
//
//  Parameters: lpProfile             -   Profile Information
//              lpUserName            -   UserName
//              lpProfileImage        -   Profile directory (unexpanded)
//              cchMaxProfileImage    -   lpProfileImage buffer size
//              lpExpProfileImage     -   Expanded directory
//              cchMaxExpProfileImage -   lpExpProfileImage buffer size
//              pSid                  -   User's sid
//              bWin9xUpg             -   Flag to say whether it is win9x upgrade
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   lpProfileImage should be initialized with the
//              root profile path and the trailing backslash.
//              if it is a win9x upgrade give back the user's dir and don't do
//              conflict resolution.
//
//  History:    Date        Author     Comment
//              6/20/95     ericflo    Created
//
//*************************************************************

BOOL ComputeLocalProfileName (LPPROFILE lpProfile, LPCTSTR lpUserName,
                              LPTSTR lpProfileImage, DWORD  cchMaxProfileImage,
                              LPTSTR lpExpProfileImage, DWORD  cchMaxExpProfileImage,
                              PSID pSid, BOOL bWin9xUpg)
{
    int i = 0;
    TCHAR szNumber[5], lpUserDomain[50], szDomainName[50+3];
    LPTSTR lpEnd;
    BOOL bRetVal = FALSE;
    BOOL bResult;
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    DWORD   dwDomainNamelen;
    DWORD dwErr;

    //
    // Check buffer size
    //

    dwDomainNamelen = ARRAYSIZE(lpUserDomain);

    if ((DWORD)(lstrlen(lpProfileImage) + lstrlen(lpUserName) + dwDomainNamelen + 2 + 5 + 1) > cchMaxProfileImage) {
        DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: buffer too small")));
        SetLastError(ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }

    //
    // Place the username onto the end of the profile image
    //

    lpEnd = CheckSlash (lpProfileImage);
    lstrcpy (lpEnd, lpUserName);


    //
    // Expand the profile path
    //

    ExpandEnvironmentStrings(lpProfileImage, lpExpProfileImage, cchMaxExpProfileImage);



    //
    // Does this directory exist?
    //

    hFile = FindFirstFile (lpExpProfileImage, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

        //
        // Attempt to create the directory, if it returns an error bail
        // CreateSecureDirectory does not return an error for already_exists
        // so this should be ok.
        //

        bResult = CreateSecureDirectory(lpProfile, lpExpProfileImage, pSid, FALSE);

        if (bResult) {
            DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: generated the profile directory <%s>"), lpExpProfileImage));
            bRetVal = TRUE;
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: trying to create dir <%s> returned %d"), lpExpProfileImage, GetLastError()));
            bRetVal = FALSE;
        }
        goto Exit;

    } else {

        FindClose (hFile);
        if (bWin9xUpg) {
            DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: generated the profile directory <%s> in win9xupg case"), lpExpProfileImage));
            bRetVal = TRUE;
            goto Exit;
        }
    }



    //
    // get the User Domain Name
    //

    if (!GetUserDomainName(lpProfile, lpUserDomain, &dwDomainNamelen)) {
        DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: Couldn't get the User Domain")));
        *lpUserDomain = TEXT('\0');
    }

    lpEnd = lpProfileImage + lstrlen(lpProfileImage);

    //
    // Place the " (DomainName)" onto the end of the username
    //

    if ((*lpUserDomain) != TEXT('\0')) {
        TCHAR szFormat[30];

        LoadString (g_hDllInstance, IDS_PROFILEDOMAINNAME_FORMAT, szFormat,
                            ARRAYSIZE(szFormat));
        wsprintf(szDomainName, szFormat, lpUserDomain);
        lstrcpy(lpEnd, szDomainName);

        //
        // Expand the profile path
        //

        ExpandEnvironmentStrings(lpProfileImage, lpExpProfileImage, cchMaxExpProfileImage);


        //
        // Does this directory exist?
        //

        hFile = FindFirstFile (lpExpProfileImage, &fd);

        if (hFile == INVALID_HANDLE_VALUE) {

            //
            // Attempt to create the directory
            //

            bResult = CreateSecureDirectory(lpProfile, lpExpProfileImage, pSid, FALSE);

            if (bResult) {
                DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: generated the profile directory <%s>"), lpExpProfileImage));
                bRetVal = TRUE;
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: trying to create dir <%s> returned %d"), lpExpProfileImage, GetLastError()));
                bRetVal = FALSE;
            }

            goto Exit;

        } else {

            FindClose (hFile);
        }
    }

    //
    // Failed to create the directory for some reason.
    // Now try username (DomanName).000, username (DomanName).001, etc
    //

    lpEnd = lpProfileImage + lstrlen(lpProfileImage);

    for (i=0; i < 1000; i++) {

        //
        // Convert the number to a string and attach it.
        //

        wsprintf (szNumber, TEXT(".%.3d"), i);
        lstrcpy (lpEnd, szNumber);


        //
        // Expand the profile path
        //

        ExpandEnvironmentStrings(lpProfileImage, lpExpProfileImage, cchMaxExpProfileImage);


        //
        // Does this directory exist?
        //

        hFile = FindFirstFile (lpExpProfileImage, &fd);

        if (hFile == INVALID_HANDLE_VALUE) {

            //
            // Attempt to create the directory
            //

            bResult = CreateSecureDirectory(lpProfile, lpExpProfileImage, pSid, FALSE);

            if (bResult) {
                DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: generated the profile directory <%s>"), lpExpProfileImage));
                bRetVal = TRUE;
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: trying to create dir <%s> returned %d"), lpExpProfileImage, GetLastError()));
                bRetVal = FALSE;
            }

            goto Exit;

        } else {

            FindClose (hFile);
        }
    }


    DebugMsg((DM_WARNING, TEXT("ComputeLocalProfileName: Could not generate a profile directory.  Error = %d"), GetLastError()));

Exit:

    if (bRetVal && lpProfile && (lpProfile->dwFlags & PI_HIDEPROFILE)) {
        SetFileAttributes(lpExpProfileImage, 
                          FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM |
                          GetFileAttributes(lpExpProfileImage));
    }

    return bRetVal;
}


//*************************************************************
//
//  SetMachineProfileKeySecurity
//
//  Purpose:    Sets the security on the profile key under HKLM/ProfileList
//
//  Parameters: lpProfile   -   Profile information
//              lpKeyName   -   Name of the registry key
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/22/99     ushaji     adapted
//              2/3/00      weiruc     fixed function comment
//                                     fixed bug 441598
//
//*************************************************************

BOOL SetMachineProfileKeySecurity (LPPROFILE lpProfile, LPTSTR lpKeyName)
{
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidSystem = NULL, psidAdmin = NULL, psidUsers = NULL;
    PSID  psidThisUser = NULL;
    DWORD cbAcl, aceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    HKEY hKeyProfile=NULL;
    DWORD Error, dwDisp;

    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DebugMsg((DM_WARNING, TEXT("SetMachineProfileKeySecurity: Failed to initialize system sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DebugMsg((DM_WARNING, TEXT("SetMachineProfileKeySecurity: Failed to initialize admin sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the users sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_USERS,
                                  0, 0, 0, 0, 0, 0, &psidUsers)) {

         DebugMsg((DM_WARNING, TEXT("SetMachineProfileKeySecurity: Failed to initialize authenticated users sid.  Error = %d"), GetLastError()));
         goto Exit;
    }

    //
    // Get this users sid
    //

    if((psidThisUser = GetUserSid(lpProfile->hTokenUser)) == NULL) {
        DebugMsg((DM_WARNING, TEXT("SetMachineProfileKeySecurity: Failed to get the user's sid. Error = %d"), GetLastError()));
        goto Exit;
    }

    //
    // Allocate space for the ACL. (No Inheritable Aces)
    //

    cbAcl = (GetLengthSid (psidSystem))    +
            (GetLengthSid (psidAdmin))     +
            (GetLengthSid (psidUsers))     +
            (GetLengthSid (psidThisUser))  +
            sizeof(ACL) +
            (4 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("SetMachineProfileKeySecurity: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Add Aces.  Non-inheritable ACEs first
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem)) {
        DebugMsg((DM_WARNING, TEXT("SetMachineProfileKeySecurity: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("SetMachineProfileKeySecurity: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_READ, psidUsers)) {
        DebugMsg((DM_WARNING, TEXT("SetMachineProfileKeySecurity: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS ^ (WRITE_DAC | WRITE_OWNER), psidThisUser)) {
        DebugMsg((DM_WARNING, TEXT("SetMachineProfileKeySecurity: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("SetMachineProfileKeySecurity: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("SetMachineProfileKeySecurity: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }

    Error = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           lpKeyName,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                           NULL,
                           &hKeyProfile,
                           &dwDisp);

    if (Error != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("SetMachineProfileKeySecurity: Couldn't open registry key to set security.  Error = %d"), Error));
        SetLastError(Error);
        goto Exit;
    }


    //
    // Set the security
    //

    Error = RegSetKeySecurity(hKeyProfile, DACL_SECURITY_INFORMATION, &sd);

    if (Error != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("SetMachineProfileKeySecurity: Couldn't set security.  Error = %d"), Error));
        SetLastError(Error);
        goto Exit;
    }
    else {
        bRetVal = TRUE;
    }


Exit:

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (psidUsers) {
        FreeSid(psidUsers);
    }

    if (psidThisUser) {
        FreeSid(psidThisUser);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }

    if (hKeyProfile) {
        RegCloseKey(hKeyProfile);
    }

    return bRetVal;
}


//*************************************************************
//
//  CreateLocalProfileKey()
//
//  Purpose:    Creates a registry key pointing at the user profile
//
//  Parameters: lpProfile   -   Profile information
//              phKey       -   Handle to registry key if successful
//              bKeyExists  -   TRUE if the registry key already existed
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/20/95     ericflo    Ported
//
//*************************************************************

BOOL CreateLocalProfileKey (LPPROFILE lpProfile, PHKEY phKey, BOOL *bKeyExists)
{
    TCHAR LocalProfileKey[MAX_PATH];
    DWORD Disposition;
    DWORD RegErr = ERROR_SUCCESS + 1;
    BOOL Result;
    LPTSTR SidString;
    DWORD dwErr;

    dwErr = GetLastError();

    SidString = GetSidString(lpProfile->hTokenUser);
    if (SidString != NULL) {

        //
        // Call the RegCreateKey api in the user's context
        //

        lstrcpy(LocalProfileKey, PROFILE_LIST_PATH);
        lstrcat(LocalProfileKey, TEXT("\\"));
        lstrcat(LocalProfileKey, SidString);

        RegErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, LocalProfileKey, 0, 0, 0,
                                KEY_READ | KEY_WRITE, NULL, phKey, &Disposition);
        if (RegErr == ERROR_SUCCESS) {

            *bKeyExists = (BOOL)(Disposition & REG_OPENED_EXISTING_KEY);

            //
            // If the key didn't exist before and profile is not mandatory, set the security on it.
            //

            if ((!(*bKeyExists)) && (!(lpProfile->dwInternalFlags & PROFILE_MANDATORY))) {
                if (!SetMachineProfileKeySecurity(lpProfile, LocalProfileKey)) {
                    DebugMsg((DM_WARNING, TEXT("CreateLocalProfileKey:  SetMachineProfileKeySecurity Failed. Error = %d"), GetLastError()));
                }
            }
            else {
               DebugMsg((DM_VERBOSE, TEXT("CreateLocalProfileKey:  Not setting additional Security")));
            }

        } else {
           DebugMsg((DM_WARNING, TEXT("CreateLocalProfileKey:  Failed trying to create the local profile key <%s>, error = %d."), LocalProfileKey, RegErr));
           dwErr = RegErr;
        }

        DeleteSidString(SidString);
    }

    SetLastError(dwErr);
    return(RegErr == ERROR_SUCCESS);
}


//*************************************************************
//
//  GetExistingLocalProfileImage()
//
//  Purpose:    opens the profileimagepath
//
//  Parameters: lpProfile            - Profile information
//
//  Return:     TRUE if the profile image is reachable
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/20/95     ericflo    Ported
//              9/26/98     ushaji     Modified
//
//*************************************************************
BOOL GetExistingLocalProfileImage(LPPROFILE lpProfile)
{
    HKEY hKey = NULL;
    BOOL bKeyExists;
    LPTSTR lpProfileImage = NULL;
    LPTSTR lpExpProfileImage = NULL;
    LPTSTR lpOldProfileImage = NULL;
    LPTSTR lpExpandedPath, lpEnd;
    DWORD cbExpProfileImage = sizeof(TCHAR)*MAX_PATH;
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    DWORD cb;
    DWORD err;
    DWORD dwType;
    DWORD dwSize;
    LONG lResult;
    DWORD dwInternalFlags = 0;
    BOOL bRetVal = FALSE;
    LPTSTR SidString;
    HANDLE hOldToken;

    lpProfile->lpLocalProfile[0] = TEXT('\0');


    if (!PatchNewProfileIfRequired(lpProfile->hTokenUser)) {
        DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage: Patch Profile Image failed")));
        return FALSE;
    }

    if (!CreateLocalProfileKey(lpProfile, &hKey, &bKeyExists)) {
        return FALSE;   // not reachable and cannot keep a local copy
    }

    // 
    // Allocate memory for Local variables to avoid stack overflow
    //

    lpProfileImage = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!lpProfileImage) {
        DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage: Out of memory")));
        goto Exit;
    }

    lpExpProfileImage = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!lpExpProfileImage) {
        DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage: Out of memory")));
        goto Exit;
    }

    lpOldProfileImage = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!lpOldProfileImage) {
        DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage: Out of memory")));
        goto Exit;
    }

    if (bKeyExists) {

        //
        // Check if the local profile image is valid.
        //

        DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Found entry in profile list for existing local profile")));

        err = RegQueryValueEx(hKey, PROFILE_IMAGE_VALUE_NAME, 0, &dwType,
            (LPBYTE)lpExpProfileImage, &cbExpProfileImage);
        if (err == ERROR_SUCCESS && cbExpProfileImage) {
            DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Local profile image filename = <%s>"), lpExpProfileImage));

            if (dwType == REG_EXPAND_SZ) {

                //
                // Expand the profile image filename
                //

                cb = sizeof(TCHAR)*MAX_PATH;
                lpExpandedPath = (LPTSTR)LocalAlloc(LPTR, cb);
                if (lpExpandedPath) {
                    ExpandEnvironmentStrings(lpExpProfileImage, lpExpandedPath, cb);
                    lstrcpy(lpExpProfileImage, lpExpandedPath);
                    LocalFree(lpExpandedPath);
                }

                DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Expanded local profile image filename = <%s>"), lpExpProfileImage));
            }


            //
            // Query for the internal flags
            //

            dwSize = sizeof(DWORD);
            err = RegQueryValueEx (hKey, PROFILE_STATE, NULL,
                &dwType, (LPBYTE) &dwInternalFlags, &dwSize);

            if (err != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Failed to query internal flags with error %d"), err));
            }


            //
            // if we do not have a fully loaded profile, mark it as new
            // if it was not called with Liteload
            //

            if (dwInternalFlags & PROFILE_PARTLY_LOADED) {
                DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  We do not have a fully loaded profile on this machine")));

                //
                // retain the partially loaded flag and remove it at the end of
                // restoreuserprofile..
                //

                lpProfile->dwInternalFlags |= PROFILE_PARTLY_LOADED;

                if (!(lpProfile->dwFlags & PI_LITELOAD)) {
                    DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Treating this profile as new")));
                    lpProfile->dwInternalFlags |= PROFILE_NEW_LOCAL;
                }
            }

            //
            // if due to leak we are getting the old TEMP profile then preserve 
            // the internal flag. This will allow to revert back to .bak profile
            // correctly when the leak is fixed. 
            //

            if (dwInternalFlags & PROFILE_TEMP_ASSIGNED) {
                lpProfile->dwInternalFlags |= dwInternalFlags;
            }


            //
            //  Call FindFirst to see if we need to migrate this profile
            //

            hFile = FindFirstFile (lpExpProfileImage, &fd);

            if (hFile == INVALID_HANDLE_VALUE) {
                DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Local profile image filename we got from our profile list doesn't exit.  Error = %d"), GetLastError()));
                bRetVal = FALSE;
                goto Exit;
            }

            FindClose(hFile);


            //
            // If this is a file, then we need to migrate it to
            // the new directory structure. (from a 3.5 machine)
            //

            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                lstrcpy (lpOldProfileImage, lpExpProfileImage);

                if (CreateLocalProfileImage(lpProfile, lpProfile->lpUserName)) {
                    if (UpgradeLocalProfile (lpProfile, lpOldProfileImage))
                        bRetVal = TRUE;
                    else {
                        DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage:  Failed to upgrade 3.5 profiles")));
                        bRetVal = FALSE;
                    }
                }
                else {
                    DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage:  Failed to create a new profile to upgrade")));
                    bRetVal = FALSE;
                }
                goto Exit;
            }

            //
            // Test if a mandatory profile exists
            //

            lpEnd = CheckSlash (lpExpProfileImage);
            lstrcpy (lpEnd, c_szNTUserMan);

            //
            // Impersonate the user, before trying to access ntuser, ntuser.man
            // fail, if we can not access..
            //

            if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
                DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage: Failed to impersonate user")));
                bRetVal = FALSE;
                goto Exit;
            }

            if (GetFileAttributes(lpExpProfileImage) != -1) {

                //
                // This is just to tag that the local profile is a mandatory profile
                //

                lpProfile->dwInternalFlags |= PROFILE_LOCALMANDATORY;

                DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Found local mandatory profile image file ok <%s>"),
                    lpExpProfileImage));

                *(lpEnd - 1) = TEXT('\0');
                lstrcpy(lpProfile->lpLocalProfile, lpExpProfileImage);

                //
                // Since this profile was mandatory, treat it as if it has never
                // synced with the server.
                //

                lpProfile->ftProfileUnload.dwLowDateTime = 0;
                lpProfile->ftProfileUnload.dwHighDateTime = 0;

                RevertToUser(&hOldToken);

                bRetVal = TRUE;   // local copy is valid and reachable
                goto Exit; 
            } else {
                DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  No local mandatory profile.  Error = %d"), GetLastError()));
            }


            //
            // Test if a normal profile exists
            //

            lstrcpy (lpEnd, c_szNTUserDat);

            if (GetFileAttributes(lpExpProfileImage) != -1) {

                RevertToUser(&hOldToken);

                DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Found local profile image file ok <%s>"),
                    lpExpProfileImage));

                *(lpEnd - 1) = TEXT('\0');
                lstrcpy(lpProfile->lpLocalProfile, lpExpProfileImage);


                //
                // Read the time this profile was unloaded
                //

                dwSize = sizeof(lpProfile->ftProfileUnload.dwLowDateTime);

                lResult = RegQueryValueEx (hKey,
                    PROFILE_UNLOAD_TIME_LOW,
                    NULL,
                    &dwType,
                    (LPBYTE) &lpProfile->ftProfileUnload.dwLowDateTime,
                    &dwSize);

                if (lResult == ERROR_SUCCESS) {

                    dwSize = sizeof(lpProfile->ftProfileUnload.dwHighDateTime);

                    lResult = RegQueryValueEx (hKey,
                        PROFILE_UNLOAD_TIME_HIGH,
                        NULL,
                        &dwType,
                        (LPBYTE) &lpProfile->ftProfileUnload.dwHighDateTime,
                        &dwSize);

                    if (lResult != ERROR_SUCCESS) {
                        DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Failed to query high profile unload time with error %d"), lResult));
                        lpProfile->ftProfileUnload.dwLowDateTime = 0;
                        lpProfile->ftProfileUnload.dwHighDateTime = 0;
                    }

                } else {
                    DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Failed to query low profile unload time with error %d"), lResult));
                    lpProfile->ftProfileUnload.dwLowDateTime = 0;
                    lpProfile->ftProfileUnload.dwHighDateTime = 0;
                }

                bRetVal = TRUE;  // local copy is valid and reachable
                goto Exit; 
            } else {
                DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Local profile image filename we got from our profile list doesn't exit.  <%s>  Error = %d"),
                    lpExpProfileImage, GetLastError()));
            }

            //
            // Revert to User before continuing
            //

            RevertToUser(&hOldToken);

        }
    }

Exit:

    if (lpProfileImage) {
        LocalFree(lpProfileImage);
    }

    if (lpExpProfileImage) {
        LocalFree(lpExpProfileImage);
    }

    if (lpOldProfileImage) {
        LocalFree(lpOldProfileImage);
    }

    if (hKey) {
        err = RegCloseKey(hKey);

        if (err != STATUS_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage:  Failed to close registry key, error = %d"), err));
        }
    }

    return bRetVal;
}


//*************************************************************
//
//  CreateLocalProfileImage()
//
//  Purpose:    creates the profileimagepath
//
//  Parameters: lpProfile   -   Profile information
//              lpBaseName  -   Base Name from which profile dir name
//                              will be generated.
//
//  Return:     TRUE if the profile image is creatable
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/20/95     ericflo    Ported
//              9/26/98     ushaji     Modified
//
//*************************************************************
BOOL CreateLocalProfileImage(LPPROFILE lpProfile, LPTSTR lpBaseName)
{
    HKEY hKey;
    BOOL bKeyExists;
    TCHAR lpProfileImage[MAX_PATH];
    TCHAR lpExpProfileImage[MAX_PATH];
    DWORD cbExpProfileImage = sizeof(TCHAR)*MAX_PATH;
    DWORD err;
    DWORD dwSize;
    PSID UserSid;
    BOOL bRetVal = FALSE;

    lpProfile->lpLocalProfile[0] = TEXT('\0');

    if (!CreateLocalProfileKey(lpProfile, &hKey, &bKeyExists)) {
        return FALSE;   // not reachable and cannot keep a local copy
    }

    //
    // No local copy found, try to create a new one.
    //

    DebugMsg((DM_VERBOSE, TEXT("CreateLocalProfileImage:  One way or another we haven't got an existing local profile, try and create one")));

    dwSize = ARRAYSIZE(lpProfileImage);
    if (!GetProfilesDirectoryEx(lpProfileImage, &dwSize, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("CreateLocalProfileImage:  Failed to get profile root directory.")));
        goto Exit;
    }

    if (ComputeLocalProfileName(lpProfile, lpBaseName,
        lpProfileImage, MAX_PATH,
        lpExpProfileImage, MAX_PATH, NULL, FALSE)) {


        //
        // Add this image file to our profile list for this user
        //

        err = RegSetValueEx(hKey,
            PROFILE_IMAGE_VALUE_NAME,
            0,
            REG_EXPAND_SZ,
            (LPBYTE)lpProfileImage,
            sizeof(TCHAR)*(lstrlen(lpProfileImage) + 1));

        if (err == ERROR_SUCCESS) {

            lstrcpy(lpProfile->lpLocalProfile, lpExpProfileImage);

            //
            // Get the sid of the logged on user
            //

            UserSid = GetUserSid(lpProfile->hTokenUser);
            if (UserSid != NULL) {

                //
                // Store the user sid under the Sid key of the local profile
                //

                err = RegSetValueEx(hKey,
                    TEXT("Sid"),
                    0,
                    REG_BINARY,
                    (BYTE*)UserSid,
                    RtlLengthSid(UserSid));


                if (err != ERROR_SUCCESS) {
                    DebugMsg((DM_WARNING, TEXT("CreateLocalProfileImage:  Failed to set 'sid' value of user in profile list, error = %d"), err));
                    SetLastError(err);
                }

                //
                // We're finished with the user sid
                //

                DeleteUserSid(UserSid);

                bRetVal = TRUE;

            } else {
                DebugMsg((DM_WARNING, TEXT("CreateLocalProfileImage:  Failed to get sid of logged on user, so unable to update profile list")));
                SetLastError(err);
            }
        } else {
            DebugMsg((DM_WARNING, TEXT("CreateLocalProfileImage:  Failed to update profile list for user with local profile image filename, error = %d"), err));
            SetLastError(err);
        }
    }


Exit:
    err = RegCloseKey(hKey);

    if (err != STATUS_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CreateLocalProfileImage:  Failed to close registry key, error = %d"), err));
        SetLastError(err);
    }

    return bRetVal;
}


//*************************************************************
//
//  IssueDefaultProfile()
//
//  Purpose:    Issues the specified default profile to a user
//
//  Parameters: lpProfile         -   Profile Information
//              lpDefaultProfile  -   Default profile location
//              lpLocalProfile    -   Local profile location
//              lpSidString       -   User's sid
//              bMandatory        -   Issue mandatory profile
//
//  Return:     TRUE if profile was successfully setup
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/22/95     ericflo    Created
//
//*************************************************************

BOOL IssueDefaultProfile (LPPROFILE lpProfile, LPTSTR lpDefaultProfile,
                          LPTSTR lpLocalProfile, LPTSTR lpSidString,
                          BOOL bMandatory)
{
    LPTSTR lpEnd, lpTemp;
    TCHAR szProfile[MAX_PATH];
    TCHAR szTempProfile[MAX_PATH];
    BOOL bProfileLoaded = FALSE;
    WIN32_FIND_DATA fd;
    HANDLE hFile;
    LONG error;
    DWORD dwFlags;
    HANDLE hOldToken;


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("IssueDefaultProfile:  Entering.  lpDefaultProfile = <%s> lpLocalProfile = <%s>"),
             lpDefaultProfile, lpLocalProfile));


    //
    // First expand the default profile
    //

    if (!ExpandEnvironmentStrings(lpDefaultProfile, szProfile, MAX_PATH)) {
        DebugMsg((DM_WARNING, TEXT("IssueDefaultProfile: ExpandEnvironmentStrings Failed with error %d"), GetLastError()));
        return FALSE;
    }


    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("IssueDefaultProfile: Failed to impersonate user")));
        return FALSE;
    }


    //
    // Does the default profile directory exist?
    //

    hFile = FindFirstFile (szProfile, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE, TEXT("IssueDefaultProfile:  Default profile <%s> does not exist."), szProfile));
        RevertToUser(&hOldToken);
        return FALSE;
    }

    FindClose(hFile);


    //
    // Copy profile to user profile
    //

    dwFlags = CPD_CREATETITLE | CPD_IGNORESECURITY | 
              CPD_IGNORELONGFILENAMES | CPD_IGNORECOPYERRORS;

    if (lpProfile->dwFlags & (PI_LITELOAD | PI_HIDEPROFILE)) {
        dwFlags |=  CPD_SYSTEMFILES | CPD_SYSTEMDIRSONLY;
    }
    else
        dwFlags |= CPD_IGNOREENCRYPTEDFILES;

    //
    // Call it with force copy unless there might be a partial profile locally
    //

    if (!(lpProfile->dwInternalFlags & PROFILE_PARTLY_LOADED)) {
        dwFlags |= CPD_FORCECOPY;
    }

    if (!CopyProfileDirectoryEx (szProfile, lpLocalProfile, dwFlags, NULL, NULL)) {
        DebugMsg((DM_WARNING, TEXT("IssueDefaultProfile:  CopyProfileDirectory returned FALSE.  Error = %d"), GetLastError()));
        RevertToUser(&hOldToken);
        return FALSE;
    }

    //
    // Rename the profile is a mandatory one was requested.
    //

    lstrcpy (szProfile, lpLocalProfile);
    lpEnd = CheckSlash (szProfile);

    if (bMandatory) {

        DebugMsg((DM_VERBOSE, TEXT("IssueDefaultProfile:  Mandatory profile was requested.")));

        lstrcpy (szTempProfile, szProfile);
        lstrcpy (lpEnd, c_szNTUserMan);

        hFile = FindFirstFile (szProfile, &fd);

        if (hFile != INVALID_HANDLE_VALUE) {
            DebugMsg((DM_VERBOSE, TEXT("IssueDefaultProfile:  Mandatory profile already exists.")));
            FindClose(hFile);

        } else {
            DebugMsg((DM_VERBOSE, TEXT("IssueDefaultProfile:  Renaming ntuser.dat to ntuser.man")));

            lpTemp = CheckSlash(szTempProfile);
            lstrcpy (lpTemp, c_szNTUserDat);

            if (!MoveFile(szTempProfile, szProfile)) {
                DebugMsg((DM_VERBOSE, TEXT("IssueDefaultProfile:  MoveFile returned false.  Error = %d"), GetLastError()));
            }
        }

    } else {
        lstrcpy (lpEnd, c_szNTUserDat);
    }

    //
    // Revert to being 'ourself'
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("IssueDefaultProfile: Failed to revert to self")));
    }


    //
    // Try to load the new profile
    //

    error = MyRegLoadKey(HKEY_USERS, lpSidString, szProfile);

    bProfileLoaded = (error == ERROR_SUCCESS);


    if (!bProfileLoaded) {
        DebugMsg((DM_VERBOSE, TEXT("IssueDefaultProfile:  MyRegLoadKey failed with error %d"),
                 error));

        SetLastError(error);

        if (error == ERROR_BADDB) {
            ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_FAILED_LOAD_1009);
        } 

        return FALSE;
    }


    DebugMsg((DM_VERBOSE, TEXT("IssueDefaultProfile:  Leaving successfully")));

    return TRUE;
}


//*************************************************************
//
//  DeleteProfileEx ()
//
//  Purpose:    Deletes the specified profile from the
//              registry and disk.
//
//  Parameters: lpSidString     -   Registry subkey
//              lpProfileDir    -   Profile directory
//              bBackup         -   Backup profile before deleting
//              szComputerName  -   Computer name. This parameter will be NULL 
//                                  for local computer.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/23/95     ericflo    Created
//
//*************************************************************

BOOL DeleteProfileEx (LPCTSTR lpSidString, LPTSTR lpLocalProfile, DWORD dwDeleteFlags, HKEY hKeyLM, LPCTSTR szComputerName)
{
    LONG lResult;
    TCHAR szTemp[MAX_PATH];
    TCHAR szUserGuid[MAX_PATH], szBuffer[MAX_PATH];
    TCHAR szRegBackup[MAX_PATH];
    HKEY hKey;
    DWORD dwType, dwSize, dwErr;
    BOOL bRetVal=TRUE;
    LPTSTR lpEnd = NULL;
    BOOL bBackup;

    bBackup = dwDeleteFlags & DP_BACKUP;

    dwErr = GetLastError();

    //
    // Cleanup the registry first.
    // delete the guid only if we don't have a bak to keep track of
    //

    if (lpSidString && *lpSidString) {

       // 
       // If profile in use then do not delete it
       //

       if (IsProfileInUse(szComputerName, lpSidString)) {
           DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Fail to delete profile with sid %s as it is still in use."), lpSidString));
           dwErr = ERROR_INVALID_PARAMETER;
           bRetVal = FALSE;
           goto Exit;
       }

       if (!(dwDeleteFlags & DP_BACKUPEXISTS)) {

            lstrcpy(szTemp, PROFILE_LIST_PATH);
            lstrcat(szTemp, TEXT("\\"));
            lstrcat(szTemp, lpSidString);


            //
            // get the user guid
            //

            lResult = RegOpenKeyEx(hKeyLM, szTemp, 0, KEY_READ, &hKey);

            if (lResult == ERROR_SUCCESS) {

                //
                // Query for the user guid
                //

                dwSize = MAX_PATH * sizeof(TCHAR);
                lResult = RegQueryValueEx (hKey, PROFILE_GUID, NULL, &dwType, (LPBYTE) szUserGuid, &dwSize);

                if (lResult != ERROR_SUCCESS) {
                    DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Failed to query profile guid with error %d"), lResult));
                }
                else {


                    lstrcpy(szTemp, PROFILE_GUID_PATH);
                    lstrcat(szTemp, TEXT("\\"));
                    lstrcat(szTemp, szUserGuid);

                    //
                    // Delete the profile guid from the guid list
                    //

                    lResult = RegDeleteKey(hKeyLM, szTemp);

                    if (lResult != ERROR_SUCCESS) {
                        DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  failed to delete profile guid.  Error = %d"), lResult));
                    }
                }

                RegCloseKey(hKey);
            }
        }


        lstrcpy(szTemp, PROFILE_LIST_PATH);
        lstrcat(szTemp, TEXT("\\"));
        lstrcat(szTemp, lpSidString);

        if (bBackup) {

            lstrcpy(szRegBackup, szTemp);
            lstrcat(szRegBackup, c_szBAK);

            lResult = RegRenameKey(hKeyLM, szTemp, szRegBackup);

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Unable to rename registry entry.  Error = %d"), lResult));
                dwErr = lResult;
                bRetVal = FALSE;
            }
        }
        else {
            lResult = RegDeleteKey(hKeyLM, szTemp);

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Unable to delete registry entry.  Error = %d"), lResult));
                dwErr = lResult;
                bRetVal = FALSE;
            }
        }
    }


    if (bBackup) {
        lResult = RegOpenKeyEx(hKeyLM, szRegBackup, 0, KEY_ALL_ACCESS, &hKey);

        if (lResult == ERROR_SUCCESS) {
            DWORD dwInternalFlags;

            dwSize = sizeof(DWORD);
            lResult = RegQueryValueEx (hKey, PROFILE_STATE, NULL, &dwType, (LPBYTE)&dwInternalFlags, &dwSize);

            if (lResult == ERROR_SUCCESS) {

                dwInternalFlags |= PROFILE_THIS_IS_BAK;
                lResult = RegSetValueEx (hKey, PROFILE_STATE, 0, REG_DWORD,
                                 (LPBYTE) &dwInternalFlags, sizeof(dwInternalFlags));
            }
            else {
                DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Failed to query profile internalflags  with error %d"), lResult));
            }


            RegCloseKey(hKey);
        }


    } else {

        if (!Delnode (lpLocalProfile)) {
            DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Delnode failed.  Error = %d"), GetLastError()));
            dwErr = GetLastError();
            bRetVal = FALSE;
        }
    }

    if (dwDeleteFlags & DP_DELBACKUP) {
        goto Exit;
        // don't delete any more stuff because the user actually might be logged in.
    }

    //
    // Delete the Group Policy per user stuff..
    //

    lstrcpy(szBuffer, GP_XXX_SID_PREFIX);
    lpEnd = CheckSlash(szBuffer);
    lstrcpy(lpEnd, lpSidString);

    if (!RegDelnode (hKeyLM, szBuffer)) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Failed to delete the group policy key %s"), szBuffer));
    }


    lstrcpy(szBuffer, GP_EXTENSIONS_SID_PREFIX);
    lpEnd = CheckSlash(szBuffer);
    lstrcpy(lpEnd, lpSidString);

    if (!RegDelnode (hKeyLM, szBuffer)) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Failed to delete the group policy extensions key %s"), szBuffer));
    }

    DeletePolicyState( lpSidString );

Exit:
    SetLastError(dwErr);
    return bRetVal;
}


//*************************************************************
//
//  UpgradeProfile()
//
//  Purpose:    Called after a profile is successfully loaded.
//              Stamps build number into the profile, and if
//              appropriate upgrades the per-user settings
//              that NT setup wants done.
//
//  Parameters: lpProfile   -   Profile Information
//              pEnv        -   Environment block
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/7/95     ericflo    Created
//
//*************************************************************

BOOL UpgradeProfile (LPPROFILE lpProfile, LPVOID pEnv)
{
    HKEY hKey;
    DWORD dwDisp, dwType, dwSize, dwBuildNumber;
    LONG lResult;
    BOOL bUpgrade = FALSE;
    BOOL bDoUserdiff = TRUE;


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("UpgradeProfile: Entering")));


    //
    // Query for the build number
    //

    lResult = RegCreateKeyEx (lpProfile->hKeyCurrentUser, WINLOGON_KEY,
                              0, NULL, REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS, NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("UpgradeProfile: Failed to open winlogon key. Error = %d"), lResult));
        return FALSE;
    }


    dwSize = sizeof(dwBuildNumber);
    lResult = RegQueryValueEx (hKey, PROFILE_BUILD_NUMBER,
                               NULL, &dwType, (LPBYTE)&dwBuildNumber,
                               &dwSize);

    if (lResult == ERROR_SUCCESS) {

        //
        // Found the build number.  If the profile build is greater,
        // we don't want to process the userdiff hive
        //

        if (dwBuildNumber >= g_dwBuildNumber) {
            DebugMsg((DM_VERBOSE, TEXT("UpgradeProfile: Build numbers match")));
            bDoUserdiff = FALSE;
        }
    } else {

        dwBuildNumber = 0;
    }


    if (bDoUserdiff) {

        //
        // Set the build number
        //

        lResult = RegSetValueEx (hKey, PROFILE_BUILD_NUMBER, 0, REG_DWORD,
                                 (LPBYTE) &g_dwBuildNumber, sizeof(g_dwBuildNumber));

        if (lResult != ERROR_SUCCESS) {
           DebugMsg((DM_WARNING, TEXT("UpgradeProfile: Failed to set build number. Error = %d"), lResult));
        }
    }


    //
    // Close the registry key
    //

    RegCloseKey (hKey);



    if (bDoUserdiff) {

        //
        // Apply changes to user's hive that NT setup needs.
        //

        if (!ProcessUserDiff(lpProfile, dwBuildNumber, pEnv)) {
            DebugMsg((DM_WARNING, TEXT("UpgradeProfile: ProcessUserDiff failed")));
        }
    }

    DebugMsg((DM_VERBOSE, TEXT("UpgradeProfile: Leaving Successfully")));

    return TRUE;

}

//*************************************************************
//
//  SetProfileTime()
//
//  Purpose:    Sets the timestamp on the remote profile and
//              local profile to be the same regardless of the
//              file system type being used.
//
//  Parameters: lpProfile        -   Profile Information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/25/95     ericflo    Ported
//
//*************************************************************

BOOL SetProfileTime(LPPROFILE lpProfile)
{
    HANDLE hFileCentral;
    HANDLE hFileLocal;
    FILETIME ft;
    TCHAR szProfile[MAX_PATH];
    LPTSTR lpEnd;
    HANDLE hOldToken;


    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("SetProfileTime: Failed to impersonate user")));
        return FALSE;
    }


    //
    // Create the central filename
    //

    lstrcpy (szProfile, lpProfile->lpRoamingProfile);
    lpEnd = CheckSlash (szProfile);

    if (lpProfile->dwInternalFlags & PROFILE_MANDATORY) {
        lstrcpy (lpEnd, c_szNTUserMan);
    } else {
        lstrcpy (lpEnd, c_szNTUserDat);
    }


    hFileCentral = CreateFile(szProfile,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ, NULL,
                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFileCentral == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_WARNING, TEXT("SetProfileTime:  couldn't open central profile <%s>, error = %d"),
                 szProfile, GetLastError()));
        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("SetProfileTime: Failed to revert to self")));
        }
        return FALSE;

    } else {

        if (!GetFileTime(hFileCentral, NULL, NULL, &ft)) {
            DebugMsg((DM_WARNING, TEXT("SetProfileTime:  couldn't get time of central profile, error = %d"), GetLastError()));
        }
    }

    //
    // Revert to being 'ourself'
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("SetProfileTime: Failed to revert to self")));
    }


    //
    // Create the local filename
    //

    lstrcpy (szProfile, lpProfile->lpLocalProfile);
    lpEnd = CheckSlash (szProfile);

    if (lpProfile->dwInternalFlags & PROFILE_MANDATORY) {
        lstrcpy (lpEnd, c_szNTUserMan);
    } else {
        lstrcpy (lpEnd, c_szNTUserDat);
    }


    hFileLocal = CreateFile(szProfile,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ, NULL,
                            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFileLocal == INVALID_HANDLE_VALUE) {

        DebugMsg((DM_WARNING, TEXT("SetProfileTime:  couldn't open local profile <%s>, error = %d"),
                 szProfile, GetLastError()));

    } else {

        if (!SetFileTime(hFileLocal, NULL, NULL, &ft)) {
            DebugMsg((DM_WARNING, TEXT("SetProfileTime: couldn't set time on local profile, error = %d"), GetLastError()));
        }
        if (!GetFileTime(hFileLocal, NULL, NULL, &ft)) {
            DebugMsg((DM_WARNING, TEXT("SetProfileTime:  couldn't get time on local profile, error = %d"), GetLastError()));
        }
        CloseHandle(hFileLocal);
    }

    //
    // Reset time of central profile in case of discrepencies in
    // times of different file systems.
    //

    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("SetProfileTime: Failed to impersonate user")));
        CloseHandle(hFileCentral);
        return FALSE;
    }


    //
    // Set the time on the central profile
    //

    if (!SetFileTime(hFileCentral, NULL, NULL, &ft)) {
         DebugMsg((DM_WARNING, TEXT("SetProfileTime:  couldn't set time on local profile, error = %d"), GetLastError()));
    }

    CloseHandle(hFileCentral);


    //
    // Revert to being 'ourself'
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("SetProfileTime: Failed to revert to self")));
    }

    return TRUE;
}


//*************************************************************
//
//  IsCacheDeleted()
//
//  Purpose:    Determines if the locally cached copy of the
//              roaming profile should be deleted.
//
//  Parameters: void
//
//  Return:     TRUE if local cache should be deleted
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/28/96     ericflo    Created
//
//*************************************************************

BOOL IsCacheDeleted (void)
{
    BOOL bRetVal = FALSE;
    DWORD dwSize, dwType;
    HKEY hKey;

    //
    // Open the winlogon registry key
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      WINLOGON_KEY,
                      0,
                      KEY_READ,
                      &hKey) == ERROR_SUCCESS) {

        //
        // Check for the flag.
        //

        dwSize = sizeof(BOOL);
        RegQueryValueEx (hKey,
                         DELETE_ROAMING_CACHE,
                         NULL,
                         &dwType,
                         (LPBYTE) &bRetVal,
                         &dwSize);

        RegCloseKey (hKey);
    }


    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      SYSTEM_POLICIES_KEY,
                      0,
                      KEY_READ,
                      &hKey) == ERROR_SUCCESS) {

        //
        // Check for the flag.
        //

        dwSize = sizeof(BOOL);
        RegQueryValueEx (hKey,
                         DELETE_ROAMING_CACHE,
                         NULL,
                         &dwType,
                         (LPBYTE) &bRetVal,
                         &dwSize);

        RegCloseKey (hKey);
    }

    return bRetVal;
}


//*************************************************************
//
//  GetProfileType()
//
//  Purpose:    Finds out some characterstics of a loaded profile
//
//  Parameters: dwFlags   -   Returns the various profile flags
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments: should be called after impersonation.
//
//  History:    Date        Author     Comment
//              11/10/98    ushaji     Created
//
//*************************************************************

BOOL WINAPI GetProfileType(DWORD *dwFlags)
{
    LPTSTR SidString;
    DWORD error, dwErr;
    HKEY hSubKey;
    BOOL bRetVal = FALSE;
    LPPROFILE lpProfile = NULL;
    HANDLE hToken;

    if (!dwFlags) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *dwFlags = 0;

    dwErr = GetLastError();

    //
    // Get the token for the caller
    //

    if (!OpenThreadToken (GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken)) {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
            DebugMsg((DM_WARNING, TEXT("GetProfileType: Failed to get token with %d"), GetLastError()));
            return FALSE;
        }
    }

    //
    // Get the Sid string for the user
    //

    SidString = GetProfileSidString(hToken);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("GetProfileType:  Failed to get sid string for user")));
        dwErr = GetLastError();
        goto Exit;
    }

    error = RegOpenKeyEx(HKEY_USERS, SidString, 0, KEY_READ, &hSubKey);

    if (error == ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("GetProfileType:  Profile already loaded.")));
        RegCloseKey(hSubKey);
    }
    else {
        DebugMsg((DM_WARNING, TEXT("GetProfileType:  Profile is not loaded.")));
        dwErr = error;
        goto Exit;
    }

    lpProfile = LoadProfileInfo(NULL, hToken, NULL);

    if (!lpProfile) {
        DebugMsg((DM_WARNING, TEXT("GetProfileType:  Couldn't load Profile Information.")));
        dwErr = GetLastError();
        *dwFlags = 0;
        goto Exit;
    }

    if (lpProfile->dwInternalFlags & PROFILE_GUEST_USER)
        *dwFlags |= PT_TEMPORARY;

    if (lpProfile->dwInternalFlags & PROFILE_MANDATORY)
        *dwFlags |= PT_MANDATORY;

    // external API, retaining the mandatory flag
    if (lpProfile->dwInternalFlags & PROFILE_READONLY)
        *dwFlags |= PT_MANDATORY;

    if (((lpProfile->dwUserPreference != USERINFO_LOCAL)) &&
        ((lpProfile->dwInternalFlags & PROFILE_UPDATE_CENTRAL) ||
        (lpProfile->dwInternalFlags & PROFILE_NEW_CENTRAL))) {

        *dwFlags |= PT_ROAMING;

        if (IsCacheDeleted()) {
            DebugMsg((DM_VERBOSE, TEXT("GetProfileType:  Profile is to be deleted")));
            *dwFlags |= PT_TEMPORARY;
        }
    }


    if (lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED)
        *dwFlags |= PT_TEMPORARY;

    bRetVal = TRUE;

Exit:
    if (SidString)
        DeleteSidString(SidString);

    SetLastError(dwErr);

    if (lpProfile) {

        if (lpProfile->lpLocalProfile) {
            LocalFree (lpProfile->lpLocalProfile);
        }

        if (lpProfile->lpRoamingProfile) {
            LocalFree (lpProfile->lpRoamingProfile);
        }

        LocalFree (lpProfile);
    }

    CloseHandle (hToken);

    if (bRetVal) {
        DebugMsg((DM_VERBOSE, TEXT("GetProfileType: ProfileFlags is %d"), *dwFlags));
    }

    return bRetVal;
}


//*************************************************************
//
//  DumpOpenRegistryHandle()
//
//  Purpose:    Dumps the existing reg handle into the debugger
//
//  Parameters: lpKeyName -   The key name to the key in the form of
//                            \registry\user....
//
//
//  Return:     Nothing
//
//  Comments:
//
//  History:    Date        Author     Comment
//*************************************************************

void DumpOpenRegistryHandle(LPTSTR lpkeyName)
{

    UNICODE_STRING      UnicodeKeyName;
    OBJECT_ATTRIBUTES   keyAttributes;
    ULONG               HandleCount = 0;
    BOOL                bBreakOnUnloadFailure=FALSE;
    HKEY                hKey;
    DWORD               dwSize, dwType;


    //
    // Initialize unicode string for our in params
    //

    RtlInitUnicodeString(&UnicodeKeyName, lpkeyName);

    //
    // Initialize the Obja structure
    //

    InitializeObjectAttributes(
            &keyAttributes,
            &UnicodeKeyName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );


    NtQueryOpenSubKeys(&keyAttributes, &HandleCount);

    DebugMsg((DM_WARNING, TEXT("DumpOpenRegistryHandle: %d user registry Handles leaked from %s"), HandleCount, lpkeyName));

    //
    // for debugging sometimes it is necessary to break at the point of
    // failure
    //


    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      WINLOGON_KEY,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(bBreakOnUnloadFailure);
        RegQueryValueEx (hKey,
                         TEXT("BreakOnHiveUnloadFailure"),
                         NULL,
                         &dwType,
                         (LPBYTE) &bBreakOnUnloadFailure,
                         &dwSize);

        RegCloseKey (hKey);
    }


    if (bBreakOnUnloadFailure)
        DebugBreak();

}


//*************************************************************
//
//  ExtractProfileFromBackup()
//
//  Purpose:  Extracts the profile from backup if required.
//
//  Parameters: hToken          -   User Token
//              SidString       -
//              dwBackupFlags   -   Backup Flags.
//                                  indicating that profile already exists.
//                                  Profile created from backup
//                                  0 indicates no such profile exists
//
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/21/99     ushaji     Created
//
//*************************************************************

#define EX_ALREADY_EXISTS   1
#define EX_PROFILE_CREATED  2

BOOL ExtractProfileFromBackup(HANDLE hToken, LPTSTR SidString, DWORD *dwBackupFlags)
{
    TCHAR LocalKey[MAX_PATH], *lpEnd, szLocalProfile;
    TCHAR LocalBackupKey[MAX_PATH];
    HKEY  hKey=NULL;
    DWORD dwType, dwSize;
    DWORD lResult;
    LPTSTR lpExpandedPath;
    DWORD cbExpProfileImage = sizeof(TCHAR)*MAX_PATH;
    TCHAR lpExpProfileImage[MAX_PATH];
    BOOL  bRetVal = TRUE;
    DWORD dwInternalFlags;
    DWORD cb;


    *dwBackupFlags = 0;

    lstrcpy(LocalKey, PROFILE_LIST_PATH);
    lpEnd = CheckSlash (LocalKey);
    lstrcpy(lpEnd, SidString);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, LocalKey, 0, KEY_ALL_ACCESS, &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx (hKey, PROFILE_STATE, NULL,
                               &dwType, (LPBYTE) &dwInternalFlags, &dwSize);

        if (lResult == ERROR_SUCCESS) {

            //
            // if there is a sid key, check whether this is a temp profile
            //

            if (dwInternalFlags & PROFILE_TEMP_ASSIGNED) {
                DWORD dwDeleteFlags = 0;

                if (dwInternalFlags & PROFILE_BACKUP_EXISTS) {
                    dwDeleteFlags |= DP_BACKUPEXISTS;
                }


                //
                // We need the path to pass to DeleteProfile
                //

                lResult = RegQueryValueEx(hKey, PROFILE_IMAGE_VALUE_NAME, 0, &dwType,
                                        (LPBYTE)lpExpProfileImage, &cbExpProfileImage);

                if (lResult == ERROR_SUCCESS && cbExpProfileImage) {
                    DebugMsg((DM_VERBOSE, TEXT("ExtractProfileFromBackup:  Local profile image filename = <%s>"), lpExpProfileImage));

                    if (dwType == REG_EXPAND_SZ) {

                        //
                        // Expand the profile image filename
                        //

                        cb = sizeof(lpExpProfileImage);
                        lpExpandedPath = (LPTSTR)LocalAlloc(LPTR, cb);
                        if (lpExpandedPath) {
                            ExpandEnvironmentStrings(lpExpProfileImage, lpExpandedPath, ARRAYSIZE(lpExpProfileImage));
                            lstrcpy(lpExpProfileImage, lpExpandedPath);
                            LocalFree(lpExpandedPath);
                        }

                        DebugMsg((DM_VERBOSE, TEXT("ExtractProfileFromBackup:  Expanded local profile image filename = <%s>"), lpExpProfileImage));
                    }

                    if (!DeleteProfileEx (SidString, lpExpProfileImage, dwDeleteFlags, HKEY_LOCAL_MACHINE, NULL)) {
                        DebugMsg((DM_WARNING, TEXT("ExtractProfileFromBackup:  DeleteProfileDirectory returned false (2).  Error = %d"), GetLastError()));
                        lResult = GetLastError();
                        goto Exit;
                    }
                    else {
                        if (!(dwInternalFlags & PROFILE_BACKUP_EXISTS)) {
                            DebugMsg((DM_VERBOSE, TEXT("ExtractProfileFromBackup:  Temprorary profile but there is no backup")));
                            bRetVal = TRUE;
                            goto Exit;
                        }
                    }
                }
                else {
                    DebugMsg((DM_VERBOSE, TEXT("ExtractProfileFromBackup:  Couldn't get the local profile path")));
                    bRetVal = FALSE;
                    goto Exit;
                }
            }
            else {
                *dwBackupFlags |= EX_ALREADY_EXISTS;
                DebugMsg((DM_VERBOSE, TEXT("ExtractProfileFromBackup:  A profile already exists")));
                goto Exit;
            }
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Failed to query internal flags with error %d"), lResult));
            bRetVal = FALSE;
            goto Exit;
        }

        RegCloseKey(hKey);
        hKey = NULL;
    }
    else {
       DebugMsg((DM_VERBOSE, TEXT("ExtractProfileFromBackup:  Failed to open key %s with error %d"), LocalKey, lResult));
    }


    //
    // Now try to get the profile from the backup
    //

    lstrcpy(LocalBackupKey, LocalKey);
    lstrcat(LocalBackupKey, c_szBAK);


    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, LocalBackupKey, 0, KEY_ALL_ACCESS, &hKey);

    if (lResult == ERROR_SUCCESS) {

        RegCloseKey(hKey);
        hKey = NULL;

        //
        // Check whether the key exists should already be done before this
        //

        lResult = RegRenameKey(HKEY_LOCAL_MACHINE, LocalBackupKey, LocalKey);
        if (lResult == ERROR_SUCCESS) {

            lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, LocalKey, 0, KEY_ALL_ACCESS, &hKey);

            if (lResult == ERROR_SUCCESS) {
                DWORD dwInternalFlags;

                dwSize = sizeof(DWORD);
                lResult = RegQueryValueEx (hKey, PROFILE_STATE, NULL, &dwType, (LPBYTE)&dwInternalFlags, &dwSize);

                if (lResult == ERROR_SUCCESS) {

                    dwInternalFlags &= ~PROFILE_THIS_IS_BAK;
                    lResult = RegSetValueEx (hKey, PROFILE_STATE, 0, REG_DWORD,
                                             (LPBYTE) &dwInternalFlags, sizeof(dwInternalFlags));
                }

                RegCloseKey(hKey);
                hKey = NULL;
            }
            else {
                DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Failed to open LocalKey with error %d"), lResult));
            }

            bRetVal = TRUE;
            *dwBackupFlags |= EX_PROFILE_CREATED;
            DebugMsg((DM_VERBOSE, TEXT("ExtractProfileFromBackup:  Profile created from Backup")));
            goto Exit;
        }
        else {
            DebugMsg((DM_WARNING, TEXT("ExtractProfileFromBackup:  Couldn't rename key %s -> %s.  Error = %d"), LocalBackupKey, LocalKey, lResult));
            bRetVal = FALSE;
            goto Exit;
        }
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("ExtractProfileFromBackup:  Couldn't open backup profile key.  Error = %d"), lResult));
    }

Exit:
    if (hKey)
        RegCloseKey(hKey);

    if (!bRetVal)
        SetLastError(lResult);

    return bRetVal;
}


//*************************************************************
//
//  PatchNewProfileIfRequired()
//
//  Purpose:  if the old sid and the new sid are not the same, delete the old
//             from the profile list and update the guidlist
//
//  Parameters: hToken   -   User Token
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/16/98    ushaji     Created
//
//*************************************************************
BOOL PatchNewProfileIfRequired(HANDLE hToken)
{
    TCHAR LocalOldProfileKey[MAX_PATH], LocalNewProfileKey[MAX_PATH], *lpEnd;
    HKEY  hNewKey=NULL;
    BOOL bRetVal = FALSE;
    DWORD dwType, dwDisp, dwSize;
    LONG lResult;
    LPTSTR OldSidString=NULL, SidString=NULL;
    PSID UserSid;
    DWORD dwBackupFlags;
    HMODULE hMsiLib = NULL;
    PFNMSINOTIFYSIDCHANGE pfnMsiNotifySidChange;

    //
    // Get the current sid.
    //

    SidString = GetSidString(hToken);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("PatchNewProfileIfRequred: No SidString found")));
        return FALSE;
    }

    if (ExtractProfileFromBackup(hToken, SidString, &dwBackupFlags)) {
        if ((dwBackupFlags & EX_ALREADY_EXISTS) || (dwBackupFlags & EX_PROFILE_CREATED)) {
            DebugMsg((DM_VERBOSE, TEXT("PatchNewProfileIfRequred: A profile already exists with the current sid, exitting")));
            bRetVal = TRUE;
            goto Exit;
        }
    }
    else {

        //
        // Treat it as if no such profile exists
        //
        DebugMsg((DM_VERBOSE, TEXT("PatchNewProfileIfRequred: ExtractProfileFromBackup returned error %d"), GetLastError()));
    }


    //
    // Get the old sid.
    //

    OldSidString = GetOldSidString(hToken, PROFILE_GUID_PATH);

    if (!OldSidString) {
        DebugMsg((DM_VERBOSE, TEXT("PatchNewProfileIfRequred: No OldSidString found")));
        bRetVal = TRUE;
        goto Exit;
    }


    //
    // if old sid and new sid are the same quit
    //

    if (lstrcmpi(OldSidString, SidString) == 0) {
        DebugMsg((DM_VERBOSE, TEXT("PatchNewProfileIfRequred: Old and the new sid are the same, exitting")));
        bRetVal = TRUE;
        goto Exit;
    }


    if (ExtractProfileFromBackup(hToken, OldSidString, &dwBackupFlags)) {
        if ((dwBackupFlags & EX_ALREADY_EXISTS) || (dwBackupFlags & EX_PROFILE_CREATED)) {
            DebugMsg((DM_VERBOSE, TEXT("PatchNewProfileIfRequred: A profile with the old sid found")));
        }
    }
    else {

        //
        // Treat it as if no such profile exists
        //
        DebugMsg((DM_VERBOSE, TEXT("PatchNewProfileIfRequred: ExtractProfileFromBackup returned error %d"), GetLastError()));
    }



    lstrcpy(LocalNewProfileKey, PROFILE_LIST_PATH);
    lpEnd = CheckSlash (LocalNewProfileKey);
    lstrcpy(lpEnd, SidString);


    lstrcpy(LocalOldProfileKey, PROFILE_LIST_PATH);
    lpEnd = CheckSlash (LocalOldProfileKey);
    lstrcpy(lpEnd, OldSidString);


    lResult = RegRenameKey(HKEY_LOCAL_MACHINE, LocalOldProfileKey, LocalNewProfileKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("PatchNewProfileIfRequred:  Failed to rename profile mapping key with error %d"), lResult));
        goto Exit;
    }


    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, LocalNewProfileKey, 0, 0, 0,
                             KEY_WRITE, NULL, &hNewKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("PatchNewProfileIfRequred:  Failed to open new profile mapping key with error %d"), lResult));
        goto Exit;
    }

    //
    // Get the sid of the logged on user
    //

    UserSid = GetUserSid(hToken);
    if (UserSid != NULL) {

        //
        // Store the user sid under the Sid key of the local profile
        //

        lResult = RegSetValueEx(hNewKey,
                    TEXT("Sid"),
                    0,
                    REG_BINARY,
                    (BYTE*)UserSid,
                    RtlLengthSid(UserSid));


        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("PatchNewProfileIfRequred:  Failed to set 'sid' value of user in profile list, error = %d"), lResult));
        }

        //
        // We're finished with the user sid
        //

         DeleteUserSid(UserSid);
    }


    //
    // Set the guid->sid corresp.
    //

    if (!SetOldSidString(hToken, SidString, PROFILE_GUID_PATH)) {
        DebugMsg((DM_WARNING, TEXT("PatchNewProfileIfRequred: Couldn't set the old Sid in the GuidList")));
    }


    //
    // Make a call to msi lib to notify sid change of user, so that it can update installation information
    //

    hMsiLib = LoadLibrary(TEXT("msi.dll"));
    if (hMsiLib) {
        pfnMsiNotifySidChange = (PFNMSINOTIFYSIDCHANGE) GetProcAddress(hMsiLib,
#ifdef UNICODE
                                                                       "MsiNotifySidChangeW");
#else
                                                                       "MsiNotifySidChangeA");
#endif

        if (pfnMsiNotifySidChange) {
            (*pfnMsiNotifySidChange)(OldSidString, SidString);
        }
        else {
            DebugMsg((DM_WARNING, TEXT("PatchNewProfileIfRequred: GetProcAddress returned failure. error %d"), GetLastError()));        
        }

        FreeLibrary(hMsiLib);
    }
    else {
        DebugMsg((DM_WARNING, TEXT("PatchNewProfileIfRequred: LoadLibrary returned failure. error %d"), GetLastError()));
    }
        

    bRetVal = TRUE;

Exit:

    if (SidString)
        DeleteSidString(SidString);

    if (OldSidString)
        DeleteSidString(OldSidString);


    if (hNewKey)
        RegCloseKey(hNewKey);

    return bRetVal;
}

//*************************************************************
//
//  IncrementProfileRefCount()
//
//  Purpose:    Increments Profile Ref Count
//
//  Parameters: lpProfile   -   Profile Information
//              bInitilize  -   dwRef should be initialized
//
//  Return:     Ref Count
//
//  Comments:   This functions ref counts independent of ability
//              to load/unload the hive.
//
//  Caveat:
//              We have changed the machanism here to use ref counting
//              and not depend on unloadability of ntuser.dat. NT4
//              apps might have forgotten to unloaduserprofiles
//              and might still be working because the handle got
//              closed automatically when processes
//              exitted. This will be treated as an App Bug.
//
//
//  History:    Date        Author     Comment
//              1/12/99     ushaji     Created
//
//*************************************************************

DWORD IncrementProfileRefCount(LPPROFILE lpProfile, BOOL bInitialize)
{
    LPTSTR SidString, lpEnd;
    TCHAR LocalProfileKey[MAX_PATH];
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize, dwCount, dwDisp, dwRef=0;

    //
    // Get the Sid string for the user
    //

    SidString = GetSidString(lpProfile->hTokenUser);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("IncrementProfileRefCount:  Failed to get sid string for user")));
        return 0;
    }


    //
    // Open the profile mapping
    //

    lstrcpy(LocalProfileKey, PROFILE_LIST_PATH);
    lpEnd = CheckSlash (LocalProfileKey);
    lstrcpy(lpEnd, SidString);

    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, LocalProfileKey, 0, 0, 0,
                             KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("IncrementProfileRefCount:  Failed to open profile mapping key with error %d"), lResult));
        DeleteSidString(SidString);
        return 0;
    }

    //
    // Query for the profile ref count.
    //

    dwSize = sizeof(DWORD);

    if (!bInitialize) {
        lResult = RegQueryValueEx (hKey,
                                   PROFILE_REF_COUNT,
                                   0,
                                   &dwType,
                                   (LPBYTE) &dwRef,
                                   &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_VERBOSE, TEXT("IncrementProfileRefCount:  Failed to query profile reference count with error %d"), lResult));
        }
    }

    dwRef++;

    //
    // Set the profile Ref count
    //

    lResult = RegSetValueEx (hKey,
                            PROFILE_REF_COUNT,
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwRef,
                            sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("IncrementProfileRefCount:  Failed to save profile reference count with error %d"), lResult));
    }


    DeleteSidString(SidString);

    RegCloseKey (hKey);

    return dwRef;

}

//*************************************************************
//
//  DecrementProfileRefCount()
//
//  Purpose:    Deccrements Profile Ref Count
//
//  Parameters: lpProfile   -   Profile Information
//
//  Return:     Ref Count
//
//  Comments:   This functions ref counts independent of ability
//              to load/unload the hive.
//
//  History:    Date        Author     Comment
//              1/12/99     ushaji     Created
//
//*************************************************************

DWORD DecrementProfileRefCount(LPPROFILE lpProfile)
{
    LPTSTR SidString, lpEnd;
    TCHAR LocalProfileKey[MAX_PATH];
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize, dwCount, dwDisp, dwRef=0;

    //
    // Get the Sid string for the user
    //

    SidString = GetSidString(lpProfile->hTokenUser);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("DecrementProfileRefCount:  Failed to get sid string for user")));
        return 0;
    }


    //
    // Open the profile mapping
    //

    lstrcpy(LocalProfileKey, PROFILE_LIST_PATH);
    lpEnd = CheckSlash (LocalProfileKey);
    lstrcpy(lpEnd, SidString);

    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, LocalProfileKey, 0, 0, 0,
                             KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("DecrementProfileRefCount:  Failed to open profile mapping key with error %d"), lResult));
        DeleteSidString(SidString);
        return 0;
    }

    //
    // Query for the profile ref count.
    //

    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx (hKey,
                            PROFILE_REF_COUNT,
                            0,
                            &dwType,
                            (LPBYTE) &dwRef,
                            &dwSize);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("DecrementProfileRefCount:  Failed to query profile reference count with error %d"), lResult));
    }


    if (dwRef) {
        dwRef--;
    }
    else {
        DebugMsg((DM_WARNING, TEXT("DecrementRefCount: Ref Count is already zero !!!!!!")));
    }


    //
    // Set the profile Ref count
    //

    lResult = RegSetValueEx (hKey,
                            PROFILE_REF_COUNT,
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwRef,
                            sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("DecrementProfileRefCount:  Failed to save profile reference count with error %d"), lResult));
    }


    DeleteSidString(SidString);

    RegCloseKey (hKey);

    return dwRef;

}

//*************************************************************
//
//  SaveProfileInfo()
//
//  Purpose:    Saves key parts of the lpProfile structure
//              in the registry for UnloadUserProfile to use.
//
//  Parameters: lpProfile   -   Profile information
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              12/4/95     ericflo    Created
//
//*************************************************************

BOOL SaveProfileInfo(LPPROFILE lpProfile)
{
    LPTSTR SidString, lpEnd;
    TCHAR LocalProfileKey[MAX_PATH];
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize, dwCount, dwDisp;
    LPTSTR szUserGuid = NULL;

    //
    // Get the Sid string for the user
    //

    SidString = GetSidString(lpProfile->hTokenUser);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("SaveProfileInfo:  Failed to get sid string for user")));
        return FALSE;
    }


    //
    // Open the profile mapping
    //

    lstrcpy(LocalProfileKey, PROFILE_LIST_PATH);
    lpEnd = CheckSlash (LocalProfileKey);
    lstrcpy(lpEnd, SidString);

    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, LocalProfileKey, 0, 0, 0,
                             KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("SaveProfileInfo:  Failed to open profile mapping key with error %d"), lResult));
        SetLastError(lResult);
        DeleteSidString(SidString);
        return FALSE;
    }

    //
    // Save the flags
    //
    lResult = RegSetValueEx (hKey,
                            PROFILE_FLAGS,
                            0,
                            REG_DWORD,
                            (LPBYTE) &lpProfile->dwFlags,
                            sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("SaveProfileInfo:  Failed to save flags with error %d"), lResult));
    }


    //
    // Save the internal flags
    //

    lResult = RegSetValueEx (hKey,
                            PROFILE_STATE,
                            0,
                            REG_DWORD,
                            (LPBYTE) &lpProfile->dwInternalFlags,
                            sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("SaveProfileInfo:  Failed to save flags2 with error %d"), lResult));
    }


    //
    // Save the central profile path only if it is non-null. 
    // That way it will allow a roaming user/administrator to change roaming profile to local 
    // and then go back to roaming again.
    //

    //
    // lpProfilePath contains the actual roaming share name whereas lpRoamingProfile contains path
    // name wrt to mapped drive name. If lpProfilePath is NULL then use lpRoamingProfile which 
    // is a NULL string.
    //

    lResult = RegSetValueEx(hKey,
                            PROFILE_CENTRAL_PROFILE,
                            0,
                            REG_SZ,
                            (LPBYTE) (lpProfile->lpProfilePath ? 
                                      lpProfile->lpProfilePath : lpProfile->lpRoamingProfile),
                            (lstrlen((lpProfile->lpProfilePath ? 
                                      lpProfile->lpProfilePath : lpProfile->lpRoamingProfile)) + 1) * sizeof(TCHAR));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("SaveProfileInfo:  Failed to save central profile with error %d"), lResult));
    }


    //
    // local profile path, saved in CreateLocalProfileImage
    //

    //
    // Save the profile load time
    //

    if (!(lpProfile->dwFlags & PI_LITELOAD)) {

        lResult = RegSetValueEx (hKey,
                                PROFILE_LOAD_TIME_LOW,
                                0,
                                REG_DWORD,
                                (LPBYTE) &lpProfile->ftProfileLoad.dwLowDateTime,
                                sizeof(DWORD));

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("SaveProfileInfo:  Failed to save low profile load time with error %d"), lResult));
        }


        lResult = RegSetValueEx (hKey,
                                PROFILE_LOAD_TIME_HIGH,
                                0,
                                REG_DWORD,
                                (LPBYTE) &lpProfile->ftProfileLoad.dwHighDateTime,
                                sizeof(DWORD));

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("SaveProfileInfo:  Failed to save high profile load time with error %d"), lResult));
        }
    }


    //
    // Set the user's GUID if this is a new profile
    //

    if (!(lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED) &&
        (lpProfile->dwInternalFlags & PROFILE_NEW_LOCAL)) {

        szUserGuid = GetUserGuid(lpProfile->hTokenUser);

        if (szUserGuid) {
            lResult = RegSetValueEx (hKey,
                                     PROFILE_GUID,
                                     0,
                                     REG_SZ,
                                     (LPBYTE) szUserGuid,
                                     (lstrlen(szUserGuid)+1)*sizeof(TCHAR));

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_WARNING, TEXT("SaveProfileInfo:  Failed to save user guid with error %d"), lResult));
            }

            LocalFree(szUserGuid);
        }

        //
        // Save the guid->sid corresp. for the next time
        //

        if (!SetOldSidString(lpProfile->hTokenUser, SidString, PROFILE_GUID_PATH)) {
            DebugMsg((DM_WARNING, TEXT("SaveProfileInfo: Couldn't set the old Sid in the GuidList")));
        }
    }

    DeleteSidString(SidString);

    RegCloseKey (hKey);


    return(TRUE);
}

//*************************************************************
//
//  LoadProfileInfo()
//
//  Purpose:    Loads key parts of the lpProfile structure
//              in the registry for UnloadUserProfile to use.
//
//  Parameters: hTokenClient      -   Caller's token.
//              hTokenUser        -   User's token
//              hKeyCurrentUser   -   User registry key handle
//
//  Return:     LPPROFILE if successful
//              NULL if not
//
//  Comments:   This function doesn't re-initialize all of the
//              fields in the PROFILE structure.
//
//  History:    Date        Author     Comment
//              12/5/95     ericflo    Created
//
//*************************************************************

LPPROFILE LoadProfileInfo (HANDLE hTokenClient, HANDLE hTokenUser, HKEY hKeyCurrentUser)
{
    LPPROFILE lpProfile;
    LPTSTR SidString = NULL, lpEnd;
    TCHAR szBuffer[MAX_PATH];
    LONG lResult;
    HKEY hKey = NULL;
    DWORD dwType, dwSize;
    UINT i;
    BOOL bSuccess = FALSE;
    DWORD dwErr = 0;

    dwErr = GetLastError();

    //
    // Allocate an internal Profile structure to work with.
    //

    lpProfile = (LPPROFILE) LocalAlloc (LPTR, sizeof(USERPROFILE));

    if (!lpProfile) {
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo: Failed to allocate memory")));
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // Save the data passed in.
    //

    lpProfile->hTokenClient = hTokenClient;
    lpProfile->hTokenUser = hTokenUser;
    lpProfile->hKeyCurrentUser = hKeyCurrentUser;


    //
    // Allocate memory for the various paths
    //

    lpProfile->lpLocalProfile = (LPTSTR)LocalAlloc (LPTR, MAX_PATH * sizeof(TCHAR));

    if (!lpProfile->lpLocalProfile) {
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to alloc memory for local profile path.  Error = %d"),
                 GetLastError()));
        dwErr = GetLastError();
        goto Exit;
    }


    lpProfile->lpRoamingProfile = (LPTSTR)LocalAlloc (LPTR, MAX_PATH * sizeof(TCHAR));

    if (!lpProfile->lpRoamingProfile) {
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to alloc memory for central profile path.  Error = %d"),
                 GetLastError()));
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // Get the Sid string for the user
    //

    SidString = GetProfileSidString(lpProfile->hTokenUser);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to get sid string for user")));
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // Open the profile mapping
    //

    lstrcpy(szBuffer, PROFILE_LIST_PATH);
    lpEnd = CheckSlash (szBuffer);
    lstrcpy(lpEnd, SidString);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0,
                             KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to open profile mapping key with error %d"), lResult));
        dwErr = lResult;
        goto Exit;
    }


    //
    // Query for the flags
    //

    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx (hKey,
                               PROFILE_FLAGS,
                               NULL,
                               &dwType,
                               (LPBYTE) &lpProfile->dwFlags,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to query flags with error %d"), lResult));
        dwErr = lResult;
        goto Exit;
    }


    //
    // Query for the internal flags
    //

    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx (hKey,
                               PROFILE_STATE,
                               NULL,
                               &dwType,
                               (LPBYTE) &lpProfile->dwInternalFlags,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to query internal flags with error %d"), lResult));
        dwErr = lResult;
        goto Exit;
    }


    //
    // Query for the user preference value
    //


    lpProfile->dwUserPreference = USERINFO_UNDEFINED;
    dwSize = sizeof(DWORD);

    RegQueryValueEx (hKey,
                     USER_PREFERENCE,
                     NULL,
                     &dwType,
                     (LPBYTE) &lpProfile->dwUserPreference,
                     &dwSize);



    //
    // Query for the central profile path
    //

    dwSize = MAX_PATH * sizeof(TCHAR);
    lResult = RegQueryValueEx (hKey,
                               PROFILE_CENTRAL_PROFILE,
                               NULL,
                               &dwType,
                               (LPBYTE) lpProfile->lpRoamingProfile,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("LoadProfileInfo:  Failed to query central profile with error %d"), lResult));
        lpProfile->lpRoamingProfile[0] = TEXT('\0');
    }


    //
    // Query for the local profile path.  The local profile path
    // needs to be expanded so read it into the temporary buffer.
    //

    dwSize = sizeof(szBuffer);
    lResult = RegQueryValueEx (hKey,
                               PROFILE_IMAGE_VALUE_NAME,
                               NULL,
                               &dwType,
                               (LPBYTE) szBuffer,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to query local profile with error %d"), lResult));
        dwErr = lResult;
        goto Exit;
    }

    //
    // Expand the local profile
    //

    ExpandEnvironmentStrings(szBuffer, lpProfile->lpLocalProfile, MAX_PATH);

    //
    // Query for the profile load time
    //

    lpProfile->ftProfileLoad.dwLowDateTime = 0;
    lpProfile->ftProfileLoad.dwHighDateTime = 0;

    if (!(lpProfile->dwFlags & PI_LITELOAD)) {
        dwSize = sizeof(lpProfile->ftProfileLoad.dwLowDateTime);

        lResult = RegQueryValueEx (hKey,
            PROFILE_LOAD_TIME_LOW,
            NULL,
            &dwType,
            (LPBYTE) &lpProfile->ftProfileLoad.dwLowDateTime,
            &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to query low profile load time with error %d"), lResult));
            dwErr = lResult;
            goto Exit;
        }


        dwSize = sizeof(lpProfile->ftProfileLoad.dwHighDateTime);

        lResult = RegQueryValueEx (hKey,
            PROFILE_LOAD_TIME_HIGH,
            NULL,
            &dwType,
            (LPBYTE) &lpProfile->ftProfileLoad.dwHighDateTime,
            &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to query high profile load time with error %d"), lResult));
            dwErr = lResult;
            goto Exit;
        }
    }

    //
    //  Sucess!
    //

    bSuccess = TRUE;


Exit:

    if (hKey) {
        RegCloseKey (hKey);
    }


    if (SidString) {
        DeleteSidString(SidString);
    }

    //
    // If the profile information was successfully loaded, return
    // lpProfile now.  Otherwise, free any memory and return NULL.
    //

    if (bSuccess) {
        SetLastError(dwErr);
        return lpProfile;
    }

    if (lpProfile) {

        if (lpProfile->lpRoamingProfile) {
            LocalFree (lpProfile->lpRoamingProfile);
        }

        if (lpProfile->lpLocalProfile) {
            LocalFree (lpProfile->lpLocalProfile);
        }

        LocalFree (lpProfile);
    }

    SetLastError(dwErr);

    return NULL;
}

//*************************************************************
//
//  CheckForSlowLink()
//
//  Purpose:    Checks if the network connection is slow.
//
//  Parameters: lpProfile   -   Profile Information
//              dwTime      -   Time delta
//              lpPath      -   UNC path to test
//              bDlgLogin   -   Type of Dialog
//
//  Return:     TRUE if profile should be downloaded
//              FALSE if not (use local)
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/21/96     ericflo    Created
//
//*************************************************************

BOOL CheckForSlowLink(LPPROFILE lpProfile, DWORD dwTime, LPTSTR lpPath, BOOL bDlgLogin)
{
    DWORD dwSlowTimeOut, dwSlowDlgTimeOut, dwSlowLinkDetectEnabled, dwSlowLinkUIEnabled;
    ULONG ulTransferRate;
    DWORD dwType, dwSize;
    BOOL bRetVal = TRUE;
    HKEY hKey;
    LONG lResult;
    BOOL bSlow = FALSE;
    BOOL bLegacyCheck = TRUE;
    LPTSTR lpPathTemp, lpTempSrc, lpTempDest;
    LPSTR lpPathTempA;
    struct hostent *hostp;
    ULONG inaddr, ulSpeed;
    DWORD dwResult;
    PWSOCK32_API pWSock32;
    LPTSTR szSidUser;
    handle_t  hIfProfileDialog;
    LPTSTR  lpRPCEndPoint = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    RPC_ASYNC_STATE  AsyncHnd;
    RPC_STATUS  status;

    //
    // If the User Preferences states to always use the local
    // profile then we can exit now with true.  The profile
    // won't actually be downloaded.  In RestoreUserProfile,
    // this will be filtered out, and only the local will be used.
    //

    if (lpProfile->dwUserPreference == USERINFO_LOCAL) {
        return TRUE;
    }


    //
    // Get the slow link detection flag, slow link timeout,
    // dialog box timeout values, and default profile to use.
    //

    dwSlowTimeOut = SLOW_LINK_TIMEOUT;
    dwSlowDlgTimeOut = PROFILE_DLG_TIMEOUT;
    dwSlowLinkDetectEnabled = 1;
    dwSlowLinkUIEnabled = 0;
    ulTransferRate = SLOW_LINK_TRANSFER_RATE;
    bRetVal = FALSE;


    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           WINLOGON_KEY,
                           0,
                           KEY_READ,
                           &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("SlowLinkDetectEnabled"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwSlowLinkDetectEnabled,
                         &dwSize);

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("SlowLinkTimeOut"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwSlowTimeOut,
                         &dwSize);

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("ProfileDlgTimeOut"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwSlowDlgTimeOut,
                         &dwSize);

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("SlowLinkUIEnabled"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwSlowLinkUIEnabled,
                         &dwSize);

        dwSize = sizeof(BOOL);
        RegQueryValueEx (hKey,
                         TEXT("SlowLinkProfileDefault"),
                         NULL,
                         &dwType,
                         (LPBYTE) &bRetVal,
                         &dwSize);

        dwSize = sizeof(ULONG);
        RegQueryValueEx (hKey,
                         TEXT("UserProfileMinTransferRate"),
                         NULL,
                         &dwType,
                         (LPBYTE) &ulTransferRate,
                         &dwSize);

        RegCloseKey (hKey);
    }


    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           SYSTEM_POLICIES_KEY,
                           0,
                           KEY_READ,
                           &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("SlowLinkDetectEnabled"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwSlowLinkDetectEnabled,
                         &dwSize);

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("SlowLinkTimeOut"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwSlowTimeOut,
                         &dwSize);

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("ProfileDlgTimeOut"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwSlowDlgTimeOut,
                         &dwSize);

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("SlowLinkUIEnabled"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwSlowLinkUIEnabled,
                         &dwSize);

        dwSize = sizeof(BOOL);
        RegQueryValueEx (hKey,
                         TEXT("SlowLinkProfileDefault"),
                         NULL,
                         &dwType,
                         (LPBYTE) &bRetVal,
                         &dwSize);

        dwSize = sizeof(ULONG);
        RegQueryValueEx (hKey,
                         TEXT("UserProfileMinTransferRate"),
                         NULL,
                         &dwType,
                         (LPBYTE) &ulTransferRate,
                         &dwSize);

        RegCloseKey (hKey);
    }


    //
    // If slow link detection is disabled, then always download
    // the profile.
    //

    if (!dwSlowLinkDetectEnabled || !ulTransferRate) {
        return TRUE;
    }

    //
    // If slow link timeout is set to 0 then always consider the link as slow link
    //

    if (!dwSlowTimeOut) {
        bSlow = TRUE;
        bLegacyCheck = FALSE;
    }

    //
    // If lpPath is  UNC path and we yet not decided that link is slow, then try 
    // pinging the server
    //

    if (!bSlow && (*lpPath == TEXT('\\')) && (*(lpPath+1) == TEXT('\\'))) {

        lpPathTemp = (LPTSTR)LocalAlloc (LPTR, (lstrlen(lpPath)+1) * sizeof(TCHAR));

        if (lpPathTemp) {
            lpTempSrc = lpPath+2;
            lpTempDest = lpPathTemp;

            while ((*lpTempSrc != TEXT('\\')) && *lpTempSrc) {
                *lpTempDest = *lpTempSrc;
                lpTempDest++;
                lpTempSrc++;
            }
            *lpTempDest = TEXT('\0');

            lpPathTempA = ProduceAFromW(lpPathTemp);

            if (lpPathTempA) {

                pWSock32 = LoadWSock32();

                if ( pWSock32 ) {

                    hostp = pWSock32->pfngethostbyname(lpPathTempA);

                    if (hostp) {
                        inaddr = *(long *)hostp->h_addr;

                        dwResult = PingComputer (inaddr, &ulSpeed);

                        if (dwResult == ERROR_SUCCESS) {

                            if (ulSpeed) {

                                //
                                // If the delta time is greater that the timeout time, then this
                                // is a slow link.
                                //

                                if (ulSpeed < ulTransferRate) {
                                    bSlow = TRUE;
                                }
                            }

                            bLegacyCheck = FALSE;
                        }
                    }
                }

                FreeProducedString(lpPathTempA);
            }

            LocalFree (lpPathTemp);
        }
    }


    if (bLegacyCheck) {

        //
        // If the delta time is less that the timeout time, then it
        // is ok to download their profile (fast enough net connection).
        //

        if (dwTime < dwSlowTimeOut) {
            return TRUE;
        }

    } else {

        if (!bSlow) {
            return TRUE;
        }
    }

    //
    // Display the slow link dialog
    //
    // If someone sets the dialog box timeout to 0, then we
    // don't want to prompt the user.  Just do the default
    //


    if ((dwSlowLinkUIEnabled) && (dwSlowDlgTimeOut > 0) && (!(lpProfile->dwFlags & PI_NOUI))) {
 
        szSidUser = GetSidString(lpProfile->hTokenUser);
        if (szSidUser) {
            lpRPCEndPoint = cUserProfileManager.GetRPCEndPoint(szSidUser);

            if (lpRPCEndPoint && GetInterface(&hIfProfileDialog, lpRPCEndPoint)) {
                DebugMsg((DM_VERBOSE, TEXT("CheckForSlowLink: RPC End point %s"), lpRPCEndPoint));
                           
                status = RpcAsyncInitializeHandle(&AsyncHnd, sizeof(RPC_ASYNC_STATE));
                if (status != RPC_S_OK) {
                    dwErr = status;
                    DebugMsg((DM_WARNING, TEXT("CheckForSlowLink: RpcAsyncInitializeHandle failed. err = %d"), dwErr));
                }
                else {
                    AsyncHnd.UserInfo = NULL;                                  // App specific info, not req
                    AsyncHnd.NotificationType = RpcNotificationTypeEvent;      // Init the notification event
                    AsyncHnd.u.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
                    
                    if (AsyncHnd.u.hEvent) {
                        RpcTryExcept {
                            cliSlowLinkDialog(&AsyncHnd, hIfProfileDialog, dwSlowDlgTimeOut, bRetVal, &bRetVal, bDlgLogin);
                        }
                        RpcExcept(1) {
                            dwErr = RpcExceptionCode();
                            DebugMsg((DM_WARNING, TEXT("CheckForSlowLink: Calling SlowLinkDialog took exception. err = %d"), dwErr));
                        }
                        RpcEndExcept

                        DebugMsg((DM_VERBOSE, TEXT("CheckForSlowLink: waiting on rpc async event")));
                        if (WaitForSingleObject(AsyncHnd.u.hEvent, (dwSlowDlgTimeOut + 10)*1000) == WAIT_OBJECT_0) {
                            RpcAsyncCompleteCall(&AsyncHnd, (PVOID)&dwErr);
                        }
                        else {
                            dwErr = GetLastError();
                            RpcAsyncCancelCall(&AsyncHnd, TRUE);
                            DebugMsg((DM_WARNING, TEXT("CheckForSlowLink: Timeout occurs. Client not responding"), dwErr));
                        }

                        // Release the resource

                        CloseHandle(AsyncHnd.u.hEvent);
                    }
                    else {
                        dwErr = GetLastError();
                        DebugMsg((DM_WARNING, TEXT("CheckForSlowLink: create event failed. error %d"), dwErr));
                    }
                } 
   
                if (dwErr != ERROR_SUCCESS) {
                    DebugMsg((DM_WARNING, TEXT("CheckForSlowLink: fail to show message error %d"), GetLastError()));
                }
                ReleaseInterface(&hIfProfileDialog);
            }

            DeleteSidString(szSidUser);
        }
        else {
            DebugMsg((DM_WARNING, TEXT("CheckForSlowLink: Unable to get SID string from token.")));
        }

        if (!lpRPCEndPoint) {
            SLOWLINKDLGINFO info;

            info.dwTimeout = dwSlowDlgTimeOut;
            info.bSyncDefault = bRetVal;
  
            DebugMsg((DM_VERBOSE, TEXT("CheckForSlowLink: Calling DialogBoxParam")));
            if (bDlgLogin) {
                bRetVal = (BOOL)DialogBoxParam (g_hDllInstance, MAKEINTRESOURCE(IDD_LOGIN_SLOW_LINK),
                                                NULL, LoginSlowLinkDlgProc, (LPARAM)&info);
            }
            else {
                bRetVal = (BOOL)DialogBoxParam (g_hDllInstance, MAKEINTRESOURCE(IDD_LOGOFF_SLOW_LINK),
                                                NULL, LogoffSlowLinkDlgProc, (LPARAM)&info);
            }
        }

    }

    if (!bRetVal) {
        lpProfile->dwInternalFlags |= PROFILE_SLOW_LINK;
        DebugMsg((DM_VERBOSE, TEXT("CheckForSlowLink:  The profile is across a slow link")));
    }

    return bRetVal;
}


//*************************************************************
//
//  LoginSlowLinkDlgProc()
//
//  Purpose:    Dialog box procedure for the slow link dialog
//              at login time
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/13/96     ericflo    Created
//
//*************************************************************

INT_PTR APIENTRY LoginSlowLinkDlgProc (HWND hDlg, UINT uMsg,
                                       WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuffer[10];
    static DWORD dwSlowLinkTime;
    BOOL bDownloadDefault;

    switch (uMsg) {

        case WM_INITDIALOG:
           SetForegroundWindow(hDlg);
           CenterWindow (hDlg);

           //
           // Set the default button and focus
           //

           if (((LPSLOWLINKDLGINFO)lParam)->bSyncDefault) {

                SetFocus (GetDlgItem(hDlg, IDC_DOWNLOAD));

           } else {
                HWND hwnd;
                LONG style;

                //
                // Set the default button to Local
                //

                hwnd = GetDlgItem (hDlg, IDC_DOWNLOAD);
                style = GetWindowLong (hwnd, GWL_STYLE);
                style &= ~(BS_DEFPUSHBUTTON | BS_NOTIFY);
                style |= BS_PUSHBUTTON;
                SetWindowLong (hwnd, GWL_STYLE, style);

                hwnd = GetDlgItem (hDlg, IDC_LOCAL);
                style = GetWindowLong (hwnd, GWL_STYLE);
                style &= ~(BS_PUSHBUTTON | BS_DEFPUSHBUTTON);
                style |= (BS_DEFPUSHBUTTON | BS_NOTIFY);
                SetWindowLong (hwnd, GWL_STYLE, style);

                SetFocus (GetDlgItem(hDlg, IDC_LOCAL));
           }

           SetWindowLongPtr (hDlg, DWLP_USER, ((LPSLOWLINKDLGINFO)lParam)->bSyncDefault);
           dwSlowLinkTime = ((LPSLOWLINKDLGINFO)lParam)->dwTimeout;
           wsprintf (szBuffer, TEXT("%d"), dwSlowLinkTime);
           SetDlgItemText (hDlg, IDC_TIMEOUT, szBuffer);
           SetTimer (hDlg, 1, 1000, NULL);
           return FALSE;

        case WM_TIMER:

           if (dwSlowLinkTime >= 1) {

               dwSlowLinkTime--;
               wsprintf (szBuffer, TEXT("%d"), dwSlowLinkTime);
               SetDlgItemText (hDlg, IDC_TIMEOUT, szBuffer);

           } else {

               //
               // Time's up.  Do the default action.
               //

               bDownloadDefault = (BOOL) GetWindowLongPtr (hDlg, DWLP_USER);

               if (bDownloadDefault) {
                   PostMessage (hDlg, WM_COMMAND, IDC_DOWNLOAD, 0);

               } else {
                   PostMessage (hDlg, WM_COMMAND, IDC_LOCAL, 0);
               }
           }
           break;

        case WM_COMMAND:

          switch (LOWORD(wParam)) {

              case IDC_DOWNLOAD:
                  if (HIWORD(wParam) == BN_KILLFOCUS) {
                      bDownloadDefault = (BOOL) GetWindowLongPtr (hDlg, DWLP_USER);
                      if (bDownloadDefault) {
                          KillTimer (hDlg, 1);
                          ShowWindow(GetDlgItem(hDlg, IDC_TIMEOUT), SW_HIDE);
                          ShowWindow(GetDlgItem(hDlg, IDC_TIMETITLE), SW_HIDE);
                      }
                  } else if (HIWORD(wParam) == BN_CLICKED) {
                      DebugMsg((DM_VERBOSE, TEXT("LoginSlowLinkDlgProc:: Killing DialogBox because download button was clicked")));
                      KillTimer (hDlg, 1);
                      EndDialog(hDlg, TRUE);
                  }
                  break;

              case IDC_LOCAL:
                  if (HIWORD(wParam) == BN_KILLFOCUS) {
                      bDownloadDefault = (BOOL) GetWindowLongPtr (hDlg, DWLP_USER);
                      if (!bDownloadDefault) {
                          KillTimer (hDlg, 1);
                          ShowWindow(GetDlgItem(hDlg, IDC_TIMEOUT), SW_HIDE);
                          ShowWindow(GetDlgItem(hDlg, IDC_TIMETITLE), SW_HIDE);
                      }
                      break;
                  } else if (HIWORD(wParam) == BN_CLICKED) {
                      DebugMsg((DM_VERBOSE, TEXT("LoginSlowLinkDlgProc:: Killing DialogBox because local button was clicked")));
                      KillTimer (hDlg, 1);
                      EndDialog(hDlg, FALSE);
                  }
                  break;

              case IDCANCEL:
                  bDownloadDefault = (BOOL) GetWindowLongPtr (hDlg, DWLP_USER);

                  //
                  // Nothing to do.  Save the state and return.
                  //

                  DebugMsg((DM_VERBOSE, TEXT("LoginSlowLinkDlgProc:: Killing DialogBox because local/cancel button was clicked")));
                  KillTimer (hDlg, 1);

                  //
                  // Return Whatever is the default in this case..
                  //

                  EndDialog(hDlg, bDownloadDefault);
                  break;

              default:
                  break;

          }
          break;

    }

    return FALSE;
}

//*************************************************************
//
//  LogoffSlowLinkDlgProc()
//
//  Purpose:    Dialog box procedure for the slow link dialog
//              at login time
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/13/96     ericflo    Created
//
//*************************************************************

INT_PTR APIENTRY LogoffSlowLinkDlgProc (HWND hDlg, UINT uMsg,
                                        WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuffer[10];
    static DWORD dwSlowLinkTime;
    BOOL bUploadDefault;

    switch (uMsg) {

        case WM_INITDIALOG:
           SetForegroundWindow(hDlg);
           CenterWindow (hDlg);

           //
           // Set the default button and focus
           //

           if (((LPSLOWLINKDLGINFO)lParam)->bSyncDefault) {

                SetFocus (GetDlgItem(hDlg, IDC_UPLOAD));

           } else {
                HWND hwnd;
                LONG style;

                //
                // Set the default button to Local
                //

                hwnd = GetDlgItem (hDlg, IDC_UPLOAD);
                style = GetWindowLong (hwnd, GWL_STYLE);
                style &= ~(BS_DEFPUSHBUTTON | BS_NOTIFY);
                style |= BS_PUSHBUTTON;
                SetWindowLong (hwnd, GWL_STYLE, style);

                hwnd = GetDlgItem (hDlg, IDC_NOUPLOAD);
                style = GetWindowLong (hwnd, GWL_STYLE);
                style &= ~(BS_PUSHBUTTON | BS_DEFPUSHBUTTON);
                style |= (BS_DEFPUSHBUTTON | BS_NOTIFY);
                SetWindowLong (hwnd, GWL_STYLE, style);

                SetFocus (GetDlgItem(hDlg, IDC_NOUPLOAD));
           }

           SetWindowLongPtr (hDlg, DWLP_USER, ((LPSLOWLINKDLGINFO)lParam)->bSyncDefault);
           dwSlowLinkTime = ((LPSLOWLINKDLGINFO)lParam)->dwTimeout;
           wsprintf (szBuffer, TEXT("%d"), dwSlowLinkTime);
           SetDlgItemText (hDlg, IDC_TIMEOUT, szBuffer);
           SetTimer (hDlg, 1, 1000, NULL);
           return FALSE;

        case WM_TIMER:

           if (dwSlowLinkTime >= 1) {

               dwSlowLinkTime--;
               wsprintf (szBuffer, TEXT("%d"), dwSlowLinkTime);
               SetDlgItemText (hDlg, IDC_TIMEOUT, szBuffer);

           } else {

               //
               // Time's up.  Do the default action.
               //

               bUploadDefault = (BOOL) GetWindowLongPtr (hDlg, DWLP_USER);

               if (bUploadDefault) {
                   PostMessage (hDlg, WM_COMMAND, IDC_UPLOAD, 0);

               } else {
                   PostMessage (hDlg, WM_COMMAND, IDC_NOUPLOAD, 0);
               }
           }
           break;

        case WM_COMMAND:

          switch (LOWORD(wParam)) {

              case IDC_UPLOAD:
                  if (HIWORD(wParam) == BN_KILLFOCUS) {
                      bUploadDefault = (BOOL) GetWindowLongPtr (hDlg, DWLP_USER);
                      if (bUploadDefault) {
                          KillTimer (hDlg, 1);
                          ShowWindow(GetDlgItem(hDlg, IDC_TIMEOUT), SW_HIDE);
                          ShowWindow(GetDlgItem(hDlg, IDC_TIMETITLE), SW_HIDE);
                      }
                  } else if (HIWORD(wParam) == BN_CLICKED) {
                      DebugMsg((DM_VERBOSE, TEXT("LogoffSlowLinkDlgProc:: Killing DialogBox because upload button was clicked")));
                      KillTimer (hDlg, 1);
                      EndDialog(hDlg, TRUE);
                  }
                  break;

              case IDC_NOUPLOAD:
                  if (HIWORD(wParam) == BN_KILLFOCUS) {
                      bUploadDefault = (BOOL) GetWindowLongPtr (hDlg, DWLP_USER);
                      if (!bUploadDefault) {
                          KillTimer (hDlg, 1);
                          ShowWindow(GetDlgItem(hDlg, IDC_TIMEOUT), SW_HIDE);
                          ShowWindow(GetDlgItem(hDlg, IDC_TIMETITLE), SW_HIDE);
                      }
                      break;
                  } else if (HIWORD(wParam) == BN_CLICKED) {
                      DebugMsg((DM_VERBOSE, TEXT("LogoffSlowLinkDlgProc:: Killing DialogBox because Don't Upload button was clicked")));
                      KillTimer (hDlg, 1);
                      EndDialog(hDlg, FALSE);
                  }
                  break;

              case IDCANCEL:
                  bUploadDefault = (BOOL) GetWindowLongPtr (hDlg, DWLP_USER);

                  //
                  // Nothing to do.  Save the state and return.
                  //

                  DebugMsg((DM_VERBOSE, TEXT("LogoffSlowLinkDlgProc:: Killing DialogBox because cancel button was clicked")));
                  KillTimer (hDlg, 1);

                  //
                  // Return Whatever is the default in this case..
                  //

                  EndDialog(hDlg, bUploadDefault);
                  break;

              default:
                  break;

          }
          break;

    }

    return FALSE;
}

//*************************************************************
//
//  GetUserPreferenceValue()
//
//  Purpose:    Gets the User Preference flags
//
//  Parameters: hToken  -   User's token
//
//  Return:     Value
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/22/96     ericflo    Created
//
//*************************************************************

DWORD GetUserPreferenceValue(HANDLE hToken)
{
    TCHAR LocalProfileKey[MAX_PATH];
    DWORD RegErr, dwType, dwSize, dwTmpVal, dwRetVal = USERINFO_UNDEFINED;
    LPTSTR lpEnd;
    LPTSTR SidString;
    HKEY hkeyProfile, hkeyPolicy;


    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SYSTEM_POLICIES_KEY,
                     0, KEY_READ,
                     &hkeyPolicy) == ERROR_SUCCESS) {

        dwSize = sizeof(dwTmpVal);
        RegQueryValueEx(hkeyPolicy,
                        PROFILE_LOCALONLY,
                        NULL, &dwType,
                        (LPBYTE) &dwTmpVal,
                        &dwSize);

        RegCloseKey (hkeyPolicy);
        if (dwTmpVal == 1) {
            dwRetVal = USERINFO_LOCAL;
            return dwRetVal;
        }
    }    

    
    SidString = GetProfileSidString(hToken);
    if (SidString != NULL) {

        //
        // Query for the UserPreference value
        //

        lstrcpy(LocalProfileKey, PROFILE_LIST_PATH);
        lpEnd = CheckSlash (LocalProfileKey);
        lstrcpy(lpEnd, SidString);

        RegErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              LocalProfileKey,
                              0,
                              KEY_READ,
                              &hkeyProfile);


        if (RegErr == ERROR_SUCCESS) {

            dwSize = sizeof(dwRetVal);
            RegQueryValueEx(hkeyProfile,
                            USER_PREFERENCE,
                            NULL,
                            &dwType,
                            (LPBYTE) &dwRetVal,
                            &dwSize);

            RegCloseKey (hkeyProfile);
        }

        lstrcat(LocalProfileKey, c_szBAK);
        RegErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              LocalProfileKey,
                              0,
                              KEY_READ,
                              &hkeyProfile);


        if (RegErr == ERROR_SUCCESS) {

            dwSize = sizeof(dwRetVal);
            RegQueryValueEx(hkeyProfile,
                            USER_PREFERENCE,
                            NULL,
                            &dwType,
                            (LPBYTE) &dwRetVal,
                            &dwSize);

            RegCloseKey (hkeyProfile);
        }

        DeleteSidString(SidString);
    }

    return dwRetVal;
}


//*************************************************************
//
//  IsTempProfileAllowed()
//
//  Purpose:    Gets the temp profile policy
//
//  Parameters:
//
//  Return:     true if temp profile can be created, false otherwise
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/8/99      ushaji     Created
//
//*************************************************************

BOOL IsTempProfileAllowed()
{
    HKEY hKey;
    LONG lResult;
    DWORD dwSize, dwType;
    DWORD dwRetVal = PROFILEERRORACTION_TEMP;

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           SYSTEM_POLICIES_KEY,
                           0,
                           KEY_READ,
                           &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("ProfileErrorAction"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwRetVal,
                         &dwSize);

        RegCloseKey (hKey);
    }

    DebugMsg((DM_VERBOSE, TEXT("IsTempProfileAllowed:  Returning %d"), (dwRetVal == PROFILEERRORACTION_TEMP)));
    return (dwRetVal == PROFILEERRORACTION_TEMP);
}

//*************************************************************
//
//  MoveUserProfiles()
//
//  Purpose:    Moves all user profiles from source location
//              to the new profile location
//
//  Parameters: lpSrcDir   -   Source directory
//              lpDestDir  -   Destination directory
//
//  Notes:      The source directory should be given in the same
//              format as the pathnames appear in the ProfileList
//              registry key.  eg:  normally the profile paths
//              are in this form:  %SystemRoot%\Profiles.  The
//              path passed to this function should be in the unexpanded
//              format.
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL MoveUserProfiles (LPCTSTR lpSrcDir, LPCTSTR lpDestDir)
{
    BOOL bResult = TRUE;
    LONG lResult;
    DWORD dwIndex, dwType, dwSize, dwDisp;
    DWORD dwLength, dwLengthNeeded, dwStrLen;
    PSECURITY_DESCRIPTOR pSD;
    LPTSTR lpEnd, lpNewPathEnd, lpNameEnd;
    TCHAR szName[75];
    TCHAR szTemp[MAX_PATH + 1];
    TCHAR szOldProfilePath[MAX_PATH + 1];
    TCHAR szNewProfilePath[MAX_PATH + 1];
    TCHAR szExpOldProfilePath[MAX_PATH + 1] = {0};
    TCHAR szExpNewProfilePath[MAX_PATH + 1];
    WIN32_FILE_ATTRIBUTE_DATA fad;
    INT iSrcDirLen;
    HKEY hKeyProfileList, hKeyProfile, hKeyFolders;
    FILETIME ftWrite;


    //
    // Make sure we don't try to move on top of ourselves
    //

    if (lstrcmpi (lpSrcDir, lpDestDir) == 0) {
        DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Old profiles directory and new profiles directory are the same.")));
        bResult = FALSE;
        goto Exit;
    }


    //
    // Open the profile list
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH,
                            0, KEY_READ, &hKeyProfileList);

    if (lResult != ERROR_SUCCESS) {
        if (lResult != ERROR_PATH_NOT_FOUND) {
            DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to open profile list registry key with %d"), lResult));
            bResult = FALSE;
        }
        goto DoDefaults;
    }


    //
    // Enumerate the profiles
    //

    lstrcpy (szTemp, PROFILE_LIST_PATH);
    lpEnd = CheckSlash (szTemp);
    iSrcDirLen = lstrlen (lpSrcDir);

    dwIndex = 0;
    dwSize = ARRAYSIZE(szName);

    while (RegEnumKeyEx (hKeyProfileList, dwIndex, szName, &dwSize, NULL, NULL,
                  NULL, &ftWrite) == ERROR_SUCCESS) {


        //
        // Check if this profile is in use
        //

        if (RegOpenKeyEx(HKEY_USERS, szName, 0, KEY_READ,
                         &hKeyProfile) == ERROR_SUCCESS) {

            DebugMsg((DM_VERBOSE, TEXT("MoveUserProfiles:  Skipping <%s> because it is in use."), szName));
            RegCloseKey (hKeyProfile);
            goto LoopAgain;
        }


        //
        // Open the key for a specific profile
        //

        lstrcpy (lpEnd, szName);

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTemp, 0,
                     KEY_READ | KEY_WRITE, &hKeyProfile) == ERROR_SUCCESS) {


            //
            // Query for the previous profile location
            //

            szOldProfilePath[0] = TEXT('\0');
            dwSize = ARRAYSIZE(szOldProfilePath) * sizeof(TCHAR);

            RegQueryValueEx (hKeyProfile, PROFILE_IMAGE_VALUE_NAME, NULL,
                             &dwType, (LPBYTE) szOldProfilePath, &dwSize);


            //
            // If the profile is located in the source directory,
            // move it to the new profiles directory.
            //

            if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                               szOldProfilePath, iSrcDirLen,
                               lpSrcDir, iSrcDirLen) == CSTR_EQUAL) {

                //
                // Copy the user's name into a buffer we can change
                //

                lstrcpy (szName, (szOldProfilePath + iSrcDirLen + 1));


                //
                // If the user's name has a .000, .001, etc at the end,
                // remove that.
                //

                dwStrLen = lstrlen(szName);
                if (dwStrLen > 3) {
                    lpNameEnd = szName + dwStrLen - 4;

                    if (*lpNameEnd == TEXT('.')) {
                        *lpNameEnd = TEXT('\0');
                    }
                }


                //
                // Call ComputeLocalProfileName to get the new
                // profile directory (this also creates the directory)
                //

                lstrcpy (szNewProfilePath, lpDestDir);

                if (!ComputeLocalProfileName (NULL, szName,
                              szNewProfilePath, ARRAYSIZE(szNewProfilePath),
                              szExpNewProfilePath, ARRAYSIZE(szExpNewProfilePath),
                              NULL, FALSE)) {
                    DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to generate unique directory name for <%s>"),
                              szName));
                    goto LoopAgain;
                }


                DebugMsg((DM_VERBOSE, TEXT("MoveUserProfiles:  Moving <%s> to <%s>"),
                          szOldProfilePath, szNewProfilePath));

                ExpandEnvironmentStrings (szOldProfilePath, szExpOldProfilePath,
                                          ARRAYSIZE(szExpOldProfilePath));


                //
                // Copy the ACLs from the old location to the new
                //

                dwLength = 1024;

                pSD = (PSECURITY_DESCRIPTOR)LocalAlloc (LPTR, dwLength);

                if (pSD) {

                    if (GetFileSecurity (szExpOldProfilePath,
                                         DACL_SECURITY_INFORMATION,
                                         pSD, dwLength, &dwLengthNeeded) &&
                        (dwLengthNeeded == 0)) {

                        SetFileSecurity (szExpNewProfilePath,
                                         DACL_SECURITY_INFORMATION, pSD);
                    } else {
                        DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to allocate get security descriptor with %d.  dwLengthNeeded = %d"),
                                 GetLastError(), dwLengthNeeded));
                    }

                    LocalFree (pSD);

                } else {
                    DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to allocate memory for SD with %d."),
                             GetLastError()));
                }


                //
                // Copy the files from the old location to the new
                //

                if (CopyProfileDirectory (szExpOldProfilePath, szExpNewProfilePath,
                                          CPD_COPYIFDIFFERENT)) {

                    DebugMsg((DM_VERBOSE, TEXT("MoveUserProfiles:  Profile copied successfully.")));


                    //
                    // Change the registry to point at the new profile
                    //

                    lResult = RegSetValueEx (hKeyProfile, PROFILE_IMAGE_VALUE_NAME, 0,
                                             REG_EXPAND_SZ, (LPBYTE) szNewProfilePath,
                                             ((lstrlen(szNewProfilePath) + 1) * sizeof(TCHAR)));

                    if (lResult == ERROR_SUCCESS) {

                        //
                        // Delete the old profile
                        //

                        Delnode (szExpOldProfilePath);

                    } else {
                        DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to set new profile path in registry with %d."), lResult));
                    }


                } else {
                    DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  CopyProfileDirectory failed.")));
                }
            }

            RegCloseKey (hKeyProfile);
        }

LoopAgain:

        dwIndex++;
        dwSize = ARRAYSIZE(szName);
    }

    RegCloseKey (hKeyProfileList);


DoDefaults:


    lstrcpy (szOldProfilePath, lpSrcDir);
    ExpandEnvironmentStrings (szOldProfilePath, szExpOldProfilePath,
                              ARRAYSIZE(szExpOldProfilePath));

    lpEnd = CheckSlash(szExpOldProfilePath);


    //
    // Now try to move the Default User profile
    //

    lstrcpy (lpEnd, DEFAULT_USER);
    if (GetFileAttributesEx (szExpOldProfilePath, GetFileExInfoStandard, &fad)) {

        dwSize = ARRAYSIZE(szExpNewProfilePath);
        if (!GetDefaultUserProfileDirectoryEx(szExpNewProfilePath, &dwSize, TRUE)) {
            DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to query default user profile directory.")));
            goto Exit;
        }

        if (CopyProfileDirectory (szExpOldProfilePath, szExpNewProfilePath,
                                  CPD_COPYIFDIFFERENT)) {
            Delnode (szExpOldProfilePath);
        }
    }


    //
    // Delnode the Network Default User profile if it exists
    //

    lstrcpy (lpEnd, DEFAULT_USER_NETWORK);
    Delnode (szExpOldProfilePath);


    //
    // Now try to move the All Users profile
    //

    lstrcpy (lpEnd, ALL_USERS);
    if (GetFileAttributesEx (szExpOldProfilePath, GetFileExInfoStandard, &fad)) {

        dwSize = ARRAYSIZE(szExpNewProfilePath);
        if (!GetAllUsersProfileDirectoryEx(szExpNewProfilePath, &dwSize, TRUE)) {
            DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to query all users profile directory.")));
            goto Exit;
        }

        if (CopyProfileDirectory (szExpOldProfilePath, szExpNewProfilePath,
                                  CPD_COPYIFDIFFERENT)) {
            Delnode (szExpOldProfilePath);
        }
    }


    //
    // If possible, remove the old profiles directory
    //

    ExpandEnvironmentStrings (lpSrcDir, szExpOldProfilePath,
                              ARRAYSIZE(szExpOldProfilePath));

    RemoveDirectory (szExpOldProfilePath);


Exit:

    return bResult;
}


//*************************************************************
//
//  PrepareProfileForUse()
//
//  Purpose:    Prepares the profile for use on this machine.
//
//  Parameters: lpProfile  -  Profile information
//              pEnv       -  Environment block in per user basis
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL PrepareProfileForUse (LPPROFILE lpProfile, LPVOID pEnv)
{
    TCHAR        szTemp[MAX_PATH];
    TCHAR        szExpTemp[MAX_PATH];
    HKEY         hKey;
    HKEY         hKeyShellFolders = NULL;
    DWORD        dwSize;
    DWORD        dwType;
    DWORD        dwDisp;
    DWORD        dwStrLen;
    DWORD        i;
    DWORD        dwErr;
    PSHELL32_API pShell32Api;

    //
    // Load Shell32.dll.  Give up if it fails.
    //

    if ( ERROR_SUCCESS !=  LoadShell32Api( &pShell32Api ) ) {
        return TRUE;
    }


    //
    // Calculate the length of the user profile environment variable
    //

    dwStrLen = lstrlen (TEXT("%USERPROFILE%"));


    //
    // Open the Shell Folders key
    //

    RegCreateKeyEx(lpProfile->hKeyCurrentUser, SHELL_FOLDERS, 0, 0, 0,
                   KEY_WRITE, NULL, &hKeyShellFolders, &dwDisp);


    //
    // Open the User Shell Folders key
    //

    if (RegOpenKeyEx (lpProfile->hKeyCurrentUser,
                      USER_SHELL_FOLDERS, 0, KEY_READ,
                      &hKey) == ERROR_SUCCESS) {


        //
        // Enumerate the folders we know about
        //

        for (i=0; i < g_dwNumShellFolders; i++) {

            //
            // Query for the unexpanded path name
            //

            szTemp[0] = TEXT('\0');
            dwSize = sizeof(szTemp);
            if (RegQueryValueEx (hKey, c_ShellFolders[i].lpFolderName, NULL,
                                &dwType, (LPBYTE) szTemp, &dwSize) == ERROR_SUCCESS) {


                //
                // Expand the path name
                //

                ExpandUserEnvironmentStrings (pEnv, szTemp, szExpTemp, ARRAYSIZE(szExpTemp));


                //
                // If this is a local directory, create it and set the
                // hidden bit if appropriate
                //

                if (c_ShellFolders[i].bLocal) {

                    if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                       TEXT("%USERPROFILE%"), dwStrLen,
                                       szTemp, dwStrLen) == CSTR_EQUAL) {

                        if (CreateNestedDirectory (szExpTemp, NULL)) {

                            if (c_ShellFolders[i].iFolderResourceID != 0) {
                                dwErr = pShell32Api->pfnShSetLocalizedName(
                                    szExpTemp,
                                    c_ShellFolders[i].lpFolderResourceDLL,
                                    c_ShellFolders[i].iFolderResourceID );
                                if (dwErr != ERROR_SUCCESS) {
                                    DebugMsg((DM_WARNING, TEXT("PrepareProfileForUse: SHSetLocalizedName failed for directory <%s>.  Error = %d"),
                                             szExpTemp, dwErr));
                                }
                            }

                            if (c_ShellFolders[i].bHidden) {
                                SetFileAttributes(szExpTemp, FILE_ATTRIBUTE_HIDDEN);
                            } else {
                                SetFileAttributes(szExpTemp, FILE_ATTRIBUTE_NORMAL);
                            }

                        } else {
                            DebugMsg((DM_WARNING, TEXT("PrepareProfileForUse:  Failed to create directory <%s> with %d."),
                                     szExpTemp, GetLastError()));
                        }
                    }
                }


                //
                // Set the expanded path in the Shell Folders key.
                // This helps some apps that look at the Shell Folders
                // key directly instead of using the shell api
                //

                if (hKeyShellFolders) {

                    RegSetValueEx (hKeyShellFolders, c_ShellFolders[i].lpFolderName, 0,
                                   REG_SZ, (LPBYTE) szExpTemp,
                                   ((lstrlen(szExpTemp) + 1) * sizeof(TCHAR)));
                }
            }
        }

        RegCloseKey (hKey);
    }


    //
    // Close the Shell Folders key
    //

    if (hKeyShellFolders) {
        RegCloseKey (hKeyShellFolders);
    }


    //
    // Now check that the temp directory exists.
    //

    if (RegOpenKeyEx (lpProfile->hKeyCurrentUser,
                      TEXT("Environment"), 0, KEY_READ,
                      &hKey) == ERROR_SUCCESS) {

        //
        // Check for TEMP
        //

        szTemp[0] = TEXT('\0');
        dwSize = sizeof(szTemp);
        if (RegQueryValueEx (hKey, TEXT("TEMP"), NULL, &dwType,
                             (LPBYTE) szTemp, &dwSize) == ERROR_SUCCESS) {

            if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                               TEXT("%USERPROFILE%"), dwStrLen,
                               szTemp, dwStrLen) == CSTR_EQUAL) {

                ExpandUserEnvironmentStrings (pEnv, szTemp, szExpTemp, ARRAYSIZE(szExpTemp));
                if (!CreateNestedDirectory (szExpTemp, NULL)) {
                    DebugMsg((DM_WARNING, TEXT("PrepareProfileForUse:  Failed to create temp directory <%s> with %d."),
                             szExpTemp, GetLastError()));
                }
            }
        }


        //
        // Check for TMP
        //

        szTemp[0] = TEXT('\0');
        dwSize = sizeof(szTemp);
        if (RegQueryValueEx (hKey, TEXT("TMP"), NULL, &dwType,
                             (LPBYTE) szTemp, &dwSize) == ERROR_SUCCESS) {

            if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                               TEXT("%USERPROFILE%"), dwStrLen,
                               szTemp, dwStrLen) == CSTR_EQUAL) {

                ExpandUserEnvironmentStrings (pEnv, szTemp, szExpTemp, ARRAYSIZE(szExpTemp));
                if (!CreateNestedDirectory (szExpTemp, NULL)) {
                    DebugMsg((DM_WARNING, TEXT("PrepareProfileForUse:  Failed to create temp directory with %d."),
                             GetLastError()));
                }
            }
        }

        RegCloseKey (hKey);
    }

    return TRUE;
}



//*************************************************************
//
//  DeleteProfile()
//
//  Purpose:    Deletes the profile
//
//  Parameters:
//
//  Return:     true if successful
//
//  Comments:
//
//  History:    Date        Author     Comment
//              4/12/99     ushaji     Created
//              6/27/00     santanuc   Bug Fix #100787
//
// TBD: Change some of the DeleteProfileEx calls to DeleteProfile
//
//*************************************************************

BOOL
DeleteProfile (LPCTSTR lpSidString, LPCTSTR lpProfilePath, LPCTSTR szComputerName)
{
    LPTSTR lpEnd;
    TCHAR  szBuffer[MAX_PATH], szProfilePath[MAX_PATH];
    LONG   lResult;
    HKEY   hKey = NULL;
    HKEY   hKeyCurrentVersion = NULL;
    HKEY   hKeyNetCache = NULL;
    DWORD  dwType, dwSize;
    BOOL   bSuccess = FALSE;
    DWORD  dwErr = 0;
    HKEY   hKeyLocalLM;
    BOOL   bRemoteReg = FALSE;
    BOOL   bEnvVarsSet = FALSE;
    TCHAR  szOrigSysRoot[MAX_PATH], szOrigSysDrive[MAX_PATH], tDrive;
    TCHAR  szShareName[MAX_PATH], szFileSystemName[MAX_PATH];
    DWORD  MaxCompLen, FileSysFlags;
    TCHAR  szSystemRoot[MAX_PATH], szSystemDrive[MAX_PATH];
    DWORD  dwBufferSize;
    TCHAR  szTemp[MAX_PATH];
    DWORD  dwInternalFlags=0, dwDeleteFlags=0, dwFlags=0;
    LPTSTR szNetComputerName = NULL;
    HMODULE hMsiLib = NULL;
    PFNMSIDELETEUSERDATA pfnMsiDeleteUserData;

    if (!lpSidString) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (szComputerName) {

        if ( !IsUNCPath(szComputerName) ) {

            // Prefixed computer name with slashes if not present
            szNetComputerName = (LPTSTR)LocalAlloc (LPTR, (lstrlen(TEXT("\\\\")) + lstrlen(szComputerName) + 1) * sizeof(TCHAR));

            if (!szNetComputerName) {
                dwErr = GetLastError();
                DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to allocate memory for computer name with %d"),dwErr));
                goto Exit;
            }

            lstrcpy(szNetComputerName, TEXT("\\\\"));
            lstrcat(szNetComputerName, szComputerName);
            szComputerName = szNetComputerName;
        }

        GetEnvironmentVariable(TEXT("SystemRoot"), szOrigSysRoot, MAX_PATH);
        GetEnvironmentVariable(TEXT("SystemDrive"), szOrigSysDrive, MAX_PATH);

        lResult = RegConnectRegistry(szComputerName, HKEY_LOCAL_MACHINE, &hKeyLocalLM);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to open remote registry %d"), lResult));
            dwErr = lResult;
            goto Exit;
        }

        bRemoteReg = TRUE;

        //
        // Get the value of %SystemRoot% and %SystemDrive% relative to the computer
        //

        lResult = RegOpenKeyEx(hKeyLocalLM,
                               TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"),
                               0,
                               KEY_READ,
                               &hKeyCurrentVersion);


        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to open remote registry CurrentVersion %d"), lResult));
            dwErr = lResult;
            goto Exit;
        }

        dwBufferSize = MAX_PATH * sizeof(TCHAR);

        lResult = RegQueryValueEx(hKeyCurrentVersion,
                                  TEXT("SystemRoot"),
                                  NULL,
                                  NULL,
                                  (BYTE *) szTemp,
                                  &dwBufferSize);

        RegCloseKey (hKeyCurrentVersion);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to open remote registry SystemRoot %d"), lResult));
            dwErr = lResult;
            goto Exit;
        }

        szTemp[1] = TEXT('$');

        //
        // These needs to be set if there are additional places below which uses envvars...
        //

        lstrcpy(szSystemRoot, szComputerName); lstrcat(szSystemRoot, TEXT("\\"));
        lstrcpy(szSystemDrive, szComputerName); lstrcat(szSystemDrive, TEXT("\\"));

        lpEnd = szSystemDrive+lstrlen(szSystemDrive);
        lstrcpyn(lpEnd, szTemp, 3);

        lpEnd = szSystemRoot+lstrlen(szSystemRoot);
        lstrcpy(lpEnd, szTemp);

        SetEnvironmentVariable(TEXT("SystemRoot"), szSystemRoot);
        SetEnvironmentVariable(TEXT("SystemDrive"), szSystemDrive);

        bEnvVarsSet = TRUE;

    }
    else {
        hKeyLocalLM = HKEY_LOCAL_MACHINE;
    }


    // 
    // If profile in use then do not delete it
    //

    if (IsProfileInUse(szComputerName, lpSidString)) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Fail to delete profile with sid %s as it is still in use."), lpSidString));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    dwErr = GetLastError();

    //
    // Open the profile mapping
    //

    lstrcpy(szProfilePath, PROFILE_LIST_PATH);
    lpEnd = CheckSlash (szProfilePath);
    lstrcpy(lpEnd, lpSidString);

    lResult = RegOpenKeyEx(hKeyLocalLM, szProfilePath, 0,
                           KEY_READ, &hKey);


    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to open profile mapping key with error %d"), lResult));
        dwErr = lResult;
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx (hKey, PROFILE_FLAGS, NULL, &dwType, (LPBYTE)&dwFlags, &dwSize);
    if (ERROR_SUCCESS == lResult && (dwFlags & PI_HIDEPROFILE)) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Fail to delete profile with sid %s as PI_HIDEPROFILE flag is specifed."), lpSidString));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
        

    if (!lpProfilePath) {

        TCHAR szTemp[MAX_PATH];

        //
        // Get the profile path...
        //

        dwSize = sizeof(szTemp);
        lResult = RegQueryValueEx (hKey,
                                   PROFILE_IMAGE_VALUE_NAME,
                                   NULL,
                                   &dwType,
                                   (LPBYTE) szTemp,
                                   &dwSize);


        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx (hKey, PROFILE_STATE, NULL, &dwType, (LPBYTE)&dwInternalFlags, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to query local profile with error %d"), lResult));
            dwErr = lResult;
            goto Exit;
        }

        if (!ExpandEnvironmentStrings(szTemp, szBuffer, MAX_PATH)) {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to expand %s, error %d"), szTemp, GetLastError()));
            dwErr = lResult;
            goto Exit;
        }

    }
    else {
        lstrcpy(szBuffer, lpProfilePath);
    }

    if (dwInternalFlags & PROFILE_THIS_IS_BAK)
        dwDeleteFlags |= DP_DELBACKUP;

    //
    // Do not fail if for some reason we could not delete the profiledir
    //

    bSuccess = DeleteProfileEx(lpSidString, szBuffer, dwDeleteFlags, hKeyLocalLM, szComputerName);

    if (!bSuccess) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to delete directory, %s with error %d"), szBuffer, dwErr));
    }

    //
    // Delete the user's trash..
    //

    if (szComputerName) {
        lstrcpy (szShareName, szComputerName); lstrcat(szShareName, TEXT("\\"));
        lpEnd = szShareName+lstrlen(szShareName);
        lstrcat(lpEnd, TEXT("A$\\"));
    }
    else {
        lstrcpy(szShareName, TEXT("a:\\"));
        lpEnd = szShareName;
    }


    for (tDrive = TEXT('A'); tDrive <= TEXT('Z'); tDrive++) {
        *lpEnd = tDrive;

        if ((!szComputerName) && (GetDriveType(szShareName) == DRIVE_REMOTE)) {
            DebugMsg((DM_VERBOSE, TEXT("DeleteProfile: Ignoring Drive %s because it is not local"), szShareName));
            continue;
        }


        if (!GetVolumeInformation(szShareName, NULL, 0,
                                NULL, &MaxCompLen, &FileSysFlags,
                                szFileSystemName, MAX_PATH))
            continue;

        if ((szFileSystemName) && (lstrcmp(szFileSystemName, TEXT("NTFS")) == 0)) {
            TCHAR szRecycleBin[MAX_PATH];

            lstrcpy(szRecycleBin, szShareName);
            lstrcat(szRecycleBin, TEXT("Recycler\\"));

            lstrcat(szRecycleBin, lpSidString);

            Delnode(szRecycleBin);

            DebugMsg((DM_VERBOSE, TEXT("DeleteProfile: Deleting trash directory at %s"), szRecycleBin));
        }
    }

    //
    // Queue for csc cleanup..
    //

    if (RegOpenKeyEx(hKeyLocalLM, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\NetCache"), 0,
                     KEY_WRITE, &hKeyNetCache) == ERROR_SUCCESS) {

        HKEY hKeyNextLogOff;

        if (RegCreateKey(hKeyNetCache, TEXT("PurgeAtNextLogoff"), &hKeyNextLogOff) == ERROR_SUCCESS) {

          if (RegSetValueEx(hKeyNextLogOff, lpSidString, 0, REG_SZ, (BYTE *)TEXT(""), sizeof(TCHAR)) == ERROR_SUCCESS) {

                DebugMsg((DM_VERBOSE, TEXT("DeleteProfile: Queued for csc cleanup at next logoff")));
            }
            else {
                DebugMsg((DM_WARNING, TEXT("DeleteProfile: Could not set the Sid Value under NextLogoff key")));
            }

            RegCloseKey(hKeyNextLogOff);
        }
        else {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile: Could not create the PurgeAtNextLogoff key")));
        }

        RegCloseKey(hKeyNetCache);
    }
    else {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile: Could not open the NetCache key")));
    }

    //
    // Delete appmgmt specific stuff..
    //

    if (!ExpandEnvironmentStrings(APPMGMT_DIR_ROOT, szBuffer, MAX_PATH)) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to expand %s, error %d"), APPMGMT_DIR_ROOT, GetLastError()));
        goto Exit;
    }

    //
    // Delete the appmgmt directory
    //

    lpEnd = CheckSlash(szBuffer);
    lstrcpy(lpEnd, lpSidString);

    if (!Delnode(szBuffer)) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to delete the appmgmt dir %s, error %d"), szBuffer, GetLastError()));
    }

    //
    // Reset the environment variables so that api's down the line 
    // do not get confused
    //

    if (bEnvVarsSet) {
        SetEnvironmentVariable(TEXT("SystemRoot"), szOrigSysRoot);
        SetEnvironmentVariable(TEXT("SystemDrive"), szOrigSysDrive);
        bEnvVarsSet = FALSE;
    }

    //
    // Delete msi registry values
    //

    lstrcpy(szBuffer, APPMGMT_REG_MANAGED);
    lpEnd = CheckSlash(szBuffer);
    lstrcpy(lpEnd, lpSidString);

    if (!RegDelnode (hKeyLocalLM, szBuffer)) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to delete the appmgmt key %s"), szBuffer));
    }

    // 
    // Delete rsop data   
    //
  
    if (!RsopDeleteUserNameSpace((LPTSTR)szComputerName, (LPTSTR)lpSidString)) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile: Failed to delete rsop data")));
    }
    
    //
    // Clean Darwin information
    //

    hMsiLib = LoadLibrary(TEXT("msi.dll"));
    if (hMsiLib) {
        pfnMsiDeleteUserData = (PFNMSIDELETEUSERDATA) GetProcAddress(hMsiLib,
#ifdef UNICODE
                                                                     "MsiDeleteUserDataW");
#else
                                                                     "MsiDeleteUserDataA");
#endif

        if (pfnMsiDeleteUserData) {
            (*pfnMsiDeleteUserData)(lpSidString, szComputerName, NULL);
        }
        else {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile: GetProcAddress returned failure. error %d"), GetLastError()));        
        }

        FreeLibrary(hMsiLib);
    }
    else {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile: LoadLibrary returned failure. error %d"), GetLastError()));
    }


Exit:

    if (hKey)
        RegCloseKey(hKey);

    if (bRemoteReg) {
        RegCloseKey(hKeyLocalLM);
    }

    if ( szNetComputerName ) 
        LocalFree(szNetComputerName);

    if (bEnvVarsSet) {
        SetEnvironmentVariable(TEXT("SystemRoot"), szOrigSysRoot);
        SetEnvironmentVariable(TEXT("SystemDrive"), szOrigSysDrive);
    }

    SetLastError(dwErr);

    return bSuccess;
}


//*************************************************************
//
//  SetNtUserIniAttributes()
//
//  Purpose:    Sets system-bit on ntuser.ini
//
//  Parameters:
//
//  Return:     true if successful
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/7/99     ushaji     Created
//
//*************************************************************

BOOL SetNtUserIniAttributes(LPTSTR szDir)
{

    TCHAR szBuffer[MAX_PATH];
    HANDLE hFileNtUser;
    LPTSTR lpEnd;
    DWORD       dwWritten;


    lstrcpy (szBuffer, szDir);
    lpEnd = CheckSlash (szBuffer);
    lstrcpy (lpEnd, c_szNTUserIni);

    //
    // Mark the file with system bit
    //

    hFileNtUser = CreateFile(szBuffer, GENERIC_ALL, 0, NULL, CREATE_NEW,
                           FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, NULL);


    if (INVALID_HANDLE_VALUE == hFileNtUser)
        SetFileAttributes (szBuffer, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
    else {

        //
        // The WritePrivateProfile* functions do not write in unicode
        // unless the file already exists in unicode format. Therefore,
        // Precreate a unicode file so that
        // the WritePrivateProfile* functions can preserve the
        // Make sure that the ini file is unicode by writing spaces into it.
        //

        WriteFile(hFileNtUser, L"\xfeff\r\n", 3 * sizeof(WCHAR), &dwWritten, NULL);
        WriteFile(hFileNtUser, L"     \r\n", 7 * sizeof(WCHAR),
                          &dwWritten, NULL);
        CloseHandle(hFileNtUser);
    }

    return TRUE;
}


//*************************************************************
//
//  CUserProfile::HandleRegKeyLeak
//
//  Purpose:    If registry key leaked, save the hive and call
//              WatchHiveRefCount to get the hive unloaded later
//              when the keys are released.
//
//  Parameters:
//
//      lpSidString             User's sid in string form.
//      lpProfile               User's LPPROFILE structure.
//      bUnloadHiveSucceeded    Indicates that we should save the hive
//                              to a temp file.
//      dwWatchHiveFlags        (in, out) WHRC_ flags.
//      dwCopyTmpHive           (out) CPD_ flag to indicate to
//                              CopyProfileDirectory whether or not a temp
//                              hive file should be used.
//      tszTmpHiveFile          (out) The tmp hive file name.
//                              privilege.
//
//  Return:     Error code to indicate if the hive is successfully saved to
//              a temp file. If yes, return ERROR_SUCCESS. Otherwise, return
//              an error code that indicates why.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/31/00     weiruc     Created
//
//*************************************************************

DWORD CUserProfile::HandleRegKeyLeak(LPTSTR lpSidString,
                                     LPPROFILE lpProfile,
                                     BOOL bUnloadHiveSucceeded,
                                     DWORD* dwWatchHiveFlags,
                                     DWORD* dwCopyTmpHive,
                                     LPTSTR pTmpHiveFile)
{
    HRESULT         hres;
    HKEY            hkCurrentUser = NULL;
    NTSTATUS        status;
    BOOLEAN         WasEnabled;
    DWORD           dwErr = ERROR_SUCCESS;
    TCHAR           szErr[MAX_PATH];
    BOOL            bAdjustPriv = FALSE;
    HANDLE          hToken = NULL;
    LPTSTR          lpUserName;


    if(!bUnloadHiveSucceeded) {
        
        //
        // Reopen the user hive.
        //

        if((dwErr = RegOpenKeyEx(HKEY_USERS,
                                 lpSidString,
                                 0,
                                 KEY_ALL_ACCESS,
                                 &hkCurrentUser)) != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("HandleRegKeyLeak: RegOpenKeyEx failed with %08x"), dwErr));

            if(dwErr == ERROR_FILE_NOT_FOUND) {

                //
                // If ERROR_FILE_NOT_FOUND, then the hive has been unloaded
                // between RegUnloadKey and here. Procceed without calling
                // WatchHiveRefCount.
                //

                DebugMsg((DM_VERBOSE, TEXT("HandleRegKeyLeak: Hive is already unloaded")));
                *dwWatchHiveFlags &= ~WHRC_UNLOAD_HIVE;
                dwErr = ERROR_SUCCESS;
            }
            
            goto NOTIFY_REGISTRY;
        }

        //
        // Make the tmp hive file name: <user profile directory>\ntuser.tmp
        //

        if(lstrlen(lpProfile->lpLocalProfile) + lstrlen(c_szNTUserTmp) + 2 > MAX_PATH) {

            //
            // If the tmp hive file name exceeds MAX_PATH give up.
            //

            dwErr = ERROR_BAD_PATHNAME;
            goto NOTIFY_REGISTRY;
        }

        lstrcpy(pTmpHiveFile, lpProfile->lpLocalProfile);
        lstrcat(pTmpHiveFile, TEXT("\\"));
        lstrcat(pTmpHiveFile, c_szNTUserTmp);

        //
        // Delete existing tmp file if any.
        //

        DeleteFile(pTmpHiveFile);

        //
        // Flush the hive.
        //

        RegFlushKey(hkCurrentUser);

        //
        // Check to see if we are impersonating.
        //

        if(!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken) || hToken == NULL) {
            bAdjustPriv = TRUE;
        }
        else {
            CloseHandle(hToken);
        }

        if(bAdjustPriv) {
            status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, TRUE, FALSE, &WasEnabled);
            if(!NT_SUCCESS(status)) {
                DebugMsg((DM_WARNING, TEXT("HandleRegKeyLeak: RtlAdjustPrivilege failed with error %08x"), status));
                dwErr = ERROR_ACCESS_DENIED;
                goto NOTIFY_REGISTRY;
            }
            DebugMsg((DM_VERBOSE, TEXT("HandleRegKeyLeak: RtlAdjustPrivilege succeeded!")));
        }

        //
        // Save the hive to the tmp file.
        //

        if((dwErr = RegSaveKey(hkCurrentUser, pTmpHiveFile, NULL)) != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("HandleRegKeyLeak: RegSaveKey failed with %08x"), dwErr));
            if (!(lpProfile->dwFlags & PI_LITELOAD)) {

                //
                // Only write event log when not in liteload mode.
                // there are known problems with liteLoad loading because
                // of which eventlog can get full during stress
                //

                ReportError(NULL, PI_NOUI, 1, EVENT_FAILED_HIVE_UNLOAD, GetErrString(dwErr, szErr));
            }
            DeleteFile(pTmpHiveFile);
            goto NOTIFY_REGISTRY;
        }
        
        // 
        // Set the hidden attribute on the temp hive file, so that when it get copied in the 
        // actual hive file it should not reset the hidden attribute
        //
       
        if (!SetFileAttributes(pTmpHiveFile, FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_HIDDEN)) {
            DebugMsg((DM_WARNING, TEXT("HandleRegKeyLeak: Failed to set the hidden attribute on temp hive file with error %d"), GetLastError()));
        }

        *dwCopyTmpHive = CPD_USETMPHIVEFILE;
        
        //
        // Log an event only if we schedule the hive for unloading.
        // If it is already scheduled for unloading (RegUnloadKey returns 
        // ERROR_WRITE_PROTECT in that case) then do not give this message.
        //

        if (*dwWatchHiveFlags & WHRC_UNLOAD_HIVE) {
            lpUserName = GetUserNameFromSid(lpSidString);
            ReportError(NULL, PI_NOUI | EVENT_WARNING_TYPE, 1, EVENT_HIVE_SAVED, lpUserName);
            if (lpUserName != lpSidString) {
                LocalFree(lpUserName);
            }
        }

        DebugMsg((DM_VERBOSE, TEXT("HandleRegKeyLeak: RegSaveKey succeeded!")));
    
        if(bAdjustPriv) {

            //
            // Restore the privilege.
            //

            status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
            if (!NT_SUCCESS(status)) {
                DebugMsg((DM_WARNING, TEXT("HandleRegKeyLeak: Failed to restore RESTORE privilege to previous enabled state %08x"), status));
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("HandleRegKeyLeak: RtlAdjustPrivilege succeeded!")));
            }
        }
    }
    
NOTIFY_REGISTRY:

    if(hkCurrentUser) {
        RegCloseKey(hkCurrentUser);
        DebugMsg((DM_VERBOSE, TEXT("HandleRegKeyLeak: hkCurrentUser closed")));
    }

    if(*dwWatchHiveFlags) {

        //
        // Watch for the hive ref count.
        //

        if((hres = WatchHiveRefCount(lpSidString, *dwWatchHiveFlags)) != S_OK) {
            DebugMsg((DM_WARNING, TEXT("HandleRegKeyLeak: Calling WatchHiveRefCount failed. err = %08x"), hres));
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("HandleRegKeyLeak: Calling WatchHiveRefCount (%s) succeeded"), lpSidString));
        }
    }

    //
    // In UnloadUserProfile, Without this registry leak fix, the code
    // goes to Exit immediately
    // if unloading of the user's hive fails without doing any of the
    // stuff below. But with the fix, we'll fall through here and reconcile
    // the local and the central profiles. The code below also cleans up
    // local profiles, i.e., delete temp profiles, guest user profiles,
    // etc. We have 2 choices here:
    //  1.  We can let the cleaning up happen, in which case files that
    //      are not in use can be cleaned up. This would mean that the
    //      next time when the user logs in, his/her profile will no
    //      longer be loaded, even though his/her hive might still be
    //      loaded. In other words, in TestIfUserProfileLoaded instead
    //      of relying simply on testing whether or not the hive is still
    //      loaded, we have to actually look at the ref count to tell if
    //      a profile is still loaded. In this case the WHRC code will
    //      only need to clean up those files that can not be cleaned up
    //      here.
    //  2.  Do not clean up here. The scenario will remain basically the
    //      same. Next time when the user logs on, his/her profile will
    //      still be loaded, so no change to TestIfUserProfileLoaded. The
    //      WHRC code will handle the complete cleaning up.
    // We implemented choise #2 because it's easier in coding. In the
    // future consider using choice #1.
    //

    return dwErr;
}


//*************************************************************
//
//  AllocAndExpandProfilePath()
//
//  Purpose:    Gets a few predetermined env variables in the profile path
//              expanded
//
//  Parameters:
//              lpProfile
//
//  Return:     true if successful
//
//  Comments:
//
//  Tt gets the environment variables and keeps it locally.
//
//*************************************************************

LPTSTR AllocAndExpandProfilePath(
        LPPROFILEINFO    lpProfileInfo)
{
    TCHAR szUserName[MAX_PATH];
    DWORD dwPathLen=0, cFullPath=0;
    TCHAR szFullPath[MAX_PATH+1];
    LPTSTR pszFullPath=NULL;

    szUserName[0] = TEXT('\0');
    GetEnvironmentVariable (USERNAME_VARIABLE, szUserName, 100);
    SetEnvironmentVariable (USERNAME_VARIABLE, lpProfileInfo->lpUserName);

    //
    // Expand the profile path using current settings
    //

    cFullPath = ExpandEnvironmentStrings(lpProfileInfo->lpProfilePath, szFullPath, MAX_PATH);
    if (cFullPath)
    {
        pszFullPath = (LPTSTR)LocalAlloc(LPTR, (1+ cFullPath) * sizeof(TCHAR));
        if (pszFullPath)
        {
            lstrcpyn( pszFullPath, szFullPath, cFullPath * sizeof(TCHAR));
        }
    }
    else
    {
        pszFullPath = NULL;
    }


    //
    // restore the env block
    //

    if (szUserName[0] != TEXT('\0'))
        SetEnvironmentVariableW (USERNAME_VARIABLE, szUserName);
    else
        SetEnvironmentVariableW (USERNAME_VARIABLE, NULL);

    return(pszFullPath);
}


//*************************************************************
//
//  MAP::MAP()
//
//      Constructor for class MAP.
//
//*************************************************************

MAP::MAP()
{
    for(DWORD i = 0; i < MAXIMUM_WAIT_OBJECTS; i++) {
        rghEvents[i] = NULL;
        rgSids[i] = NULL;
    }
    dwItems = 0;
    pNext = NULL;
}


//*************************************************************
//
//  MAP::Delete
//
//      Delete an work item from a map. Switch the last item into the now
//      empty spot. Caller has to hold the critical section csMap.
//
//  Parameters:
//
//      dwIndex         index into the work list
//
//  Return value:
//
//      None.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

void MAP::Delete(DWORD dwIndex)
{
    //
    // Switch the last work item into the newly finished work item position.
    //

    if(rghEvents[dwIndex]) {
        CloseHandle(rghEvents[dwIndex]);
        rghEvents[dwIndex] = NULL;
    }
    if(rgSids[dwIndex]) {
        LocalFree(rgSids[dwIndex]);
        rgSids[dwIndex] = NULL;
    }
    if(dwIndex < dwItems - 1) {
        rghEvents[dwIndex] = rghEvents[dwItems - 1];
        rgSids[dwIndex] = rgSids[dwItems - 1];
    }
    rgSids[dwItems - 1] = NULL;
    rghEvents[dwItems - 1] = NULL;
    dwItems--;
}


//*************************************************************
//
//  MAP::Insert
//
//      Insert an work item into a map. Caller must hold csMap.
//      the items need to be added before the count is changed
//      because WorkerThreadMain accesses the map without holding
//      a lock.
//
//  Parameters:
//
//      HANDLE          Event to be inserted.
//      LPTSTR          Sid string to be inserted.
//
//  Return value:
//
//      None.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

void MAP::Insert(HANDLE hEvent, LPTSTR ptszSid)
{
    rghEvents[dwItems] = hEvent;
    rgSids[dwItems] = ptszSid;
    dwItems++;
}


//*************************************************************
//
//  MAP::GetSid
//
//      Get a sid by the index; Caller has to hold csMap.
//
//  Parameters:
//
//      dwIndex         index
//
//  Return value:
//
//      The sid.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

LPTSTR MAP::GetSid(DWORD dwIndex)
{
    LPTSTR  ptszTmpSid = rgSids[dwIndex];

    rgSids[dwIndex] = NULL;

    return ptszTmpSid;
}


//*************************************************************
//
//  CHashTable::CHashTable
//
//      CHashTable class initializer.
//
//  Parameters:
//
//  Return value:
//
//      None.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

void CHashTable::Initialize()
{
    for(DWORD i = 0; i < NUM_OF_BUCKETS; i++) {
        Table[i] = NULL;
    }
}


//*************************************************************
//
//  CHashTable::Hash
//
//      Hash a string.
//
//  Parameters:
//
//      pctszString     the string to be hashed
//
//  Return value:
//
//      Hash value.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

DWORD CHashTable::Hash(LPTSTR ptszString)
{
    DWORD       dwHashValue = 0;
    TCHAR*      ptch = ptszString;

    while(*ptch != TEXT('\0')) {
        dwHashValue += *ptch;
        ptch++;
    }

    return dwHashValue % NUM_OF_BUCKETS;
}


//*************************************************************
//
//  CHashTable::IsInTable
//
//      Check to see if a string is already in this hash table. This function
//      is not thread safe. Caller must ensure thread safety when calling this
//      function from multiple threads.
//
//  Parameters:
//
//      ptszString     the string to be checked.
//      ppCSEntry      buffer for the pointer to the CSEntry stored.
//
//  Return value:
//
//      TRUE/FALSE
//
//  History:
//
//      Created         weiruc          5/25/2000
//
//*************************************************************

BOOL CHashTable::IsInTable(LPTSTR ptszString, CSEntry** ppCSEntry)
{
    DWORD       dwHashValue = Hash(ptszString);
    PBUCKET     pbucket;
    PBUCKET     pTmp;

    //
    // Check to see if ptszString is already in the hash table.
    //

    for(pTmp = Table[dwHashValue]; pTmp != NULL; pTmp = pTmp->pNext) {
        if(lstrcmp(pTmp->ptszString, ptszString) == 0) {
            if (ppCSEntry) {
                *ppCSEntry = pTmp->pEntry;
            }
            return TRUE;
        }
    }

    return FALSE;
}
    
    
//*************************************************************
//
//  CHashTable::HashAdd
//
//      Add a string into the hash table. This function doesn't check to see
//      if the string is already in the table. The caller is responsible for
//      calling IsInTable before calling this function. This function
//      is not thread safe. Caller must ensure thread safety when calling this
//      function from multiple threads.
//
//  Parameters:
//
//      ptszString     the string to be added.
//      pCSEntry       the CS entry to be added
//
//  Return value:
//
//      TRUE/FALSE indicating success/failure. The function will fail if
//      the item is already in the hash table, or if we are out of memory.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

BOOL CHashTable::HashAdd(LPTSTR ptszString, CSEntry* pCSEntry)
{
    DWORD       dwHashValue = Hash(ptszString);
    PBUCKET     pbucket;
    PBUCKET     pTmp;


    pbucket = new BUCKET(ptszString, pCSEntry);
    if(pbucket == NULL) {
        DebugMsg((DM_WARNING, TEXT("Can't insert %s. Out of memory"), ptszString));
        return FALSE;
    }
    pbucket->pNext = Table[dwHashValue];
    Table[dwHashValue] = pbucket;

    DebugMsg((DM_VERBOSE, TEXT("CHashTable::HashAdd: %s added in bucket %d"), ptszString, dwHashValue));
    return TRUE;
}


//*************************************************************
//
//  CHashTable::HashDelete
//
//      Delete a string from the hash table. This function
//      is not thread safe. Caller must ensure thread safety when calling this
//      function from multiple threads.
//
//  Parameters:
//
//      ptszString     the string to be deleted.
//
//  Return value:
//
//      none.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

void CHashTable::HashDelete(LPTSTR ptszString)
{
    PBUCKET     pPrev, pCur;
    DWORD       dwHashValue = Hash(ptszString);

    if(Table[dwHashValue] == NULL) {
        return;
    }

    pCur = Table[dwHashValue];
    if(lstrcmp(pCur->ptszString, ptszString) == 0) {
        Table[dwHashValue] = Table[dwHashValue]->pNext;
        pCur->pNext = NULL;
        delete pCur;
        DebugMsg((DM_VERBOSE, TEXT("CHashTable::HashDelete: %s deleted"), ptszString));
        return;
    }
    
    for(pPrev = Table[dwHashValue], pCur = pPrev->pNext; pCur != NULL; pPrev = pCur, pCur = pCur->pNext) {
        if(lstrcmp(pCur->ptszString, ptszString) == 0) {
            pPrev->pNext = pCur->pNext;
            pCur->pNext = NULL;
            DebugMsg((DM_VERBOSE, TEXT("CHashTable::HashDelete: %s deleted"), ptszString));
            delete pCur;
            return;
        }
    }
}


//*************************************************************
//
//  Called by and only by console winlogon process.
//
//*************************************************************

void WINAPI InitializeUserProfile()
{
    cUserProfileManager.Initialize();
}


//*************************************************************
//
//  Called by CreateThread
//
//*************************************************************

DWORD ThreadMain(PMAP pThreadMap)
{
    return cUserProfileManager.WorkerThreadMain(pThreadMap);
}

//*************************************************************
//
// CSyncManager::Initialize()
//
//      Initialize the critical section that protects the CS
//      entries list and the hash table.
//
// Parameters:
//
//      void
//
// Return value:
//
//      TRUE/FALSE to indicate if initialization succeeded or failed.
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

BOOL CSyncManager::Initialize()
{
    BOOL    bRet = TRUE;


    cTable.Initialize();

    //
    // Initialize the critical section that protects the cs entry list.
    //

    __try {
        if(!InitializeCriticalSectionAndSpinCount(&cs, 0x80000000)) {
            DebugMsg((DM_WARNING, TEXT("CSyncManager::Initialize: InitializeCriticalSectionAndSpinCount failed with %08x"), GetLastError()));
            bRet = FALSE;
        }
        
        DebugMsg((DM_VERBOSE, TEXT("CSyncManager::Initialize: critical section initialized")));
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        DebugMsg((DM_WARNING, TEXT("CSyncManager::Initialize: InitializeCriticalSection failed")));
        bRet = FALSE;
    }

    return bRet;
}


//*************************************************************
//
// CSyncManager::EnterLock()
//
//      Get a user's profile lock.
//
// Parameters:
//
//      pSid            - User's sid string
//
// Return value:
//
//      TRUE/FALSE. GetLastError to get error.
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

BOOL CSyncManager::EnterLock(LPTSTR pSid, LPTSTR lpRPCEndPoint)
{
    DWORD       dwError = ERROR_SUCCESS;
    CSEntry*    pEntry = NULL;

    DebugMsg((DM_VERBOSE, TEXT("CSyncManager::EnterLock <%s>"), pSid));

    EnterCriticalSection(&cs);

    //
    // Look up entry in the hash table.
    //

    if(cTable.IsInTable(pSid, &pEntry)) {
        DebugMsg((DM_VERBOSE, TEXT("CSyncManager::EnterLock: Found existing entry")));
    }
    else {

        DebugMsg((DM_VERBOSE, TEXT("CSyncManager::EnterLock: No existing entry found")));

        pEntry = new CSEntry;
        if(!pEntry) {
            dwError = ERROR_OUTOFMEMORY;
            DebugMsg((DM_WARNING, TEXT("CSyncManager::EnterLock: Can't create new CSEntry %08x"), dwError));
            goto Exit;
        }

        if(!pEntry->Initialize(pSid)) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CSyncManager::EnterLock: Can not initialize new entry %08x"), dwError));
            goto Exit;
        }
        DebugMsg((DM_VERBOSE, TEXT("CSyncManager::EnterLock: New entry created")));
    
        //
        // Insert the new entry in the list.
        //

        pEntry->pNext = pCSList;
        pCSList = pEntry;

        //
        // Add the new entry into the hash table.
        //

        cTable.HashAdd(pEntry->pSid, pEntry);
    }

    pEntry->IncrementRefCount();
    LeaveCriticalSection(&cs);
    pEntry->EnterCS();
    pEntry->SetRPCEndPoint(lpRPCEndPoint);
    return TRUE;

Exit:

    LeaveCriticalSection(&cs);

    if(pEntry) {
        delete pEntry;
    }

    SetLastError(dwError);
    return FALSE;
}


//*************************************************************
//
// CSyncManager::LeaveLock()
//
//      Release a user's profile lock
//
// Parameters:
//
//      pSid    -   The user's sid string
//
// Return value:
//
//      TRUE/FALSE
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

BOOL CSyncManager::LeaveLock(LPTSTR pSid)
{
    BOOL        bRet = FALSE;
    DWORD       dwError = ERROR_SUCCESS;
    CSEntry*    pPrev;
    CSEntry*    pCur;
    CSEntry*    pToBeDeleted;


    DebugMsg((DM_VERBOSE, TEXT("CSyncManager::LeaveLock <%s>"), pSid));
        
    EnterCriticalSection(&cs);

    //
    // Look up the critical section entry.
    //

    if(!cTable.IsInTable(pSid, &pCur)) {
        DebugMsg((DM_WARNING, TEXT("CSyncManager::LeaveLock: User not found!!!!")));
        dwError = ERROR_NOT_FOUND;
        goto Exit;
    }

    pCur->LeaveCS();
    bRet = TRUE;
    DebugMsg((DM_VERBOSE, TEXT("CSyncManager::LeaveLock: Lock released")));

    //
    // If there's more user waiting for this lock, return.
    //

    if(!pCur->NoMoreUser()) {
        goto Exit;
    }

    //
    // Nobody is waiting on this lock anymore, delete it from the hash table.
    //

    cTable.HashDelete(pSid);

    //
    // Delete from the cs list.
    //

    pToBeDeleted = pCur;
    if(pCur == pCSList) {

        //
        // Entry is the first one in the list.
        //

        pCSList = pCSList->pNext;
        pCur->Uninitialize();
        delete pCur;
        DebugMsg((DM_VERBOSE, TEXT("CSyncManager::LeaveLock: Lock deleted")));
    } else {
        for(pPrev = pCSList, pCur = pCSList->pNext; pCur; pPrev = pCur, pCur = pCur->pNext) {
            if(pCur == pToBeDeleted) {
                pPrev->pNext = pCur->pNext;
                pCur->Uninitialize();
                delete pCur;
                DebugMsg((DM_VERBOSE, TEXT("CSyncManager::DestroyCSEntry: Entry deleted")));
                goto Exit;
            }
        }
    }

Exit:

    LeaveCriticalSection(&cs);

    SetLastError(dwError);
    return bRet;
}

//*************************************************************
//
//  CSyncManager::GetRPCEndPoint()
//
//  Purpose:  returns the RPCEndPoint registered by client     
//
//  Parameters:
//
//      pSid    - User's sid string
//
//  Return:
//
//      LPTSTR 
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/25/00    santanuc   Created
//
//*************************************************************

LPTSTR CSyncManager::GetRPCEndPoint(LPTSTR pSid)
{
    CSEntry*    pEntry = NULL;
    LPTSTR      lpRPCEndPoint;

    EnterCriticalSection(&cs);

    //
    // Look up entry in the hash table.
    //

    if(cTable.IsInTable(pSid, &pEntry)) {
       lpRPCEndPoint = pEntry->GetRPCEndPoint();
    }
    else {
       lpRPCEndPoint = NULL;
    }

    LeaveCriticalSection(&cs);
    return lpRPCEndPoint;
}

//*************************************************************
//
// CSEntry::Initialize()
//
//      Initialize the user's critical section. This function can
//      only be called by the sync manager.
//
// Parameters:
//
//      pSid    -   The user's sid string
//
// Return value:
//
//      TRUE/FALSE
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

BOOL CSEntry::Initialize(LPTSTR pSidParam)
{
    BOOL    bRet = FALSE;
    DWORD   dwError = ERROR_SUCCESS;


    pSid = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pSidParam) + 1) * sizeof(TCHAR));
    if(!pSid) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CSEntry::Initialize: LocalAlloc failed with %08x"), dwError));
        goto Exit;
    }
    lstrcpy(pSid, pSidParam);

    __try {
        if(!InitializeCriticalSectionAndSpinCount(&csUser, 0x80000000)) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CSEntry::Initialize: InitializeCriticalSectionAndSpinCount failed with %08x"), dwError));
        }
        else {
            bRet = TRUE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = GetExceptionCode();
        DebugMsg((DM_WARNING, TEXT("CSEntry::Initialize: InitializeCriticalSectionAndSpinCount exception %08x"), dwError));
    }

Exit:

    SetLastError(dwError);
    return bRet;
}


//*************************************************************
//
// CSEntry::Uninitialize()
//
//      Delete the user's critical section. This function can
//      only be called by the sync manager.
//
// Parameters:
//
//      void.
//
// Return value:
//
//      void
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

void CSEntry::Uninitialize()
{
    DeleteCriticalSection(&csUser);
    if (pSid) {
        LocalFree(pSid);
    }
}


//*************************************************************
//
// CSEntry::EnterCS()
//
//      Enter a user's critical section
//
// Parameters:
//
//      void.
//
// Return value:
//
//      void
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

void CSEntry::EnterCS()
{
    EnterCriticalSection(&csUser);
}


//*************************************************************
//
// CSEntry::LeaveCS()
//
//      Leave a user's critical section
//
// Parameters:
//
//      void.
//
// Return value:
//
//      void
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

void CSEntry::LeaveCS()
{
    dwRef--;
    LeaveCriticalSection(&csUser);
}


//*************************************************************
//
// CSEntry::NoMoreUser()
//
//      Are there more users?
//
// Parameters:
//
//      void
//
// Return value:
//
//      TRUE/FALSE
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

BOOL CSEntry::NoMoreUser()
{
    return dwRef == 0;
}

//*************************************************************
//
// CSEntry::IncrementRefCount()
//
//      Increment the reference count.
//
// Parameters:
//
//      void
//
// Return value:
//
//      void
//
// History:
//
//      8/24/00     santanuc      Created
//
//*************************************************************

void CSEntry::IncrementRefCount()
{
    dwRef++;
}

//*************************************************************
//
// CSEntry::SetRPCEndPoint()
//
//      Store the RPCEndPoint. Memory freed by the ~CSEntry
//      
// Parameters:
//
//      lpRPCEndPoint
//
// Return value:
//
//      void
//
// History:
//
//      8/24/00     santanuc      Created
//
//*************************************************************

void CSEntry::SetRPCEndPoint(LPTSTR lpRPCEndPoint)
{
   if (lpRPCEndPoint) {
       szRPCEndPoint = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lpRPCEndPoint)+1)*sizeof(TCHAR));
       if (szRPCEndPoint) {
           lstrcpy(szRPCEndPoint, lpRPCEndPoint);
       }
   }
}

//*************************************************************
//
// EnterUserProfileLock()
//
//      Get the user profile lock for a user
//
// Parameters:
//
//      pSid        -   The user's sid string
//
// Return value:
//
//      HRESULT
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

DWORD WINAPI EnterUserProfileLock(LPTSTR pSid)
{
    CSEntry*       pEntry = NULL;
    DWORD          dwErr = ERROR_ACCESS_DENIED;
    handle_t       hIfUserProfile;
    BOOL           bBindInterface = FALSE;
    
    if(cUserProfileManager.IsConsoleWinlogon()) {
        if(!cUserProfileManager.EnterUserProfileLockLocal(pSid)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("EnterUserProfileLock: GetUserProfileMutex returned %d"), dwErr));
            goto Exit;
        }
    }
    else {
        if (!GetInterface(&hIfUserProfile, cszRPCEndPoint)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("EnterUserProfileLock: GetInterface returned %d"), dwErr));
            goto Exit;
        }
        bBindInterface = TRUE;

        RpcTryExcept {
            dwErr = cliEnterUserProfileLockRemote(hIfUserProfile, pSid);
        }
        RpcExcept(1) {
            dwErr = RpcExceptionCode();
            DebugMsg((DM_WARNING, TEXT("EnterUserProfileLock: EnterUserProfileLockRemote took exception error %d"), dwErr));
        }
        RpcEndExcept

        if (dwErr != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("EnterUserProfileLock: EnterUserProfileLockRemote returned error %d"), dwErr));
            goto Exit;
        }
    }
    
    dwErr = ERROR_SUCCESS;

Exit:

   if (bBindInterface) {
       if (!ReleaseInterface(&hIfUserProfile)) {
           DebugMsg((DM_WARNING, TEXT("EnterUserProfileLock: ReleaseInterface failed.")));
       }
    }

    //
    // Return.
    //

    SetLastError(dwErr);
    return dwErr;
}


//*************************************************************
//
// LeaveUserProfileLock()
//
//      Leave the user profile lock
//
// Parameters:
//
//      pSid        -   The user's sid string
//
// Return value:
//
//      HRESULT
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

DWORD WINAPI LeaveUserProfileLock(LPTSTR pSid)
{
    CSEntry*       pEntry = NULL;
    DWORD          dwErr = ERROR_ACCESS_DENIED;
    handle_t       hIfUserProfile;
    BOOL           bBindInterface = FALSE;
    
    if(cUserProfileManager.IsConsoleWinlogon()) {
        cUserProfileManager.LeaveUserProfileLockLocal(pSid);
    }
    else {
        if (!GetInterface(&hIfUserProfile, cszRPCEndPoint)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LeaveUserProfileLock: GetInterface returned %d"), dwErr));
            goto Exit;
        }
        bBindInterface = TRUE;

        RpcTryExcept {
            dwErr = cliLeaveUserProfileLockRemote(hIfUserProfile, pSid);
        }
        RpcExcept(1) {
            dwErr = RpcExceptionCode();
            DebugMsg((DM_WARNING, TEXT("LeaveUserProfileLock: LeaveUserProfileLockRemote took exception error %d"), dwErr));
        }
        RpcEndExcept

        if (dwErr != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("LeaveUserProfileLock: LeaveUserProfileLockRemote returned error %d"), dwErr));
            goto Exit;
        }

   }

   dwErr = ERROR_SUCCESS;

Exit:

    if (bBindInterface) {
        if (!ReleaseInterface(&hIfUserProfile)) {
            DebugMsg((DM_WARNING, TEXT("LeaveUserProfileLock: ReleaseInterface failed.")));
        }
    }

    //
    // Return.
    //

    SetLastError(dwErr);
    return dwErr;
}

//*************************************************************
//
//  IsProfileInUse()
//
//  Purpose:    Determines if the given profile is currently in use
//
//  Parameters: szComputer - Name of the machine
//              lpSid      - Sid (text) to test
//
//  Return:     TRUE if in use
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/28/00     santanuc   Created
//
//*************************************************************

BOOL IsProfileInUse (LPCTSTR szComputer, LPCTSTR lpSid)
{
    LONG lResult;    
    HKEY hKeyUsers, hKeyProfile;
    BOOL bRemoteReg = FALSE;
    BOOL bRetVal = FALSE;

    if (szComputer) {
        lResult = RegConnectRegistry(szComputer, HKEY_USERS, &hKeyUsers);
        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("IsProfileInUse:  Failed to open remote registry %d"), lResult));
            return TRUE;
        }

        bRemoteReg = TRUE;
    }
    else {
        hKeyUsers = HKEY_USERS;
    }

    if (RegOpenKeyEx (hKeyUsers, lpSid, 0, KEY_READ, &hKeyProfile) == ERROR_SUCCESS) {
        RegCloseKey (hKeyProfile);
        bRetVal = TRUE;
    }
    else {
        LPTSTR lpSidClasses;

        lpSidClasses = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lpSid)+lstrlen(TEXT("_Classes"))+1)*sizeof(TCHAR));
        if (lpSidClasses) {
            lstrcpy(lpSidClasses, lpSid);
            lstrcat(lpSidClasses, TEXT("_Classes"));
            if (RegOpenKeyEx (hKeyUsers, lpSidClasses, 0, KEY_READ, &hKeyProfile) == ERROR_SUCCESS) {
                RegCloseKey (hKeyProfile);
                bRetVal = TRUE;
            }
            LocalFree(lpSidClasses);
        }
    }

    if (bRemoteReg) {
        RegCloseKey(hKeyUsers);
    }

    return bRetVal;
}

//*************************************************************
//
//  IsUIRequired()
//
//  Purpose:    Determines if the profile error message requires
//              If the ref count is > 1 then we do not required
//              error reporting. If ref count is 1 then we check
//              
//
//  Parameters: hToken - User's token
//
//  Return:     TRUE if error message req
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/27/00    santanuc   Created
//
//*************************************************************
BOOL IsUIRequired(HANDLE hToken)
{
    LPTSTR   lpSidString = GetSidString(hToken);
    BOOL     bRetVal = FALSE;
    TCHAR    szBuffer[MAX_PATH];
    LPTSTR   lpEnd;
    HKEY     hKeyProfile;
    DWORD    dwType, dwFlags, dwRef, dwSize;

    if (lpSidString) {
        lstrcpy(szBuffer, PROFILE_LIST_PATH);
        lpEnd = CheckSlash (szBuffer);
        lstrcpy(lpEnd, lpSidString);

        if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ, &hKeyProfile) == ERROR_SUCCESS) {

            dwSize = sizeof(DWORD);
            if (RegQueryValueEx (hKeyProfile,
                                 PROFILE_REF_COUNT,
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &dwRef,
                                 &dwSize) == ERROR_SUCCESS) {
                if (dwRef == 1) {
                    
                    dwSize = sizeof(DWORD);
                    if (RegQueryValueEx (hKeyProfile,
                                         PROFILE_FLAGS,
                                         NULL,
                                         &dwType,
                                         (LPBYTE) &dwFlags,
                                         &dwSize) == ERROR_SUCCESS) {
                        if (!(dwFlags & (PI_NOUI | PI_LITELOAD))) {
                            bRetVal = TRUE;
                        }
                    }
                    else {
                        DebugMsg((DM_WARNING, TEXT("IsUIRequired: Failed to query value for flags.")));
                    }
                }

            }
            else {
                DebugMsg((DM_WARNING, TEXT("IsUIRequired: Failed to query value for ref count.")));
            }

            RegCloseKey(hKeyProfile);
        }
        else {
            DebugMsg((DM_WARNING, TEXT("IsUIRequired:  Failed to open key %s"), szBuffer));
        }

        DeleteSidString(lpSidString);
    }

    return bRetVal;
}

//*************************************************************
//
//  CheckRUPShare()
//
//  Purpose:    Determines if the RUP share is CSCed, if it is 
//              then issue an event log warning.
//
//  Parameters: lpProfilePath - User's roaming profile path
//
//  Return:     None
//
//  Comments:
//
//*************************************************************
void CheckRUPShare(LPTSTR lpProfilePath)
{
    LPTSTR lpServer, lpShare, lpCopy;
    PSHARE_INFO_1005 pBufPtr1, pBufPtr2;
    BOOL bIssueWarning = FALSE;
    
    if (!lpProfilePath || !IsUNCPath(lpProfilePath)) {
        return;
    }

    lpCopy = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lpProfilePath)+1) * sizeof(TCHAR));
    if (!lpCopy) {
        DebugMsg((DM_WARNING, TEXT("CheckRUPShare: Failed to allocate memory")));
        return;
    }

    lstrcpy(lpCopy, lpProfilePath);
    ConvertToShareName(lpCopy);
    lpServer = lpCopy;
    lpShare = lpCopy+2;  // Skip initial two slashes
    while (*lpShare != TCHAR('\\') && *lpShare != TCHAR('\0')) 
        lpShare++;

    if (*lpShare == TCHAR('\\')) {
        *lpShare = TCHAR('\0');
        lpShare++;
    
        if (NetShareGetInfo(lpServer, lpShare, 1005,
                            (LPBYTE *)&pBufPtr1) == ERROR_SUCCESS) {
            if ((pBufPtr1->shi1005_flags & CSC_MASK) == CSC_CACHE_NONE) {
                bIssueWarning = FALSE;
            }
            else if (pBufPtr1->shi1005_flags & SHI1005_FLAGS_DFS_ROOT) {

                //
                // If share is DFS root then we need to check the DfsLink to see 
                // whether csc is disabled on it
                //

                // Construct the dfs link 

                lstrcpy(lpCopy, lpProfilePath);
                int iDfsLink = 0;
                lpServer = lpCopy;
                lpShare = lpCopy+2;  // Skip initial two slashes
                while ((iDfsLink < 3) && *lpShare != TCHAR('\0')) {
                    if (*lpShare == TCHAR('\\')) {
                        iDfsLink++;
                    }
                    lpShare++;
                }
                if (*lpShare != TCHAR('\0')) {
                    *(lpShare-1) = TCHAR('\0');
                }
                if (iDfsLink >= 2) {
                    PDFS_INFO_3 pDfsBuf;

                    // Query for the actual server and share

                    if (NetDfsGetInfo(lpServer, NULL, NULL, 3, 
                                      (LPBYTE *)&pDfsBuf) == NERR_Success) {
                        if (pDfsBuf->NumberOfStorages >= 1) {
                            lpServer = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pDfsBuf->Storage->ServerName)+3) * sizeof(WCHAR));
                            if (!lpServer) {
                                DebugMsg((DM_WARNING, TEXT("CheckRUPShare: Failed to allocate memory")));
                                goto Exit;
                            }
                            lstrcpy(lpServer, TEXT("\\\\"));
                            lstrcat(lpServer, pDfsBuf->Storage->ServerName);

                            // Get csc information from actual server and share 

                            if (NetShareGetInfo(lpServer, pDfsBuf->Storage->ShareName, 1005,
                                                (LPBYTE *)&pBufPtr2) == ERROR_SUCCESS) {
                                if ((pBufPtr2->shi1005_flags & CSC_MASK) == CSC_CACHE_NONE) {
                                    bIssueWarning = FALSE;
                                }
                                else {
                                    bIssueWarning = TRUE;
                                }
                                NetApiBufferFree(pBufPtr2);
                            }
                            LocalFree(lpServer);
                        }
                        NetApiBufferFree(pDfsBuf);
                    }
                }
            }
            else {
                bIssueWarning = TRUE;
            }
            NetApiBufferFree(pBufPtr1);

            if (bIssueWarning) {
                ReportError(NULL, PI_NOUI | EVENT_WARNING_TYPE, 0, EVENT_CSC_ON_PROFILE_SHARE);
            }
        }
    }

Exit:
    LocalFree(lpCopy);

}

//*************************************************************
//
//  IsPartialRoamingProfile()
//
//  Purpose:    determines if roaming profile contains a partial 
//              copy or not. This is indicated by setting a flag
//              in ntuser.ini.
//
//  Parameters: lpProfile - User's profile 
//
//  Return:     TRUE : If Roaming profile contains a Partial 
//                     profile due to LITE_LOAD unload.
//              FALSE: otherwise.
//
//  Comments:
//
//*************************************************************
BOOL IsPartialRoamingProfile(LPPROFILE lpProfile)
{
    TCHAR  szLastUploadState[20];
    LPTSTR szNTUserIni = NULL;
    LPTSTR lpEnd;
    BOOL   bRetVal = FALSE;

    // 
    // Allocate memory for Local variables to avoid stack overflow
    //

    szNTUserIni = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szNTUserIni) {
        DebugMsg((DM_WARNING, TEXT("IsPartialRoamingProfile: Out of memory")));
        goto Exit;
    }

    lstrcpy (szNTUserIni, lpProfile->lpRoamingProfile);
    lpEnd = CheckSlash (szNTUserIni);
    lstrcpy (lpEnd, c_szNTUserIni);

    GetPrivateProfileString (PROFILE_LOAD_TYPE,
                             PROFILE_LAST_UPLOAD_STATE,
                             COMPLETE_PROFILE, szLastUploadState,
                             ARRAYSIZE(szLastUploadState),
                             szNTUserIni);

    if (lstrcmpi(szLastUploadState, PARTIAL_PROFILE) == 0) {
        bRetVal = TRUE;
    }

Exit:

    if (szNTUserIni) 
        LocalFree(szNTUserIni);

    return bRetVal;
}


//*************************************************************
//
//  TouchLocalHive()
//
//  Purpose:  Check whether in local machine user profile is 
//            switching from local to roaming for first time. If 
//            yes and we have a existing hive in RUP share then 
//            always overwrite the local hive with hive in RUP 
//            share. This is to avoid wrong hive usage due to 
//            cached login.
//
//
//  Parameters: lpProfile - User's profile 
//
//  Return:     None
//
//  Comments:
//
//*************************************************************
void TouchLocalHive(LPPROFILE lpProfile)
{
    LPTSTR   szBuffer = NULL, lpEnd;
    LPTSTR   SidString = NULL;
    HKEY     hKey = NULL;
    HANDLE   hFile = NULL;
    DWORD    dwSize, dwType;
    LONG     lResult;
    const LONGLONG datetime1980 = 0x01A8E79FE1D58000;  // 1/1/80, origin of DOS datetime
    union {
        FILETIME ft;
        LONGLONG datetime;
    };

    if ((lpProfile->dwInternalFlags & PROFILE_NEW_CENTRAL) ||
        (lpProfile->dwInternalFlags & PROFILE_MANDATORY)) {
        goto Exit;
    }

    //
    // Set the time to base
    //

    datetime = datetime1980;

    //
    // Allocate local buffer
    //

    szBuffer = (LPTSTR) LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szBuffer) {
        DebugMsg((DM_WARNING, TEXT("TouchLocalHive: Out of memory")));
        goto Exit;
    }

    //
    // Get the Sid string for the user
    //

    SidString = GetSidString(lpProfile->hTokenUser);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("TouchLocalHive: Failed to get sid string for user")));
        goto Exit;
    }

    //
    // Open the profile mapping
    //

    lstrcpy(szBuffer, PROFILE_LIST_PATH);
    lpEnd = CheckSlash (szBuffer);
    lstrcpy(lpEnd, SidString);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0,
                           KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("TouchLocalHive: Failed to open profile mapping key with error %d"), lResult));
        goto Exit;
    }

    //
    // Query for the central profile path
    //

    dwSize = MAX_PATH * sizeof(TCHAR);
    lResult = RegQueryValueEx (hKey,
                               PROFILE_CENTRAL_PROFILE,
                               NULL,
                               &dwType,
                               (LPBYTE) szBuffer,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("TouchLocalHive: Failed to query central profile with error %d"), lResult));
        goto Exit;
    }

    if (szBuffer[0] == TEXT('\0')) {
 
        //
        // So we are switching from local to roaming profile for first time
        //
        
        //
        // Make sure we don't overrun our temporary buffer
        //

        if ((lstrlen(lpProfile->lpLocalProfile) + 1 + lstrlen(c_szNTUserDat) + 1) > MAX_PATH) {
            DebugMsg((DM_VERBOSE, TEXT("TouchLocalHive: Failed because temporary buffer is too small.")));
            goto Exit;
        }


        //
        // Copy the local profile path to a temporary buffer
        // we can munge it.
        //

        lstrcpy (szBuffer, lpProfile->lpLocalProfile);


        //
        // Add the slash if appropriate and then tack on
        // ntuser.dat.
        //

        lpEnd = CheckSlash(szBuffer);
        lstrcpy(lpEnd, c_szNTUserDat);

        //
        // See if this file exists
        //

        DebugMsg((DM_VERBOSE, TEXT("TouchLocalHive: Testing <%s>"), szBuffer));

        hFile = CreateFile(szBuffer, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);


        if (hFile != INVALID_HANDLE_VALUE) {
            DebugMsg((DM_VERBOSE, TEXT("TouchLocalHive: Found a user hive.")));

            //
            // Set the local hive time to base i.e 1/1/1980, so that RUP hive 
            // overwrites this hive during profile merge
            //

            if (SetFileTime(hFile, NULL, NULL, &ft)) {
                DebugMsg((DM_VERBOSE, TEXT("TouchLocalHive: Touched user hive.")));
            }
            else {
                DebugMsg((DM_WARNING, TEXT("TouchLocalHive: Fail to touch user hive.")));
            }
            CloseHandle(hFile);
        }
    }


Exit:

    if (szBuffer) {
        LocalFree(szBuffer);
    }

    if (SidString) {
        DeleteSidString(SidString);
    }

    if (hKey) {
        RegCloseKey(hKey);
    }
}        
    


//*************************************************************
//
//  RegisterDialogInterface()
//
//  Purpose:    Registers IProfileDialog interface
//
//  Parameters: szRPCEndPoint - RPCEndPoint name
//
//  Return:     TRUE if successfully registered
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/27/00    santanuc   Created
//
//*************************************************************
BOOL RegisterDialogInterface(LPTSTR szRPCEndPoint)
{
    RPC_STATUS  status = RPC_S_OK;
    
    //
    // Specify to use the local rpc protocol sequence 
    //

    status = RpcServerUseProtseqEp(cszRPCProtocol,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,  
                                   szRPCEndPoint,
                                   NULL);                           // Security descriptor
    if (status != RPC_S_OK && status != RPC_S_DUPLICATE_ENDPOINT) {
        DebugMsg((DM_WARNING, TEXT("RegisterErrorDialogInterface: RpcServerUseProtseqEp fails with error %ld"), status));
        goto Exit;
    }
 
    //
    // Register the IUserProfile interface
    //

    status = RpcServerRegisterIfEx(IProfileDialog_v1_0_s_ifspec,      // interface to register
                                   NULL,                              // MgrTypeUuid
                                   NULL,                              // MgrEpv; null means use default
                                   RPC_IF_AUTOLISTEN,                 // auto-listen interface
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,    // max concurrent calls
                                   NULL);                             // no callback
    if (status != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("RegisterErrorDialogInterface: RpcServerRegisterIfEx fails with error %ld"), status));
    }

Exit:

    return (status == RPC_S_OK);
}

//*************************************************************
//
//  UnRegisterDialogInterface()
//
//  Purpose:    UnRegisters IProfileDialog interface
//
//  Parameters: 
//
//  Return:     TRUE if successfully unregistered
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/27/00    santanuc   Created
//
//*************************************************************
BOOL UnRegisterDialogInterface(void)
{
    RPC_STATUS status = RPC_S_OK;

    // unregister the server endpoint
    status = RpcServerUnregisterIf(IProfileDialog_v1_0_s_ifspec, NULL, TRUE);
    if (status != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("UnRegisterErrorDialogInterface: RpcServerUnregisterIf fails with error %ld"), status));
    }
    return (status == RPC_S_OK);
}

//*************************************************************
//
//  ErrorDialog()
//
//  Purpose:    ErrorDialog api of IProfileDialog interface
//              Display error message on client's desktop
//
//  Parameters: 
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/27/00    santanuc   Created
//
//*************************************************************
void ErrorDialog(IN PRPC_ASYNC_STATE pAsync, IN handle_t hBindHandle, IN DWORD dwTimeOut, IN LPTSTR lpErrMsg)
{
    DWORD dwRetVal = ERROR_SUCCESS;

    ErrorDialogEx(dwTimeOut, lpErrMsg);
    RpcAsyncCompleteCall(pAsync, (PVOID)&dwRetVal);
}

//*************************************************************
//
//  SlowLinkDialog()
//
//  Purpose:    SlowLinkDialog api of IProfileDialog interface
//              Display SlowLink message on client's desktop
//
//  Parameters: 
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/27/00    santanuc   Created
//
//*************************************************************
void SlowLinkDialog(IN PRPC_ASYNC_STATE pAsync, IN handle_t hBindHandle, IN DWORD dwTimeOut, IN BOOL bDefault, OUT BOOL *bpResponse, IN BOOL bDlgLogin)
{
    SLOWLINKDLGINFO info;
    DWORD dwRetVal = ERROR_SUCCESS;

    info.dwTimeout = dwTimeOut;
    info.bSyncDefault = bDefault;
  
    DebugMsg((DM_VERBOSE, TEXT("SlowLinkDialog: Calling DialogBoxParam")));
    if (bDlgLogin) {
        *bpResponse = (BOOL)DialogBoxParam (g_hDllInstance, MAKEINTRESOURCE(IDD_LOGIN_SLOW_LINK),
                                            NULL, LoginSlowLinkDlgProc, (LPARAM)&info);
    }
    else {
        *bpResponse = (BOOL)DialogBoxParam (g_hDllInstance, MAKEINTRESOURCE(IDD_LOGOFF_SLOW_LINK),
                                            NULL, LogoffSlowLinkDlgProc, (LPARAM)&info);
    }
    RpcAsyncCompleteCall(pAsync, (PVOID)&dwRetVal);
}

//
// RPC routines
//

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t count)
{
    DebugMsg((DM_VERBOSE, TEXT("MIDL_user_allocate enter")));
    return(malloc(count));
}

void __RPC_USER MIDL_user_free(void __RPC_FAR * p)
{
    DebugMsg((DM_VERBOSE, TEXT("MIDL_user_free enter")));
    free(p);
}

void __RPC_USER PCONTEXT_HANDLE_rundown (PCONTEXT_HANDLE phContext)
{
    DebugMsg((DM_VERBOSE, TEXT("PCONTEXT_HANDLE_rundown : Client died with open context")));
    ReleaseClientContext_s(&phContext);
}

//******************************************************************************
//
//  CheckRoamingShareOwnership()
//
//  Purpose:    Check the ownership of the roaming user's profile on the server.
//              If the owner is not the user or not an admin, this function will
//              fail, and an error message will be issued. Administrator can set
//              a policy "CompatibleRUPSecurity" to disable this check.
//
//  Parameters: 
//              lpDir      - profile directory on the server
//              hTokenUser - user's token
//
//  Return:     S_OK on success, else for failure
//
//  Comments:
//
//  History:    Date        Author     Comment
//              03/21/2002  mingzhu    Created
//
//******************************************************************************

HRESULT CheckRoamingShareOwnership(LPTSTR lpDir, HANDLE hTokenUser)
{
    HRESULT hr = E_FAIL;
    BOOL    bDisableCheck = FALSE;
    HKEY    hSubKey = NULL;
    DWORD   dwRegValue;
    DWORD   dwSize;
    DWORD   dwType;
    DWORD   cbSD;
    BOOL    bDefaultOwner;
    DWORD   dwErr;
    PSID    pSidAdmin = NULL;
    PSID    pSidUser = NULL;
    PSID    pSidOwner = NULL;
    
    PSECURITY_DESCRIPTOR        psd = NULL;
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;

    //
    //  Output a debug message for entering the function.
    //
    
    DebugMsg((DM_VERBOSE, TEXT("CheckRoamingShareOwnership: checking ownership for %s"), lpDir));

    //
    // Check for the policy to see if this check has been disabled
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwRegValue);
        if (RegQueryValueEx(hSubKey, TEXT("CompatibleRUPSecurity"), NULL, &dwType, (LPBYTE) &dwRegValue, &dwSize) == ERROR_SUCCESS)
        {
            bDisableCheck = (BOOL)(dwRegValue);   
        }
        RegCloseKey(hSubKey);
    }

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwRegValue);
        if (RegQueryValueEx(hSubKey, TEXT("CompatibleRUPSecurity"), NULL, &dwType, (LPBYTE) &dwRegValue, &dwSize) == ERROR_SUCCESS)
        {
            bDisableCheck = (BOOL)(dwRegValue);   
        }
        RegCloseKey(hSubKey);
    }

    if (bDisableCheck)
    {
         DebugMsg((DM_VERBOSE, TEXT("CheckRoamingShareOwnership: policy set to disable ownership check")));
         hr = S_OK;
         goto Exit;
    }

    //
    //  Get the security of the directory, should fail with  ERROR_INSUFFICIENT_BUFFER
    //
    
    GetFileSecurity(lpDir, OWNER_SECURITY_INFORMATION, NULL, 0, &cbSD);

    dwErr = GetLastError();
    if (dwErr != ERROR_INSUFFICIENT_BUFFER)
    {
        DebugMsg((DM_WARNING, TEXT("CheckRoamingShareOwnership : GetFileSecurity failed with %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    //
    //  Allocate memory for SD
    //
    psd = (PSECURITY_DESCRIPTOR) LocalAlloc (LPTR, cbSD);
    if (!psd)
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckRoamingShareOwnership : LocalAlloc failed with %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    //
    //  Try it again
    //
    if (!GetFileSecurity(lpDir, OWNER_SECURITY_INFORMATION, psd, cbSD, &cbSD))
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckRoamingShareOwnership : GetFileSecurity failed with %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    //
    // Get the owner in SD 
    //

    if (!GetSecurityDescriptorOwner(psd, &pSidOwner, &bDefaultOwner))
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckRoamingShareOwnership: Failed to get security descriptor owner.  Error = %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0, &pSidAdmin))
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckRoamingShareOwnership: Failed to initialize admin sid.  Error = %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    //
    // Get the user sid
    //

    pSidUser = GetUserSid(hTokenUser);
    if (pSidUser == NULL)
    {
        DebugMsg((DM_WARNING, TEXT("CheckRoamingShareOwnership: GetUserSid returned NULL")));
        hr = E_FAIL; 
        goto Exit;
    }

    //
    // Check the owner
    //
    if (EqualSid(pSidAdmin, pSidOwner))
    {
        DebugMsg((DM_VERBOSE, TEXT("CheckRoamingShareOwnership: owner is admin")));
        hr = S_OK;
    }
    else if (EqualSid(pSidUser, pSidOwner))
    {
        DebugMsg((DM_VERBOSE, TEXT("CheckRoamingShareOwnership: owner is the right user")));
        hr = S_OK;
    }
    else
    {
        LPTSTR  lpSidOwner = NULL;
        if (ConvertSidToStringSid(pSidOwner, &lpSidOwner))
        {
            DebugMsg((DM_WARNING, TEXT("CheckRoamingShareOwnership: owner is %s!"), lpSidOwner));
            LocalFree(lpSidOwner);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CheckRoamingShareOwnership: owner is someone else!")));
        }
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_OWNER);
    }
        
    
Exit:
    if (psd)
    {
        LocalFree(psd);
    }

    if (pSidAdmin)
    {
        FreeSid(pSidAdmin);
    }

    if (pSidUser)
    {
        DeleteUserSid(pSidUser);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\profile\userdiff.c ===
//*************************************************************
//
//  Userdiff.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"

#define MAX_KEY_NAME    MAX_PATH

BOOL AddUDNode (LPUDNODE *lpList, LPTSTR lpBuildNumber);
BOOL FreeUDList (LPUDNODE lpList);
BOOL ProcessBuild(LPPROFILE lpProfile, LPUDNODE lpItem, LPVOID pEnv);
BOOL ProcessHive(LPPROFILE lpProfile, LPUDNODE lpItem, HKEY hKey);
BOOL ProcessFiles(LPPROFILE lpProfile, LPUDNODE lpItem, HKEY hKey);
BOOL ProcessPrograms(LPPROFILE lpProfile, LPUDNODE lpItem, HKEY hKey, LPVOID pEnv);
BOOL OkToProcessItem(DWORD dwProductType);

//*************************************************************
//
//  ProcessUserDiff()
//
//  Purpose:    Processes the userdiff hive
//
//  Parameters: lpProfile       -   Profile information
//              dwBuildNumber   -   profile build #
//              pEnv            -   Environment block
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/2/95     ericflo    Created
//
//*************************************************************

BOOL ProcessUserDiff (LPPROFILE lpProfile, DWORD dwBuildNumber, LPVOID pEnv)
{
    TCHAR szUserDiff[MAX_PATH] = {0};
    TCHAR szName[MAX_KEY_NAME];
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    LPUDNODE lpList = NULL, lpItem;
    LONG lResult;
    HKEY hKeyUserDiff;
    UINT Index = 0;
    DWORD dwSize;
    FILETIME ftWrite;


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ProcessUserDiff:  Entering.")));


    //
    // Test if the hive exists, first look for USERDIFR
    //

    ExpandUserEnvironmentStrings(pEnv, USERDIFR_LOCATION, szUserDiff, MAX_PATH);
    hFile = FindFirstFile (szUserDiff, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessUserDiff:  userdifr hive doesn't exist.  Trying userdiff.")));

        ExpandUserEnvironmentStrings(pEnv, USERDIFF_LOCATION, szUserDiff, MAX_PATH);
        hFile = FindFirstFile (szUserDiff, &fd);

        if (hFile == INVALID_HANDLE_VALUE) {
            DebugMsg((DM_WARNING, TEXT("ProcessUserDiff:  userdiff hive doesn't exist.  Leaving.")));
            return TRUE;
        }
    }

    FindClose (hFile);


    //
    // Load the hive
    //

    if (MyRegLoadKey(HKEY_USERS, USERDIFF, szUserDiff) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("ProcessUserDiff:  Failed to load userdiff.")));
        return FALSE;
    }

    //
    // Open the key
    //

    lResult = RegOpenKeyEx(HKEY_USERS, USERDIFF, 0, KEY_READ, &hKeyUserDiff);

    if (lResult != ERROR_SUCCESS) {
        MyRegUnLoadKey(HKEY_USERS, USERDIFF);
        DebugMsg((DM_WARNING, TEXT("ProcessUserDiff:  failed to open registry root (%d)"), lResult));
        return FALSE;
    }

    //
    // Enumerate the build numbers
    //

    dwSize = MAX_KEY_NAME;
    lResult = RegEnumKeyEx(hKeyUserDiff, Index, szName, &dwSize, NULL,
                           NULL, NULL, &ftWrite);

    if (lResult == ERROR_SUCCESS) {

        do {

            //
            // Add the node
            //

            if (!AddUDNode (&lpList, szName)) {
                break;
            }

            Index++;
            dwSize = MAX_KEY_NAME;

            lResult = RegEnumKeyEx(hKeyUserDiff, Index, szName, &dwSize, NULL,
                                   NULL, NULL, &ftWrite);


        } while (lResult == ERROR_SUCCESS);
    }


    //
    // Close the open key
    //

    RegCloseKey(hKeyUserDiff);


    //
    // Process the builds
    //

    lpItem = lpList;

    while (lpItem) {

        //
        // Only want to apply changes that occurred in
        // builds after the one the user is running.
        //

        if ( (lpItem->dwBuildNumber > dwBuildNumber) &&
              (lpItem->dwBuildNumber <= g_dwBuildNumber) )  {
            ProcessBuild(lpProfile, lpItem, pEnv);
        }

        lpItem = lpItem->pNext;
    }


    //
    // Free the link list
    //

    FreeUDList (lpList);


    //
    // Unload the hive
    //

    MyRegUnLoadKey(HKEY_USERS, USERDIFF);


    //
    // Success
    //

    DebugMsg((DM_VERBOSE, TEXT("ProcessUserDiff:  Leaving successfully.")));

    return TRUE;

}

//*************************************************************
//
//  AddUDNode()
//
//  Purpose:    Adds a build node to the link listed
//              sorted by build number
//
//  Parameters: lpList         -   Link list of nodes
//              lpBuildNumber  -   New node name
//      
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL AddUDNode (LPUDNODE *lpList, LPTSTR lpBuildNumber)
{
    LPUDNODE lpNewItem;
    LPUDNODE lpHead, lpPrev;

    if (!lpBuildNumber || !*lpBuildNumber) {
        return TRUE;
    }


    //
    // Setup the new node
    //

    lpNewItem = (LPUDNODE) LocalAlloc(LPTR, sizeof(UDNODE));

    if (!lpNewItem) {
        return FALSE;
    }

    lstrcpy (lpNewItem->szBuildNumber, lpBuildNumber);
    lpNewItem->dwBuildNumber = StringToInt(lpBuildNumber);
    lpNewItem->pNext = NULL;


    //
    // Now add it to the list sorted
    //

    lpHead = *lpList;
    lpPrev = NULL;


    if (!lpHead) {

        //
        // First item in the list
        //

        *lpList = lpNewItem;

        return TRUE;
    }


    //
    // If we made it here, there is one or more items in the list
    //


    while (lpHead) {

        if (lpNewItem->dwBuildNumber <= lpHead->dwBuildNumber) {

            if (lpPrev) {

                //
                // Insert the item
                //

                lpPrev->pNext = lpNewItem;
                lpNewItem->pNext = lpHead;
                return TRUE;

            } else {

                //
                // Head of the list
                //

                lpNewItem->pNext = lpHead;
                *lpList = lpNewItem;
                return TRUE;

            }

        }

        lpPrev = lpHead;
        lpHead = lpHead->pNext;
    }


    //
    // Add node to the end of the list
    //

    lpPrev->pNext = lpNewItem;


    return TRUE;
}


//*************************************************************
//
//  FreeUDList()
//
//  Purpose:    Free's a UDNODE link list
//
//  Parameters: lpList  -   List to be freed
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL FreeUDList (LPUDNODE lpList)
{
    LPUDNODE lpNext;


    if (!lpList) {
        return TRUE;
    }


    lpNext = lpList->pNext;

    while (lpList) {
        LocalFree (lpList);
        lpList = lpNext;

        if (lpList) {
            lpNext = lpList->pNext;
        }
    }

    return TRUE;
}

//*************************************************************
//
//  ProcessBuild()
//
//  Purpose:    Processes the changes for a specific build
//
//  Parameters: lpProfile   -   Profile information
//              lpItem  -   Build item to process
//              pEnv    -   Environment block
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL ProcessBuild(LPPROFILE lpProfile, LPUDNODE lpItem, LPVOID pEnv)
{
    TCHAR szSubKey[MAX_PATH];
    LONG lResult;
    HKEY hKey;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ProcessBuild:  Entering with build <%s>."),
             lpItem->szBuildNumber));


    //
    // Open "Hive" subkey
    //

    wsprintf (szSubKey, TEXT("%s\\%s\\Hive"), USERDIFF, lpItem->szBuildNumber);
    lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS) {
        ProcessHive(lpProfile, lpItem, hKey);
        RegCloseKey (hKey);
    }


    //
    // Open "Files" subkey
    //

    wsprintf (szSubKey, TEXT("%s\\%s\\Files"), USERDIFF, lpItem->szBuildNumber);
    lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS) {
        ProcessFiles(lpProfile, lpItem, hKey);
        RegCloseKey (hKey);
    }


    //
    // Open "Execute" subkey
    //

    wsprintf (szSubKey, TEXT("%s\\%s\\Execute"), USERDIFF, lpItem->szBuildNumber);
    lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS) {
        ProcessPrograms(lpProfile, lpItem, hKey, pEnv);
        RegCloseKey (hKey);
    }

    //
    // Success
    //

    DebugMsg((DM_VERBOSE, TEXT("ProcessBuild:  Leaving successfully.")));

    return TRUE;

}

//*************************************************************
//
//  ProcessHive()
//
//  Purpose:    Processes the Hive entry for a build
//
//  Parameters: lpProfile   -   Profile information
//              lpItem      -   Build item
//              hKey        -   Registry key to enumerate
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL ProcessHive(LPPROFILE lpProfile, LPUDNODE lpItem, HKEY hKey)
{
    TCHAR szSubKey[MAX_PATH];
    TCHAR szValueName[MAX_KEY_NAME];
    DWORD dwSize, dwType, dwAction, dwDisp, dwFlags, dwProductType;
    LPBYTE lpValueData;
    LONG lResult;
    UINT Index = 1;
    FILETIME ftWrite;
    HKEY hKeyEntry, hKeyTemp;
    LPTSTR lpName;


    DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Entering.")));

    //
    // Process the entry
    //

    wsprintf (szSubKey, TEXT("%s\\%s\\Hive\\%d"), USERDIFF, lpItem->szBuildNumber, Index);
    lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKeyEntry);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  No hive entries.")));
        goto Exit;
    }


    do {

        //
        // Query for the product type
        //

        dwSize = sizeof(dwProductType);
        lResult = RegQueryValueEx(hKeyEntry, UD_PRODUCTTYPE, NULL, &dwType,
                                  (LPBYTE)&dwProductType, &dwSize);


        //
        // It's ok to not have a product type listed in userdiff.ini.
        // In this case, we always apply the change regardless of the
        // platform.
        //

        if (lResult == ERROR_SUCCESS) {

            //
            // A specific product was listed.  Check if
            // we can process this entry.
            //

            if (!OkToProcessItem(dwProductType)) {
                DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Skipping Item %d due to product type mismatch."), Index));
                goto LoopAgain;
            }
        }


        //
        // Query for the action type
        //

        dwSize = sizeof(dwAction);
        lResult = RegQueryValueEx(hKeyEntry, UD_ACTION, NULL, &dwType,
                                  (LPBYTE)&dwAction, &dwSize);

        if (lResult == ERROR_SUCCESS) {

            switch (dwAction) {

                DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Item %d has an action of %d."),
                         Index, dwAction));

                case 1: {
                    //
                    // Add New Key
                    //
                    // Get the key name
                    //

                   dwSize = MAX_PATH * sizeof(TCHAR);
                   lResult = RegQueryValueEx(hKeyEntry, UD_KEYNAME, NULL, &dwType,
                                             (LPBYTE)szSubKey, &dwSize);

                   if (lResult == ERROR_SUCCESS) {

                       lResult = RegCreateKeyEx (lpProfile->hKeyCurrentUser,
                                                 szSubKey, 0, NULL,
                                                 REG_OPTION_NON_VOLATILE,
                                                 KEY_ALL_ACCESS, NULL,
                                                 &hKeyTemp, &dwDisp);

                       if (lResult == ERROR_SUCCESS) {

                           DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Created subkey <%s>."),
                                    szSubKey));

                           RegCloseKey(hKeyTemp);
                       } else {

                           DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to create subkey <%s> with error %d."),
                                    szSubKey, lResult));
                       }
                   }

                   }
                   break;

                case 2: {
                    //
                    // Delete a key and all it's subkeys
                    //
                    // Get the key name
                    //

                   dwSize = MAX_PATH * sizeof(TCHAR);
                   lResult = RegQueryValueEx(hKeyEntry, UD_KEYNAME, NULL, &dwType,
                                             (LPBYTE)szSubKey, &dwSize);

                   if (lResult == ERROR_SUCCESS) {

                       DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Calling RegDelnode on <%s>."),
                                szSubKey));

                       RegDelnode (lpProfile->hKeyCurrentUser, szSubKey);
                   }

                   }
                   break;

                case 3: {
                    //
                    // Add a new value
                    //
                    // Get the key name
                    //

                   DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Adding a new value.")));

                   dwSize = MAX_PATH * sizeof(TCHAR);
                   lResult = RegQueryValueEx(hKeyEntry, UD_KEYNAME, NULL, &dwType,
                                             (LPBYTE)szSubKey, &dwSize);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to get UD_KEYNAME with error %d."), lResult));
                       goto LoopAgain;
                   }

                   lResult = RegCreateKeyEx (lpProfile->hKeyCurrentUser,
                                             szSubKey, 0, NULL,
                                             REG_OPTION_NON_VOLATILE,
                                             KEY_ALL_ACCESS, NULL,
                                             &hKeyTemp, &dwDisp);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to create UD_KEYNAME with error %d."), lResult));
                       goto LoopAgain;
                   }


                   //
                   // Query for the value name
                   //

                   dwSize = MAX_KEY_NAME * sizeof(TCHAR);
                   lResult = RegQueryValueEx(hKeyEntry, UD_VALUENAME, NULL, &dwType,
                                             (LPBYTE)szValueName, &dwSize);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to query UD_VALUENAME with error %d."), lResult));
                       RegCloseKey(hKeyTemp);
                       goto LoopAgain;
                   }


                   //
                   // Query for the value data size
                   //

                   dwSize = 0;
                   lResult = RegQueryValueEx(hKeyEntry, UD_VALUE, NULL, &dwType,
                                             NULL, &dwSize);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to query UD_VALUE with error %d."), lResult));
                       RegCloseKey(hKeyTemp);
                       goto LoopAgain;
                   }


                   //
                   // Allocate space for the data
                   //

                   lpValueData = LocalAlloc (LPTR, dwSize);

                   if (!lpValueData) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  LocalAlloc failed (%d)."), GetLastError()));
                       RegCloseKey(hKeyTemp);
                       goto LoopAgain;
                   }


                   //
                   // Query for the value data
                   //

                   lResult = RegQueryValueEx(hKeyEntry, UD_VALUE, NULL, &dwType,
                                             lpValueData, &dwSize);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to query value data with error %d."), lResult));
                       LocalFree (lpValueData);
                       RegCloseKey(hKeyTemp);
                       goto LoopAgain;
                   }


                   //
                   // Set the new value
                   //

                   RegSetValueEx(hKeyTemp, szValueName, 0, dwType,
                                 lpValueData, dwSize);


                   //
                   // Clean up
                   //

                   LocalFree (lpValueData);

                   RegCloseKey(hKeyTemp);

                   DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Finished adding value <%s>."), szValueName));
                   }
                   break;

                case 4: {
                   //
                   // Delete value(s)
                   //
                   // Get the key name
                   //

                   DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Entering delete a value.")));

                   dwSize = ARRAYSIZE(szSubKey);
                   lResult = RegQueryValueEx(hKeyEntry, UD_KEYNAME, NULL, &dwType,
                                             (LPBYTE)szSubKey, &dwSize);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to query for value to delete (%d)."), lResult));
                       goto LoopAgain;
                   }

                   lResult = RegCreateKeyEx (lpProfile->hKeyCurrentUser,
                                             szSubKey, 0, NULL,
                                             REG_OPTION_NON_VOLATILE,
                                             KEY_ALL_ACCESS, NULL,
                                             &hKeyTemp, &dwDisp);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to create key (%s) for value to delete (%d)."), szSubKey, lResult));
                       goto LoopAgain;
                   }


                   //
                   // Query for the flags
                   //

                   dwSize = sizeof(dwFlags);
                   lResult = RegQueryValueEx(hKeyEntry, UD_FLAGS, NULL, &dwType,
                                             (LPBYTE)&dwFlags, &dwSize);

                   if (lResult != ERROR_SUCCESS) {
                       dwFlags = 0;
                   }


                   //
                   // Process the flags
                   //

                   if (dwFlags == 2) {
                       DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Calling DeleteAllValues.")));
                       DeleteAllValues (hKeyTemp);
                       RegCloseKey(hKeyTemp);
                       goto LoopAgain;
                   }


                   //
                   // Query for the value names size
                   //

                   dwSize = 0;
                   lResult = RegQueryValueEx(hKeyEntry, UD_VALUENAMES, NULL, &dwType,
                                             NULL, &dwSize);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to query for value names to delete (%d)."), lResult));
                       RegCloseKey(hKeyTemp);
                       goto LoopAgain;
                   }


                   //
                   // Allocate space for the data
                   //

                   lpValueData = LocalAlloc (LPTR, dwSize);

                   if (!lpValueData) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  LocalAlloc failed (%d)."), GetLastError()));
                       RegCloseKey(hKeyTemp);
                       goto LoopAgain;
                   }


                   //
                   // Query for the value data
                   //

                   lResult = RegQueryValueEx(hKeyEntry, UD_VALUENAMES, NULL, &dwType,
                                             lpValueData, &dwSize);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to query for value data to delete (%d)."), lResult));
                       LocalFree (lpValueData);
                       RegCloseKey(hKeyTemp);
                       goto LoopAgain;
                   }


                   //
                   // Delete the values
                   //

                   lpName = (LPTSTR) lpValueData;

                   while (*lpName) {
                       DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Deleting (%s)."), lpName));
                       RegDeleteValue (hKeyTemp, lpName);
                       lpName += lstrlen(lpName) + 1;
                   }


                   //
                   // Delete the no-name value if appropriate
                   //

                   if (dwFlags == 1) {
                       DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Deleting no name value.")));
                       RegDeleteValue (hKeyTemp, NULL);
                   }


                   //
                   // Clean up
                   //

                   LocalFree (lpValueData);
                   RegCloseKey(hKeyTemp);

                   DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Leaving deletion code.")));
                   }

                   break;
            }

        }

LoopAgain:

        //
        // Close the registry key
        //

        RegCloseKey(hKeyEntry);


        //
        // Enumerate again
        //

        Index++;

        wsprintf (szSubKey, TEXT("%s\\%s\\Hive\\%d"), USERDIFF, lpItem->szBuildNumber, Index);
        lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKeyEntry);

    } while (lResult == ERROR_SUCCESS);

Exit:

    DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Leaving.")));

    return TRUE;
}

//*************************************************************
//
//  ProcessFiles()
//
//  Purpose:    Processes the Files entry for a build
//
//  Parameters: lpProfile - Profile information
//              lpItem    -   Build item
//              hKey      -   Registry key to enumerate
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL ProcessFiles(LPPROFILE lpProfile, LPUDNODE lpItem, HKEY hKey)
{
    TCHAR szSubKey[MAX_PATH];
    TCHAR szSrc[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    TCHAR szItem[MAX_PATH];
    LPTSTR lpEnd, lpTemp;
    DWORD dwSize, dwType, dwAction, dwProductType;
    LONG lResult;
    UINT Index = 1;
    FILETIME ftWrite;
    HKEY hKeyEntry;
    HANDLE hOldToken;
    BOOL   bImpersonateUser = FALSE;


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Entering.")));


    //
    // Process the entry
    //

    wsprintf (szSubKey, TEXT("%s\\%s\\Files\\%d"), USERDIFF, lpItem->szBuildNumber, Index);
    lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKeyEntry);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  No Files entries.")));
        goto Exit;
    }


    do {
        //
        // Query for the product type
        //

        dwSize = sizeof(dwProductType);
        lResult = RegQueryValueEx(hKeyEntry, UD_PRODUCTTYPE, NULL, &dwType,
                                  (LPBYTE)&dwProductType, &dwSize);


        //
        // It's ok to not have a product type listed in userdiff.ini.
        // In this case, we always apply the change regardless of the
        // platform.
        //

        if (lResult == ERROR_SUCCESS) {

            //
            // A specific product was listed.  Check if
            // we can process this entry.
            //

            if (!OkToProcessItem(dwProductType)) {
                DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Skipping Item %d due to product type mismatch."), Index));
                goto LoopAgain;
            }
        }


        //
        // Query for the action type
        //

        dwSize = sizeof(dwAction);
        lResult = RegQueryValueEx(hKeyEntry, UD_ACTION, NULL, &dwType,
                                  (LPBYTE)&dwAction, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("ProcessFiles:  Failed to query action type (%d)."), lResult));
            goto LoopAgain;
        }


        //
        // Query for the item
        //

        dwSize = ARRAYSIZE(szItem);
        lResult = RegQueryValueEx(hKeyEntry, UD_ITEM, NULL, &dwType,
                                  (LPBYTE)szItem, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("ProcessFiles:  Failed to query UD_ITEM type (%d)."), lResult));
            goto LoopAgain;
        }

        DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Item %d has an action of %d."),
                 Index, dwAction));

        //
        // Impersonate the user
        //

        if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("ProcessFiles: Failed to impersonate user")));
            RegCloseKey(hKeyEntry);
            goto Exit;
        }
        bImpersonateUser = TRUE;

        switch (dwAction) {

            case 1:

               //
               // Create new program group
               //

               GetSpecialFolderPath (CSIDL_PROGRAMS, szDest);
               lpEnd = CheckSlash(szDest);
               lstrcpy (lpEnd, szItem);

               if (CreateNestedDirectory(szDest, NULL)) {
                   DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Created new group (%s)."), szDest));
               } else {
                   DebugMsg((DM_WARNING, TEXT("ProcessFiles:  Failed to created new group (%s) with (%d)."),
                            szDest, GetLastError()));
               }

               break;

            case 2:
               //
               // Delete a program group
               //

               GetSpecialFolderPath (CSIDL_PROGRAMS, szDest);
               lpEnd = CheckSlash(szDest);
               lstrcpy (lpEnd, szItem);

               Delnode(szDest);

               DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Deleted group (%s)."), szDest));

               break;

            case 3:
               {
               TCHAR szStartMenu [MAX_FOLDER_SIZE];
               DWORD dwSize;

               //
               // Add a new item
               //

               dwSize = ARRAYSIZE(szSrc);
               if (!GetDefaultUserProfileDirectory(szSrc, &dwSize)) {
                   DebugMsg((DM_WARNING, TEXT("ProcessFiles:  Failed to get default user profile.")));
                   goto LoopAgain;
               }

               lpEnd = CheckSlash(szSrc);

               if (LoadString (g_hDllInstance, IDS_SH_PROGRAMS, szStartMenu,
                           MAX_FOLDER_SIZE)) {

                   lstrcpy (lpEnd, szStartMenu);
                   lpEnd = CheckSlash(szSrc);
                   lstrcpy (lpEnd, szItem);


                   GetSpecialFolderPath (CSIDL_PROGRAMS, szDest);
                   lpEnd = CheckSlash(szDest);
                   lstrcpy (lpEnd, szItem);

                   if (CopyFile (szSrc, szDest, FALSE)) {
                       DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  <%s> ==> <%s>  [OK]."),
                                szSrc, szDest));
                   } else {
                       DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  <%s> ==> <%s>  [FAILED %d]."),
                                szSrc, szDest, GetLastError()));
                   }
               }
               }

               break;

            case 4:
               //
               // Delete a program item
               //

               GetSpecialFolderPath (CSIDL_PROGRAMS, szDest);
               lpEnd = CheckSlash(szDest);
               lstrcpy (lpEnd, szItem);

               if (DeleteFile(szDest)) {
                   DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Deleted <%s>"), szDest));
               } else {
                   DebugMsg((DM_WARNING, TEXT("ProcessFiles:  Failed to deleted <%s> with %d"), szDest, GetLastError()));
               }


               //
               // Attempt to delete the directory
               //

               lpTemp = szDest + lstrlen(szDest) - 1;
               lpEnd--;

               while ((*lpTemp != TEXT('\\')) && lpTemp > lpEnd) {
                   lpTemp--;
               }

               if (lpTemp == lpEnd) {
                   break;
               }

               *lpTemp = TEXT('\0');

               if (RemoveDirectory(szDest)) {
                   DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Deleted directory <%s>"), szDest));
               } else {
                   DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Failed to delete directory <%s> with %d"), szDest, GetLastError()));
               }

               break;
        }


LoopAgain:

        if (bImpersonateUser) {
            //
            // Revert to being 'ourself'
            //

            if (!RevertToUser(&hOldToken)) {
                DebugMsg((DM_WARNING, TEXT("ProcessFiles: Failed to revert to self")));
            }
            bImpersonateUser = FALSE;
        }

        //
        // Close the registry key
        //

        RegCloseKey(hKeyEntry);


        //
        // Enumerate again
        //

        Index++;

        wsprintf (szSubKey, TEXT("%s\\%s\\Files\\%d"), USERDIFF, lpItem->szBuildNumber, Index);
        lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKeyEntry);

    } while (lResult == ERROR_SUCCESS);

Exit:

    DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Leaving.")));

    return TRUE;
}

//*************************************************************
//
//  ProcessPrograms()
//
//  Purpose:    Processes the Execute entry for a build
//
//  Parameters: lpProfile - Profile information
//              lpItem    - Build item
//              hKey      - Registry key to enumerate
//              pEnv      - Environment block
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/16/95    ericflo    Created
//
//*************************************************************

BOOL ProcessPrograms (LPPROFILE lpProfile, LPUDNODE lpItem, HKEY hKey, LPVOID pEnv)
{
    TCHAR szSubKey[MAX_PATH];
    TCHAR szCmdLine[MAX_PATH];
    TCHAR szFullPath[MAX_PATH];
    DWORD dwSize, dwType, dwProductType;
    LONG lResult;
    UINT Index = 1;
    HKEY hKeyEntry;
    STARTUPINFO si;
    PROCESS_INFORMATION ProcessInformation;
    BOOL Result;


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ProcessPrograms:  Entering.")));


    //
    // Process the entry
    //

    wsprintf (szSubKey, TEXT("%s\\%s\\Execute\\%d"), USERDIFF, lpItem->szBuildNumber, Index);
    lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKeyEntry);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessPrograms:  No execute entries.")));
        goto Exit;
    }


    do {

        //
        // Query for the product type
        //

        dwSize = sizeof(dwProductType);
        lResult = RegQueryValueEx(hKeyEntry, UD_PRODUCTTYPE, NULL, &dwType,
                                  (LPBYTE)&dwProductType, &dwSize);


        //
        // It's ok to not have a product type listed in userdiff.ini.
        // In this case, we always apply the change regardless of the
        // platform.
        //

        if (lResult == ERROR_SUCCESS) {

            //
            // A specific product was listed.  Check if
            // we can process this entry.
            //

            if (!OkToProcessItem(dwProductType)) {
                DebugMsg((DM_VERBOSE, TEXT("ProcessPrograms:  Skipping Item %d due to product type mismatch."), Index));
                goto LoopAgain;
            }
        }


        //
        // Query for the command line
        //


        dwSize = MAX_PATH * sizeof(TCHAR);
        lResult = RegQueryValueEx(hKeyEntry, UD_COMMANDLINE, NULL, &dwType,
                                  (LPBYTE)szCmdLine, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            goto LoopAgain;
        }


        //
        // If we have a NULL path, loop again.
        //

        if (szCmdLine[0] == TEXT('\0')) {
            goto LoopAgain;
        }


        //
        // Expand the command line
        //

        ExpandUserEnvironmentStrings(pEnv, szCmdLine, szFullPath, MAX_PATH);


        //
        // Initialize process startup info
        //

        si.cb = sizeof(STARTUPINFO);
        si.lpReserved = NULL;
        si.lpTitle = NULL;
        si.lpDesktop = NULL;
        si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
        si.dwFlags = STARTF_USESHOWWINDOW;
        si.wShowWindow = SW_SHOWNORMAL;
        si.lpReserved2 = NULL;
        si.cbReserved2 = 0;


        //
        // Start the app
        //

        Result = CreateProcessAsUser(lpProfile->hTokenUser, NULL, szFullPath,
                                     NULL, NULL, FALSE,
                                     NORMAL_PRIORITY_CLASS | CREATE_UNICODE_ENVIRONMENT, 
                                     pEnv, NULL, &si, &ProcessInformation);

        if (Result) {

            DebugMsg((DM_VERBOSE, TEXT("ProcessPrograms:  Spawned <%s>.  Waiting for it to complete."),
                      szFullPath));

            //
            // Wait for the app to complete (3 minutes max)
            //

            WaitForSingleObject(ProcessInformation.hProcess, 180000);


            DebugMsg((DM_VERBOSE, TEXT("ProcessPrograms:  Finished waiting for <%s>."),
                     szFullPath));


            //
            // Close our handles to the process and thread
            //

            CloseHandle(ProcessInformation.hProcess);
            CloseHandle(ProcessInformation.hThread);

        } else {
            DebugMsg((DM_WARNING, TEXT("ProcessPrograms:  Failed to execute <%s>, error = %d"),
                      szFullPath, GetLastError()));
        }

LoopAgain:

        //
        // Close the registry key
        //

        RegCloseKey(hKeyEntry);


        //
        // Enumerate again
        //

        Index++;

        wsprintf (szSubKey, TEXT("%s\\%s\\Execute\\%d"), USERDIFF, lpItem->szBuildNumber, Index);
        lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKeyEntry);

    } while (lResult == ERROR_SUCCESS);

Exit:

    DebugMsg((DM_VERBOSE, TEXT("ProcessPrograms:  Leaving.")));

    return TRUE;
}

//*************************************************************
//
//  OkToProcessItem()
//
//  Purpose:    Determines if the platform currently running
//              on should have the change in userdiff.ini applied.
//
//  Parameters: dwProductType - ProductType for a specific entry
//                              in userdiff.ini
//
//  Return:     TRUE if change should be applied
//              FALSE if not
//
//  Comments:   dwProductType can be one of these values:
//
//              0 = All platforms
//              1 = All server platforms
//              2 = Workstation
//              3 = Server
//              4 = Domain Controller
//
//  History:    Date        Author     Comment
//              4/08/96     ericflo    Created
//
//*************************************************************

BOOL OkToProcessItem(DWORD dwProductType)
{
    BOOL bRetVal = FALSE;


    switch (g_ProductType) {

        case PT_WORKSTATION:

            if ( (dwProductType == 0) ||
                 (dwProductType == 2) ) {

                bRetVal = TRUE;
            }

            break;

        case PT_SERVER:

            if ( (dwProductType == 0) ||
                 (dwProductType == 1) ||
                 (dwProductType == 3) ) {

                bRetVal = TRUE;
            }

            break;

        case PT_DC:
            if ( (dwProductType == 0) ||
                 (dwProductType == 1) ||
                 (dwProductType == 4) ) {

                bRetVal = TRUE;
            }

            break;

    }

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\rsop\chkacc.cpp ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:        ChkAcc.cpp
//
// Description: RSOP Security functions
//
// History:     31-Jul-99   leonardm    Created
//
//******************************************************************************

#include "uenv.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <Windows.h>
#include <DsGetDC.h>
#include "ChkAcc.h"
#include "smartptr.h"
#include "RsopUtil.h"
#include "RsopDbg.h"


CDebug dbgAccessCheck( L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                       L"ChkAccDebugLevel",
                       L"ChkAcc.log",
                       L"ChkAcc.bak",
                       TRUE );

#undef dbg
#define dbg dbgAccessCheck


//******************************************************************************
//
// Class:       CSid
//
// Description: Objects of this class encapsulate and simplify manipulation of
//              SIDs for the purposes of access control checks.
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
class CSid
{
private:
    bool m_bState;                          // Flag to indicate whether the object is currently
                                            // associated with a valid SID.

    PSID m_pSid;                            // Pointer to the SID encapsulated by thi class.

    CWString m_sUser;                 // User name
    CWString m_sDomain;               // Domain where the user account resides.
    CWString m_sComputer;             // Computer in the domain where the user account exists

    CWString m_sSidString;            // String representation of the encapsulated SID.

    SID_NAME_USE m_eUse;                    // SID type.

public:

    //
    // Overloaded constructors
    //

    CSid() : m_bState(false), m_pSid(NULL), m_eUse(SidTypeUnknown){}

    CSid(const PSID pSid, const WCHAR* szComputer = NULL ) :
    m_bState(false),
    m_pSid(NULL),
    m_eUse(SidTypeUnknown)
    {
        Initialize(pSid, szComputer);
    }

    CSid(const WCHAR* szUser, const WCHAR* szComputer = NULL ) :
    m_bState(false),
    m_pSid(NULL),
    m_eUse(SidTypeUnknown)
    {
        Initialize(szUser, szComputer);
    }

    CSid(const CSid& otherSid) :
    m_bState(false),
    m_pSid(NULL),
    m_eUse(SidTypeUnknown)
    {
        Initialize(otherSid.User(), otherSid.Computer());
    }

    ~CSid()
    {
        Reset();
    }


    //
    // Attempts to initialize an object of this class by associating it with
    // an existing user represented in the SID pointed to by pSid.
    //

    bool Initialize(PSID pSid, const WCHAR* szComputer = NULL);


    //
    // Attempts to initialize an object of this class by associating it with
    // an existing user represented by szUser.
    //

    bool Initialize(const WCHAR* szUser, const WCHAR* szComputer = NULL);


    //
    // Indicates whether this object is currently associated with a valid user.
    //

    bool IsValid() const{ return m_bState; }


    //
    // Overload of assignment operator. Copies one CSid to another.
    // After a this call two objects encapsulate the same SID.
    // However, each owns its own memory. So the destructor of
    // one object can be called without invalidating resources used by the other.
    //

    CSid& operator = (CSid otherSid);


    //
    // Overload of assignment operator. Initializes
    //  the current object with an existing SID.
    //

    CSid& operator = (PSID pSid);


    //
    // Returns a pointer to the SID encapsulated by this object.
    //

    PSID GetSidPtr() const{ return m_pSid; }


    //
    // Returns the name of the user associated with this object.
    //

    const WCHAR* User() const{ return m_sUser; }


    //
    // Returns the name of the computer used to Initialize this object with a user.
    //

    const WCHAR* Computer() const{ return m_sComputer; }


    //
    // Returns the name of the domain of which the user is a member.
    //

    const WCHAR* Domain() const{ return m_sDomain; }


    //
    // Returns a the SID associated with object in
    // a string format suitable for display
    //

    const WCHAR* SidString() const{ return m_sSidString; }


    //
    // Returns the type as it was found in the SID associated
    // with this object during processing of Initialize.
    //

    SID_NAME_USE SidType() const{ return m_eUse; }


    //
    // Breaks the association of this object with an exisitng SID. Releases
    // memory allocate during Initialize and set the internal state to Invalid.
    // This call is safe even if the object is not initialized.
    //

    void Reset();
};

//******************************************************************************
//
// Function:    CSid::Initialize
//
// Description: Attempts to initialize an object of this class by associating it with
//              an existing user represented in the SID pointed to by pSid.
//
// Parameters:  - pSid:         Pointer to an exisitng SID. The memory pointed to
//                              by this parameter may be released after a call to
//                              this function since objects of this class allocate
//                              and release their own memory for the associated SID.
//              - szComputer:   Pointer to a string naming the computer where the
//                              lookup of the account is to take place. If NULL, the
//                              curent computer is used.
//
// Return:      true on success. false otherwise.
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
bool CSid::Initialize(const PSID pSid, const WCHAR* szComputer/* = NULL */)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"CSid::Initialize - Entering...");

    Reset();

    if(!IsValidSid(pSid))
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"CSid::Initialize - IsValidSid returned false!");
        return m_bState;
    }

    m_pSid = new BYTE[GetLengthSid(pSid)];

    if(!m_pSid)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"CSid::Initialize - call to new failed!");
        return m_bState;
    }

    BOOL bRes = CopySid(GetLengthSid(pSid), m_pSid, pSid);
    if(!bRes)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"CSid::Initialize - Call to CopySid returned FALSE!");
        Reset();
        return m_bState;
    }


    DWORD cbUser = 0;
    DWORD cbDomain = 0;

    LookupAccountSid(szComputer, m_pSid, NULL, &cbUser, NULL, &cbDomain, &m_eUse);
    if(cbUser && cbDomain)
    {
        XPtrST<WCHAR>xpszUser = new WCHAR[cbUser];

        if(!xpszUser)
        {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"CSid::Initialize - call to new failed!");
            Reset();
            return m_bState;
        }

        XPtrST<WCHAR>xpszDomain = new WCHAR[cbDomain];

        if(!xpszDomain)
        {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"CSid::Initialize - call to new failed!");
            Reset();
            return m_bState;
        }

        bRes = LookupAccountSid(szComputer, m_pSid, xpszUser, &cbUser, xpszDomain, &cbDomain, &m_eUse);

        if(!bRes)
        {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"CSid::Initialize - call to LookupAccountSid returned FALSE!");
            Reset();
            return m_bState;
        }

        m_sUser = xpszUser;
        if(!m_sUser.ValidString())
        {
            Reset();
            return m_bState;
        }

        m_sDomain = xpszDomain;
        if(!m_sDomain.ValidString())
        {
            Reset();
            return m_bState;
        }

        XPtrLF<WCHAR>szSidString = NULL;
        BOOL bRes = ConvertSidToStringSid(m_pSid, &szSidString);
        if(!bRes)
        {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"CSid::Initialize - call to ConvertSidToStringSid returned false!");
            Reset();
            return m_bState;
        }

        m_sSidString = szSidString;
        if(!m_sSidString.ValidString())
        {
            Reset();
            return m_bState;
        }

        m_bState = true;
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"CSid::Initialize - Leaving successfully.");
    return m_bState;
}


//******************************************************************************
//
// Function:    CSid::Initialize
//
// Description: Attempts to initialize an object of this class by associating it with
//              an existing user represented by szUser.
//
// Parameters:  - szUser:       Name of an existing user.
//              - szComputer:   Pointer to a string naming the computer where the
//                              lookup of the account is to take place. If NULL, the
//                              curent computer is used.
//
// Return:      true on success. false otherwise.
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
bool CSid::Initialize(const WCHAR* szUser, const WCHAR* szComputer/* = NULL */)
{
    Reset();

    if(!szUser)
    {
        return m_bState;
    }

    m_sUser = szUser;
    if(!m_sUser.ValidString())
    {
        Reset();
        return m_bState;
    }

    m_sComputer = szComputer ? szComputer : L"";
    if(!m_sComputer.ValidString())
    {
        Reset();
        return m_bState;
    }

    DWORD cSid = 0;

    DWORD cDomain = 0;

    LookupAccountName(szComputer, szUser, NULL, &cSid, NULL, &cDomain, &m_eUse);

    if(cSid && cDomain)
    {
        m_pSid = new BYTE[cSid];
        if(!m_pSid)
        {
            Reset();
            return m_bState;
        }

        XPtrST<WCHAR>xpszDomain = new WCHAR[cDomain];

        if(!xpszDomain)
        {
            Reset();
            return m_bState;
        }

        BOOL bRes = LookupAccountName(szComputer, szUser, m_pSid, &cSid, xpszDomain, &cDomain, &m_eUse);

        if(!bRes)
        {
            Reset();
            return m_bState;
        }

        m_sDomain = xpszDomain;
        if(!m_sDomain.ValidString())
        {
            Reset();
            return m_bState;
        }

        XPtrLF<WCHAR>szSidString = NULL;
        bRes = ConvertSidToStringSid(m_pSid, &szSidString);
        if(!bRes)
        {
            Reset();
            return m_bState;
        }

        m_sSidString = szSidString;
        if(!m_sSidString.ValidString())
        {
            Reset();
            return m_bState;
        }

        m_bState = true;
    }

    return m_bState;
}

//******************************************************************************
//
// Function:    Reset
//
// Description: Breaks the association of this object with an exisitng SID. Releases
//              memory allocate during Initialize and set the internal state to Invalid.
//              This call is safe even if the object is not initialized.
//
// Parameters:  None.
//
// Return:
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
void CSid::Reset()
{
    delete[] (BYTE*)m_pSid;

    m_pSid = NULL;

    m_sUser = m_sDomain = m_sComputer = m_sSidString = L"";

    m_eUse = SidTypeUnknown;

    m_bState = false;
}

//******************************************************************************
//
// Function:    operator =
//
// Description: Overload of assignment operator. Copies one CSid to another.
//              After a this call two objects encapsulate the same SID.
//              However, each owns its own memory. So the destructor of
//              one object can be called without invalidating resources used by the other.
//
// Parameters:  - otherSid: The CSid whose value is to be copied.
//
// Return:      A reference to the object on which the call is invoked.
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
CSid& CSid::operator = (CSid otherSid)
{
    if(this == &otherSid)
    {
        return *this;
    }

    Reset();

    if(!IsValidSid(otherSid.GetSidPtr()))
    {
        return *this;
    }

    Initialize(otherSid.User(), otherSid.Computer());

    return *this;
}

//******************************************************************************
//
// Function:    operator =
//
// Description: Overload of assignment operator. Initializes the current object with
//              an existing SID.
//
// Parameters:  - otherSid: The CSid whose value is to be copied.
//
// Return:      A reference to the object on which the call is invoked.
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
CSid& CSid::operator = (PSID pSid)
{
    Reset();

    if(!IsValidSid(pSid))
    {
        return *this;
    }

    Initialize(pSid);

    return *this;
}

//******************************************************************************
//
// Structure:   CTLink
//
// Description:
//
// History:     8/02/99         leonardm        Created.
//
//******************************************************************************
template<typename T> struct CTLink
{
    T* m_pData;
    CTLink* m_pNext;
    CTLink* m_pPrev;
    CTLink(T* pData) : m_pData(pData), m_pNext(NULL), m_pPrev(NULL){}
    ~CTLink()
    {
        delete m_pData;
    }
};

//******************************************************************************
//
// Structure:   CRsopToken
//
// Description: This reprents a pseudo-token containing an arbitrary
//              combination of SIDs which
//              can be used to check access to objects protected with security descriptors.
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
struct CRsopToken
{
    CTLink<CSid>* m_pSidsHead;
    CTLink<CSid>* m_pSidsTail;


    //
    // Default constructor. Constructs an object with no sids. Access checks
    // against an CRsopToken with no SIDs will always fail; even on objects
    // with no DACL.
    //

    CRsopToken() : m_pSidsHead(NULL), m_pSidsTail(NULL) {}


    //
    // Destructor. Releases the memory pointed
    //  to by each of the elements of m_pSidsHead.
    //

    ~CRsopToken();


    //
    // Adds a CSid to this object. The client of this class allocates the memory
    // for the CSid and this class releases the memory in the destructor.
    //

    HRESULT AddSid(CSid* pSid);
};

//******************************************************************************
//
// Function:    CRsopToken::~CRsopToken
//
// Description: Destructor. Releases the memory pointed to by each of the elements of
//              m_pSidsHead.
//
// Parameters:  None.
//
// Return:      N/A
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
CRsopToken::~CRsopToken()
{
    CTLink<CSid>* pLinkIterator = m_pSidsHead;
    while(pLinkIterator)
    {
        CTLink<CSid>* pLinkToDelete = pLinkIterator;
        pLinkIterator = pLinkIterator->m_pNext;
        delete pLinkToDelete;
    }
}


//******************************************************************************
//
// Function:    CRsopToken::AddSid
//
// Description: Adds a CSid to this object. The client of this class allocates the
//              memory for the CSid and this class releases the memory in the destructor.
//
// Parameters:  - pSid: A pointer to a CSid. The memory pointed to by pSid will be released by
//              in the destructor.
//
// Return:      On success it returns S_OK.
//              On failure it returns E_OUTOFMEMORY.
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
HRESULT CRsopToken::AddSid(CSid* pSid)
{

    //
    // first check if the Sid is already in there
    //
    for(CTLink<CSid>* pTraverseLink = m_pSidsHead; pTraverseLink; pTraverseLink = pTraverseLink->m_pNext)
    {
        //
        // If one of the SIDs in the RsopToken matches
        // this Sid, return
        //

        if (EqualSid(pSid->GetSidPtr(), pTraverseLink->m_pData->GetSidPtr())) 
            return S_OK;
    }


    //
    // Allocate a new link using the pSid passed in.
    //

    CTLink<CSid>* pLink = new CTLink<CSid>(pSid);
    if(!pLink)
    {
        return E_OUTOFMEMORY;
    }

    if(!m_pSidsHead)
    {
        m_pSidsHead = pLink;
    }
    else
    {
        m_pSidsTail->m_pNext = pLink;
    }

    m_pSidsTail = pLink;

    return S_OK;
}
//******************************************************************************
//
// Function:    GetUserInfo
//
// Description:
//
// Parameters:
//
// Return:      S_OK if successful. An HRESULT error code on failure.
//
// History:     8/7/99      leonardm        Created.
//
//******************************************************************************
HRESULT GetUserInfo(const CWString& sUser,
                    CWString& sUserName,
                    CWString& sUserDomain,
                    CWString& sUserDC)
{
    if(!sUser.ValidString())
    {
        return E_FAIL;
    }

    NET_API_STATUS status;

    XPtrST<WCHAR>xpUserName = NULL;
    XPtrST<WCHAR>xpUserDomain = NULL;

    size_t len = sUser.length();

    WCHAR* backslashPos = wcschr(sUser, L'\\');
    if(backslashPos)
    {
        size_t index = backslashPos - sUser;
        xpUserDomain = new WCHAR[index + 1];
        if(!xpUserDomain )
        {
            return E_OUTOFMEMORY;
        }
        wcsncpy(xpUserDomain, sUser, index);
        xpUserDomain[index] = L'\0';

        xpUserName = new WCHAR[len - index];
        if(!xpUserName)
        {
            return E_OUTOFMEMORY;
        }
        wcsncpy(xpUserName, backslashPos + 1, len - index - 1);
        xpUserName[len - index - 1] = L'\0';
    }

    sUserName = xpUserName ? CWString(xpUserName) : sUser;
    if(!sUserName.ValidString())
    {
        return E_FAIL;
    }

    if(xpUserDomain)
    {
        // Use supplied domain.
        sUserDomain = xpUserDomain;
    }
    else
    {
        // Use current domain
        WKSTA_INFO_100* pWkstaInfo = NULL;
        status = NetWkstaGetInfo(NULL,100,(LPBYTE*)&pWkstaInfo);
        if(status != NERR_Success)
        {
            return E_FAIL;
        }
        sUserDomain = pWkstaInfo->wki100_langroup;
        NetApiBufferFree(pWkstaInfo);
    }

    if(!sUserDomain.ValidString())
    {
        return E_FAIL;
    }

    PDOMAIN_CONTROLLER_INFO pDCInfo = 0;
    
    DWORD dwError = DsGetDcName(0,
                                sUserDomain,
                                0,
                                0,
                                0,
                                &pDCInfo );
    if ( dwError != NO_ERROR )
    {
        return HRESULT_FROM_WIN32( dwError );
    }
    
    sUserDC = pDCInfo->DomainControllerName;

    NetApiBufferFree(pDCInfo);

    if ( !sUserDC.ValidString() )
    {
        return E_FAIL;
    }

    return S_OK;
}

//******************************************************************************
//
// Function:    AddSpecialGroup
//
// Description:
//
// Parameters:
//
// Return:      S_OK if successful. An HRESULT error code on failure.
//
// History:     8/7/99      leonardm        Created.
//
//******************************************************************************
HRESULT AddSpecialGroup(PRSOPTOKEN pRsopToken, PSID pSid)
{
    CRsopToken* pToken = static_cast<CRsopToken*>(pRsopToken);

    XPtrST<CSid> xpCSid = new CSid(pSid);

    if(!xpCSid)
    {
        return E_OUTOFMEMORY;
    }

    if(!xpCSid->IsValid())
    {
        return E_FAIL;
    }

    HRESULT hr = pToken->AddSid(xpCSid);

    if(FAILED(hr))
    {
        return hr;
    }

    xpCSid.Acquire();

    return S_OK;
}

//******************************************************************************
//
// Function:    AddSpecialGroups
//
// Description:
//
// Parameters:
//
// Return:      S_OK if successful. An HRESULT error code on failure.
//
// History:     8/7/99      leonardm        Created.
//
//******************************************************************************
HRESULT AddSpecialGroups(PRSOPTOKEN pRsopToken )
{
    BOOL bRes;
    PSID pSid;
    HRESULT hr;

    //
    // Everyone
    //

    SID_IDENTIFIER_AUTHORITY IdentifierAuthority_World = SECURITY_WORLD_SID_AUTHORITY;

    bRes = AllocateAndInitializeSid(&IdentifierAuthority_World, 1,
                                    SECURITY_WORLD_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSid);

    if(!bRes)
    {
        DWORD dwLastError = GetLastError();
        return E_FAIL;
    }

    hr = AddSpecialGroup(pRsopToken, pSid);

    FreeSid(pSid);

    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Authenticated users
    //

    SID_IDENTIFIER_AUTHORITY IdentifierAuthority_NT = SECURITY_NT_AUTHORITY;

    bRes = AllocateAndInitializeSid(&IdentifierAuthority_NT, 1,
                                    SECURITY_AUTHENTICATED_USER_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSid);

    if(!bRes)
    {
        DWORD dwLastError = GetLastError();
        return E_FAIL;
    }

    hr = AddSpecialGroup(pRsopToken, pSid);

    FreeSid(pSid);

    if(FAILED(hr))
    {
        return hr;
    }


    return S_OK;
}


//******************************************************************************
//
// Function:    AddGlobalGroups
//
// Description:
//
// Parameters:
//
// Return:      S_OK if successful. An HRESULT error code on failure.
//
// History:     8/7/99      leonardm        Created.
//
//******************************************************************************
HRESULT AddGlobalGroups(const CWString& sUserName,
                        const CWString& sUserDC,
                        PRSOPTOKEN pRsopToken)
{
    if(!sUserName.ValidString())
    {
        return E_FAIL;
    }

    CRsopToken* pToken = static_cast<CRsopToken*>(pRsopToken);

    BYTE* pBuffer = NULL;
    DWORD dwEntriesread;
    DWORD dwTotalentries;

    NET_API_STATUS result = NetUserGetGroups(   sUserDC,
                                                sUserName,
                                                0,
                                                &pBuffer,
                                                MAX_PREFERRED_LENGTH,
                                                &dwEntriesread,
                                                &dwTotalentries);

    if(result != NERR_Success)
    {
        return HRESULT_FROM_WIN32(result);
    }

    HRESULT hr = S_OK;

    GROUP_USERS_INFO_0* pGui = (GROUP_USERS_INFO_0*)pBuffer;

    XPtrST<CSid> xpCSid;

    for(DWORD dwi = 0; dwi < dwEntriesread; dwi++)
    {
        xpCSid = new CSid((pGui[dwi]).grui0_name);

        if(!xpCSid)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        if(!xpCSid->IsValid())
        {
            hr = E_FAIL;
            break;
        }

        hr = pToken->AddSid(xpCSid);
        if(FAILED(hr))
        {
            break;
        }

        xpCSid.Acquire();
    }

    NetApiBufferFree(pBuffer);

    return hr;
}


//******************************************************************************
//
// Function:    AddLocalGroups
//
// Description:
//
// Parameters:
//
// Return:      S_OK if successful. An HRESULT error code on failure.
//
//
//******************************************************************************
HRESULT AddLocalGroups(const CWString& sUserName,
                        const CWString& sUserDC,
                        PRSOPTOKEN pRsopToken)
{
    if(!sUserName.ValidString())
    {
        return E_FAIL;
    }

    CRsopToken* pToken = static_cast<CRsopToken*>(pRsopToken);

    BYTE* pBuffer = NULL;
    DWORD dwEntriesread;
    DWORD dwTotalentries;

    NET_API_STATUS result = NetUserGetLocalGroups(   
                                                sUserDC, 
                                                sUserName,
                                                0,
                                                LG_INCLUDE_INDIRECT,
                                                &pBuffer,
                                                MAX_PREFERRED_LENGTH,
                                                &dwEntriesread,
                                                &dwTotalentries);

    if(result != NERR_Success)
    {
        HRESULT_FROM_WIN32(result);
    }

    HRESULT hr = S_OK;

    LPLOCALGROUP_USERS_INFO_0 pLui = (LPLOCALGROUP_USERS_INFO_0)pBuffer;

    XPtrST<CSid> xpCSid;

    for(DWORD dwi = 0; dwi < dwEntriesread; dwi++)
    {
        xpCSid = new CSid((pLui[dwi]).lgrui0_name);

        if(!xpCSid)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        if(!xpCSid->IsValid())
        {
            hr = E_FAIL;
            break;
        }

        hr = pToken->AddSid(xpCSid);
        if(FAILED(hr))
        {
            break;
        }

        xpCSid.Acquire();
    }

    NetApiBufferFree(pBuffer);

    return hr;
}

//******************************************************************************
//
// Function:    ExpandGroup
//
// Description: Expands a given group by expanding to include all the member subgroups etc..
//
// Parameters:  - pRsopToken:               Rsop token
//                hAuthz:                   A pointer to the Authz resource manager 
//                                          (that we are using to expand the grps)
//                pCSid:                    Sid of the group 
//
//
// Return:      S_OK if successful. An HRESULT error code on failure.
//
//******************************************************************************

HRESULT ExpandGroup(CRsopToken *pRsopToken, AUTHZ_RESOURCE_MANAGER_HANDLE hAuthz, 
                  CSid *pCSid )
{
    AUTHZ_CLIENT_CONTEXT_HANDLE   hAuthzContext=0;
    LUID                          luid = {0};
    HRESULT                       hrRet = S_OK;
    DWORD                         dwSize=0;
    XPtrLF<TOKEN_GROUPS>          xGrps;
    XPtrST<CSid>                  xpCSid;


    if (!AuthzInitializeContextFromSid(0,
                                       pCSid->GetSidPtr(), 
                                       hAuthz,
                                       NULL,
                                       luid, // we are not using it
                                       NULL,
                                      &hAuthzContext)) {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - AuthzInitializeContextFromSid failed. Error - %d", GetLastError());
        hrRet = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // Now get the list of expanded sids
    // find the size first
    //

    if (!AuthzGetInformationFromContext(hAuthzContext, 
                               AuthzContextInfoGroupsSids, 
                               NULL,
                               &dwSize,
                               0)) {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - AuthzGetInformationFromContext failed. Error - %d", GetLastError());
            hrRet = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }

    xGrps = (PTOKEN_GROUPS)LocalAlloc(LPTR, dwSize);
    
    if (!xGrps) {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - Couldn't allocate memory for the token grps. Error - %d", GetLastError());
        hrRet = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    
    if (!AuthzGetInformationFromContext(hAuthzContext, 
                                AuthzContextInfoGroupsSids, 
                                dwSize,
                                &dwSize,
                                xGrps)) {

        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - AuthzGetInformationFromContext(2) failed. Error - %d", GetLastError());
        hrRet = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    
    for (DWORD i = 0; i < xGrps->GroupCount; i++) {
        xpCSid = new CSid(xGrps->Groups[i].Sid, NULL);

        if (!xpCSid) {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - couldn't allocate memory(2). Error - %d", GetLastError());
            hrRet = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        hrRet = pRsopToken->AddSid(xpCSid);
        if(FAILED(hrRet)) {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - AddSid failed. Error - 0x%x", hrRet);
            goto Exit;
        }

        xpCSid.Acquire();
    }
                
    hrRet = S_OK;

Exit:
    if (hAuthzContext)
        AuthzFreeContext(hAuthzContext);

    return hrRet;
}


//******************************************************************************
//
// Function:    RsopCreateToken
//
// Description: Creates a pseudo-token using an exisitng user or machine account plus
//              the accounts of which that user is currently a member of.
//              The returned pseudo-token can be used subsequently in call
//              to other RSOP security functions to check access to
//              objects protected by security descriptors.
//
// Parameters:  - szaccountName:            Pointer to a user or machine account name.
//              - psaUserSecurityGroups:    Pointer ta SAFEARRAY of BSTRs representing
//                                          security groups.
//                                          If NULL, then all the current security groups for the
//                                          szaccountName are added to the RsopToken.
//                                          If not NULL but pointing to an empty array,
//                                          only the szaccountName is added to the RsopToken.
//              - ppRsopToken:              Address of a PRSOPTOKEN that receives the newly
//                                          created pseudo-token
//
//
// Return:      S_OK if successful. An HRESULT error code on failure.
//
// History:     8/7/99      leonardm        Created.
//
//******************************************************************************
HRESULT RsopCreateToken(WCHAR* szAccountName,
                        SAFEARRAY* psaUserSecurityGroups,
                        PRSOPTOKEN* ppRsopToken )
{


    dbg.Initialize( L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                    L"ChkAccDebugLevel",
                    L"ChkAcc.log",
                    L"ChkAcc.bak");

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopCreateToken - Entering...");

    HRESULT hr = E_FAIL;


    //
    // Instantiate a new CRsopToken
    //

    *ppRsopToken = NULL;

    XPtrST<CRsopToken>xpRsopToken = new CRsopToken();

    if(!xpRsopToken)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - Operator new returned NULL. Creation of a CRsopToken failed.");
        return E_OUTOFMEMORY;
    }

    //
    // Add to the new CRsopToken a CSid corresponding to the
    // principal represented by parameter szAccountName. For
    // dummy target the szAccountName will be null.
    //

    XPtrST<CSid>xpCSid;

    if ( szAccountName )
    {
        xpCSid = new CSid(szAccountName);

        if(!xpCSid)
        {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - Operator new returned NULL. Creation of a CSid failed.");
            return E_OUTOFMEMORY;
        }

        if(!xpCSid->IsValid())
        {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - Call to CSid::IsValid failed.");
            return E_FAIL;
        }

        hr = xpRsopToken->AddSid(xpCSid);
        if(FAILED(hr))
        {
            return hr;
        }

        xpCSid.Acquire();
    }

    //
    // If the parameter is NULL, that means we are to add the security
    // groups to which the user currently belongs.
    //

    if(!psaUserSecurityGroups)
    {
        if (szAccountName) {
            CWString sUser = szAccountName;
            CWString sUserName;
            CWString sUserDomain;
            CWString sUserDC;

            hr = GetUserInfo(sUser, sUserName, sUserDomain, sUserDC);
            if(FAILED(hr))
            {
                return hr;
            }

/*          for cross domain cases this fails

            //
            // Get Global group membership
            //
            hr = AddGlobalGroups(sUserName, sUserDC, xpRsopToken);
            if(FAILED(hr))
            {
                return hr;
            }
*/

            hr = AddLocalGroups(sUserName, sUserDC, xpRsopToken);
            if(FAILED(hr))
            {
                return hr;
            }

            //
            // Universal groups across domains cannot be retrieved by 
            // NetUserGetGroups but can be fetched by authz functions.
            //

            xpCSid = new CSid(szAccountName);

            AUTHZ_RESOURCE_MANAGER_HANDLE hAuthz;

            if (!AuthzInitializeResourceManager(NULL, 
                                           NULL, 
                                           NULL, 
                                           NULL, 
                                           0,    
                                          &hAuthz)) {
                dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - AuthzInitializeResourceManager failed. Error - %d", GetLastError());
                return HRESULT_FROM_WIN32(GetLastError());
            }

            HRESULT hr = ExpandGroup(xpRsopToken, hAuthz, xpCSid);
            if (FAILED(hr)) {
                dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - ExpandGrp failed for user. Error - 0x%x", hr);
                AuthzFreeResourceManager(hAuthz);
                return hr;
            }
                            
            AuthzFreeResourceManager(hAuthz);
            // xpCSid will be freed automatically.
        }
    }


    //
    // Otherwise, we add only those groups named in the SAFERARRAY.
    //

    else
    {
        BSTR* pbstr;
        AUTHZ_RESOURCE_MANAGER_HANDLE hAuthz;

        if (!AuthzInitializeResourceManager(NULL, 
                                       NULL, 
                                       NULL, 
                                       NULL, 
                                       0,    
                                      &hAuthz)) {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - AuthzInitializeResourceManager failed. Error - %d", GetLastError());
            return HRESULT_FROM_WIN32(GetLastError());
        }


        // Get a pointer to the elements of the array.
        HRESULT hr = SafeArrayAccessData(psaUserSecurityGroups, (void**)&pbstr);
        if(FAILED(hr))
        {
            AuthzFreeResourceManager(hAuthz);
            return hr;
        }

        int count = psaUserSecurityGroups->rgsabound[0].cElements;
        for (int i = 0; i < count; i++)
        {
            xpCSid = new CSid(pbstr[i]);

            if(!xpCSid)
            {
                AuthzFreeResourceManager(hAuthz);
                SafeArrayUnaccessData(psaUserSecurityGroups);
                return E_OUTOFMEMORY;
            }

            if(!xpCSid->IsValid())
            {
                dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - %s is invalid", pbstr[i]);
                AuthzFreeResourceManager(hAuthz);
                SafeArrayUnaccessData(psaUserSecurityGroups);
                return HRESULT_FROM_WIN32(ERROR_INVALID_ACCOUNT_NAME);
            }

            HRESULT hr = ExpandGroup(xpRsopToken, hAuthz, xpCSid);
            if (FAILED(hr)) {
                dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - ExpandGrp failed. Error - 0x%x", hr);
                AuthzFreeResourceManager(hAuthz);
                SafeArrayUnaccessData(psaUserSecurityGroups);
                return hr;
            }
                            
            hr = xpRsopToken->AddSid(xpCSid);
            if(FAILED(hr))
            {
                AuthzFreeResourceManager(hAuthz);
                SafeArrayUnaccessData(psaUserSecurityGroups);
                return hr;
            }

            xpCSid.Acquire();

        }

        AuthzFreeResourceManager(hAuthz);
        SafeArrayUnaccessData(psaUserSecurityGroups);
        
        
    }

    hr = AddSpecialGroups(xpRsopToken);
    if(FAILED(hr))
    {
        return hr;
    }
    
    *ppRsopToken = xpRsopToken;

    xpRsopToken.Acquire();

    return S_OK;
}

//******************************************************************************
//
// Function:    RsopDeleteToken
//
// Description: Destroys a pseudo-token previously created by any of the overloaded
//              forms of RSOPCreateRsopToken
//
// Parameters:  - pRsopToken: Pointer to a valid PRSOPTOKEN
//
// Return:      S_OK on success. An HRESULT error code on failure.
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
HRESULT RsopDeleteToken(PRSOPTOKEN pRsopToken)
{
    CRsopToken* pToken = static_cast<CRsopToken*>(pRsopToken);
    delete pToken;
    return S_OK;
}

//******************************************************************************
//
// Function:    GetAceSid
//
// Description:
//
// Parameters:
//
// Return:
//
// History:             10/19/99          leonardm        Created.
//
//******************************************************************************
PISID GetAceSid(PACE_HEADER pAceHeader)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"GetAceSid - Entering.");


    //
    // Check for invalid argument
    //

    if(!pAceHeader)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"GetAceSid - Invalid parameter: pAceHeader is NULL");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"GetAceSid - Leaving.");
        return NULL;
    }

    PISID pSid = NULL;

    PACCESS_ALLOWED_ACE pACCESS_ALLOWED_ACE;
    PACCESS_ALLOWED_OBJECT_ACE pACCESS_ALLOWED_OBJECT_ACE;
    PACCESS_DENIED_ACE pACCESS_DENIED_ACE;
    PACCESS_DENIED_OBJECT_ACE pACCESS_DENIED_OBJECT_ACE;

    //
    // Cast the ACE header to the appropriate ACE type based on the 'Acetype' member of the
    // ACE header.
    //

    switch(pAceHeader->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"GetAceSid - ACE type: ACCESS_ALLOWED_ACE_TYPE");
        pACCESS_ALLOWED_ACE = reinterpret_cast<PACCESS_ALLOWED_ACE>(pAceHeader);
        pSid = reinterpret_cast<PISID>(&(pACCESS_ALLOWED_ACE->SidStart));
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"GetAceSid - ACE type: ACCESS_ALLOWED_OBJECT_ACE_TYPE");
        pACCESS_ALLOWED_OBJECT_ACE = reinterpret_cast<PACCESS_ALLOWED_OBJECT_ACE>(pAceHeader);

        if( (pACCESS_ALLOWED_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT) &&
            (pACCESS_ALLOWED_OBJECT_ACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT))
        {
            //
            // If both ACE_OBJECT_TYPE_PRESENT and ACE_INHERITED_OBJECT_TYPE_PRESENT are set in
            // the ACE flags, the SID starts at the offset specified by 'SidStart'.
            //

            pSid = reinterpret_cast<PISID>(&(pACCESS_ALLOWED_OBJECT_ACE->SidStart));
        }
        else if((pACCESS_ALLOWED_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT) ||
                (pACCESS_ALLOWED_OBJECT_ACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT))
        {
            //
            // If either ACE_OBJECT_TYPE_PRESENT or ACE_INHERITED_OBJECT_TYPE_PRESENT is set in
            // the ACE flags, the SID starts at the offset specified by 'InheritedObjectType'.
            //

            pSid = reinterpret_cast<PISID>(&(pACCESS_ALLOWED_OBJECT_ACE->InheritedObjectType));
        }
        else
        {
            //
            // If neither ACE_OBJECT_TYPE_PRESENT nor ACE_INHERITED_OBJECT_TYPE_PRESENT is set in
            // the ACE flags, the SID starts at the offset specified by 'ObjectType'.
            //

            pSid = reinterpret_cast<PISID>(&(pACCESS_ALLOWED_OBJECT_ACE->ObjectType));
        }
        break;

    case ACCESS_DENIED_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"GetAceSid - ACE type: ACCESS_DENIED_ACE_TYPE");
        pACCESS_DENIED_ACE = reinterpret_cast<PACCESS_DENIED_ACE>(pAceHeader);
        pSid = reinterpret_cast<PISID>(&(pACCESS_DENIED_ACE->SidStart));
        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"GetAceSid - ACE type: ACCESS_DENIED_OBJECT_ACE_TYPE");
        pACCESS_DENIED_OBJECT_ACE = reinterpret_cast<PACCESS_DENIED_OBJECT_ACE>(pAceHeader);
        if( (pACCESS_DENIED_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT) &&
            (pACCESS_DENIED_OBJECT_ACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT))
        {
            //
            // If both ACE_OBJECT_TYPE_PRESENT and ACE_INHERITED_OBJECT_TYPE_PRESENT are set in
            // the ACE flags, the SID starts at the offset specified by 'SidStart'.
            //

            pSid = reinterpret_cast<PISID>(&(pACCESS_DENIED_OBJECT_ACE->SidStart));
        }
        else if((pACCESS_DENIED_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT) ||
                (pACCESS_DENIED_OBJECT_ACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT))
        {
            //
            // If either ACE_OBJECT_TYPE_PRESENT or ACE_INHERITED_OBJECT_TYPE_PRESENT is set in
            // the ACE flags, the SID starts at the offset specified by 'InheritedObjectType'.
            //

            pSid = reinterpret_cast<PISID>(&(pACCESS_DENIED_OBJECT_ACE->InheritedObjectType));
        }
        else
        {
            //
            // If neither ACE_OBJECT_TYPE_PRESENT nor ACE_INHERITED_OBJECT_TYPE_PRESENT is set in
            // the ACE flags, the SID starts at the offset specified by 'ObjectType'.
            //

            pSid = reinterpret_cast<PISID>(&(pACCESS_DENIED_OBJECT_ACE->ObjectType));
        }
        break;

    default:
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"GetAceSid - Unexpected ACE type found. Type: 0x%08X", pAceHeader->AceType);
        break;
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"GetAceSid - Leaving.");

    return pSid;
}

//******************************************************************************
//
// Function:    CheckAceApplies
//
// Description:
//
// Parameters:
//
// Return:              S_OK on success. An HRESULT error code on failure.
//
// History:             8/8/99          leonardm        Created.
//
//******************************************************************************
HRESULT CheckAceApplies(PACE_HEADER pAceHeader, PRSOPTOKEN pRsopToken, bool* pbAceApplies)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"CheckAceApplies - Entering.");

    //
    // Get the SID from the ACE associated with this Ace Header.
    //

    PISID pSid = GetAceSid(pAceHeader);
    if(!pSid)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"CheckAceApplies - GetAceSid failed.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"CheckAceApplies - Leaving.");
        return E_FAIL;
    }

    *pbAceApplies = false;

    //
    // Compare the SID from the ACE with all the SIDs in the RsopToken.
    //

    CRsopToken* pToken  = static_cast<CRsopToken*>(pRsopToken);
    for(CTLink<CSid>* pLink = pToken->m_pSidsHead; pLink; pLink = pLink->m_pNext)
    {
        //
        // If one of the SIDs in the RsopToken matches
        // the SID in the ACE, this ACE applies.
        //

        if(EqualSid(pSid, pLink->m_pData->GetSidPtr()))
        {
            *pbAceApplies = true;
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"CheckAceApplies - One of the SIDs in the RsopToken matches the SID in the ACE. The ACE applies.");
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"CheckAceApplies - Leaving.");
            return S_OK;
        }
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"CheckAceApplies - None of the SIDs in the RsopToken matches the SID in the ACE. The ACE does not apply.");
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"CheckAceApplies - Leaving.");

    return S_OK;
}

//******************************************************************************
const DWORD MAX_PERM_BITS=25;

//******************************************************************************
enum EPermission{ PERMISSION_DENIED, PERMISSION_ALLOWED, PERMISSION_NOT_SET};


//******************************************************************************
//
// Class:       CSubObjectPerm
//
// Description:
//
// History:     11/09/99     leonardm        Created.
//
//******************************************************************************
class CSubObjectPerm
{
private:

    CTLink<GUID>* m_pGuidsHead;
    CTLink<GUID>* m_pGuidsTail;

    EPermission permissionBits[MAX_PERM_BITS];

public:

    CSubObjectPerm();
    ~CSubObjectPerm();

    HRESULT AddGuid(GUID* pGuid);

    void ProcessAceMask(DWORD dwMask, EPermission permission, GUID* pGuid);
    DWORD GetAccumulatedPermissions();
    bool  AnyDenied();
};

//******************************************************************************
//
// Function:    CSubObjectPerm::CSubObjectPerm
//
// Description:
//
// Parameters:
//
// Return:
//
// History:     11/09/99     leonardm        Created.
//
//******************************************************************************
CSubObjectPerm::CSubObjectPerm() : m_pGuidsHead(NULL), m_pGuidsTail(NULL)
{
    for (int i = 0; i < MAX_PERM_BITS; i++)
    {
        permissionBits[i] = PERMISSION_NOT_SET;
    }
}

//******************************************************************************
//
// Function:    CSubObjectPerm::~CSubObjectPerm
//
// Description:
//
// Parameters:
//
// Return:
//
// History:     11/09/99     leonardm        Created.
//
//******************************************************************************
CSubObjectPerm::~CSubObjectPerm()
{
    CTLink<GUID>* pLinkIterator = m_pGuidsHead;
    while(pLinkIterator)
    {
        CTLink<GUID>* pLinkToDelete = pLinkIterator;
        pLinkIterator = pLinkIterator->m_pNext;
        delete pLinkToDelete;
    }
}

//******************************************************************************
//
// Function:    CSubObjectPerm::AddGuid
//
// Description:
//
// Parameters:
//
// Return:
//
// History:     11/09/99     leonardm        Created.
//
//******************************************************************************
HRESULT CSubObjectPerm::AddGuid(GUID* pGuid)
{
    CTLink<GUID>* pLink = new CTLink<GUID>(pGuid);
    if(!pLink)
    {
        return E_OUTOFMEMORY;
    }

    if(!m_pGuidsHead)
    {
        m_pGuidsHead = pLink;
    }
    else
    {
        m_pGuidsTail->m_pNext = pLink;
    }

    m_pGuidsTail = pLink;

    return S_OK;
}

//******************************************************************************
//
// Function:    CSubObjectPerm::ProcessAceMask
//
// Description:
//
// Parameters:
//
// Return:
//
// History:     11/09/99     leonardm        Created.
//
//******************************************************************************
void CSubObjectPerm::ProcessAceMask(DWORD dwMask, EPermission permission, GUID* pGuid)
{
    bool bAceApplies = false;

    if(!pGuid)
    {
        bAceApplies = true;
    }

    else if(pGuid && m_pGuidsHead)
    {
        CTLink<GUID>* pLinkIterator = m_pGuidsHead;

        while(pLinkIterator)
        {
            if(*(pLinkIterator->m_pData) == *pGuid)
            {
                bAceApplies = true;
                break;
            }

            pLinkIterator = pLinkIterator->m_pNext;
        }
    }

    if(bAceApplies)
    {
        DWORD dwTemp = 0x00000001;

        for(int i = 0; i < MAX_PERM_BITS; i++)
        {
            if((dwMask & dwTemp) && (permissionBits[i] == PERMISSION_NOT_SET))
            {
                permissionBits[i] = permission;
            }

            dwTemp <<= 1;
        }
    }
}

//******************************************************************************
//
// Function:    CSubObjectPerm::AccumulatedPermissions
//
// Description:
//
// Parameters:
//
// Return:
//
// History:     11/09/99     leonardm        Created.
//
//******************************************************************************
DWORD CSubObjectPerm::GetAccumulatedPermissions()
{
    DWORD dwAccumulatedPermissions = 0;

    for(int i = MAX_PERM_BITS - 1; i >= 0; i--)
    {
        dwAccumulatedPermissions <<= 1;
        if(permissionBits[i] == PERMISSION_ALLOWED)
        {
            dwAccumulatedPermissions |= 0x00000001;
        }
    }

    return dwAccumulatedPermissions;
}

//******************************************************************************
//
// Function:    CSubObjectPerm::AnyDenied
//
// Description:
//
// Parameters:
//
// Return:
//
// History:     11/09/99     leonardm        Created.
//
//******************************************************************************
bool CSubObjectPerm::AnyDenied()
{
    for(int i = 0; i < MAX_PERM_BITS; i++)
    {
        if(permissionBits[i] == PERMISSION_DENIED)
        {
            return true;
        }
    }

    return false;
}

//******************************************************************************
//
// Struct:    CDSObject
//
// Description:
//
//
// History:             10/25/99          leonardm        Created.
//
//******************************************************************************
struct CDSObject
{
    DWORD m_dwLevel;
    GUID* m_pGuid;

    CDSObject() : m_pGuid(NULL){}
    ~CDSObject()
    {
        delete m_pGuid;
    }
};

//******************************************************************************
//
// Class:    CAccumulatedPermissions
//
// Description:
//
//
// History:             10/25/99          leonardm        Created.
//
//******************************************************************************
class CAccumulatedPermissions
{
    CTLink<CSubObjectPerm>* m_pSubObjectsHead;
    CTLink<CSubObjectPerm>* m_pSubObjectsTail;

    CTLink<CDSObject>* m_pDSObjectsHead;
    CTLink<CDSObject>* m_pDSObjectsTail;

    bool m_bInitialized;

public:
    CAccumulatedPermissions(POBJECT_TYPE_LIST pObjectTypeList,
                            DWORD ObjectTypeListLength);
    ~CAccumulatedPermissions();
    void ProcessAceMask(DWORD dwMask, EPermission permission, GUID* pGuid);
    DWORD GetAccumulatedPermissions();
    bool AnyDenied();

    bool Initialized(){return m_bInitialized;}
};

//******************************************************************************
//
// Function:    CAccumulatedPermissions::CAccumulatedPermissions
//
// Description:
//
// Parameters:
//
// Return:
//
// History:             10/25/99          leonardm        Created.
//
//******************************************************************************
CAccumulatedPermissions::CAccumulatedPermissions(   POBJECT_TYPE_LIST pObjectTypeList,
                                                    DWORD ObjectTypeListLength) :
                                                    m_pSubObjectsHead(NULL),
                                                    m_pSubObjectsTail(NULL),
                                                    m_bInitialized(false),
                                                    m_pDSObjectsHead(NULL),
                                                    m_pDSObjectsTail(NULL)
{

    if(!pObjectTypeList || ObjectTypeListLength == 0)
    {
        XPtrST<CSubObjectPerm>xpSubObjectPerm = new CSubObjectPerm;
        if(!xpSubObjectPerm)
        {
            return;
        }

        m_pSubObjectsHead = new CTLink<CSubObjectPerm>(xpSubObjectPerm);
        if(!m_pSubObjectsHead)
        {
            return;
        }
        xpSubObjectPerm.Acquire();

        m_pSubObjectsTail = m_pSubObjectsHead;

        m_bInitialized = true;

        return;
    }


        DWORD dwCurrentLevel;

    for(DWORD i = 0; i < ObjectTypeListLength; i++)
    {
        if( i==0 )
        {
            //
            // This assumes that the first element in the list of
            // OBJECT_TYPEs pointed to by pObjectTypeList is at
            // level ACCESS_OBJECT_GUID.
            //

            dwCurrentLevel = pObjectTypeList[i].Level;

            XPtrST<CDSObject>xpDSObject = new CDSObject;
            if(!xpDSObject)
            {
                return;
            }

            XPtrST<GUID>xpGuid = new GUID(*(pObjectTypeList[i].ObjectType));
            if(!xpGuid)
            {
                return;
            }

            m_pDSObjectsHead = new CTLink<CDSObject>(xpDSObject);
            if(!m_pDSObjectsHead)
            {
                return;
            }

            xpDSObject.Acquire();

            m_pDSObjectsHead->m_pData->m_pGuid = xpGuid.Acquire();

            m_pDSObjectsHead->m_pData->m_dwLevel = pObjectTypeList[i].Level;

            m_pDSObjectsTail = m_pDSObjectsHead;

            continue;
        }

        else if(pObjectTypeList[i].Level > dwCurrentLevel)
        {
            dwCurrentLevel = pObjectTypeList[i].Level;

            XPtrST<CDSObject> xpDSObject = new CDSObject;
            if(!xpDSObject)
            {
                return;
            }

            XPtrST<GUID>xpGuid = new GUID(*(pObjectTypeList[i].ObjectType));
            if(!xpGuid)
            {
                return;
            }

            CTLink<CDSObject>* pDSObjectLink = new CTLink<CDSObject>(xpDSObject);
            if(!pDSObjectLink)
            {
                return;
            }

            xpDSObject.Acquire();

            pDSObjectLink->m_pData->m_pGuid = xpGuid.Acquire();
            pDSObjectLink->m_pData->m_dwLevel = pObjectTypeList[i].Level;

            pDSObjectLink->m_pPrev = m_pDSObjectsTail;
            m_pDSObjectsTail->m_pNext = pDSObjectLink;
            m_pDSObjectsTail = pDSObjectLink;
        }

        else
        {
            XPtrST<CSubObjectPerm>xpSubObjectPerm = new CSubObjectPerm;
            if(!xpSubObjectPerm)
            {
                return;
            }

            CTLink<CSubObjectPerm>* pSubObjectLink = new CTLink<CSubObjectPerm>(xpSubObjectPerm);
            if(!pSubObjectLink)
            {
                return;
            }

            xpSubObjectPerm.Acquire();


            CTLink<CDSObject>* pLinkIterator = m_pDSObjectsHead;
            while(pLinkIterator)
            {
                XPtrST<GUID>xpGuid = new GUID(*(pLinkIterator->m_pData->m_pGuid));
                if(!xpGuid)
                {
                    delete pSubObjectLink;
                    return;
                }

                if(FAILED(pSubObjectLink->m_pData->AddGuid(xpGuid)))
                {
                    delete pSubObjectLink;
                    return;
                }

                xpGuid.Acquire();

                pLinkIterator = pLinkIterator->m_pNext;
            }

            if(!m_pSubObjectsHead)
            {
                m_pSubObjectsHead = pSubObjectLink;
            }
            else
            {
                m_pSubObjectsTail->m_pNext = pSubObjectLink;
            }
            m_pSubObjectsTail = pSubObjectLink;


            pLinkIterator = m_pDSObjectsTail;

            if(pLinkIterator)
            {
                while(pLinkIterator->m_pData->m_dwLevel >= pObjectTypeList[i].Level)
                {
                    CTLink<CDSObject>* pLinkToDelete = pLinkIterator;
                    pLinkIterator = pLinkIterator->m_pPrev;
                    delete pLinkToDelete;
                    m_pDSObjectsTail = pLinkIterator;
                    if(m_pDSObjectsTail)
                    {
                        m_pDSObjectsTail->m_pNext = NULL;
                    }
                }
            }

            XPtrST<CDSObject>xpDSObject = new CDSObject;
            if(!xpDSObject)
            {
                return;
            }

            XPtrST<GUID>xpGuid = new GUID(*(pObjectTypeList[i].ObjectType));
            if(!xpGuid)
            {
                return;
            }

            CTLink<CDSObject>* pLink = new CTLink<CDSObject>(xpDSObject);
            if(!pLink)
            {
                return;
            }

            xpDSObject.Acquire();

            pLink->m_pData->m_pGuid = xpGuid.Acquire();
            pLink->m_pData->m_dwLevel = pObjectTypeList[i].Level;

            pLink->m_pPrev = m_pDSObjectsTail;
            m_pDSObjectsTail->m_pNext = pLink;
            m_pDSObjectsTail = pLink;
        }
    }

    CTLink<CDSObject>* pLinkIterator = m_pDSObjectsHead;

    if(pLinkIterator)
    {
        XPtrST<CSubObjectPerm>xpSubObject = new CSubObjectPerm;
        if(!xpSubObject)
        {
            return;
        }

        CTLink<CSubObjectPerm>* pSubObjectLink = new CTLink<CSubObjectPerm>(xpSubObject);
        if(!pSubObjectLink)
        {
            return;
        }

        xpSubObject.Acquire();

        while(pLinkIterator)
        {
            XPtrST<GUID>xpGuid = new GUID(*(pLinkIterator->m_pData->m_pGuid));
            if(!xpGuid)
            {
                delete pSubObjectLink;
                return;
            }

            if(FAILED(pSubObjectLink->m_pData->AddGuid(xpGuid)))
            {
                delete pSubObjectLink;
                return;
            }

            xpGuid.Acquire();

            pLinkIterator = pLinkIterator->m_pNext;
        }

        if(!m_pSubObjectsHead)
        {
            m_pSubObjectsHead = pSubObjectLink;
        }
        else
        {
            m_pSubObjectsTail->m_pNext = pSubObjectLink;
        }
        m_pSubObjectsTail = pSubObjectLink;
    }

    pLinkIterator = m_pDSObjectsHead;

    while(pLinkIterator)
    {
        CTLink<CDSObject>* pLinkToDelete = pLinkIterator;
        pLinkIterator = pLinkIterator->m_pNext;
        delete pLinkToDelete;
    }

    m_pDSObjectsHead = m_pDSObjectsTail = NULL;

    m_bInitialized = true;
}

//******************************************************************************
//
// Function:    CAccumulatedPermissions::~CAccumulatedPermissions
//
// Description:
//
// Parameters:
//
// Return:
//
// History:             10/25/99          leonardm        Created.
//
//******************************************************************************
CAccumulatedPermissions::~CAccumulatedPermissions()
{
    CTLink<CSubObjectPerm>* pSubObjectLinkIterator = m_pSubObjectsHead;
    while(pSubObjectLinkIterator)
    {
        CTLink<CSubObjectPerm>* pSubObjectLinkToDelete = pSubObjectLinkIterator;
        pSubObjectLinkIterator = pSubObjectLinkIterator->m_pNext;
        delete pSubObjectLinkToDelete;
    }

    CTLink<CDSObject>* pDSObjectLinkIterator = m_pDSObjectsHead;

    while(pDSObjectLinkIterator)
    {
        CTLink<CDSObject>* pDSObjectLinkToDelete = pDSObjectLinkIterator;
        pDSObjectLinkIterator = pDSObjectLinkIterator->m_pNext;
        delete pDSObjectLinkToDelete;
    }
}

//******************************************************************************
//
// Function:    CAccumulatedPermissions::ProcessAceMask
//
// Description:
//
// Parameters:
//
// Return:
//
// History:             8/8/99          leonardm        Created.
//
//******************************************************************************
void CAccumulatedPermissions::ProcessAceMask(DWORD dwMask, EPermission permission, GUID* pGuid)
{
    CTLink<CSubObjectPerm>* pLinkIterator = m_pSubObjectsHead;
    while(pLinkIterator)
    {
        pLinkIterator->m_pData->ProcessAceMask(dwMask, permission, pGuid);
        pLinkIterator = pLinkIterator->m_pNext;
    }
}

//******************************************************************************
//
// Function:    CAccumulatedPermissions::AccumulatedPermissions
//
// Description:
//
// Parameters:
//
// Return:
//
// History:             8/8/99          leonardm        Created.
//
//******************************************************************************
DWORD CAccumulatedPermissions::GetAccumulatedPermissions()
{

    DWORD dwAccumulatedPermissions = 0x01FFFFFF;

    CTLink<CSubObjectPerm>* pLinkIterator = m_pSubObjectsHead;
    while(pLinkIterator)
    {
        dwAccumulatedPermissions &= pLinkIterator->m_pData->GetAccumulatedPermissions();
        pLinkIterator = pLinkIterator->m_pNext;
    }

    return dwAccumulatedPermissions;
}


//******************************************************************************
//
// Function:    CAccumulatedPermissions::AnyDenied
//
// Description:
//
// Parameters:
//
// Return:
//
// History:             8/8/99          leonardm        Created.
//
//******************************************************************************
bool CAccumulatedPermissions::AnyDenied()
{
    CTLink<CSubObjectPerm>* pLinkIterator = m_pSubObjectsHead;
    while(pLinkIterator)
    {
        if(pLinkIterator->m_pData->AnyDenied())
        {
            return true;
        }

        pLinkIterator = pLinkIterator->m_pNext;
    }

    return false;
}


//******************************************************************************
//
// Function:    LogGuid
//
// Description:
//
// Parameters:
//
// Return:      void
//
// History:     10/26/99      leonardm        Created.
//
//******************************************************************************
void LogGuid(GUID& guid)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogGuid - Entering.");

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogGuid - {0x%08x 0x%04x 0x%04x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x}",
                                                    guid.Data1,
                                                    guid.Data2,
                                                    guid.Data3,
                                                    guid.Data4[0],
                                                    guid.Data4[1],
                                                    guid.Data4[2],
                                                    guid.Data4[3],
                                                    guid.Data4[4],
                                                    guid.Data4[5],
                                                    guid.Data4[6],
                                                    guid.Data4[7]);

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogGuid - (%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x)",
                                                    guid.Data1,
                                                    guid.Data2,
                                                    guid.Data3,
                                                    guid.Data4[0],
                                                    guid.Data4[1],
                                                    guid.Data4[2],
                                                    guid.Data4[3],
                                                    guid.Data4[4],
                                                    guid.Data4[5],
                                                    guid.Data4[6],
                                                    guid.Data4[7]);

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogGuid - Leaving.");
}


//******************************************************************************
//
// Function:    LogSid
//
// Description:
//
// Parameters:
//
// Return:      void
//
// History:     10/26/99      leonardm        Created.
//
//******************************************************************************
void LogSid(PSID pSid)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Entering.");

    XPtrST<CSid>xpCSid = new CSid(pSid);

    if(!xpCSid)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"LogSid - Call to operator new failed.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Leaving.");
        return;
    }

    if(!(xpCSid->IsValid()))
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"LogSid - call to CSid::IsValid returned false.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Leaving.");
        return;
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid string: %s.", xpCSid->SidString());

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid User: %s.", xpCSid->User());

    if(xpCSid->SidType() == SidTypeUser)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeUser.");
    }
    else if(xpCSid->SidType() == SidTypeGroup)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeGroup.");
    }
    else if(xpCSid->SidType() == SidTypeDomain)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeDomain.");
    }
    else if(xpCSid->SidType() == SidTypeAlias)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeAlias.");
    }
    else if(xpCSid->SidType() == SidTypeWellKnownGroup)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeWellKnownGroup.");
    }
    else if(xpCSid->SidType() == SidTypeDeletedAccount)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeDeletedAccount.");
    }
    else if(xpCSid->SidType() == SidTypeInvalid)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeInvalid.");
    }
    else if(xpCSid->SidType() == SidTypeUnknown)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeUnknown.");
    }
    else if(xpCSid->SidType() == SidTypeComputer)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeComputer.");
    }
    else
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"LogSid - Sid type: UNKNOWN SID type.");
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid Domain: %s.", xpCSid->Domain());
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid Computer: %s.", xpCSid->Computer());

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Leaving.");
}


//******************************************************************************
//
// Function:    LogAce
//
// Description:
//
// Parameters:
//
// Return:      void
//
// History:     10/26/99      leonardm        Created.
//
//******************************************************************************
void LogAce(PACE_HEADER pAceHeader)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Entering.");

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - AceType = 0x%08X.", pAceHeader->AceType);


    PACCESS_ALLOWED_ACE pACCESS_ALLOWED_ACE = NULL;
    PACCESS_ALLOWED_OBJECT_ACE pACCESS_ALLOWED_OBJECT_ACE = NULL;

    PACCESS_DENIED_ACE pACCESS_DENIED_ACE = NULL;
    PACCESS_DENIED_OBJECT_ACE pACCESS_DENIED_OBJECT_ACE = NULL;

    PSYSTEM_AUDIT_ACE pSYSTEM_AUDIT_ACE = NULL;
    PSYSTEM_AUDIT_OBJECT_ACE pSYSTEM_AUDIT_OBJECT_ACE = NULL;

    PSYSTEM_ALARM_ACE pSYSTEM_ALARM_ACE = NULL;
    PSYSTEM_ALARM_OBJECT_ACE pSYSTEM_ALARM_OBJECT_ACE = NULL;

    switch(pAceHeader->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE type: ACCESS_ALLOWED_ACE_TYPE");
        pACCESS_ALLOWED_ACE = reinterpret_cast<PACCESS_ALLOWED_ACE>(pAceHeader);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE Mask: 0x%08X", pACCESS_ALLOWED_ACE->Mask);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE type: ACCESS_ALLOWED_OBJECT_ACE_TYPE");
        pACCESS_ALLOWED_OBJECT_ACE = reinterpret_cast<PACCESS_ALLOWED_OBJECT_ACE>(pAceHeader);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE Mask: 0x%08X", pACCESS_ALLOWED_OBJECT_ACE->Mask);

        if(pACCESS_ALLOWED_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT)
        {
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Flag is on: ACE_OBJECT_TYPE_PRESENT.");
            LogGuid(pACCESS_ALLOWED_OBJECT_ACE->ObjectType);
        }

        if(pACCESS_ALLOWED_OBJECT_ACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
        {
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Flag is on: ACE_INHERITED_OBJECT_TYPE_PRESENT.");
            LogGuid(pACCESS_ALLOWED_OBJECT_ACE->InheritedObjectType);
        }
        break;

    case ACCESS_DENIED_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE type: ACCESS_DENIED_ACE_TYPE");
        pACCESS_DENIED_ACE = reinterpret_cast<PACCESS_DENIED_ACE>(pAceHeader);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE Mask: 0x%08X", pACCESS_DENIED_ACE->Mask);
        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE type: ACCESS_DENIED_OBJECT_ACE_TYPE");
        pACCESS_DENIED_OBJECT_ACE = reinterpret_cast<PACCESS_DENIED_OBJECT_ACE>(pAceHeader);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE Mask: 0x%08X", pACCESS_DENIED_OBJECT_ACE->Mask);

        if(pACCESS_DENIED_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT)
        {
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Flag is on: ACE_OBJECT_TYPE_PRESENT.");
            LogGuid(pACCESS_DENIED_OBJECT_ACE->ObjectType);
        }

        if(pACCESS_DENIED_OBJECT_ACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
        {
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Flag is on: ACE_INHERITED_OBJECT_TYPE_PRESENT.");
            LogGuid(pACCESS_DENIED_OBJECT_ACE->InheritedObjectType);
        }
        break;

    case SYSTEM_AUDIT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE type: SYSTEM_AUDIT_ACE_TYPE");
        pSYSTEM_AUDIT_ACE = reinterpret_cast<PSYSTEM_AUDIT_ACE>(pAceHeader);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE Mask: 0x%08X", pSYSTEM_AUDIT_ACE->Mask);
        break;

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE type: SYSTEM_AUDIT_OBJECT_ACE_TYPE");
        pSYSTEM_AUDIT_OBJECT_ACE = reinterpret_cast<PSYSTEM_AUDIT_OBJECT_ACE>(pAceHeader);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE Mask: 0x%08X", pSYSTEM_AUDIT_OBJECT_ACE->Mask);

        if(pSYSTEM_AUDIT_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT)
        {
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Flag is on: ACE_OBJECT_TYPE_PRESENT.");
            LogGuid(pSYSTEM_AUDIT_OBJECT_ACE->ObjectType);
        }

        if(pSYSTEM_AUDIT_OBJECT_ACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
        {
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Flag is on: ACE_INHERITED_OBJECT_TYPE_PRESENT.");
            LogGuid(pSYSTEM_AUDIT_OBJECT_ACE->InheritedObjectType);
        }
        break;

    case SYSTEM_ALARM_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE type: SYSTEM_ALARM_ACE_TYPE");
        pSYSTEM_ALARM_ACE = reinterpret_cast<PSYSTEM_ALARM_ACE>(pAceHeader);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE Mask: 0x%08X", pSYSTEM_ALARM_ACE->Mask);
        break;

    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE type: SYSTEM_ALARM_OBJECT_ACE_TYPE");
        pSYSTEM_ALARM_OBJECT_ACE = reinterpret_cast<PSYSTEM_ALARM_OBJECT_ACE>(pAceHeader);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE Mask: 0x%08X", pSYSTEM_ALARM_OBJECT_ACE->Mask);

        if(pSYSTEM_ALARM_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT)
        {
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Flag is on: ACE_OBJECT_TYPE_PRESENT.");
            LogGuid(pSYSTEM_ALARM_OBJECT_ACE->ObjectType);
        }

        if(pSYSTEM_ALARM_OBJECT_ACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
        {
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Flag is on: ACE_INHERITED_OBJECT_TYPE_PRESENT.");
            LogGuid(pSYSTEM_ALARM_OBJECT_ACE->InheritedObjectType);
        }
        break;

    default:
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"LogAce - ACE type: UNKNOWN ACE type.");
        break;
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - AceFlags = 0x%08X.", pAceHeader->AceFlags);

    if(pAceHeader->AceFlags & OBJECT_INHERIT_ACE)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - The Following ACE header flag is on: OBJECT_INHERIT_ACE.");
    }

    if(pAceHeader->AceFlags & CONTAINER_INHERIT_ACE)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - The Following ACE header flag is on: CONTAINER_INHERIT_ACE.");
    }

    if(pAceHeader->AceFlags & NO_PROPAGATE_INHERIT_ACE)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - The Following ACE header flag is on: NO_PROPAGATE_INHERIT_ACE.");
    }

    if(pAceHeader->AceFlags & INHERIT_ONLY_ACE)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - The Following ACE header flag is on: INHERIT_ONLY_ACE.");
    }

    if(pAceHeader->AceFlags & INHERITED_ACE)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - The Following ACE header flag is on: INHERITED_ACE.");
    }

    if(pAceHeader->AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - The Following ACE header flag is on: SUCCESSFUL_ACCESS_ACE_FLAG.");
    }

    if(pAceHeader->AceFlags & FAILED_ACCESS_ACE_FLAG)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - The Following ACE header flag is on: FAILED_ACCESS_ACE_FLAG.");
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - AceSize = 0x%08X.", pAceHeader->AceSize);


    PISID pSid = GetAceSid(pAceHeader);
    if(!pSid)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"LogAce - Call to GetAceSid failed.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Leaving.");
        return;
    }

    LogSid(pSid);

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Leaving.");
}

//******************************************************************************
//
// Function:    ProcessAce
//
// Description:
//
// Parameters:
//
// Return:              S_OK on success. An HRESULT error code on failure.
//
// History:             8/8/99          leonardm        Created.
//
//******************************************************************************
HRESULT ProcessAce( PACE_HEADER pAceHeader,
                    PRSOPTOKEN pRsopToken,
                    POBJECT_TYPE_LIST pObjectTypeList,
                    DWORD ObjectTypeListLength,
                    DWORD dwDesiredAccessMask,
                    CAccumulatedPermissions& accumulatedPermissions,
                    bool* pbAccessExplicitlyDenied)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Entering.");

    //
    // Check parameters.
    //

    if( !pAceHeader || !pRsopToken ||
        (ObjectTypeListLength && !pObjectTypeList) ||
        !pbAccessExplicitlyDenied)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"ProcessAce - Invalid argument(s).");
        return E_FAIL;
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Desired Access Mask: 0x%08X.", dwDesiredAccessMask);
    if(dwDesiredAccessMask == MAXIMUM_ALLOWED)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Desired Access Mask == MAXIMUM_ALLOWED.");
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Accumulated Permissions BEFORE Processing Ace: 0x%08X.", accumulatedPermissions.GetAccumulatedPermissions());


    //
    // Log ACE information
    //

    LogAce(pAceHeader);

    *pbAccessExplicitlyDenied = false;

    //
    // ACEs with INHERIT_ONLY_ACE flag do no control access to the current object.
    // Therefore, we ignore them.
    //

    if(pAceHeader->AceFlags & INHERIT_ONLY_ACE)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Found ACE with INHERIT_ONLY_ACE flag. Ace does not apply.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Leaving.");
        return S_OK;
    }

    //
    // If this ACE does not reference any of the SIDs contained in the RsopToken,
    // we ignore it.
    //

    bool bAceApplies;
    HRESULT hr = CheckAceApplies(pAceHeader, pRsopToken, &bAceApplies);
    if(FAILED(hr))
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"ProcessAce - CheckAceApplies failed. Return code: 0x%08X", hr);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Leaving.");
        return hr;
    }

    if(!bAceApplies)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - ACE does not apply.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Leaving.");
        return S_OK;
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - ACE aplies.");

    PACCESS_ALLOWED_ACE pACCESS_ALLOWED_ACE;
    PACCESS_ALLOWED_OBJECT_ACE pACCESS_ALLOWED_OBJECT_ACE;
    PACCESS_DENIED_ACE pACCESS_DENIED_ACE;
    PACCESS_DENIED_OBJECT_ACE pACCESS_DENIED_OBJECT_ACE;

    DWORD i;
    DWORD dwMask;
    switch(pAceHeader->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - ACE type: ACCESS_ALLOWED_ACE_TYPE");
        pACCESS_ALLOWED_ACE = reinterpret_cast<PACCESS_ALLOWED_ACE>(pAceHeader);

        //
        // If the requested access is MAXIMUM_ALLOWED, consider all bits in the Mask
        // controlled by this ACE.
        // Otherwise, consider only those bits that are also specified in the
        // desired access mask.
        //

        if(dwDesiredAccessMask == MAXIMUM_ALLOWED)
        {
            dwMask = pACCESS_ALLOWED_ACE->Mask;
        }
        else
        {
            dwMask = dwDesiredAccessMask & pACCESS_ALLOWED_ACE->Mask;
        }

        accumulatedPermissions.ProcessAceMask(  dwMask,
                                                PERMISSION_ALLOWED,
                                                NULL);

        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - ACE type: ACCESS_ALLOWED_OBJECT_ACE_TYPE");
        pACCESS_ALLOWED_OBJECT_ACE = reinterpret_cast<PACCESS_ALLOWED_OBJECT_ACE>(pAceHeader);


        //
        // We have chosen to process only those object ACEs that have
        // the flag ACE_OBJECT_TYPE_PRESENT set.
        //

        if(pACCESS_ALLOWED_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT)
        {


            //
            // Notice that if this function is invoked with no
            // ObjectTypeList, object ACEs are disregarded.
            //

            for(i = 0; i < ObjectTypeListLength; i++)
            {
                POBJECT_TYPE_LIST pObjectType = &(pObjectTypeList[i]);
                if(*(pObjectType->ObjectType) == pACCESS_ALLOWED_OBJECT_ACE->ObjectType)
                {
                    //
                    // If the requested access is MAXIMUM_ALLOWED, consider all bits in the Mask
                    // controlled by this ACE.
                    // Otherwise, consider only those bits that are also specified in the
                    // desired access mask.
                    //

                    if(dwDesiredAccessMask == MAXIMUM_ALLOWED)
                    {
                        dwMask = pACCESS_ALLOWED_OBJECT_ACE->Mask;
                    }
                    else
                    {
                        dwMask = dwDesiredAccessMask & pACCESS_ALLOWED_OBJECT_ACE->Mask;
                    }

                    accumulatedPermissions.ProcessAceMask(  dwMask,
                                                            PERMISSION_ALLOWED,
                                                            &(pACCESS_ALLOWED_OBJECT_ACE->ObjectType));

                    break;
                }
            }
        }

        break;

    case ACCESS_DENIED_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - ACE type: ACCESS_DENIED_ACE_TYPE");
        pACCESS_DENIED_ACE = reinterpret_cast<PACCESS_DENIED_ACE>(pAceHeader);


        //
        // If the requested access is MAXIMUM_ALLOWED, consider all bits in the Mask
        // controlled by this ACE.
        // Otherwise, consider only those bits that are also specified in the
        // desired access mask.
        //

        if(dwDesiredAccessMask == MAXIMUM_ALLOWED)
        {
            dwMask = pACCESS_DENIED_ACE->Mask;
        }
        else
        {
            dwMask = dwDesiredAccessMask & pACCESS_DENIED_ACE->Mask;
        }

        accumulatedPermissions.ProcessAceMask(  dwMask,
                                                PERMISSION_DENIED,
                                                NULL);

        if(dwDesiredAccessMask != MAXIMUM_ALLOWED)
        {
            if(accumulatedPermissions.AnyDenied())
            {
                *pbAccessExplicitlyDenied = true;
            }
        }

        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - ACE type: ACCESS_DENIED_OBJECT_ACE_TYPE");
        pACCESS_DENIED_OBJECT_ACE = reinterpret_cast<PACCESS_DENIED_OBJECT_ACE>(pAceHeader);


        //
        // We have chosen to process only those object ACEs that have
        // the flag ACE_OBJECT_TYPE_PRESENT set.
        //

        if(pACCESS_DENIED_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT)
        {


            //
            // Notice that if this function is invoked with no
            // ObjectTypeList, object ACEs are disregarded.
            //

            for(i = 0; i < ObjectTypeListLength; i++)
            {
                POBJECT_TYPE_LIST pObjectType = &(pObjectTypeList[i]);
                if(*(pObjectType->ObjectType) == pACCESS_DENIED_OBJECT_ACE->ObjectType)
                {
                    //
                    // If the requested access is MAXIMUM_ALLOWED, consider all bits in the Mask
                    // controlled by this ACE.
                    // Otherwise, consider only those bits that are also specified in the
                    // desired access mask.
                    //

                    if(dwDesiredAccessMask == MAXIMUM_ALLOWED)
                    {
                        dwMask = pACCESS_DENIED_OBJECT_ACE->Mask;
                    }
                    else
                    {
                        dwMask = dwDesiredAccessMask & pACCESS_DENIED_OBJECT_ACE->Mask;
                    }

                    accumulatedPermissions.ProcessAceMask(  dwMask,
                                                            PERMISSION_DENIED,
                                                            &(pACCESS_DENIED_OBJECT_ACE->ObjectType));

                    if(dwDesiredAccessMask != MAXIMUM_ALLOWED)
                    {
                        if(accumulatedPermissions.AnyDenied())
                        {
                            *pbAccessExplicitlyDenied = true;
                        }
                    }

                    break;
                }
            }
        }

        break;

    default:
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"ProcessAce - Unexpected ACE type found in ACE header. Type: 0x%08x", pAceHeader->AceType);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Leaving.");
        return E_FAIL;
        break;
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Accumulated Permissions AFTER Processing Ace: 0x%08X.", accumulatedPermissions.GetAccumulatedPermissions());

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Leaving.");

    return S_OK;
}

//******************************************************************************
//
// Function:    RsopAccessCheckByType
//
// Description:
//
// Parameters:          - pSecurityDescriptor,
//                      - pPrincipalSelfSid:
//                      - pRsopToken:
//                      - dwDesiredAccessMask:
//                      - pObjectTypeList:
//                      - ObjectTypeListLength:
//                      - pGenericMapping:
//                      - pPrivilegeSet:
//                      - pdwPrivilegeSetLength:
//                      - pdwGrantedAccessMask:
//                      - pbAccessStatus:
//
// Return:              S_OK on success. An HRESULT error code on failure.
//
// History:             7/30/99         leonardm        Created.
//
//******************************************************************************
HRESULT RsopAccessCheckByType(  PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                PSID pPrincipalSelfSid,
                                PRSOPTOKEN pRsopToken,
                                DWORD dwDesiredAccessMask,
                                POBJECT_TYPE_LIST pObjectTypeList,
                                DWORD ObjectTypeListLength,
                                PGENERIC_MAPPING pGenericMapping,
                                PPRIVILEGE_SET pPrivilegeSet,
                                LPDWORD pdwPrivilegeSetLength,
                                LPDWORD pdwGrantedAccessMask,
                                LPBOOL pbAccessStatus)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Entering.");


    //
    // Check arguments.
    //

    if( !pSecurityDescriptor |
        !IsValidSecurityDescriptor(pSecurityDescriptor) |
        !pRsopToken |
        !pGenericMapping |
        !pdwGrantedAccessMask |
        !pbAccessStatus)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopAccessCheckByType - Function invoked with invalid arguments.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");
        return E_INVALIDARG;
    }


    //
    // Get the DACL from the Security Descriptor
    //

    BOOL bDaclPresent;
    PACL pDacl;
    BOOL bDaclDefaulted;
    if(!GetSecurityDescriptorDacl(pSecurityDescriptor, &bDaclPresent, &pDacl, &bDaclDefaulted))
    {
        DWORD dwLastError = GetLastError();
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopAccessCheckByType - GetSecurityDescriptorDacl failed. GetLastError=0x%08X", dwLastError);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");
        return E_FAIL;
    }


    //
    // Map generic rights specified in dwDesiredAccessMask to standard
    // and specific rights.
    // This is necessary because the ACEs in the DACL specify standard
    // and specific rights only.
    //

    if(dwDesiredAccessMask != MAXIMUM_ALLOWED)
    {
        MapGenericMask(&dwDesiredAccessMask, pGenericMapping);
    }


    //
    // If no DACL is present (as indicated by bDaclPresent) in the security descriptor,
    // or if it present (as indicated by bDaclPresent) but it is a NULL DACL
    // the object implicitly grants all access.
    //

    if(!bDaclPresent || pDacl == NULL)
    {
        if(dwDesiredAccessMask == MAXIMUM_ALLOWED)
        {
            *pdwGrantedAccessMask = pGenericMapping->GenericAll |
                                    pGenericMapping->GenericExecute |
                                    pGenericMapping->GenericRead |
                                    pGenericMapping->GenericWrite;
        }
        else
        {
            *pdwGrantedAccessMask = dwDesiredAccessMask;
        }
        *pbAccessStatus = TRUE;
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - No DACL present. All access is granted.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");
        return S_OK;
    }

    DWORD dwAceCount = pDacl->AceCount;


    //
    // If the DACL is present but it is empty,
    // the object implicitly denies access to everyone.
    //

    if(!dwAceCount)
    {
        *pdwGrantedAccessMask = 0;
        *pbAccessStatus = FALSE;
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - The DACL is present but it is empty. All access is denied.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");
        return S_OK;
    }


    //
    // At this point we have an array of ACES structures
    //
    // If the desired access is different from MAXIMUM_ALLOWED,
    // inspect them until one of the following happens:
    //
    //      1. An ACE is found which explicitly denies one of the requested
    //      access rights. In this case checking stops immediately and
    //      access is (explicitly) denied.
    //
    //      2. All the requested accesses are explicitly granted by one or
    //      more ACEs. In this case checking stops immediately and
    //      access is (explicitly) allowed.
    //
    //
    //      3. All the ACEs have been inspected inspected and there is at least
    //      one requested access right that has not been explicitly allowed.
    //      In this case, access is (implicitly) denied.
    //
    // If the desired access is MAXIMUM_ALLOWED, inspect all the ACEs.
    //

    PISID pSid;
    BYTE* pByte;

    CAccumulatedPermissions accumulatedPermissions( pObjectTypeList, ObjectTypeListLength);

    if(!accumulatedPermissions.Initialized())
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopAccessCheckByType - CAccumulatedPermissions failed to initialize.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");
        return E_FAIL;
    }



    *pdwGrantedAccessMask = 0;
    *pbAccessStatus = FALSE;


    //
    // Log SID information contained in the RsopToken.
    //

    CRsopToken* pToken  = static_cast<CRsopToken*>(pRsopToken);
    for(CTLink<CSid>* pLink = pToken->m_pSidsHead; pLink; pLink = pLink->m_pNext)
    {
        LogSid(pLink->m_pData->GetSidPtr());
    }


    //
    // The first ACE immediately follows the DACL structure. We don't know up front
    // the type of ACE so we get the ACE header which has a format common to all
    // ACE types.
    //

    PACE_HEADER pAceHeader = reinterpret_cast<PACE_HEADER>(pDacl+1);

    for(DWORD i=0; i<dwAceCount; i++)
    {
        bool bAccessExplicitlyDenied;
        HRESULT hr = ProcessAce(pAceHeader,
                                pRsopToken,
                                pObjectTypeList,
                                ObjectTypeListLength,
                                dwDesiredAccessMask,
                                accumulatedPermissions,
                                &bAccessExplicitlyDenied);

        if(FAILED(hr))
        {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopAccessCheckByType - ProcessAce failed. Return code: 0x%08X", hr);
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");
            return hr;
        }


        //
        // If, this ACE explicitly denies any of the requested access rights,
        // stop immediately. Access is denied.
        // ProcessAce will never set this variable to true when dwDesiredAccessMask
        // is MAXIMUM_ALLOWED.
        //

        if(bAccessExplicitlyDenied)
        {
            *pdwGrantedAccessMask = 0;
            *pbAccessStatus = FALSE;
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - An ACE explicitly denies any of the requested access rights. Access is denied.");
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");
            return S_OK;
        }


        //
        // If, after processing this ACE all requested access rights have been granted,
        // stop immediately. Access is granted.
        //

        DWORD dwAccumulatedPermissions = accumulatedPermissions.GetAccumulatedPermissions();
        if((dwDesiredAccessMask != MAXIMUM_ALLOWED) && (dwAccumulatedPermissions == dwDesiredAccessMask))
        {
            *pdwGrantedAccessMask = dwDesiredAccessMask;
            *pbAccessStatus = TRUE;
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - dwDesiredAccessMask != MAXIMUM_ALLOWED && dwAccumulatedPermissions == dwDesiredAccessMask. Access is granted.");
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");
            return S_OK;
        }


        //
        // Otherwise, point to the next ACE.
        //

        pAceHeader = reinterpret_cast<PACE_HEADER>(reinterpret_cast<BYTE*>(pAceHeader) + pAceHeader->AceSize);
    }

    if(dwDesiredAccessMask == MAXIMUM_ALLOWED)
    {
        *pdwGrantedAccessMask = accumulatedPermissions.GetAccumulatedPermissions();
        *pbAccessStatus = *pdwGrantedAccessMask ? TRUE : FALSE;
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");

    return S_OK;
}

//******************************************************************************
//
// Function:    RsopFileAccessCheck
//
// Description: Determines whether the security descriptor pointed to by pSecurityDescriptor
//              grants the set of file access rights specified in dwDesiredAccessMask
//              to the client identified by the RSOPTOKEN pointed to by pRsopToken.
//
// Parameters:  - pszFileName:          Pointer to an existing filename.
//              - pRsopToken:           Pointer to a valid RSOPTOKEN against which access
//                                      is to be checked.
//              - dwDesiredAccessMask:  Mask of requested generic and/or standard and/or specific access rights,
//              - pdwGrantedAccessMask: On success, if pbAccessStatus is true, it contains
//                                      the mask of standard and specific rights granted.
//                                      If pbAccessStatus is false, it is set to 0.
//                                      On failure, it is not modified.
//              - pbAccessStatus:       On success, indicates wether the requested set
//                                      of access rights was granted.
//                                      On failure, it is not modified
//
// Return:      S_OK on success. An HRESULT error code on failure.
//
// History:     7/30/99         leonardm        Created.
//
//******************************************************************************
HRESULT RsopFileAccessCheck(LPTSTR pszFileName,
                            PRSOPTOKEN pRsopToken,
                            DWORD dwDesiredAccessMask,
                            LPDWORD pdwGrantedAccessMask,
                            LPBOOL pbAccessStatus)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopFileAccessCheck - Entering.");


    //
    // Check for invalid arguments.
    //

    if( !pszFileName |!pRsopToken | !pdwGrantedAccessMask | !pbAccessStatus)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopFileAccessCheck - Function called with invalid parameters.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopFileAccessCheck - Leaving.");
        return E_INVALIDARG;
    }


    //
    // Attempt to get a handle with READ_CONTROL access right that can be used to
    // read the security descriptor.
    //

    XHandle hFile = CreateFile( pszFileName,
                                READ_CONTROL,
                                FILE_SHARE_READ|FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL);


    if(hFile == INVALID_HANDLE_VALUE)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopFileAccessCheck - Call to CreateFile failed. Filename: %s. Last error: 0x%08X", pszFileName, GetLastError());
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopFileAccessCheck - Leaving.");
        return E_FAIL;
    }


    //
    // Use the handle to get the security descriptor with only the DACL in it.
    //

    PACL pDacl;
    XPtrLF<SECURITY_DESCRIPTOR>xpSecurityDescriptor = NULL;
    DWORD status = GetSecurityInfo( hFile,
                                    SE_FILE_OBJECT,
                                    DACL_SECURITY_INFORMATION,
                                    NULL,
                                    NULL,
                                    &pDacl,
                                    NULL,
                                    reinterpret_cast<void**>(&xpSecurityDescriptor));

    if(status != ERROR_SUCCESS)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopFileAccessCheck - Call to GetSecurityInfo failed. Return: 0x%08X", status);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopFileAccessCheck - Leaving.");
        return E_FAIL;
    }


    //
    // This will be used by RSOPAccessCheckByType to map generic rights specified in
    // dwDesiredAccessMask to standard and specific rights.
    //

    GENERIC_MAPPING FileGenericMapping;
    FileGenericMapping.GenericRead = FILE_GENERIC_READ;
    FileGenericMapping.GenericWrite = FILE_GENERIC_WRITE;
    FileGenericMapping.GenericExecute = FILE_GENERIC_EXECUTE;
    FileGenericMapping.GenericAll = FILE_ALL_ACCESS;


    //
    // Call RsopAccessCheckByType to do the actual checking.
    //

    HRESULT hr = RsopAccessCheckByType( xpSecurityDescriptor,
                                        NULL,
                                        pRsopToken,
                                        dwDesiredAccessMask,
                                        NULL,
                                        0,
                                        &FileGenericMapping,
                                        NULL,
                                        0,
                                        pdwGrantedAccessMask,
                                        pbAccessStatus);

    if(SUCCEEDED(hr))
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopFileAccessCheck - Leaving successfully.");
    }
    else
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopFileAccessCheck - Call to RsopAccessCheckByType failed. Return: 0x%08X", hr);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopFileAccessCheck - Leaving.");
    }

    return hr;
}

//******************************************************************************
//
// Function:    RsopSidsFromToken
//
// Description:  Returns all the sids in the token
//
// Parameters: pRsopToken -- an rsop token from which to obtain sids
//             ppGroups -- a pointer to the address of a TOKEN_GROUPS structure
//                 that will be allocated by this function and will contain
//                 references to the sids.  The caller should free this
//                 pointer with LocalFree -- this will also free all memory
//                 referenced by the structure.
//
// Return:      S_OK on success. An HRESULT error code on failure.
//
//
//******************************************************************************
HRESULT RsopSidsFromToken(PRSOPTOKEN     pRsopToken,
                          PTOKEN_GROUPS* ppGroups)
{
    HRESULT     hr;
    CRsopToken* pToken;

    //
    // Initializations
    //
    hr = S_OK;
    *ppGroups = NULL;

    pToken = (CRsopToken*) pRsopToken;

    //
    // First, determine the number of groups and the size
    // needed for each sid
    //
    CTLink<CSid>* pCurrent;
    DWORD         cbSize;
    DWORD         cGroups;

    cbSize = 0;
    cGroups = 0;

    //
    // Iterate through each sid, adding its size to the total
    // needed to store the sids
    //
    for ( pCurrent = pToken->m_pSidsHead;
          pCurrent;
          pCurrent = pCurrent->m_pNext)
    {
        cbSize += RtlLengthSid(pCurrent->m_pData->GetSidPtr());
        cGroups++;
    }

    //
    // Add in the size of the fixed portion of the return structure.
    // Note that the fixed portion of the structure already has
    // space for one group, so we exclude that group from the amount
    // neeeded to allocate if we are allocating at least one group
    //
    cbSize += sizeof(TOKEN_GROUPS) + (sizeof(SID_AND_ATTRIBUTES) *
                                      (cGroups - (cGroups ? 1 : 0)));

    //
    // Now allocate space for the groups
    //
    *ppGroups = (PTOKEN_GROUPS) LocalAlloc( LPTR, cbSize );

    if ( !*ppGroups )
    {
        return E_OUTOFMEMORY;
    }

    //
    // Set the count member of the structure
    //
    (*ppGroups)->GroupCount = cGroups;

    //
    // If there are groups, copy the sids
    //
    if ( 0 != cGroups )
    {
        PSID                pCurrentSid;
        PSID_AND_ATTRIBUTES pCurrentGroup;

        //
        // Set the current sid to an offset past the
        // array of SID_AND_ATTRIBUTE structures that
        // represents each group
        //
        pCurrentSid = &((*ppGroups)->Groups[cGroups]);

        //
        // Set the current group to the first SID_AND_ATTRIBUTE structure
        //
        pCurrentGroup = (PSID_AND_ATTRIBUTES) &((*ppGroups)->Groups);

        //
        // We have no information in the rsop token regarding
        // the attributes, so we clear this member
        //
        pCurrentGroup->Attributes = 0;

        //
        // Iterate through each group and copy it
        //
        for (pCurrent = pToken->m_pSidsHead;
             pCurrent;
             pCurrent = pCurrent->m_pNext)
        {
            DWORD    cbSid;
            NTSTATUS Status;

            //
            // Determine the length of the source sid
            //
            cbSid = RtlLengthSid(pCurrent->m_pData->GetSidPtr());

            //
            // Copy the source sid to the current sid
            //
            Status = RtlCopySid(
                cbSid,
                pCurrentSid,
                pCurrent->m_pData->GetSidPtr());

            //
            // Check for errors
            //
            if (STATUS_SUCCESS != Status)
            {
                hr = HRESULT_FROM_WIN32(Status);

                break;
            }

            //
            // Set the current group's sid reference to the
            // current sid
            //
            pCurrentGroup->Sid = pCurrentSid;

            //
            // Move our current sid offset forward by the length of
            // the current sid.  Move our group reference forward as well.
            //
            pCurrentSid = (PSID) (((BYTE*) pCurrentSid) + cbSid);
            pCurrentGroup++;
        }
    }

    //
    // Free any memory on failure and remove
    // any reference to it
    //
    if (FAILED(hr))
    {
        LocalFree(*ppGroups);
        *ppGroups = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\profile\userdiff.h ===
//*************************************************************
//
//   userdiff.h     -   Header file for userdiff.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************


#define USERDIFF            TEXT("UserDiff")
#define USERDIFR_LOCATION   TEXT("%SystemRoot%\\system32\\config\\userdifr")
#define USERDIFF_LOCATION   TEXT("%SystemRoot%\\system32\\config\\userdiff")


//
// Hive processing key words
//

#define UD_ACTION              TEXT("Action")
#define UD_KEYNAME             TEXT("KeyName")
#define UD_VALUE               TEXT("Value")
#define UD_VALUENAME           TEXT("ValueName")
#define UD_VALUENAMES          TEXT("ValueNames")
#define UD_FLAGS               TEXT("Flags")
#define UD_ITEM                TEXT("Item")
#define UD_COMMANDLINE         TEXT("CommandLine")
#define UD_PRODUCTTYPE         TEXT("Product")



#define MAX_BUILD_NUMBER    30

typedef struct _UDNODE {
    TCHAR           szBuildNumber[MAX_BUILD_NUMBER];
    DWORD           dwBuildNumber;
    struct _UDNODE *pNext;
} UDNODE, * LPUDNODE;


#if defined(__cplusplus)
extern "C" {
#endif
BOOL ProcessUserDiff (LPPROFILE lpProfile, DWORD dwBuildNumber, LPVOID pEnv);
#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\rsop\chkacc.h ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:           ChkAcc.h
//
// Description:    RSOP Security functions
//
// History:    31-Jul-99   leonardm    Created
//
//******************************************************************************

#ifndef CHKACC_H__85EE6A51_C327_4453_ACBE_FEC6F0010740__INCLUDED_
#define CHKACC_H__85EE6A51_C327_4453_ACBE_FEC6F0010740__INCLUDED_


#include <windows.h>
#include <accctrl.h>
#include <aclapi.h>
#include <sddl.h>
#include <lm.h>
#include <oaidl.h>
#include <authz.h>

//******************************************************************************
//
// Structure:   CRsopToken
//
// Description: This reprents a pseudo-token containing an arbitrary
//              combination of SIDs which
//              can be used to check access to objects protected with security descriptors.
//
// History:     7/30/99 leonardm Created.
//
//******************************************************************************

#if defined(__cplusplus)
extern "C"{
#endif

typedef void* PRSOPTOKEN;

//******************************************************************************
//
// Function:    RsopCreateToken
//
// Description: Creates a pseudo-token using an exisitng user or machine account plus
//              the accounts of which that user is currently a member of.
//              The returned pseudo-token can be used subsequently in call
//              to other RSOP security functions to check access to
//              objects protected by security descriptors.
//
// Parameters:  - accountName: Pointer to a user or machine account name.
//              - psaSecurity: Pointer ta SAFEARRAY of BSTRs representing
//                             security groups.
//                             If NULL, then all the current security groups for the
//                             szaccountName are added to the RsopToken.
//                             If not NULL but pointing to an empty array,
//                             only the szaccountName is added to the RsopToken.
//              - ppRsopToken:  Address of a PRSOPTOKEN that receives the newly
//                              created pseudo-token
//
//
// Return:      S_OK if successful. An HRESULT error code on failure.
//
// History:     8/7/99          leonardm        Created.
//
//******************************************************************************
HRESULT RsopCreateToken( WCHAR* szAccountName,
                         SAFEARRAY *psaUserSecurityGroups,
                         PRSOPTOKEN* ppRsopToken );

//******************************************************************************
//
// Function:    RsopDeleteToken
//
// Description: Destroys a pseudo-token previously created by any of the overloaded
//                      forms of RSOPCreateRsopToken
//
// Parameters:  - pRsopToken: Pointer to a valid PRSOPTOKEN
//
// Return:      S_OK on success. An HRESULT error code on failure.
//
// History:     7/30/99         leonardm        Created.
//
//******************************************************************************
HRESULT RsopDeleteToken(PRSOPTOKEN pRsopToken);


#if defined(__cplusplus)
}
#endif

#endif // #ifndef CHKACC_H__85EE6A51_C327_4453_ACBE_FEC6F0010740__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\rsop\collect.h ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:        Collect.h
//
// Description: Support for Namespace Garbage Collection
//
// History:     12-01-99   leonardm    Created
//
//******************************************************************************


#ifdef __cplusplus
extern "C"{
#endif 

//******************************************************************************
//
// Function:    GarbageCollectNamespaces
//
// Description: Iterates through namespaces under root\rsop and for each of those
//              that are determined to be garbage-collectable, it connects to
//              sub-namespaces 'User' and 'Computer'.
//
//              Any of the sub-namespaces that is older than TTLMinutes will be deleted.
//              If no sub-namespaces are left, then the parent namespace is deleted as well.
//
//              Garbage-collectable are those namespaces which satisfy a set of 
//              criteria which at the present time is based solely on the naming convention
//              as follows: namespaces under root\rsop whose name starts with "NS"
//
//              Sub-namespaces 'User' and 'Computer' are expected to have an instance of class
//              RSOP_Session. The data member 'creationTime' of that instance is examined when
//              evaluating whether the sub-namespace should be deleted.
//
//
// Parameters:  TTLMinutes -    The maximum number of minutes that may have 
//                              elapsed since the creation of a sub-namespace
//
// Return:      
//
// History:     12/01/99     leonardm        Created.
//
//******************************************************************************

HRESULT GarbageCollectNamespaces(ULONG TTLMinutes);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\rsop\diagprov.cpp ===
//*************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:        diagprov.cpp
//
// Description: Rsop diagnostic mode provider
//
// History:     8-20-99   leonardm    Created
//
//*************************************************************

#include "uenv.h"
#include "diagprov.h"
#include "rsopinc.h"
#include "Indicate.h"
#include "rsopdbg.h"
#include "rsopsec.h"

HRESULT EnumerateUserNameSpace( IWbemLocator *pWbemLocator, HANDLE hToken, SAFEARRAY **psaUserSids );

HRESULT UpdateGPCoreStatus(IWbemLocator *pWbemLocator,
                           LPWSTR szSid, LPWSTR szNameSpace);

//*************************************************************
//
//  GetMachAccountName()
//
//  Purpose:    Gets Machine account name
//
//  Return:     Machine Account
//
// Note: Need to call it w/o impersonation
//*************************************************************


LPTSTR GetMachAccountName()
{
    return MyGetUserName(NameSamCompatible);
}

//*************************************************************
//
//  GetUserAccountName()
//
//  Purpose:    Gets the user account given the Sid
//
//  Parameters: lpSidString - Sid in string format that we are interested in
//
//  Return:     Account Name
//
//*************************************************************

LPTSTR GetUserAccountName(LPTSTR lpSidString)
{
    SID_NAME_USE peUse;
    DWORD        dwNameSize = 0;
    PSID         pSid = NULL;
    DWORD        dwDomainSize = 0;
    LPTSTR       szRetAccount = NULL;


    if (AllocateAndInitSidFromString(lpSidString, &pSid) != STATUS_SUCCESS ) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("GetUserAccountName::AllocateAndInitSidFromString failed."));
        goto Exit;
    }

    
    LookupAccountSid(NULL, pSid, NULL, &dwNameSize, NULL, &dwDomainSize, &peUse);

    if (dwNameSize && dwDomainSize) {
        
        XPtrLF<TCHAR>   xszAccount =
                LocalAlloc(LPTR, sizeof(TCHAR)*(dwNameSize+dwDomainSize+4));

        XPtrLF<TCHAR>   xszDomainName =
                LocalAlloc(LPTR, sizeof(TCHAR)*(dwDomainSize+1));

        XPtrLF<TCHAR>   xszName =
                LocalAlloc(LPTR, sizeof(TCHAR)*(dwNameSize+1));



        if (!xszAccount || !xszDomainName || !xszName ) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("GetUserAccountName::AllocMem failed with 0x%x."), GetLastError());
            goto Exit;
        }

        if (!LookupAccountSid(NULL, pSid, xszName, &dwNameSize, xszDomainName, &dwDomainSize, &peUse)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("GetUserAccountName::LookupaccountSid failed with 0x%x."), GetLastError());
            goto Exit;
        }

        lstrcpy(xszAccount, xszDomainName);
        lstrcat(xszAccount, TEXT("\\"));
        lstrcat(xszAccount, xszName);


        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("GetUserAccountName::User account is %s."), xszAccount);

        szRetAccount = xszAccount.Acquire();
    }
    

Exit:
    if (pSid) 
        FreeSid(pSid);

    return szRetAccount;
}


//*************************************************************
//
//  CheckRsopDiagPolicyInteractive()
//
//  Purpose: Can this user get the rsop data even if the user is logged 
//           on interactively
//
//  Parameters: 
//
//  Return:     CheckRsopDiagPolicyInteractive
//
//*************************************************************

BOOL CheckRsopDiagPolicyInteractive()
{
    HKEY    hKeyUser = NULL;
    HKEY    hKey;
    DWORD   dwSize = 0, dwType = 0;
    BOOL    bDeny = FALSE;

    CoImpersonateClient();

    if (!RegOpenCurrentUser(KEY_READ, &hKeyUser) == ERROR_SUCCESS) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CheckRsopDiagPolicyInteractive:: couldn't access registry of interactive user."));
        hKeyUser = NULL;
    }

    CoRevertToSelf();




    //
    // First, check for a user preference
    //

    if (hKeyUser) {
        if (RegOpenKeyEx (hKeyUser, WINLOGON_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            dwSize = sizeof(bDeny);
            RegQueryValueEx (hKey, DENY_RSOP_FROM_INTERACTIVE_USER, NULL, &dwType,
                             (LPBYTE) &bDeny, &dwSize);

            RegCloseKey (hKey);
        }
    }


    //
    // Check for a machine preference
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0,
                            KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(bDeny);
        RegQueryValueEx (hKey, DENY_RSOP_FROM_INTERACTIVE_USER, NULL, &dwType,
                         (LPBYTE) &bDeny, &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Check for a user policy
    //

    if (hKeyUser) {
        if (RegOpenKeyEx (hKeyUser, SYSTEM_POLICIES_KEY, 0,
                                KEY_READ, &hKey) == ERROR_SUCCESS) {
    
            dwSize = sizeof(bDeny);
            RegQueryValueEx (hKey, DENY_RSOP_FROM_INTERACTIVE_USER, NULL, &dwType,
                             (LPBYTE) &bDeny, &dwSize);
    
            RegCloseKey (hKey);
        }
    }

    //
    // Check for a machine policy
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY, 0,
                            KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(bDeny);
        RegQueryValueEx (hKey, DENY_RSOP_FROM_INTERACTIVE_USER, NULL, &dwType,
                         (LPBYTE) &bDeny, &dwSize);

        RegCloseKey (hKey);
    }

    if (hKeyUser) {
        RegCloseKey(hKeyUser);
    }

    return (!bDeny);
}

//*************************************************************
//
// Functions:  Constructor, Destructor, QueryInterface, AddRef, Release
//
//*************************************************************

CSnapProv::CSnapProv()
   :  m_cRef(1),
      m_bInitialized(false),
      m_pNamespace(NULL)
{
    InterlockedIncrement(&g_cObj);

    m_xbstrUserSid = L"userSid";
    if ( !m_xbstrUserSid )
         return;

    m_xbstrUserSids = L"userSids";
    if ( !m_xbstrUserSids )
         return;

    m_xbstrNameSpace = L"nameSpace";
    if ( !m_xbstrNameSpace )
       return;

    m_xbstrResult = L"hResult";
    if ( !m_xbstrResult )
        return;

    m_xbstrFlags = L"flags";
    if ( !m_xbstrFlags )
        return;

    m_xbstrExtendedInfo = L"ExtendedInfo";
    if ( !m_xbstrExtendedInfo )
         return;

    m_xbstrClass = L"RsopLoggingModeProvider";
    if ( !m_xbstrClass )
       return;

    m_bInitialized = TRUE;
}


CSnapProv::~CSnapProv()
{
    if(m_pNamespace != NULL)
    {
        m_pNamespace->Release();
    }

    InterlockedDecrement(&g_cObj);
}

STDMETHODIMP CSnapProv::QueryInterface (REFIID riid, LPVOID* ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemServices)
    {
            *ppv = static_cast<IWbemServices*>(this);
    }
    else if(riid == IID_IWbemProviderInit)
    {
            *ppv = static_cast<IWbemProviderInit*>(this);
    }
    else
    {
            *ppv=NULL;
            return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CSnapProv::AddRef()
{
        return InterlockedIncrement( &m_cRef );
}


STDMETHODIMP_(ULONG) CSnapProv::Release()
{
        if (!InterlockedDecrement(&m_cRef))
        {
                delete this;
                return 0;
        }
        return m_cRef;
}

//*************************************************************
//
//  Initialize()
//
//  Purpose:    WbemProvider's initialize method
//
//  Parameters: See IWbemProivderInit::Initialize
//
//  Return:     hresult
//
//*************************************************************

STDMETHODIMP CSnapProv::Initialize( LPWSTR pszUser,
                                    LONG lFlags,
                                    LPWSTR pszNamespace,
                                    LPWSTR pszLocale,
                                    IWbemServices __RPC_FAR *pNamespace,
                                    IWbemContext __RPC_FAR *pCtx,
                                    IWbemProviderInitSink __RPC_FAR *pInitSink)
{
    HRESULT hr;

    if ( !m_bInitialized ) {
        hr = pInitSink->SetStatus(E_FAIL, 0);
        return hr;
    }

    //
    // No need to authenticate user. The ACLs on Rsop namespace will
    // deny access to users that cannot snapshot diagnostic mode data.
    //

    m_pNamespace = pNamespace;
    m_pNamespace->AddRef();

    hr = pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);

    return hr;
}


#if _MSC_FULL_VER <= 13008827 && defined(_M_IX86)
#pragma optimize("", off)
#endif


//*************************************************************
//
//  ExecMethodAsync()
//
//  Purpose:    Execute method
//
//  Parameters: See IWbemServices::ExecMethodAsync
//
//  Return:     hresult
//
//*************************************************************

STDMETHODIMP CSnapProv::ExecMethodAsync( const BSTR bstrObject,
                                         const BSTR bstrMethod,
                                         long lFlags,
                                         IWbemContext __RPC_FAR *pCtx,
                                         IWbemClassObject __RPC_FAR *pInParams,
                                         IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr;

    CFailRetStatus retStatus( pResponseHandler );
    IUnknown      *pOldSecContext;

    //
    // Make sure the provider is properly initialized
    //

    //
    // Allow for debugging level to be dynamically changed during queries
    //


    dbgRsop.Initialize(  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                     L"RsopDebugLevel",
                     L"userenv.log",
                     L"userenv.bak",
                     FALSE );

    InitDebugSupport(0);

    if ( !m_bInitialized )
    {
        hr = E_OUTOFMEMORY;
        retStatus.SetError( hr );
        return hr;
    }

    //
    // Initialize the return status object to fail status
    //

    IWbemLocator *pWbemLocator = NULL;
    hr = CoCreateInstance( CLSID_WbemAuthenticatedLocator,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IWbemLocator,
                           (LPVOID *) &pWbemLocator );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync: CoCreateInstance returned 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    XInterface<IWbemLocator> xLocator( pWbemLocator );

    IWbemClassObject* pProvClass = NULL;
    IWbemClassObject* pOutClass = NULL;
    IWbemClassObject* pOutParams = NULL;

    hr = m_pNamespace->GetObject( m_xbstrClass, 0, pCtx, &pProvClass, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::GetObject failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    XInterface<IWbemClassObject> xProvClass( pProvClass );

    hr = pProvClass->GetMethod( bstrMethod, 0, NULL, &pOutClass);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::GetMethod failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    XInterface<IWbemClassObject> xOutClass( pOutClass );

    hr = pOutClass->SpawnInstance(0, &pOutParams);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::SpawnInstance failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }


    //
    // Get the tokens and Sids upfront
    //
    
    XPtrLF <WCHAR> xszSidString;
    XPtrLF <SID>   xSid;
    XHandle        xUserToken;

    hr = CoImpersonateClient();
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoImpersonateClient failed with 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    if (OpenThreadToken (GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &xUserToken)) {
        

        LPWSTR szSid = GetSidString(xUserToken);
        if (!szSid) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::GetSidString failed with %d"), GetLastError() );
            CoRevertToSelf();
            retStatus.SetError( hr );
            return hr;
        }
        else {
            xszSidString = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(lstrlen(szSid)+1));

            if (!xszSidString) {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::LocalAlloc failed with %d"), GetLastError() );
                hr = HRESULT_FROM_WIN32(GetLastError());
                DeleteSidString(szSid);
                CoRevertToSelf();
                retStatus.SetError( hr );
                return hr;
            }

            lstrcpy(xszSidString, szSid);

            DeleteSidString(szSid);
        }


        xSid = (SID *)GetUserSid(xUserToken);
        if (!xSid) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::GetUserSid failed with %d"), GetLastError() );
            CoRevertToSelf();
            retStatus.SetError( hr );
            return hr;
        }
    } else {
        hr = HRESULT_FROM_WIN32(GetLastError());
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Openthreadtoken failed with 0x%x"), hr );
        CoRevertToSelf();
        retStatus.SetError( hr );
        return hr;
    }

    CoRevertToSelf();

    
    XInterface<IWbemClassObject> xOutParams( pOutParams );

    if ( _wcsicmp( (WCHAR *) bstrMethod, L"RsopDeleteSession" ) == 0 ) {

        //
        // rsopdeletesession
        //

        VARIANT vNameSpace;
        hr = pInParams->Get( m_xbstrNameSpace, 0, &vNameSpace, NULL, NULL);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get machine name failed with 0x%x."), hr );
            retStatus.SetError( hr );
            return hr;
        }
        XVariant xvNameSpace( &vNameSpace );


        if  (vNameSpace.vt != VT_NULL ) {
                
            //
            // We want to run as LS
            //

            hr = CoSwitchCallContext(NULL, &pOldSecContext);

            if (FAILED(hr)) {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr );
                retStatus.SetError( hr );
                return hr;
            }
            
            hr = ProviderDeleteRsopNameSpace( pWbemLocator, 
                                              vNameSpace.bstrVal,
                                              xUserToken, 
                                              xszSidString, 
                                              SETUP_NS_SM);

            
            IUnknown  *pNewObject;
            HRESULT hr2 = CoSwitchCallContext(pOldSecContext, &pNewObject);

            if (FAILED(hr2)) {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr2 );
            }
        }
        else {
            hr = E_INVALIDARG;
        }


        VARIANT var;
        var.vt = VT_I4;
        var.lVal = hr;

        hr = pOutParams->Put( m_xbstrResult, 0, &var, 0);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put result failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        hr = pResponseHandler->Indicate(1, &pOutParams);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Indicate failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        return hr;
    }
    else if ( _wcsicmp( (WCHAR *) bstrMethod, L"RsopEnumerateUsers" ) == 0 ) 
    {

        //
        // RsopenumerateUsers
        //

        SAFEARRAY    *pArray;

        hr = EnumerateUserNameSpace( pWbemLocator, xUserToken, &pArray );
        
        XSafeArray    xsaUserSids(pArray);        
        
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::EnumerateUserNameSpace failed") );
        }

        VARIANT var;
        var.vt = VT_I4;
        var.lVal = hr;

        hr = pOutParams->Put( m_xbstrResult, 0, &var, 0);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put result failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        var.vt = VT_ARRAY | VT_BSTR;
        var.parray = xsaUserSids;

        hr = pOutParams->Put( m_xbstrUserSids, 0, &var, 0 );
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put sids failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        hr = pResponseHandler->Indicate(1, &pOutParams);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Indicate failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        return hr;
    }


    //
    // progress indicator.
    // 25% done when we enter the first critical section.
    // 50% done when we enter the second critical section.
    // 100% complete when we copy the namespace.
    //

    CProgressIndicator  Indicator(  pResponseHandler,
                                    (lFlags & WBEM_FLAG_SEND_STATUS) != 0 );

    //
    // 5% done. Hack for UI.
    //

    hr = Indicator.IncrementBy( 5 );

    VARIANT vUserSid;
    hr = pInParams->Get( m_xbstrUserSid, 0, &vUserSid, NULL, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get RemoteComputer failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }
    XVariant xvUserSid ( &vUserSid );
    

    VARIANT vFlags;
    VariantInit( &vFlags );
    hr = pInParams->Get( m_xbstrFlags, 0, &vFlags, NULL, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get dwFlags failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    DWORD dwFlags = vFlags.vt == VT_EMPTY || vFlags.vt == VT_NULL ? 0 : vFlags.ulVal;
    
    //
    // Flags specific to Diagnostic mode provider
    //

    if ((dwFlags & FLAG_NO_USER) && (dwFlags & FLAG_NO_COMPUTER)) {
        hr = WBEM_E_INVALID_PARAMETER;
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Both user and computer are null."));
        retStatus.SetError( hr );
        return hr;
    }


    //
    // We can dump out all the input parameters here later on.
    //

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::---------------RsopCreateSession::Input Parameters--------------------"));
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::UserSid = <%s>"), vUserSid.vt == VT_NULL ? L"NULL" : vUserSid.bstrVal);
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::flags = <%d>"), dwFlags);
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::---------------RsopCreateSession::Input Parameters--------------------"));


    //
    // Code for RsopCreateSession method
    //



    XPtrLF<TCHAR> xszMachSOM;
    XPtrLF<TCHAR> xszUserSOM;
    BOOL          bDelegated = FALSE;
    BOOL          bCheckAccess = FALSE;
    DWORD         dwExtendedInfo = 0;
    XPtrLF<TCHAR> xszUserAccount;
    XPtrLF<TCHAR> xszMachAccount;


    //
    // Get the machine SOM
    //

    if ( !(dwFlags & FLAG_NO_COMPUTER) ) {

        xszMachAccount = GetMachAccountName();

        dwExtendedInfo |= RSOP_COMPUTER_ACCESS_DENIED;

        if (!xszMachAccount) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::No machine account. error %d"), GetLastError() );
        }
        else {
            xszMachSOM = GetSOM(xszMachAccount);

            if (xszMachSOM) {
                bCheckAccess = TRUE;
                dwExtendedInfo &= ~RSOP_COMPUTER_ACCESS_DENIED;
            }
            else {
                dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::No machine SOM. error %d"), GetLastError() );
            }
        }
    }
    else {
        bCheckAccess = TRUE;
    }


    //
    // Get the User SOM
    //

    if ((bCheckAccess) && ( !(dwFlags & FLAG_NO_USER) ) ) {

        bCheckAccess = FALSE;
        dwExtendedInfo |= RSOP_USER_ACCESS_DENIED;

        xszUserAccount = GetUserAccountName(vUserSid.vt == VT_NULL ? xszSidString : vUserSid.bstrVal);

        if (!xszUserAccount) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::No User account. error %d"), GetLastError() );
        }
        else {
            xszUserSOM = GetSOM(xszUserAccount);

            if (xszUserSOM) {
                bCheckAccess = TRUE;
                dwExtendedInfo &= ~RSOP_USER_ACCESS_DENIED;
            }
            else {
                dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::No User SOM. error %d"), GetLastError() );
            }
        }
    }


    //
    // Check access now
    //

    if (bCheckAccess) {
        hr = AuthenticateUser(xUserToken, xszMachSOM, xszUserSOM, TRUE, &dwExtendedInfo);

        if (FAILED(hr)) {
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::User is not a delegated admin. Error 0x%x"), hr );
            hr = S_OK;
        }
        else {
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::User is a delegated admin. Error 0x%x"), hr );
            bDelegated = TRUE;
        }
    }

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecMethodAsync::Getting policy critical sections"));

    XCriticalPolicySection criticalPolicySectionMACHINE( EnterCriticalPolicySectionEx(TRUE, 40000, ECP_FAIL_ON_WAIT_TIMEOUT) );

    if ( !criticalPolicySectionMACHINE )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync::EnterCriticalPolicySection failed with 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    //
    // 25% done when we enter the first critical section.
    //

    hr = Indicator.IncrementBy( 20 );
    if ( FAILED( hr ) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync::IncrementBy() failed with 0x%x"), hr );
    }

    
    XCriticalPolicySection criticalPolicySectionUSER( EnterCriticalPolicySectionEx(FALSE, 40000, ECP_FAIL_ON_WAIT_TIMEOUT) );

    if ( !criticalPolicySectionUSER )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync::EnterCriticalPolicySection failed with 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }


    //
    // 50% done when we enter the second critical section.
    //
    hr = Indicator.IncrementBy( 25 );
    if ( FAILED( hr ) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync::IncrementBy() failed with 0x%x"), hr );
    }


    LPWSTR wszNameSpace = 0;

      
    //
    // Impersonate if not delegated
    //

    if (!bDelegated) {
        hr = CoImpersonateClient();
        
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoImpersonateClient failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }
    }
    else {

        //
        // We want to run as LS
        //

        hr = CoSwitchCallContext(NULL, &pOldSecContext);

        if (FAILED(hr)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }
    }
    

    XPtrLF<WCHAR> xwszNameSpace;

    DWORD dwNewNameSpaceFlags = SETUP_NS_SM;
    
    dwNewNameSpaceFlags |= (dwFlags & FLAG_NO_USER) ? SETUP_NS_SM_NO_USER : 0;
    dwNewNameSpaceFlags |= (dwFlags & FLAG_NO_COMPUTER) ? SETUP_NS_SM_NO_COMPUTER : 0;



    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::UserSid = <%s>"), vUserSid.vt == VT_NULL ? L"NULL" : vUserSid.bstrVal);
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::User who is running the tool = <%s>"), (LPWSTR)xszSidString);

    hr = SetupNewNameSpace( &xwszNameSpace,
                             0, // namespace on this machine
                             (vUserSid.vt == VT_NULL) ? ((LPWSTR)xszSidString) : vUserSid.bstrVal,
                             xSid,
                             pWbemLocator, 
                             dwNewNameSpaceFlags,
                             &dwExtendedInfo); 

    if (!bDelegated) {
        CoRevertToSelf();
    }
    else {

        //
        // restore call context
        //

        IUnknown  *pNewObject;
        HRESULT hr2 = CoSwitchCallContext(pOldSecContext, &pNewObject);

        if (FAILED(hr2)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr2 );
        }
    }



    if ( FAILED(hr) && !bDelegated)
    {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::SetupNewNameSpace failed with 0x%x"), hr );

        if (IsUserAnInteractiveUser(xUserToken) && CheckRsopDiagPolicyInteractive()) {
            
            if ( (vUserSid.vt == VT_NULL) || (_wcsicmp(vUserSid.bstrVal, xszSidString) == 0 )) {

                dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::SetupNewNameSpace failed. retrying in interactive mode"), hr );


                //
                // We want to run as LS
                //

                hr = CoSwitchCallContext(NULL, &pOldSecContext);

                if (FAILED(hr)) {
                    dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr );
                    retStatus.SetError( hr );
                    return hr;
                }
                
                //
                // if the namespace is null, get the name of the interactive namespace
                //
    
                XPtrLF<WCHAR> xszInteractiveNS;
                  
                hr = GetInteractiveNameSpace(xszSidString, &xszInteractiveNS);
    
                if (FAILED(hr)) {
                    dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr );
                    retStatus.SetError( hr );
                    return hr;
                }

                BOOL bContinue=TRUE;

                if (dwFlags & FLAG_FORCE_CREATENAMESPACE) {
                    hr = DeleteRsopNameSpace( xszInteractiveNS, pWbemLocator );
                    // ignore error
                }
                else {
                    XInterface<IWbemServices> xWbemServices;

                    hr = pWbemLocator->ConnectServer( xszInteractiveNS,
                                                      NULL,
                                                      NULL,
                                                      0L,
                                                      0L,
                                                      NULL,
                                                      NULL,
                                                      &xWbemServices );

                    if (SUCCEEDED(hr)) {
                        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Namespace already exists. Failing call"));
                        hr = WBEM_E_ALREADY_EXISTS;
                        dwExtendedInfo = RSOP_TEMPNAMESPACE_EXISTS;
                        bContinue = FALSE;
                    }
                }
                
                if (bContinue) {
                    dwNewNameSpaceFlags |= SETUP_NS_SM_INTERACTIVE;

                    hr = SetupNewNameSpace( &xwszNameSpace,
                                             0, // namespace on this machine
                                             xszSidString,
                                             xSid,
                                             pWbemLocator, 
                                             dwNewNameSpaceFlags,
                                             &dwExtendedInfo); 

                }
                
                //
                // restore call context
                //

                IUnknown  *pNewObject;
                HRESULT hr2 = CoSwitchCallContext(pOldSecContext, &pNewObject);

                if (FAILED(hr2)) {
                    dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr2 );
                }
            }
        }
    }


    if (FAILED(hr)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::SetupNewNameSpace failed with 0x%x"), hr );
    }
    else
    {
        HRESULT hr2;
        VARIANT var;
        //
        // if we managed to get a snapshot, then ignore the extended access denied info
        //

        dwExtendedInfo = 0;


        //
        // We want to run as LS
        //

        hr = CoSwitchCallContext(NULL, &pOldSecContext);

        if (FAILED(hr)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        if ( !(dwFlags & FLAG_NO_COMPUTER) ) {

            hr = UpdateGPCoreStatus(pWbemLocator, NULL, xwszNameSpace); 
        }

        if ( (SUCCEEDED(hr)) && (!(dwFlags & FLAG_NO_USER)) ) {
            hr = UpdateGPCoreStatus(pWbemLocator, 
                                    vUserSid.vt == VT_NULL ? xszSidString : vUserSid.bstrVal,
                                    xwszNameSpace); 
            
        }

        //
        // restore call context
        //

        IUnknown  *pNewObject;
        hr2 = CoSwitchCallContext(pOldSecContext, &pNewObject);

        if (FAILED(hr2)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr2 );
        }


        //
        // Return the error code if the status cannot be updated..
        //

        if (FAILED(hr)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::UpdateGPCoreStatus failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        XBStr xbstrNS( xwszNameSpace );
        if ( !xbstrNS )
        {
            hr2 = HRESULT_FROM_WIN32( E_OUTOFMEMORY );
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Memory allocate failed") );
            retStatus.SetError( hr2 );
            return hr2;
        }

        var.vt = VT_BSTR;
        var.bstrVal = xbstrNS;
        hr2 = pOutParams->Put( m_xbstrNameSpace, 0, &var, 0);
        if ( FAILED(hr2) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put namespace failed with 0x%x"), hr );
            retStatus.SetError( hr2 );
            return hr2;
        }
    }


    VARIANT var;
    var.vt = VT_I4;
    var.lVal = hr;

    hr = pOutParams->Put( m_xbstrResult, 0, &var, 0);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put result failed with 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    var.lVal = dwExtendedInfo;
    hr = pOutParams->Put( m_xbstrExtendedInfo, 0, &var, 0);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put result failed with 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    //
    // 100% complete when we copy the namespace.
    //
    hr = Indicator.SetComplete();
    if ( FAILED( hr ) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync::IncrementBy() failed with 0x%x"), hr );
    }

    hr = pResponseHandler->Indicate(1, &pOutParams);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Indicate failed with 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    return hr;
}

#if _MSC_FULL_VER <= 13008827 && defined(_M_IX86)
#pragma optimize("", on)
#endif



//*************************************************************
//
//  EnumerateUserNameSpace()
//
//  Purpose:    EnumerateUserNameSpace
//
//  Parameters: 
//          pWbemLocator - Pointer to a locator
//    [out] psaUserSids  - Pointer to User Sids
//
//  Return:     hresult
//
//*************************************************************

typedef struct _UserSidList {
    LPWSTR                  szUserSid; 
     struct _UserSidList   *pNext;
} USERSIDLIST, *PUSERSIDLIST;

HRESULT EnumerateUserNameSpace( IWbemLocator *pWbemLocator, HANDLE hToken, SAFEARRAY **psaUserSids )
{
    USERSIDLIST     SidList = {0,0};
    DWORD           dwNum = 0;
    PUSERSIDLIST    pElem = NULL;
    HRESULT         hr = S_OK;
    DWORD           dwExtendedInfo;
    IUnknown       *pOldSecContext;
    
    //
    // Connect to namespace ROOT\RSOP\User
    //

    *psaUserSids = NULL;
    
    XInterface<IWbemServices>xpWbemServices = NULL;

    XBStr xbstrNamespace = RSOP_NS_DIAG_USERROOT;

    if(!xbstrNamespace)
    {
        DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    hr = pWbemLocator->ConnectServer(xbstrNamespace,
                                      NULL,
                                      NULL,
                                      0L,
                                      0L,
                                      NULL,
                                      NULL,
                                      &xpWbemServices);
    if(FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: ConnectServer failed. hr=0x%x" ), hr ));
        return hr;
    }


    //
    //  Enumerate all instances of __namespace at the root\rsop\user level.
    //

    XInterface<IEnumWbemClassObject> xpEnum;
    XBStr xbstrClass = L"__namespace";
    if(!xbstrClass)
    {
        DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    hr = xpWbemServices->CreateInstanceEnum( xbstrClass,
                                            WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY,
                                            NULL,
                                            &xpEnum);
    if(FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: CreateInstanceEnum failed. hr=0x%x" ), hr ));
        return hr;
    }

    XBStr xbstrProperty = L"Name";
    if(!xbstrProperty)
    {
        DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: Failed to allocate memory")));
        return E_FAIL;
    }

    XInterface<IWbemClassObject>xpInstance = NULL;
    ULONG ulReturned = 1;

    while(1)
    {
        hr = xpEnum->Next( WBEM_NO_WAIT, 1, &xpInstance, &ulReturned);
        if (hr != WBEM_S_NO_ERROR || !ulReturned)
        {
            break;
        }

        VARIANT var;
        VariantInit(&var);

        hr = xpInstance->Get(xbstrProperty, 0L, &var, NULL, NULL);
        xpInstance = NULL;
        if(FAILED(hr))
        {
            DebugMsg((DM_VERBOSE, TEXT("EnumerateUserNameSpace: Get failed. hr=0x%x" ), hr ));
            goto Exit;  // continue
        }


        //
        // Check to see whether user is delegated admin for the user account
        //

        XPtrLF<WCHAR> xszUserSid = (LPWSTR)LocalAlloc(LPTR, (1+lstrlen(var.bstrVal))*sizeof(WCHAR));

        if (!xszUserSid) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg((DM_VERBOSE, TEXT("EnumerateUserNameSpace: AllocMem failed. hr=0x%x" ), hr ));
            goto Exit;  
        }

        ConvertWMINameToSid(var.bstrVal, xszUserSid);

        //
        // See whether it is a valid Sid
        //

        PSID    pSid = NULL;

        if (AllocateAndInitSidFromString(xszUserSid, &pSid) != STATUS_SUCCESS ) {
            DebugMsg((DM_VERBOSE, TEXT("EnumerateUserNameSpace: AllocateAndInitSidFromString - %s is not a valid Sid" ), xszUserSid));
            continue;
        }


        if (!IsValidSid(pSid)) {
            DebugMsg((DM_VERBOSE, TEXT("EnumerateUserNameSpace: %s is not a valid Sid" ), xszUserSid));
            FreeSid(pSid);
            continue;
        }

        FreeSid(pSid);
        

        //
        // First try to connect to the NameSpace
        //

        hr = CoImpersonateClient();
    
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoImpersonateClient failed with 0x%x"), hr );
            goto Exit;
        }

        XInterface<IWbemServices> xpChildNamespace = NULL;
        hr = xpWbemServices->OpenNamespace(  var.bstrVal,
                                             0,
                                             NULL,
                                             &xpChildNamespace,
                                             NULL);
        
        CoRevertToSelf();

        if(FAILED(hr))
        {
            IUnknown  *pNewObject;
            HRESULT hr2=S_OK;
            BOOL    bDelegated = TRUE;


            DebugMsg((DM_VERBOSE, TEXT("EnumerateUserNameSpace: OpenNamespace returned 0x%x"), hr));

            //
            // Check whether user has access as LS
            // 

            //
            // We want to run as LS
            //

            hr = CoSwitchCallContext(NULL, &pOldSecContext);

            if (FAILED(hr)) {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr );
                goto Exit;
            }


            XPtrLF<TCHAR> xszAccount = GetUserAccountName(xszUserSid);

            if (!xszAccount) {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::No User account. error %d"), GetLastError() );
                bDelegated = FALSE;
            }
            
            XPtrLF<TCHAR> xszUserSOM;
            
            if (bDelegated) {
                xszUserSOM = GetSOM(xszAccount);
                if (!xszUserSOM) {
                    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::No User SOM. Probably local account. error %d"), GetLastError() );
                    bDelegated = FALSE;
                }
            }

            //
            // Check access now
            //

            if (bDelegated) {
                hr = AuthenticateUser(hToken, NULL, xszUserSOM, TRUE, &dwExtendedInfo);

                if (FAILED(hr)) {
                    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::User is not a delegated admin. Error 0x%x"), hr );
                    bDelegated = FALSE;
                }
            }
            
            //
            // restore call context
            //

            hr2 = CoSwitchCallContext(pOldSecContext, &pNewObject);

            if (FAILED(hr2)) {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr2 );
            }

            if (!bDelegated) {
                continue;
            }

        }


        //
        // For every instance of __namespace under ROOT\RSOP\user
        // convert it to Sid and return
        //
        
        pElem = (PUSERSIDLIST)LocalAlloc(LPTR, sizeof(USERSIDLIST));        

        if (!pElem) {
            DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: Couldn't allocate memory Error = GetLastError()" ), GetLastError()));
            goto Exit;
        }

        
        pElem->szUserSid = xszUserSid.Acquire();

        //
        // Attach to the beginning of the list
        //
        
        pElem->pNext = SidList.pNext;
        SidList.pNext = pElem;
        dwNum++;
        
        VariantClear( &var );

    }


    if(hr != WBEM_S_FALSE || ulReturned)
    {
        DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: Get failed. hr=0x%x" ), hr ));
        hr = E_FAIL;
        goto Exit;
    }

    //
    // Now make the safe array from the list that we got
    //
    
    SAFEARRAYBOUND arrayBound[1];
    arrayBound[0].lLbound = 0;
    arrayBound[0].cElements = dwNum;

    *psaUserSids = SafeArrayCreate( VT_BSTR, 1, arrayBound );
    
    if ( *psaUserSids == NULL ) {
        DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: Failed to allocate memory. Error = %d" ), GetLastError() ));
        hr = E_FAIL;
        goto Exit;
    }

    //
    // traverse the list
    //

    DWORD i;
    for (i=0, pElem = SidList.pNext; (i < dwNum); i++, pElem = pElem->pNext) {
        XBStr xbstrUserSid(pElem->szUserSid);

        SafeArrayPutElement( *psaUserSids, (LONG *)&i, xbstrUserSid);
    }
        
    hr = S_OK;

Exit:

    // free
    for (i=0, pElem = SidList.pNext; (i < dwNum); i++ ) {
        if (pElem->szUserSid)
            LocalFree(pElem->szUserSid);

        PUSERSIDLIST pTemp = pElem;

        pElem = pElem->pNext;
        LocalFree(pTemp);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\rsop\collect.cpp ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:        Collect.cpp
//
// Description: Support for Namespace Garbage Collection
//
// History:     12-01-99   leonardm    Created
//
//******************************************************************************


#include "uenv.h"
#include "collect.h"
#include "..\rsoputil\smartptr.h"
#include "..\rsoputil\rsoputil.h"
#include "..\rsoputil\wbemtime.h"


//******************************************************************************
//
// Function:    GetMinutesElapsed
//
// Description: Returns the number of minutes elapsed between a time represented
//              in a BSTR in WBEM format and the present time.
//              It expects a string in WBEM datetime format: "yyyymmddhhmmss.000000+000"
//              where yyyy=year, mm=month, dd=day, hh=hour, mm=minutes, ss=seconds
//
//
// Parameters:  xbstrOldTime -      Reference to XBStr representing the time from which
//                                  calculate the time span.
//
//              pMinutesElapsed -   Pointer to a ULONG that receives the minutes elapsed
//                                  between xbstrOldTime and the present time.
//
// Return:      S_OK on success. An HRESULT error code on failure.
//
// History:     12/01/99     leonardm        Created.
//
//******************************************************************************

HRESULT GetMinutesElapsed(XBStr& xbstrOldTime, ULONG* pMinutesElapsed)
{

    //
    // Convert the WbemTime value to a SYSTEMTIME value.
    //

    SYSTEMTIME systemTime_Old;

    HRESULT hr = WbemTimeToSystemTime(xbstrOldTime, systemTime_Old);
    if(FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetMinutesElapsed: WbemTimeToSystemTime failed. hr=0x%08X."), hr));
        return hr;
    }

    //
    // Convert the SYSTEMTIME value to a FILETIME value.
    //

    BOOL bRes;
    FILETIME fileTime_Old;

    bRes = SystemTimeToFileTime(&systemTime_Old, &fileTime_Old);
    if(!bRes)
    {
        DWORD dwLastError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetMinutesElapsed: SystemTimeToFileTime failed. LastError=0x%08X."), dwLastError));
        return E_FAIL;
    }

    unsigned __int64 old = fileTime_Old.dwHighDateTime;
    old <<= 32;
    old |= fileTime_Old.dwLowDateTime;


    //
    // Get the current time in SYSTEMTIME format
    //

    SYSTEMTIME systemTime_Current;
    GetSystemTime(&systemTime_Current);

    //
    // Convert the current time from a SYSTEMTIME to a FILETIME value
    //

    FILETIME fileTime_Current;
    bRes = SystemTimeToFileTime(&systemTime_Current, &fileTime_Current);
    if(!bRes)
    {
        DWORD dwLastError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetMinutesElapsed: SystemTimeToFileTime failed. LastError=0x%08X."), dwLastError));
        return E_FAIL;
    }

    //
    // The time passed in as a parameter must precede the current time
    //

    unsigned __int64 current = fileTime_Current.dwHighDateTime;
    current <<= 32;
    current |= fileTime_Current.dwLowDateTime;

    if(old > current)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // We have converted SYSTEMTIMEs to FILETIMEs.
    // "The FILETIME structure is a 64-bit value representing the number
    // of 100-nanosecond intervals since January 1, 1601."
    // Therefore we need to divide by ten million to obtain seconds
    // and by sixty to obtain minutes.
    //

    *pMinutesElapsed = (ULONG) (( current - old ) / (60 * 10 * 1000 * 1000));

    return S_OK;
}


//******************************************************************************
//
// Function:    IsNamespaceStale
//
// Description: Check if namespace is stale Sub-namespaces 'User' and 'Computer' are expected to have
//              RSOP_Session. The data member 'creationTime' of that instance is examined when
//              evaluating whether the sub-namespace should be deleted. For some failures treat the
//              namespace as garbage-collectable because we don't clean up properly when an error is
//              encountered during the creation of the namespace, and setting up security etc.
//
//
// Parameters:  pChildNamespace -   Pointer to IWbemServices associated with child namespace
//              TTLMinutes -        ULONG variable that represents the maximum number of
//                                  minutes that may have elapsed before a sub-namespace is
//                                  deleted.
//
// Return:      True if namespace is stale, false otherwise
//
//******************************************************************************

BOOL IsNamespaceStale( IWbemServices *pChildNamespace, ULONG TTLMinutes )
{
    //
    // compute TTL
    // To do so compare the "creationTime" data member of class RSOP_Session with
    // the current time. If the time span exceeds the threshold (as found in the
    // registry), the namespace is to be deleted.
    //

    XBStr xbstrInstancePath = L"RSOP_Session.id=\"Session1\"";
    if(!xbstrInstancePath)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory.")));
        return FALSE;
    }

    XInterface<IWbemClassObject>xpInstance = NULL;
    HRESULT hr = pChildNamespace->GetObject(xbstrInstancePath, 0, NULL, &xpInstance, NULL);

    if(FAILED(hr))
    {
        DebugMsg((DM_VERBOSE, TEXT("GarbageCollectNamespace: GetObject failed. hr=0x%08X"), hr));
        return TRUE;
    }

    XBStr xbstrPropertyName = L"creationTime";
    if(!xbstrPropertyName)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory.")));
        return TRUE;
    }

    VARIANT var;
    VariantInit(&var);
    XVariant xVar(&var);

    hr = xpInstance->Get(xbstrPropertyName, 0, &var, NULL, NULL);

    if(FAILED(hr))
    {
        DebugMsg((DM_VERBOSE, TEXT("GarbageCollectNamespace: Get failed. hr=0x%08X."), hr));
        return TRUE;
    }

    if ( var.vt == VT_NULL )
        return TRUE;

    XBStr xbstrPropertyValue = var.bstrVal;

    if(!xbstrPropertyValue)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory.")));
        return FALSE;
    }

    ULONG minutesElapsed = 10;

    hr = GetMinutesElapsed(xbstrPropertyValue, &minutesElapsed);
    if(FAILED(hr))
    {
        DebugMsg((DM_VERBOSE, TEXT("GarbageCollectNamespace: GetMinutesElapsed failed. hr=0x%08X."), hr));
        return TRUE;
    }

    if(minutesElapsed > TTLMinutes)
        return TRUE;
    else
        return FALSE;
}



//******************************************************************************
//
// Function:    GarbageCollectNamespace
//
// Description: Garabage-collects the namespace passed in as a parameter.
//              If no sub-namespaces are found or if all sub-namespaces
//              are deleted, it deletes the parent namespace as well.
//              It deletes sub-namespaces whose TTL has expired.
//              It computes the TTL from the 'creationTime' data member of the only
//              instance of class RSOP_Session as defined in rsop.mof.
//
//              Any of the sub-namespaces that is older than TTLMinutes will be deleted.
//              If no sub-namespaces are left, then the parent namespace is deleted as well.
//
//              Garbage-collectable are those namespaces which satisfy a set of
//              criteria which at the present time is based solely on the naming convention
//              as follows: namespaces under root\rsop whose name starts with "NS"
//
//              Sub-namespaces 'User' and 'Computer' are expected to have an instance of class
//              RSOP_Session. The data member 'creationTime' of that instance is examined when
//              evaluating whether the sub-namespace should be deleted.
//
//
// Parameters:  bstrNamespace -     Name of the namesapce to garbage collect.
//              pWbemServices -     Pointer to IWbemServices associated with
//                                  the parent of bstrNamespace (root\rsop)
//              TTLMinutes -        ULONG variable that represents the maximum number of
//                                  minutes that may have elapsed before a sub-namespace is
//                                  deleted.
//
// Return:      S_OK on success. An HRESULT error code on failure.
//
// History:     12/01/99     leonardm        Created.
//
//******************************************************************************

HRESULT GarbageCollectNamespace(BSTR bstrNamespace, IWbemServices* pWbemServices, ULONG TTLMinutes)
{
    if(!bstrNamespace || !pWbemServices)
    {
        return E_FAIL;
    }

    //
    // Connect to that namespace and enumerate instances of __namespace.
    // It's assumed that there will be at most 2 namespaces:
    // "User" and "Computer".
    //

    XInterface<IWbemServices> xpParentNamespace;
    HRESULT hr = pWbemServices->OpenNamespace(  bstrNamespace,
                                                0,
                                                NULL,
                                                &xpParentNamespace,
                                                NULL);

    if(FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: OpenNamespace failed. hr=0x%08X"), hr));
        return hr;
    }

    //
    //  Enumerate all instances of __namespace.
    //

    XInterface<IEnumWbemClassObject> xpEnum;
    XBStr xbstrClass = L"__namespace";
    if(!xbstrClass)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory")));
        return E_OUTOFMEMORY;
    }

    hr = xpParentNamespace->CreateInstanceEnum( xbstrClass,
                                                WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY,
                                                NULL,
                                                &xpEnum);
    if(FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: CreateInstanceEnum failed. hr=0x%08X" ), hr ));
        return hr;
    }

    //
    // We re interested in data member "Name" of class __namespace.
    //

    XBStr xbstrProperty = L"Name";
    if(!xbstrProperty)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory")));
        return E_FAIL;
    }

    //
    // This pointer will be used to iterate through every instance
    // in the enumeration.
    //

    XInterface<IWbemClassObject>xpInstance = NULL;

    ULONG ulReturned = 0;
    long namespacesFound = 0;
    long namespacesDeleted = 0;

    while(1)
    {
        //
        // Retrieve the next instance in the enumeration.
        //

        hr = xpEnum->Next( WBEM_NO_WAIT, 1, &xpInstance, &ulReturned);
        if (hr != WBEM_S_NO_ERROR || !ulReturned)
        {
            //
            // Either the end of the enumeration has been reached or an error
            // ocurred. We will find out outside the loop.
            //

            break;
        }

        namespacesFound++;

        //
        // Get the namespace name.
        //

        VARIANT var;
        VariantInit(&var);

        hr = xpInstance->Get(xbstrProperty, 0L, &var, NULL, NULL);

        //
        // Release the pointer to the current element of the enumeration..
        //

        xpInstance = NULL;

        if(FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Get failed. hr=0x%x" ), hr ));
            return E_FAIL;
        }

        //
        // Use the name of the namespace to connect to it.
        //

        XBStr xbstrChildNamespace = var.bstrVal;
        VariantClear( &var );

        if(!xbstrChildNamespace)
        {
            DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory" )));
            return E_FAIL;
        }

        XInterface<IWbemServices> xpChildNamespace = NULL;
        hr = xpParentNamespace->OpenNamespace(  xbstrChildNamespace,
                                                0,
                                                NULL,
                                                &xpChildNamespace,
                                                NULL);

        if(FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: OpenNamespace returned 0x%x"), hr));
            return hr;
        }

        BOOL bStale = IsNamespaceStale( xpChildNamespace, TTLMinutes );
        xpChildNamespace = NULL;

        if ( bStale )
        {
            //
            // DeleteInstance
            //

            CWString sNamespaceToDelete = L"__namespace.name=\"";
            sNamespaceToDelete += (WCHAR*)xbstrChildNamespace;
            sNamespaceToDelete += L"\"";

            if(!sNamespaceToDelete.ValidString())
            {
                DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory.")));
                return E_OUTOFMEMORY;
            }

            XBStr xbstrInstancePath = sNamespaceToDelete;
            if(!xbstrInstancePath)
            {
                DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory.")));
                return E_OUTOFMEMORY;
            }

            hr = xpParentNamespace->DeleteInstance(xbstrInstancePath, 0, NULL, NULL);
            if(FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: DeleteInstance returned 0x%x"), hr));
                return hr;
            }

            DebugMsg((DM_VERBOSE, TEXT("GarbageCollectNamespace: Deleted namespace:%ws\\%ws\n"),
                      (WCHAR*)bstrNamespace, (WCHAR*)xbstrChildNamespace ));

            namespacesDeleted++;
        }

    }

    //
    // Check to find out whther the loop was exited because the end of the
    // enumeration was reached or because an error ocurred.
    //

    if(hr != WBEM_S_FALSE || ulReturned)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Get failed. hr=0x%x" ), hr ));
        return E_FAIL;
    }

    //
    // If no namespaces are found or if namespaces in enumeration
    // equal deleted namespaces delete the parent namespace as well.
    //

    if((!namespacesFound) || (namespacesDeleted == namespacesFound))
    {
        xpParentNamespace = NULL;

        CWString sNamespaceToDelete = L"__namespace.name=\"";
        sNamespaceToDelete += (WCHAR*)bstrNamespace;
        sNamespaceToDelete += L"\"";

        if(!sNamespaceToDelete.ValidString())
        {
            DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory.")));
            return E_OUTOFMEMORY;
        }

        XBStr xbstrInstancePath = sNamespaceToDelete;
        if(!xbstrInstancePath)
        {
            DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory.")));
            return E_OUTOFMEMORY;
        }

        hr = pWbemServices->DeleteInstance(xbstrInstancePath, 0, NULL, NULL);
        if(FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: DeleteInstance returned 0x%x"), hr));
            return hr;
        }

        DebugMsg((DM_VERBOSE, TEXT("GarbageCollectNamespace: Deleted namespace %ws\n"),
                  (WCHAR*)bstrNamespace ));
    }

    return S_OK;
}

//******************************************************************************
//
// Function:    IsGarbageCollectable
//
// Description: Determines whether a namespace is garbage-collectable.
//              Garbage-collectable are those namespaces which satisfy a set of
//              criteria which at the present time is based solely on the naming convention
//              as follows: namespaces under root\rsop whose name starts with "NS"
//
//
// Parameters:  bstrNamespace -     BSTR that represents the namespace name.
//
// Return:      'true'  or 'false'.
//
// History:     12/01/99     leonardm        Created.
//
//******************************************************************************

bool IsGarbageCollectable(BSTR bstrNamespace)
{
    if(bstrNamespace && wcslen(bstrNamespace) > 1 &&  _wcsnicmp(bstrNamespace, L"NS", 2) == 0)
    {
        return true;
    }

    return false;
}


//******************************************************************************
//
// Function:    GarbageCollectNamespaces
//
// Description: Iterates through namespaces under root\rsop and for each of those
//              that are determined to be garbage-collectable, it connects to
//              sub-namespaces 'User' and 'Computer'.
//
//              Any of the sub-namespaces that is older than TTLMinutes will be deleted.
//              If no sub-namespaces are left, then the parent namespace is deleted as well.
//
//              Garbage-collectable are those namespaces which satisfy a set of
//              criteria which at the present time is based solely on the naming convention
//              as follows: namespaces under root\rsop whose name starts with "NS"
//
//              Sub-namespaces 'User' and 'Computer' are expected to have an instance of class
//              RSOP_Session. The data member 'creationTime' of that instance is examined when
//              evaluating whether the sub-namespace should be deleted.
//
//
// Parameters:  TTLMinutes -    The maximum number of minutes that may have
//                              elapsed since the creation of a sub-namespace
//
// Return:
//
// History:     12/01/99     leonardm        Created.
//
//******************************************************************************

HRESULT GarbageCollectNamespaces(ULONG TTLMinutes)
{
    XInterface<IWbemLocator> xpWbemLocator = NULL;

    //
    // Connect to namespace ROOT\RSOP
    //

    HRESULT hr = CoCreateInstance(  CLSID_WbemLocator,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IWbemLocator,
                                    (LPVOID*) &xpWbemLocator);
    if(FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: CoCreateInstance returned 0x%x"), hr));
        return hr;
    }

    XInterface<IWbemServices>xpWbemServices = NULL;

    XBStr xbstrNamespace = L"root\\rsop";

    if(!xbstrNamespace)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    hr = xpWbemLocator->ConnectServer(xbstrNamespace,
                                      NULL,
                                      NULL,
                                      0L,
                                      0L,
                                      NULL,
                                      NULL,
                                      &xpWbemServices);
    if(FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: ConnectServer failed. hr=0x%x" ), hr ));
        return hr;
    }

    //
    //  Enumerate all instances of __namespace at the root\rsop level.
    //

    XInterface<IEnumWbemClassObject> xpEnum;
    XBStr xbstrClass = L"__namespace";
    if(!xbstrClass)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    hr = xpWbemServices->CreateInstanceEnum( xbstrClass,
                                            WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY,
                                            NULL,
                                            &xpEnum);
    if(FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: CreateInstanceEnum failed. hr=0x%x" ), hr ));
        return hr;
    }

    XBStr xbstrProperty = L"Name";
    if(!xbstrProperty)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: Failed to allocate memory")));
        return E_FAIL;
    }

    XInterface<IWbemClassObject>xpInstance = NULL;
    ULONG ulReturned = 1;

    while(1)
    {
        hr = xpEnum->Next( WBEM_NO_WAIT, 1, &xpInstance, &ulReturned);
        if (hr != WBEM_S_NO_ERROR || !ulReturned)
        {
            break;
        }

        VARIANT var;
        VariantInit(&var);

        hr = xpInstance->Get(xbstrProperty, 0L, &var, NULL, NULL);
        xpInstance = NULL;
        if(FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: Get failed. hr=0x%x" ), hr ));
            return E_FAIL;
        }

        XBStr xbstrNamespace = var.bstrVal;

        VariantClear( &var );

        if(!xbstrNamespace)
        {
            DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: Failed to allocate memory.")));
            return E_OUTOFMEMORY;
        }

        //
        // For every instance of __namespace under ROOT\RSOP
        // find out whether it is garbage-collectable.
        //

        if(IsGarbageCollectable(xbstrNamespace))
        {
            //
            // If it is garbage-collectable, delete it if it
            // was created more than 'TTLMinutes' minutes ago.
            // In case of failure, continue with next namespace
            // in the enumeration.
            //

            GarbageCollectNamespace(xbstrNamespace, xpWbemServices, TTLMinutes);
        }
    }

    if(hr != WBEM_S_FALSE || ulReturned)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: Get failed. hr=0x%x" ), hr ));
        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\rsop\diagprov.h ===
//*************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:        diagProv.h
//
// Description: Diagnostic mode snapshot provider
//
// History:     8-20-99   leonardm    Created
//
//*************************************************************

#ifndef _SNAPPROV_H__CE49F9FF_5775_4575_9052_C76FBD20AD79__INCLUDED
#define _SNAPPROV_H__CE49F9FF_5775_4575_9052_C76FBD20AD79__INCLUDED

#include <wbemidl.h>
#include "smartptr.h"

#define DENY_RSOP_FROM_INTERACTIVE_USER     L"DenyRsopToInteractiveUser"

extern long g_cObj;
extern long g_cLock;


//*************************************************************
//
// Class:      CNotImplSnapProv
//
// Description:
//
//*************************************************************

class CNotImplSnapProv : public IWbemServices
{
public:

        virtual HRESULT STDMETHODCALLTYPE OpenNamespace(
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall(
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink(
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE GetObject(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE GetObjectAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE PutClass(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE PutClassAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE DeleteClass(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum(
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE PutInstance(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE DeleteInstance(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE ExecQuery(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE ExecMethod(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) { return WBEM_E_NOT_SUPPORTED;}
};


//*************************************************************
//
// Class:       CSnapProv
//
// Description: Actual snapshot provider class
//
//*************************************************************

class CSnapProv : public CNotImplSnapProv, public IWbemProviderInit
{

private:
        long               m_cRef;
        bool               m_bInitialized;
        IWbemServices*     m_pNamespace;

        XBStr              m_xbstrNameSpace;
        XBStr              m_xbstrResult;
        XBStr              m_xbstrExtendedInfo;
        XBStr              m_xbstrClass;
        XBStr              m_xbstrUserSid;
        XBStr              m_xbstrUserSids;
        XBStr              m_xbstrFlags;
        
public:

        CSnapProv();
        ~CSnapProv();

        // From IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppv);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        // From IWbemProviderInit
        STDMETHOD(Initialize)(LPWSTR pszUser,LONG lFlags,LPWSTR pszNamespace,LPWSTR pszLocale,IWbemServices __RPC_FAR *pNamespace,IWbemContext __RPC_FAR *pCtx,IWbemProviderInitSink __RPC_FAR *pInitSink);

        // From IWbemServices
        STDMETHOD(ExecMethodAsync)( const BSTR strObjectPath,
                                    const BSTR strMethodName,
                                    long lFlags,
                                    IWbemContext __RPC_FAR *pCtx,
                                    IWbemClassObject __RPC_FAR *pInParams,
                                    IWbemObjectSink __RPC_FAR *pResponseHandler);

};

#endif // _SNAPPROV_H__CE49F9FF_5775_4575_9052_C76FBD20AD79__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\rsop\factory.h ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:			Factory.h
//
// Description:		
//
// History:    8-20-99   leonardm    Created
//
///////////////////////////////////////////////////////////////////////////////////

#ifndef _FACTORY_H__CB339D7F_83AC_4dd4_9DD3_C7737D698CD3__INCLUDED
#define _FACTORY_H__CB339D7F_83AC_4dd4_9DD3_C7737D698CD3__INCLUDED

///////////////////////////////////////////////////////////////////////////////////
//
// Class:	
//
// Description:	
//
// History:		8/20/99		leonardm	Created.
//
///////////////////////////////////////////////////////////////////////////////////
class CProvFactory : public IClassFactory
{
private:
	long m_cRef;

public:
  CProvFactory();
  ~CProvFactory();

  // From IUnknown
  STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppv);
  STDMETHOD_(ULONG, AddRef)();
  STDMETHOD_(ULONG, Release)();

  // From IClassFactory
  STDMETHOD(CreateInstance)(LPUNKNOWN punk, REFIID riid, LPVOID* ppv);
  STDMETHOD(LockServer)(BOOL bLock);
};

#endif // _FACTORY_H__CB339D7F_83AC_4dd4_9DD3_C7737D698CD3__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\rsop\logger.h ===
//***********************************************
//
//  Resultant set of policy
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//  History:    7-Jun-99   SitaramR    Created
//
//*************************************************************

#include "..\rsoputil\smartptr.h"
#include <initguid.h>

class CSessionLogger
{
public:
    CSessionLogger( IWbemServices *pWbemServices );
    BOOL Log(LPRSOPSESSIONDATA lprsopSessionData );

private:
    BOOL                           m_bInitialized;
    XBStr                          m_xbstrId;
    XBStr                          m_xbstrVersion;
    XBStr                          m_xbstrTargetName;
    XBStr                          m_xbstrSOM;
    XBStr                          m_xbstrSecurityGroups;
    XBStr                          m_xbstrSite;
    XBStr                          m_xbstrCreationTime;
    XBStr                          m_xbstrIsSlowLink;

    XBStr                          m_xbstrClass;
    XInterface<IWbemClassObject>   m_xClass;

    IWbemServices *                m_pWbemServices;
};


class CSOMLogger
{
public:
    CSOMLogger( DWORD dwFlags, IWbemServices *pWbemServices );
    BOOL Log( SCOPEOFMGMT *pSOM, DWORD dwOrder, BOOL bLoopback );

private:
    BOOL                           m_bInitialized;
    DWORD                          m_dwFlags;
    XBStr                          m_xbstrId;
    XBStr                          m_xbstrType;
    XBStr                          m_xbstrOrder;
    XBStr                          m_xbstrBlocking;
    XBStr                          m_xbstrBlocked;
    XBStr                          m_xbstrReason;
    XBStr                          m_xbstrClass;
    XInterface<IWbemClassObject>   m_xClass;
    XInterface<IWbemClassObject>   m_pInstance;
    IWbemServices *                m_pWbemServices;
};


class CGpoLogger
{
public:
    CGpoLogger( DWORD dwFlags, IWbemServices *pWbemServices );
    BOOL Log( GPCONTAINER *pGpContainer );

private:
    BOOL                           m_bInitialized;
    DWORD                          m_dwFlags;
    XBStr                          m_xbstrId;
    XBStr                          m_xbstrGuidName;
    XBStr                          m_xbstrDisplayName;
    XBStr                          m_xbstrFileSysPath;
    XBStr                          m_xbstrVer;
    XBStr                          m_xbstrAccessDenied;
    XBStr                          m_xbstrEnabled;
    XBStr                          m_xbstrSD;
    XBStr                          m_xbstrFilterAllowed;
    XBStr                          m_xbstrFilterId;
    XBStr                          m_xbstrClass;
    XInterface<IWbemClassObject>   m_xClass;
    XInterface<IWbemClassObject>   m_pInstance;
    IWbemServices *                m_pWbemServices;
};



class CGpLinkLogger
{
public:
    CGpLinkLogger( IWbemServices *pWbemServices );
    BOOL Log( WCHAR *pwszSOMId, BOOL bLoopback, GPLINK *pGpLink, DWORD dwSomOrder,
              DWORD dwLinkOrder, DWORD dwAppliedOrder );

private:
    BOOL                           m_bInitialized;
    XBStr                          m_xbstrSOM;
    XBStr                          m_xbstrGPO;
    XBStr                          m_xbstrOrder;
    XBStr                          m_xbstrLinkOrder;
    XBStr                          m_xbstrAppliedOrder;
    XBStr                          m_xbstrEnabled;
    XBStr                          m_xbstrEnforced;
    XBStr                          m_xbstrClass;
    XInterface<IWbemClassObject>   m_xClass;
    XInterface<IWbemClassObject>   m_pInstance;
    IWbemServices *                m_pWbemServices;
};


/*
class CGpLinkListLogger
{
public:
    CGpLinkListLogger( DWORD dwFlags, IWbemServices *pWbemServices );
    BOOL Log( PGROUP_POLICY_OBJECT pGPO, DWORD dwSOMOrder, BOOL bLoopback, DWORD dwTypeOrder );

private:
    BOOL                           m_bInitialized;
    DWORD                          m_dwFlags;
    XBStr                          m_xbstrGpLink;
    XBStr                          m_xbstrOrder;
    XBStr                          m_xbstrClass;
    XInterface<IWbemClassObject>   m_xClass;
    XInterface<IWbemClassObject>   m_pInstance;
    IWbemServices *                m_pWbemServices;
};
*/

WCHAR *StripPrefix( WCHAR *pwszPath );
WCHAR *StripLinkPrefix( WCHAR *pwszPath );


class CRegistryLogger
{
public:
    CRegistryLogger( DWORD dwFlags, IWbemServices *pWbemServices );
    BOOL Log( WCHAR *pwszKeyName, WCHAR *pwszValueName,
              REGDATAENTRY *pDataEntry, DWORD dwOrder );

private:
    BOOL                           m_bInitialized;
    DWORD                          m_dwFlags;
    XBStr                          m_xbstrClass;
    XInterface<IWbemClassObject>   m_xClass;
    IWbemServices *                m_pWbemServices;

    //
    // Strings for parent policy object
    //
    XBStr                          m_xbstrId;
    XBStr                          m_xbstrName;
    XBStr                          m_xbstrGPO;
    XBStr                          m_xbstrSOM;
    XBStr                          m_xbstrPrecedence;

    //
    // Strings for registry policy object
    //
    XBStr                          m_xbstrKey;
    XBStr                          m_xbstrValueName;
    XBStr                          m_xbstrDeleted;
    XBStr                          m_xbstrValueType;
    XBStr                          m_xbstrValue;
    XBStr                          m_xbstrCommand;
};


BOOL LogBlobProperty( IWbemClassObject *pInstance, BSTR bstrPropName, BYTE *pbBlob,
                      DWORD dwLen );


class CAdmFileLogger
{

public:
    CAdmFileLogger( IWbemServices *pWbemServices );
    BOOL Log( ADMFILEINFO *pAdmInfo );

private:
    BOOL                           m_bInitialized;
    IWbemServices *                m_pWbemServices;

    //
    // Strings for Adm policy object
    //
    XBStr                          m_xbstrName;
    XBStr                          m_xbstrGpoId;
    XBStr                          m_xbstrWriteTime;
    XBStr                          m_xbstrData;
    XBStr                          m_xbstrClass;
    XInterface<IWbemClassObject>   m_xClass;
};



class CExtSessionLogger
{

public:
    CExtSessionLogger( IWbemServices *pWbemServices );
    BOOL Log( LPGPEXT lpExt, BOOL bSupported );
    BOOL Update( LPTSTR lpExtKeyName, BOOL bLoggingIncomplete, DWORD dwErr );
    BOOL Set( LPGPEXT lpExt, BOOL bSupported, LPRSOPEXTSTATUS lpRsopExtStatus );


private:
    BOOL                           m_bInitialized;
    IWbemServices *                m_pWbemServices;

    //
    // Strings for ExtSession Status policy object
    //
    
    XBStr                          m_xbstrExtGuid;
    XBStr                          m_xbstrDisplayName;
    XBStr                          m_xbstrPolicyBeginTime;
    XBStr                          m_xbstrPolicyEndTime;
    XBStr                          m_xbstrStatus;
    XBStr                          m_xbstrError;
    XBStr                          m_xbstrClass;
    XInterface<IWbemClassObject>   m_xClass;

    WCHAR                          m_szGPCoreNameBuf[100];
};


extern BOOL DeleteInstances( WCHAR *pwszClass, IWbemServices *pWbemServices );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\rsop\logger.cpp ===
//*************************************************************
//
//  Resultant set of policy, Logger classes
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//  History:    7-Jun-99   SitaramR    Created
//
//*************************************************************

#include "stdio.h"
#include "uenv.h"
#include <wbemcli.h>
#include "reghash.h"
#include "logger.h"
#include "..\rsoputil\wbemtime.h"
#include "SmartPtr.h"
#include "rsopinc.h"
#include <ntdsapi.h>

BOOL PrintToString( XPtrST<WCHAR>& xwszValue, WCHAR *wszString,
                    WCHAR *pwszParam1, WCHAR *pwszParam2, DWORD dwParam3 );
BOOL LogTimeProperty( IWbemClassObject *pInstance, BSTR bstrPropName, SYSTEMTIME *pSysTime );
HRESULT LogSecurityGroups( IWbemClassObject *pInstance, BSTR bstrPropName, PTOKEN_GROUPS pTokenGroups );
LPWSTR DsUnquoteDN( LPCWSTR szQDN, BOOL bGpLink = FALSE );

const MAX_LENGTH = 100; // Length of stringized guid

//*************************************************************
//
//  DsUnquoteDN()
//
//  Purpose:    Convert a quoted/escaped DN to an unquoted/unescaped DN 
//
//  Parameters: szQDN - quoted/escaped DN       ou=\+test\+1,dc="nt dev",dc=com
//              
//  Return:
//              szUDN - unquoted/unescaped DN   ou=+test+1,dc=nt dev,dc=com
//
//*************************************************************

LPWSTR
DsUnquoteDN( LPCWSTR szQDN, BOOL bGpLink )
{
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   cQDN = wcslen( szQDN );
    DWORD   cKey = 0, cVal = 0;
    LPCWSTR szKey = 0, szVal = 0;
    
    XPtrLF<WCHAR>   szUDN = LocalAlloc( LPTR, ( wcslen( szQDN ) + 32 ) * sizeof( WCHAR ) );

    if ( !szUDN )
    {
        return 0;
    }
    
    while ( cQDN )
    {
        //
        // crack the DN and get the RDN
        // ou=\+test,dc=microsoft,dc=com
        //
        dwError = DsGetRdnW(&szQDN,
                            &cQDN,
                            &szKey,
                            &cKey,
                            &szVal,
                            &cVal );
        if ( dwError == ERROR_SUCCESS )
        {
            //
            // slap on the key, ou=
            //
            if ( cKey )
            {
                wcsncat( szUDN, szKey, cKey );
                wcscat( szUDN, L"=" );
            }
            if ( cVal )
            {
                //
                // unquote/unescape the RDN
                //
                DWORD   cURDN = 255;
                WCHAR   szURDN[255];

                dwError = DsUnquoteRdnValue(cVal,
                                            szVal,
                                            &cURDN,
                                            szURDN );
                if ( dwError == ERROR_SUCCESS )
                {
                    //
                    // slap on the unquoted value, +test,
                    //
                    LPWSTR szEnd = szUDN + wcslen( szUDN );
                    for ( DWORD i = 0 ; i < cURDN ; i++ )
                    {
                        if ( szURDN[i] == L'"' )
                        {
                            *szEnd++ = L'\\';
                            if ( bGpLink )
                            {
                                *szEnd++ = L'\\';
                                *szEnd++ = L'\\';
                            }
                        }
                        *szEnd++ = szURDN[i];
                    }
                    *szEnd++ = L',';
                    *szEnd = 0;
                }
                else
                {
                    break;
                }
            }
        }
        else
        {
            break;
        }
    }

    if ( dwError == ERROR_SUCCESS )
    {
        //
        // remove the extra trailing ','
        //
        cKey = wcslen( szUDN );
        if ( cKey )
        {
            szUDN[cKey-1] = 0;
        }
        
        return szUDN.Acquire();
    }

    return 0;
}

//*************************************************************
//
//  CSessionLogger::CSessionLogger()
//
//  Purpose:    Constructor
//
//  Parameters: pWbemServices - Wbem services
//
//*************************************************************

CSessionLogger::CSessionLogger( IWbemServices *pWbemServices )
     : m_bInitialized(FALSE),
       m_pWbemServices(pWbemServices)
{
    m_xbstrId = L"id";
    if ( !m_xbstrId )
        return;

    m_xbstrTargetName = L"targetName";
    if ( !m_xbstrTargetName )
        return;

    m_xbstrSOM = L"SOM";
    if ( !m_xbstrSOM )
        return;

    m_xbstrSecurityGroups = L"SecurityGroups";
    if ( !m_xbstrSecurityGroups )
        return;

    m_xbstrSite = L"Site";
    if ( !m_xbstrSite )
        return;

    m_xbstrCreationTime = L"creationTime";
    if ( !m_xbstrCreationTime )
        return;

    m_xbstrIsSlowLink = L"slowLink";
    if ( !m_xbstrIsSlowLink )
        return;

    m_xbstrVersion = L"version";
    if ( !m_xbstrVersion )
        return;

    m_xbstrClass = L"RSOP_Session";
    if ( !m_xbstrClass )
        return;


    HRESULT hr = m_pWbemServices->GetObject( m_xbstrClass,
                                             0L,
                                             NULL,
                                             &m_xClass,
                                             NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::CSessionLogger: GetObject failed with 0x%x" ), hr ));
        return;
    }

    m_bInitialized = TRUE;
}



//*************************************************************
//
//  CSessionLogger::Log()
//
//  Purpose:    Logs an instance of session object
//
//*************************************************************

BOOL CSessionLogger::Log(LPRSOPSESSIONDATA lprsopSessionData )
{
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Failed to initialize." )));
        return FALSE;
    }


    //
    // First get the creation time
    //

    XBStr xbstrCreationTimeValue; // initialised to null
    XSafeArray xsaSecurityGrps;

    XBStr xbstrInstancePath = L"RSOP_Session.id=\"Session1\"";
    if(!xbstrInstancePath)
    {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Failed to allocate memory.")));
        return FALSE;
    }


    XInterface<IWbemClassObject>xpInstance = NULL;
    HRESULT hr = m_pWbemServices->GetObject(xbstrInstancePath, 0, NULL, &xpInstance, NULL);

    if(SUCCEEDED(hr))
    {
        VARIANT var;
        VariantInit(&var);
        XVariant xVar(&var);

        hr = xpInstance->Get(m_xbstrCreationTime, 0, &var, NULL, NULL);

        if((SUCCEEDED(hr)) && ( var.vt != VT_NULL ))
        {
            xbstrCreationTimeValue = var.bstrVal;
        }
        else
        {
            DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: Get failed. hr=0x%08X."), hr));
        }

        VariantClear(&var);

        hr = xpInstance->Get(m_xbstrSecurityGroups, 0, &var, NULL, NULL);

        if((SUCCEEDED(hr)) && ( var.vt != VT_NULL ))
        {
             SafeArrayCopy(var.parray, &xsaSecurityGrps);
        }
        else
        {
            DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: Get failed. hr=0x%08X."), hr));
        }
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: GetObject failed. hr=0x%08X"), hr));
    }



    IWbemClassObject *pInstance = NULL;

    hr = m_xClass->SpawnInstance( 0, &pInstance );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: SpawnInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    XInterface<IWbemClassObject> xInstance( pInstance );

    XBStr xId( L"Session1" );
    if ( !xId ) {
         DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal = xId;
    hr = pInstance->Put( m_xbstrId, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    //
    // Version
    //

    var.vt = VT_I4;
    var.lVal = RSOP_MOF_SCHEMA_VERSION;
    hr = pInstance->Put( m_xbstrVersion, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    //
    // IsSlowLink
    //

    var.vt = VT_BOOL;
    var.boolVal = lprsopSessionData->bSlowLink ? VARIANT_TRUE : VARIANT_FALSE;
    hr = pInstance->Put( m_xbstrIsSlowLink, 0, &var, 0 );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    //
    // Target Name, can be null for dummy user in planning mode
    //

    XBStr xTarget( lprsopSessionData->pwszTargetName );
    if ( lprsopSessionData->pwszTargetName ) {

        if ( !xTarget ) {
            DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Failed to allocate memory" )));
            return FALSE;
        }

        var.vt = VT_BSTR;
        var.bstrVal = xTarget;
        hr = pInstance->Put( m_xbstrTargetName, 0, &var, 0 );
        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed with 0x%x" ), hr ));
            return FALSE;
        }

    }

    //
    // SOM, if Applicable (non NULL)
    //

    XBStr xSOM( lprsopSessionData->pwszSOM );

    if (lprsopSessionData->pwszSOM) {

        if ( !xSOM ) {
             DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Failed to allocate memory" )));
            return FALSE;
        }

        var.vt = VT_BSTR;
        var.bstrVal = xSOM;
        hr = pInstance->Put( m_xbstrSOM, 0, &var, 0 );
        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed with 0x%x" ), hr ));
            return FALSE;
        }
    }
    else {
         DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: new SOM is NULL")));
    }


    //
    // Security Group, if Applicable (non NULL)
    //


    if (lprsopSessionData->bLogSecurityGroup) {
        DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: logging new security grps" )));

        hr = LogSecurityGroups(pInstance, m_xbstrSecurityGroups, lprsopSessionData->pSecurityGroups);
    }
    else {

        if ( lprsopSessionData->pSecurityGroups && !xsaSecurityGrps ) {
            DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: logging new security grps because it wasn't defined before" )));
            hr = LogSecurityGroups(pInstance, m_xbstrSecurityGroups, lprsopSessionData->pSecurityGroups);
        }
        else {
            
            //
            // reset the old value
            //
            DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: restoring old security grps" )));

            var.vt = VT_ARRAY | VT_BSTR;
            var.parray = (SAFEARRAY *)xsaSecurityGrps;
            hr = pInstance->Put( m_xbstrSecurityGroups, 0, &var, 0 );
        }
    }

    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    //
    // Site, if Applicable (non NULL)
    //

    XBStr xSite( lprsopSessionData->pwszSite );

    if (lprsopSessionData->pwszSite) {

        if ( !xSite ) {
             DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Failed to allocate memory" )));
            return FALSE;
        }

        var.vt = VT_BSTR;
        var.bstrVal = lprsopSessionData->pwszSite;
        hr = pInstance->Put( m_xbstrSite, 0, &var, 0 );
        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed with 0x%x" ), hr ));
            return FALSE;
        }
    }
    else {
         DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: new Site is NULL")));
    }


    //
    // Update or set the creation Time
    //

    SYSTEMTIME sysTime;

    if (xbstrCreationTimeValue) {
        var.vt = VT_BSTR;
        var.bstrVal = xbstrCreationTimeValue;

        hr = pInstance->Put( m_xbstrCreationTime, 0, &var, 0 );
        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed for creationtime with 0x%x" ), hr ));
            return FALSE;
        }
    }
    else {

        // if it doesn't exist already create it as current time..
        GetSystemTime(&sysTime);
        LogTimeProperty( pInstance, m_xbstrCreationTime, &sysTime );
    }


    //
    // Instantiate...
    //

    hr = m_pWbemServices->PutInstance( pInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );

    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}




//*************************************************************
//
//  CSomLogger::CSOMLogger()
//
//  Purpose:    Constructor
//
//  Parameters: dwFlags       - Flags
//              pWbemServices - Wbem services
//
//*************************************************************

CSOMLogger::CSOMLogger( DWORD dwFlags, IWbemServices *pWbemServices )
     : m_bInitialized(FALSE),
       m_dwFlags(dwFlags),
       m_pWbemServices(pWbemServices)
{
    m_xbstrId = L"id";
    if ( !m_xbstrId )
        return;

    m_xbstrType = L"type";
    if ( !m_xbstrType )
        return;

    m_xbstrOrder = L"SOMOrder";
    if ( !m_xbstrOrder )
        return;

    m_xbstrBlocking = L"blocking";
    if ( !m_xbstrBlocking )
        return;


    m_xbstrBlocked = L"blocked";
    if ( !m_xbstrBlocked )
        return;

    
    m_xbstrReason = L"reason";
    if ( !m_xbstrReason )
        return;

    m_xbstrClass = L"RSOP_SOM";
    if ( !m_xbstrClass )
        return;

    HRESULT hr = m_pWbemServices->GetObject( m_xbstrClass,
                                             0L,
                                             NULL,
                                             &m_xClass,
                                             NULL );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::CSOMLogger: GetObject failed with 0x%x" ), hr ));
        return;
    }

    hr = m_xClass->SpawnInstance( 0, &m_pInstance );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::CSOMLogger: SpawnInstance failed with 0x%x" ), hr ));
        return;
    }

    m_bInitialized = TRUE;
}



//*************************************************************
//
//  CSomLogger::Log()
//
//  Purpose:    Logs an instance of scope of management
//
//  Parameters: pSOM  - SOM to log
//
//*************************************************************

BOOL CSOMLogger::Log( SCOPEOFMGMT *pSOM, DWORD dwOrder, BOOL bLoopback )
{
    if ( !m_bInitialized )
    {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: Failed to initialize." )));
        return FALSE;
    }

    HRESULT hr;
    VARIANT var;

    var.vt = VT_I4;
    var.lVal = pSOM->dwType;
    hr = m_pInstance->Put( m_xbstrType, 0, &var, 0 );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.lVal = dwOrder;
    hr = m_pInstance->Put( m_xbstrOrder, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.vt = VT_BOOL;
    var.boolVal = pSOM->bBlocking ? VARIANT_TRUE : VARIANT_FALSE;

    hr = m_pInstance->Put( m_xbstrBlocking, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.vt = VT_BOOL;
    var.boolVal = pSOM->bBlocked ? VARIANT_TRUE : VARIANT_FALSE;

    hr = m_pInstance->Put( m_xbstrBlocked, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.vt = VT_I4;
    var.lVal = bLoopback ? 2 : 1;

    hr = m_pInstance->Put( m_xbstrReason, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    XPtrLF<WCHAR> xDSPath = DsUnquoteDN( pSOM->pwszSOMId );
    XBStr xId;

    if ( !xDSPath )
    {
        xId = pSOM->pwszSOMId;
    }
    else
    {
        xId = xDSPath;
    }
    
    if ( !xId ) {
         DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.vt = VT_BSTR;
    var.bstrVal = xId;
    hr = m_pInstance->Put( m_xbstrId, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    hr = m_pWbemServices->PutInstance( m_pInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}


//*************************************************************
//
//  CGpoLogger::CGpoLogger()
//
//  Purpose:    Constructor
//
//  Parameters: pWbemServices - Wbem services
//
//*************************************************************

CGpoLogger::CGpoLogger( DWORD dwFlags, IWbemServices *pWbemServices )
     : m_bInitialized(FALSE),
       m_dwFlags(dwFlags),
       m_pWbemServices(pWbemServices)
{
    m_xbstrId = L"id";
    if ( !m_xbstrId )
        return;

    m_xbstrGuidName = L"guidName";
    if ( !m_xbstrGuidName )
        return;

    m_xbstrDisplayName = L"name";
    if ( !m_xbstrDisplayName )
        return;

    m_xbstrFileSysPath = L"fileSystemPath";
    if ( !m_xbstrFileSysPath )
        return;

    m_xbstrVer = L"version";
    if ( !m_xbstrVer )
        return;

    m_xbstrAccessDenied = L"accessDenied";
    if ( !m_xbstrAccessDenied )
        return;

    m_xbstrEnabled = L"enabled";
    if ( !m_xbstrEnabled )
        return;

    m_xbstrSD = L"securityDescriptor";
    if ( !m_xbstrSD )
        return;

    m_xbstrFilterAllowed = L"filterAllowed";
    if ( !m_xbstrFilterAllowed )
        return;

    m_xbstrFilterId = L"filterId";
    if ( !m_xbstrFilterId )
        return;

    m_xbstrClass = L"RSOP_GPO";
    if ( !m_xbstrClass )
        return;

    HRESULT hr = m_pWbemServices->GetObject( m_xbstrClass,
                                             0L,
                                             NULL,
                                             &m_xClass,
                                             NULL );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::CGpoLogger: GetObject failed with 0x%x" ), hr ));
        return;
    }

    hr = m_xClass->SpawnInstance( 0, &m_pInstance );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::CGpoLogger: SpawnInstance failed with 0x%x" ), hr ));
        return;
    }

    m_bInitialized = TRUE;
}


//*************************************************************
//
//  CGpoLogger::Log()
//
//  Purpose:    Logs an instance of scope of management
//
//  Parameters: pGpContainer  - Gp container
//
//*************************************************************

BOOL CGpoLogger::Log( GPCONTAINER *pGpContainer )
{
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Failed to initialize." )));
        return FALSE;
    }

    HRESULT hr;
    VARIANT var;

    var.vt = VT_I4;
    if ( m_dwFlags & GP_MACHINE )
        var.lVal = pGpContainer->dwMachVersion;
    else
        var.lVal = pGpContainer->dwUserVersion;

    hr = m_pInstance->Put( m_xbstrVer, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    //
    // Note the change from disabled <--> enabled
    //

    var.vt = VT_BOOL;
    if ( m_dwFlags & GP_MACHINE )
        var.boolVal = pGpContainer->bMachDisabled ? VARIANT_FALSE : VARIANT_TRUE;
    else
        var.boolVal = pGpContainer->bUserDisabled ? VARIANT_FALSE : VARIANT_TRUE;

    hr = m_pInstance->Put( m_xbstrEnabled, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.boolVal = pGpContainer->bAccessDenied ? VARIANT_TRUE : VARIANT_FALSE;
    hr = m_pInstance->Put( m_xbstrAccessDenied, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.boolVal = pGpContainer->bFilterAllowed ? VARIANT_TRUE : VARIANT_FALSE;
    hr = m_pInstance->Put( m_xbstrFilterAllowed, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    if ( pGpContainer->pwszFilterId ) {

        XBStr xFilterId( pGpContainer->pwszFilterId );
        if ( !xFilterId ) {
             DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Failed to allocate memory" )));
             return FALSE;
        }

        var.vt = VT_BSTR;
        var.bstrVal = xFilterId;
        hr = m_pInstance->Put( m_xbstrFilterId, 0, &var, 0 );
        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
            return FALSE;
        }
    }

    XBStr xId = pGpContainer->pwszDSPath;
    if ( !xId ) {
         DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.vt = VT_BSTR;
    var.bstrVal = xId;
    hr = m_pInstance->Put( m_xbstrId, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    XBStr xGuid( pGpContainer->pwszGPOName );
    if ( !xGuid ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Failed to allocate memory" )));
        return FALSE;
    }

    var.bstrVal = xGuid;
    hr = m_pInstance->Put( m_xbstrGuidName, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    XBStr xDisplay( pGpContainer->pwszDisplayName );
    if ( !xDisplay ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Failed to allocate memory" )));
        return FALSE;
    }

    var.bstrVal = xDisplay;
    hr = m_pInstance->Put( m_xbstrDisplayName, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    XBStr xFile( pGpContainer->pwszFileSysPath );
    if ( !xFile ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Failed to allocate memory" )));
        return FALSE;
    }

    var.bstrVal = xFile;
    hr = m_pInstance->Put( m_xbstrFileSysPath, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    if ( !LogBlobProperty( m_pInstance, m_xbstrSD,
                           (BYTE *) pGpContainer->pSD, pGpContainer->cbSDLen ) ) {
        return FALSE;
    }

    hr = m_pWbemServices->PutInstance( m_pInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}


//*************************************************************
//
//  CGpLinkLogger::CGpLinkLogger()
//
//  Purpose:    Constructor
//
//  Parameters: pWbemServices - Wbem services
//
//*************************************************************

CGpLinkLogger::CGpLinkLogger( IWbemServices *pWbemServices )
     : m_bInitialized(FALSE),
       m_pWbemServices(pWbemServices)
{
    m_xbstrSOM = L"SOM";
    if ( !m_xbstrSOM )
        return;

    m_xbstrGPO = L"GPO";
    if ( !m_xbstrGPO )
        return;

    m_xbstrOrder = L"somOrder";
    if ( !m_xbstrOrder )
        return;

    m_xbstrLinkOrder = L"linkOrder";
    if ( !m_xbstrLinkOrder )
        return;

    m_xbstrAppliedOrder = L"appliedOrder";
    if ( !m_xbstrAppliedOrder )
        return;

    m_xbstrEnabled = L"Enabled";
    if ( !m_xbstrEnabled )
        return;

    m_xbstrEnforced = L"noOverride";
    if ( !m_xbstrEnforced )
        return;

    m_xbstrClass = L"RSOP_GPLink";
    if ( !m_xbstrClass )
        return;

    HRESULT hr = m_pWbemServices->GetObject( m_xbstrClass,
                                             0L,
                                             NULL,
                                             &m_xClass,
                                             NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::CGpLinkLogger: GetObject failed with 0x%x" ), hr ));
        return;
    }

    hr = m_xClass->SpawnInstance( 0, &m_pInstance );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::CGpLinkLogger: SpawnInstance failed with 0x%x" ), hr ));
        return;
    }

    m_bInitialized = TRUE;
}



//*************************************************************
//
//  CGpLinkLogger::Log()
//
//  Purpose:    Logs an instance of scope of management
//
//  Parameters: pwszSOMID   - SOM that the Gpos are linked to
//              pGpLink     - Gpo
//              dwOrder     - Order of Gpo in SOM
//
//*************************************************************

BOOL CGpLinkLogger::Log( WCHAR *pwszSOMId, BOOL bLoopback, GPLINK *pGpLink, DWORD dwSomOrder,
                         DWORD dwLinkOrder, DWORD dwAppliedOrder )
{
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Failed to initialize." )));
        return FALSE;
    }

    VARIANT var;
    HRESULT hr;

    var.vt = VT_I4;
    var.lVal = dwSomOrder;
    hr = m_pInstance->Put( m_xbstrOrder, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.vt = VT_I4;
    var.lVal = dwLinkOrder;
    hr = m_pInstance->Put( m_xbstrLinkOrder, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.vt = VT_I4;
    var.lVal = dwAppliedOrder;
    hr = m_pInstance->Put( m_xbstrAppliedOrder, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.vt = VT_BOOL;
    var.boolVal = pGpLink->bEnabled ? VARIANT_TRUE : VARIANT_FALSE;
    hr = m_pInstance->Put( m_xbstrEnabled, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.boolVal = pGpLink->bNoOverride ? VARIANT_TRUE : VARIANT_FALSE;
    hr = m_pInstance->Put( m_xbstrEnforced, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    XPtrLF<WCHAR> szUnquote = DsUnquoteDN( pwszSOMId, TRUE );
    WCHAR wszSOMRef[] = L"RSOP_SOM.id=\"%ws\",reason=%s";
    XPtrST<WCHAR> xwszSOMValue;

    if (szUnquote)
    {
        if ( !PrintToString( xwszSOMValue, wszSOMRef, szUnquote, bLoopback ? L"2" : L"1", 0 ) )
            return FALSE;
    }
    else
    {
        if ( !PrintToString( xwszSOMValue, wszSOMRef, pwszSOMId, bLoopback ? L"2" : L"1", 0 ) )
            return FALSE;
    }

    XBStr xbstrSOMValue( xwszSOMValue );
    if ( !xbstrSOMValue ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Failed to allocate memory" )));
        return FALSE;
    }

    var.vt = VT_BSTR;
    var.bstrVal = xbstrSOMValue;
    hr = m_pInstance->Put( m_xbstrSOM, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    WCHAR wszGPORef[] = L"RSOP_GPO.id=\"%ws\"";
    XPtrST<WCHAR> xwszGPOValue;
    
    if ( !PrintToString( xwszGPOValue, wszGPORef, pGpLink->pwszGPO, 0, 0 ) )
        return FALSE;

    XBStr xbstrGPOValue( xwszGPOValue );
    if ( !xbstrGPOValue ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Failed to allocate memory" )));
        return FALSE;
    }

    var.bstrVal = xbstrGPOValue;

    hr = m_pInstance->Put( m_xbstrGPO, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    hr = m_pWbemServices->PutInstance( m_pInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}



//*************************************************************
//
//  StripPrefix()
//
//  Purpose:    Strips out prefix to get canonical path to Gpo
//
//  Parameters: lpGPOInfo     - Gpo Info
//              pWbemServices - Wbem services
//
//  Returns:    Pointer to suffix
//
//*************************************************************

WCHAR *StripPrefix( WCHAR *pwszPath )
{
    WCHAR wszMachPrefix[] = TEXT("LDAP://CN=Machine,");
    INT iMachPrefixLen = lstrlen( wszMachPrefix );
    WCHAR wszUserPrefix[] = TEXT("LDAP://CN=User,");
    INT iUserPrefixLen = lstrlen( wszUserPrefix );
    WCHAR *pwszPathSuffix;

    //
    // Strip out prefix to get the canonical path to Gpo
    //

    if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                        pwszPath, iUserPrefixLen, wszUserPrefix, iUserPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iUserPrefixLen;
    } else if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                        pwszPath, iMachPrefixLen, wszMachPrefix, iMachPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iMachPrefixLen;
    } else
        pwszPathSuffix = pwszPath;

    return pwszPathSuffix;
}


//*************************************************************
//
//  StripLinkPrefix()
//
//  Purpose:    Strips out prefix to get canonical path to DS
//              object
//
//  Parameters: pwszPath - path to strip
//
//  Returns:    Pointer to suffix
//
//*************************************************************

WCHAR *StripLinkPrefix( WCHAR *pwszPath )
{
    WCHAR wszPrefix[] = TEXT("LDAP://");
    INT iPrefixLen = lstrlen( wszPrefix );
    WCHAR *pwszPathSuffix;

    //
    // Strip out prefix to get the canonical path to Som
    //

    if ( wcslen(pwszPath) <= (DWORD) iPrefixLen ) {
        return pwszPath;
    }

    if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                        pwszPath, iPrefixLen, wszPrefix, iPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iPrefixLen;
    } else
        pwszPathSuffix = pwszPath;

    return pwszPathSuffix;
}



//*************************************************************
//
//  CRegistryLogger::CRegistryLogger()
//
//  Purpose:    Constructor
//
//  Parameters: dwFlags       - Flags
//              pWbemServices - Wbem services
//
//*************************************************************

CRegistryLogger::CRegistryLogger( DWORD dwFlags, IWbemServices *pWbemServices )
     : m_bInitialized(FALSE),
       m_dwFlags(dwFlags),
       m_pWbemServices(pWbemServices)
{
    m_xbstrId = L"id";
    if ( !m_xbstrId )
        return;

    m_xbstrName = L"name";
    if ( !m_xbstrName )
        return;

    m_xbstrGPO = L"GPOID";
    if ( !m_xbstrGPO )
        return;

    m_xbstrSOM = L"SOMID";
    if ( !m_xbstrSOM )
        return;

    m_xbstrPrecedence = L"precedence";
    if ( !m_xbstrPrecedence )
        return;

    m_xbstrKey = L"registryKey";
    if ( !m_xbstrKey )
        return;

    m_xbstrValueName = L"valueName";
    if ( !m_xbstrValueName )
        return;

    m_xbstrDeleted = L"deleted";
    if ( !m_xbstrDeleted )
        return;

    m_xbstrValueType = L"valueType";
    if ( !m_xbstrValueType )
        return;

    m_xbstrValue = L"value";
    if ( !m_xbstrValue )
        return;

    m_xbstrCommand = L"command";
    if ( !m_xbstrCommand )
        return;

    m_xbstrClass = L"RSOP_RegistryPolicySetting";
    if ( !m_xbstrClass )
        return;

    HRESULT hr = m_pWbemServices->GetObject( m_xbstrClass,
                                             0L,
                                             NULL,
                                             &m_xClass,
                                             NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkListLogger::CGpLinkListLogger: GetObject failed with 0x%x" ), hr ));
        return;
    }

    m_bInitialized = TRUE;
}



//*************************************************************
//
//  CRegistryLogger::Log()
//
//  Purpose:    Logs an instance of registry policy object
//
//  Parameters: pwszKeyName   - Registry key name
//              pwszValueName - Value name
//              pDataEntry    - Data entry
//              dwOrder       - Precedence order
//
//*************************************************************

BOOL CRegistryLogger::Log( WCHAR *pwszKeyName, WCHAR *pwszValueName,
                           REGDATAENTRY *pDataEntry, DWORD dwOrder )
{
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Failed to initialize." )));
        return FALSE;
    }

    IWbemClassObject *pInstance = NULL;

    HRESULT hr = m_xClass->SpawnInstance( 0, &pInstance );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: SpawnInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    XInterface<IWbemClassObject> xInstance( pInstance );

    VARIANT var;
    var.vt = VT_I4;
    var.lVal = dwOrder;
    hr = pInstance->Put( m_xbstrPrecedence, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    if ( pDataEntry->bDeleted ) {
        var.vt = VT_BOOL;
        var.boolVal = VARIANT_TRUE;
        hr = pInstance->Put( m_xbstrDeleted, 0, &var, 0 );
        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
            return FALSE;
        }
    }

    XBStr xName( pwszValueName );
    if ( !xName ) {
         DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.vt = VT_BSTR;
    var.bstrVal = xName;
    hr = pInstance->Put( m_xbstrName, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    hr = pInstance->Put( m_xbstrValueName, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    XBStr xKey( pwszKeyName );
    if ( !xKey ) {
         DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.bstrVal = xKey;
    hr = pInstance->Put( m_xbstrKey, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    WCHAR *pwszPath = StripPrefix( pDataEntry->pwszGPO );

    XBStr xGPO( pwszPath );
    if ( !xGPO ) {
         DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.bstrVal = xGPO;
    hr = pInstance->Put( m_xbstrGPO, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    WCHAR *pwszSomPath = StripLinkPrefix( pDataEntry->pwszSOM );

    XBStr xSOM( pwszSomPath );
    if ( !xSOM ) {
         DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.bstrVal = xSOM;
    hr = pInstance->Put( m_xbstrSOM, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    XBStr xCommand( pDataEntry->pwszCommand );
    if ( !xCommand ) {
         DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.bstrVal = xCommand;
    hr = pInstance->Put( m_xbstrCommand, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    WCHAR wszId[MAX_LENGTH];
    GUID guid;

    OLE32_API *pOle32Api = LoadOle32Api();
    if ( pOle32Api == NULL )
        return FALSE;

    hr = pOle32Api->pfnCoCreateGuid( &guid );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Failed to obtain guid" )));
        return FALSE;
    }

    GuidToString( &guid, wszId );

    XBStr xId( wszId );
    if ( !xId ) {
         DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.bstrVal = xId;
    hr = pInstance->Put( m_xbstrId, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    if ( !LogBlobProperty( pInstance, m_xbstrValue,
                           pDataEntry->pData, pDataEntry->dwDataLen ) ) {
        return FALSE;
    }

    var.vt = VT_I4;
    var.lVal = pDataEntry->dwValueType;
    hr = pInstance->Put( m_xbstrValueType, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    hr = m_pWbemServices->PutInstance( pInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  LogSecurityGroups
//
//  Purpose:    Logs token_groups as an array of strings
//
//*************************************************************

HRESULT LogSecurityGroups( IWbemClassObject *pInstance, BSTR bstrPropName, PTOKEN_GROUPS pTokenGroups )
{
    SAFEARRAYBOUND arrayBound[1];
    arrayBound[0].lLbound = 0;
    arrayBound[0].cElements = pTokenGroups->GroupCount;
    HRESULT hr;
    NTSTATUS ntStatus;
    UNICODE_STRING unicodeStr;

    XSafeArray xSafeArray = SafeArrayCreate( VT_BSTR, 1, arrayBound );
    if ( xSafeArray == 0 )
    {
        DebugMsg((DM_WARNING, TEXT("LogSecurityGroups: Failed to allocate memory" )));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    for ( DWORD i = 0 ; i < (pTokenGroups->GroupCount) ; i++ )
    {
        //
        // Convert user SID to a string.
        //

        ntStatus = RtlConvertSidToUnicodeString( &unicodeStr,
                                                 pTokenGroups->Groups[i].Sid,
                                                 (BOOLEAN)TRUE ); // Allocate
        if ( !NT_SUCCESS(ntStatus) ) {
            DebugMsg((DM_WARNING, TEXT("LogSecurityGroups: RtlConvertSidToUnicodeString failed, status = 0x%x"),
                      ntStatus));
            return HRESULT_FROM_NT(ntStatus);
        }

        XBStr xbstrSid(unicodeStr.Buffer);

        RtlFreeUnicodeString( &unicodeStr );

        hr = SafeArrayPutElement( xSafeArray, (long *)&i, xbstrSid );
        if ( FAILED( hr ) ) 
        {
            DebugMsg((DM_WARNING, TEXT("LogSecurityGroups: Failed to SafeArrayPutElement with 0x%x" ), hr ));
            return hr;
        }
    }
    
    VARIANT var;
    var.vt = VT_ARRAY | VT_BSTR;
    var.parray = xSafeArray;

    hr = pInstance->Put( bstrPropName, 0, &var, 0 );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("LogSecurityGroups: PutInstance failed with 0x%x" ), hr ));
        return hr;
    }

    return S_OK;

}

//*************************************************************
//
//  CRegistryLogger::LogBlobProperty()
//
//  Purpose:    Logs an instance of registry policy object
//
//  Parameters: pwszKeyName   - Registry key name
//              pwszValueName - Value name
//              pDataEntry    - Data entry
//              dwOrder       - Precedence order
//
//*************************************************************

BOOL LogBlobProperty( IWbemClassObject *pInstance, BSTR bstrPropName, BYTE *pbBlob, DWORD dwLen )
{
    SAFEARRAYBOUND arrayBound[1];
    arrayBound[0].lLbound = 0;
    arrayBound[0].cElements = dwLen;
    HRESULT hr;

    XSafeArray xSafeArray = SafeArrayCreate( VT_UI1, 1, arrayBound );
    if ( xSafeArray == 0 )
    {
        DebugMsg((DM_WARNING, TEXT("LogBlobProperty: Failed to allocate memory" )));
        return FALSE;
    }

    for ( DWORD i = 0 ; i < dwLen ; i++ )
    {
        hr = SafeArrayPutElement( xSafeArray, (long *)&i, &pbBlob[i] );
        if ( FAILED( hr ) ) 
        {
            DebugMsg((DM_WARNING, TEXT("LogBlobProperty: Failed to SafeArrayPutElement with 0x%x" ), hr ));
            return FALSE;
        }
    }
    
    VARIANT var;
    var.vt = VT_ARRAY | VT_UI1;
    var.parray = xSafeArray;

    hr = pInstance->Put( bstrPropName, 0, &var, 0 );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("LogBlobProperty: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}



//*************************************************************
//
//  CAdmFileLogger::CAdmFileLogger()
//
//  Purpose:    Constructor
//
//  Parameters: pWbemServices - Wbem services
//
//*************************************************************

CAdmFileLogger::CAdmFileLogger( IWbemServices *pWbemServices )
    : m_bInitialized(FALSE),
      m_pWbemServices(pWbemServices)
{
    m_xbstrName = L"name";
    if ( !m_xbstrName )
        return;

    m_xbstrGpoId = L"GPOID";
    if ( !m_xbstrGpoId )
        return;

    m_xbstrWriteTime = L"lastWriteTime";
    if ( !m_xbstrWriteTime )
        return;

    m_xbstrData = L"data";
    if ( !m_xbstrData )
        return;

    m_xbstrClass = L"RSOP_AdministrativeTemplateFile";
    if ( !m_xbstrClass )
        return;

    HRESULT hr = m_pWbemServices->GetObject( m_xbstrClass,
                                             0L,
                                             NULL,
                                             &m_xClass,
                                             NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CAdmFileLogger::CAdmFileLogger: GetObject failed with 0x%x" ), hr ));
        return;
    }

    m_bInitialized = TRUE;
}



//*************************************************************
//
//  CAdmFileLogger::Log()
//
//  Purpose:    Logs an instance of Adm file object
//
//  Parameters: pAdmInfo  -  Adm file info object
//
//*************************************************************

BOOL CAdmFileLogger::Log( ADMFILEINFO *pAdmInfo )
{
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CAdmFileLogger::Log: Failed to initialize." )));
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("CAdmFileLogger::Log: Logging %s" ), pAdmInfo->pwszFile));
    IWbemClassObject *pInstance = NULL;

    HRESULT hr = m_xClass->SpawnInstance( 0, &pInstance );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CAdmFileLogger::Log: SpawnInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    XInterface<IWbemClassObject> xInstance( pInstance );

    XBStr xName( pAdmInfo->pwszFile );
    if ( !xName ) {
         DebugMsg((DM_WARNING, TEXT("CAdmFileLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }



    VARIANT var;
    var.vt = VT_BSTR;

    var.bstrVal = xName;
    hr = pInstance->Put( m_xbstrName, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CAdmFileLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    WCHAR *pwszPath = StripPrefix( pAdmInfo->pwszGPO );

    XBStr xGPO( pwszPath );
    if ( !xGPO ) {
         DebugMsg((DM_WARNING, TEXT("CAdmFileLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.bstrVal = xGPO;
    hr = pInstance->Put( m_xbstrGpoId, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CAdmFileLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    SYSTEMTIME sysTime;
    if ( !FileTimeToSystemTime( &pAdmInfo->ftWrite, &sysTime ) ) {
        DebugMsg((DM_WARNING, TEXT("CAdmPolicyLogger::Log: FileTimeToSystemTime failed with 0x%x" ), GetLastError() ));
        return FALSE;
    }

    if ( !LogTimeProperty( pInstance, m_xbstrWriteTime, &sysTime ) ) {
        return FALSE;
    }

    hr = m_pWbemServices->PutInstance( pInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CAdmPolicyLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}



//*************************************************************
//
//  LogTimeProperty()
//
//  Purpose:    Logs an instance of a datetime property
//
//  Parameters: pInstance     - Instance pointer
//              pwszPropName  - Property name
//              pSysTime      - System time
//
//*************************************************************

BOOL LogTimeProperty( IWbemClassObject *pInstance, BSTR bstrPropName, SYSTEMTIME *pSysTime )
{
    if(!pInstance || !bstrPropName || !pSysTime)
    {
        DebugMsg((DM_WARNING, TEXT("LogTimeProperty: Function called with invalid parameters.")));
        return FALSE;
    }

    XBStr xbstrTime;

    HRESULT hr = SystemTimeToWbemTime(*pSysTime, xbstrTime);

    if(FAILED(hr) || !xbstrTime)
    {
        DebugMsg((DM_WARNING, TEXT("LogTimeProperty: Call to SystemTimeToWbemTime failed. hr=0x%08X"),hr));
        return FALSE;
    }

    VARIANT var;
    var.vt = VT_BSTR;

    var.bstrVal = xbstrTime;
    hr = pInstance->Put( bstrPropName, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("LogTimeProperty: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}



//*************************************************************
//
//  CExtSessionLogger::CExtSessionLogger()
//
//  Purpose:    Constructor
//
//  Parameters: pWbemServices - Wbem services
//
//*************************************************************

CExtSessionLogger::CExtSessionLogger( IWbemServices *pWbemServices )
    : m_bInitialized(FALSE),
      m_pWbemServices(pWbemServices)
{
    m_xbstrExtGuid = L"extensionGuid";
    if ( !m_xbstrExtGuid )
        return;

    m_xbstrDisplayName = L"displayName";
    if ( !m_xbstrDisplayName )
        return;

    m_xbstrPolicyBeginTime = L"beginTime";
    if ( !m_xbstrPolicyBeginTime )
        return;

    m_xbstrPolicyEndTime = L"endTime";
    if ( !m_xbstrPolicyEndTime )
        return;

    m_xbstrStatus = L"loggingStatus";
    if ( !m_xbstrStatus )
        return;

    m_xbstrError = L"error";
    if ( !m_xbstrError )
        return;

    m_xbstrClass = L"RSOP_ExtensionStatus";
    if ( !m_xbstrClass )
        return;

    HRESULT hr = m_pWbemServices->GetObject( m_xbstrClass,
                                             0L,
                                             NULL,
                                             &m_xClass,
                                             NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::CExtSessionLogger: GetObject failed with 0x%x" ), hr ));
        return;
    }

    if ( 0 == LoadString (g_hDllInstance, IDS_GPCORE_NAME, m_szGPCoreNameBuf, ARRAYSIZE(m_szGPCoreNameBuf) - 1) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::CExtSessionLogger: LoadString for GP Core Name failed with 0x%x" ), GetLastError() ));
        return;
    }

    m_bInitialized = TRUE;
}



//*************************************************************
//
//  CExtSessionLogger::Log()
//
//  Purpose:    Logs an instance of ExtensionSessionStatus
//
//*************************************************************

#define EXT_INSTPATH_FMT L"RSOP_ExtensionStatus.extensionGuid=\"%s\""

BOOL CExtSessionLogger::Log( LPGPEXT lpExt, BOOL bSupported )
{
    LPTSTR lpGuid=NULL, lpName=NULL;
    HRESULT hr;
    
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Failed to initialize." )));
        return FALSE;
    }

    lpGuid = lpExt ? lpExt->lpKeyName : GPCORE_GUID;
    lpName = lpExt ? lpExt->lpDisplayName : m_szGPCoreNameBuf;

    XInterface<IWbemClassObject>xInstance = NULL;
    XBStr xDisplayName;

    hr = m_xClass->SpawnInstance( 0, &xInstance );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: SpawnInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    xDisplayName = lpName;
    if ( !xDisplayName ) {
         DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    XBStr xGuid ( lpGuid );
    if ( !xGuid ) {
         DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    VARIANT var;
    var.vt = VT_BSTR;

    var.bstrVal = xGuid;
    hr = xInstance->Put( m_xbstrExtGuid, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    var.bstrVal = xDisplayName;
    hr = xInstance->Put( m_xbstrDisplayName, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    SYSTEMTIME sysTime;
    GetSystemTime(&sysTime);

    if ( !LogTimeProperty( xInstance, m_xbstrPolicyBeginTime, &sysTime ) )
    {
        return FALSE;
    }
    
    var.vt = VT_I4;
    var.lVal = bSupported ? 2 : 3;

    hr = xInstance->Put( m_xbstrStatus, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    var.vt = VT_I4;
    var.lVal = 0;

    hr = xInstance->Put( m_xbstrError, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    hr = m_pWbemServices->PutInstance( xInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}


//*************************************************************
//
//  CExtSessionLogger::Update()
//
//  Purpose:    Logs an instance of ExtensionSessionStatus
//
//*************************************************************

BOOL CExtSessionLogger::Update( LPTSTR lpKeyName, BOOL bLoggingIncomplete, DWORD dwErr )
{
    LPTSTR lpGuid=NULL;
    HRESULT hr;
    
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Failed to initialize." )));
        return FALSE;
    }

    lpGuid = lpKeyName ? lpKeyName : GPCORE_GUID;

    XInterface<IWbemClassObject>xInstance = NULL;
    
    //
    // We should have an instance
    //

    XPtrLF<TCHAR> xszInstPath = (LPTSTR) LocalAlloc(LPTR, sizeof(WCHAR)*
                                        (lstrlen(EXT_INSTPATH_FMT)+lstrlen(lpGuid)+10));

    if (!xszInstPath) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Not enough memory." )));
        return FALSE;
    }

    wsprintf(xszInstPath, EXT_INSTPATH_FMT, lpGuid);
    

    XBStr xbstrInstancePath = xszInstPath;
    if(!xbstrInstancePath)
    {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Failed to allocate memory.")));
        return FALSE;
    }

    hr = m_pWbemServices->GetObject(xbstrInstancePath, 0, NULL, &xInstance, NULL);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Didn't find an instance of the extension object when trying to set the dirty flag.")));
        return FALSE;
    }

    VARIANT var;
    VariantInit(&var);
    XVariant xVar(&var);

    //
    // Display name
    //

    hr = xInstance->Get(m_xbstrDisplayName, 0, &var, NULL, NULL);

    if(FAILED(hr)) {
        DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: Get failed for displayname. hr=0x%08X."), hr));
        return FALSE;
    }

    hr = xInstance->Put(m_xbstrDisplayName, 0, &var, NULL);

    if(FAILED(hr)) {
        DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: Put failed for displayname. hr=0x%08X."), hr));
        return FALSE;
    }


    //
    // Start time
    //

    hr = xInstance->Get(m_xbstrPolicyBeginTime, 0, &var, NULL, NULL);

    if(FAILED(hr)) {
        DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: Get failed for displayname. hr=0x%08X."), hr));
        return FALSE;
    }

    hr = xInstance->Put(m_xbstrPolicyBeginTime, 0, &var, NULL);

    if(FAILED(hr)) {
        DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: Put failed for displayname. hr=0x%08X."), hr));
        return FALSE;
    }


    //
    // end time
    //


    SYSTEMTIME sysTime;
    GetSystemTime(&sysTime);

    if (!LogTimeProperty( xInstance, m_xbstrPolicyEndTime, &sysTime) ) {
        DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: Get failed for dispayname. hr=0x%08X."), hr));
        return FALSE;
    }


    //
    // Dirty flag
    //

    if (bLoggingIncomplete) {

        hr = xInstance->Get(m_xbstrStatus, 0, &var, NULL, NULL);

        if(FAILED(hr)) {
            DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: Get failed for loggingstatus. hr=0x%08X."), hr));
            return FALSE;
        }
    }
    else {
        var.vt = VT_I4;
        var.lVal = 1;    // logging completed successfully
    }


    hr = xInstance->Put( m_xbstrStatus, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    //
    // Error code
    //

    var.vt = VT_I4;
    var.lVal = dwErr;

    hr = xInstance->Put( m_xbstrError, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    hr = m_pWbemServices->PutInstance( xInstance, WBEM_FLAG_UPDATE_ONLY, NULL, NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }


    return TRUE;
}

//*************************************************************
//
//  CExtSessionLogger::Update()
//
//  Purpose:    Logs an instance of ExtensionSessionStatus
//
//*************************************************************


BOOL CExtSessionLogger::Set( LPGPEXT lpExt, BOOL bSupported, LPRSOPEXTSTATUS lpRsopExtStatus )
{
    LPTSTR lpGuid=NULL, lpName=NULL;
    HRESULT hr;
    
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Failed to initialize." )));
        return FALSE;
    }

    lpGuid = lpExt ? lpExt->lpKeyName : GPCORE_GUID;
    lpName = lpExt ? lpExt->lpDisplayName : m_szGPCoreNameBuf;

    XInterface<IWbemClassObject>xInstance = NULL;
    XBStr xDisplayName;

    hr = m_xClass->SpawnInstance( 0, &xInstance );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: SpawnInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    xDisplayName = lpName;
    if ( !xDisplayName ) {
         DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    XBStr xGuid ( lpGuid );
    if ( !xGuid ) {
         DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    VARIANT var;
    var.vt = VT_BSTR;

    var.bstrVal = xGuid;
    hr = xInstance->Put( m_xbstrExtGuid, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    var.bstrVal = xDisplayName;
    hr = xInstance->Put( m_xbstrDisplayName, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    SYSTEMTIME sysTime;

    if (!FileTimeToSystemTime(&(lpRsopExtStatus->ftStartTime), &sysTime)) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: FileTimeToSystemTime failed with 0x%x" ), GetLastError() ));
        return FALSE;
    }

    if ( !LogTimeProperty( xInstance, m_xbstrPolicyBeginTime, &sysTime ) )
    {
        return FALSE;
    }
    
    if (!FileTimeToSystemTime(&(lpRsopExtStatus->ftEndTime), &sysTime)) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: FileTimeToSystemTime failed with 0x%x" ), GetLastError() ));
        return FALSE;
    }

    if ( !LogTimeProperty( xInstance, m_xbstrPolicyEndTime, &sysTime ) )
    {
        return FALSE;
    }
    
    var.vt = VT_I4;
    var.lVal = (!bSupported) ? 3 : (FAILED(lpRsopExtStatus->dwLoggingStatus) ? 2 : 1  );

    hr = xInstance->Put( m_xbstrStatus, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    var.vt = VT_I4;
    var.lVal = lpRsopExtStatus->dwStatus;

    hr = xInstance->Put( m_xbstrError, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    hr = m_pWbemServices->PutInstance( xInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}


//*************************************************************
//
//  GetRsopSchemaVersionNumber
//
//  Purpose:    Gets the Rsop schema version number from the namespace that we are
//              connected to
//
// returns S_OK on success, failur code o/w
//*************************************************************


HRESULT GetRsopSchemaVersionNumber(IWbemServices *pWbemServices, DWORD *dwVersionNumber)
{
    XInterface<IWbemClassObject>xpInstance = NULL;
    
    VARIANT                     var;
    XBStr                       xbstrInstancePath;
    XBStr                       xbstrVersion;
    HRESULT                     hr;

    *dwVersionNumber = 0;

    xbstrVersion = L"version";
    if ( !xbstrVersion ) {
        DebugMsg((DM_WARNING, TEXT("CompileMof: Failed to allocate memory.")));
        return HRESULT_FROM_WIN32(GetLastError());
    }


    xbstrInstancePath = L"RSOP_Session.id=\"Session1\"";
    if(!xbstrInstancePath)
    {
        DebugMsg((DM_WARNING, TEXT("CompileMof: Failed to allocate memory.")));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    hr = pWbemServices->GetObject(xbstrInstancePath, 0, NULL, &xpInstance, NULL);

    if(SUCCEEDED(hr)) {

        VariantInit(&var);
        XVariant xVar(&var);

        hr = xpInstance->Get(xbstrVersion, 0, &var, NULL, NULL);

        if((SUCCEEDED(hr)) && ( var.vt != VT_NULL )) 
            *dwVersionNumber = var.lVal;
    }


    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\rsop\maindll.cpp ===
//*************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999.
//
// File:        MainDll.cpp
//
// Description: Dll registry, get class object functions
//
// History:     8-20-99   leonardm    Created
//              1-15-00   NishadM
//
//*************************************************************

#include "uenv.h"
#include "Factory.h"
#include "rsopdbg.h"
#include "initguid.h"
#include <wbemcli.h>
#define SECURITY_WIN32
#include <security.h>
#include <aclapi.h>
#include "smartptr.h"
#include "rsopinc.h"
#include "rsopsec.h"

HRESULT GetRsopSchemaVersionNumber(IWbemServices *pWbemServices, DWORD *dwVersionNumber);

// {B3FF88A4-96EC-4cc1-983F-72BE0EBB368B}
DEFINE_GUID(CLSID_CSnapProv, 0xb3ff88a4, 0x96ec, 0x4cc1, 0x98, 0x3f, 0x72, 0xbe, 0xe, 0xbb, 0x36, 0x8b);

// Count of objects and locks.

long g_cObj = 0;
long g_cLock = 0;

CDebug dbgRsop;

extern "C"
{
STDMETHODIMP RSoPMakeAbsoluteSD(SECURITY_DESCRIPTOR* pSelfRelativeSD, SECURITY_DESCRIPTOR** ppAbsoluteSD);
STDMETHODIMP GetNamespaceSD(IWbemServices* pWbemServices, SECURITY_DESCRIPTOR** ppSD);
STDMETHODIMP SetNamespaceSD(SECURITY_DESCRIPTOR* pSD, IWbemServices* pWbemServices);
STDMETHODIMP FreeAbsoluteSD(SECURITY_DESCRIPTOR* pAbsoluteSD);
STDMETHODIMP GetWbemServicesPtr( LPCWSTR, IWbemLocator**, IWbemServices** );
};

/*
LPWSTR GetDomainName();
DWORD MakeUserName( LPWSTR szDomain, LPWSTR szUser, LPWSTR* pszUserName );
STDMETHODIMP SetNameSpaceSecurity( IWbemServices*, PSECURITY_DESCRIPTOR, LPWSTR* pszPrincipals, DWORD   nPrincipals );
*/
  
void
InitializeSnapProv( void )
{
    dbgRsop.Initialize(  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                     L"RsopDebugLevel",
                     L"userenv.log",
                     L"userenv.bak",
                     FALSE );                     
}

extern "C"
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        if (rclsid != CLSID_CSnapProv)
        {
                return CLASS_E_CLASSNOTAVAILABLE;
        }

        CProvFactory* pFactory = new CProvFactory();

        if (pFactory == NULL)
        {
                return E_OUTOFMEMORY;
        }

        HRESULT hRes = pFactory->QueryInterface(riid, ppv);

        pFactory->Release();

        return hRes;
}

extern "C"
STDAPI DllCanUnloadNow()
{
    // It is OK to unload if there are no objects or locks on the class factory.
    if( g_cObj == 0L && g_cLock == 0L )
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

extern "C"
STDAPI DllRegisterServer(void)
{
    wchar_t szID[128];
    wchar_t szCLSID[128];
    wchar_t szModule[MAX_PATH];
    wchar_t* pName = L"Rsop Logging Mode Provider";
    wchar_t* pModel = L"Both";

    HKEY hKey1, hKey2;

    // Create the path.
    GuidToString( &CLSID_CSnapProv, szID );
    wcscpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE*)pName, (wcslen(pName) + 1) * sizeof(wchar_t));

    RegCreateKey(hKey1, L"InprocServer32", &hKey2);
    GetModuleFileName(g_hDllInstance, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE*)szModule, (wcslen(szModule) + 1) * sizeof(wchar_t));
    RegSetValueEx(hKey2, L"ThreadingModel", 0, REG_SZ, (BYTE*)pModel, (wcslen(pModel) + 1) * sizeof(wchar_t));

    CloseHandle(hKey1);
    CloseHandle(hKey2);

    return S_OK;
}

extern "C"
STDAPI DllUnregisterServer(void)
{
    wchar_t szID[128];
    wchar_t szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    GuidToString( &CLSID_CSnapProv, szID );
    wcscpy(szCLSID, TEXT("CLSID\\"));
    wcscat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hKey);
    if(dwRet == ERROR_SUCCESS)
    {
        RegDeleteKey(hKey, L"InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, L"CLSID", &hKey);
    if(dwRet == ERROR_SUCCESS)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return S_OK;
}
                    

BOOL RunningOnWow64()
{
#if defined(_WIN64) 
    // 64bit builds don't run in Wow64
    return false;
#else

    // OS version
    OSVERSIONINFO osviVersion;
    osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osviVersion)) {
        DebugMsg((DM_WARNING, TEXT("RunningOnWow64: Couldn't detect Version with error %d"), GetLastError()));
        return FALSE;
    }


    // on NT5 or later 32bit build. Check for 64 bit OS
    if ((osviVersion.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
         (osviVersion.dwMajorVersion >= 5))
    {
        // QueryInformation for ProcessWow64Information returns a pointer to the Wow Info.
        // if running native, it returns NULL.

        PVOID pWow64Info = 0;
        if (NT_SUCCESS(NtQueryInformationProcess(GetCurrentProcess(), ProcessWow64Information, &pWow64Info, sizeof(pWow64Info), NULL))
            && pWow64Info != NULL)
        {
            // running 32bit on Wow64.
            return TRUE;
        }
    }
    return FALSE;
#endif
}

HRESULT
CompileMOF( LPCWSTR szMOFFile, LPCWSTR szMFLFile )
{
    WCHAR                       szNamespace[MAX_PATH];
    BOOL                        bUpgrade = FALSE;
    HRESULT                     hr;

    XInterface<IWbemLocator>    xWbemLocator;
    XInterface<IWbemServices>   xWbemServicesOld;
    DWORD                       dwCurrentVersion= 0;
    DWORD                       dwNewVersion = RSOP_MOF_SCHEMA_VERSION; 


    //
    // On wow64 do nothing
    //

    if (RunningOnWow64()) {
        DebugMsg((DM_VERBOSE, TEXT("CompileMof: Running on Wow64. returning without doing anything")));
        return S_OK;
    }


    if ( !szMOFFile )
    {
        return E_POINTER;
    }

    wcscpy(szNamespace, RSOP_NS_ROOT);
 
    //
    // Get the wbem services pointer to the machine namespace
    //

    hr = GetWbemServicesPtr(RSOP_NS_MACHINE,
                            &xWbemLocator,
                            &xWbemServicesOld );


    if (!xWbemLocator) {
        DebugMsg((DM_WARNING, TEXT("CompileMof: Failed to get IWbemLocator pointer.Error 0x%x"), hr));
        return hr;
    }

    if ( (SUCCEEDED(hr)) && (xWbemServicesOld)) {
        hr = GetRsopSchemaVersionNumber(xWbemServicesOld, &dwCurrentVersion);        
        if (FAILED(hr)) {
            return hr;
        }
    }

    if (HIWORD(dwCurrentVersion) != HIWORD(dwNewVersion)) {

        //
        // We should cleanout the schema and recreate below
        //

        DebugMsg((DM_VERBOSE, TEXT("CompileMof: Major version schema upgrade detected. Deleting rsop namespace and rebuilding")));
        
        xWbemServicesOld = NULL;
        hr = DeleteRsopNameSpace(szNamespace, xWbemLocator);
        if (FAILED(hr)) {
            DebugMsg((DM_WARNING, TEXT("CompileMof: Failed to get delete the rsop namespace. Error 0x%x. Continuing.."), hr));
        }
        
        //
        // Delete the state info on the machine
        //


        if (!RegDelnode(HKEY_LOCAL_MACHINE, GP_STATE_ROOT_KEY)) {
            DebugMsg((DM_WARNING, TEXT("CompileMof: Failed to delete the state key. Error 0x%x. Continuing.."), hr));
        }

        bUpgrade = FALSE;
    }
    else {
        bUpgrade = TRUE;
    }

    XInterface<IMofCompiler> xpMofCompiler;
    
    //
    // get a handle to IMofCompiler
    //

    hr = CoCreateInstance(  CLSID_MofCompiler,
                            0,
                            CLSCTX_INPROC_SERVER,
                            IID_IMofCompiler,
                            (LPVOID*) &xpMofCompiler );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, L"CompileMOF: CoCreateInstance() failed, 0x%X.", hr));
        return hr;
    }

    WBEM_COMPILE_STATUS_INFO Info;

    hr = xpMofCompiler->CompileFile((LPWSTR)szMOFFile,
                                    0,  // no server & namespace
                                    0,  // no user
                                    0,  // no authority
                                    0,  // no password
                                    0,  // no options
                                    0,  // no class flags
                                    0,  // no instance flags
                                    &Info );
    if ( FAILED( hr ) )
    {
        DebugMsg((DM_WARNING, L"CompileMOF: IMofCompiler::CompileFile() failed, 0x%X.", hr));
    }
    else 
    {
        if (hr != S_OK ) 
        {
            DebugMsg((DM_WARNING, L"CompileMOF: IMofCompiler::CompileFile() returned with 0x%X.", hr));
            DebugMsg((DM_WARNING, L"CompileMOF: Details - lPhaseError - %d, hRes = 0x%x, ObjectNum - %d, firstline - %d, LastLine - %d", 
                      Info.lPhaseError, Info.hRes, Info.ObjectNum, Info.FirstLine, Info.LastLine ));
        }
        else
        {
            hr = xpMofCompiler->CompileFile((LPWSTR)szMFLFile,
                                            0,  // no server & namespace
                                            0,  // no user
                                            0,  // no authority
                                            0,  // no password
                                            0,  // no options
                                            0,  // no class flags
                                            0,  // no instance flags
                                            &Info );
            if ( FAILED( hr ) )
            {
                DebugMsg((DM_WARNING, L"CompileMOF: IMofCompiler::CompileFile() failed, 0x%X.", hr));
            }
            else 
            {
                if (hr != S_OK ) 
                {
                    DebugMsg((DM_WARNING, L"CompileMOF: IMofCompiler::CompileFile() returned with 0x%X.", hr));
                    DebugMsg((DM_WARNING, L"CompileMOF: Details - lPhaseError - %d, hRes = 0x%x, ObjectNum - %d, firstline - %d, LastLine - %d", 
                              Info.lPhaseError, Info.hRes, Info.ObjectNum, Info.FirstLine, Info.LastLine ));
                }
            }
        }
    }

    //
    // if xWbemServicesOld exists, this is an upgrade.
    // retain old security.
    //
    if ( !bUpgrade )
    {
        XPtrLF<SECURITY_DESCRIPTOR> xsd;
        SECURITY_ATTRIBUTES sa;
        CSecDesc Csd;

        Csd.AddLocalSystem(RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);
        Csd.AddAdministrators(RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);
        Csd.AddAdministratorsAsOwner();
        Csd.AddAdministratorsAsGroup();
        Csd.AddAuthUsers(RSOP_READ_PERMS);          // no inheritance

        xsd = Csd.MakeSelfRelativeSD();
        if (!xsd) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CompileMOF::MakeSelfSD failed with %d"), GetLastError());
            return HRESULT_FROM_WIN32(GetLastError());
        }


        if (!SetSecurityDescriptorControl( (SECURITY_DESCRIPTOR *)xsd, SE_DACL_PROTECTED, SE_DACL_PROTECTED )) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CompileMOF::SetSecurityDescriptorControl failed with %d"), GetLastError());
            return HRESULT_FROM_WIN32(GetLastError());
        }

        hr = SetNameSpaceSecurity(szNamespace, xsd, xWbemLocator);

        if (FAILED(hr)) {
            DebugMsg((DM_WARNING, L"CompileMOF: SetNamespaceSecurity() failed, 0x%X.", hr));
            return hr;
        }


        hr = SetNameSpaceSecurity(RSOP_NS_USER, xsd, xWbemLocator);

        if (FAILED(hr)) {
            DebugMsg((DM_WARNING, L"CompileMOF: SetNamespaceSecurity() failed, 0x%X.", hr));
            return hr;
        }


        hr = SetNameSpaceSecurity(RSOP_NS_MACHINE, xsd, xWbemLocator);

        if (FAILED(hr)) {
            DebugMsg((DM_WARNING, L"CompileMOF: SetNamespaceSecurity() failed, 0x%X.", hr));
            return hr;
        }

    }
    
    return hr;
}

//
// currently this code is intended to be called by regsvr32.
// setup does not call this code.
// "regsvr32 /n /i userenv.dll"
// waiting for WMI gives us a mechanism to install our MOF at setup time.
//

extern "C"
STDAPI DllInstall( BOOL, LPCWSTR )
{
    HRESULT hr = S_OK;
    WCHAR   szMofFile[MAX_PATH];
    WCHAR   szMflFile[MAX_PATH];

    if ( GetSystemDirectory( szMofFile, MAX_PATH ) )
    {
        wcscpy( szMflFile, szMofFile );

        LPWSTR szMOF = CheckSlash(szMofFile);
        LPWSTR szMFL = CheckSlash(szMflFile);
        
        wcscat( szMOF, L"Wbem\\RSoP.mof" );
        wcscat( szMFL, L"Wbem\\RSoP.mfl" );

        hr = CompileMOF( szMofFile, szMflFile );
    }
    else
    {
        hr = GetLastError();
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\rsop\factory.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:                        Factory.cpp
//
// Description:         
//
// History:    8-20-99   leonardm    Created
//
///////////////////////////////////////////////////////////////////////////////////

#include "uenv.h"
#include "Factory.h"
#include "diagprov.h"

extern long g_cLock;

///////////////////////////////////////////////////////////////////////////////////
//
// Function:    
//
// Description: 
//
// Parameters:  
//
// Return:              
//
// History:             8/20/99         leonardm        Created.
//
///////////////////////////////////////////////////////////////////////////////////
CProvFactory::CProvFactory() : m_cRef(1)
{
}

///////////////////////////////////////////////////////////////////////////////////
//
// Function:    
//
// Description: 
//
// Parameters:  
//
// Return:              
//
// History:             8/20/99         leonardm        Created.
//
///////////////////////////////////////////////////////////////////////////////////
CProvFactory::~CProvFactory()
{
}

///////////////////////////////////////////////////////////////////////////////////
//
// Function:    
//
// Description: 
//
// Parameters:  
//
// Return:              
//
// History:             8/20/99         leonardm        Created.
//
///////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProvFactory::QueryInterface(REFIID riid, LPVOID* ppv)
{
        if ( riid == IID_IUnknown || riid == IID_IClassFactory )
        {
                *ppv = this;
                AddRef();
                return S_OK;
        }
        else
        {
                *ppv = NULL;
                return E_NOINTERFACE;
        }
}

///////////////////////////////////////////////////////////////////////////////////
//
// Function:    
//
// Description: 
//
// Parameters:  
//
// Return:              
//
// History:             8/20/99         leonardm        Created.
//
///////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CProvFactory::AddRef()
{
        return InterlockedIncrement(&m_cRef);
}

///////////////////////////////////////////////////////////////////////////////////
//
// Function:    
//
// Description: 
//
// Parameters:  
//
// Return:              
//
// History:             8/20/99         leonardm        Created.
//
///////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CProvFactory::Release()
{
        if (!InterlockedDecrement(&m_cRef))
        {
                delete this;
                return 0;
        }
        return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////////
//
// Function:    
//
// Description: 
//
// Parameters:  
//
// Return:              
//
// History:             8/20/99         leonardm        Created.
//
///////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN punk, REFIID riid, LPVOID* ppv)
{
        *ppv = NULL;

        if(punk != NULL)
        {
                return CLASS_E_NOAGGREGATION;
        }

        CSnapProv* pProvider = new CSnapProv();
        if (pProvider == NULL)
        {
                return E_OUTOFMEMORY;
        }

        HRESULT hr = pProvider->QueryInterface(riid, ppv);

        pProvider->Release();

        return hr;

        return S_OK;
}

///////////////////////////////////////////////////////////////////////////////////
//
// Function:    
//
// Description: 
//
// Parameters:  
//
// Return:              
//
// History:             8/20/99         leonardm        Created.
//
///////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProvFactory::LockServer(BOOL bLock)
{
        if (bLock)
        {
                InterlockedIncrement( &g_cLock );
        }
        else
        {
                InterlockedDecrement( &g_cLock );
        }

        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\rsop\polset.cpp ===
//*************************************************************
//
//  Resultant set of policy
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//  History:    15-July-2000   NishadM    Created
//
//*************************************************************

#include "uenv.h"
#include <wbemcli.h>
#include "SmartPtr.h"
#include "WbemTime.h"

//*************************************************************
//
//  RsopSetPolicySettingStatus
//
//  Purpose:  Creates create instances of RSOP_PolicySettingStatus and
//              links them to RSOP_PolicySetting
//
//  Parameters: 
//              dwFlags             - flags
//              pServices           - namespace
//              pSettingInstance    - instance of RSOP_PolicySetting
//              nLinks              - number of setting statuses
//              pStatus             - setting status information
//
//  Returns:    S_OK if successful
//
//*************************************************************

HRESULT
RsopSetPolicySettingStatus( DWORD,
                        IWbemServices*              pServices,
                        IWbemClassObject*           pSettingInstance,
                        DWORD 				        nLinks,
                        POLICYSETTINGSTATUSINFO*    pStatus )
{
    HRESULT hr;

    //
    //  validate arguments
    //
    if ( !pServices || !pSettingInstance || !nLinks || !pStatus )
    {
        DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: invalid arguments" ) );
        return E_INVALIDARG;
    }

    //
    //  get the RSoP_PolicySettingStatus class
    //
    XBStr bstr = L"RSoP_PolicySettingStatus";
    XInterface<IWbemClassObject> xClassStatus;
    hr = pServices->GetObject(  bstr,
                                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                0,
                                &xClassStatus,
                                0 );
    if ( FAILED( hr ) )
    {
        DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: GetObject failed, 0x%x", hr ) );
        return hr;
    }

    //
    //  spawn the RSoP_PolicySettingStatus instance
    //
    XInterface<IWbemClassObject> xInstStatus;
    hr = xClassStatus->SpawnInstance( 0, &xInstStatus );
    if ( FAILED (hr) )
    {
        DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: SpawnInstance failed, 0x%x", hr ) );
        return hr;
    }

    //
    //  get the RSoP_PolicySettingLink class
    //
    XInterface<IWbemClassObject> xClassLink;

    bstr = L"RSoP_PolicySettingLink";
    hr = pServices->GetObject(  bstr,
                                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                0,
                                &xClassLink,
                                0 );
    if ( FAILED( hr ) )
    {
        DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: GetObject failed, 0x%x", hr ) );
        return hr;
    }

    //
    //  spawn the RSoP_PolicySettingLink class
    //
    XInterface<IWbemClassObject> xInstLink;
    hr = xClassLink->SpawnInstance( 0, &xInstLink );
    if ( FAILED (hr) )
    {
        DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: SpawnInstance failed, 0x%x", hr ) );
        return hr;
    }

    //
    //  get the class name of the instance
    //
    VARIANT varClass;
    VariantInit( &varClass );
    XVariant xVarClass(&varClass);

    bstr = L"__CLASS";
    hr = pSettingInstance->Get( bstr,
                                0,
                                xVarClass,
                                0,
                                0 );
    if ( FAILED (hr) )
    {
        DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Get __CLASS failed, 0x%x", hr ) );
        return hr;
    }

    if ( varClass.vt == VT_NULL || varClass.vt == VT_EMPTY )
    {
        return E_UNEXPECTED;
    }

    //
    //  get the [key] of the RSoP_PolicySetting instance
    //
    VARIANT varId;
    VariantInit( &varId );
    XVariant xVarId(&varId);
    XBStr    bstrid = L"id";
    XBStr    bstrPath = L"__RELPATH";

    hr = pSettingInstance->Get( bstrPath,
                                0,
                                xVarId,
                                0,
                                0 );
    if ( FAILED (hr) )
    {
        DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Get id failed, 0x%x", hr ) );
        return hr;
    }

    LPWSTR szSetting = varId.bstrVal;

    //
    //  set the setting value
    //
    VARIANT var;
    XBStr   bstrVal;
    XBStr   bstrsetting = L"setting";
    XBStr   bstreventSource = L"eventSource";
    XBStr   bstreventLogName = L"eventLogName";
    XBStr   bstreventID = L"eventID";
    XBStr   bstreventTime = L"eventTime";
    XBStr   bstrstatus = L"status";
    XBStr   bstrerrorCode = L"errorCode";

    //
    //  for each info.
    //
    for ( DWORD i = 0 ; i < nLinks ; i++ )
    {
        //
        // RSoP_PolicySettingStatus
        //

        WCHAR   szGuid[64];
        LPWSTR  szPolicyStatusKey; 

        if ( !pStatus[i].szKey )
        {
            //
            // caller did not specify a key. generate it.
            //
            GUID guid;

            //
            // create the [key]
            //
            hr = CoCreateGuid( &guid );
            if ( FAILED(hr) )
            {
                DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: CoCreateGuid failed, 0x%x", hr ) );
                return hr;
            }

            wsprintf( szGuid,
                      L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
                      guid.Data1,
                      guid.Data2,
                      guid.Data3,
                      guid.Data4[0], guid.Data4[1],
                      guid.Data4[2], guid.Data4[3],
                      guid.Data4[4], guid.Data4[5],
                      guid.Data4[6], guid.Data4[7] );

            bstrVal = szPolicyStatusKey = szGuid;
        }
        else
        {
            //
            // caller specified a key. use it.
            //
            bstrVal = szPolicyStatusKey = pStatus[i].szKey;
        }

        var.vt = VT_BSTR;
        var.bstrVal = bstrVal;
        //
        //  set the id
        //
        hr = xInstStatus->Put(  bstrid,
                                0,
                                &var,
                                0 );
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put id failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  set the eventSource
        //
        if ( pStatus[i].szEventSource )
        {
            var.vt = VT_BSTR;
            bstrVal = pStatus[i].szEventSource;
            var.bstrVal = bstrVal;

            hr = xInstStatus->Put(  bstreventSource,
                                    0,
                                    &var,
                                    0 );
            if ( FAILED (hr) )
            {
                DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put eventSource failed, 0x%x", hr ) );
                return hr;
            }
        }

        //
        //  set the eventLogName
        //
        if ( pStatus[i].szEventLogName )
        {
            var.vt = VT_BSTR;
            bstrVal = pStatus[i].szEventLogName;
            var.bstrVal = bstrVal;

            hr = xInstStatus->Put(  bstreventLogName,
                                    0,
                                    &var,
                                    0 );
            if ( FAILED (hr) )
            {
                DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put eventLogName failed, 0x%x", hr ) );
                return hr;
            }
        }

        //
        //  set the eventID
        //
        var.vt = VT_I4;
        var.lVal = pStatus[i].dwEventID;

        hr = xInstStatus->Put(  bstreventID,
                                0,
                                &var,
                                0 );
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put eventID failed, 0x%x", hr ) );
            return hr;
        }

        XBStr xTimeLogged;

        //
        //  convert SYSTEMTIME to WBEM time
        //
        hr = SystemTimeToWbemTime( pStatus[i].timeLogged, xTimeLogged );
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: SystemTimeToWbemTime failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  set the eventTime
        //
        var.vt = VT_BSTR;
        var.bstrVal = xTimeLogged;

        hr = xInstStatus->Put(  bstreventTime,
                                0,
                                &var,
                                0 );
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put eventTime failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  set the errorCode
        //
        var.vt = VT_I4;
        var.lVal = pStatus[i].dwErrorCode;
        
        hr = xInstStatus->Put(  bstrerrorCode,
                                0,
                                &var,
                                0 );
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put errorCode failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  set the status
        //
        var.vt = VT_I4;
        var.lVal = pStatus[i].status;
        
        hr = xInstStatus->Put(  bstrstatus,
                                0,
                                &var,
                                0 );
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put status failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  commit the RSOP_PolicySettingStatus
        //
        hr = pServices->PutInstance(xInstStatus,
                                    WBEM_FLAG_CREATE_OR_UPDATE,
                                    0,
                                    0 );
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: PutInstance RSOP_PolicySettingStatus failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  RSoP_PolicySettingLink
        //

        var.vt = VT_BSTR;
        bstrVal = szSetting;
        var.bstrVal = bstrVal;

        hr = xInstLink->Put(bstrsetting,
                            0,
                            &var,
                            0);
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put setting failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  create the second key
        //
        WCHAR szStatus[96];

        //
        // e.g. RSoP_PolicySettingStatus.id="{00000000-0000-0000-000000000000}"
        //
        wsprintf( szStatus, L"RSoP_PolicySettingStatus.id=\"%s\"", szPolicyStatusKey );

        //
        //  set the status
        //
        bstrVal = szStatus;
        var.bstrVal = bstrVal;

        hr = xInstLink->Put(bstrstatus,
                            0,
                            &var,
                            0);
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put status failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  commit the RSOP_PolicySettingLink
        //
        hr = pServices->PutInstance(xInstLink,
                                    WBEM_FLAG_CREATE_OR_UPDATE,
                                    0,
                                    0 );
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: PutInstance RSOP_PolicySettingLink failed, 0x%x", hr ) );
            return hr;
        }
    }

    return hr;
}

//*************************************************************
//
//  RsopResetPolicySettingStatus
//
//  Purpose:  Creates create instances of RSOP_PolicySettingStatus and
//              links them to RSOP_PolicySetting
//
//  Parameters: 
//              dwFlags             - flags
//              pServices           - namespace
//              pSettingInstance    - instance of RSOP_PolicySetting
//
//  Returns:    S_OK if successful
//
//*************************************************************

#define RESET_QUERY_TEMPLATE L"REFERENCES OF {%s} WHERE ResultClass = RSOP_PolicySettingLink"

HRESULT
RsopResetPolicySettingStatus(   DWORD,
                            IWbemServices*      pServices,
                            IWbemClassObject*   pSettingInstance )
{
    // query for the RSOP_PolicySettingLink
    // for every RSOP_PolicySettingLink query for the RSoP_PolicySettingLink.status
        // delete the RSoP_PolicySettingStatus
        // delete the RSOP_PolicySettingLink

    if ( !pServices || !pSettingInstance )
    {
        return E_INVALIDARG;
    }

    //
    //  get the [key] of the RSoP_PolicySetting instance
    //
    VARIANT varId;
    VariantInit( &varId );
    XVariant  xVarId(&varId);
    XBStr    bstrRelPath = L"__RELPATH";

    HRESULT hr;

    hr = pSettingInstance->Get( bstrRelPath,
                                0,
                                xVarId,
                                0,
                                0 );
    if ( FAILED (hr) )
    {
        DebugMsg( ( DM_WARNING, L"RsopResetPolicySettingStatus: Get __RELPATH failed, 0x%x", hr ) );
        return hr;
    }

    if ( varId.vt == VT_NULL || varId.vt == VT_EMPTY )
    {
        return E_UNEXPECTED;
    }

    DWORD dwIdSize = wcslen(varId.bstrVal);

    //
    //  Create a query for all references of the object
    //

    //
    //  Query template
    //

    XPtrLF<WCHAR>   szQuery = LocalAlloc( LPTR, sizeof(WCHAR) * ( dwIdSize ) + sizeof(RESET_QUERY_TEMPLATE) );

    if ( !szQuery )
    {
        DebugMsg( ( DM_WARNING, L"RsopResetPolicySettingStatus: LocalAlloc failed, 0x%x", GetLastError() ) );
        return E_OUTOFMEMORY;
    }

    wsprintf( szQuery, RESET_QUERY_TEMPLATE, varId.bstrVal );

    XBStr bstrLanguage = L"WQL";
    XBStr bstrQuery = szQuery;
    XInterface<IEnumWbemClassObject> pEnum;
    XBStr bstrPath = L"__PATH";
    XBStr bstrStatus = L"status";

    //
    // search for RSOP_ExtensionEventSourceLink
    //
    hr = pServices->ExecQuery(  bstrLanguage,
                                bstrQuery,
                                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_ENSURE_LOCATABLE | WBEM_FLAG_RETURN_IMMEDIATELY,
                                0,
                                &pEnum );
    if ( SUCCEEDED( hr ) )
    {
        DWORD dwReturned;

        do 
        {
            XInterface<IWbemClassObject> xInst;

            dwReturned = 0;

            hr = pEnum->Next(   WBEM_INFINITE,
                                1,
                                &xInst,
                                &dwReturned );
            if ( SUCCEEDED( hr ) && dwReturned == 1 )
            {
                //
                // delete RSoP_PolicySettingStatus
                //
                VARIANT varStatus;
                VariantInit( &varStatus );
                XVariant xVarStatus( &varStatus );

                hr = xInst->Get(bstrStatus,
                                0,
                                &varStatus,
                                0,
                                0 );
                if ( SUCCEEDED( hr ) )
                {
                    hr = pServices->DeleteInstance( varStatus.bstrVal,
                                                    0L,
                                                    0,
                                                    0 );
                    if ( SUCCEEDED( hr ) )
                    {
                        //
                        // delete RSoP_PolicySettingLink
                        //

                        VARIANT varLink;
                        VariantInit( &varLink );
                        hr = xInst->Get(bstrPath,
                                        0L,
                                        &varLink,
                                        0,
                                        0 );
                        if ( SUCCEEDED(hr) )
                        {
                            XVariant xVarLink( &varLink );

                            hr = pServices->DeleteInstance( varLink.bstrVal,
                                                            0L,
                                                            0,
                                                            0 );
                            if ( FAILED( hr ) )
                            {
                                return hr;
                            }
                        }
                    }
                }
            }

        } while ( SUCCEEDED( hr ) && dwReturned == 1 );
    }

    if ( hr == S_FALSE )
    {
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\rsop\reghash.h ===
//*************************************************************
//
//  Hash table for registry Rsop data
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1999
//  All rights reserved
//
//  History:    7-Jun-99   SitaramR    Created
//
//*************************************************************

#define HASH_TABLE_SIZE 97                  // # buckets in hash table
#define STARCOMMAND     TEXT("**Command")   // A special valuename created to keep the commands
//
// List of data values for key registry value in precedence order,
// entries at the beginning of list have higher precedence.
//

typedef struct _REGDATAENTRY {
    BOOL                      bDeleted;        // Is this a deleted value ?
    BOOL                      bAdmPolicy;      // Is this generated by an Adm policy ?
    DWORD                     dwValueType;
    DWORD                     dwDataLen;
    BYTE  *                   pData;
    WCHAR *                   pwszGPO;         // Gpo that set this data
    WCHAR *                   pwszSOM;         // SDOU that the above Gpo is linked to
    WCHAR *                   pwszCommand;     // The actual command that caused the change in data value
    struct _REGDATAENTRY *    pNext;
} REGDATAENTRY, *LPREGDATAENTRY;


//
// List of registry value names under a common registry key
//

typedef struct _REGVALUEENTRY {
    WCHAR *                   pwszValueName;    // Registry value name
    REGDATAENTRY *            pDataList;
    struct _REGVALUEENTRY *   pNext;

} REGVALUEENTRY, *LPREGVALUEENTRY;



//
// List of registry keys that map to same hash bucket
//

typedef struct _REGKEYENTRY {
    WCHAR *                 pwszKeyName;        // Registry key name
    REGVALUEENTRY *         pValueList;
    struct _REGKEYENTRY *   pNext;
} REGKEYENTRY, *LPREGKEYENTRY;


//
// Hash table for looking up registry keys
//

typedef struct _REGHASHTABLE {
    REGKEYENTRY *   aHashTable[HASH_TABLE_SIZE];
    HRESULT         hrError;
} REGHASHTABLE, *LPREGHASHTABLE;


//
// Registry operation types for deleting and
// adding values.
//

typedef enum _REGOPERATION {
    REG_DELETEVALUE = 0,
    REG_DELETEALLVALUES,
    REG_DELETEKEY,
    REG_ADDVALUE,
    REG_SOFTADDVALUE,
    REG_INTERNAL_DELETESINGLEKEY
} REGOPERATION;

//
// Public methods of hash table: alloc, free and addentry
//

#ifdef __cplusplus
extern "C" {
#endif

REGHASHTABLE * AllocHashTable();

void FreeHashTable( REGHASHTABLE *pHashTable );

BOOL AddRegHashEntry( REGHASHTABLE *pHashTable,
                      REGOPERATION opnType,
                      WCHAR *pwszKeyName,
                      WCHAR *pwszValueName,
                      DWORD dwType,
                      DWORD dwDataLen,
                      BYTE *pData,
                      WCHAR *pwszGPO,
                      WCHAR *pwszSOM,
                      WCHAR *szCommand, 
                      BOOL bCreateCommand);
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\applygp\test.c ===
#include <windows.h>
#include <userenv.h>
#include <userenvp.h>

int __cdecl main( int argc, char *argv[])
{
    HANDLE hToken;
    HANDLE hEvent;


    OpenProcessToken (GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken);

    hEvent = CreateEvent (NULL, TRUE, FALSE, TEXT("some event"));

    ApplyGroupPolicy (GP_APPLY_DS_POLICY | GP_BACKGROUND_REFRESH, hToken, hEvent, HKEY_CURRENT_USER, NULL);

    for (;;) ;

    CloseHandle (hEvent);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\rsop\rsop.cpp ===
//*************************************************************
//
//  Resultant set of policy
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//  History:    7-Jun-99   SitaramR    Created
//
//*************************************************************

#include "uenv.h"
#include "wbemcli.h"
#include "reghash.h"
#include "rsop.h"
#include "logger.h"
#include "RsopInc.h"
#include "rsopsec.h"
#include "locator.h"

BOOL LogSessionData( LPGPOINFO lpGPOInfo, LPRSOPSESSIONDATA lprsopSessionData );
BOOL LogSOMData( LPGPOINFO lpGPOInfo );
BOOL LogGpoData( LPGPOINFO lpGPOInfo );
BOOL LogGpLinkData( LPGPOINFO lpGPOInfo );
/*
BOOL LogGpLinkListData( LPGPOINFO lpGPOInfo );
*/

BOOL DeleteInstances( WCHAR *pwszClass, IWbemServices *pWbemServices );
BOOL ConnectToNameSpace(LPGPOINFO lpGPOInfo, WCHAR *pwszRootNameSpace,
                        BOOL bPlanningMode, IWbemLocator *pWbemLocator, 
                        IWbemServices **ppWbemServices, BOOL *pbCreated);
HRESULT
CreateCSE_EventSourceAssoc( IWbemServices*  pServices,
                            LPWSTR          szCSEGuid,
                            LPWSTR          szEventLogSources );

HRESULT
DeleteCSE_EventSourceAssoc( IWbemServices*  pServices,
                            LPWSTR          szCSEGuid );

//*************************************************************
//
//  GetWbemServices()
//
//  Purpose:    Returns IWbemServices ptr to namespace
//
//  Parameters: lpGPOInfo     - Gpo info
//              pwszNameSpace - namespace
//              bPlanningMode - Is this called during planning mode ?
//
//  Return:     True if successful
//
//*************************************************************

BOOL GetWbemServices( LPGPOINFO lpGPOInfo,
                      WCHAR *pwszRootNameSpace,
                      BOOL bPlanningMode,
                      BOOL *bCreated,
                      IWbemServices **ppWbemServices)
{
    HRESULT hr;

    OLE32_API *pOle32Api = LoadOle32Api();
    if ( pOle32Api == NULL )
        return FALSE;


    IWbemLocator *pWbemLocator = NULL;
    hr = pOle32Api->pfnCoCreateInstance( CLSID_WbemLocator,
                                         NULL,
                                         CLSCTX_INPROC_SERVER,
                                         IID_IWbemLocator,
                                         (LPVOID *) &pWbemLocator );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("GetWbemServices: CoCreateInstance returned 0x%x"), hr));
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("GetWbemServices: CoCreateInstance succeeded")));

    XInterface<IWbemLocator> xLocator( pWbemLocator );

    //
    // get the appropriate name space and connect
    //

    
    if (!ConnectToNameSpace( lpGPOInfo, pwszRootNameSpace, bPlanningMode, pWbemLocator, ppWbemServices, bCreated)) {
        DebugMsg((DM_WARNING, TEXT("GetWbemServices: ConnectToNameSpace failed with 0x%x" ), GetLastError()));
        return FALSE;
    }

    
    return TRUE;
}



//*************************************************************
//
//  ReleaseWbemServices()
//
//  Purpose:    Releases wbem service pointer
//
//  Parameters: lpGPOInfo - Gpo info
//
//*************************************************************

void ReleaseWbemServices( LPGPOINFO lpGPOInfo )
{
    if ( lpGPOInfo->pWbemServices ) {
        lpGPOInfo->pWbemServices->Release();
        lpGPOInfo->pWbemServices = NULL;
    }
}



//*************************************************************
//
//  LogRsopData()
//
//  Purpose:    Logs Rsop data to Cimom database
//
//  Parameters: lpGPOInfo  - Gpo Info
//
//  Return:     True if successful
//
//*************************************************************
BOOL LogRsopData( LPGPOINFO lpGPOInfo, LPRSOPSESSIONDATA lprsopSessionData )
{
    HRESULT hr;

    if ( lpGPOInfo->pWbemServices  == NULL ) {
         DebugMsg((DM_WARNING, TEXT("LogRsopData: Null wbem services pointer, so cannot log Rsop data" )));
         return FALSE;
    }

    if ( !LogSessionData( lpGPOInfo, lprsopSessionData ) )
        return FALSE;

    if ( !LogSOMData( lpGPOInfo ) )
        return FALSE;

    if ( !LogGpoData( lpGPOInfo ) )
        return FALSE;

    if ( !LogGpLinkData( lpGPOInfo ) )
        return FALSE;

    DebugMsg((DM_VERBOSE, TEXT("LogRsopData: Successfully logged Rsop data" )));

    return TRUE;
}

//*************************************************************
//
//  LogSessionData()
//
//  Purpose:    Logs scopes of management data
//
//  Parameters: lpGPOInfo     - Gpo Info
//
//  Return:     True if successful
//
//*************************************************************

BOOL LogSessionData( LPGPOINFO lpGPOInfo, LPRSOPSESSIONDATA lprsopSessionData )
{
    CSessionLogger sessionLogger( lpGPOInfo->pWbemServices );
    if ( !sessionLogger.Log(lprsopSessionData) )
        return FALSE;

    return TRUE;
}


//*************************************************************
//
//  LogSOMData()
//
//  Purpose:    Logs scopes of management data
//
//  Parameters: lpGPOInfo     - Gpo Info
//
//  Return:     True if successful
//
//*************************************************************

BOOL LogSOMData( LPGPOINFO lpGPOInfo )
{
    IWbemServices *pWbemServices = lpGPOInfo->pWbemServices;

    if ( !(lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD) ) {

        //
        // Clean up SOM data at foreground refresh only. Otherwise extensions that run in
        // foreground only may have policy data that have dangling references to SOM that
        // existed at foreground refresh time.
        //

        if ( !DeleteInstances( L"RSOP_SOM", pWbemServices ) )
            return FALSE;
    }

    DWORD dwOrder = 1;
    CSOMLogger somLogger( lpGPOInfo->dwFlags, pWbemServices );

    LPSCOPEOFMGMT pSOMList = lpGPOInfo->lpSOMList;
    while ( pSOMList ) {

        if ( !somLogger.Log( pSOMList, dwOrder, FALSE ) )
             return FALSE;

        dwOrder++;
        pSOMList = pSOMList->pNext;
    }

    pSOMList = lpGPOInfo->lpLoopbackSOMList;
    while ( pSOMList ) {

        if ( !somLogger.Log( pSOMList, dwOrder, TRUE ) )
             return FALSE;

        dwOrder++;
        pSOMList = pSOMList->pNext;
    }

    return TRUE;
}

//*************************************************************
//
//  LogGpoData()
//
//  Purpose:    Logs GPO data
//
//  Parameters: lpGPOInfo     - Gpo Info
//
//  Return:     True if successful
//
//*************************************************************

BOOL LogGpoData( LPGPOINFO lpGPOInfo )
{
    IWbemServices *pWbemServices = lpGPOInfo->pWbemServices;

    if ( !(lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD) ) {

        //
        // Clean up SOM data at foreground refresh only. Otherwise extensions that run in
        // foreground only may have policy data that have dangling references to SOM that
        // existed at foreground refresh time.
        //

        if ( !DeleteInstances( L"RSOP_GPO", pWbemServices ) )
            return FALSE;
    }

    CGpoLogger gpoLogger( lpGPOInfo->dwFlags, pWbemServices );

    GPCONTAINER *pGpContainer = lpGPOInfo->lpGpContainerList;
    while ( pGpContainer ) {
        if ( !gpoLogger.Log( pGpContainer ) )
            return FALSE;

        pGpContainer = pGpContainer->pNext;
    }

    pGpContainer = lpGPOInfo->lpLoopbackGpContainerList;
    while ( pGpContainer ) {
        if ( !gpoLogger.Log( pGpContainer ) )
            return FALSE;

        pGpContainer = pGpContainer->pNext;
    }

    return TRUE;
}


//*************************************************************
//
//  FindGPO()
//
//  Purpose:    Finds order of GPO in SOM
//
//  Parameters: pSOM  - SOM
//              pGPO  - GPO
//
//  Return:     Order #
//
//*************************************************************

DWORD FindGPO( LPEXTFILTERLIST pGPOFilterList, LPSCOPEOFMGMT pSOM, GPLINK *pGpLink )
{
    DWORD dwOrder = 1;
    WCHAR *pwszLinkGPOPath = StripLinkPrefix( pGpLink->pwszGPO );
    WCHAR *pwszLinkSOMPath = StripLinkPrefix( pSOM->pwszSOMId );
    
    //
    // If the SOM is blocked then the GPO is linked here
    // only if the GPO is forced
    //

    if ( pSOM->bBlocked && !pGpLink->bNoOverride ) 
        return 0;

    while ( pGPOFilterList )
    {
        WCHAR *pwszAppliedGPOPath = StripPrefix( pGPOFilterList->lpGPO->lpDSPath );
        WCHAR *pwszAppliedGPOSomPath = StripLinkPrefix( pGPOFilterList->lpGPO->lpLink );

        if ( !pGPOFilterList->bLogged && 
             (CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE, pwszLinkGPOPath, -1,
                             pwszAppliedGPOPath, -1 ) == CSTR_EQUAL) && 
             (CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE, pwszLinkSOMPath, -1,
                             pwszAppliedGPOSomPath, -1 ) == CSTR_EQUAL))
        {
            pGPOFilterList->bLogged = TRUE;
            return dwOrder;
        }

        pGPOFilterList = pGPOFilterList->pNext;
        dwOrder++;
    }

    return 0;
}

void
ClearLoggedFlag( LPEXTFILTERLIST pGPOFilterList )
{
    while ( pGPOFilterList )
    {
        pGPOFilterList->bLogged = FALSE;
        pGPOFilterList = pGPOFilterList->pNext;
    }
}


//*************************************************************
//
//  LogGpLinkData()
//
//  Purpose:    Logs GPLINK data
//
//  Parameters: lpGPOInfo     - Gpo Info
//
//  Return:     True if successful
//
//*************************************************************

BOOL LogGpLinkData( LPGPOINFO lpGPOInfo )
{
    IWbemServices *pWbemServices = lpGPOInfo->pWbemServices;
    DWORD          dwListOrder = 1;
    DWORD          dwAppliedOrder = 1;

    if ( !DeleteInstances( L"RSOP_GPLink", pWbemServices ) )
         return FALSE;

    CGpLinkLogger gpLinkLogger( pWbemServices );

    // The GPO application order
    LPEXTFILTERLIST pFilterList = lpGPOInfo->lpExtFilterList;
    
    ClearLoggedFlag( pFilterList );
    // the function takes care of Null list.


    //
    // Normal case
    //

    SCOPEOFMGMT *pSOMList = lpGPOInfo->lpSOMList;
    while ( pSOMList ) {

        GPLINK *pGpLinkList = pSOMList->pGpLinkList;
        DWORD dwSomOrder = 1;

        while ( pGpLinkList ) {

            dwAppliedOrder = FindGPO( pFilterList, pSOMList, pGpLinkList );
           
            if ( !gpLinkLogger.Log( pSOMList->pwszSOMId, FALSE, pGpLinkList, dwSomOrder, dwListOrder, dwAppliedOrder ) )
                 return FALSE;

            pGpLinkList = pGpLinkList->pNext;
            dwSomOrder++;
            dwListOrder++;
        }

        pSOMList = pSOMList->pNext;
    }


    //
    // Loopback case
    //

    pSOMList = lpGPOInfo->lpLoopbackSOMList;
    while ( pSOMList ) {

        GPLINK *pGpLinkList = pSOMList->pGpLinkList;
        DWORD dwSomOrder = 1;

        while ( pGpLinkList ) {

            //
            // If the SOM is blocked then the GPO is linked here
            // only if the GPO is forced
            //

            dwAppliedOrder = FindGPO( pFilterList, pSOMList, pGpLinkList );
           
            if ( !gpLinkLogger.Log( pSOMList->pwszSOMId, TRUE, pGpLinkList, dwSomOrder, dwListOrder, dwAppliedOrder ) )
                 return FALSE;

            pGpLinkList = pGpLinkList->pNext;
            dwSomOrder++;
            dwListOrder++;
        }

        pSOMList = pSOMList->pNext;
    }

    return TRUE;
}

/*
//*************************************************************
//
//  LogGpLinkListData()
//
//  Purpose:    Logs GPLinkList data
//
//  Parameters: lpGPOInfo     - Gpo Info
//
//  Return:     True if successful
//
//*************************************************************

BOOL LogGpLinkListData( LPGPOINFO lpGPOInfo )
{
    BOOL bLoopback;

    IWbemServices *pWbemServices = lpGPOInfo->pWbemServices;

    if ( !DeleteInstances( L"RSOP_GPLinkList", pWbemServices ) )
    {
         return FALSE;
    }

    ClearLoggedFlag( lpGPOInfo->lpSOMList );
    ClearLoggedFlag( lpGPOInfo->lpLoopbackSOMList ); 
    // the function takes care of Null list.

    CGpLinkListLogger gpLinkListLogger( lpGPOInfo->dwFlags, pWbemServices );
    DWORD dwTypeOrder = 1;
    LPEXTFILTERLIST pFilterList = lpGPOInfo->lpExtFilterList;

    while ( pFilterList )
    {
        PGROUP_POLICY_OBJECT pGPO = pFilterList->lpGPO;
        DWORD dwSOMOrder  = 0;
        BOOL bFound = FALSE;
        LPSCOPEOFMGMT pSOMList = lpGPOInfo->lpSOMList;


        bLoopback = FALSE;
        while ( pSOMList )
        {
            if ( CompareString( LOCALE_USER_DEFAULT,
                                NORM_IGNORECASE,
                                pSOMList->pwszSOMId,
                                -1,
                                StripLinkPrefix(pGPO->lpLink),
                                -1 ) == CSTR_EQUAL )
            {
                dwSOMOrder = FindGPO( pSOMList, pGPO );
                if ( dwSOMOrder != 0 ) {
                    bFound = TRUE;
                    break;
                }
            }
            pSOMList = pSOMList->pNext;
        }


        
        if ( !bFound )
        {
            pSOMList = lpGPOInfo->lpLoopbackSOMList;

            bLoopback = TRUE;
            while ( pSOMList )
            {
                if ( CompareString( LOCALE_USER_DEFAULT,
                                    NORM_IGNORECASE,
                                    pSOMList->pwszSOMId,
                                    -1,
                                    StripLinkPrefix(pGPO->lpLink),
                                    -1 ) == CSTR_EQUAL )
                {
                    dwSOMOrder = FindGPO( pSOMList, pGPO );
                    if ( dwSOMOrder != 0 ) {
                        bFound = TRUE;
                        break;
                    }
                }
                pSOMList = pSOMList->pNext;
            }
        }

        
        if ( !bFound )
        {
            ClearLoggedFlag( lpGPOInfo->lpSOMList );
            return FALSE;
        }

        if ( !gpLinkListLogger.Log( pGPO, dwSOMOrder, bLoopback, dwTypeOrder ) )
        {
            ClearLoggedFlag( lpGPOInfo->lpSOMList );
            ClearLoggedFlag( lpGPOInfo->lpLoopbackSOMList ); 
            return FALSE;
        }
        
        dwTypeOrder++;
        pFilterList = pFilterList->pNext;
    }

    ClearLoggedFlag( lpGPOInfo->lpSOMList );
    ClearLoggedFlag( lpGPOInfo->lpLoopbackSOMList ); 

    return TRUE;
}

*/

//*************************************************************
//
//  DeleteInstaces()
//
//  Purpose:    Deletes all instances of a specified class
//
//  Parameters: pwszClass     - Class name
//              pWbemServices - Wbem services
//
//  Return:     True if successful
//
//*************************************************************

BOOL DeleteInstances( WCHAR *pwszClass, IWbemServices *pWbemServices )
{
    IEnumWbemClassObject *pEnum = NULL;

    XBStr xbstrClass( pwszClass );
    if ( !xbstrClass ) {
        DebugMsg((DM_WARNING, TEXT("DeleteInstances: Failed to allocate memory" )));
        return FALSE;
    }

    HRESULT hr = pWbemServices->CreateInstanceEnum( xbstrClass,
                                                    WBEM_FLAG_SHALLOW,
                                                    NULL,
                                                    &pEnum );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("DeleteInstances: DeleteInstances failed with 0x%x" ), hr ));
        return FALSE;
    }

    XInterface<IEnumWbemClassObject> xEnum( pEnum );

    XBStr xbstrPath( L"__PATH" );
    if ( !xbstrPath ) {
        DebugMsg((DM_WARNING, TEXT("DeleteInstances: Failed to allocate memory" )));
        return FALSE;
    }

    IWbemClassObject *pInstance = NULL;
    ULONG ulReturned = 1;
    LONG TIMEOUT = -1;

    while ( ulReturned == 1 ) {

        hr = pEnum->Next( TIMEOUT,
                          1,
                          &pInstance,
                          &ulReturned );
        if ( hr == S_OK && ulReturned == 1 ) {

            XInterface<IWbemClassObject> xInstance( pInstance );

            VARIANT var;
            VariantInit( &var );

            hr = pInstance->Get( xbstrPath,
                                 0L,
                                 &var,
                                 NULL,
                                 NULL );
            if ( FAILED(hr) ) {
                 DebugMsg((DM_WARNING, TEXT("DeleteInstances: Get failed with 0x%x" ), hr ));
                 return FALSE;
            }

            hr = pWbemServices->DeleteInstance( var.bstrVal,
                                                0L,
                                                NULL,
                                                NULL );
            VariantClear( &var );

            if ( FAILED(hr) ) {
                 DebugMsg((DM_WARNING, TEXT("DeleteInstances: DeleteInstance failed with 0x%x" ), hr ));
                 return FALSE;
            }

        }
    }

    return TRUE;

}




//*************************************************************
//
//  LogRegistryRsopData()
//
//  Purpose:    Logs registry Rsop data to Cimom database
//
//  Parameters: dwFlags       - Gpo Info flags
//              pHashTable    - Hash table with registry policy data
//              pWbemServices - Namespace pointer for logging
//
//  Return:     True if successful
//
//*************************************************************

BOOL LogRegistryRsopData( DWORD dwFlags, REGHASHTABLE *pHashTable, IWbemServices *pWbemServices )
{
    HRESULT hr;
    DWORD i;

    if ( !DeleteInstances( L"RSOP_RegistryPolicySetting", pWbemServices ) )
         return FALSE;

    CRegistryLogger regLogger( dwFlags, pWbemServices );

    for ( i=0; i<HASH_TABLE_SIZE; i++ ) {

        REGKEYENTRY *pKeyEntry = pHashTable->aHashTable[i];
        while ( pKeyEntry ) {

            WCHAR *pwszKeyName = pKeyEntry->pwszKeyName;
            REGVALUEENTRY *pValueEntry = pKeyEntry->pValueList;

            while ( pValueEntry ) {

                DWORD dwOrder = 1;
                WCHAR *pwszValueName = pValueEntry->pwszValueName;
                REGDATAENTRY *pDataEntry = pValueEntry->pDataList;

                while ( pDataEntry ) {
                    if ( !regLogger.Log( pwszKeyName,
                                         pwszValueName,
                                         pDataEntry,
                                         dwOrder ) )
                        return FALSE;

                    pDataEntry = pDataEntry->pNext;
                    dwOrder++;
                }

                pValueEntry = pValueEntry->pNext;

            }   // while pValueEntry

            pKeyEntry = pKeyEntry->pNext;

        }   // while pKeyEntry

    }   // for

    DebugMsg((DM_VERBOSE, TEXT("LogRegistry RsopData: Successfully logged registry Rsop data" )));

    return TRUE;
}



//*************************************************************
//
//  LogAdmRsopData()
//
//  Purpose:    Logs Rsop ADM template data to Cimom database
//
//  Parameters: pAdmFileCache - List of adm file to log
//              pWbemServices - Namespace pointer
//
//  Return:     True if successful
//
//*************************************************************

BOOL LogAdmRsopData( ADMFILEINFO *pAdmFileCache, IWbemServices *pWbemServices )
{
    if ( !DeleteInstances( L"RSOP_AdministrativeTemplateFile", pWbemServices ) )
         return FALSE;

    CAdmFileLogger admLogger( pWbemServices );

    while ( pAdmFileCache ) {
        if ( !admLogger.Log( pAdmFileCache ) )
             return FALSE;

        pAdmFileCache = pAdmFileCache->pNext;
    }

    DebugMsg((DM_VERBOSE, TEXT("LogAdmRsopData: Successfully logged Adm data" )));

    return TRUE;
}



//*************************************************************
//
//  LogExtSessionStatus()
//
//  Purpose:    Logs ExtensionSessionStatus at the beginning of processing
//
//  Parameters: pWbemServices - Namespace pointer
//              lpExt         - Extension description
//              bSupported    - Rsop Logging Supported
//
//  Return:     True if successful
//
//*************************************************************

BOOL LogExtSessionStatus(IWbemServices *pWbemServices, LPGPEXT lpExt, BOOL bSupported, BOOL bLogEventSrc )
{
    CExtSessionLogger extLogger( pWbemServices );

    if (!extLogger.Log(lpExt, bSupported))
        return FALSE;

    if ( !bLogEventSrc )
    {
        return TRUE;
    }

    HRESULT hr;

    if ( lpExt )
    {
        hr = DeleteCSE_EventSourceAssoc(pWbemServices,
                                        lpExt->lpKeyName );
        if ( FAILED( hr ) )
        {
            DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: DeleteCSE_EventSourceAssoc failed with 0x%x" ), hr ));
            return FALSE;
        }

        if ( lpExt->szEventLogSources )
        {
            if ( lpExt->lpKeyName )
            {
                //
                // good CSE
                //
                hr = CreateCSE_EventSourceAssoc(pWbemServices,
                                                lpExt->lpKeyName,
                                                lpExt->szEventLogSources );
                if ( FAILED(hr) )
                {
                    DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: CreateCSEEventSourceNameAssoc failed with 0x%x" ), hr ));
                    return FALSE;
                }
            }
            else
            {
                return FALSE;
            }
        }
        else
        {
            //
            // most likely the Registry CSE
            //
            if ( !lpExt->lpDllName || !lpExt->lpKeyName )
            {
                return FALSE;
            }
            else
            {
                WCHAR szEventLogSources[MAX_PATH];

                wcscpy( szEventLogSources, L"(" );
                wcscat( szEventLogSources, lpExt->lpDllName );
                LPWSTR szTemp = wcsrchr( szEventLogSources, L'.' );

                if ( szTemp )
                {
                    *szTemp = 0;
                }
                // duble null terminate it
                wcscat( szEventLogSources, L",Application)");
                szEventLogSources[lstrlen(szEventLogSources)+1] = L'\0';

                hr = CreateCSE_EventSourceAssoc(pWbemServices,
                                                lpExt->lpKeyName,
                                                szEventLogSources );
                if ( FAILED(hr) )
                {
                    DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: CreateCSEEventSourceNameAssoc failed with 0x%x" ), hr ));
                    return FALSE;
                }
            }
        }
    }
    else
    {
        hr = DeleteCSE_EventSourceAssoc(pWbemServices,
                                        GPCORE_GUID );
        if ( FAILED( hr ) )
        {
            DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: DeleteCSE_EventSourceAssoc failed with 0x%x" ), hr ));
            return FALSE;
        }

        //
        // gp engine
        //
        WCHAR   szEventLogSources[] = L"(userenv,Application)\0";

        hr = CreateCSE_EventSourceAssoc(pWbemServices,
                                        GPCORE_GUID,
                                        szEventLogSources );
        if ( FAILED(hr) )
        {
            DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: CreateCSEEventSourceNameAssoc failed with 0x%x" ), hr ));
            return FALSE;
        }
    }

    DebugMsg((DM_VERBOSE, TEXT("LogExtSessionStatus: Successfully logged Extension Session data" )));

    return TRUE;
}


//*************************************************************
//
//  UpdateExtSessionStatus()
//
//  Purpose:    Updates ExtensionSessionStatus at the end of processing
//
//  Parameters: pWbemServices - Namespace pointer
//              lpKeyName     - Extension Guid Can be NULL in which case it means GPEngine
//              bDirty        - Logging was done successfully..
//              dwErr         - Error in processing
//
//  Return:     True if successful
//
//*************************************************************

BOOL UpdateExtSessionStatus(IWbemServices *pWbemServices, LPTSTR lpKeyName, BOOL bIncomplete, DWORD dwErr )
{
    CExtSessionLogger extLogger( pWbemServices );

    if (!extLogger.Update(lpKeyName, bIncomplete, dwErr))
        return FALSE;

    return TRUE;
}





//*************************************************************
//
//  RsopDeleteAllValues ()
//
//  Purpose:    Deletes all values under specified key
//
//  Parameters: hKey    -   Key to delete values from
//
//  Return:
//
//  Comments: Same as util.c!DeleteAllValues except that it logs
//            Data into the rsop hash table
//
//*************************************************************

BOOL RsopDeleteAllValues(HKEY hKey, REGHASHTABLE *pHashTable,
                         WCHAR *lpKeyName, WCHAR *pwszGPO, WCHAR *pwszSOM, WCHAR *szCommand, BOOL *bLoggingOk)
{
    TCHAR ValueName[MAX_PATH+1];
    DWORD dwSize = MAX_PATH+1;
    LONG lResult;
    BOOL bFirst=TRUE;

    while (RegEnumValue(hKey, 0, ValueName, &dwSize,
            NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {

            lResult = RegDeleteValue(hKey, ValueName);

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_WARNING, TEXT("RsopDeleteAllValues:  Failed to delete value <%s> with %d."), ValueName, lResult));
                return FALSE;
            } else {
                DebugMsg((DM_VERBOSE, TEXT("RsopDeleteAllValues:  Deleted <%s>"), ValueName));
            }


            *bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEVALUE, lpKeyName,
                                          ValueName, 0, 0, NULL,
                                          pwszGPO, pwszSOM, szCommand, bFirst );

            bFirst = FALSE;
            dwSize = MAX_PATH+1;
    }
    return TRUE;
}


//*************************************************************
//
//  SetRsopTargetName()
//
//  Purpose:    Allocates and returns the target name under which Rsop data will be logged.
//
//  Parameters: lpGPOInfo       -  GPOInfo structure
//
//  Return:     TRUE if successful
//              FALSE otherwise
//
//*************************************************************

BOOL SetRsopTargetName(LPGPOINFO lpGPOInfo)
{
    XPtrLF<TCHAR>   xszFullName;
    XPtrLF<TCHAR>   xszTargetName;          // return value
    HANDLE          hOldToken;

    if ( lpGPOInfo->szName && lpGPOInfo->szTargetName )
    {
        return TRUE;
    }

    if ( lpGPOInfo->szName )
    {
        LocalFree( lpGPOInfo->szName );
    }

    if ( lpGPOInfo->szTargetName )
    {
        LocalFree( lpGPOInfo->szTargetName );
    }

    //
    // fill up the right target name
    //

    if ( lpGPOInfo->dwFlags & GP_MACHINE ) {
        if ( lpGPOInfo->dwFlags & GP_APPLY_DS_POLICY ) {
            xszFullName = MyGetComputerName (NameSamCompatible);
        }
        else {
            DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
            xszFullName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(MAX_COMPUTERNAME_LENGTH + 1));

            if (xszFullName) {
                 if (!GetComputerName(xszFullName, &dwSize)) {
                     xszFullName = NULL;
                 }
            }
        }
    }
    else {

        if (!ImpersonateUser(lpGPOInfo->hToken, &hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("RsopTargetName: Failed to impersonate user")));
            return FALSE;
        }

        xszFullName = MyGetUserName (NameSamCompatible);

        RevertToUser(&hOldToken);
    }


    if (!xszFullName) {
        DebugMsg((DM_WARNING, TEXT("RsopTargetName: Failed to get the %s name, error = %d"),
                    (lpGPOInfo->dwFlags & GP_MACHINE ? TEXT("Computer"): TEXT("User")), GetLastError()));
        return FALSE;
    }

    xszTargetName = (LPTSTR) LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(xszFullName)+1));
    if (!xszTargetName)
        return FALSE;


    //
    // Format the TargetName appropriately.
    //
    // We are just going to look for the first slash if present and treat the rest of
    // it as username.
    //


    LPTSTR lpTemp = xszFullName;

    while (*lpTemp && ((*lpTemp) != TEXT('\\')))
        lpTemp++;

    if ((*lpTemp) == TEXT('\\'))
        lstrcpy(xszTargetName, lpTemp+1);
    else
        lstrcpy(xszTargetName, xszFullName);

    //
    // To be consistent we will also remove the final $ in the machine name
    //

    lpTemp = xszTargetName;

    if ( lpGPOInfo->dwFlags & GP_MACHINE ) {
        if ((*lpTemp) && (lpTemp[lstrlen(lpTemp)-1] == TEXT('$')))
            lpTemp[lstrlen(lpTemp)-1] = TEXT('\0');

    }
    
    // let the structure own it
    lpGPOInfo->szTargetName = xszTargetName.Acquire();
    lpGPOInfo->szName = xszFullName.Acquire();
    
    return TRUE;
}


//*************************************************************
//
//  ConnectToNameSpace()
//
//  Purpose:    Creates (if necessary) and connects to the appropriate name space
//
//  Parameters: lpGPOInfo           -  GPOInfo structure
//              pwszRootNameSpace   -  Root name space
//              bPlanningMode       -  Is this planning mode
//              pWbemLocator        -  locator pointer
//       [out]  ppWbemServices      -  pointer to WbemServices to a connected pointer
//       [out]  pbCreated           -  Is the name space created. Optional Can be null
//
//  Return:     TRUE if successful
//              FALSE otherwise
//
//*************************************************************

BOOL ConnectToNameSpace(LPGPOINFO lpGPOInfo, WCHAR *pwszRootNameSpace,
                        BOOL bPlanningMode, IWbemLocator *pWbemLocator, 
                        IWbemServices **ppWbemServices, BOOL *pbCreated)
{
    XPtrLF<WCHAR>               xwszNameSpace = NULL;
    XInterface<IWbemServices>   xWbemServices;
    LPTSTR                      lpEnd = NULL;
    XPtrLF<WCHAR>               xszWmiNameFromUserSid;                      
    DWORD                       dwCurrentVersion;

    *ppWbemServices = NULL;
    if (pbCreated)
        *pbCreated = FALSE;
    
    if (!bPlanningMode) {


        //
        // Diagnostic mode
        //
        
        if (lpGPOInfo->dwFlags & GP_MACHINE) {
            xwszNameSpace = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pwszRootNameSpace)+lstrlen(RSOP_NS_DIAG_MACHINE_OFFSET)+5)*sizeof(TCHAR));
            if (!xwszNameSpace) 
                return FALSE;

            lstrcpy(xwszNameSpace, pwszRootNameSpace);
            lpEnd = CheckSlash(xwszNameSpace);
            lstrcpy(lpEnd, RSOP_NS_DIAG_MACHINE_OFFSET);
        }
        else {

            xszWmiNameFromUserSid = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(lpGPOInfo->lpwszSidUser)+1));
            if (!xszWmiNameFromUserSid)
            {
                DebugMsg(( DM_WARNING, TEXT("ConnectToNameSpace::CreateNameSpace couldn't allocate memory with error %d"), GetLastError() ));
                return FALSE;
            }

            ConvertSidToWMIName(lpGPOInfo->lpwszSidUser, xszWmiNameFromUserSid);

            xwszNameSpace = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pwszRootNameSpace)+lstrlen(RSOP_NS_DIAG_USER_OFFSET_FMT)+
                                                      lstrlen(xszWmiNameFromUserSid)+5)*sizeof(TCHAR));
            if (!xwszNameSpace) 
                return FALSE;

            lstrcpy(xwszNameSpace, pwszRootNameSpace);
            lpEnd = CheckSlash(xwszNameSpace);
            wsprintf(lpEnd, RSOP_NS_DIAG_USER_OFFSET_FMT, xszWmiNameFromUserSid);
        }
    }
    else {

        //
        // Planning Mode
        //
        
        if (lpGPOInfo->dwFlags & GP_MACHINE) {
        
            //
            // Machine
            //
            
            xwszNameSpace = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pwszRootNameSpace)+lstrlen(RSOP_NS_PM_MACHINE_OFFSET)+5)*sizeof(TCHAR));
            if (!xwszNameSpace) 
                return FALSE;


            lstrcpy(xwszNameSpace, pwszRootNameSpace);
            lpEnd = CheckSlash(xwszNameSpace);
            lstrcpy(lpEnd, RSOP_NS_PM_MACHINE_OFFSET);
        }
        else {

            //
            // User
            //
            
            xwszNameSpace = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pwszRootNameSpace)+lstrlen(RSOP_NS_PM_USER_OFFSET)+5)*sizeof(TCHAR));
            if (!xwszNameSpace) 
                return FALSE;


            lstrcpy(xwszNameSpace, pwszRootNameSpace);
            lpEnd = CheckSlash(xwszNameSpace);
            lstrcpy(lpEnd, RSOP_NS_PM_USER_OFFSET);
        }
    }


    XBStr xNameSpace( xwszNameSpace );

    HRESULT hr = pWbemLocator->ConnectServer( xNameSpace,
                                    NULL,
                                    NULL,
                                    0L,
                                    0L,
                                    NULL,
                                    NULL,
                                    &xWbemServices );

    DebugMsg((DM_VERBOSE, TEXT("ConnectToNameSpace: ConnectServer returned 0x%x"), hr));

    if (bPlanningMode) {       
        if (FAILED(hr)) {
            DebugMsg((DM_WARNING, TEXT("ConnectToNameSpace: ConnectServer failed with 0x%x" ), hr ));
        }
        *ppWbemServices = xWbemServices.Acquire();
        return (SUCCEEDED(hr));
    }

    //
    // only diagnostic mode logging should reach here
    //

    if (FAILED(hr)) {
        DebugMsg((DM_VERBOSE, TEXT("ConnectToNameSpace: ConnectServer failed with 0x%x, trying to recreate the name space" ), hr ));

        if (lpGPOInfo->dwFlags & GP_MACHINE) {
            return FALSE;
        }
    }


    if (SUCCEEDED(hr)) {
        
        //
        // Now check whether there is an RSOP_Session instance under this namespace
        // to set the *pbCreated flag
        //


        hr = GetRsopSchemaVersionNumber(xWbemServices, &dwCurrentVersion);


        //
        // We don't have an Rsop schema version number
        //

        if (FAILED(hr)) {
            return FALSE;
        }

        if (dwCurrentVersion == 0) {
            DebugMsg((DM_VERBOSE, TEXT("ConnectToNameSpace: Rsop data has not been logged before or a major schema upg happened. relogging.." )));
            if (pbCreated)
                *pbCreated = TRUE;
        }
            
        if (lpGPOInfo->dwFlags & GP_MACHINE) {
            *ppWbemServices = xWbemServices.Acquire();
            return TRUE;
        }


        if (dwCurrentVersion != RSOP_MOF_SCHEMA_VERSION) {
            BOOL bAbort = FALSE;

            DebugMsg((DM_VERBOSE, TEXT("ConnectToNameSpace: Minor schema upg happened. copying classes. " )));
            hr = CopyNameSpace(RSOP_NS_USER, xNameSpace, FALSE, &bAbort, pWbemLocator );
            if ( FAILED(hr) )
            {
                DebugMsg((DM_WARNING, TEXT("ConnectToNameSpace: CopyNameSpace failed with 0x%x" ), hr ));
                return FALSE;
            }
        }

        *ppWbemServices = xWbemServices.Acquire();
        return TRUE;

    }    


    // Only user mode in diagnostic mode should reach here 
    // when it couldn't find the namespace
    //
    //

    XPtrLF<TCHAR>  xRootNameSpace = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(pwszRootNameSpace)+
                                                            lstrlen(RSOP_NS_DIAG_ROOTUSER_OFFSET)+20));
    if (!xRootNameSpace) {
        // there is nothing more we can do
        DebugMsg((DM_WARNING, TEXT("ConnectToNameSpace: Failed to allocate memory.3")));
        return FALSE;
    }

    lstrcpy(xRootNameSpace, pwszRootNameSpace);
    lpEnd = CheckSlash(xRootNameSpace);
    lstrcpy(lpEnd, RSOP_NS_DIAG_ROOTUSER_OFFSET);
    
    //
    // The security descriptor
    //

    XPtrLF<SID> xSid = GetUserSid(lpGPOInfo->hToken);

    if (!xSid) {
        DebugMsg((DM_WARNING, TEXT("ConnectToNameSpace::GetUserSid failed with %d"), GetLastError()));
        return FALSE;
    }


    XPtrLF<SECURITY_DESCRIPTOR> xsd;
    SECURITY_ATTRIBUTES sa;
    CSecDesc Csd;

    Csd.AddLocalSystem(RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);
    Csd.AddAdministrators(RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);
    Csd.AddSid(xSid, RSOP_READ_PERMS, CONTAINER_INHERIT_ACE);
    Csd.AddAdministratorsAsOwner();
    Csd.AddAdministratorsAsGroup();

    xsd = Csd.MakeSelfRelativeSD();
    if (!xsd) {
        DebugMsg((DM_WARNING, TEXT("ConnectToNameSpace::MakeselfRelativeSD failed with %d"), GetLastError()));
        return FALSE;
    }

    if (!SetSecurityDescriptorControl( (SECURITY_DESCRIPTOR *)xsd, SE_DACL_PROTECTED, SE_DACL_PROTECTED )) {
        DebugMsg((DM_WARNING, TEXT("ConnectToNameSpace::SetSecurityDescriptorControl failed with %d"), GetLastError()));
        return FALSE;
    }

    
    hr = CreateAndCopyNameSpace(pWbemLocator,
                                xRootNameSpace,
                                xRootNameSpace, 
                                xszWmiNameFromUserSid,
                                NEW_NS_FLAGS_COPY_CLASSES,
                                xsd,
                                0);
    if ( FAILED( hr ) )
    {
        DebugMsg((DM_WARNING, TEXT("ConnectToNameSpace:: CreateAndCopyNameSpace failed. Error=0x%08X."), hr));
        return FALSE;                                
    }                                

    hr = pWbemLocator->ConnectServer( xNameSpace,
                                    NULL,
                                    NULL,
                                    0L,
                                    0L,
                                    NULL,
                                    NULL,
                                    &xWbemServices );


    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("ConnectToNameSpace:: ConnectServer failed. hr=0x%08X."), hr));
        return FALSE;                                
    }                                

    *ppWbemServices = xWbemServices.Acquire();
    if (pbCreated)
        *pbCreated = TRUE;
    return TRUE;    
}


//*************************************************************
//
//  RsopDeleteUserNameSpace()
//
//  Purpose:    Deletes the name space for the user.
//              This should be used with cae because it calls
//              CoInitializeEx and can have other effects
//
//  Parameters: 
//              szComputer          -  Computer name
//              lpSid               -  Name of the User Name Space
//
//  Return:     TRUE if successful
//              FALSE otherwise
//
//*************************************************************

BOOL RsopDeleteUserNameSpace(LPTSTR szComputer, LPTSTR lpSid)
{
    IWbemLocator    *pLocalWbemLocator=NULL;
    BOOL             bStatus = TRUE;
    XCoInitialize    xCoInit;

    if (FAILED(xCoInit.Status())) {
        DebugMsg((DM_VERBOSE, TEXT("ApplyGroupPolicy: CoInitializeEx failed with 0x%x."), xCoInit.Status() ));
    }

    {
        CLocator         locator;
        LPTSTR           szLocComputer;

        szLocComputer = szComputer ? szComputer : TEXT(".");

        XPtrLF<WCHAR> xszParentNameSpace = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(RSOP_NS_DIAG_REMOTE_USERROOT_FMT)
                                                                             +lstrlen(szLocComputer)+5));

        if (!xszParentNameSpace) {
            DebugMsg(( DM_WARNING, TEXT("RsopDeleteUserNameSpace: Unable to allocate memory 0" )));
            return FALSE;
        }


        XPtrLF<WCHAR> xszWmiName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(lpSid)+1));
        if (!xszWmiName)
        {
            DebugMsg(( DM_WARNING, TEXT("RsopDeleteUserNameSpace::couldn't allocate memory with error %d"), GetLastError()));
            return FALSE;
        }

        ConvertSidToWMIName(lpSid, xszWmiName);
    

        pLocalWbemLocator = locator.GetWbemLocator();

        if (!pLocalWbemLocator) {
            return FALSE;
        }
        

        if ( (szLocComputer[0] == TEXT('\\')) && (szLocComputer[1] == TEXT('\\')) )
            szLocComputer += 2;
        
        wsprintf(xszParentNameSpace, RSOP_NS_DIAG_REMOTE_USERROOT_FMT, szLocComputer);

        HRESULT hr = DeleteNameSpace( xszWmiName, xszParentNameSpace, pLocalWbemLocator  );

        return SUCCEEDED( hr );
    }
}

HRESULT
CreateCSE_EventSourceAssoc( IWbemServices*  pServices,
                            LPWSTR          szCSEGuid,
                            LPWSTR          szEventLogSources )
{
    HRESULT hr;

    if ( !pServices || !szCSEGuid || !szEventLogSources )
    {
        DebugMsg( ( DM_WARNING, L"CreateCSEEventSourceNameAssoc: invalid arguments" ) );
        return E_INVALIDARG;
    }
    
    //
    //  get the RSOP_ExtensionEventSource class
    //
    XBStr bstr = L"RSOP_ExtensionEventSource";
    XInterface<IWbemClassObject> xClassSrc;
    hr = pServices->GetObject(  bstr,
                                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                0,
                                &xClassSrc,
                                0 );
    if ( FAILED( hr ) )
    {
        DebugMsg( ( DM_WARNING, L"CreateCSEEventSourceNameAssoc: GetObject failed, 0x%x", hr ) );
        return hr;
    }

    //
    //  spawn the RSOP_ExtensionEventSource instance
    //
    XInterface<IWbemClassObject> xInstSrc;
    hr = xClassSrc->SpawnInstance( 0, &xInstSrc );
    if ( FAILED (hr) )
    {
        DebugMsg( ( DM_WARNING, L"CreateCSEEventSourceNameAssoc: SpawnInstance failed, 0x%x", hr ) );
        return hr;
    }

    //
    //  get the RSOP_ExtensionEventSourceLink class
    //
    XInterface<IWbemClassObject> xClassLink;

    bstr = L"RSOP_ExtensionEventSourceLink";
    hr = pServices->GetObject(  bstr,
                                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                0,
                                &xClassLink,
                                0 );
    if ( FAILED( hr ) )
    {
        DebugMsg( ( DM_WARNING, L"CreateCSEEventSourceNameAssoc: GetObject failed, 0x%x", hr ) );
        return hr;
    }

    //
    //  spawn the RSOP_ExtensionEventSourceLink class
    //
    XInterface<IWbemClassObject> xInstLink;
    hr = xClassLink->SpawnInstance( 0, &xInstLink );
    if ( FAILED (hr) )
    {
        DebugMsg( ( DM_WARNING, L"CreateCSEEventSourceNameAssoc: SpawnInstance failed, 0x%x", hr ) );
        return hr;
    }

    //
    //  RSOP_ExtensionEventSourceLink
    //

    //
    //  create the first key
    //
    const LPCWSTR   szFormat = L"RSOP_ExtensionStatus.extensionGuid=\"%s\"";
    XPtrLF<WCHAR>   szCSE = LocalAlloc( LPTR, sizeof(WCHAR) * ( 48 + wcslen(szCSEGuid) ) );

    if ( !szCSE )
    {
        DebugMsg( ( DM_WARNING, L"CreateCSEEventSourceNameAssoc: LocalAlloc failed, 0x%x", GetLastError() ) );
        return E_OUTOFMEMORY;
    }

    //
    // e.g. RSOP_ExtensionStatus.extensionGuid="{00000000-0000-0000-0000-000000000000}"
    //
    wsprintf( szCSE, szFormat, szCSEGuid );

    VARIANT var;
    XBStr bstrVal;

    XBStr   bstreventLogSource = L"eventLogSource";
    XBStr   bstreventLogName = L"eventLogName";
    XBStr   bstrextensionStatus = L"extensionStatus";
    XBStr   bstreventSource = L"eventSource";
    XBStr   bstrid = L"id";

    var.vt = VT_BSTR;

    //
    //  szEventLogSources is in the format,
    //  "(source, name)"
    //  "(source, name)"
    //  ...
    //
    LPWSTR szStart = szEventLogSources;

    while ( *szStart )
    {
        //
        // extensionStatus
        //
        bstrVal = szCSE;
        var.bstrVal = bstrVal;

        hr = xInstLink->Put(bstrextensionStatus,
                            0,
                            &var,
                            0 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        GUID guid;

        //
        // create the [key]
        //
        hr = CoCreateGuid( &guid );
        if ( FAILED(hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: CoCreateGuid failed, 0x%x", hr ) );
            return hr;
        }

        WCHAR   szGuid[64];
        wsprintf( szGuid,
                  L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
                  guid.Data1,
                  guid.Data2,
                  guid.Data3,
                  guid.Data4[0], guid.Data4[1],
                  guid.Data4[2], guid.Data4[3],
                  guid.Data4[4], guid.Data4[5],
                  guid.Data4[6], guid.Data4[7] );

        LPWSTR szFormat = L"RSOP_ExtensionEventSource.id=\"%s\"";
        DWORD  dwSrcLen = wcslen(szGuid);

        XPtrLF<WCHAR> szKey = LocalAlloc( LPTR, sizeof(WCHAR) * (dwSrcLen + 48));
        if ( !szKey )
        {
            return E_OUTOFMEMORY;
        }
        wsprintf( szKey, szFormat, szGuid );

        //
        // eventSource
        //
        bstrVal = szKey;
        var.bstrVal = bstrVal;

        hr = xInstLink->Put(bstreventSource,
                            0,
                            &var,
                            0 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // RSOP_ExtensionEventSourceLink
        //
        hr = pServices->PutInstance(xInstLink,
                                    WBEM_FLAG_CREATE_OR_UPDATE,
                                    0,
                                    0 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // id
        //
        bstrVal = szGuid;
        var.bstrVal = bstrVal;

        hr = xInstSrc->Put( bstrid,
                            0,
                            &var,
                            0 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // search for '('
        //
        szStart = wcschr( szStart, L'(' );

        if ( !szStart )
        {
             break;
        }
        szStart++;

        //
        // search for ,
        //
        LPWSTR  szEnd = wcschr( szStart, L',' );

        if ( szEnd )
        {
            if ( szStart == szEnd )
            {
                return E_INVALIDARG;
            }
            *szEnd = 0;
        }
        else
        {
            return E_INVALIDARG;
        }

        //
        // eventLogSource
        //
        bstrVal = szStart;
        var.bstrVal = bstrVal;

        hr = xInstSrc->Put( bstreventLogSource,
                            0,
                            &var,
                            0 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        *szEnd = L',';
        szStart = szEnd + 1;

        //
        // search for )
        //
        szEnd = wcschr( szStart, L')' );

        if ( szEnd )
        {
            if ( szStart == szEnd )
            {
                return E_INVALIDARG;
            }
            *szEnd = 0;
        }
        else
        {
            return E_INVALIDARG;
        }

        //
        // eventLogName
        //
        bstrVal = szStart;
        var.bstrVal = bstrVal;

        hr = xInstSrc->Put( bstreventLogName,
                            0,
                            &var,
                            0 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // RSOP_ExtensionEventSource
        //
        hr = pServices->PutInstance(xInstSrc,
                                    WBEM_FLAG_CREATE_OR_UPDATE,
                                    0,
                                    0 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // next
        //
        *szEnd = L')';
        szStart = wcschr( szEnd, 0 );
        szStart++;
    }

    return hr;
}


HRESULT
DeleteCSE_EventSourceAssoc( IWbemServices*  pServices,
                            LPWSTR          szCSEGuid )
{
    HRESULT hr = S_OK;

    if ( !pServices || !szCSEGuid )
    {
        DebugMsg( ( DM_WARNING, L"DeleteCSE_EventSourceAssoc: invalid arguments" ) );
        return E_INVALIDARG;
    }

    //
    // construct the query
    //
    WCHAR szQuery[256];
    LPWSTR szFormat = L"SELECT * FROM RSOP_ExtensionEventSourceLink WHERE extensionStatus=\"RSOP_ExtensionStatus.extensionGuid=\\\"%s\\\"\"";

    wsprintf( szQuery, szFormat, szCSEGuid );

    XBStr bstrLanguage = L"WQL";
    XBStr bstrQuery = szQuery;
    XInterface<IEnumWbemClassObject> pEnum;
    XBStr bstrPath = L"__PATH";
    XBStr bstrEventSource = L"eventSource";

    //
    // search for RSOP_ExtensionEventSourceLink
    //
    hr = pServices->ExecQuery(  bstrLanguage,
                                bstrQuery,
                                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_ENSURE_LOCATABLE,
                                0,
                                &pEnum );
    if ( SUCCEEDED( hr ) )
    {
        DWORD dwReturned = 0;
        do 
        {
            XInterface<IWbemClassObject> xInst;

            hr = pEnum->Next(   WBEM_INFINITE,
                                1,
                                &xInst,
                                &dwReturned );
            if ( SUCCEEDED( hr ) && dwReturned == 1 )
            {
                //
                // delete RSOP_ExtensionEventSource
                //
                VARIANT varSource;
                VariantInit( &varSource );
                XVariant xVarSource( &varSource );

                hr = xInst->Get(bstrEventSource,
                                0,
                                &varSource,
                                0,
                                0 );
                if ( SUCCEEDED( hr ) )
                {
                    hr = pServices->DeleteInstance( varSource.bstrVal,
                                                    0L,
                                                    0,
                                                    0 );
                    if ( SUCCEEDED( hr ) )
                    {
                        //
                        // delete RSOP_ExtensionEventSourceLink
                        //

                        VARIANT varLink;
                        VariantInit( &varLink );
                        hr = xInst->Get(bstrPath,
                                        0L,
                                        &varLink,
                                        0,
                                        0 );
                        if ( SUCCEEDED(hr) )
                        {
                            XVariant xVarLink( &varLink );

                            hr = pServices->DeleteInstance( varLink.bstrVal,
                                                            0L,
                                                            0,
                                                            0 );
                            if ( FAILED( hr ) )
                            {
                                return hr;
                            }
                        }
                    }
                }
            }
        } while ( SUCCEEDED( hr ) && dwReturned == 1 );
    }

    if ( hr == S_FALSE )
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT UpdateGPCoreStatus(IWbemLocator *pWbemLocator,
                           LPWSTR szSid, LPWSTR szNameSpace)
{
    RSOPEXTSTATUS  GPCoreRsopExtStatus;
    BOOL           bMachine = (szSid == NULL);
    XPtrLF<WCHAR>  xszFullNameSpace;
    HRESULT        hr = S_OK;
    LPWSTR         lpEnd = NULL;
    DWORD          dwError = ERROR_SUCCESS;


    xszFullNameSpace = (LPWSTR) LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(szNameSpace)+5+
                                                                (MAX(lstrlen(RSOP_NS_USER_OFFSET), lstrlen(RSOP_NS_MACHINE_OFFSET)))));

    if (!xszFullNameSpace) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg( ( DM_WARNING, L"UpdateGPCoreStatus: failed to allocate memory, 0x%x", hr ) );
        return hr;
    }

    //
    // Construct the namespace
    //

    wcscpy(xszFullNameSpace, szNameSpace);
    lpEnd = CheckSlash(xszFullNameSpace);
    wcscpy(lpEnd, bMachine ? RSOP_NS_MACHINE_OFFSET : RSOP_NS_USER_OFFSET);


    DebugMsg( ( DM_VERBOSE, L"UpdateGPCoreStatus: updating status from <%s> registry for gp core", 
                    bMachine ? RSOP_NS_MACHINE_OFFSET : RSOP_NS_USER_OFFSET) );
    //
    // read the GP Core extension status
    //

    dwError = ReadLoggingStatus(szSid, NULL, &GPCoreRsopExtStatus);

    if (dwError != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(dwError);
    }


    //
    // Get th wbem interface pointer to the namespace constructed
    //

    XInterface<IWbemServices>   xWbemServices;

    hr = GetWbemServicesPtr( xszFullNameSpace, &pWbemLocator, &xWbemServices );

    if (FAILED(hr)) {
        DebugMsg( ( DM_WARNING, L"UpdateGPCoreStatus: GetWbemServicesPtr failed, hr = 0x%x", hr ) );
        return hr;
    }

    GPTEXT_API* pGpText = LoadGpTextApi();

    if ( pGpText )
    {
        hr = pGpText->pfnScrRegGPOListToWbem( szSid, xWbemServices );
        if ( FAILED( hr ) )
        {
            DebugMsg( ( DM_WARNING, L"UpdateGPCoreStatus: ScrRegGPOListToWbem failed, hr = 0x%x", hr ) );
            return hr;
        }
    }

    //
    // Log the data actually
    //

    CExtSessionLogger extLogger( xWbemServices );

    if (!extLogger.Set(NULL, TRUE, &GPCoreRsopExtStatus))
        return E_FAIL;

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\rsop\rsop.h ===
//*************************************************************
//
//  Resultant set of policy
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//  History:    7-Jun-99   SitaramR    Created
//
//*************************************************************

#if defined(__cplusplus)
extern "C"{
#endif

BOOL GetWbemServices( LPGPOINFO lpGPOInfo,
                      WCHAR *pwszRootNameSpace,
                      BOOL bPlanningMode,
                      BOOL *bCreated,
                      IWbemServices **ppWbemServices);

void ReleaseWbemServices( LPGPOINFO lpGPOInfo );

BOOL LogRsopData( LPGPOINFO lpGPOInfo, LPRSOPSESSIONDATA lprsopSessionData );
BOOL LogSessionData( LPGPOINFO lpGPOInfo, LPRSOPSESSIONDATA lprsopSessionData );

BOOL LogRegistryRsopData( DWORD dwFlags, REGHASHTABLE *pHashTable, IWbemServices *pWbemServices );

BOOL LogAdmRsopData( ADMFILEINFO *pAdmFileInfo, IWbemServices *pWbemServices );

BOOL LogExtSessionStatus( IWbemServices *pWbemServices, LPGPEXT lpExt, BOOL bSupported, BOOL bLogEventSrc = TRUE );

BOOL UpdateExtSessionStatus( IWbemServices *pWbemServices, LPTSTR lpKeyName, BOOL bIncomplete, DWORD dwErr );

#if defined(__cplusplus)
}
#endif


BOOL SetRsopTargetName(LPGPOINFO lpGPOInfo);
BOOL RsopDeleteAllValues(HKEY hKey, REGHASHTABLE *pHashTable,
                         WCHAR *lpKeyName, WCHAR *pwszGPO, WCHAR *pwszSOM, WCHAR *szCommand, BOOL *bLoggingOk);

HRESULT GetRsopSchemaVersionNumber(IWbemServices *pWbemServices, DWORD *dwVersionNumber);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\rsop\reghash.cpp ===
//*************************************************************
//
//  Hash table for registry Rsop data
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1999
//  All rights reserved
//
//  History:    7-Jun-99   SitaramR    Created
//
//*************************************************************

#include "uenv.h"
#include "reghash.h"
#include "rsop.h"

REGKEYENTRY * AllocRegKeyEntry( WCHAR *pwszKeyName );
void FreeRegKeyEntry( REGKEYENTRY *pKeyEntry );
REGVALUEENTRY *AllocValueEntry( WCHAR *pwszValueName );
void FreeValueEntry( REGVALUEENTRY *pValueEntry );
REGDATAENTRY * AllocDataEntry( REGOPERATION opnType,
                               DWORD dwType,
                               DWORD dwLen,
                               BYTE *pData,
                               WCHAR *pwszGPO,
                               WCHAR *pwszSOM,
                               WCHAR *pwszCommand);
                               
void FreeDataEntry( REGDATAENTRY *pDataEntry );
BOOL DeleteRegTree( REGHASHTABLE *pHashTable,
                    WCHAR *pwszKeyName,
                    WCHAR *pwszGPO,
                    WCHAR *pwszSOM,
                    WCHAR *szCommand);
REGKEYENTRY * FindRegKeyEntry( REGHASHTABLE *pHashTable,
                               WCHAR *pwszKeyName,
                               BOOL bCreate );
REGVALUEENTRY * FindValueEntry( REGHASHTABLE *pHashTable,
                                WCHAR *pwszKeyName,
                                WCHAR *pwszValueName,
                                BOOL bCreate );
BOOL AddDataEntry( REGVALUEENTRY *pValueEntry,
                   REGOPERATION opnType,
                   DWORD dwType,
                   DWORD dwLen,
                   BYTE *pData,
                   WCHAR *pwszGPO,
                   WCHAR *pwszSOM,
                   WCHAR *pwszCommand);


////////////////////////////////////////////////////////////////////////
// Hash Table for registry policies
// ----------------------------------
//
// This hash table is used to log rsop data for registry policies. 
// A hash table entry is created for each registry entry. The registry entry
// name itself is used to calculate the hash table.
//
// Each Registry entry has a link to each of the values modified by policy.
// These values are in a link list and sorted by the valueNames.
//
// Each Value has the list of Data that are being set on the Values. This 
// sorted by the order of execution. The topmost value will contain the final value.
// The Data entries have fields that mark the value as deleted and the Command 
// associated with the action. To look for the possible commands look in the
// ParseRegistryFile.
// 
// Additionally, in the hash table 2 special case values exist.
//  a.   **Command Value. The Data under this value will contain all the commands 
//                     that are executed under this key.
//
//  b.  An ""(Empty ValueName) This valuename represents the modifications happening
//      to the key itself. For example a key can deleted or added..
//
// Note:
//      The szCommand that is passed in has to be non NULL but can be an empty string.
// There is a dependency on it in AddDataEntry and in logger.cpp. There is an Assert 
// for this in AddRegHashEntry
// 
////////////////////////////////////////////////////////////////////////



//*************************************************************
//
//  AllocHashTable
//
//  Purpose:    Allocates a new hash table
//
//  Returns:    Pointer to hash table
//
//*************************************************************

REGHASHTABLE * AllocHashTable()
{
    DWORD i;

    REGHASHTABLE *pHashTable = (REGHASHTABLE *) LocalAlloc (LPTR, sizeof(REGHASHTABLE));

    if ( pHashTable == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocHashTable: Failed to alloc hashtable.")));
        return NULL;
    }

    for ( i=0; i<HASH_TABLE_SIZE; i++) {
        pHashTable->aHashTable[i] = 0;
    }

    pHashTable->hrError = S_OK;

    return pHashTable;
}



//*************************************************************
//
//  FreeHashTable
//
//  Purpose:    Deletes a hash table
//
//  Parameters: pHashTable   -  Hash table to delete
//
//*************************************************************

void FreeHashTable( REGHASHTABLE *pHashTable )
{
    DWORD i;

    if ( pHashTable == NULL )
        return;

    for ( i=0; i<HASH_TABLE_SIZE; i++ ) {
        REGKEYENTRY *pKeyEntry = pHashTable->aHashTable[i];

        while ( pKeyEntry ) {
            REGKEYENTRY *pNext = pKeyEntry->pNext;
            FreeRegKeyEntry( pKeyEntry );
            pKeyEntry = pNext;
        }
    }
}


//*************************************************************
//
//  AllocRegKey
//
//  Purpose:    Allocates a new registry key entry
//
//  Returns:    Pointer to registr key entry
//
//*************************************************************

REGKEYENTRY * AllocRegKeyEntry( WCHAR *pwszKeyName )
{
    REGKEYENTRY *pKeyEntry = (REGKEYENTRY *) LocalAlloc (LPTR, sizeof(REGKEYENTRY));
    if ( pKeyEntry == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocRegKeyEntry: Failed to alloc key entry.")));
        return NULL;
    }

    pKeyEntry->pwszKeyName = (WCHAR *) LocalAlloc (LPTR, (lstrlen(pwszKeyName) + 1 ) * sizeof(WCHAR));

    if ( pKeyEntry->pwszKeyName == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocRegKeyEntry: Failed to alloc key name.")));
        LocalFree( pKeyEntry );
        return NULL;
    }

    lstrcpy( pKeyEntry->pwszKeyName, pwszKeyName );

    return pKeyEntry;
}


//*************************************************************
//
//  FreeRegKeyEntry
//
//  Purpose:    Deletes a registry key entry
//
//  Parameters: pKeyEntry   -  Entry to delete
//
//*************************************************************

void FreeRegKeyEntry( REGKEYENTRY *pKeyEntry )
{
    REGVALUEENTRY *pValueEntry = NULL;

    if ( pKeyEntry == NULL )
        return;

    LocalFree( pKeyEntry->pwszKeyName );

    pValueEntry = pKeyEntry->pValueList;
    while ( pValueEntry ) {
        REGVALUEENTRY *pNext = pValueEntry->pNext;
        FreeValueEntry( pValueEntry );
        pValueEntry = pNext;
    }

    LocalFree( pKeyEntry );
}


//*************************************************************
//
//  AllocValueEntry
//
//  Purpose:    Allocates a new value entry
//
//  Returns:    Pointer to value entry
//
//*************************************************************

REGVALUEENTRY *AllocValueEntry( WCHAR *pwszValueName )
{
    REGVALUEENTRY *pValueEntry = (REGVALUEENTRY *) LocalAlloc (LPTR, sizeof(REGVALUEENTRY));
    if ( pValueEntry == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocValueEntry: Failed to alloc value entry.")));
        return NULL;
    }

    pValueEntry->pwszValueName = (WCHAR *) LocalAlloc (LPTR, (lstrlen(pwszValueName) + 1 ) * sizeof(WCHAR));

    if ( pValueEntry->pwszValueName == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocValueEntry: Failed to alloc key name.")));
        LocalFree( pValueEntry );
        return NULL;
    }

    lstrcpy( pValueEntry->pwszValueName, pwszValueName );

    return pValueEntry;
}


//*************************************************************
//
//  FreeValueEntry
//
//  Purpose:    Deletes a value entry
//
//  Parameters: pValueEntry   -  Entry to delete
//
//*************************************************************

void FreeValueEntry( REGVALUEENTRY *pValueEntry )
{
    REGDATAENTRY *pDataEntry = NULL;

    if ( pValueEntry == NULL )
        return;

    LocalFree( pValueEntry->pwszValueName );

    pDataEntry = pValueEntry->pDataList;
    while ( pDataEntry ) {
        REGDATAENTRY *pNext = pDataEntry->pNext;
        FreeDataEntry( pDataEntry );
        pDataEntry = pNext;
    }

    LocalFree( pValueEntry );
}



//*************************************************************
//
//  AllocDataEntry
//
//  Purpose:    Allocates a new data entry
//
//  Returns:    Pointer to data entry
//
//*************************************************************

REGDATAENTRY * AllocDataEntry( REGOPERATION opnType,
                               DWORD dwType,
                               DWORD dwLen,
                               BYTE *pData,
                               WCHAR *pwszGPO,
                               WCHAR *pwszSOM,
                               WCHAR *pwszCommand)
{
    BOOL bResult = FALSE;

    REGDATAENTRY *pDataEntry = (REGDATAENTRY *) LocalAlloc (LPTR, sizeof(REGDATAENTRY));
    if ( pDataEntry == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocDataEntry: Failed to alloc data entry.")));
        return NULL;
    }

    if ( opnType == REG_ADDVALUE )
        pDataEntry->bDeleted = FALSE;
    else
        pDataEntry->bDeleted = TRUE;

    pDataEntry->bAdmPolicy = FALSE;
    pDataEntry->dwValueType = dwType;
    pDataEntry->dwDataLen = dwLen;

    if ( pData ) {
        pDataEntry->pData = (BYTE *) LocalAlloc (LPTR, dwLen);
        if ( pDataEntry->pData == NULL ) {
            DebugMsg((DM_WARNING, TEXT("AllocDataEntry: Failed to alloc data.")));
            goto Exit;
        }

        CopyMemory( pDataEntry->pData, pData, dwLen );
    }

    DmAssert( pwszGPO != NULL && pwszSOM != NULL );

    pDataEntry->pwszGPO = (WCHAR *) LocalAlloc (LPTR, (lstrlen(pwszGPO) + 1 ) * sizeof(WCHAR));

    if ( pDataEntry->pwszGPO == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocDataEntry: Failed to alloc Gpo name.")));
        goto Exit;
    }

    lstrcpy( pDataEntry->pwszGPO, pwszGPO );

    pDataEntry->pwszSOM = (WCHAR *) LocalAlloc (LPTR, (lstrlen(pwszSOM) + 1 ) * sizeof(WCHAR));

    if ( pDataEntry->pwszSOM == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocDataEntry: Failed to alloc Sdou name.")));
        goto Exit;
    }

    lstrcpy( pDataEntry->pwszSOM, pwszSOM );

    pDataEntry->pwszCommand = (WCHAR *) LocalAlloc (LPTR, (lstrlen(pwszCommand) + 1 ) * sizeof(WCHAR));

    if ( pDataEntry->pwszCommand == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocDataEntry: Failed to alloc Sdou name.")));
        goto Exit;
    }

    lstrcpy( pDataEntry->pwszCommand, pwszCommand );

    bResult = TRUE;

Exit:

    if ( !bResult ) {
        LocalFree( pDataEntry->pData );
        LocalFree( pDataEntry->pwszGPO );
        LocalFree( pDataEntry->pwszSOM );
        if (pDataEntry->pwszCommand)
            LocalFree(pDataEntry->pwszCommand);
        LocalFree( pDataEntry);
        return NULL;
    }

    return pDataEntry;

}


//*************************************************************
//
//  FreeDataEntry
//
//  Purpose:    Deletes a data entry
//
//  Parameters: pDataEntry   -  Entry to delete
//
//*************************************************************

void FreeDataEntry( REGDATAENTRY *pDataEntry )
{
    if ( pDataEntry ) {
        LocalFree( pDataEntry->pData );
        LocalFree( pDataEntry->pwszGPO );
        LocalFree( pDataEntry->pwszSOM );
        LocalFree( pDataEntry);
    }
}



//*************************************************************
//
//  Hash
//
//  Purpose:    Maps a key name to a hash bucket
//
//  Parameters: pwszName   -  Key name
//
//  Returns:    Hash bucket
//
//*************************************************************

DWORD Hash( WCHAR *pwszName )
{
    DWORD dwLen = lstrlen( pwszName );
    DWORD dwHashValue = 0;

    for ( ; dwLen>0; pwszName++ ) {
        dwHashValue = toupper(*pwszName) + 31 * dwHashValue;
        dwLen--;
    }

    return dwHashValue % HASH_TABLE_SIZE;
}


//*************************************************************
//
//  AddRegHashEntry
//
//  Purpose:    Adds a registry key to the hash table
//
//  Parameters: pwszName   -  Key name
//
//*************************************************************

BOOL AddRegHashEntry( REGHASHTABLE *pHashTable,
                      REGOPERATION opnType,
                      WCHAR *pwszKeyName,
                      WCHAR *pwszValueName,
                      DWORD dwType,
                      DWORD dwDataLen,
                      BYTE *pData,
                      WCHAR *pwszGPO,
                      WCHAR *pwszSOM,
                      WCHAR *szCommand,
                      BOOL   bCreateCommand)
{
    REGVALUEENTRY *pValueEntry = NULL;
    BOOL bResult = FALSE;
    REGKEYENTRY *pKeyEntry=NULL;
    
    
    switch (opnType) {

    case REG_DELETEKEY:
        bResult = DeleteRegTree( pHashTable, pwszKeyName, pwszGPO, pwszSOM, szCommand );
        break;
        
    case REG_INTERNAL_DELETESINGLEKEY:
    case REG_DELETEALLVALUES:
    
        pKeyEntry = FindRegKeyEntry( pHashTable,
                                     pwszKeyName,
                                     FALSE );
        if ( pKeyEntry == NULL ) {

            //
            // Delete all values is similar to policy being disabled and
            // so do nothing. 
            //

            if (opnType == REG_DELETEALLVALUES) {
                bResult = TRUE;
                break;
            }
            else
                // no command entry in this case.
                return TRUE;
        }

        pValueEntry = pKeyEntry->pValueList;
        while ( pValueEntry ) {

            if (lstrcmp(pValueEntry->pwszValueName, TEXT("")) != 0) {

                if (lstrcmpi(pValueEntry->pwszValueName, STARCOMMAND) != 0) {
                

                    //
                    // Mark the value as deleted
                    //
                    
                    bResult = AddDataEntry( pValueEntry, opnType, 0, 0, NULL,
                                            pwszGPO, pwszSOM, szCommand );
                    if ( !bResult )
                        return FALSE;
                }
            }
            else {

                //
                // Mark the key as deleted
                //
                
                if (opnType == REG_INTERNAL_DELETESINGLEKEY) {
                    bResult = AddDataEntry( pValueEntry, opnType, 0, 0, NULL,
                                            pwszGPO, pwszSOM, szCommand );
                    if ( !bResult )
                        return FALSE;
                }                        
            }
            
            pValueEntry = pValueEntry->pNext;
        }

        bResult = TRUE;

        break;
        
    case REG_ADDVALUE:
    case REG_SOFTADDVALUE:

        //
        // We have to make a value with no name to represent the creation of key itself..
        //
    
        pValueEntry = FindValueEntry( pHashTable, pwszKeyName,
                                      TEXT(""), TRUE );
        if ( pValueEntry == NULL )
            return FALSE;

        bResult = AddDataEntry( pValueEntry, opnType, 0, 0, NULL,
                                pwszGPO, pwszSOM, szCommand );


        if (!bResult)
            return FALSE;
            
        if ((!pwszValueName) || (!(*pwszValueName)) || 
                (dwDataLen == 0) || (dwType == REG_NONE)) 
            break;                                

    // fall through
    
    case REG_DELETEVALUE:
        pValueEntry = FindValueEntry( pHashTable, pwszKeyName,
                                      pwszValueName, TRUE );
        if ( pValueEntry == NULL )
            return FALSE;


        //
        // In case of SOFTADDVALUE the final decision to add the value is made in
        // AddDataEntry
        //
        
        bResult = AddDataEntry( pValueEntry, opnType, dwType, dwDataLen, pData,
                                pwszGPO, pwszSOM, szCommand );

        break;
    default:
        DmAssert(FALSE && "Unknown Case Selector for AddRegHashEntry");
    }


    DmAssert(szCommand);

    //
    // If everything succeeded, then log the command if
    // bCreateCommand is true. This is done creating or adding
    // to a value called **Command. This means that this value is not
    // Settable by adm file..
    //
    
    if ((bResult) && (bCreateCommand) && (opnType != REG_INTERNAL_DELETESINGLEKEY) && (*szCommand != TEXT('\0'))) {
        pValueEntry = FindValueEntry( pHashTable, pwszKeyName,
                                      STARCOMMAND, TRUE );
                                      
        if ( pValueEntry == NULL )
            return FALSE;

        bResult = AddDataEntry( pValueEntry, REG_ADDVALUE, 0, 
                                sizeof(TCHAR)*(lstrlen(szCommand)+1), (BYTE *)szCommand,
                                pwszGPO, pwszSOM, szCommand);    
    }


    return bResult;
}


//*************************************************************
//
//  DeleteRegTree
//
//  Purpose:    Deletes a key and all its subkeys
//
//  Parameters: pHashTable   -   Hash table
//              pwszKeyName  -   Key name to delete
//              pwszGPO      -   Gpo
//              pwszSOM      -   Sdou that the Gpo is linked to
//
//*************************************************************

BOOL DeleteRegTree( REGHASHTABLE *pHashTable,
                    WCHAR *pwszKeyName,
                    WCHAR *pwszGPO,
                    WCHAR *pwszSOM,
                    WCHAR *szCommand)
{
    DWORD i=0;
    DWORD dwKeyLen = lstrlen( pwszKeyName );

    for ( i=0; i<HASH_TABLE_SIZE; i++ ) {

        REGKEYENTRY *pKeyEntry = pHashTable->aHashTable[i];
        while ( pKeyEntry ) {

            BOOL bAdd = FALSE;
            DWORD dwKeyLen2  = lstrlen(pKeyEntry->pwszKeyName);

            if ( dwKeyLen2 >= dwKeyLen
                 && CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                   pKeyEntry->pwszKeyName, dwKeyLen,
                                   pwszKeyName, dwKeyLen ) == CSTR_EQUAL) {

                //
                // It's a prefix if length and strings match, or if one
                // string is bigger and there is a '\' at the right place.
                //

                if ( dwKeyLen2 > dwKeyLen ) {

                    if ( pKeyEntry->pwszKeyName[dwKeyLen] == L'\\' ) 
                        bAdd = TRUE;
                } else
                    bAdd = TRUE;

                if ( bAdd ) {
                    BOOL bResult = AddRegHashEntry( pHashTable,
                                                    REG_INTERNAL_DELETESINGLEKEY,
                                                    pKeyEntry->pwszKeyName,
                                                    NULL, 0, 0, NULL,
                                                    pwszGPO, pwszSOM, szCommand, FALSE );
                    if ( !bResult )
                        return FALSE;
                }

            }   // if dwKeyLen2 >= dwKeyLen

            pKeyEntry = pKeyEntry->pNext;

        }   // while

    }   // for

    return TRUE;
}


//*************************************************************
//
//  FindRegKeyEntry
//
//  Purpose:    Looks up a reg key entry in hash table
//
//  Parameters: pHashTable   -   Hash table
//              pwszKeyName  -   Key name to find
//              bCreate      -   Should key be created if not found ?
//
//*************************************************************

REGKEYENTRY * FindRegKeyEntry( REGHASHTABLE *pHashTable,
                               WCHAR *pwszKeyName,
                               BOOL bCreate )
{
    DWORD dwHashValue = Hash( pwszKeyName );
    REGKEYENTRY *pCurPtr = pHashTable->aHashTable[dwHashValue];
    REGKEYENTRY *pTrailPtr = NULL;

    while ( pCurPtr != NULL ) {

        INT iResult = CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                     pwszKeyName, -1,
                                     pCurPtr->pwszKeyName, -1 );

        if ( iResult  == CSTR_EQUAL ) {
            return pCurPtr;
        } else if ( iResult == CSTR_LESS_THAN ) {

            //
            // Keys are in ascending order, so insert if bCreate
            //

            if ( bCreate ) {

                REGKEYENTRY *pKeyEntry = AllocRegKeyEntry( pwszKeyName );
                if ( pKeyEntry == NULL )
                    return 0;

                pKeyEntry->pNext = pCurPtr;
                if ( pTrailPtr == NULL )
                    pHashTable->aHashTable[dwHashValue] = pKeyEntry;
                else
                    pTrailPtr->pNext = pKeyEntry;

                return pKeyEntry;

            } else
                return NULL;

        } else {

            //
            // Advance down the list
            //

            pTrailPtr = pCurPtr;
            pCurPtr = pCurPtr->pNext;

        }

    }

    //
    // End of list or null list case
    //

    if ( bCreate ) {
        REGKEYENTRY *pKeyEntry = AllocRegKeyEntry( pwszKeyName );
        if ( pKeyEntry == NULL )
            return 0;

        pKeyEntry->pNext = 0;
        if ( pTrailPtr == NULL )
            pHashTable->aHashTable[dwHashValue] = pKeyEntry;
        else
            pTrailPtr->pNext = pKeyEntry;

        return pKeyEntry;
    }

    return NULL;
}


//*************************************************************
//
//  FindValueEntry
//
//  Purpose:    Looks up a value entry in hash table
//
//  Parameters: pHashTable    -   Hash table
//              pwszKeyName   -   Key name to find
//              pwszValueName -   Value name to find
//              bCreate       -   Should key be created if not found ?
//
//*************************************************************

REGVALUEENTRY * FindValueEntry( REGHASHTABLE *pHashTable,
                                WCHAR *pwszKeyName,
                                WCHAR *pwszValueName,
                                BOOL bCreate )
{
    REGVALUEENTRY *pCurPtr = NULL;
    REGVALUEENTRY *pTrailPtr = NULL;

    REGKEYENTRY *pKeyEntry = FindRegKeyEntry( pHashTable, pwszKeyName, bCreate );
    if ( pKeyEntry == NULL )
        return NULL;

    pCurPtr = pKeyEntry->pValueList;
    pTrailPtr = NULL;

    while ( pCurPtr != NULL ) {

        INT iResult = CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                     pwszValueName, -1,
                                     pCurPtr->pwszValueName, -1 );

        if ( iResult  == CSTR_EQUAL ) {
            return pCurPtr;
        } else if ( iResult == CSTR_LESS_THAN ) {

            //
            // Keys are in ascending order, so insert if bCreate
            //

            if ( bCreate ) {

                REGVALUEENTRY *pValueEntry = AllocValueEntry( pwszValueName );
                if ( pValueEntry == NULL )
                    return 0;

                pValueEntry->pNext = pCurPtr;
                if ( pTrailPtr == NULL )
                    pKeyEntry->pValueList = pValueEntry;
                else
                    pTrailPtr->pNext = pValueEntry;

                return pValueEntry;

            } else
                return NULL;

        } else {

            //
            // Advance down the list
            //

            pTrailPtr = pCurPtr;
            pCurPtr = pCurPtr->pNext;

        }

    }

    //
    // End of list or null list case
    //

    if ( bCreate ) {

        REGVALUEENTRY *pValueEntry = AllocValueEntry( pwszValueName );
        if ( pValueEntry == NULL )
            return 0;

        pValueEntry->pNext = 0;
        if ( pTrailPtr == NULL )
            pKeyEntry->pValueList = pValueEntry;
        else
            pTrailPtr->pNext = pValueEntry;

        return pValueEntry;
    }

    return NULL;
}



//*************************************************************
//
//  AddDataEntry
//
//  Purpose:    Adds a data entry to a value entry struct
//
//  Parameters: pValueEntry   - Value entry
//              opnType       - Operation type
//              dwType        - Type of registry data
//              dwLen         - Length of registry data
//              pData         - Data
//              pwszGPO       - Gpo that set this value
//              pwszSOM       - Sdou that the Gpo is linked to
//
//*************************************************************

BOOL AddDataEntry( REGVALUEENTRY *pValueEntry,
                   REGOPERATION opnType,
                   DWORD dwType,
                   DWORD dwLen,
                   BYTE *pData,
                   WCHAR *pwszGPO,
                   WCHAR *pwszSOM,
                   WCHAR *pwszCommand)
{
    REGDATAENTRY *pDataEntry = NULL; 

    if (opnType == REG_SOFTADDVALUE) {

        //
        // if the data list is null or if the first value (highest precedence value is deleted)
        // then add it to the list
        //
        
        if ((pValueEntry->pDataList == NULL) || (pValueEntry->pDataList->pNext->bDeleted))         
            opnType = REG_ADDVALUE;
        else
            return TRUE;
            // return without adding the value.
    }


    pDataEntry = AllocDataEntry( opnType, dwType, dwLen, pData,
                                               pwszGPO, pwszSOM, pwszCommand );
    if ( pDataEntry == NULL )
        return FALSE;
    
    //
    // Prepend to data list because entries at beginning of list have higher precedence
    //

    pDataEntry->pNext = pValueEntry->pDataList;
    pValueEntry->pDataList = pDataEntry;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\copydir\generic.c ===
/****************************************************************************

        PROGRAM: Generic.c

        PURPOSE: Generic template for Windows applications

****************************************************************************/

#include <windows.h>
#include <userenv.h>
#include <userenvp.h>
#include "generic.h"


HINSTANCE hInst;
HWND      hwndMain;
HANDLE    hProfile, hUserToken;

TCHAR szAppName[] = TEXT("Generic");
#ifdef UNICODE
TCHAR szTitle[]   = TEXT("UserEnv Profile Test App - UNICODE");
#else
TCHAR szTitle[]   = TEXT("UserEnv Profile Test App - ANSI");
#endif


TCHAR szSrcDir[MAX_PATH];
TCHAR szDestDir[MAX_PATH];
TCHAR szProfilePath[MAX_PATH];
TCHAR szDefaultPath[MAX_PATH];
TCHAR szUserName[MAX_PATH];
TCHAR szDomainName[MAX_PATH];

void ChangeMenuState (BOOL bLoggedOn);
BOOL GetProfileType(DWORD *flags);

/****************************************************************************

        FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)

        PURPOSE: calls initialization function, processes message loop

****************************************************************************/
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine, INT nCmdShow)
{
        MSG msg;
        HANDLE hAccelTable;

        if (!hPrevInstance)
           {
           if (!InitApplication(hInstance))
              {
              return (FALSE);
              }
           }


        // Perform initializations that apply to a specific instance
        if (!InitInstance(hInstance, nCmdShow))
           {
           return (FALSE);
           }

        hAccelTable = LoadAccelerators (hInstance, szAppName);

        while (GetMessage(&msg, NULL, 0, 0))
           {
           if (!TranslateAccelerator (msg.hwnd, hAccelTable, &msg))
              {
              TranslateMessage(&msg);
              DispatchMessage(&msg);
              }
           }


        return (msg.wParam);

        lpCmdLine;
}


/****************************************************************************

        FUNCTION: InitApplication(HINSTANCE)

        PURPOSE: Initializes window data and registers window class

****************************************************************************/

BOOL InitApplication(HINSTANCE hInstance)
{
        WNDCLASS  wc;

        wc.style         = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc   = (WNDPROC)WndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;
        wc.hInstance     = hInstance;
        wc.hIcon         = LoadIcon (hInstance, szAppName);
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wc.lpszMenuName  = szAppName;
        wc.lpszClassName = szAppName;

        return (RegisterClass(&wc));
}


/****************************************************************************

        FUNCTION:  InitInstance(HINSTANCE, int)

        PURPOSE:  Saves instance handle and creates main window

****************************************************************************/

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
        HWND  hWnd;

        hInst = hInstance;
        hProfile = NULL;

        szSrcDir[0] = TEXT('\0');
        szDestDir[0] = TEXT('\0');
        szProfilePath[0] = TEXT('\0');
        szDefaultPath[0] = TEXT('\0');
        szUserName[0] = TEXT('\0');
        szDomainName[0] = TEXT('\0');

        hWnd = CreateWindow(szAppName,
                            szTitle,
                            WS_OVERLAPPEDWINDOW,
                            CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
                            NULL,
                            NULL,
                            hInstance,
                            NULL);

        if (!hWnd)
           {
           return (FALSE);
           }
        else
          {
          hwndMain = hWnd;
          }

        ChangeMenuState(FALSE);
        PostMessage (hWnd, WM_COMMAND, IDM_LOGON, 0);

        ShowWindow(hWnd, SW_SHOWDEFAULT);
        UpdateWindow(hWnd);

        return (TRUE);

}

/****************************************************************************

        FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)

        PURPOSE:  Processes messages

****************************************************************************/

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        DWORD dwFlags;
        TCHAR szBuffer[MAX_PATH];

        switch (message)
           {
           case WM_COMMAND:
              {
              switch (LOWORD(wParam))
                 {
                 case IDM_LOGON:
                    if (DialogBox (hInst, TEXT("LOGONDLG"), hWnd, LogonDlgProc)) {
                        ChangeMenuState(TRUE);
                    }
                    break;

                 case IDM_LOGOFF:
                    CloseHandle(hUserToken);
                    ChangeMenuState(FALSE);
                    break;

                 case IDM_LUP:
                    DialogBox (hInst, TEXT("LUPDLG"), hWnd, LUPDlgProc);
                    break;

                 case IDM_ULUP:
                    if (hProfile) {
                        if (UnloadUserProfile(hUserToken, hProfile)) {
                            hProfile = NULL;
                        }
                    }
                    break;

                 case IDM_PFTYPE:
                    if (hUserToken) {
                        if (!ImpersonateLoggedOnUser(hUserToken)) {
                            wsprintf(szBuffer, TEXT("Impersonate Failed with Error %d"), GetLastError());
                            MessageBox (hWnd, szBuffer, TEXT("Impersonate"), MB_OK | MB_ICONEXCLAMATION);
                            return TRUE;
                        }

                        if (GetProfileType(&dwFlags)) {
                        }

                        RevertToSelf();
                    }
                    break;

                 case IDM_ABOUT:
                    DialogBox (hInst, TEXT("AboutBox"), hWnd, About);
                    break;

                 case IDM_EXIT:
                    DestroyWindow (hwndMain);
                    break;


                 default:
                    return (DefWindowProc(hWnd, message, wParam, lParam));
                 }
              }
              break;

           case WM_DESTROY:
              if (hProfile) {
                  if (UnloadUserProfile(hUserToken, hProfile)) {
                      hProfile = NULL;
                  }
              }

              PostQuitMessage(0);
              break;

           default:
              return (DefWindowProc(hWnd, message, wParam, lParam));
           }

        return FALSE;
}

/****************************************************************************

        FUNCTION: About(HWND, UINT, WPARAM, LPARAM)

        PURPOSE:  Processes messages for "About" dialog box

****************************************************************************/

LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

        switch (message)
           {
           case WM_COMMAND:
              if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
                 {
                 EndDialog(hDlg, TRUE);
                 return (TRUE);
                 }
              break;
           }

        return (FALSE);

        lParam;
}


/****************************************************************************

        FUNCTION: LUPDlgProc(HWND, UINT, WPARAM, LPARAM)

****************************************************************************/

LRESULT CALLBACK LUPDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

        switch (message)
           {
           case WM_INITDIALOG:
              SetDlgItemText(hDlg, IDD_PROFILEPATH, szProfilePath);
              SetDlgItemText(hDlg, IDD_DEFAULTPATH, szDefaultPath);
              SetFocus (GetDlgItem (hDlg, IDD_PROFILEPATH));

              return FALSE;

           case WM_COMMAND:
              if (LOWORD(wParam) == IDOK)
                  {
                  PROFILEINFO pi;
                  DWORD dwStart, dwEnd, dwFlags = 0;
                  TCHAR szBuffer[200];
                  HCURSOR hCursor;
                  BOOL bResult;

                  SetDlgItemText(hDlg, IDD_RETVAL, NULL);
                  SetDlgItemText(hDlg, IDD_TIME, NULL);
                  SetDlgItemText(hDlg, IDD_PROFILE, NULL);


                  GetDlgItemText(hDlg, IDD_PROFILEPATH, szProfilePath, MAX_PATH);
                  GetDlgItemText(hDlg, IDD_DEFAULTPATH, szDefaultPath, MAX_PATH);

                  if (IsDlgButtonChecked(hDlg, IDD_NOUI)) {
                    dwFlags |= PI_NOUI;
                  }

                  if (IsDlgButtonChecked(hDlg, IDD_APPLYPOLICY)) {
                    dwFlags |= PI_APPLYPOLICY;
                    pi.lpPolicyPath = TEXT("ntconfig.pol");
                  }

                  if (IsDlgButtonChecked(hDlg, IDD_LITELOAD)) {
                    dwFlags |= PI_LITELOAD;
                  }

                  pi.dwSize = sizeof(PROFILEINFO);
                  pi.dwFlags = dwFlags;
                  pi.lpUserName = szUserName;
                  pi.lpProfilePath = szProfilePath;
                  pi.lpDefaultPath = szDefaultPath;
                  pi.lpServerName = NULL;

                  hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

                  dwStart = GetTickCount();
                  bResult = LoadUserProfile(hUserToken, &pi);
                  dwEnd = GetTickCount();

                  SetCursor(hCursor);

                  SetDlgItemInt(hDlg, IDD_TIME, dwEnd - dwStart, FALSE);
                  SetDlgItemInt(hDlg, IDD_RETVAL, bResult, FALSE);

                  if (bResult) {
                      hProfile = pi.hProfile;

                      wsprintf (szBuffer, TEXT("0x%x"), pi.hProfile);
                      SetDlgItemText(hDlg, IDD_PROFILE, szBuffer);
                  }

                  }

              if (LOWORD(wParam) == IDCANCEL)
                 {
                 EndDialog(hDlg, TRUE);
                 return (TRUE);
                 }

              break;
           }

        return (FALSE);
}


void ChangeMenuState (BOOL bLoggedOn)
{
    HMENU hMenu;


    hMenu = GetMenu(hwndMain);

    if (bLoggedOn) {

        EnableMenuItem (hMenu, IDM_LOGON, MF_BYCOMMAND | MF_GRAYED);


        EnableMenuItem (hMenu, IDM_LOGOFF, MF_BYCOMMAND | MF_ENABLED);
        EnableMenuItem (hMenu, IDM_LUP, MF_BYCOMMAND | MF_ENABLED);
        EnableMenuItem (hMenu, IDM_ULUP, MF_BYCOMMAND | MF_ENABLED);

    } else {

        EnableMenuItem (hMenu, IDM_LOGOFF, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem (hMenu, IDM_LUP, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem (hMenu, IDM_ULUP, MF_BYCOMMAND | MF_GRAYED);

        EnableMenuItem (hMenu, IDM_LOGON, MF_BYCOMMAND | MF_ENABLED);
    }

}

/****************************************************************************

        FUNCTION: LogonDlgProc(HWND, UINT, WPARAM, LPARAM)

****************************************************************************/

LRESULT CALLBACK LogonDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

        switch (message)
           {
           case WM_INITDIALOG:
              {
              HBITMAP hBmp;

              hBmp = LoadBitmap (hInst, TEXT("Logo"));

              if (hBmp) {
                 SendDlgItemMessage (hDlg, IDD_ICON, STM_SETIMAGE,
                                     IMAGE_BITMAP, (LPARAM) hBmp);
              }
              SetDlgItemText(hDlg, IDD_USERNAME, szUserName);
              SetDlgItemText(hDlg, IDD_DOMAIN, szDomainName);
              }
              return TRUE;

           case WM_COMMAND:
              if (LOWORD(wParam) == IDOK)
                  {
                  TCHAR szPassword[MAX_PATH];

                  GetDlgItemText(hDlg, IDD_USERNAME, szUserName, MAX_PATH);
                  GetDlgItemText(hDlg, IDD_DOMAIN,   szDomainName, MAX_PATH);
                  GetDlgItemText(hDlg, IDD_PASSWORD, szPassword, MAX_PATH);

                  if (LogonUser(szUserName, szDomainName, szPassword,
                                LOGON32_LOGON_INTERACTIVE,
                                LOGON32_PROVIDER_DEFAULT,
                                &hUserToken)) {
                      EndDialog(hDlg, TRUE);
                      return TRUE;

                  } else {
                      TCHAR szBuffer[200];

                      wsprintf(szBuffer, TEXT("Logon Failed with Error %d"),
                               GetLastError());
                      MessageBox (hDlg, szBuffer, TEXT("Logon"), MB_OK | MB_ICONEXCLAMATION);
                      return TRUE;
                  }

                  }

              if (LOWORD(wParam) == IDCANCEL)
                 {
                 EndDialog(hDlg, FALSE);
                 return TRUE;
                 }

              break;
           }

        return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\copydir\generic.h ===
#define IDM_CPD              100
#define IDM_EXIT             101
#define IDM_ABOUT            102
#define IDM_LUP              103
#define IDM_ULUP             104
#define IDM_LOGON            105
#define IDM_LOGOFF           106
#define IDM_PFTYPE           107

#define IDD_PROFILEPATH      601
#define IDD_KEYNAMEBOX       602
#define IDD_KEYNAME          603
#define IDD_TIME             605
#define IDD_PROFILE          606
#define IDD_TIME_TEXT        607
#define IDD_PROFILE_TEXT     608
#define IDD_DEFAULTPATH      609
#define IDD_RETVAL           610
#define IDD_NOUI             611
#define IDD_APPLYPOLICY      612
#define IDD_LITELOAD         613

#define IDD_USERNAME         700
#define IDD_DOMAIN           701
#define IDD_PASSWORD         702
#define IDD_ICON             703

BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK About  (HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK LUPDlgProc  (HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK LogonDlgProc(HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\debug\debug.c ===
//*************************************************************
//
//  Debug.c     -   Debugging utility for User Environments
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntexapi.h>
#include "debug.h"


int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine, INT nCmdShow)
{

    DialogBox (hInstance, TEXT("DEBUG"), NULL, DebugDlgProc);

    return 0;

}

BOOL CALLBACK DebugDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    switch (uMsg) {

        case WM_INITDIALOG:
            {
            HKEY hKey;
            LONG lResult;
            DWORD dwButton = IDD_NORMAL;
            DWORD dwType, dwSize, dwValue;

            lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                   WINLOGON_KEY,
                                   0,
                                   KEY_READ,
                                   &hKey);

            if (lResult == ERROR_SUCCESS) {

                dwSize = sizeof(dwValue);
                lResult = RegQueryValueEx(hKey,
                                          USERENV_DEBUG_LEVEL,
                                          NULL,
                                          &dwType,
                                          (LPBYTE)&dwValue,
                                          &dwSize);

                if (lResult == ERROR_SUCCESS) {

                    if (LOWORD(dwValue) == DL_NONE) {
                        dwButton = IDD_NONE;
                    } else if (LOWORD(dwValue) == DL_VERBOSE) {
                        dwButton = IDD_VERBOSE;
                    }

                }

                RegCloseKey(hKey);
            }

            CheckRadioButton (hDlg, IDD_NONE, IDD_VERBOSE, dwButton);

            if (dwValue & DL_LOGFILE) {
                CheckDlgButton (hDlg, IDD_LOGFILE, 1);
            }


            //
            // Now check for winlogon
            //

            dwButton = 0;
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                   EXEC_OPTIONS_KEY,
                                   0,
                                   KEY_READ,
                                   &hKey) == ERROR_SUCCESS) {

                dwButton = 1;
                RegCloseKey(hKey);
            }

            CheckDlgButton (hDlg, IDD_WINLOGON, dwButton);

            }
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    {
                    HKEY hKey;
                    LONG lResult;
                    DWORD dwType, dwValue = DL_NORMAL;
                    DWORD dwButton, dwSize, dwDisp;

                    if (IsDlgButtonChecked(hDlg, IDD_NONE)) {
                        dwValue = DL_NONE;
                    } else if (IsDlgButtonChecked(hDlg, IDD_VERBOSE)) {
                        dwValue = (DL_VERBOSE | DL_DEBUGGER);
                    }

                    if (IsDlgButtonChecked(hDlg, IDD_LOGFILE)) {
                        dwValue |= DL_LOGFILE;
                    }

                    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                           WINLOGON_KEY,
                                           0,
                                           KEY_WRITE,
                                           &hKey);

                    if (lResult == ERROR_SUCCESS) {

                        lResult = RegSetValueEx(hKey,
                                                USERENV_DEBUG_LEVEL,
                                                0,
                                                REG_DWORD,
                                                (LPBYTE)&dwValue,
                                                sizeof(dwValue));

                        if (lResult != ERROR_SUCCESS) {
                            MessageBox(hDlg, TEXT("Failed to save settings."), NULL, MB_OK);
                        }

                        RegCloseKey(hKey);
                    }


                    //
                    // Debug output for winlogon / msgina
                    //

                    if (dwValue & DL_VERBOSE) {

                        WriteProfileString (TEXT("Winlogon"),
                                            TEXT("DebugFlags"),
                                            TEXT("Error,Warning,Trace,Init,Timeout,Sas,State,CoolSwitch,Profile,Notify,Job"));

                        WriteProfileString (TEXT("Winlogon"),
                                            TEXT("EnableDesktopSwitching"),
                                            TEXT("1"));

                        WriteProfileString (TEXT("MSGina"),
                                            TEXT("DebugFlags"),
                                            TEXT("Error,Warning,Trace,Domain,Cache"));

                    } else {

                        WriteProfileString (TEXT("Winlogon"),
                                            TEXT("DebugFlags"),
                                            NULL);

                        WriteProfileString (TEXT("Winlogon"),
                                            TEXT("EnableDesktopSwitching"),
                                            NULL);

                        WriteProfileString (TEXT("MSGina"),
                                            TEXT("DebugFlags"),
                                            NULL);
                    }



                    //
                    // Now check for winlogon
                    //

                    if (IsDlgButtonChecked(hDlg, IDD_WINLOGON)) {

                        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                           EXEC_OPTIONS_KEY,
                                           0,
                                           NULL,
                                           REG_OPTION_NON_VOLATILE,
                                           KEY_ALL_ACCESS,
                                           NULL,
                                           &hKey,
                                           &dwDisp) == ERROR_SUCCESS) {

                            RegSetValueEx (hKey,
                                           TEXT("Debugger"),
                                           0, REG_SZ,
                                           (LPBYTE) TEXT("ntsd -d -G"),
                                           16);

                            RegCloseKey (hKey);
                        }

                    } else {
                        RegDeleteKey (HKEY_LOCAL_MACHINE,
                                      EXEC_OPTIONS_KEY);
                    }

                    EndDialog(hDlg, FALSE);
                    return TRUE;
                    }

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return TRUE;

            }
            break;

        default:
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\createadt\createadt.c ===
#include <windows.h>
#include <tchar.h>
#include <stdio.h>

TCHAR szADT[MAX_PATH];

BOOL ParseCommandLine (int argc, char *argv[]);
UINT CreateNestedDirectory(LPCTSTR lpDirectory);
LPTSTR CheckSlash (LPTSTR lpDir);


int __cdecl main( int argc, char *argv[])
{
    LPTSTR lpEnd, lpRoot;
    HANDLE hFile;
    INT i;

    if (!ParseCommandLine (argc, argv)) {
        return 1;
    }

    if (!CreateNestedDirectory (szADT)) {
        return 1;
    }


    lpRoot = CheckSlash (szADT);

    lstrcpy (lpRoot, TEXT("GPT.ini"));
    if (!WritePrivateProfileString (TEXT("General"),
                                    TEXT("GUID"),
                                    TEXT("<GUID goes here>"),
                                    szADT)) {
        return 1;
    }

    if (!WritePrivateProfileString (TEXT("General"),
                                    TEXT("Class Store"),
                                    TEXT(" <Path to a Class Store goes here>"),
                                    szADT)) {
        return 1;
    }

    *(lpRoot - 1) = TEXT('\0');

    for (i=0; i < 2; i++ ) {

        lpRoot = CheckSlash (szADT);

        if (i == 0) {
            lstrcpy (lpRoot, TEXT("User"));
        } else {
            lstrcpy (lpRoot, TEXT("Machine"));
        }

        lpEnd = CheckSlash (szADT);

        lstrcpy (lpEnd, TEXT("Applications\\Assigned\\Alpha"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Applications\\Assigned\\x86\\WinNT"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Applications\\Assigned\\x86\\Win95"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }


        lstrcpy (lpEnd, TEXT("Applications\\Published\\Alpha"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Applications\\Published\\x86\\WinNT"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Applications\\Published\\x86\\Win95"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }


        if (i > 0) {
            lstrcpy (lpEnd, TEXT("OS Upgrades"));
            if (!CreateNestedDirectory (szADT)) {
                return 1;
            }
        }

        lstrcpy (lpEnd, TEXT("Profile"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Power Schemes"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }


        lstrcpy (lpEnd, TEXT("Scripts"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Registry.txt"));
        hFile = CreateFile (szADT, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle (hFile);
        }


        lstrcpy (lpEnd, TEXT("Profile"));
        lpEnd = CheckSlash (szADT);

        lstrcpy (lpEnd, TEXT("Application Data"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Desktop\\My Documents"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Favorites"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("NetHood"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("PrintHood"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Recent"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("SendTo"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Templates"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Start Menu\\Programs\\Startup"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        if (i == 0) {
            lstrcpy (lpRoot, TEXT("User\\Scripts\\Scripts.ini"));
         } else {
            lstrcpy (lpRoot, TEXT("Machine\\Scripts\\Scripts.ini"));
         }

        if (i == 0) {
            if (!WritePrivateProfileString (TEXT("Logon"),
                                            TEXT("CommandLine"),
                                            TEXT(" <Command line goes here>"),
                                            szADT)) {
                return 1;
            }

            if (!WritePrivateProfileString (TEXT("Logoff"),
                                            TEXT("CommandLine"),
                                            TEXT(" <Command line goes here>"),
                                            szADT)) {
                return 1;
            }
        } else {
            if (!WritePrivateProfileString (TEXT("Boot"),
                                            TEXT("CommandLine"),
                                            TEXT(" <Command line goes here>"),
                                            szADT)) {
                return 1;
            }

            if (!WritePrivateProfileString (TEXT("Shutdown"),
                                            TEXT("CommandLine"),
                                            TEXT(" <Command line goes here>"),
                                            szADT)) {
                return 1;
            }
        }


        *(lpRoot - 1) = TEXT('\0');
    }

    _tprintf (TEXT("\r\nThe %s Group Policy Template (GPT) was successfully created.\r\n\r\n"), szADT);
    _tprintf (TEXT("Add this directory to the %%SystemRoot%%\\DS.INI file on each client machine.\r\n"));
    _tprintf (TEXT("The Path entry can have multiple ADT paths each separated by a semi-colon.\r\n"));
    _tprintf (TEXT("The file format is:\r\n\r\n"));
    _tprintf (TEXT("[User ADT]\r\nPath=%s\r\n\r\n"), szADT);

    return 0;
}


BOOL ParseCommandLine (int argc, char *argv[])
{

    if (argc != 2) {
        goto usage;
    }

    if (!lstrcmpi(argv[1], TEXT("/?"))) {
        goto usage;
    }

    if (!lstrcmpi(argv[1], TEXT("-?"))) {
        goto usage;
    }

    lstrcpy (szADT, argv[1]);

    return TRUE;

usage:
    _tprintf (TEXT("\r\nusage:  creategpt <gptpath>\r\n\r\n"));

    return FALSE;
}


UINT CreateNestedDirectory(LPCTSTR lpDirectory)
{
    TCHAR szDirectory[MAX_PATH];
    LPTSTR lpEnd;


    if (CreateDirectory (lpDirectory, NULL)) {
        return 1;
    }


    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    lstrcpy (szDirectory, lpDirectory);


    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {
        lpEnd += 2;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        lpEnd++;


    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!CreateDirectory (szDirectory, NULL)) {

                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    return 0;
                }
            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    if (CreateDirectory (szDirectory, NULL)) {
        return 1;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    return 0;

}

LPTSTR CheckSlash (LPTSTR lpDir)
{
    DWORD dwStrLen;
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\debug\debug.h ===
//
// Debug levels
//

#define DL_NONE     0x00000000
#define DL_NORMAL   0x00000001
#define DL_VERBOSE  0x00000002
#define DL_LOGFILE  0x00010000
#define DL_DEBUGGER 0x00020000

//
// Winlogon location
//

#define WINLOGON_KEY        TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define EXEC_OPTIONS_KEY    TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\Winlogon.exe")

#define USERENV_DEBUG_LEVEL TEXT("UserEnvDebugLevel")
#define GLOBAL_FLAG         TEXT("GlobalFlag")

#define IDD_NONE           401
#define IDD_NORMAL         402
#define IDD_VERBOSE        403
#define IDD_LOGFILE        404
#define IDD_WINLOGON       405

BOOL CALLBACK DebugDlgProc (HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\poltest\poltest.c ===
#include <windows.h>
#include <ole2.h>
#include <userenv.h>
#define SECURITY_WIN32
#include <security.h>
#include <dsgetdc.h>
#include <lm.h>
#include <shellapi.h>
#include <commdlg.h>
#include "poltest.h"


HINSTANCE hInst;
HWND      hwndMain;
HWND      hwndListBox;
HMENU     hMenu;
HANDLE    hMachineSection;
HANDLE    hUserSection;
HANDLE    hMachineEvent;
HANDLE    hUserEvent;
HANDLE    hExit;
HANDLE    hThread;
BOOL      bVerbose = FALSE;
BOOL      bSync = FALSE;


TCHAR szAppName[] = TEXT("PolTest");
TCHAR szTitle[]   = TEXT("Group Policy Tester");

/****************************************************************************

        FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)

        PURPOSE: calls initialization function, processes message loop

****************************************************************************/
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine, INT nCmdShow)
{
        MSG msg;
        HANDLE hAccelTable;

        if (!hPrevInstance)
           {
           if (!InitApplication(hInstance))
              {
              return (FALSE);
              }
           }

        // Perform initializations that apply to a specific instance
        if (!InitInstance(hInstance, nCmdShow))
           {
           return (FALSE);
           }

        hAccelTable = LoadAccelerators (hInstance, szAppName);

        while (GetMessage(&msg, NULL, 0, 0))
           {
           if (!TranslateAccelerator (msg.hwnd, hAccelTable, &msg))
              {
              TranslateMessage(&msg);
              DispatchMessage(&msg);
              }
           }


        SetEvent (hExit);
        WaitForSingleObject (hThread, INFINITE);
        CloseHandle (hExit);
        CloseHandle (hMachineEvent);
        CloseHandle (hUserEvent);
        CloseHandle (hThread);

        return (msg.wParam);

        lpCmdLine;
}


/****************************************************************************

        FUNCTION: InitApplication(HINSTANCE)

        PURPOSE: Initializes window data and registers window class

****************************************************************************/

BOOL InitApplication(HINSTANCE hInstance)
{
        WNDCLASS  wc;


        hExit = CreateEvent (NULL, FALSE, FALSE, TEXT("poltest:  exit event"));

        if (!hExit) {
            AddString (TEXT("failed to create exit event"));
        }


        hMachineEvent = CreateEvent (NULL, FALSE, FALSE, TEXT("poltest:  machine policy event"));

        if (!hMachineEvent) {
            AddString (TEXT("failed to create machine notify event"));
        }


        hUserEvent = CreateEvent (NULL, FALSE, FALSE, TEXT("poltest:  user policy event"));

        if (!hUserEvent) {
            AddString (TEXT("failed to create user notify event"));
        }


        wc.style         = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc   = (WNDPROC)WndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;
        wc.hInstance     = hInstance;
        wc.hIcon         = LoadIcon (hInstance, szAppName);
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wc.lpszMenuName  = szAppName;
        wc.lpszClassName = szAppName;

        return (RegisterClass(&wc));
}


/****************************************************************************

        FUNCTION:  InitInstance(HINSTANCE, int)

        PURPOSE:  Saves instance handle and creates main window

****************************************************************************/

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
        HWND  hWnd;
        HKEY hKey;
        DWORD dwSize,dwType;

        hInst = hInstance;

        hWnd = CreateWindow(szAppName,
                            szTitle,
                            WS_OVERLAPPEDWINDOW,
                            CW_USEDEFAULT, 0, 500, 500,
                            NULL,
                            NULL,
                            hInstance,
                            NULL);

        if (!hWnd)
           {
           return (FALSE);
           }
        else
          {
          hwndMain = hWnd;
          }


        ShowWindow(hWnd, SW_SHOWDEFAULT);
        UpdateWindow(hWnd);

        if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Diagnostics"),
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            dwSize = sizeof(bVerbose);
            RegQueryValueEx (hKey, TEXT("RunDiagnosticLoggingGroupPolicy"),
                             NULL, &dwType, (LPBYTE) &bVerbose, &dwSize);

            RegCloseKey (hKey);
        }

        CheckMenuItem (GetMenu(hWnd), IDM_VERBOSE, MF_BYCOMMAND |
                       (bVerbose ? MF_CHECKED : MF_UNCHECKED));

        if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            dwSize = sizeof(bSync);
            RegQueryValueEx (hKey, TEXT("SynchronousGroupPolicy"),
                             NULL, &dwType, (LPBYTE) &bSync, &dwSize);

            RegCloseKey (hKey);
        }

        CheckMenuItem (GetMenu(hWnd), IDM_SYNCPOLICY, MF_BYCOMMAND |
                       (bSync ? MF_CHECKED : MF_UNCHECKED));

        return (TRUE);

}

/****************************************************************************

        FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)

        PURPOSE:  Processes messages

****************************************************************************/

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    DWORD dwID;

        switch (message)
           {
           case WM_CREATE:
                {
                RECT rc;

                GetClientRect (hWnd, &rc);

                hMenu = GetMenu(hWnd);

                EnableMenuItem (hMenu, IDM_RESUME_MACHINE, MF_BYCOMMAND | MF_GRAYED);
                EnableMenuItem (hMenu, IDM_RESUME_USER, MF_BYCOMMAND | MF_GRAYED);

                hwndListBox = CreateWindow(TEXT("LISTBOX"),
                                    NULL,
                                    WS_CHILDWINDOW | WS_VSCROLL | WS_VISIBLE | LBS_NOINTEGRALHEIGHT,
                                    0, 0, rc.right, rc.bottom,
                                    hWnd,
                                    NULL,
                                    hInst,
                                    NULL);

                SendMessage (hwndListBox, WM_SETFONT, (WPARAM) GetStockObject(ANSI_VAR_FONT), 0);


                hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE) NotifyThread,
                                        0, 0, &dwID);


                }
                break;

           case WM_COMMAND:
              {
              switch (LOWORD(wParam))
                 {
                 case IDM_UPDATE_MACHINE:
                    RefreshPolicy (TRUE);
                    break;

                 case IDM_UPDATE_USER:
                    RefreshPolicy (FALSE);
                    break;

                 case IDM_PAUSE_MACHINE:
                    hMachineSection = EnterCriticalPolicySection (TRUE);

                    if (hMachineSection) {
                        EnableMenuItem (hMenu, IDM_RESUME_MACHINE, MF_BYCOMMAND | MF_ENABLED);
                        EnableMenuItem (hMenu, IDM_PAUSE_MACHINE, MF_BYCOMMAND | MF_GRAYED);
                    } else {
                        AddString (TEXT("Failed to claim critical section."));
                    }
                    break;

                 case IDM_RESUME_MACHINE:
                    LeaveCriticalPolicySection (hMachineSection);
                    hMachineSection = NULL;
                    EnableMenuItem (hMenu, IDM_RESUME_MACHINE, MF_BYCOMMAND | MF_GRAYED);
                    EnableMenuItem (hMenu, IDM_PAUSE_MACHINE, MF_BYCOMMAND | MF_ENABLED);
                    break;

                 case IDM_PAUSE_USER:
                    hUserSection = EnterCriticalPolicySection (FALSE);

                    if (hUserSection) {
                        EnableMenuItem (hMenu, IDM_RESUME_USER, MF_BYCOMMAND | MF_ENABLED);
                        EnableMenuItem (hMenu, IDM_PAUSE_USER, MF_BYCOMMAND | MF_GRAYED);
                    } else {
                        AddString (TEXT("Failed to claim critical section."));
                    }
                    break;

                 case IDM_RESUME_USER:
                    LeaveCriticalPolicySection (hUserSection);
                    hUserSection = NULL;
                    EnableMenuItem (hMenu, IDM_RESUME_USER, MF_BYCOMMAND | MF_GRAYED);
                    EnableMenuItem (hMenu, IDM_PAUSE_USER, MF_BYCOMMAND | MF_ENABLED);
                    break;

                 case IDM_EXIT:
                    DestroyWindow (hwndMain);
                    break;


                 case IDM_VERBOSE:
                    {
                    HKEY hKey;
                    DWORD dwDisp, dwTemp;
                    TCHAR szMsg[MAX_PATH];
                    LONG lResult;

                    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Diagnostics"),
                                              0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                                              NULL, &hKey, &dwDisp);

                    if (lResult == ERROR_SUCCESS) {

                        bVerbose = !bVerbose;

                        RegSetValueEx (hKey, TEXT("RunDiagnosticLoggingGroupPolicy"),
                                       0, REG_DWORD, (LPBYTE) &bVerbose, sizeof(bVerbose));

                        RegCloseKey (hKey);

                        CheckMenuItem (GetMenu(hWnd), IDM_VERBOSE, MF_BYCOMMAND |
                                       (bVerbose ? MF_CHECKED : MF_UNCHECKED));
                    } else {

                        szMsg[0] = TEXT('\0');

                        FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
                                      NULL, lResult,
                                      MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                      szMsg, MAX_PATH, NULL);

                        MessageBox (hWnd, szMsg, TEXT("Error setting registry value"),
                                    MB_OK | MB_ICONERROR);
                    }

                    }
                    break;

                 case IDM_EVENTVWR:
                    ShellExecute (NULL, TEXT("open"), TEXT("eventvwr.msc"), NULL,
                                  NULL, SW_SHOWNORMAL);
                    break;

                 case IDM_USERNAME:
                    {
                    TCHAR szName[512];
                    DWORD dwSize = 512;

                    if (GetUserNameEx(NameFullyQualifiedDN, szName, &dwSize)) {
                        AddString (szName);
                    } else {
                        TCHAR szError[100];

                        wsprintf (szError, TEXT("Failed to get user name with %d"), GetLastError());
                        AddString (szError);
                    }
                    }
                    break;

                 case IDM_COMPUTERNAME:
                    {
                    TCHAR szName[512];
                    DWORD dwSize = 512;

                    if (GetComputerObjectName(NameFullyQualifiedDN, szName, &dwSize)) {
                        AddString (szName);
                    } else {
                        TCHAR szError[100];

                        wsprintf (szError, TEXT("Failed to get computer name with %d"), GetLastError());
                        AddString (szError);
                    }
                    }
                    break;

                 case IDM_SITENAME:
                    {
                    LPTSTR lpName;
                    ULONG ulResult;

                    ulResult = DsGetSiteName (NULL, &lpName);

                    if (ulResult == ERROR_SUCCESS) {
                        AddString (lpName);
                        NetApiBufferFree (lpName);
                    } else {
                        TCHAR szError[100];

                        wsprintf (szError, TEXT("Failed to get site name with %d"), ulResult);
                        AddString (szError);
                    }
                    }
                    break;

                 case IDM_PDCNAME:
                    {
                    DWORD dwResult;
                    PDOMAIN_CONTROLLER_INFO pDCI;


                    dwResult = DsGetDcName (NULL, NULL, NULL, NULL,
                                            DS_DIRECTORY_SERVICE_REQUIRED | DS_PDC_REQUIRED,
                                            &pDCI);

                    if (dwResult == ERROR_SUCCESS) {
                        AddString (pDCI->DomainControllerName);
                        NetApiBufferFree(pDCI);

                    } else {
                        TCHAR szBuffer[100];

                        wsprintf (szBuffer, TEXT("Failed to get the PDC name with %d"), dwResult);
                        AddString (szBuffer);
                    }
                    }
                    break;

                 case IDM_SYNCPOLICY:
                    {
                    HKEY hKey;
                    DWORD dwDisp, dwTemp;
                    TCHAR szMsg[MAX_PATH];
                    LONG lResult;

                    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                                              0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                                              NULL, &hKey, &dwDisp);

                    if (lResult == ERROR_SUCCESS) {

                        bSync = !bSync;

                        RegSetValueEx (hKey, TEXT("SynchronousGroupPolicy"),
                                       0, REG_DWORD, (LPBYTE) &bSync, sizeof(bSync));

                        RegCloseKey (hKey);

                        CheckMenuItem (GetMenu(hWnd), IDM_SYNCPOLICY, MF_BYCOMMAND |
                                       (bSync ? MF_CHECKED : MF_UNCHECKED));

                        AddString (TEXT("You need to reboot for this change to take effect."));

                    } else {

                        szMsg[0] = TEXT('\0');

                        FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
                                      NULL, lResult,
                                      MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                      szMsg, MAX_PATH, NULL);

                        MessageBox (hWnd, szMsg, TEXT("Error setting registry value"),
                                    MB_OK | MB_ICONERROR);
                    }

                    }
                    break;

                 case IDM_DCLIST:
                    ManageDomainInfo(hWnd);
                    break;

                 case IDM_CHECKGPO:
                    CheckGPO(hWnd);
                    break;

                 case IDM_CLEARWINDOW:
                    SendMessage (hwndListBox, LB_RESETCONTENT, 0, 0);
                    break;

                 case IDM_SAVEAS:
                    {
                    HANDLE hFile;
                    INT iCount, i;
                    DWORD dwWrite;
                    TCHAR szFilter[100];
                    TCHAR szFileName[MAX_PATH];
                    CHAR szString[MAX_PATH];
                    TCHAR szError[100];
                    CHAR szLF[] = "\r\n";
                    OPENFILENAME ofn;

                    iCount = SendMessage (hwndListBox, LB_GETCOUNT, 0, 0);

                    if (iCount == LB_ERR) {
                        break;
                    }

                    lstrcpy (szFileName, TEXT("Poltest Results.txt"));

                    ZeroMemory (szFilter, sizeof(szFilter));

                    lstrcpy (szFilter, TEXT("Text Files#*.txt"));
                    szFilter[10] = TEXT('\0');

                    ZeroMemory (&ofn, sizeof(ofn));
                    ofn.lStructSize = sizeof(ofn);
                    ofn.hwndOwner = hWnd;
                    ofn.hInstance = hInst;
                    ofn.lpstrFile = szFileName;
                    ofn.nMaxFile =  MAX_PATH;
                    ofn.lpstrFilter = szFilter;
                    ofn.lpstrDefExt = TEXT("txt");
                    ofn.Flags = OFN_CREATEPROMPT | OFN_ENABLESIZING | OFN_HIDEREADONLY |
                                OFN_OVERWRITEPROMPT;

                    if (!GetSaveFileName (&ofn)) {
                        break;
                    }

                    hFile = CreateFile (szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL, NULL);

                    if (hFile == INVALID_HANDLE_VALUE) {
                        wsprintf (szError, TEXT("Failed to open file with %d"), GetLastError());
                        AddString (szError);
                        break;
                    }

                    for (i = 0; i < iCount; i++) {
                        szString[0] = '\0';
                        SendMessageA (hwndListBox, LB_GETTEXT, i, (LPARAM)szString);
                        WriteFile (hFile, szString, lstrlenA(szString),
                                   &dwWrite, NULL);
                        WriteFile (hFile, szLF, lstrlenA(szLF),
                                   &dwWrite, NULL);
                    }

                    CloseHandle (hFile);
                    }
                    break;

                 default:
                    return (DefWindowProc(hWnd, message, wParam, lParam));
                 }
              }
              break;

           case WM_WININICHANGE:

              if (!lstrcmpi ((LPTSTR)lParam, TEXT("Policy"))) {

                   if (wParam) {
                       AddString (TEXT("Received WM_WININICHANGE:  machine policy applied."));
                   } else {
                       AddString (TEXT("Received WM_WININICHANGE:  user policy applied."));
                   }
              }
              break;

           case WM_SIZE:
                SetWindowPos (hwndListBox, HWND_TOP, 0, 0,
                              LOWORD(lParam), HIWORD(lParam),
                              SWP_NOMOVE | SWP_NOZORDER);
                break;

           case WM_DESTROY:
              PostQuitMessage(0);
              break;

           default:
              return (DefWindowProc(hWnd, message, wParam, lParam));
           }

        return FALSE;
}

VOID AddString (LPTSTR lpString)
{
    SYSTEMTIME systime;
    TCHAR  szString[300];

    GetLocalTime (&systime);
    wsprintf (szString, TEXT("%02d:%02d:%02d:%03d   %s"),
              systime.wHour, systime.wMinute, systime.wSecond,
              systime.wMilliseconds, lpString);


    SendMessage (hwndListBox, LB_INSERTSTRING, -1,
                 (LPARAM) szString);

}

DWORD NotifyThread (DWORD dwDummy)
{
    HANDLE hHandles[3];
    DWORD dwResult;


    RegisterGPNotification(hMachineEvent, TRUE);
    RegisterGPNotification(hUserEvent, FALSE);

    hHandles[0] = hExit;
    hHandles[1] = hMachineEvent;
    hHandles[2] = hUserEvent;

    while (TRUE) {

        dwResult = WaitForMultipleObjects (3, hHandles, FALSE, INFINITE);

        if ((dwResult == WAIT_FAILED) || ((dwResult - WAIT_OBJECT_0) == 0)) {
            if (dwResult == WAIT_FAILED) {
                AddString (TEXT("WaitForMultipleObjects failed."));
            }
            break;
        }

        if ((dwResult - WAIT_OBJECT_0) == 1) {
            AddString (TEXT("Machine notify event signaled."));
        } else {
            AddString (TEXT("User notify event signaled."));
        }
    }

    UnregisterGPNotification(hMachineEvent);
    UnregisterGPNotification(hUserEvent);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\gpolist\test.c ===
#include <windows.h>
#include <userenv.h>
#include <tchar.h>
#include <stdio.h>
#include <dsgetdc.h>
#include <lm.h>
#define SECURITY_WIN32
#include <security.h>

int __cdecl main( int argc, char *argv[])
{
    HANDLE hToken;
    DWORD dwStart, dwDelta;
    PGROUP_POLICY_OBJECT pGPOList, pTemp;
    TCHAR szName[200];
    TCHAR szDCName[200];
    ULONG ulSize;
    DWORD dwResult;
    PDOMAIN_CONTROLLER_INFO pDCI = NULL;


    OpenProcessToken (GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken);

    dwStart = GetTickCount();

    if (GetGPOList (hToken, NULL, NULL, NULL, 0, &pGPOList)) {

        dwDelta = GetTickCount() - dwStart;

        _tprintf (TEXT("\r\nTick count:  %d\r\n\r\n"), dwDelta);

        pTemp = pGPOList;

        while (pTemp) {

            _tprintf (TEXT("%s\t%s\r\n"), pTemp->szGPOName, pTemp->lpDisplayName);

            pTemp = pTemp->pNext;
        }

        FreeGPOList (pGPOList);
    }

    CloseHandle (hToken);


    //
    // Second time without the hToken
    //

    _tprintf (TEXT("\r\n\r\nRound 2 without token\r\n\r\n"));

    ulSize = 200;
    if (!GetUserNameEx (NameFullyQualifiedDN, szName, &ulSize)) {
        return 0;
    }


    //
    // Check this domain for a DC
    //

    dwResult = DsGetDcName (NULL, NULL, NULL, NULL,
                            DS_DIRECTORY_SERVICE_PREFERRED, &pDCI);

    if (dwResult != ERROR_SUCCESS) {
        return 0;
    }


    //
    // Found a DC, does it have a DS ?
    //

    if (!(pDCI->Flags & DS_DS_FLAG)) {
        NetApiBufferFree(pDCI);
        return 0;
    }


    dwStart = GetTickCount();

    if (GetGPOList (NULL, szName, pDCI->DomainControllerName, NULL, 0, &pGPOList)) {

        dwDelta = GetTickCount() - dwStart;

        _tprintf (TEXT("\r\nTick count:  %d\r\n\r\n"), dwDelta);

        pTemp = pGPOList;

        while (pTemp) {

            _tprintf (TEXT("%s\t%s\r\n"), pTemp->szGPOName, pTemp->lpDisplayName);

            pTemp = pTemp->pNext;
        }

        FreeGPOList (pGPOList);
    }

    NetApiBufferFree(pDCI);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\poltest\gpcheck.cpp ===
#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <tchar.h>
#include <lm.h>
#include <ole2.h>
#include <olectl.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commctrl.h>
#include <prsht.h>
#include <dsclient.h>
#include <dsgetdc.h>
#include <mmc.h>
#include <initguid.h>
#include <gpedit.h>
#define _USERENV_NO_LINK_APIS_ 1
#include <userenv.h>
#include <userenvp.h>


#include "poltest.h"


typedef struct _GPOINFO {
    TCHAR szGPOName[50];
    DWORD dwFlags;
} GPOINFO, *LPGPOINFO;

#define GPO_FLAG_VERSION   1
#define GPO_FLAG_REGISTRY  2

LPTSTR CheckSlash (LPTSTR lpDir);

//*************************************************************
//
//  GetDCList()
//
//  Purpose:    Reads the DC list from the registry
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

LPTSTR GetDCList (BOOL bZero)
{
    HKEY hKey;
    LPTSTR lpList = NULL;
    LPTSTR lpTemp;
    DWORD dwType, dwSize;


    lpList = (LPTSTR) LocalAlloc (LPTR, 256 * sizeof(TCHAR));

    if (!lpList)
        return NULL;


    if (RegOpenKeyEx (HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Poltest"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = 256 * sizeof(TCHAR);
        RegQueryValueEx (hKey, TEXT("DCList"), NULL, &dwType,
                         (LPBYTE) lpList, &dwSize);

        RegCloseKey (hKey);
    }

    if (bZero) {
        lpTemp = lpList;

        while (*lpTemp) {
            if (*lpTemp == TEXT(';')) {
                *lpTemp = TEXT('\0');
            }

            lpTemp++;
        }
    }

    if (*lpList == TEXT('\0')) {
        LocalFree (lpList);
        return NULL;
    }

    return lpList;
}

//*************************************************************
//
//  GetDomainName()
//
//  Purpose:    Reads the domain name from the registry
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

LPTSTR GetDomainName (BOOL bZero)
{
    HKEY hKey;
    LPTSTR lpList = NULL;
    LPTSTR lpTemp;
    DWORD dwType, dwSize;


    lpList = (LPTSTR) LocalAlloc (LPTR, 256 * sizeof(TCHAR));

    if (!lpList)
        return NULL;


    if (RegOpenKeyEx (HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Poltest"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = 256 * sizeof(TCHAR);
        RegQueryValueEx (hKey, TEXT("DomainName"), NULL, &dwType,
                         (LPBYTE) lpList, &dwSize);

        RegCloseKey (hKey);
    }

    if (bZero) {
        lpTemp = lpList;

        while (*lpTemp) {
            if (*lpTemp == TEXT('.')) {
                *lpTemp = TEXT('\0');
            }

            lpTemp++;
        }
    }


    if (*lpList == TEXT('\0')) {
        LocalFree (lpList);
        return NULL;
    }

    return lpList;
}

//*************************************************************
//
//  CheckSpecificGPO()
//
//  Purpose:    Checks a specific GPO's for the requested
//              attributes
//
//  Parameters: lpGPOName  - gpo name
//              dwFlags    - GPO_FLAG_*
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL CheckSpecificGPO (LPTSTR lpGPOName, DWORD dwFlags)
{
    LPTSTR lpList;
    LPTSTR lpDomainName;
    LPTSTR lpDomainName2;
    LPTSTR lpDC, lpTemp;
    TCHAR szPath[MAX_PATH];
    TCHAR szLDAPPath[MAX_PATH];
    TCHAR szMsg[512];
    WIN32_FILE_ATTRIBUTE_DATA fad;
    DWORD dwFileSysVersion;
    LPTSTR lpEnd;
    FILETIME filetime;
    SYSTEMTIME systime;
    TCHAR szDate[50];
    TCHAR szTime[50];
    IADs *pADs;
    VARIANT var;
    BSTR bstrProperty;
    HRESULT hr;



    lpList = GetDCList (TRUE);

    if (!lpList) {
        AddString (TEXT("You need to enter the list of DC names"));
        return TRUE;
    }

    lpDomainName = GetDomainName (FALSE);

    if (!lpDomainName) {
        AddString (TEXT("You need to enter a domain name"));
        LocalFree (lpList);
        return TRUE;
    }

    CoInitialize(NULL);

    AddString (TEXT("============================================"));
    wsprintf (szMsg, TEXT("Listing GPO %s's information from all DCs"), lpGPOName);
    AddString (szMsg);


    lpDC = lpList;

    while (*lpDC) {

        AddString (TEXT("------------"));

        wsprintf (szMsg, TEXT("Checking DC:  %s"), lpDC);
        AddString (szMsg);

        wsprintf (szPath, TEXT("\\\\%s\\SysVol\\%s\\policies\\%s"),
                  lpDC, lpDomainName, lpGPOName);

        if (!GetFileAttributesEx (szPath, GetFileExInfoStandard, &fad)) {
            wsprintf (szMsg, TEXT("Failed to find %s with %d"), szPath, GetLastError());
            AddString (szMsg);
            goto LoopAgain;
        }

        lpEnd = CheckSlash (szPath);

        if (dwFlags & GPO_FLAG_VERSION) {
            lstrcpy (lpEnd, TEXT("gpt.ini"));

            dwFileSysVersion = GetPrivateProfileInt(TEXT("General"), TEXT("Version"), 0, szPath);


            lpDomainName2 = GetDomainName (TRUE);

            lstrcpy (szLDAPPath, TEXT("LDAP://"));
            lstrcat (szLDAPPath, lpDC);
            lstrcat (szLDAPPath, TEXT("/CN="));
            lstrcat (szLDAPPath, lpGPOName);
            lstrcat (szLDAPPath, TEXT(",CN=Policies,CN=System"));

            lpTemp = lpDomainName2;

            while (*lpTemp) {

                lstrcat (szLDAPPath, TEXT(",DC="));
                lstrcat (szLDAPPath, lpTemp);
                lpTemp += lstrlen(lpTemp) + 1;
            }

            hr = ADsGetObject(szLDAPPath, IID_IADs, (void **)&pADs);

            if (FAILED(hr)) {
                wsprintf (szMsg, TEXT("ADsGetObject failed with 0x%x"), hr);
                AddString (szMsg);
                goto LoopAgain;
            }


            VariantInit(&var);
            bstrProperty = SysAllocString (L"versionNumber");

            hr = pADs->Get(bstrProperty, &var);

            if (FAILED(hr)) {
                wsprintf (szMsg, TEXT("pADs->Get failed with 0x%x"), hr);
                AddString (szMsg);
                SysFreeString (bstrProperty);
                VariantClear (&var);
                goto LoopAgain;
            }

            wsprintf (szMsg, TEXT("DS Version:  %d"), var.lVal);
            AddString (szMsg);

            SysFreeString (bstrProperty);
            VariantClear (&var);
            pADs->Release();

            wsprintf (szMsg, TEXT("SysVol Version:  %d"), dwFileSysVersion);
            AddString (szMsg);
        }

        if (dwFlags & GPO_FLAG_REGISTRY) {

            lstrcpy (lpEnd, TEXT("machine\\registry.pol"));

            if (GetFileAttributesEx (szPath, GetFileExInfoStandard, &fad)) {

                FileTimeToLocalFileTime (&fad.ftLastWriteTime, &filetime);
                FileTimeToSystemTime (&filetime, &systime);

                GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systime,
                               NULL, szDate, 50);

                GetTimeFormat (LOCALE_USER_DEFAULT, 0, &systime,
                               NULL, szTime, 50);

                wsprintf (szMsg, TEXT("Last Registry Update (machine):  %s %s"), szDate, szTime);
                AddString (szMsg);
            }

            lstrcpy (lpEnd, TEXT("user\\registry.pol"));

            if (GetFileAttributesEx (szPath, GetFileExInfoStandard, &fad)) {

                FileTimeToLocalFileTime (&fad.ftLastWriteTime, &filetime);
                FileTimeToSystemTime (&filetime, &systime);

                GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systime,
                               NULL, szDate, 50);

                GetTimeFormat (LOCALE_USER_DEFAULT, 0, &systime,
                               NULL, szTime, 50);

                wsprintf (szMsg, TEXT("Last Registry Update (user):        %s %s"), szDate, szTime);
                AddString (szMsg);
            }
        }

LoopAgain:

        lpDC += lstrlen(lpDC) + 1;
    }

    CoUninitialize();

    LocalFree (lpList);
    LocalFree (lpDomainName);

    return TRUE;
}


BOOL CALLBACK DomainInfo (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            {
            LPTSTR lpTemp;

            lpTemp = GetDomainName (FALSE);

            if (lpTemp) {
                SetDlgItemText (hDlg, IDC_NAME, lpTemp);
                LocalFree (lpTemp);
            }

            lpTemp = GetDCList (FALSE);

            if (lpTemp) {
                SetDlgItemText (hDlg, IDC_DCLIST, lpTemp);
                LocalFree (lpTemp);
            }
            }
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK) {
                HKEY hKey;
                DWORD dwDisp;
                TCHAR szBuffer[512];


                if (RegCreateKeyEx (HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Poltest"),
                                    0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                                    NULL, &hKey, &dwDisp) == ERROR_SUCCESS) {

                    GetDlgItemText (hDlg, IDC_NAME, szBuffer, 512);
                    RegSetValueEx (hKey, TEXT("DomainName"), NULL, REG_SZ,
                                   (LPBYTE) szBuffer, (lstrlen(szBuffer) + 1) *sizeof(TCHAR));

                    GetDlgItemText (hDlg, IDC_DCLIST, szBuffer, 512);
                    RegSetValueEx (hKey, TEXT("DCList"), NULL, REG_SZ,
                                   (LPBYTE) szBuffer, (lstrlen(szBuffer) + 1) *sizeof(TCHAR));

                    RegCloseKey (hKey);
                }


                EndDialog(hDlg, TRUE);
                return (TRUE);
            }


            if (LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, FALSE);
                return (TRUE);
            }
            break;
    }

    return (FALSE);
}


BOOL ManageDomainInfo(HWND hWnd)
{

    DialogBox (GetModuleHandle(NULL), TEXT("DOMAIN_INFO"), hWnd, DomainInfo);

    return TRUE;
}

DWORD WINAPI CheckGPOThread (LPGPOINFO lpInfo)
{
    CheckSpecificGPO (lpInfo->szGPOName, lpInfo->dwFlags);
    
    LocalFree (lpInfo);

    return 0;
}

BOOL CALLBACK GPONameDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            {
            HKEY hKey;
            DWORD dwType, dwSize, dwTemp;
            TCHAR szGPOName[50];

            szGPOName[0] = TEXT('\0');
            if (RegOpenKeyEx (HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Poltest"),
                              0, KEY_READ, &hKey) == ERROR_SUCCESS) {

                dwSize = 50 * sizeof(TCHAR);
                RegQueryValueEx (hKey, TEXT("GPOName"), NULL, &dwType,
                                 (LPBYTE) szGPOName, &dwSize);

                dwSize = sizeof(dwTemp);
                dwTemp = 0;
                RegQueryValueEx (hKey, TEXT("GPONameOptions"), NULL, &dwType,
                                 (LPBYTE) &dwTemp, &dwSize);


                RegCloseKey (hKey);
            }


            SetDlgItemText (hDlg, IDC_NAME, szGPOName);

            if (dwTemp & GPO_FLAG_VERSION) {
                CheckDlgButton (hDlg, IDC_VERSION, BST_CHECKED);
            }

            if (dwTemp & GPO_FLAG_REGISTRY) {
                CheckDlgButton (hDlg, IDC_REGISTRY, BST_CHECKED);
            }


            }
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK) {

                HKEY hKey;
                DWORD dwDisp, dwTemp;
                TCHAR szGPOName[50];
                LPGPOINFO lpInfo;
                HANDLE hThread;
                DWORD dwID;

                dwTemp = 0;

                if (IsDlgButtonChecked (hDlg, IDC_VERSION)) {
                    dwTemp |= GPO_FLAG_VERSION;
                }

                if (IsDlgButtonChecked (hDlg, IDC_REGISTRY)) {
                    dwTemp |= GPO_FLAG_REGISTRY;
                }


                if (RegCreateKeyEx (HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Poltest"),
                                    0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                                    NULL, &hKey, &dwDisp) == ERROR_SUCCESS) {

                    GetDlgItemText (hDlg, IDC_NAME, szGPOName, 50);
                    RegSetValueEx (hKey, TEXT("GPOName"), NULL, REG_SZ,
                                   (LPBYTE) szGPOName, (lstrlen(szGPOName) + 1) *sizeof(TCHAR));
                    RegSetValueEx (hKey, TEXT("GPONameOptions"), NULL, REG_SZ,
                                   (LPBYTE) &dwTemp, sizeof(dwTemp));

                    RegCloseKey (hKey);
                }

                lpInfo = (LPGPOINFO) LocalAlloc (LPTR, sizeof(GPOINFO));

                if (lpInfo) {
                    lstrcpy (lpInfo->szGPOName, szGPOName);
                    lpInfo->dwFlags = dwTemp;

                    hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)CheckGPOThread,
                                            lpInfo, 0, &dwID);

                    if (hThread) {
                        CloseHandle (hThread);
                    }

                }
                EndDialog(hDlg, TRUE);
                return (TRUE);
            }


            if (LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, FALSE);
                return (TRUE);
            }

            if (LOWORD(wParam) == IDC_BROWSE) {
                GPOBROWSEINFO info;
                TCHAR szName[500];
                TCHAR szPath[512];
                LPGROUPPOLICYOBJECT pGPO;

                szName[0] = TEXT('\0');
                ZeroMemory (&info, sizeof(info));
                info.dwSize = sizeof(info);
                info.dwFlags = GPO_BROWSE_NOCOMPUTERS;
                info.hwndOwner = hDlg;
                info.lpDSPath = szPath;
                info.dwDSPathSize = 512;
                info.lpName = szName;
                info.dwNameSize = 500;

                if (SUCCEEDED(BrowseForGPO (&info))) {

                    if (SUCCEEDED(CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                                  CLSCTX_SERVER, IID_IGroupPolicyObject,
                                  (void**)&pGPO))) {


                        if (SUCCEEDED(pGPO->OpenDSGPO (szPath, GPO_OPEN_READ_ONLY))){
                            pGPO->GetName (szName, 500);
                            SetDlgItemText (hDlg, IDC_NAME, szName);
                        }
                        pGPO->Release();
                    }
                }
            }
            break;
    }

    return (FALSE);
}


BOOL CheckGPO(HWND hWnd)
{

    DialogBox (GetModuleHandle(NULL), TEXT("GPO_NAME"), hWnd, GPONameDlgProc);

    return TRUE;
}

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    DWORD dwStrLen;
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\poltest\poltest.h ===
#ifdef __cplusplus
extern "C" {
#endif


#define IDM_UPDATE_MACHINE  1
#define IDM_UPDATE_USER     2
#define IDM_PAUSE_MACHINE   3
#define IDM_RESUME_MACHINE  4
#define IDM_PAUSE_USER      5
#define IDM_RESUME_USER     6
#define IDM_EXIT            7
#define IDM_VERBOSE         8
#define IDM_EVENTVWR        9
#define IDM_USERNAME       10
#define IDM_COMPUTERNAME   11
#define IDM_SITENAME       12
#define IDM_SYNCPOLICY     13
#define IDM_DCLIST         14
#define IDM_CHECKGPO       15
#define IDM_CLEARWINDOW    16
#define IDM_SAVEAS         17
#define IDM_PDCNAME        18


#define IDC_NAME           100
#define IDC_DCLIST         101
#define IDC_BROWSE         102
#define IDC_VERSION        103
#define IDC_REGISTRY       104

BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
VOID AddString (LPTSTR lpString);
DWORD NotifyThread (DWORD dwDummy);



BOOL ManageDomainInfo(HWND hWnd);
BOOL CheckGPO(HWND hWnd);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\rcmd\server\async.c ===
/****************************** Module Header ******************************\
* Module Name: async.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* This module implements asynchronous I/O on file handles in a more
* useful way than provided for by Win32 apis.
*
* This module provides 2 main apis : ReadFileAsync, WriteFileAsync.
* These apis take a handle to an async object and always return
* immediately without waiting for the I/O to complete. An event
* can be queried from the async object and used to wait for completion.
* When this event is signalled, the I/O result can be queried from
* the async object.
*
* History:
* 06-29-92 Davidc       Created.
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <windef.h>
#include <nturtl.h>
#include <winbase.h>
#include "rcmdsrv.h"

//
// Define RCOVERLAPPED structure
//

typedef struct {

    OVERLAPPED  Overlapped;

    HANDLE      FileHandle; // Non-null when I/O operation in progress.

    DWORD       CompletionCode;
    DWORD       BytesTransferred;
    BOOL        CompletedSynchronously;

} RCOVERLAPPED, *PRCOVERLAPPED;





/////////////////////////////////////////////////////////////////////////////
//
// CreateAsync
//
// Creates an async object.
// The async event is created with the initial state specified. If this
// is TRUE the async object created simulates a successfully completed
// transfer of 0 bytes.
//
// Returns handle on success, NULL on failure. GetLastError() for details.
//
// The object should be deleted by calling DeleteAsync.
//
/////////////////////////////////////////////////////////////////////////////

HANDLE
CreateAsync(
    BOOL    InitialState
    )
{
    SECURITY_ATTRIBUTES SecurityAttributes;
    PRCOVERLAPPED   RcOverlapped;

    SecurityAttributes.nLength = sizeof(SecurityAttributes);
    SecurityAttributes.lpSecurityDescriptor = NULL; // Use default ACL
    SecurityAttributes.bInheritHandle = FALSE; // No inheritance

    //
    // Allocate space for the async structure
    //


    RcOverlapped = (PRCOVERLAPPED)Alloc(sizeof(RCOVERLAPPED));
    if (RcOverlapped == NULL) {
	RcDbgPrint("CreateAsync : Failed to allocate space for async object\n");
	return(NULL);
    }

    //
    // Create the synchronisation event
    //

    RcOverlapped->Overlapped.hEvent = CreateEvent( &SecurityAttributes,
						   TRUE,        // Manual-reset
						   InitialState,
						   NULL);       // Name
    if (RcOverlapped->Overlapped.hEvent == NULL) {
	RcDbgPrint("CreateAsync failed to create event, error = %d\n", GetLastError());
	Free(RcOverlapped);
	return(NULL);
    }

    //
    // Initialize other fields.
    // (Set FileHandle non-NULL to keep GetAsyncResult happy)
    //

    RcOverlapped->FileHandle = InitialState ? (HANDLE)1 : NULL;
    RcOverlapped->BytesTransferred = 0;
    RcOverlapped->CompletionCode = ERROR_SUCCESS;
    RcOverlapped->CompletedSynchronously = TRUE;


    return((HANDLE)RcOverlapped);
}




/////////////////////////////////////////////////////////////////////////////
//
// DeleteAsync
//
// Deletes resources used by async object
//
// Returns nothing
//
/////////////////////////////////////////////////////////////////////////////

VOID
DeleteAsync(
    HANDLE AsyncHandle
    )
{
    PRCOVERLAPPED RcOverlapped = (PRCOVERLAPPED)AsyncHandle;
    DWORD   BytesTransferred;

    //
    // Wait for operation if in progress
    //


    if (GetAsyncResult(AsyncHandle, &BytesTransferred) == ERROR_IO_INCOMPLETE)  {
	if (WaitForSingleObject(
		GetAsyncCompletionHandle(AsyncHandle),
		5000) != WAIT_OBJECT_0 ) {
	    RcDbgPrint("Async object rundown wait failed, error %d\n",
		GetLastError());
	    }
	}


    RcCloseHandle(RcOverlapped->Overlapped.hEvent, "async overlapped event");
    Free(RcOverlapped);

    return;
}




/////////////////////////////////////////////////////////////////////////////
//
// ReadFileAsync
//
// Reads from file asynchronously.
//
// Returns TRUE on success, FALSE on failure (GetLastError() for detail)
//
// Caller should wait on async event for operation to complete, then call
// GetAsyncResult to retrieve information on transfer.
//
/////////////////////////////////////////////////////////////////////////////

BOOL
ReadFileAsync(
    HANDLE  hFile,
    LPVOID  lpBuffer,
    DWORD   nBytesToRead,
    HANDLE  AsyncHandle
    )
{
    BOOL Result;
    DWORD Error;
    PRCOVERLAPPED RcOverlapped = (PRCOVERLAPPED)AsyncHandle;

    //
    // Check an IO operation is not in progress
    //

    if (RcOverlapped->FileHandle != NULL) {
	RcDbgPrint("ReadFileAsync : Operation already in progress!\n");
	SetLastError(ERROR_IO_PENDING);
	return(FALSE);
    }

    //
    // Reset the event
    //

    Result = ResetEvent(RcOverlapped->Overlapped.hEvent);
    if (!Result) {
	RcDbgPrint("ReadFileAsync : Failed to reset async event, error = %d\n", GetLastError());
	return(FALSE);
    }


    //
    // Store the file handle in our structure.
    // This also functions as a signal that an operation is in progress.
    //

    RcOverlapped->FileHandle = hFile;
    RcOverlapped->CompletedSynchronously = FALSE;

    Result = ReadFile(hFile,
		      lpBuffer,
		      nBytesToRead,
		      &RcOverlapped->BytesTransferred,
		      &RcOverlapped->Overlapped);

    if (!Result) {

	Error = GetLastError();

	if (Error == ERROR_IO_PENDING) {

	    //
	    // The I/O has been started synchronously, we're done
	    //

	    return(TRUE);
	}

	//
	// The read really did fail, reset our flag and get out
	//

	RcDbgPrint("ReadFileAsync : ReadFile failed, error = %d\n", Error);
	RcOverlapped->FileHandle = NULL;
	return(FALSE);
    }


    //
    // The operation completed synchronously. Store the paramaters in our
    // structure ready for GetAsyncResult and signal the event
    //

    RcOverlapped->CompletionCode = ERROR_SUCCESS;
    RcOverlapped->CompletedSynchronously = TRUE;

    //
    // Set the event
    //

    Result = SetEvent(RcOverlapped->Overlapped.hEvent);
    if (!Result) {
	RcDbgPrint("ReadFileAsync : Failed to set async event, error = %d\n", GetLastError());
    }

    return(TRUE);
}



/////////////////////////////////////////////////////////////////////////////
//
// WriteFileAsync
//
// Writes to file asynchronously.
//
// Returns TRUE on success, FALSE on failure (GetLastError() for detail)
//
// Caller should wait on async event for operation to complete, then call
// GetAsyncResult to retrieve information on transfer.
//
/////////////////////////////////////////////////////////////////////////////

BOOL
WriteFileAsync(
    HANDLE  hFile,
    LPVOID  lpBuffer,
    DWORD   nBytesToWrite,
    HANDLE  AsyncHandle
    )
{
    BOOL Result;
    DWORD Error;
    PRCOVERLAPPED RcOverlapped = (PRCOVERLAPPED)AsyncHandle;

    //
    // Check an IO operation is not in progress
    //

    if (RcOverlapped->FileHandle != NULL) {
	RcDbgPrint("ReadFileAsync : Operation already in progress!\n");
	SetLastError(ERROR_IO_PENDING);
	return(FALSE);
    }


    //
    // Reset the event
    //

    Result = ResetEvent(RcOverlapped->Overlapped.hEvent);
    if (!Result) {
	RcDbgPrint("WriteFileAsync : Failed to reset async event, error = %d\n", GetLastError());
	return(FALSE);
    }

    //
    // Store the file handle in our structure.
    // This also functions as a signal that an operation is in progress.
    //

    RcOverlapped->FileHandle = hFile;
    RcOverlapped->CompletedSynchronously = FALSE;

    Result = WriteFile(hFile,
		      lpBuffer,
		      nBytesToWrite,
		      &RcOverlapped->BytesTransferred,
		      &RcOverlapped->Overlapped);

    if (!Result) {

	Error = GetLastError();

	if (Error == ERROR_IO_PENDING) {

	    //
	    // The I/O has been started synchronously, we're done
	    //

	    return(TRUE);
	}

	//
	// The read really did fail, reset our flag and get out
	//

	RcDbgPrint("WriteFileAsync : WriteFile failed, error = %d\n", Error);
	RcOverlapped->FileHandle = NULL;
	return(FALSE);
    }


    //
    // The operation completed synchronously. Store the paramaters in our
    // structure ready for GetAsyncResult and signal the event
    //

    RcOverlapped->CompletionCode = ERROR_SUCCESS;
    RcOverlapped->CompletedSynchronously = TRUE;

    //
    // Set the event
    //

    Result = SetEvent(RcOverlapped->Overlapped.hEvent);
    if (!Result) {
	RcDbgPrint("WriteFileAsync : Failed to set async event, error = %d\n", GetLastError());
    }

    return(TRUE);
}




/////////////////////////////////////////////////////////////////////////////
//
// GetCompletionHandle
//
// Returns a handle that can be used to wait for completion of the
// operation associated with this async object
//
// Returns an event handle or NULL on failure
//
/////////////////////////////////////////////////////////////////////////////

HANDLE
GetAsyncCompletionHandle(
    HANDLE  AsyncHandle
    )
{
    PRCOVERLAPPED RcOverlapped = (PRCOVERLAPPED)AsyncHandle;

    return(RcOverlapped->Overlapped.hEvent);
}




/////////////////////////////////////////////////////////////////////////////
//
// GetAsyncResult
//
// Returns the result of the last completed operation involving the
// passed async object handle.
//
// Returns the completion code of the last operation OR
// ERROR_IO_INCOMPLETE if the operation has not completed.
// ERROR_NO_DATA if there is no operation in progress.
//
/////////////////////////////////////////////////////////////////////////////

DWORD
GetAsyncResult(
    HANDLE  AsyncHandle,
    LPDWORD BytesTransferred
    )
{
    BOOL Result;
    DWORD WaitResult;
    PRCOVERLAPPED RcOverlapped = (PRCOVERLAPPED)AsyncHandle;
    DWORD AsyncResult;

    //
    // Check an IO operation is (was) in progress
    //

    if (RcOverlapped->FileHandle == NULL) {
	RcDbgPrint("GetAsyncResult : No operation in progress !\n");
	return(ERROR_NO_DATA);
    }


    //
    // Check the event is set - i.e that an IO operation has completed
    //

    WaitResult = WaitForSingleObject(RcOverlapped->Overlapped.hEvent, 0);
    if (WaitResult != 0) {
	RcDbgPrint("GetAsyncResult : Event was not set, wait result = %d\n", WaitResult);
	return(ERROR_IO_INCOMPLETE);
    }


    //
    // If the call completed synchronously, copy the data out of
    // our structure
    //

    if (RcOverlapped->CompletedSynchronously) {

	AsyncResult = RcOverlapped->CompletionCode;
	*BytesTransferred = RcOverlapped->BytesTransferred;

    } else {

	//
	// Go get the asynchronous result info from the system
	//

	AsyncResult = ERROR_SUCCESS;

	Result = GetOverlappedResult(RcOverlapped->FileHandle,
				     &RcOverlapped->Overlapped,
				     BytesTransferred,
				     FALSE);
	if (!Result) {
	    AsyncResult = GetLastError();
	    RcDbgPrint("GetAsyncResult : GetOverlappedResult failed, error = %d\n", AsyncResult);
	}
    }


    //
    // Reset the event so it doesn't trigger the caller again
    //

    Result = ResetEvent(RcOverlapped->Overlapped.hEvent);
    if (!Result) {
	RcDbgPrint("GetAsyncResult : Failed to reset async event\n");
    }


    //
    // Result the file handle so we know there is no pending operation
    //

    RcOverlapped->FileHandle = NULL;


    return(AsyncResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\rcmd\ntclient\rcmd.c ===
/****************************** Module Header ******************************\
* Module Name: rcmd.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Remote shell NT client main module
*
* History:
* 05-20-92 Davidc       Created.
* 05-01-94 DaveTh       Modified for remote command service (single cmd mode)
\***************************************************************************/

// #define UNICODE	// BUGBUG - Unicode support not complete

#include <nt.h>
#include <ntrtl.h>
#include <windef.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <assert.h>
#include <conio.h>

#include <rcmd.h>

#define PIPE_NAME   TEXT("%hs\\pipe\\rcmdsvc")
#define BUFFER_SIZE 1000
#define MAX_SERVER_NAME_LENGTH	15

//
// Globals
//

HANDLE PipeHandle = NULL;	    // These are used by Ctrl-C handler
BOOLEAN SessionConnected = FALSE;
BOOLEAN MultiServerMode = FALSE;
HANDLE ReadThreadHandle;
HANDLE WriteThreadHandle;

BOOLEAN RcDbgPrintEnable = FALSE;   // If TRUE, enables DbgPrint

LPTSTR    ServerName = NULL;	    // Name of remote server, for messages


//
// Private prototypes
//

DWORD
ReadThreadProc(
    LPVOID Parameter
    );

DWORD
WriteThreadProc(
    LPVOID Parameter
    );

BOOL
CtrlHandler(
    DWORD CtrlType
    );

int RcPrintf (
    const char *format,
    ...
    );

int RcDbgPrint (
    const char *format,
    ...
    );

void Usage(
    void
    );

long ParseCommandLine(
    LPTSTR lpszServer,
    COMMAND_HEADER *chCommandHeader,
    LPTSTR *aszArgv,
    int iArgc
    );


void
Usage(
    void
    )
/*++

Routine Description:

    Prints a usage message and exits the program

Arguments:

    None

Return Value:

    void

--*/
{
	RcPrintf("\nUsage: rcmd [server_name [command] ]\n\n");
	RcPrintf("Prompts for server_name if  not supplied.   Session is\n");
	RcPrintf("interactive and is terminated by ctrl-Break or Exit of\n");
	RcPrintf("remote shell.   Program is terminated by ctrl-Break or\n");
	RcPrintf("ctrl-C when no session is in progress.\n\n");
	RcPrintf("If no command supplied,  session is interactive and is\n");
	RcPrintf("terminated by ctrl-Break  or Exit  of remote cmd shell\n\n");
	RcPrintf("If command is supplied,  remote shell executes  single\n");
	RcPrintf("command on specified server and exits.\n\n");
	RcPrintf("Note : Command line server_name requires leading '\\\\'s\n");

    exit(0);
}



LONG ParseCommandLine(
    LPTSTR lpszServer,
    COMMAND_HEADER *chCommandHeader,
    LPTSTR *aszArgv,
    int iArgc
    )
/*++

Routine Description:

    Parses command line of the form:
    rcmd [server_name [[command] | ["command"]]

Arguments:

    lpszServer      - on exit gets the name of the server from the command line
    chCommandHeader - information to pass to rcmdsvc on exit
    aszArgv         - array of zero terminated strings (passed in from command line)
    iArgc           - number of strings in argv (passed in from command line)

Return Value:

    LONG

--*/
{

    LPTSTR buf = NULL;
    LONG nChars = 0;
    int i;

    //
    // get the first argument (either the server name or a [-/][?hH])
    //
    if (iArgc > 1)
    {
        //
        // convert argument to lower case
        //
        CharLowerBuff(aszArgv[1], lstrlen(aszArgv[1]));

        //
        // check for switch (only ?Hh are valid)
        //
        if ((*aszArgv[1] == TEXT('-')) ||
            (*aszArgv[1] == TEXT('/'))) {
            //
            // check the switch
            //
            if ( (aszArgv[1][1] == TEXT('h')) ||
                 (aszArgv[1][1] == TEXT('?')) ) {
                Usage();
            }
            else {
                RcPrintf(TEXT("Unknown switch %s\n"), aszArgv[1]);
                Usage();
            }
        }
        else if ( (*aszArgv[1] == TEXT('\\'))  && (aszArgv[1][1] == TEXT('\\'))) {
            //
            // first argument is a server name
            //
            lstrcpy(lpszServer, aszArgv[1]);
        }
        else {
            //
            // usage error
            //
            Usage();
        }

    }
    else {
        //
        // user failed to enter a server name
        // default to local machine
        //
        lstrcpy(lpszServer, "\\\\.");
    }

    //
    // If user entered anything beyond the server name, save it for passing to
    // to rcmdsvc.
    //

    // init
    chCommandHeader->CommandFixedHeader.CommandLength = 0;
    buf = chCommandHeader->Command;
    buf[0] = TEXT('\0');
    for (i = 2; i < iArgc; i++) {
        //
        // append each argument to saved command line
        //
        if (NULL != strchr(aszArgv[i], ' '))
        {
            nChars = wsprintf(buf, "\"%s\" ", aszArgv[i]);
        }
        else
        {
            nChars = wsprintf(buf, "%s ", aszArgv[i]);
        }
        buf += nChars;
        chCommandHeader->CommandFixedHeader.CommandLength += nChars;
    }
    //
    // in case we went too far, truncate the string
    //
    chCommandHeader->Command[MAX_CMD_LENGTH] = TEXT('\0');

    return (long)iArgc;
}



/***************************************************************************\
* FUNCTION: Main
*
* PURPOSE:  Main entry point.
*
* RETURNS:  0 on success, 1 on failure
*
* HISTORY:
*
*   07-10-92 Davidc       Created.
*
\***************************************************************************/

int
__cdecl main(
    int argc,
    char **argv
    )
{

    SECURITY_ATTRIBUTES SecurityAttributes;
    HANDLE StdInputHandle;
    HANDLE StdOutputHandle;
    HANDLE StdErrorHandle;
    CHAR  PipeName[MAX_PATH];
    //WCHAR  PipeName[MAX_PATH];
    DWORD ThreadId;
    HANDLE HandleArray[2];
    COMMAND_HEADER CommandHeader;
    RESPONSE_HEADER ResponseHeader;
    DWORD BytesWritten, BytesRead;
    DWORD Result;
    CHAR ServerNameBuffer[MAX_SERVER_NAME_LENGTH+3];  // +3 for gets counts, null
    CHAR FullServerNameBuffer[MAX_SERVER_NAME_LENGTH+3];  // +3 for "\\", null
    LONG nArgs = 0;
    BOOLEAN bBadServerName = TRUE;

    //
    // Install a handler for Ctrl-C
    //

    if (!SetConsoleCtrlHandler((PHANDLER_ROUTINE) &CtrlHandler, TRUE)) {
    	RcPrintf("Error:1 - Internal error = %d\n", GetLastError());
    	return(1);
    }

    //
    // Command line parsing
    //
    nArgs = ParseCommandLine(FullServerNameBuffer, &CommandHeader, argv, argc);
    ServerName = FullServerNameBuffer;

    if (nArgs == 1)  {
    	MultiServerMode = TRUE;
        ServerNameBuffer[0] = MAX_SERVER_NAME_LENGTH;
       	FullServerNameBuffer[0] = '\\';
        FullServerNameBuffer[1] = '\\';
        }

    //
    //  Loop for MultServerMode case (will return appropriately if not)
    //

    while (TRUE) {

        //
        //	If MultiServerMode, prompt for server name until it's right (enough)
        //
        while (MultiServerMode) {

            //
            //  BUGBUG - call netapi to validate server name
            //

            RcPrintf("\nEnter Server Name : ");
            FullServerNameBuffer[2] = '\0';  // re-terminate "\\" string
            ServerNameBuffer[0] = MAX_SERVER_NAME_LENGTH;
            ServerName = strcat(FullServerNameBuffer, _cgets(ServerNameBuffer));

            if (strlen(ServerName) < 3) {
                RcPrintf("\nError - Invalid Server Name\n");
            } else {
                break;	// valid name, go on
            }
        }


        //
        // Construct server pipe name
        //

        wsprintf(PipeName, PIPE_NAME, ServerName);


        //
        // Store away our normal i/o handles
        //

        if (((StdInputHandle = GetStdHandle(STD_INPUT_HANDLE)) == INVALID_HANDLE_VALUE) ||
            ((StdOutputHandle = GetStdHandle(STD_OUTPUT_HANDLE)) == INVALID_HANDLE_VALUE) ||
            ((StdErrorHandle = GetStdHandle(STD_ERROR_HANDLE)) == INVALID_HANDLE_VALUE))  {

            RcPrintf("Error:2 - Internal error = %d\n", GetLastError());
            return(1);  // catastrophic error - exit
        }


        //
        // Open the named pipe - need security flags to pass all privileges, not
        // just effective during impersonation
        //

        SecurityAttributes.nLength = sizeof(SecurityAttributes);
        SecurityAttributes.lpSecurityDescriptor = NULL; // Use default SD
        SecurityAttributes.bInheritHandle = FALSE;

        PipeHandle = CreateFile(PipeName,                     // pipe to server
                         GENERIC_READ | GENERIC_WRITE, // read/write
                         0,                            // No sharing
                         &SecurityAttributes,          // default Security Descriptor
                         OPEN_EXISTING,                // open existing pipe if it exists
                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED |
                         SECURITY_SQOS_PRESENT |
                         SECURITY_IMPERSONATION | SECURITY_CONTEXT_TRACKING,
                         NULL                       // Template file
                         );

        if (PipeHandle == INVALID_HANDLE_VALUE ) {
    	    Result = GetLastError();
    	    RcDbgPrint("Failed to open named pipe, error = %d\n", Result);

        	switch (Result) {

        	case ERROR_FILE_NOT_FOUND:
        	    RcPrintf("Error - Failed to connect to <%s>, system not found or service not active\n", ServerName);
        	    break;

        	case ERROR_PIPE_BUSY:
        	    RcPrintf("Error - Failed to connect to <%s>, remote command server busy\n", ServerName);
        	    break;

        	default:
        	    RcPrintf("Error - Failed to connect to <%s>, Error = %d\n", ServerName, GetLastError());

    	    }
            goto ServerError;
        }

        //
        //  Send command header - if single command mode, send command for
        //  excecute and return.  else 0 length indicates no command present
        //  Specify BASIC level support desired.
        //

        CommandHeader.CommandFixedHeader.Signature = RCMD_SIGNATURE;
        CommandHeader.CommandFixedHeader.RequestedLevel =
            RC_LEVEL_REQUEST | RC_LEVEL_BASIC;

        if (!WriteFile(
             PipeHandle,
    	     &CommandHeader,
    	     sizeof(CommandHeader.CommandFixedHeader) +
    		 CommandHeader.CommandFixedHeader.CommandLength,
    	     &BytesWritten,
    	     NULL ))  {
    	RcPrintf("Error - Failed to send to remote command server, Error = %ld\n", GetLastError());
    	goto ServerError;
        }

        //
        //  Get response header.  Will specify reported level or any error.
        //

        if ((!ReadFile(
    	    PipeHandle,
    	    &ResponseHeader,
    	    sizeof(ResponseHeader),
    	    &BytesRead,
    	    NULL)) || (BytesRead != sizeof(ResponseHeader)))  {

    	RcPrintf("Error - Remote command server failed to respond, Error = %ld\n", GetLastError());
    	goto ServerError;
        }

        if (ResponseHeader.Signature != RCMD_SIGNATURE)  {
    	RcPrintf("Error - Incompatible remote command server\n");
    	goto ServerError;
        }

        //
        //  Check for returned errors or supported level
        //

        if (!(ResponseHeader.SupportedLevel ==
    	    (RC_LEVEL_RESPONSE | RC_LEVEL_BASIC)))  {

    	if (ResponseHeader.SupportedLevel & RC_ERROR_RESPONSE)  {

    	    //
    	    //  Error returned
    	    //

    	    switch  (ResponseHeader.SupportedLevel & ~RC_ERROR_RESPONSE)	 {

    	    case ERROR_ACCESS_DENIED:
    		RcPrintf("Error - You have insufficient access on the remote system\n");
    		break;

    	    default:
    		RcPrintf("Error - Failed to establish remote session, Error = %d\n",
    		    (ResponseHeader.SupportedLevel & ~RC_ERROR_RESPONSE));
    		break;

    	    } //switch

    	    goto ServerError;

    	} else if (ResponseHeader.SupportedLevel & RC_LEVEL_RESPONSE)  {

    	    //
    	    //  Supported level returned - but not a valid value (not BASIC)
    	    //

    	    RcPrintf("Error - Invalid support level returned\n");
    	    goto ServerError;

    	}  else  {

    	    //
    	    //  Neither error nor supported level returned
    	    //

    	    RcPrintf("Error - Invalid response from remote server\n");
    	    goto ServerError;

    	}
        }

        //
        // All is well - Session is connected
        //

        SessionConnected = TRUE;

        if (CommandHeader.CommandFixedHeader.CommandLength == 0) {
            RcPrintf("Connected to %s\n\n", ServerName);
        } else {
            RcPrintf("Executing on %s: %s\n\n", ServerName, CommandHeader.Command);
        }

        //
        // Exec 2 threads - 1 copies data from stdin to pipe, the other
        // copies data from the pipe to stdout.
        //

        ReadThreadHandle = CreateThread(
    			NULL,                       // Default security
    			0,                          // Default Stack size
    			(LPTHREAD_START_ROUTINE) ReadThreadProc,
    			(PVOID)PipeHandle,
    			0,
    			&ThreadId);

        if (ReadThreadHandle == NULL) {
    	RcPrintf("Error:3 - Internal error = %ld\n", GetLastError());
    	return(1);  // catastrophic error - exit
        }


        //
        // Create the write thread
        //

        WriteThreadHandle = CreateThread(
    			NULL,                       // Default security
    			0,                          // Default Stack size
    			(LPTHREAD_START_ROUTINE) WriteThreadProc,
    			(PVOID)PipeHandle,
    			0,
    			&ThreadId);

        if (WriteThreadHandle == NULL) {
    	RcPrintf("Error:4 - Internal error = %ld\n", GetLastError());
    	TerminateThread(ReadThreadHandle, 0);
    	CloseHandle(ReadThreadHandle);
    	return(1);  // catastrophic error, exit
        }



        //
        // Wait for either thread to finish
        //

        HandleArray[0] = ReadThreadHandle;
        HandleArray[1] = WriteThreadHandle;

        Result = WaitForMultipleObjects(
    			    2,
    			    HandleArray,
    			    FALSE,              // Wait for either to finish
    			    0xffffffff
    			   );			// Wait forever

        //
        //	Finished - terminate other thread and close pipe handle
        //


        if (Result == (WAIT_OBJECT_0 + 0))	{    // Read thread finished - terminate write
    	TerminateThread(WriteThreadHandle, 0);
        }

        if (Result == (WAIT_OBJECT_0 + 1))	{    // Write thread finished - terminate read
    	TerminateThread(ReadThreadHandle, 0);
        }

        RcDbgPrint("Read or write thread terminated\n");


        //
        // Close our pipe handle
        //

        CloseHandle(PipeHandle);
        PipeHandle = NULL;


        //
        //	Re-enable normal ctrl-C processing
        //

        SessionConnected = FALSE;

        //
        //	Normal completion - return if not MultServerMode
        //

        if (!MultiServerMode)  {
            //
            // return - process exit will terminate threads and close thread handles
            //
            return(1);
        }

ServerError:

        if (PipeHandle != NULL) {
            CloseHandle(PipeHandle);
        }

        if (!MultiServerMode) {
            //
            //  return false on error - process exit terminates threads/closes handles
            //
            return(0);
        }

        //
        //	Multi-service mode exits occurs with ctrl-C/break only
        //
    }

}


/***************************************************************************\
* FUNCTION: ReadPipe
*
* PURPOSE:  Implements an overlapped read such that read and write operations
*           to the same pipe handle don't deadlock.
*
* RETURNS:  TRUE on success, FALSE on failure (GetLastError() has error)
*
* HISTORY:
*
*   05-27-92 Davidc       Created.
*
\***************************************************************************/

BOOL
ReadPipe(
    HANDLE PipeHandle,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead
    )
{
    DWORD Result;
    OVERLAPPED Overlapped;
    HANDLE  EventHandle;
    DWORD Error;

    //
    // Create an event for the overlapped operation
    //

    EventHandle = CreateEvent(
			      NULL,         // no security
			      TRUE,         // Manual reset
			      FALSE,        // Initial state
			      NULL          // Name
			     );
    if (EventHandle == NULL) {
	RcDbgPrint("ReadPipe: CreateEvent failed, error = %d\n", GetLastError());
	return(FALSE);
    }

    Overlapped.hEvent = EventHandle;
    Overlapped.Internal = 0;
    Overlapped.InternalHigh = 0;
    Overlapped.Offset = 0;
    Overlapped.OffsetHigh = 0;


    Result = ReadFile(
		      PipeHandle,
		      lpBuffer,
		      nNumberOfBytesToRead,
		      lpNumberOfBytesRead,
		      &Overlapped
		     );
    if (Result) {

	//
	// Success without waiting - it's too easy !
	//

	CloseHandle(EventHandle);

    } else {

	//
	// Read failed, if it's overlapped io, go wait for it
	// If failure due to server, print appropriate message.
	//

	Error = GetLastError();

	switch (Error)  {

	case ERROR_IO_PENDING:
	    break;

	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_BROKEN_PIPE:
	    RcPrintf("\nRemote server %s disconnected\n", ServerName);
	    CloseHandle(EventHandle);
	    return(FALSE);

	default:
	    RcPrintf("Error:5 - Internal error = %d\n", Error);
	    RcDbgPrint("ReadPipe: ReadFile failed, error = %d\n", Error);
	    CloseHandle(EventHandle);
	    return(FALSE);

	}

	//
	// Wait for the I/O to complete
	//

	Result = WaitForSingleObject(EventHandle, (DWORD)-1);
	if (Result != 0) {
	    RcDbgPrint("ReadPipe: event wait failed, result = %d, last error = %d\n", Result, GetLastError());
	    CloseHandle(EventHandle);
	    return(FALSE);
	}

	//
	// Go get the I/O result
	//

	Result = GetOverlappedResult( PipeHandle,
				      &Overlapped,
				      lpNumberOfBytesRead,
				      FALSE
				    );
	//
	// We're finished with the event handle
	//

	CloseHandle(EventHandle);

	//
	// Check result of GetOverlappedResult
	//

	if (!Result) {
	    Error = GetLastError();

	    switch (Error)  {

	    case ERROR_PIPE_NOT_CONNECTED:
	    case ERROR_BROKEN_PIPE:
		RcPrintf("\nRemote server %s disconnected\n", ServerName);
		return(FALSE);

	    default:
		RcPrintf("Error:9 - Internal error = %d\n", Error);
		RcDbgPrint("ReadPipe: GetOverLappedRsult failed, error = %d\n", Error);
		return(FALSE);
	    }

	}
    }

    return(TRUE);
}


/***************************************************************************\
* FUNCTION: WritePipe
*
* PURPOSE:  Implements an overlapped write such that read and write operations
*           to the same pipe handle don't deadlock.
*
* RETURNS:  TRUE on success, FALSE on failure (GetLastError() has error)
*
* HISTORY:
*
*   05-27-92 Davidc       Created.
*
\***************************************************************************/

BOOL
WritePipe(
    HANDLE PipeHandle,
    CONST VOID *lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten
    )
{
    DWORD Result;
    OVERLAPPED Overlapped;
    HANDLE  EventHandle;
    DWORD Error;

    //
    // Create an event for the overlapped operation
    //

    EventHandle = CreateEvent(
			      NULL,         // no security
			      TRUE,         // Manual reset
			      FALSE,        // Initial state
			      NULL          // Name
			     );
    if (EventHandle == NULL) {
	RcDbgPrint("WritePipe: CreateEvent failed, error = %d\n", GetLastError());
	return(FALSE);
    }

    Overlapped.hEvent = EventHandle;
    Overlapped.Internal = 0;
    Overlapped.InternalHigh = 0;
    Overlapped.Offset = 0;
    Overlapped.OffsetHigh = 0;

    Result = WriteFile(
		      PipeHandle,
		      lpBuffer,
		      nNumberOfBytesToWrite,
		      lpNumberOfBytesWritten,
		      &Overlapped
		     );
    if (Result) {

	//
	// Success without waiting - it's too easy !
	//

	CloseHandle(EventHandle);

    } else {

	//
	// Write failed, if it's overlapped io, go wait for it
	// If failure due to server, print appropriate message.
	//

	Error = GetLastError();

	switch (Error)  {

	case ERROR_IO_PENDING:
	    break;

	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_BROKEN_PIPE:
	    RcPrintf("\nRemote server %s disconnected\n", ServerName);
	    CloseHandle(EventHandle);
	    return(FALSE);

	default:
	    RcPrintf("Error:6 - Internal error = %d\n", Error);
	    RcDbgPrint("WritePipe: WriteFile failed, error = %d\n", Error);
	    CloseHandle(EventHandle);
	    return(FALSE);

	}

	//
	// Wait for the I/O to complete
	//

	Result = WaitForSingleObject(EventHandle, (DWORD)-1);
	if (Result != 0) {
	    RcDbgPrint("WritePipe: event wait failed, result = %d, last error = %d\n", Result, GetLastError());
	    CloseHandle(EventHandle);
	    return(FALSE);
	}

	//
	// Go get the I/O result
	//

	Result = GetOverlappedResult( PipeHandle,
				      &Overlapped,
				      lpNumberOfBytesWritten,
				      FALSE
				    );
	//
	// We're finished with the event handle
	//

	CloseHandle(EventHandle);

	//
	// Check result of GetOverlappedResult
	//

	if (!Result) {
	    Error = GetLastError();

	    switch (Error)  {

	    case ERROR_PIPE_NOT_CONNECTED:
	    case ERROR_BROKEN_PIPE:
		RcPrintf("\nRemote server %s disconnected\n", ServerName);
		return(FALSE);

	    default:
		RcPrintf("Error:10 - Internal error = %d\n", Error);
		RcDbgPrint("WritePipe: GetOverLappedRsult failed, error = %d\n", Error);
		return(FALSE);
	    }
	}
    }

    return(TRUE);
}


/***************************************************************************\
* FUNCTION: ReadThreadProc
*
* PURPOSE:  The read thread procedure. Reads from pipe and writes to STD_OUT
*
* RETURNS:  Nothing
*
* HISTORY:
*
*   05-21-92 Davidc       Created.
*
\***************************************************************************/

DWORD
ReadThreadProc(
    LPVOID Parameter
    )
{
    HANDLE  PipeHandle = Parameter;
    BYTE    Buffer[BUFFER_SIZE];
    DWORD   BytesRead;
    DWORD   BytesWritten;

    while (ReadPipe(PipeHandle, Buffer, sizeof(Buffer), &BytesRead)) {
		if (!WriteFile(
			    GetStdHandle(STD_OUTPUT_HANDLE),
			    Buffer,
			    BytesRead,
			    &BytesWritten,
			    NULL
			    )) {

		    RcPrintf("Error:7 - Internal error = %d\n", GetLastError());
		    RcDbgPrint("ReadThreadProc exitting, WriteFile error = %d\n",
		       GetLastError());
		    ExitThread((DWORD)0);
		    assert(FALSE);  // Should never get here
		    break;
		}
    }

    //
    //	ReadPipe issues more error information to user, debugger
    //	falls through here on read error
    //

    RcDbgPrint("WriteThreadProc exitting, ReadPipe failed\n");

    ExitThread((DWORD)0);

    return(0);
}


/***************************************************************************\
* FUNCTION: WriteThreadProc
*
* PURPOSE:  The write thread procedure. Reads from STD_INPUT and writes to pipe
*
* RETURNS:  Nothing
*
* HISTORY:
*
*   05-21-92 Davidc       Created.
*
\***************************************************************************/

DWORD
WriteThreadProc(
    LPVOID Parameter
    )
{
    HANDLE PipeHandle = Parameter;
    BYTE    Buffer[BUFFER_SIZE];
    DWORD   BytesRead;
    DWORD   BytesWritten;
    DWORD   Result;

    while (ReadFile(
		    GetStdHandle(STD_INPUT_HANDLE),
		    Buffer,
		    sizeof(Buffer),
		    &BytesRead,
		    NULL
		   )) {

	if ((DWORD)Buffer[0] == 0x0A0D0A0D)  {
	    RcPrintf("\nDouble crlf sent\n");
	    }

	if (!WritePipe(
		    PipeHandle,
		    Buffer,
		    BytesRead,
		    &BytesWritten
		 )) {

		//
		//  WritePipe issues more error information to user, debugger
		//

		RcDbgPrint("WriteThreadProc exitted due to WritePipe\n");
		ExitThread((DWORD)0);
		break;

	}
    }

    //
    //	Falls out if read fails
    //

    RcDbgPrint("WriteThreadProc, ReadFile error = %d\n", GetLastError());

    RcPrintf("Error:8 - Internal error = %d\n", GetLastError());
    ExitThread((DWORD)0);

    return(0);
}


/***************************************************************************\
* FUNCTION: CtrlHandler
*
* PURPOSE:  Handles console event notifications.
*
* RETURNS:  TRUE if the event has been handled, otherwise FALSE.
*
* HISTORY:
*
*   05-21-92 Davidc       Created.
*
\***************************************************************************/

BOOL
CtrlHandler(
    DWORD CtrlType
    )
{
    //
    // We'll handle Ctrl-C, Ctl-Break events if session is connected
    //

    if (SessionConnected)  {

	if (CtrlType == CTRL_C_EVENT)  {

	    //
	    //	Session established - pass ctl-C to remote server
	    //

	    if (PipeHandle != NULL) {

		//
		// Send a Ctrl-C to the server, don't care if it fails
		//

		CHAR	CtrlC = '\003';
		DWORD	BytesWritten;

		WriteFile(PipeHandle,
		      &CtrlC,
		      sizeof(CtrlC),
		      &BytesWritten,
		      NULL
		     );

		return(TRUE);  // we handled it
	    }

	    return(FALSE);  // no pipe - not handled (when in doubt, bail out)

	}  else if (CtrlType == CTRL_BREAK_EVENT)  {

	    if (MultiServerMode)  {

		//
		//   If ctl-Break in session w/MultiServerMode, break session
		//   BUGBUG - eliminate terminate thread
		//

		TerminateThread(ReadThreadHandle, 0);
		CloseHandle(ReadThreadHandle);
		TerminateThread(WriteThreadHandle, 0);
		CloseHandle(WriteThreadHandle);

		return(TRUE);  // we handled it

	    }  else  {

		//
		//  Not MultiServer mode - handle normally
		//

		return(FALSE);
	    }

	}  else {

	    return(FALSE);  // not ctl-c or break - we didn't handle it

	}

    }

    //
    // Not connected - we didn't handle it
    //

    return(FALSE);
}


/***************************************************************************\
* FUNCTION: RcPrintf
*
* PURPOSE:  Printf that uses low-level io.
*
* HISTORY:
*
*   07-15-92 Davidc       Created.
*
\***************************************************************************/

int RcPrintf (
    const char *format,
    ...
    )
{
    CHAR Buffer[MAX_PATH];
    va_list argpointer;
    int Result;
    DWORD BytesWritten;

    va_start(argpointer, format);

    Result = vsprintf(Buffer, format, argpointer);

    if (!WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), Buffer, Result, &BytesWritten, NULL)) {
	RcDbgPrint("RcPrintf : Write file to stdout failed, error = %d\n", GetLastError());
	Result = 0;
    }

    va_end(argpointer);

    return(Result);
}

/***************************************************************************\
* FUNCTION: RcDbgPrint
*
* PURPOSE:  DbgPrint enabled at runtime by setting RcDbgPrintEnable
*
* HISTORY:
*
*   05-22-92 DaveTh   Created.
*
\***************************************************************************/

int RcDbgPrint (
    const char *format,
    ...
    )
{
    CHAR Buffer[MAX_PATH];
    va_list argpointer;
    int iRetval = 0;

    if (RcDbgPrintEnable)  {

        va_start(argpointer, format);
        iRetval = vsprintf(Buffer, format, argpointer);
        assert (iRetval >= 0);
        va_end(argpointer);
        OutputDebugString(Buffer);

    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\rcmd\inc\rcmd.h ===
/****************************** Module Header ******************************\
* Module Name: rcmd.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Remote shell common header module
*
* History:
* 05-2-94 DaveTh	Created.
\***************************************************************************/

#define MAX_CMD_LENGTH 500

typedef struct {
    DWORD   Signature;			// Identifies Remote Command Service
    DWORD   RequestedLevel;		// Level of functionality desired
    ULONG   CommandLength;		// Length of command.
} COMMAND_FIXED_HEADER, *PCOMMAND_FIXED_HEADER;

typedef struct {
    COMMAND_FIXED_HEADER CommandFixedHeader;
    UCHAR   Command[MAX_CMD_LENGTH+1];	// Present if CommandLength non-zero
					// Not zero terminated, but +1 allows
					// for local use with string
} COMMAND_HEADER, *PCOMMAND_HEADER;


typedef struct {
    DWORD   Signature;
    DWORD   SupportedLevel;		// Level or Error Response
} RESPONSE_HEADER, *PRESPONSE_HEADER;

#define RCMD_SIGNATURE 'RC94'

//
// SupportedLevel is Error response if RC_ERROR_RESPONSE
//

#define RC_ERROR_RESPONSE	      0x80000000L

//
// SupportedLevel is Level response if RC_LEVEL_RESPONSE
//

#define RC_LEVEL_RESPONSE    0x40000000L
#define RC_LEVEL_REQUEST     0x40000000L

#define RC_LEVEL_BASIC	     0x00000001L  // Basic functionality - stdin/out only

void print_help();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\rcmd\server\lsautil.h ===
/****************************** Module Header ******************************\
* Module Name: lsautil.h
*
* Copyright (c) 1994, Microsoft Corporation
*
* Defines functions exported by pipe.c
*
* History:
* 05-20-94 DaveTh	 Created.
\***************************************************************************/

#include <ntlsa.h>

//
// Function prototypes
//

DWORD
CheckUserSystemAccess(
    HANDLE TokenHandle,
    ULONG DesiredSystemAccess,
    PBOOLEAN UserHasAccess
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\rcmd\server\lsautil.c ===
/****************************** Module Header ******************************\
* Module Name: lsautil.c
*
* Copyright (c) 1994, Microsoft Corporation
*
* Remote shell server main module
*
* History:
* 05-19-94 DaveTh	Created.
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <ntlsa.h>
#include <windef.h>
#include <nturtl.h>
#include <winbase.h>

#include "rcmdsrv.h"

#define INITIAL_SIZE_REQUIRED 600

DWORD
CheckUserSystemAccess(
    HANDLE TokenHandle,
    ULONG DesiredSystemAccess,
    PBOOLEAN UserHasAccess
    )

/*++

Routine Description:

    This function determines whether or not the user whose token is passed
    has the interactive accesses desired on this machine.

Arguments:

    TokenHandle - Handle of user's token.

    DesiredSystemAccess - Specifies desired access type(s).

    UserHasAccess - pointer to boolean returned - TRUE means that user
	has interactive access.

Return Value:

    ERROR_SUCCESS in absence of errors.  UserHasAccess is TRUE if all
    requested access types are permitted, otherwise FALSE.  WIN32 errors
    are returned in error cases.

--*/
{


    DWORD Result;
    LPVOID LpTokenUserInformation = NULL;
    LPVOID LpTokenGroupInformation = NULL;
    DWORD SizeRequired, SizeProvided;
    LSA_HANDLE PolicyHandle = NULL;
    LSA_HANDLE AccountHandle = NULL;
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    POBJECT_ATTRIBUTES LpObjectAttributes;
    ULONG GrantedSystemAccess, SidSystemAccess;
    DWORD i;


    //
    //	Access LSA policy database
    //

    LpObjectAttributes = &ObjectAttributes;

    InitializeObjectAttributes(
	      LpObjectAttributes,
	      NULL,
	      0,
	      NULL,
	      NULL);

    if (!NT_SUCCESS(NtStatus = LsaOpenPolicy(
				   NULL,		   // Local system
				   LpObjectAttributes,
				   GENERIC_READ,
				   &PolicyHandle)))  {

	RcDbgPrint("Error opening policy database, error = %x\n", NtStatus);
	Result = RtlNtStatusToDosError(NtStatus);
	goto Failure;
    }

    //
    //	Check groups, user - For each SID, open the account (if it exists).
    //	If it doesn't exist, no failure, but no access (FALSE).	If it
    //	does exist, accumulate granted accesses in and compare to
    //	requested mask.	If all the bits of the mask have been set at any
    //	point, UserHasAccess is set TRUE.  Otherise, it is left FALSE.
    //

    *UserHasAccess = FALSE;
    GrantedSystemAccess = 0;

    //
    //	Get list of SIDs of groups of which user is a member
    //

    if ((LpTokenGroupInformation = Alloc(INITIAL_SIZE_REQUIRED)) == NULL)  {
	Result = GetLastError();
	goto Failure;
    }

    if (!GetTokenInformation (
			TokenHandle,
			TokenGroups,
			LpTokenGroupInformation,
			INITIAL_SIZE_REQUIRED,
			&SizeRequired))  {

	Result = GetLastError();
	if ( (Result == ERROR_MORE_DATA) || (Result == ERROR_INSUFFICIENT_BUFFER) )	{

	    Free(LpTokenGroupInformation);

	    if ((LpTokenGroupInformation = Alloc(SizeRequired)) == NULL)  {
		Result = GetLastError();
		goto Failure;
	    }

	    SizeProvided = SizeRequired;

	    if (!GetTokenInformation (
			TokenHandle,
			TokenGroups,
			LpTokenGroupInformation,
			SizeProvided,
			&SizeRequired))  {

		Result=GetLastError();
		RcDbgPrint("Error accessing group SIDs, error = %d\n", Result);
		goto Failure;
	    }

	}  else {
	    RcDbgPrint("Error accessing group SIDs, error = %d\n", Result);
	    goto Failure;

	}

    }

    //
    //	Check for each group that user is a member of since groups
    //	are most likely source of permitted access.  Permitted access types
    //	are cumulative.
    //


    for (i=0; i< ((PTOKEN_GROUPS)LpTokenGroupInformation)->GroupCount; i++)  {

	if (NT_SUCCESS(NtStatus = LsaOpenAccount(
		    PolicyHandle,
		    ((PTOKEN_GROUPS)LpTokenGroupInformation)->Groups[i].Sid,
		    GENERIC_READ,
		    &AccountHandle)))  {

	    //
	    //	found account - accumulate and check accesses
	    //

	    if (!NT_SUCCESS(NtStatus = LsaGetSystemAccessAccount (
					    AccountHandle,
					    &SidSystemAccess)))	{

		RcDbgPrint("Error getting group account access, error = %x\n", NtStatus);
		Result = RtlNtStatusToDosError(NtStatus);
		goto Failure;

	    }  else  {

		//
		// Got system access - don't need account handle anymore
		//

		if (NT_SUCCESS(NtStatus = LsaClose(AccountHandle)))  {

		    AccountHandle = NULL;

		}  else  {

		    RcDbgPrint("Error closing account handle, error = %x\n", NtStatus);
		    Result = RtlNtStatusToDosError(NtStatus);
		    goto Failure;
		}


		GrantedSystemAccess |= SidSystemAccess;;

		if ((GrantedSystemAccess & DesiredSystemAccess) == DesiredSystemAccess)	{
		    *UserHasAccess = TRUE;
		    goto Success;
		}
	    }

	}  else if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND)  {
	    RcDbgPrint("Error opening group account, error = %x\n", NtStatus);
	    Result = RtlNtStatusToDosError(NtStatus);
	    goto Failure;
	}

    }

    //
    //	Get user SID
    //

    if ((LpTokenUserInformation = Alloc(INITIAL_SIZE_REQUIRED)) == NULL)  {
	Result = GetLastError();
	goto Failure;
    }

    if (!GetTokenInformation (
			TokenHandle,
			TokenUser,
			LpTokenUserInformation,
			INITIAL_SIZE_REQUIRED,
			&SizeRequired))  {

	Result = GetLastError();
	if (Result == ERROR_MORE_DATA)	{   // Not enough - alloc and redo

	    Free(LpTokenUserInformation);

	    if ((LpTokenUserInformation = Alloc(SizeRequired)) == NULL)  {
		Result = GetLastError();
		goto Failure;
	    }

	    SizeProvided = SizeRequired;

	    if (!GetTokenInformation (
			TokenHandle,
			TokenUser,
			LpTokenUserInformation,
			SizeProvided,
			&SizeRequired))  {

		RcDbgPrint("Error accessing user SID, error = %d\n", Result);
		Result=GetLastError();
		goto Failure;
	    }

	}  else {
	    RcDbgPrint("Error accessing user SID, error = %d\n", Result);
	    goto Failure;

	}
    }

    //
    //	Now, check user account.  If present, check access and return
    //	if requested access is allowed.  If not allowed, go on to check groups.
    //	If account doesn't exist, go on to check groups.
    //

    if (NT_SUCCESS(NtStatus = LsaOpenAccount(
				  PolicyHandle,
				  ((PTOKEN_USER)LpTokenUserInformation)->User.Sid,
				  GENERIC_READ,
				  &AccountHandle)))  {

	//
	//  found account - check accesses
	//

	if (!NT_SUCCESS(NtStatus = LsaGetSystemAccessAccount (
					AccountHandle,
					&GrantedSystemAccess)))	{

	    RcDbgPrint("Error getting group account access, error = %x\n", NtStatus);
	    Result = RtlNtStatusToDosError(NtStatus);
	    goto Failure;

	}  else  {

	    GrantedSystemAccess |= SidSystemAccess;;

	    if ((GrantedSystemAccess & DesiredSystemAccess) == DesiredSystemAccess)	{
		*UserHasAccess = TRUE;
		goto Success;
	    }
	}

    }  else if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND)  {
	RcDbgPrint("Error opening user account, error = %x\n", NtStatus);
	Result = RtlNtStatusToDosError(NtStatus);
	goto Failure;
    }

    //
    //	Success - Jump here if access granted, fall through here on no error
    //

Success:

    Result = ERROR_SUCCESS;


    //
    //	General failure  and success exit - frees memory, closes handles
    //

Failure:

    if (LpTokenGroupInformation != NULL)  {
	Free(LpTokenGroupInformation);
    }

    if (LpTokenUserInformation != NULL)  {
	Free(LpTokenGroupInformation);
    }

    if ((PolicyHandle != NULL) &&
	    (!NT_SUCCESS(NtStatus = LsaClose(PolicyHandle))))  {
	RcDbgPrint("Error closing policy handle at exit, error = %x\n", NtStatus);
	Result = RtlNtStatusToDosError(NtStatus);
    }

    if ((AccountHandle != NULL) &&
	    (!NT_SUCCESS(NtStatus = LsaClose(AccountHandle))))	{
	RcDbgPrint("Error closing account handle at exit, error = %x\n", NtStatus);
	Result = RtlNtStatusToDosError(NtStatus);
    }

    return(Result);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\rcmd\server\async.h ===
/****************************** Module Header ******************************\
* Module Name: async.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Defines types and functions used by async module.
*
* History:
* 06-29-92 Davidc       Created.
\***************************************************************************/


//
// Function prototypes
//

HANDLE
CreateAsync(
    BOOL    InitialState
    );

VOID
DeleteAsync(
    HANDLE AsyncHandle
    );

BOOL
ReadFileAsync(
    HANDLE  hFile,
    LPVOID  lpBuffer,
    DWORD   nBytesToRead,
    HANDLE  AsyncHandle
    );

BOOL
WriteFileAsync(
    HANDLE  hFile,
    LPVOID  lpBuffer,
    DWORD   nBytesToWrite,
    HANDLE  AsyncHandle
    );

HANDLE
GetAsyncCompletionHandle(
    HANDLE  AsyncHandle
    );

DWORD
GetAsyncResult(
    HANDLE  AsyncHandle,
    LPDWORD BytesTransferred
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\rcmd\server\rcmdsrv.h ===
/****************************** Module Header ******************************\
* Module Name: rcmdsrv.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Main include file for remote shell server
*
* History:
* 06-28-92 Davidc       Created.
\***************************************************************************/

// #define UNICODE	// BUGBUG - Not completely unicode yet

#include <windows.h>
#include <stdio.h>
#include <assert.h>
#include <rcmd.h>
#include <lsautil.h>
//
// Macros
//

#define RcCloseHandle(Handle, handle_name) \
        if (CloseHandle(Handle) == FALSE) { \
	    RcDbgPrint("Close Handle failed for <%s>, error = %d\n", handle_name, GetLastError()); \
            assert(FALSE); \
        }

#define Alloc(Bytes)            LocalAlloc(LPTR, Bytes)
#define Free(p)                 LocalFree(p)

//
//  Maximum number of connected clients
//

#define MAX_SESSIONS	10

//
// main server routine if built as service
//

int Rcmd ( );

//
// service stop routine
//

DWORD RcmdStop ( );

//
//  Runtime-enabled DbgPrint
//

int RcDbgPrint (
    const char *format,
    ...
    );


extern HANDLE RcmdStopEvent;
extern HANDLE RcmdStopCompleteEvent;
extern HANDLE SessionThreadHandles[MAX_SESSIONS+1];
// extern BOOLEAN RcDbgPrintEnable;

//
// Module header files
//

#include "session.h"
#include "async.h"
#include "pipe.h"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\rcmd\server\pipe.c ===
/****************************** Module Header ******************************\
* Module Name: pipe.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* This module implements:
*   1. a version of CreatePipe that allows control over the file
*      flags. e.g. FILE_FLAG_OVERLAPPED
*   2. Timed-out pipe read and write
*
* History:
* 06-29-92 Davidc	Created.
* 05-17-94 DaveTh	Added ReadPipe, WritePipe.
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <windef.h>
#include <nturtl.h>
#include <winbase.h>
#include "rcmdsrv.h"


ULONG PipeSerialNumber = 0;

#define PIPE_FORMAT_STRING  "\\\\.\\pipe\\rshsrv\\%08x.%08x"



/////////////////////////////////////////////////////////////////////////////
//
// RcCreatePipe
//
// Creates a uni-directional pipe with the specified security attributes,
// size and timeout. The handles are opened with the specified file-flags
// so FILE_FLAG_OVERLAPPED etc. can be specified.
//
// Returns handles to both end of pipe in passed parameters.
//
// Returns TRUE on success, FALSE on failure. (GetLastError() for details)
//
/////////////////////////////////////////////////////////////////////////////

BOOL
RcCreatePipe(
    LPHANDLE ReadHandle,
    LPHANDLE WriteHandle,
    LPSECURITY_ATTRIBUTES SecurityAttributes,
    DWORD Size,
    DWORD Timeout,
    DWORD ReadHandleFlags,
    DWORD WriteHandleFlags
    )
{
    CHAR PipeName[MAX_PATH];

    //
    // Make up a random pipe name
    //

    sprintf(PipeName, PIPE_FORMAT_STRING, GetCurrentProcessId(), PipeSerialNumber++);


    //
    // Create the pipe
    //

    *ReadHandle = CreateNamedPipeA(
			PipeName,
			PIPE_ACCESS_INBOUND | ReadHandleFlags,
			PIPE_TYPE_BYTE | PIPE_WAIT,
			1,             // Number of pipes
			Size,          // Out buffer size
			Size,          // In buffer size
			Timeout,       // Timeout in ms
			SecurityAttributes
		      );

    if (*ReadHandle == NULL) {
	RcDbgPrint("RcCreatePipe: failed to created pipe <%s>, error = %d\n", PipeName, GetLastError());
	return(FALSE);
    }

    //
    // Open the client end of the pipe
    //


    *WriteHandle = CreateFileA(
			PipeName,
			GENERIC_WRITE,
			0,                         // No sharing
			SecurityAttributes,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL | WriteHandleFlags,
			NULL                       // Template file
		      );

    if (*WriteHandle == INVALID_HANDLE_VALUE ) {
	RcDbgPrint("Failed to open client end of pipe <%s>, error = %d\n", PipeName, GetLastError());
	RcCloseHandle(*ReadHandle, "async pipe (server(read) side)");
	return(FALSE);
    }


    //
    // Everything succeeded
    //

    return(TRUE);
}



/***************************************************************************\
* FUNCTION: ReadPipe
*
* PURPOSE:  Implements a timed-out (ms) read on a pipe.
*
* RETURNS:  ERROR_SUCCESS on success
*	    WAIT_TIMEOUT if timed out before completing read
*	    or respective error code on other failures
*
* HISTORY:
*
*   05-17-94 DaveTh	 Created from DavidC read pipe.
*
\***************************************************************************/

DWORD
ReadPipe(
    HANDLE PipeHandle,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    DWORD Timeout
    )
{
    DWORD Result;
    OVERLAPPED Overlapped;
    HANDLE  EventHandle;
    DWORD Error;

    //
    // Create an event for the overlapped operation
    //

    EventHandle = CreateEvent(
                              NULL,         // no security
                              TRUE,         // Manual reset
                              FALSE,        // Initial state
                              NULL          // Name
                             );
    if (EventHandle == NULL) {
	RcDbgPrint("Internal error = %d\n", GetLastError());
	return(GetLastError());
    }

    Overlapped.hEvent = EventHandle;

    Result = ReadFile(
                      PipeHandle,
                      lpBuffer,
                      nNumberOfBytesToRead,
                      lpNumberOfBytesRead,
                      &Overlapped
                     );
    if (Result) {

        //
        // Success without waiting - it's too easy !
        //

        CloseHandle(EventHandle);

    } else {

        //
        // Read failed, if it's overlapped io, go wait for it
        //

        Error = GetLastError();

        if (Error != ERROR_IO_PENDING) {
	    RcDbgPrint("ReadPipe: ReadFile failed, error = %d\n", Error);
            CloseHandle(EventHandle);
	    return(Error);
        }

        //
        // Wait for the I/O to complete
        //

	Result = WaitForSingleObject(EventHandle, Timeout);
	if (Result != WAIT_OBJECT_0) {
	    if (Result == WAIT_TIMEOUT)  {
		return(Result);
	    }  else  {
		RcDbgPrint("ReadPipe: event wait failed, result = %d, last error = %d\n", Result, GetLastError());
	    }
	    CloseHandle(EventHandle);
	}

        //
        // Go get the I/O result
        //

        Result = GetOverlappedResult( PipeHandle,
                                      &Overlapped,
                                      lpNumberOfBytesRead,
                                      FALSE
                                    );
        //
        // We're finished with the event handle
        //

        CloseHandle(EventHandle);

        //
        // Check result of GetOverlappedResult
        //

        if (!Result) {
	    RcDbgPrint("ReadPipe: GetOverlappedResult failed, error = %d\n", GetLastError());
	    return(GetLastError());
        }
    }

    return(ERROR_SUCCESS);
}

/***************************************************************************\
* FUNCTION: WritePipe
*
* PURPOSE:  Implements a timed-out (ms) write on a pipe.
*
* RETURNS:  ERROR_SUCCESS on success
*	    WAIT_TIMEOUT if timed out before completing write
*	    or respective error code on other failures
*
* HISTORY:
*
*   05-22-94 DaveTh	 Created.
*
\***************************************************************************/

DWORD
WritePipe(
    HANDLE PipeHandle,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    DWORD Timeout
    )
{
    DWORD Result;
    OVERLAPPED Overlapped;
    HANDLE  EventHandle;
    DWORD Error;

    //
    // Create an event for the overlapped operation
    //

    EventHandle = CreateEvent(
                              NULL,         // no security
                              TRUE,         // Manual reset
                              FALSE,        // Initial state
                              NULL          // Name
                             );
    if (EventHandle == NULL) {
	RcDbgPrint("Internal error = %d\n", GetLastError());
	return(GetLastError());
    }

    Overlapped.hEvent = EventHandle;

    Result = WriteFile(
                      PipeHandle,
                      lpBuffer,
		      nNumberOfBytesToWrite,
		      lpNumberOfBytesWritten,
                      &Overlapped
                     );
    if (Result) {

        //
        // Success without waiting - it's too easy !
        //

        CloseHandle(EventHandle);

    } else {

        //
	// Write failed, if it's overlapped io, go wait for it
        //

        Error = GetLastError();

        if (Error != ERROR_IO_PENDING) {
	    RcDbgPrint("WritePipe: WriteFile failed, error = %d\n", Error);
            CloseHandle(EventHandle);
	    return(Error);
        }

        //
        // Wait for the I/O to complete
        //

	Result = WaitForSingleObject(EventHandle, Timeout);
	if (Result != WAIT_OBJECT_0) {
	    if (Result == WAIT_TIMEOUT)  {
		return(Result);
	    }  else  {
		RcDbgPrint("Write: event wait failed, result = %d, last error = %d\n", Result, GetLastError());
	    }
	    CloseHandle(EventHandle);
	}

        //
        // Go get the I/O result
        //

        Result = GetOverlappedResult( PipeHandle,
                                      &Overlapped,
				      lpNumberOfBytesWritten,
                                      FALSE
                                    );
        //
        // We're finished with the event handle
        //

        CloseHandle(EventHandle);

        //
        // Check result of GetOverlappedResult
        //

        if (!Result) {
	    RcDbgPrint("WritePipe: GetOverlappedResult failed, error = %d\n", GetLastError());
	    return(GetLastError());
        }
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\rcmd\server\pipe.h ===
/****************************** Module Header ******************************\
* Module Name: pipe.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Defines functions exported by pipe.c
*
* History:
* 06-29-92 Davidc       Created.
\***************************************************************************/


//
// Function prototypes
//

BOOL
RcCreatePipe(
    LPHANDLE ReadHandle,
    LPHANDLE WriteHandle,
    LPSECURITY_ATTRIBUTES SecurityAttributes,
    DWORD Size,
    DWORD Timeout,
    DWORD ReadHandleFlags,
    DWORD WriteHandleFlags
    );

DWORD
ReadPipe(
    HANDLE PipeHandle,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    DWORD Timeout
    );

DWORD
WritePipe(
    HANDLE PipeHandle,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    DWORD Timeout
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\regview\regview.c ===
#include <windows.h>
#include <tchar.h>
#include <stdio.h>


#define MAX_KEYNAME_SIZE         2048
#define MAX_VALUENAME_SIZE        512

//
// Verison number for the registry file format
//

#define REGISTRY_FILE_VERSION       1


//
// File signature
//

#define REGFILE_SIGNATURE  0x67655250


BOOL DisplayRegistryData (LPTSTR lpRegistry);


int __cdecl main( int argc, char *argv[])
{
    WCHAR szPath[MAX_PATH * 2];

    if (argc != 2) {
        _tprintf(TEXT("usage:  regview <pathname>\registry.pol"));
        _tprintf(TEXT("example:  regview d:\registry.pol"));
        return 1;
    }


    if (!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, argv[1], -1, szPath,
                            (MAX_PATH * 2))) {
        _tprintf(TEXT("Failed to convert path to unicode"));
        return 1;
    }

    DisplayRegistryData(szPath);

    return 0;
}


//*************************************************************
//
//  DisplayRegistryData()
//
//  Purpose:    Displays the registry data
//
//  Parameters: lpRegistry  -   Path to registry.pol
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL DisplayRegistryData (LPTSTR lpRegistry)
{
    HANDLE hFile;
    BOOL bResult = FALSE;
    DWORD dwTemp, dwBytesRead, dwType, dwDataLength, dwIndex, dwCount;
    LPWSTR lpKeyName, lpValueName, lpTemp;
    LPBYTE lpData = NULL, lpIndex;
    WCHAR  chTemp;
    INT i;
    CHAR szString[20];


    //
    // Open the registry file
    //

    hFile = CreateFile (lpRegistry, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);


    if (hFile == INVALID_HANDLE_VALUE) {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            return TRUE;
        }
        else
        {
            _tprintf(TEXT("DisplayRegistryData: CreateFile failed with %d"),
                     GetLastError());
            return FALSE;
        }
    }


    //
    // Allocate buffers to hold the keyname, valuename, and data
    //

    lpKeyName = (LPWSTR) LocalAlloc (LPTR, MAX_KEYNAME_SIZE * sizeof(WCHAR));

    if (!lpKeyName)
    {
        _tprintf(TEXT("DisplayRegistryData: Failed to allocate memory with %d"),
                 GetLastError());
        return FALSE;
    }


    lpValueName = (LPWSTR) LocalAlloc (LPTR, MAX_VALUENAME_SIZE * sizeof(WCHAR));

    if (!lpValueName)
    {
        _tprintf(TEXT("DisplayRegistryData: Failed to allocate memory with %d"),
                 GetLastError());
        LocalFree (lpKeyName);
        return FALSE;
    }


    //
    // Read the header block
    //
    // 2 DWORDS, signature (PReg) and version number and 2 newlines
    //

    if (!ReadFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(dwTemp))
    {
        _tprintf(TEXT("DisplayRegistryData: Failed to read signature with %d"),
                 GetLastError());
        goto Exit;
    }


    if (dwTemp != REGFILE_SIGNATURE)
    {
        _tprintf(TEXT("DisplayRegistryData: Invalid file signature"));
        goto Exit;
    }


    if (!ReadFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(dwTemp))
    {
        _tprintf(TEXT("DisplayRegistryData: Failed to read version number with %d"),
                 GetLastError());
        goto Exit;
    }

    if (dwTemp != REGISTRY_FILE_VERSION)
    {
        _tprintf(TEXT("DisplayRegistryData: Invalid file version"));
        goto Exit;
    }


    //
    // Read the data
    //

    while (TRUE)
    {

        //
        // Read the first character.  It will either be a [ or the end
        // of the file.
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                _tprintf(TEXT("DisplayRegistryData: Failed to read first character with %d"),
                         GetLastError());
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L'['))
        {
            break;
        }


        //
        // Read the keyname
        //

        lpTemp = lpKeyName;

        while (TRUE)
        {

            if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
            {
                _tprintf(TEXT("DisplayRegistryData: Failed to read keyname character with %d"),
                         GetLastError());
                goto Exit;
            }

            *lpTemp++ = chTemp;

            if (chTemp == TEXT('\0'))
                break;
        }


        //
        // Read the semi-colon
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                _tprintf(TEXT("DisplayRegistryData: Failed to read first character with %d"),
                         GetLastError());
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L';'))
        {
            break;
        }


        //
        // Read the valuename
        //

        lpTemp = lpValueName;

        while (TRUE)
        {

            if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
            {
                _tprintf(TEXT("DisplayRegistryData: Failed to read valuename character with %d"),
                         GetLastError());
                goto Exit;
            }

            *lpTemp++ = chTemp;

            if (chTemp == TEXT('\0'))
                break;
        }


        //
        // Read the semi-colon
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                _tprintf(TEXT("DisplayRegistryData: Failed to read first character with %d"),
                         GetLastError());
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L';'))
        {
            break;
        }


        //
        // Read the type
        //

        if (!ReadFile (hFile, &dwType, sizeof(DWORD), &dwBytesRead, NULL))
        {
            _tprintf(TEXT("DisplayRegistryData: Failed to read type with %d"),
                     GetLastError());
            goto Exit;
        }


        //
        // Skip semicolon
        //

        if (!ReadFile (hFile, &dwTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            _tprintf(TEXT("DisplayRegistryData: Failed to skip semicolon with %d"),
                     GetLastError());
            goto Exit;
        }


        //
        // Read the data length
        //

        if (!ReadFile (hFile, &dwDataLength, sizeof(DWORD), &dwBytesRead, NULL))
        {
            _tprintf(TEXT("DisplayRegistryData: Failed to data length with %d"),
                     GetLastError());
            goto Exit;
        }


        //
        // Skip semicolon
        //

        if (!ReadFile (hFile, &dwTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            _tprintf(TEXT("DisplayRegistryData: Failed to skip semicolon with %d"),
                     GetLastError());
            goto Exit;
        }


        //
        // Allocate memory for data
        //

        lpData = (LPBYTE) LocalAlloc (LPTR, dwDataLength);

        if (!lpData)
        {
            _tprintf(TEXT("DisplayRegistryData: Failed to allocate memory for data with %d"),
                     GetLastError());
            goto Exit;
        }


        //
        // Read data
        //

        if (!ReadFile (hFile, lpData, dwDataLength, &dwBytesRead, NULL))
        {
            _tprintf(TEXT("DisplayRegistryData: Failed to read data with %d"),
                     GetLastError());
            goto Exit;
        }


        //
        // Skip closing bracket
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            _tprintf(TEXT("DisplayRegistryData: Failed to skip closing bracket with %d"),
                     GetLastError());
            goto Exit;
        }

        if (chTemp != L']')
        {
            _tprintf(TEXT("DisplayRegistryData: Expected to find ], but found %c"),
                     chTemp);
            goto Exit;
        }

        //
        // Print out the entry
        //

        _tprintf (TEXT("\nKeyName:\t%s\n"), lpKeyName);
        _tprintf (TEXT("ValueName:\t%s\n"), lpValueName);


        switch (dwType) {

            case REG_DWORD:
                _tprintf (TEXT("ValueType:\tREG_DWORD\n"));
                _tprintf (TEXT("Value:\t\t0x%08x\n"), *((LPDWORD)lpData));
                break;

            case REG_SZ:
                _tprintf (TEXT("ValueType:\tREG_SZ\n"));
                _tprintf (TEXT("Value:\t%s\n"), (LPTSTR)lpData);
                break;

            case REG_EXPAND_SZ:
                _tprintf (TEXT("ValueType:\tREG_EXPAND_SZ\n"));
                _tprintf (TEXT("Value:\t%s\n"), (LPTSTR)lpData);
                break;

            case REG_MULTI_SZ:
                _tprintf (TEXT("ValueType:\tREG_MULTI_SZ\n"));
                _tprintf (TEXT("Value:\n\t\t"));
                lpTemp = (LPWSTR) lpData;

                while (*lpTemp) {
                    _tprintf (TEXT("%s\n\t\t"), lpTemp);
                    lpTemp += lstrlen(lpTemp) + 1;
                }
                break;

            case REG_BINARY:
                _tprintf (TEXT("ValueType:\tREG_BINARY\n"));
                _tprintf (TEXT("Value:\n\t"));

                dwIndex = 0;
                dwCount = 0;
                lpIndex = lpData;
                ZeroMemory(szString, sizeof(szString));

                while (dwIndex <= dwDataLength) {
                    _tprintf (TEXT("%02x "), *lpIndex);

                    if ((*lpIndex > 32) && (*lpIndex < 127)) {
                        szString[dwCount] = *lpIndex;
                    } else {
                        szString[dwCount] = '.';
                    }

                    if (dwCount < 15) {
                        dwCount++;
                    } else {
                        printf (" %s", szString);
                        _tprintf (TEXT("\n\t"));
                        ZeroMemory(szString, sizeof(szString));
                        dwCount = 0;
                    }

                    dwIndex++;
                    lpIndex++;
                }

                if (dwCount > 0) {
                    while (dwCount < 16) {
                        _tprintf (TEXT("   "));
                        dwCount++;
                    }
                    printf (" %s\n", szString);
                }

                _tprintf (TEXT("\n"));

                break;

            case REG_NONE:
                _tprintf (TEXT("ValueType:\tREG_NONE\n"));
                _tprintf (TEXT("Value:\t\tThis key contains no values\n"), *lpData);
                break;


            default:
                _tprintf (TEXT("ValueType:\tUnknown\n"));
                _tprintf (TEXT("ValueSize:\t%d\n"), dwDataLength);
                break;
        }

        LocalFree (lpData);
        lpData = NULL;

    }

    bResult = TRUE;

Exit:

    //
    // Finished
    //

    if (lpData) {
        LocalFree (lpData);
    }
    CloseHandle (hFile);
    LocalFree (lpKeyName);
    LocalFree (lpValueName);

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\rcmd\server\session.c ===
/****************************** Module Header ******************************\
* Module Name: session.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Remote shell session module
*
* History:
* 06-28-92 Davidc       Created.
* 05-05-94 DaveTh       Modifed for RCMD service
* 02-04-99 MarkHar      Fixed NTBug #287923
\***************************************************************************/


#include <nt.h>
#include <ntrtl.h>
#include <windef.h>
#include <nturtl.h>
#include <winbase.h>

#include "rcmdsrv.h"
#include <io.h>
#include <stdlib.h>

//
// Define shell command line
//

#define SHELL_COMMAND_LINE  TEXT("cmd /q")
#define SHELL_COMMAND_PREFIX TEXT("cmd /c ")
#define SHELL_REMOTE_CMD_TITLE TEXT("Remote Command")
#define SHELL_CMD_PREFIX_LEN 7

//
// Define buffer size for reads/writes to/from shell
//

#define SHELL_BUFFER_SIZE   1000

//
//  Home directory constants
//

#define MAX_DIRECTORY_LENGTH 255
#define ROOT_OF_C TEXT("C:\\")

//
// Define multiple wait handle table size - extra handle for service stop
//

#define NUM_WAIT_HANDLES  5

//
// Define the structure used to describe each session
//

typedef struct {

    //
    // These fields are filled in at session creation time
    //

    HANDLE  ShellReadPipeHandle;        // Handle to shell stdout pipe
    HANDLE  ShellWritePipeHandle;        // Handle to shell stdin pipe
    HANDLE  ShellProcessHandle;     // Handle to shell process
    DWORD   ShellProcessGroupId;        // Process group ID of shell process
    PCHAR  DefaultDirectory;            // Default directory

    //
    // These fields maintain the state of asynchronouse reads/writes
    // to the shell process across client disconnections. They
    // are initialized at session creation.
    //

    BYTE    ShellReadBuffer[SHELL_BUFFER_SIZE]; // Data for shell reads goes here
    HANDLE  ShellReadAsyncHandle;   // Object used for async reads from shell

    BYTE    ShellWriteBuffer[SHELL_BUFFER_SIZE]; // Data for shell writes goes here
    HANDLE  ShellWriteAsyncHandle; // Object used for async writes to shell

    //
    // These fields are filled in at session connect time and are only
    // valid when the session is connected
    //

    HANDLE  ClientPipeHandle;       // Handle to client pipe
    HANDLE  SessionThreadHandle;    // Handle to session thread


} SESSION_DATA, *PSESSION_DATA;




//
// Private prototypes
//

HANDLE
StartShell(
    HANDLE StdinPipeHandle,
    HANDLE StdoutPipeHandle,
    PSESSION_DATA Session,
    HANDLE TokenToUse,
    PCOMMAND_HEADER LpCommandHeader
    );

DWORD
SessionThreadFn(
    LPVOID Parameter
    );

CHAR *
GetDefaultDirectory(
    void
    );
//
// Useful macros
//

#define SESSION_CONNECTED(Session) ((Session)->ClientPipeHandle != NULL)




/////////////////////////////////////////////////////////////////////////////
//
// CreateSession
//
// Creates a new session. Involves creating the shell process and establishing
// pipes for communication with it.
//
// Returns a handle to the session or NULL on failure.
//
/////////////////////////////////////////////////////////////////////////////

HANDLE
CreateSession(
    HANDLE TokenToUse,
    PCOMMAND_HEADER LpCommandHeader
    )
{
    PSESSION_DATA Session = NULL;
    BOOL Result;
    SECURITY_ATTRIBUTES SecurityAttributes;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    HANDLE ShellStdinPipe = NULL;
    HANDLE ShellStdoutPipe = NULL;

    //
    // Allocate space for the session data
    //

    Session = (PSESSION_DATA)Alloc(sizeof(SESSION_DATA));
    if (Session == NULL) {
	return(NULL);
    }

    //
    // Reset fields in preparation for failure
    //

    Session->ShellReadPipeHandle  = NULL;
    Session->ShellWritePipeHandle = NULL;
    Session->ShellReadAsyncHandle = NULL;
    Session->ShellWriteAsyncHandle = NULL;


    //
    // Create the I/O pipes for the shell - give world access so that spawned
    // command process can access them in client's contex
    //

    Result = InitializeSecurityDescriptor (
		    &SecurityDescriptor,
		    SECURITY_DESCRIPTOR_REVISION);

    if (!Result) {
	RcDbgPrint("Failed to initialize shell pipe security descriptor, error = %d\n", 
                   GetLastError());
	goto Failure;
    }

    Result = SetSecurityDescriptorDacl (
		    &SecurityDescriptor,
		    TRUE,
		    NULL,
		    FALSE);

    if (!Result) {
	RcDbgPrint("Failed to set shell pipe DACL, error = %d\n", GetLastError());
	goto Failure;
    }

    SecurityAttributes.nLength = sizeof(SecurityAttributes);
    SecurityAttributes.lpSecurityDescriptor = &SecurityDescriptor; // Use world-ACL
    SecurityAttributes.bInheritHandle = TRUE; // Shell will inherit handles

    Result = RcCreatePipe(&Session->ShellReadPipeHandle,
			  &ShellStdoutPipe,
			  &SecurityAttributes,
			  0,            // Default pipe size
			  0,            // Default timeout
			  FILE_FLAG_OVERLAPPED, // shell read flags
			  0              // shell stdout flags
			  );
    if (!Result) {
	RcDbgPrint("Failed to create shell stdout pipe, error = %d\n", 
                   GetLastError());
	goto Failure;
    }

    Result = RcCreatePipe(&ShellStdinPipe,
			  &Session->ShellWritePipeHandle,
			  &SecurityAttributes,
			  0,            // Default pipe size
			  0,            // Default timeout
			  0,            // shell stdin flags
			  FILE_FLAG_OVERLAPPED // shell write flags
			  );
    if (!Result) {
	RcDbgPrint("Failed to create shell stdin pipe, error = %d\n", 
                   GetLastError());
	goto Failure;
    }


    //
    // Initialize async objects
    //

    Session->ShellReadAsyncHandle = CreateAsync(FALSE);
    if (Session->ShellReadAsyncHandle == NULL) {
	RcDbgPrint("Failed to create shell read async object, error = %d\n", 
                   GetLastError());
	goto Failure;
    }

    Session->ShellWriteAsyncHandle = CreateAsync(FALSE);
    if (Session->ShellWriteAsyncHandle == NULL) {
	RcDbgPrint("Failed to create shell write async object, error = %d\n", 
                   GetLastError());
	goto Failure;
    }



    Session->DefaultDirectory = GetDefaultDirectory();

    //
    //  Start command shell with pipes connection to stdin/out/err
    //

    Session->ShellProcessHandle = StartShell(ShellStdinPipe, 
                                             ShellStdoutPipe, 
                                             Session, TokenToUse, 
                                             LpCommandHeader);

    //
    //  Close local handles
    //

    if (!(CloseHandle(ShellStdinPipe) &&
	  CloseHandle(ShellStdoutPipe)))  
    {
	ShellStdinPipe = NULL;
	ShellStdoutPipe = NULL;
	RcDbgPrint("Failed to close local pipe handles, error = %d\n", 
                   GetLastError());
	goto Failure;
    }

    //
    // Check result of shell start
    //

    if (Session->ShellProcessHandle == NULL) 
    {
	RcDbgPrint("Failed to execute shell\n");
	goto Failure;
    }

    //
    // The session is not yet connected, initialize variables to indicate that
    //

    Session->ClientPipeHandle = NULL;

    //
    // Success, return the session pointer as a handle
    //

    return((HANDLE)Session);



Failure:

    //
    // We get here for any failure case.
    // Free up any resources and exit
    //


    //
    // Cleanup shell pipe handles
    //

    if (ShellStdinPipe != NULL) {
	RcCloseHandle(ShellStdinPipe, "shell stdin pipe (shell side)");
    }

    if (ShellStdoutPipe != NULL) {
	RcCloseHandle(ShellStdoutPipe, "shell stdout pipe (shell side)");
    }

    if (Session->ShellReadPipeHandle != NULL) {
	RcCloseHandle(Session->ShellReadPipeHandle, "shell read pipe (session side)");
    }

    if (Session->ShellWritePipeHandle != NULL) {
	RcCloseHandle(Session->ShellWritePipeHandle, "shell write pipe (session side)");
    }


    //
    // Cleanup async data
    //

    if (Session->ShellReadAsyncHandle != NULL) {
	DeleteAsync(Session->ShellReadAsyncHandle);
    }

    if (Session->ShellWriteAsyncHandle != NULL) {
	DeleteAsync(Session->ShellWriteAsyncHandle);
    }


    //
    // Free up our session data
    //

    Free(Session);

    return(NULL);
}


CHAR *
GetDefaultDirectory(
    void
    )
{
    CHAR *HomeDirectory = (CHAR *)malloc(MAX_PATH * sizeof(CHAR));
    WIN32_FIND_DATA FileFindData;


    // Local system doesn't have many env. vars.  
    // One that it does have is USERPROFILE.  We'll try that first
    if (!GetEnvironmentVariable("USERPROFILE", HomeDirectory, MAX_PATH))
    {
        if (!GetEnvironmentVariable("TEMP", HomeDirectory, MAX_PATH))
        {
            if (!GetEnvironmentVariable("TMP", HomeDirectory, MAX_PATH))
            {
                RcDbgPrint("Can't find USERPROFILE, TEMP, TMP: defaulting to NULL");
                free(HomeDirectory);
                return NULL;
            }
        }
    }  


    if (strlen((const char *)HomeDirectory) < MAX_DIRECTORY_LENGTH)
    {
        RcDbgPrint("Trying to use home directory %s\n", HomeDirectory);

        // Now verify that indeed the USERPROFILE directory is actually a directory
        // If not, then go for NULL
        if (INVALID_HANDLE_VALUE == FindFirstFile(HomeDirectory, &FileFindData))
        {
            free(HomeDirectory);
            return NULL;
        }
        else
        {
            if (!(FileFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                free(HomeDirectory);
                return NULL;
            }
        }
        
        RcDbgPrint("HomeDirectory = %s\n", HomeDirectory);
        
        return HomeDirectory;
    }
    else
    {
        RcDbgPrint("Using NULL default directory\n");
        free(HomeDirectory);
        return NULL;
    }


}

/////////////////////////////////////////////////////////////////////////////
//
// DeleteSession
//
// Deletes the session specified by SessionHandle.
//
// Returns nothing
//
/////////////////////////////////////////////////////////////////////////////

VOID
DeleteSession(
    HANDLE  SessionHandle
    )
{
    PSESSION_DATA   Session = (PSESSION_DATA)SessionHandle;
    BOOL Result;


    //
    // Kill off the shell process
    //

    Result = TerminateProcess(Session->ShellProcessHandle, 1);
    if (!Result) {
	RcDbgPrint("May have failed to terminate shell, error = %d\n", GetLastError());
    }

    RcCloseHandle(Session->ShellProcessHandle, "shell process");


    //
    // Close the shell pipe handles
    //

    RcCloseHandle(Session->ShellReadPipeHandle, "shell read pipe (session side)");
    RcCloseHandle(Session->ShellWritePipeHandle, "shell write pipe (session side)");


    //
    // Cleanup async data
    //

    DeleteAsync(Session->ShellReadAsyncHandle);
    DeleteAsync(Session->ShellWriteAsyncHandle);


    //
    // Free up the session structure
    //

    Free(Session);

    //
    // We're done
    //

    return;
}




/////////////////////////////////////////////////////////////////////////////
//
// ConnectSession
//
// Connects the session specified by SessionHandle to a client
// on the other end of the pipe specified by PipeHandle
//
// Returns a session disconnect notification handle or NULL on failure.
// The returned handle will be signalled if the client disconnects or the
// shell terminates.
//
/////////////////////////////////////////////////////////////////////////////

HANDLE
ConnectSession(
    HANDLE  SessionHandle,
    HANDLE  ClientPipeHandle
    )
{
    PSESSION_DATA   Session = (PSESSION_DATA)SessionHandle;
    DWORD ThreadId;

    assert(ClientPipeHandle != NULL);

    //
    // Fail if the session is already connected
    //

    if (SESSION_CONNECTED(Session)) {
        RcDbgPrint("Attempted to connect session already connected\n");
        return(NULL);
    }


    //
    // Store the client pipe handle in the session structure so the thread
    // can get at it. This also signals that the session is connected.
    //

    Session->ClientPipeHandle = ClientPipeHandle;


    //
    // Create the session thread
    //

    Session->SessionThreadHandle = CreateThread(
                     NULL,
                     0,                 // Default stack size
                     (LPTHREAD_START_ROUTINE)SessionThreadFn,   // Start address
                     (LPVOID)Session,           // Parameter
                     0,                 // Creation flags
                     &ThreadId          // Thread id
				     );
    if (Session->SessionThreadHandle == NULL) {

        RcDbgPrint("Failed to create session thread, error = %d\n", GetLastError());

        //
        // Reset the client pipe handle to indicate this session is disconnected
        //

        Session->ClientPipeHandle = NULL;
    }

    return(Session->SessionThreadHandle);
}





/////////////////////////////////////////////////////////////////////////////
//
// StartShell
//
// Execs the shell with the specified handle as stdin, stdout/err
//
// Returns process handle or NULL on failure
//
/////////////////////////////////////////////////////////////////////////////

HANDLE
StartShell(
    HANDLE StdinPipeHandle,
    HANDLE StdoutPipeHandle,
    PSESSION_DATA Session,
    HANDLE TokenToUse,
    PCOMMAND_HEADER LpCommandHeader
    )
{

    PROCESS_INFORMATION ProcessInformation;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    STARTUPINFO si;
    HANDLE ProcessHandle = NULL;
    PROCESS_ACCESS_TOKEN ProcessTokenInfo;
    DWORD Result;
    UCHAR ShellCommandLine[MAX_CMD_LENGTH+SHELL_CMD_PREFIX_LEN+1];

    //
    // Detached process has no console - create new process with stdin,
    // stdout set to the passed-in handles
    //


    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpTitle = SHELL_REMOTE_CMD_TITLE;
    si.lpDesktop = NULL;
    si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput =  StdinPipeHandle;
    si.hStdOutput = StdoutPipeHandle;
    si.hStdError =  StdoutPipeHandle;
    si.wShowWindow = SW_SHOW;
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;

    //
    //  Set command string for single command or interactive mode
    //

    if (LpCommandHeader->CommandFixedHeader.CommandLength == 0) 
    {
        strcpy ((char *)ShellCommandLine, SHELL_COMMAND_LINE);
    }
    else 
    {

        //
        // Construct command string for execute and exit
        //

        strcpy ((char *)ShellCommandLine, SHELL_COMMAND_PREFIX);
        strncat ((char *)ShellCommandLine,
                 (const char *)LpCommandHeader->Command,
                 LpCommandHeader->CommandFixedHeader.CommandLength);
    }

    //
    // Create process with stdin/out/err connected to session pipes.
    // Create suspended then set the process token to the token of the
    // connected client (primary version of impersonate token).
    //

    // What if I use CreateProcessAsUser here?

    if (CreateProcess(NULL,
		      (char *)ShellCommandLine,
		      NULL,
		      NULL,
		      TRUE, // Inherit handles
		      CREATE_NEW_PROCESS_GROUP | CREATE_SUSPENDED , // | CREATE_NEW_CONSOLE
		      NULL,
		      Session->DefaultDirectory,
		      &si,
		      &ProcessInformation)) 
    {

        ProcessHandle = ProcessInformation.hProcess;
        Session->ShellProcessGroupId = ProcessInformation.dwProcessId;

    }
    else 
    {
	    RcDbgPrint("Failed to execute shell, error = %d\n", GetLastError());
	    return(NULL);
    }

    //
    //  Set process token for client and local system context access
    //  BUGBUG - actually, world, for now
    //

    Result = InitializeSecurityDescriptor (
        &SecurityDescriptor,
        SECURITY_DESCRIPTOR_REVISION);
    if (!Result)  
    {
        RcDbgPrint(
            "Failed to initialize shell process security descriptor, error = %d\n", 
            GetLastError()
            );
        RcCloseHandle(ProcessInformation.hThread, "process thread");
        return(NULL);
    }

    Result = SetSecurityDescriptorDacl (
		    &SecurityDescriptor,
		    TRUE,
		    NULL,
		    FALSE);
    if (0 == Result)  {
        RcDbgPrint("Failed to initialize shell process DACL, error = %d\n", GetLastError());
        RcCloseHandle(ProcessInformation.hThread, "process thread");
        return(NULL);
    }

    Result = SetKernelObjectSecurity(
	    ProcessHandle,
	    DACL_SECURITY_INFORMATION,
	    &SecurityDescriptor );
    if (0 == Result) {

        RcDbgPrint("Failed to set DACL on client token, error = %d\n", GetLastError());
        RcCloseHandle(ProcessInformation.hThread, "process thread");
        return(NULL);
    }

    //
    //  Now set the process token and resume execution
    //

    ProcessTokenInfo.Token = TokenToUse;
    ProcessTokenInfo.Thread = ProcessInformation.hThread;

    if (!NT_SUCCESS( NtSetInformationProcess(
            ProcessInformation.hProcess,
            ProcessAccessToken,
            &ProcessTokenInfo,
            sizeof(ProcessTokenInfo)))) {

        RcDbgPrint("Failed to set token");
        RcCloseHandle(ProcessInformation.hThread, "process thread");
        return (NULL);
    }


    Result = ResumeThread (ProcessInformation.hThread);

    if (Result != 1)  {
        RcDbgPrint("Failed to resume shell, suspend = %d, error = %d\n", Result, GetLastError());
        RcCloseHandle(ProcessInformation.hThread, "process thread");
        return(NULL);
    }

    RcCloseHandle(ProcessInformation.hThread, "process thread");

    return(ProcessHandle);
}








/////////////////////////////////////////////////////////////////////////////
//
// SessionThreadFn
//
// This is the code executed by the session thread
//
// Waits for read or write from/to shell or client pipe and termination
// event. Handles reads or writes by passing data to either client or
// shell as appropriate. Any error or termination event being signalled
// causes the thread to exit with an appropriate exit code.
//
/////////////////////////////////////////////////////////////////////////////

DWORD
SessionThreadFn(
    LPVOID Parameter
    )
{
    PSESSION_DATA   Session = (PSESSION_DATA)Parameter;
    HANDLE  ClientReadAsyncHandle;
    HANDLE  ClientWriteAsyncHandle;
    DWORD   BytesTransferred;
    DWORD   CompletionCode;
    BOOL    Result;
    DWORD   WaitResult;
    DWORD   ExitCode;
    HANDLE  WaitHandles[NUM_WAIT_HANDLES];
    BOOL    Done;
    DWORD   i;


    //
    // Initialize the client async structures
    //

    ClientReadAsyncHandle = CreateAsync(TRUE);
    if (ClientReadAsyncHandle == NULL) {
    	RcDbgPrint("Failed to create client read async object, error = %d\n", GetLastError());
    	return((DWORD)ConnectError);
    }

    ClientWriteAsyncHandle = CreateAsync(TRUE);
    if (ClientWriteAsyncHandle == NULL) {
    	RcDbgPrint("Failed to create client write async object, error = %d\n", GetLastError());
    	DeleteAsync(ClientReadAsyncHandle);
    	return((DWORD)ConnectError);
    }



    //
    // Initialize the handle array we'll wait on
    //

    WaitHandles[0] = RcmdStopEvent;
    WaitHandles[1] = GetAsyncCompletionHandle(Session->ShellReadAsyncHandle);
    WaitHandles[2] = GetAsyncCompletionHandle(Session->ShellWriteAsyncHandle);
    WaitHandles[3] = GetAsyncCompletionHandle(ClientReadAsyncHandle);
    WaitHandles[4] = GetAsyncCompletionHandle(ClientWriteAsyncHandle);

    //
    // Wait on our handle array in a loop until an error occurs or
    // we're signalled to exit.
    //

    Done = FALSE;

    while (!Done) {

        //
        // Wait for one of our objects to be signalled.
        //

        WaitResult = WaitForMultipleObjects(NUM_WAIT_HANDLES, WaitHandles, FALSE, INFINITE);

        if (WaitResult == WAIT_FAILED) {
            RcDbgPrint("Session thread wait failed, error = %d\n", GetLastError());
            ExitCode = (DWORD)ConnectError;
            break; // out of while
        }


        switch (WaitResult-WAIT_OBJECT_0) {
        case 0:

            //
            //  Service being stopped
            //

            RcDbgPrint("Service Shutdown\n");
            ExitCode = (DWORD)ServiceStopped;
            Done = TRUE;
            break;  // out of switch

        case 1:

            //
            // Shell read completed
            //

            CompletionCode = GetAsyncResult(Session->ShellReadAsyncHandle,
                            &BytesTransferred);

            if (CompletionCode != ERROR_SUCCESS) {
                RcDbgPrint("Async read from shell returned error, completion code = %d\n", CompletionCode);
                ExitCode = (DWORD)ShellEnded;
                Done = TRUE;
                break; // out of switch
            }

            //
            // Start an async write to client pipe
            //

            Result = WriteFileAsync(Session->ClientPipeHandle,
                        Session->ShellReadBuffer,
                        BytesTransferred,
                        ClientWriteAsyncHandle);
            if (!Result) {
                RcDbgPrint("Async write to client pipe failed, error = %d\n", GetLastError());
                ExitCode = (DWORD)ClientDisconnected;
                Done = TRUE;
            }

            break; // out of switch


        case 4:

            //
            // Client write completed
            //

            CompletionCode = GetAsyncResult(ClientWriteAsyncHandle,
                            &BytesTransferred);

            if (CompletionCode != ERROR_SUCCESS) {
                RcDbgPrint("Async write to client returned error, completion code = %d\n", CompletionCode);
                ExitCode = (DWORD)ClientDisconnected;
                Done = TRUE;
                break; // out of switch
            }

            //
            // Start an async read from shell
            //

            Result = ReadFileAsync(Session->ShellReadPipeHandle,
                       Session->ShellReadBuffer,
                       sizeof(Session->ShellReadBuffer),
                       Session->ShellReadAsyncHandle);
            if (!Result) {
                RcDbgPrint("Async read from shell failed, error = %d\n", GetLastError());
                ExitCode = (DWORD)ShellEnded;
                Done = TRUE;
            }

            break; // out of switch


        case 3:

            //
            // Client read completed
            //

            CompletionCode = GetAsyncResult(ClientReadAsyncHandle,
                            &BytesTransferred);

            if (CompletionCode != ERROR_SUCCESS) {
                RcDbgPrint("Async read from client returned error, completion code = %d\n", CompletionCode);
                ExitCode = (DWORD)ClientDisconnected;
                Done = TRUE;
                break; // out of switch
            }

            //
            // Check for Ctrl-C from the client
            //

            for (i=0; i < BytesTransferred; i++) {
                if (Session->ShellWriteBuffer[i] == '\003') {

                    //
                    // Generate control-C:  use Ctrl-Break because ctrl-c is
                    // disabled for process group
                    //

                    if (!(GenerateConsoleCtrlEvent (
                        CTRL_BREAK_EVENT,
                        Session->ShellProcessGroupId)))  {
                        RcDbgPrint("Ctrl-break event failure, error = %d\n", GetLastError());
                    }

                    //
                    // Remove the Ctrl-C from the buffer
                    //

                    BytesTransferred --;

                    for (; i < BytesTransferred; i++) {
                        Session->ShellWriteBuffer[i] = Session->ShellWriteBuffer[i+1];
                    }
                }
            }

            //
            // Start an async write to shell
            //

            Result = WriteFileAsync(Session->ShellWritePipeHandle,
                        Session->ShellWriteBuffer,
                        BytesTransferred,
                        Session->ShellWriteAsyncHandle);
            if (!Result) {
            RcDbgPrint("Async write to shell failed, error = %d\n", GetLastError());
            ExitCode = (DWORD)ShellEnded;
            Done = TRUE;
            }

            break; // out of switch



        case 2:

            //
            // Shell write completed
            //

            CompletionCode = GetAsyncResult(Session->ShellWriteAsyncHandle,
                            &BytesTransferred);

            if (CompletionCode != ERROR_SUCCESS) {
            RcDbgPrint("Async write to shell returned error, completion code = %d\n", CompletionCode);
            ExitCode = (DWORD)ShellEnded;
            Done = TRUE;
            break; // out of switch
            }

            //
            // Start an async read from client
            //

            Result = ReadFileAsync(Session->ClientPipeHandle,
                       Session->ShellWriteBuffer,
                       sizeof(Session->ShellWriteBuffer),
                       ClientReadAsyncHandle);
            if (!Result) {
            RcDbgPrint("Async read from client failed, error = %d\n", GetLastError());
            ExitCode = (DWORD)ClientDisconnected;
            Done = TRUE;
            }

            break; // out of switch


        default:

            RcDbgPrint("Session thread, unexpected result from wait, result = %d\n", WaitResult);
            ExitCode = (DWORD)ConnectError;
            Done = TRUE;
            break;

        } // switch

    } // while(!done)



    //
    // Cleanup and exit
    //

    //
    // Closing the client pipe should interrupt any pending I/O so
    // we should then be safe to close the event handles in the client
    // overlapped structs
    //

    Result = DisconnectNamedPipe(Session->ClientPipeHandle);
    if (!Result) {
        RcDbgPrint("Session thread: disconnect client named pipe failed, error = %d\n", GetLastError());
    }

    RcCloseHandle(Session->ClientPipeHandle, "client pipe");
    Session->ClientPipeHandle = NULL;

    //
    //  Delete client async objects
    //

    DeleteAsync(ClientReadAsyncHandle);
    DeleteAsync(ClientWriteAsyncHandle);

    //
    //  Terminate shell process, close shell pipe handles, and free session
    //  structure
    //

    DeleteSession (Session);


    //
    // Return the appropriate exit code
    //

    ExitThread(ExitCode);

    assert(FALSE);
    return(ExitCode); // keep compiler happy
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\rcmd\server\rcmdsvc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rcmdsvc.c

Abstract:

    This is the remote command service.  It serves multiple remote clients
    running standard i/o character based programs.

Author:

    Dave Thompson, basically incorporating the remote command shell written
    by David Chalmers.

Environment:

    User Mode -Win32

Revision History:

    5/1/94  DaveTh  Created.
    7/30/96 MarkHar Fixed bug 40834 - "doesn't work on NT4.0"
                    Removed function calls within asserts.
    1/31/99 MarkHar bug about install not working
    6/22/99 MarkHar added usage message
--*/

//
// Includes
//

#include <nt.h>
#include <ntrtl.h>
#include <windef.h>
#include <nturtl.h>
#include <winbase.h>

#include <winsvc.h>

#include "rcmdsrv.h"

//
// Defines
//

#define INFINITE_WAIT_TIME  0xFFFFFFFF

#define NULL_STRING     TEXT("");


//
// Globals
//


SERVICE_STATUS   RcmdStatus;

SERVICE_STATUS_HANDLE   RcmdStatusHandle;

//
// Events for syncrhonizing service shutdown
//

HANDLE    RcmdStopEvent = NULL;

HANDLE    RcmdStopCompleteEvent = NULL;

HANDLE    SessionThreadHandles[MAX_SESSIONS+1] = {NULL,};


//
//  Flag to enable debug print
//

// BOOLEAN   RcDbgPrintEnable = FALSE;


//
// Function Prototypes
//

VOID
RcmdStart (
    DWORD   argc,
    LPTSTR  *argv
    );


VOID
RcmdCtrlHandler (
    IN  DWORD   opcode
    );

DWORD
RcmdInitialization(
    DWORD   argc,
    LPTSTR  *argv,
    DWORD   *specificError
    );

void CmdInstallService(void);
void CmdRemoveService();
void Usage(void);
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );


/****************************************************************************/
VOID __cdecl
main(int argc, char ** argv)

/*++

Routine Description:

    This is the main routine for the service RCMD process.

    This thread calls StartServiceCtrlDispatcher which connects to the
    service controller and then waits in a loop for control requests.
    When all the services in the service process have terminated, the
    service controller will send a control request to the dispatcher
    telling it to shut down.  This thread with then return from the
    StartServiceCtrlDispatcher call so that the process can terminate.

Arguments:



Return Value:



--*/
{

    DWORD      status;
    char      *szArgument = NULL;

    SERVICE_TABLE_ENTRY   DispatchTable[] = {
	{ TEXT("Remote Command"), RcmdStart },
	{ NULL, NULL  }
    };

    if (argc > 1)
    {
        if ((*argv[1] == '-') || (*argv[1] == '/')) 
        {
            szArgument = argv[1]+1;
            if (_stricmp("install", szArgument) == 0)
            {
                CmdInstallService();
            }
            else if (_stricmp("uninstall", szArgument) == 0)
            {
                CmdRemoveService();
            }
            else
            {
                Usage();
            }
        }
    }
    else
    {
        status = StartServiceCtrlDispatcher( DispatchTable);
    }

    ExitProcess(0);

}


void Usage(void)
{
    char *szUsage = "usage: rcmdsvc\n"
                    "rcmdsvc [[-/] [install | uninstall | H]]\n"
                    "\tinstall - registers the service with the service controller\n"
                    "\tuninstall - unregisters the service with the service controller\n"
                    "\tHh?       - prints this usage message\n";
    fprintf(stdout, szUsage);
}


void CmdInstallService()
/*++
  
Routine Description:


Arguments:

    None

Return Value:

    None

--*/
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;
    TCHAR szErr[256];
    TCHAR szPath[512];

    if ( GetModuleFileName( NULL, szPath, 512 ) == 0 )
    {
        printf(TEXT("Unable to install %s - %s\n"), 
               TEXT("Remote Command"), 
               GetLastErrorText(szErr, 256));
        return;
    }

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = CreateService(
            schSCManager,               // SCManager database
            TEXT("rcmdsvc"),        // name of service
            TEXT("Remote Command Service"), // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_WIN32_OWN_PROCESS,  // service type
            SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            szPath,                     // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            NULL,                       // dependencies
            NULL,                       // LocalSystem account
            NULL);                      // no password

        if ( schService )
        {
            printf(TEXT("%s installed.\n"), TEXT("Remote Command Service") );
            CloseServiceHandle(schService);
        }
        else
        {
            printf(TEXT("CreateService failed - %s\n"), GetLastErrorText(szErr, 256));
        }

        CloseServiceHandle(schSCManager);
    }
    else
        printf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}


void CmdRemoveService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;
    TCHAR       szErr[256];


    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, 
                                 TEXT("rcmdsvc"), 
                                 SERVICE_ALL_ACCESS);
        
        if (schService)
        {
            // try to stop the service
            if ( ControlService( schService, 
                                 SERVICE_CONTROL_STOP, 
                                 &RcmdStatus ) )
            {
                printf(TEXT("Stopping %s."), TEXT("Remote Command Service"));
                Sleep( 1000 );

                while( QueryServiceStatus( schService, &RcmdStatus ) )
                {
                    if ( RcmdStatus.dwCurrentState == SERVICE_STOP_PENDING ) {
                        printf(TEXT("."));
                        Sleep( 1000 );
                    }
                    else {
                        break;
                    }
                }

                if ( RcmdStatus.dwCurrentState == SERVICE_STOPPED ) {
                    printf(TEXT("\n%s stopped.\n"), 
                           TEXT("Remote Command Service") );
                }
                else {
                    printf(TEXT("\n%s failed to stop.\n"), 
                                TEXT("Remote Command Service") );
                }

            }

            // now remove the service
            if( DeleteService(schService) ) {
                printf(TEXT("%s removed.\n"), 
                       TEXT("Remote Command Service") );
            }
            else {
                printf(TEXT("DeleteService failed - %s\n"), 
                       GetLastErrorText(szErr,256));
            }
            CloseServiceHandle(schService);
        }
        else {
            printf(TEXT("OpenService failed -\n%s\n"), 
                        GetLastErrorText(szErr,256));
            printf(TEXT("The service must be installed before removing it."));
        }

        CloseServiceHandle(schSCManager);
    }
    else {
        printf(TEXT("OpenSCManager failed - %s\n"), 
               GetLastErrorText(szErr,256));
    }
}



/****************************************************************************/
void
RcmdStart (
    DWORD   argc,
    LPTSTR  *argv
    )
/*++

Routine Description:

    This is the entry point for the service.  When the control dispatcher
    is told to start a service, it creates a thread that will begin
    executing at this point.  The function has access to command line
    arguments in the same manner as a main() routine.

    Rather than return from this function, it is more appropriate to
    call ExitThread().

Arguments:



Return Value:



--*/
{
    DWORD   status;
    DWORD   specificError;

    //
    // Initialize the services status structure
    //

    RcmdStatus.dwServiceType        = SERVICE_WIN32;
    RcmdStatus.dwCurrentState       = SERVICE_START_PENDING;
    RcmdStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP;   // stop only
    RcmdStatus.dwWin32ExitCode      = 0;
    RcmdStatus.dwServiceSpecificExitCode = 0;
    RcmdStatus.dwCheckPoint         = 0;
    RcmdStatus.dwWaitHint           = 0;

    //
    // Register the Control Handler routine.
    //

    RcmdStatusHandle = RegisterServiceCtrlHandler(
                          TEXT("Remote Command"),
                          RcmdCtrlHandler);

    if (RcmdStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        RcDbgPrint(" [Rcmd] RegisterServiceCtrlHandler failed %d\n",
        GetLastError());
    }

    //
    // Initialize service global structures
    //

    status = RcmdInitialization(argc,argv, &specificError);

    if (status != NO_ERROR) {
        RcmdStatus.dwCurrentState       = SERVICE_RUNNING;
        RcmdStatus.dwCheckPoint         = 0;
        RcmdStatus.dwWaitHint           = 0;
        RcmdStatus.dwWin32ExitCode      = status;
        RcmdStatus.dwServiceSpecificExitCode = specificError;

        SetServiceStatus (RcmdStatusHandle, &RcmdStatus);
        ExitThread(NO_ERROR);
	    return;
    }

    //
    // Return the status to indicate we are done with intialization.
    //

    RcmdStatus.dwCurrentState       = SERVICE_RUNNING;
    RcmdStatus.dwCheckPoint         = 0;
    RcmdStatus.dwWaitHint           = 0;

    if (!SetServiceStatus (RcmdStatusHandle, &RcmdStatus)) {
    	status = GetLastError();
    	RcDbgPrint(" [Rcmd] SetServiceStatus error %ld\n",status);
    }

    //
    //  Run remote command processor - return when shutdown
    //

    if (0 != (status = Rcmd()))
    {
        RcDbgPrint(" [Rcmd]: problem occurred in Rcmd()\n");
        RcmdStatus.dwCurrentState       = SERVICE_STOPPED;
        RcmdStatus.dwCheckPoint         = 0;
        RcmdStatus.dwWaitHint           = 0;
        RcmdStatus.dwWin32ExitCode      = status;

        SetServiceStatus(RcmdStatusHandle, &RcmdStatus);
        ExitThread(status);
    }
    else
    {

        RcDbgPrint(" [Rcmd] Leaving My Service \n");
        ExitThread(NO_ERROR);
    }
}


/****************************************************************************/
VOID
RcmdCtrlHandler (
    IN  DWORD   Opcode
    )

/*++

Routine Description:

    This function executes in the context of the Control Dispatcher's
    thread.  Therefore, it it not desirable to perform time-consuming
    operations in this function.

    If an operation such as a stop is going to take a long time, then
    this routine should send the STOP_PENDING status, and then
    signal the other service thread(s) that a shut-down is in progress.
    Then it should return so that the Control Dispatcher can service
    more requests.  One of the other service threads is then responsible
    for sending further wait hints, and the final SERVICE_STOPPED.


Arguments:



Return Value:



--*/
{

    DWORD   status;

    //
    // Find and operate on the request.
    //

    switch(Opcode) {

    case SERVICE_CONTROL_PAUSE:

        RcDbgPrint(" [Rcmd] Pause - Unsupported opcode\n");
        break;

    case SERVICE_CONTROL_CONTINUE:

        RcDbgPrint(" [Rcmd] Continue - Unsupported opcode\n");
        break;

    case SERVICE_CONTROL_STOP:

        RcmdStatus.dwCurrentState = SERVICE_STOPPED;
        RcmdStatus.dwWin32ExitCode = RcmdStop();
        break;

    case SERVICE_CONTROL_INTERROGATE:
	
        //
        // All that needs to be done in this case is to send the
        // current status.
        //

        break;

    default:
        RcDbgPrint(" [Rcmd] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (RcmdStatusHandle,  &RcmdStatus)) {
        status = GetLastError();
        RcDbgPrint(" [Rcmd] SetServiceStatus error %ld\n",status);
    }

}

DWORD
RcmdInitialization(
    DWORD   argc,
    LPTSTR  *argv,
    DWORD   *specificError)
{

    UNREFERENCED_PARAMETER(argv);
    UNREFERENCED_PARAMETER(argc);

    //
    // Initialize global stop event (signals running threads) and session
    // thread handle array (for threads to signal back on exit).
    //

    if (!(RcmdStopEvent = CreateEvent ( NULL, TRUE, FALSE, NULL )))  {
        *specificError = GetLastError();
        return(*specificError);
    }

    if (!(RcmdStopCompleteEvent = CreateEvent ( NULL, TRUE, FALSE, NULL )))  {
        *specificError = GetLastError();
        return(*specificError);
    }

    return(NO_ERROR);
}


LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER
                           | FORMAT_MESSAGE_FROM_SYSTEM 
                           | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           NULL,
                           GetLastError(),
                           LANG_NEUTRAL,
                           (LPTSTR)&lpszTemp,
                           0,
                           NULL );

    // supplied buffer is not long enough
    if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
        lpszBuf[0] = TEXT('\0');
    else
    {
        lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character
        sprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
    }

    if ( lpszTemp )
        LocalFree((HLOCAL) lpszTemp );

    return lpszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\sidname\sidname.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <shellapi.h>
#include <sddl.h>



DWORD __cdecl main (int argc, char *argv[])
{
    WCHAR   szPath[4*MAX_PATH];
    WCHAR   szName[MAX_PATH];
    DWORD   dwType;
    LPTSTR  szOldPath;
    WCHAR   szOutPath[4*MAX_PATH];
    BOOL bResult;

    if (argc != 3) {
        printf("Usage: %s </s|/u> <user name or Sid>\n", argv[0]);
        return 0;
    }

    if (_strcmpi(argv[1],"/s") == 0) {
        WCHAR *szSid, szUserName[MAX_PATH+1], szDomainName[MAX_PATH+1];
        PSID   pSid;
        DWORD cUserName = MAX_PATH, cDomainName = MAX_PATH;
        SID_NAME_USE    SidUse;


        szSid = (WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(1+strlen(argv[2])));

        wsprintf(szSid, L"%S", argv[2]);
        ConvertStringSidToSid (szSid, &pSid);

        if (!LookupAccountSid(NULL, pSid, szUserName, &cUserName, szDomainName, &cDomainName, &SidUse)) {
            printf("LookupAccountSid failed with error %d\n", GetLastError());
            return 0;
        }

        printf("UserName = %S, DomainName = %S, SidUse = %d\n", szUserName, szDomainName, SidUse);
        return;

    }
    else {
        WCHAR *szSid, szUserName[MAX_PATH+1], szDomainName[MAX_PATH+1];
        PSID   pSid;
        DWORD cUserName = 1024, cDomainName = MAX_PATH;
        SID_NAME_USE    SidUse;

        wsprintf(szUserName, L"%S", argv[2]);

        pSid = (SID *)LocalAlloc(LPTR, 1024);

        if (!LookupAccountName(NULL, szUserName, pSid, &cUserName, szDomainName, &cDomainName, &SidUse)) {
            printf("LookupAccountName failed with error %d\n", GetLastError());
            return 0;
        }

        ConvertSidToStringSid(pSid, &szSid);

        printf("SId = %S, Domain = %S, SidUse = %d\n", szSid, szDomainName, SidUse);
        return;

    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\testnotify\test.c ===
#include <windows.h>
#include <stdio.h>
#include <userenv.h>
#include <userenvp.h>

int __cdecl main( int argc, char *argv[])
{
    HANDLE hToken;
    HANDLE hEventMach, hEventUser, hEvents[2];
    DWORD dwRet;


    OpenProcessToken (GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken);

    hEvents[0] = hEventMach = CreateEvent (NULL, FALSE, FALSE, TEXT("some event mach"));
    hEvents[1] = hEventUser = CreateEvent (NULL, FALSE, FALSE, TEXT("some event user"));

    if (!RegisterGPNotification(hEventMach, TRUE)) {
        printf("RegisterGPNotification for machine failed with error - %d\n", GetLastError());
        return FALSE;
    }

    if (!RegisterGPNotification(hEventUser, FALSE)) {
        printf("RegisterGPNotification for user failed with error - %d\n", GetLastError());
        return FALSE;
    }


    printf("Going into the loop\n");
    
    for (;;) {

        dwRet = WaitForMultipleObjects(2, hEvents, FALSE, INFINITE);


        switch (dwRet - WAIT_OBJECT_0) {
        case 0:
            printf("Machine event got notified\n");
            break;

        case 1:
            printf("User event got notified\n");
            break;


        default:
            printf("WaitForMultipleObjects returned error - %d\n", GetLastError());
            break;
        }

        printf("Rewaiting..\n");
    }

    CloseHandle (hEventMach);
    CloseHandle (hEventUser);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\samples\rcmd\server\session.h ===
/****************************** Module Header ******************************\
* Module Name: session.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Remote shell session module header file
*
* History:
* 06-28-92 Davidc       Created.
\***************************************************************************/


//
// Define session thread notification values
//

typedef enum {
    ConnectError,
    DisconnectError,
    ClientDisconnected,
    ShellEnded,
    ServiceStopped
} SESSION_DISCONNECT_CODE, *PSESSION_NOTIFICATION_CODE;


//
// Function protoypes
//

HANDLE
CreateSession(
    HANDLE TokenToUse,
    PCOMMAND_HEADER LpCommandHeader
    );

VOID
DeleteSession(
    HANDLE  SessionHandle
    );

HANDLE
ConnectSession(
    HANDLE  SessionHandle,
    HANDLE  ClientPipeHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\utils\debug.cpp ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include "rsopdbg.h"

//
// Global Variable containing the debugging level.
//

DWORD   dwDebugLevel;
DWORD   dwRsopLoggingLevel = 1;  // Rsop logging setting

//
// Debug strings
//

const TCHAR c_szUserEnv[] = TEXT("USERENV(%x.%x) %02d:%02d:%02d:%03d ");
const TCHAR c_szCRLF[]    = TEXT("\r\n");


//
// Registry debug information
//

#define DEBUG_REG_LOCATION  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon")
#define DEBUG_KEY_NAME      TEXT("UserEnvDebugLevel")
#define RSOP_KEY_NAME       TEXT("RsopLogging")

//
// Log files
//


TCHAR szLogFileName[] = L"%SystemRoot%\\Debug\\UserMode\\userenv.log";       // Current log
TCHAR szBackupLogFileName[] = L"%SystemRoot%\\Debug\\UserMode\\userenv.bak"; // Backup/previous log

CDebug dbgCommon;


//*************************************************************
//
//  InitDebugSupport()
//
//  Purpose:    Sets the debugging level.
//              Also checks the registry for a debugging level.
//
//  Parameters: dwLoadFlags - If this is being loaded by winlogon
//                            or setup.exe
//
//  Return:     void
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void InitDebugSupport( DWORD dwLoadFlags )
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize, dwRet;
    TCHAR szExpLogDirectory[MAX_PATH+1];
    WIN32_FILE_ATTRIBUTE_DATA   FileData;

    //
    // Initialize the debug level to normal for checked builds, and
    // none for retail builds. Enable warning output in retail builds.
    // Enable Enable logfile output in both retail and checked builds.
    //

#if DBG
    dwDebugLevel = DL_NORMAL | DL_LOGFILE | DL_DEBUGGER;
#else
    OSVERSIONINFOEX version;

    dwDebugLevel = DL_NORMAL | DL_LOGFILE;
    
    version.dwOSVersionInfoSize = sizeof(version);
    if ( GetVersionEx( (LPOSVERSIONINFO) &version ) )
    {
        if ( ( version.wSuiteMask & VER_SUITE_PERSONAL ) != 0 )
        {
            //
            // no logging on personal
            //
            dwDebugLevel = DL_NONE;
        }
    }
#endif

    dwRsopLoggingLevel = 1;

    //
    // Check the registry
    //

    lResult = RegOpenKey (HKEY_LOCAL_MACHINE, DEBUG_REG_LOCATION,
                          &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwDebugLevel);
        RegQueryValueEx(hKey, DEBUG_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwDebugLevel, &dwSize);

        dwSize = sizeof(dwRsopLoggingLevel);
        RegQueryValueEx(hKey, RSOP_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwRsopLoggingLevel, &dwSize);

        RegCloseKey(hKey);
    }

    lResult = RegOpenKey (HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY,
                          &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwDebugLevel);
        RegQueryValueEx(hKey, DEBUG_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwDebugLevel, &dwSize);

        dwSize = sizeof(dwRsopLoggingLevel);
        RegQueryValueEx(hKey, RSOP_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwRsopLoggingLevel, &dwSize);

        RegCloseKey(hKey);
    }



    //
    // Initialize the common logging with userenv values
    //

    dbgCommon.Initialize( DEBUG_REG_LOCATION,
                     DEBUG_KEY_NAME,
                     L"userenv.log",
                     L"userenv.bak",
                     FALSE );


    dbgCommon.Initialize( SYSTEM_POLICIES_KEY,
                     DEBUG_KEY_NAME,
                     L"userenv.log",
                     L"userenv.bak",
                     FALSE );


    if ( dwLoadFlags == WINLOGON_LOAD ) {

        //
        // To avoid a huge log file, copy current log file to backup
        // file if the log file is over 300K
        //

        TCHAR szExpLogFileName[MAX_PATH+1];
        TCHAR szExpBackupLogFileName[MAX_PATH+1];

        dwRet = ExpandEnvironmentStrings ( szLogFileName, szExpLogFileName, MAX_PATH+1);

        if ( dwRet == 0 || dwRet > MAX_PATH)
            return;

        if (!GetFileAttributesEx(szExpLogFileName, GetFileExInfoStandard, &FileData)) {
            return;
        }

        if ( FileData.nFileSizeLow < (300 * 1024) ) {
            return;
        }

        dwRet = ExpandEnvironmentStrings ( szBackupLogFileName, szExpBackupLogFileName, MAX_PATH+1);

        if ( dwRet == 0 || dwRet > MAX_PATH)
            return;

        dwRet = MoveFileEx( szExpLogFileName, szExpBackupLogFileName, MOVEFILE_REPLACE_EXISTING);

        if ( dwRet == 0 ) {
            DebugMsg((DM_VERBOSE, TEXT("Moving log file to backup failed with 0x%x"), GetLastError()));
            return;
        }
    }
}

//*************************************************************
//
//  DebugMsg()
//
//  Purpose:    Displays debug messages based on the debug level
//              and type of debug message.
//
//  Parameters: mask    -   debug message type
//              pszMsg  -   debug message
//              ...     -   variable number of parameters
//
//  Return:     void
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...)
{
    BOOL bOutput;
    TCHAR szDebugTitle[60];
    LPTSTR lpDebugBuffer;
    va_list marker;
    DWORD dwErrCode;
    SYSTEMTIME systime;
    BOOL bDebugOutput = FALSE;
    BOOL bLogfileOutput = FALSE;

    //
    // Save the last error code (so the debug output doesn't change it).
    //

    dwErrCode = GetLastError();


    //
    // Determine the correct amount of debug output
    //

    switch (LOWORD(dwDebugLevel)) {

        case DL_VERBOSE:
            bOutput = TRUE;
            break;

        case DL_NORMAL:

            //
            // Normal debug output.  Don't
            // display verbose stuff, but
            // do display warnings/asserts.
            //

            if (mask != DM_VERBOSE) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;

        case DL_NONE:
        default:

            //
            // Only display asserts
            //

            if (mask == DM_ASSERT) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;
    }


    //
    // Display the error message if appropriate
    //

    bDebugOutput = dwDebugLevel & DL_DEBUGGER;
    bLogfileOutput = dwDebugLevel & DL_LOGFILE;

    if (bOutput) {
        INT iChars;

        lpDebugBuffer = (LPTSTR) LocalAlloc (LPTR, 2048 * sizeof(TCHAR));

        if (lpDebugBuffer) {

            GetLocalTime (&systime);
            wsprintf (szDebugTitle, c_szUserEnv,
                      GetCurrentProcessId(), GetCurrentThreadId(),
                      systime.wHour, systime.wMinute, systime.wSecond,
                      systime.wMilliseconds);

            if ( bDebugOutput)
                OutputDebugString(szDebugTitle);

            va_start(marker, pszMsg);
            iChars = wvsprintf(lpDebugBuffer, pszMsg, marker);

            DmAssert( iChars < 2048 );

            if ( bDebugOutput) {
                OutputDebugString(lpDebugBuffer);
                OutputDebugString(c_szCRLF);
            }

            va_end(marker);

            if ( bLogfileOutput ) {

                HANDLE hFile;
                DWORD dwBytesWritten;
                TCHAR szExpLogFileName[MAX_PATH+1];

                DWORD dwRet = ExpandEnvironmentStrings ( szLogFileName, szExpLogFileName, MAX_PATH+1);

                if ( dwRet != 0 && dwRet <= MAX_PATH) {

                    hFile = CreateFile( szExpLogFileName,
                                       FILE_WRITE_DATA | FILE_APPEND_DATA,
                                       FILE_SHARE_READ,
                                       NULL,
                                       OPEN_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL,
                                       NULL);

                    if (hFile != INVALID_HANDLE_VALUE) {

                        if (SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF) {

                            WriteFile (hFile, (LPCVOID) szDebugTitle,
                                       lstrlen (szDebugTitle) * sizeof(TCHAR),
                                       &dwBytesWritten,
                                       NULL);

                            WriteFile (hFile, (LPCVOID) lpDebugBuffer,
                                       lstrlen (lpDebugBuffer) * sizeof(TCHAR),
                                       &dwBytesWritten,
                                       NULL);

                            WriteFile (hFile, (LPCVOID) c_szCRLF,
                                       lstrlen (c_szCRLF) * sizeof(TCHAR),
                                       &dwBytesWritten,
                                       NULL);
                        }

                        CloseHandle (hFile);
                    }
                }

            }

            LocalFree (lpDebugBuffer);
        }
    }


    //
    // Restore the last error code
    //

    SetLastError(dwErrCode);


    //
    // Break to the debugger if appropriate
    //

#if DBG
    if (mask == DM_ASSERT) {
        DebugBreak();
    }
#endif
}



//*************************************************************
//
//  RsopLoggingEnabled()
//
//  Purpose:    Checks if Rsop logging is enabled.
//
//*************************************************************

extern "C"
BOOL RsopLoggingEnabled()
{
    return dwRsopLoggingLevel != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\utils\dllload.h ===
//*************************************************************
//  File name: dllload.h
//
//  Description:   DLL loading function proto-types
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1999
//  All rights reserved
//
//*************************************************************

void InitializeAPIs( void );
void CloseApiDLLsCritSec( void );

//
// NETAPI32 functions
//

typedef DWORD  (WINAPI * PFNDSGETDCNAMEA)(LPCSTR ComputerName,
                                  LPCSTR DomainName,
                                  GUID *DomainGuid,
                                  LPCSTR SiteName,
                                  ULONG Flags,
                                  PDOMAIN_CONTROLLER_INFOA *DomainControllerInfo);

typedef DWORD (WINAPI * PFNDSGETDCNAMEW) (LPCWSTR ComputerName,
                                  LPCWSTR DomainName,
                                  GUID *DomainGuid,
                                  LPCWSTR SiteName,
                                  ULONG Flags,
                                  PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo);

typedef DWORD (WINAPI * PFNDSGETSITENAMEA)(IN LPCSTR ComputerName OPTIONAL,
                                           OUT LPSTR *SiteName);

typedef DWORD (WINAPI * PFNDSGETSITENAMEW)(IN LPCWSTR ComputerName OPTIONAL,
                                           OUT LPWSTR *SiteName);

typedef DWORD (WINAPI * PFNDSROLEGETPRIMARYDOMAININFORMATION)(
                                  IN LPCWSTR lpServer OPTIONAL,
                                  IN DSROLE_PRIMARY_DOMAIN_INFO_LEVEL InfoLevel,
                                  OUT PBYTE *Buffer );

typedef VOID (WINAPI * PFNDSROLEFREEMEMORY)(IN PVOID Buffer);

typedef DWORD (*PFNNETAPIBUFFERFREE)(LPVOID Buffer);

typedef DWORD (*PFNNETUSERGETGROUPS)(
    LPCWSTR    servername,
    LPCWSTR    username,
    DWORD     level,
    LPBYTE    *bufptr,
    DWORD     prefmaxlen,
    LPDWORD   entriesread,
    LPDWORD   totalentries
    );

typedef DWORD (*PFNNETUSERGETINFO) (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     username,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr
    );


#ifdef UNICODE
#define PFNDSGETDCNAME            PFNDSGETDCNAMEW
#define PFNDSGETSITENAME          PFNDSGETSITENAMEW
#else
#define PFNDSGETDCNAME            PFNDSGETDCNAMEA
#define PFNDSGETSITENAME          PFNDSGETSITENAMEA
#endif

typedef struct _NETAPI32_API {
    HINSTANCE                hInstance;
    PFNDSGETDCNAME           pfnDsGetDcName;
    PFNDSGETSITENAME         pfnDsGetSiteName;
    PFNDSROLEGETPRIMARYDOMAININFORMATION pfnDsRoleGetPrimaryDomainInformation;
    PFNDSROLEFREEMEMORY      pfnDsRoleFreeMemory;
    PFNNETAPIBUFFERFREE      pfnNetApiBufferFree;
    PFNNETUSERGETGROUPS      pfnNetUserGetGroups;
    PFNNETUSERGETINFO        pfnNetUserGetInfo;
} NETAPI32_API, *PNETAPI32_API;


PNETAPI32_API LoadNetAPI32 ();



//
// SECUR32 functions
//


typedef BOOLEAN (*PFNGETUSERNAMEEXA)(
    EXTENDED_NAME_FORMAT  NameFormat,
    LPSTR lpNameBuffer,
    PULONG nSize
    );

typedef BOOLEAN (*PFNGETUSERNAMEEXW)(
    EXTENDED_NAME_FORMAT NameFormat,
    LPWSTR lpNameBuffer,
    PULONG nSize
    );

typedef BOOLEAN (*PFNGETCOMPUTEROBJECTNAMEA)(
    EXTENDED_NAME_FORMAT  NameFormat,
    LPSTR lpNameBuffer,
    PULONG nSize
    );

typedef BOOLEAN (*PFNGETCOMPUTEROBJECTNAMEW)(
    EXTENDED_NAME_FORMAT NameFormat,
    LPWSTR lpNameBuffer,
    PULONG nSize
    );

typedef BOOLEAN (*PFNTRANSLATENAMEA)(
    IN LPCSTR                lpAccountName,
    IN EXTENDED_NAME_FORMAT  AccountNameFormat,
    IN EXTENDED_NAME_FORMAT  DesiredNameFormat,
    IN LPSTR                 lpTranslatedName,
    IN PULONG                nSize
    );

typedef BOOLEAN (*PFNTRANSLATENAMEW)(
    IN LPCWSTR              lpAccountName,
    IN EXTENDED_NAME_FORMAT AccountNameFormat,
    IN EXTENDED_NAME_FORMAT DesiredNameFormat,
    IN LPWSTR               lpTranslatedName,
    IN PULONG               nSize
    );


#ifdef UNICODE
#define PFNGETUSERNAMEEX          PFNGETUSERNAMEEXW
#define PFNGETCOMPUTEROBJECTNAME  PFNGETCOMPUTEROBJECTNAMEW
#define PFNTRANSLATENAME          PFNTRANSLATENAMEW
#else
#define PFNGETUSERNAMEEX          PFNGETUSERNAMEEXA
#define PFNGETCOMPUTEROBJECTNAME  PFNGETCOMPUTEROBJECTNAMEA
#define PFNTRANSLATENAME          PFNTRANSLATENAMEA
#endif


typedef struct _SECUR32_API {
    HINSTANCE                       hInstance;
    PFNGETUSERNAMEEX                pfnGetUserNameEx;
    PFNGETCOMPUTEROBJECTNAME        pfnGetComputerObjectName;
    PFNTRANSLATENAME                pfnTranslateName;
    ACCEPT_SECURITY_CONTEXT_FN      pfnAcceptSecurityContext;
    ACQUIRE_CREDENTIALS_HANDLE_FN   pfnAcquireCredentialsHandle;
    DELETE_SECURITY_CONTEXT_FN      pfnDeleteSecurityContext;
    FREE_CONTEXT_BUFFER_FN          pfnFreeContextBuffer;
    FREE_CREDENTIALS_HANDLE_FN      pfnFreeCredentialsHandle;
    INITIALIZE_SECURITY_CONTEXT_FN  pfnInitializeSecurityContext;
    QUERY_SECURITY_CONTEXT_TOKEN_FN pfnQuerySecurityContextToken;
    QUERY_SECURITY_PACKAGE_INFO_FN  pfnQuerySecurityPackageInfo;

} SECUR32_API, *PSECUR32_API;


PSECUR32_API LoadSecur32 ();



//
// WLDAP32 functions
//

typedef LDAP * (LDAPAPI * PFNLDAP_OPENW)( PWCHAR HostName, ULONG PortNumber );
typedef LDAP * (LDAPAPI * PFNLDAP_OPENA)( PCHAR HostName, ULONG PortNumber );

typedef LDAP * (LDAPAPI * PFNLDAP_INITW)( PWCHAR HostName, ULONG PortNumber );
typedef LDAP * (LDAPAPI * PFNLDAP_INITA)( PCHAR HostName, ULONG PortNumber );

typedef ULONG (LDAPAPI * PFNLDAP_BIND_SW)( LDAP *ld, PWCHAR dn, PWCHAR cred, ULONG method );
typedef ULONG (LDAPAPI * PFNLDAP_BIND_SA)( LDAP *ld, PCHAR dn, PCHAR cred, ULONG method );

typedef ULONG (LDAPAPI * PFNLDAP_SEARCH_SW)(
        LDAP            *ld,
        PWCHAR          base,
        ULONG           scope,
        PWCHAR          filter,
        PWCHAR          attrs[],
        ULONG           attrsonly,
        LDAPMessage     **res
    );
typedef ULONG (LDAPAPI * PFNLDAP_SEARCH_SA)(
        LDAP            *ld,
        PCHAR           base,
        ULONG           scope,
        PCHAR           filter,
        PCHAR           attrs[],
        ULONG           attrsonly,
        LDAPMessage     **res
    );

typedef ULONG (LDAPAPI * PFNLDAP_SEARCH_EXT_SW)(
        LDAP            *ld,
        PWCHAR          base,
        ULONG           scope,
        PWCHAR          filter,
        PWCHAR          attrs[],
        ULONG           attrsonly,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        struct l_timeval  *timeout,
        ULONG           SizeLimit,
        LDAPMessage     **res
    );

typedef ULONG (LDAPAPI * PFNLDAP_SEARCH_EXT_SA)(
        LDAP            *ld,
        PCHAR           base,
        ULONG           scope,
        PCHAR           filter,
        PCHAR           attrs[],
        ULONG           attrsonly,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        struct l_timeval  *timeout,
        ULONG           SizeLimit,
        LDAPMessage     **res
    );

typedef PWCHAR * (LDAPAPI * PFNLDAP_GET_VALUESW)(
        LDAP            *ld,
        LDAPMessage     *entry,
        PWCHAR          attr
        );
typedef PCHAR * (LDAPAPI * PFNLDAP_GET_VALUESA)(
        LDAP            *ld,
        LDAPMessage     *entry,
        PCHAR           attr
        );

typedef ULONG (LDAPAPI * PFNLDAP_VALUE_FREEW)( PWCHAR *vals );
typedef ULONG (LDAPAPI * PFNLDAP_VALUE_FREEA)( PCHAR *vals );


typedef struct berval ** (LDAPAPI * PFNLDAP_GET_VALUES_LENW)(
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    PWCHAR          attr
    );
typedef struct berval ** (LDAPAPI * PFNLDAP_GET_VALUES_LENA) (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    PCHAR           attr
    );

typedef ULONG (LDAPAPI * PFNLDAP_VALUE_FREE_LEN)( struct berval **vals );

typedef ULONG (LDAPAPI * PFNLDAP_MSGFREE)( LDAPMessage *res );

typedef ULONG (LDAPAPI * PFNLDAP_UNBIND)( LDAP *ld );
typedef ULONG (LDAPAPI * PFNLDAPGETLASTERROR)( VOID );
typedef PWCHAR (LDAPAPI * PFNLDAP_ERR2STRINGW)( ULONG );
typedef PCHAR (LDAPAPI * PFNLDAP_ERR2STRINGA)( ULONG );

typedef LDAPMessage * (LDAPAPI * PFNLDAP_FIRST_ENTRY)( LDAP *ld, LDAPMessage *entry );
typedef LDAPMessage * (LDAPAPI * PFNLDAP_NEXT_ENTRY)( LDAP *ld, LDAPMessage *entry );

typedef PWCHAR (LDAPAPI * PFNLDAP_GET_DNW)( LDAP *ld, LDAPMessage *entry );
typedef PCHAR  (LDAPAPI * PFNLDAP_GET_DNA)( LDAP *ld, LDAPMessage *entry );

typedef ULONG (LDAPAPI *PFNLDAP_SET_OPTION)( LDAP *ld, int option, void *invalue );
typedef ULONG (LDAPAPI *PFNLDAP_SET_OPTIONW)( LDAP *ld, int option, void *invalue );

typedef VOID (LDAPAPI * PFNLDAP_MEMFREEW)( PWCHAR Block );
typedef VOID (LDAPAPI * PFNLDAP_MEMFREEA)( PCHAR Block );

typedef ULONG (LDAPAPI * PFNLDAP_CONNECT)( LDAP *ld, struct l_timeval  *timeout );

typedef ULONG (LDAPAPI * PFNLDAPMAPERRORTOWIN32)( ULONG LdapError );

//
// WNet functions
//

typedef DWORD (*PFNWNETGETCONNECTION)(LPCTSTR lpLocalName, LPTSTR lpRemoteName, LPDWORD lpnLength);
typedef DWORD (*PFNWNETGETRESOURCEINFORMATION)(LPNETRESOURCE lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPTSTR *lplpSystem);

//
// msi functions
//

typedef UINT (*PFNMSINOTIFYSIDCHANGE)(LPCTSTR pOldSid, LPCTSTR pNewSid);
typedef UINT (*PFNMSIDELETEUSERDATA)(LPCTSTR pSid, LPCTSTR szComputerName, LPVOID pReserved);


#ifdef UNICODE
#define PFNLDAP_OPEN              PFNLDAP_OPENW
#define PFNLDAP_INIT              PFNLDAP_INITW
#define PFNLDAP_BIND_S            PFNLDAP_BIND_SW
#define PFNLDAP_SEARCH_S          PFNLDAP_SEARCH_SW
#define PFNLDAP_SEARCH_EXT_S      PFNLDAP_SEARCH_EXT_SW
#define PFNLDAP_GET_VALUES        PFNLDAP_GET_VALUESW
#define PFNLDAP_VALUE_FREE        PFNLDAP_VALUE_FREEW
#define PFNLDAP_GET_VALUES_LEN    PFNLDAP_GET_VALUES_LENW
#define PFNLDAP_GET_DN            PFNLDAP_GET_DNW
#define PFNLDAP_MEMFREE           PFNLDAP_MEMFREEW
#define PFNLDAP_SET_OPTION        PFNLDAP_SET_OPTIONW
#define PFNLDAP_ERR2STRING        PFNLDAP_ERR2STRINGW
#else
#define PFNLDAP_OPEN              PFNLDAP_OPENA
#define PFNLDAP_INIT              PFNLDAP_INITA
#define PFNLDAP_BIND_S            PFNLDAP_BIND_SA
#define PFNLDAP_SEARCH_S          PFNLDAP_SEARCH_SA
#define PFNLDAP_SEARCH_EXT_S      PFNLDAP_SEARCH_EXT_SA
#define PFNLDAP_GET_VALUES        PFNLDAP_GET_VALUESA
#define PFNLDAP_VALUE_FREE        PFNLDAP_VALUE_FREEA
#define PFNLDAP_GET_VALUES_LEN    PFNLDAP_GET_VALUES_LENA
#define PFNLDAP_GET_DN            PFNLDAP_GET_DNA
#define PFNLDAP_MEMFREE           PFNLDAP_MEMFREEA
#define PFNLDAP_ERR2STRING        PFNLDAP_ERR2STRINGA
#endif

typedef struct _LDAP_API {
    HINSTANCE                hInstance;
    PFNLDAP_OPEN             pfnldap_open;
    PFNLDAP_INIT             pfnldap_init;
    PFNLDAP_CONNECT          pfnldap_connect;
    PFNLDAP_BIND_S           pfnldap_bind_s;
    PFNLDAP_SEARCH_S         pfnldap_search_s;
    PFNLDAP_SEARCH_EXT_S     pfnldap_search_ext_s;
    PFNLDAP_GET_VALUES       pfnldap_get_values;
    PFNLDAP_VALUE_FREE       pfnldap_value_free;
    PFNLDAP_GET_VALUES_LEN   pfnldap_get_values_len;
    PFNLDAP_VALUE_FREE_LEN   pfnldap_value_free_len;
    PFNLDAP_MSGFREE          pfnldap_msgfree;
    PFNLDAP_UNBIND           pfnldap_unbind;
    PFNLDAPGETLASTERROR      pfnLdapGetLastError;
    PFNLDAP_FIRST_ENTRY      pfnldap_first_entry;
    PFNLDAP_NEXT_ENTRY       pfnldap_next_entry;
    PFNLDAP_GET_DN           pfnldap_get_dn;
    PFNLDAP_SET_OPTION       pfnldap_set_option;
    PFNLDAP_MEMFREE          pfnldap_memfree;
    PFNLDAPMAPERRORTOWIN32   pfnLdapMapErrorToWin32;
    PFNLDAP_ERR2STRING       pfnldap_err2string;
} LDAP_API, *PLDAP_API;

PLDAP_API LoadLDAP();

//
// ICMP functions
//
typedef HANDLE (*PFNICMPCREATEFILE)(VOID);
typedef BOOL (*PFNICMPCLOSEHANDLE)(HANDLE IcmpHandle);
typedef DWORD (*PFNICMPSENDECHO)(
               HANDLE                   IcmpHandle,
               IPAddr                   DestinationAddress,
               LPVOID                   RequestData,
               WORD                     RequestSize,
               PIP_OPTION_INFORMATION   RequestOptions,
               LPVOID                   ReplyBuffer,
               DWORD                    ReplySize,
               DWORD                    Timeout
               );


typedef struct _ICMP_API {
    HINSTANCE                   hInstance;
    PFNICMPCREATEFILE           pfnIcmpCreateFile;
    PFNICMPCLOSEHANDLE          pfnIcmpCloseHandle;
    PFNICMPSENDECHO             pfnIcmpSendEcho;
} ICMP_API, *PICMP_API;


DWORD LoadIcmp (PICMP_API *);



//
// WSOCK32 functions
//


typedef struct _WSOCK32_API {
    HINSTANCE                   hInstance;
    LPFN_INET_ADDR              pfninet_addr;
    LPFN_GETHOSTBYNAME          pfngethostbyname;
} WSOCK32_API, *PWSOCK32_API;


PWSOCK32_API LoadWSock32 ();


//
// DSAPI functions
//

typedef DWORD (WINAPI *PFN_DSCRACKNAMESW)( HANDLE  hDS,
                                           DS_NAME_FLAGS flags,
                                           DS_NAME_FORMAT formatOffered,
                                           DS_NAME_FORMAT formatDesired,
                                           DWORD cNames,
                                           const LPCWSTR *rpNames,
                                           PDS_NAME_RESULTW *ppResult);

typedef DWORD (WINAPI *PFN_DSCRACKNAMESA)( HANDLE  hDS,
                                           DS_NAME_FLAGS flags,
                                           DS_NAME_FORMAT formatOffered,
                                           DS_NAME_FORMAT formatDesired,
                                           DWORD cNames,
                                           const LPCSTR *rpNames,
                                           PDS_NAME_RESULTA *ppResult);

typedef void (WINAPI *PFN_DSFREENAMERESULTW)( DS_NAME_RESULTW *pResult);

typedef void (WINAPI *PFN_DSFREENAMERESULTA)( DS_NAME_RESULTA *pResult);


#ifdef UNICODE
#define PFN_DSCRACKNAMES          PFN_DSCRACKNAMESW
#define PFN_DSFREENAMERESULT      PFN_DSFREENAMERESULTW
#else
#define PFN_DSCRACKNAMES          PFN_DSCRACKNAMESA
#define PFN_DSFREENAMERESULT      PFN_DSFREENAMERESULTA
#endif

typedef struct _DS_API {
    HINSTANCE                   hInstance;
    PFN_DSCRACKNAMES            pfnDsCrackNames;
    PFN_DSFREENAMERESULT        pfnDsFreeNameResult;
} DS_API, *PDS_API;


PDS_API LoadDSApi();

//
// Ole32 functions
//

typedef HRESULT (*PFNCOCREATEINSTANCE)(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                 DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);

typedef HRESULT (*PFNCOINITIALIZE)(LPVOID pvReserved);
typedef HRESULT (*PFNCOINITIALIZEEX)(LPVOID pvReserved, DWORD dwCoInit);
typedef VOID    (*PFNCOUNINITIALIZE)(VOID);

typedef HRESULT (*PFNCOCREATEGUID)(GUID *pGuid );

typedef VOID (*PFNINITCOMMONCONTROLS)(VOID);

typedef struct _OLE32_API {
    HINSTANCE                   hInstance;
    PFNCOCREATEINSTANCE         pfnCoCreateInstance;
    PFNCOINITIALIZEEX           pfnCoInitializeEx;
    PFNCOUNINITIALIZE           pfnCoUnInitialize;
    PFNCOCREATEGUID             pfnCoCreateGuid;
} OLE32_API, *POLE32_API;

POLE32_API LoadOle32Api();

//
// Shell32 functions
//

typedef VOID (*PFNSHCHANGENOTIFY)(LONG wEventId, UINT uFlags,
                                  LPCVOID dwItem1, LPCVOID dwItem2);

typedef BOOL (*PFNSHGETSPECIALFOLDERPATHA)(HWND hwnd, LPSTR lpszPath,
                                           int csidl, BOOL fCreate);
typedef BOOL (*PFNSHGETSPECIALFOLDERPATHW)(HWND hwnd, LPWSTR lpszPath,
                                           int csidl, BOOL fCreate);

typedef HRESULT (*PFNSHGETFOLDERPATHA)(HWND hwnd, int csidl, HANDLE hToken,
                                       DWORD dwFlags, LPSTR pszPath);

typedef HRESULT (*PFNSHGETFOLDERPATHW)(HWND hwnd, int csidl, HANDLE hToken,
                                       DWORD dwFlags, LPWSTR pszPath);

typedef HRESULT (*PFNSHSETFOLDERPATHA)(int csidl, HANDLE hToken,
                                       DWORD dwFlags, LPSTR pszPath);

typedef HRESULT (*PFNSHSETFOLDERPATHW)(int csidl, HANDLE hToken,
                                       DWORD dwFlags, LPWSTR pszPath);

typedef HRESULT (*PFNSHSETLOCALIZEDNAME)(LPWSTR pszPath,
                                         LPCWSTR pszResModule, int idsRes);

#ifdef UNICODE
#define PFNSHGETSPECIALFOLDERPATH PFNSHGETSPECIALFOLDERPATHW
#define PFNSHGETFOLDERPATH        PFNSHGETFOLDERPATHW
#define PFNSHSETFOLDERPATH        PFNSHSETFOLDERPATHW
#else
#define PFNSHGETSPECIALFOLDERPATH PFNSHGETSPECIALFOLDERPATHA
#define PFNSHGETFOLDERPATH        PFNSHGETFOLDERPATHA
#define PFNSHSETFOLDERPATH        PFNSHSETFOLDERPATHA
#endif

#define SHSetFolderA_Ord        231
#define SHSetFolderW_Ord        232

typedef struct _SHELL32_API {
    HINSTANCE                   hInstance;
    PFNSHGETSPECIALFOLDERPATH   pfnShGetSpecialFolderPath;
    PFNSHGETFOLDERPATH          pfnShGetFolderPath;
    PFNSHSETFOLDERPATH          pfnShSetFolderPath;
    PFNSHCHANGENOTIFY           pfnShChangeNotify;
    PFNSHSETLOCALIZEDNAME       pfnShSetLocalizedName;
} SHELL32_API, *PSHELL32_API;

DWORD LoadShell32Api( PSHELL32_API * );

//
// shlwapi functions
//

typedef LPSTR  (*PFNPATHGETARGSA)(LPCSTR pszPath);
typedef LPWSTR (*PFNPATHGETARGSW)(LPCWSTR pszPath);

typedef VOID   (*PFNPATHUNQUOTESPACESA)(LPSTR lpsz);
typedef VOID   (*PFNPATHUNQUOTESPACESW)(LPWSTR lpsz);

#ifdef UNICODE
#define PFNPATHGETARGS            PFNPATHGETARGSW
#define PFNPATHUNQUOTESPACES      PFNPATHUNQUOTESPACESW
#else
#define PFNPATHGETARGS            PFNPATHGETARGSA
#define PFNPATHUNQUOTESPACES      PFNPATHUNQUOTESPACESA
#endif

typedef struct _SHLWAPI_API {
    HINSTANCE                   hInstance;
    PFNPATHGETARGS              pfnPathGetArgs;
    PFNPATHUNQUOTESPACES        pfnPathUnquoteSpaces;
} SHLWAPI_API, *PSHLWAPI_API;

PSHLWAPI_API LoadShlwapiApi();

//
// Gptext.dll functions
//

typedef BOOL (*PFNPARSEADMFILE)( WCHAR *pwszAdmFile, BOOL bUser, void **ppAdmHandle );
typedef BOOL (*PFNFREEADMDATA)( void *pAdmHandle );
typedef DWORD (*PFNSCRREGGPOLISTTOWBEM)( LPWSTR szSID, IWbemServices*  pServices );

typedef struct _GPTEXT_API {
    HINSTANCE          hInstance;
    PFNSCRREGGPOLISTTOWBEM pfnScrRegGPOListToWbem;
} GPTEXT_API;

GPTEXT_API *LoadGpTextApi();


//
// iphlpapi.dll functions
//

typedef DWORD (WINAPI *PFNGETBESTINTERFACE)(IPAddr  dwDestAddr, PDWORD  pdwBestIfIndex);
typedef DWORD (WINAPI *PFNGETIFENTRY)(PMIB_IFROW   pIfRow);
typedef DWORD (WINAPI *PFNGETADAPTERINDEX)(LPWSTR, PULONG);

typedef struct _IPHLPAPI_API
{
    HINSTANCE           hInstance;
    PFNGETBESTINTERFACE pfnGetBestInterface;
    PFNGETIFENTRY       pfnGetIfEntry;
    PFNGETADAPTERINDEX  pfnGetAdapterIndex;
} IPHLPAPI_API, *PIPHLPAPI_API;

PIPHLPAPI_API LoadIpHlpApi();

//
// ws2_32.dll functions
//

typedef INT (WINAPI *PFNWSALOOKUPSERVICEBEGIN)( LPWSAQUERYSET, DWORD, LPHANDLE );
typedef INT (WINAPI *PFNWSALOOKUPSERVICENEXT)( HANDLE, DWORD, LPDWORD, LPWSAQUERYSET );
typedef INT (WINAPI *PFNWSALOOKUPSERVICEEND)( HANDLE );
typedef INT (WINAPI *PFNWSASTARTUP)( WORD, LPWSADATA );
typedef INT (WINAPI *PFNWSACLEANUP)();
typedef INT (WINAPI *PFNWSAGETLASTERROR)();

typedef struct _WS2_32_API
{
    HINSTANCE                   hInstance;
    PFNWSALOOKUPSERVICEBEGIN    pfnWSALookupServiceBegin;
    PFNWSALOOKUPSERVICENEXT     pfnWSALookupServiceNext;
    PFNWSALOOKUPSERVICEEND      pfnWSALookupServiceEnd;
    PFNWSASTARTUP               pfnWSAStartup;
    PFNWSACLEANUP               pfnWSACleanup;
    PFNWSAGETLASTERROR          pfnWSAGetLastError;
} WS2_32_API, *PWS2_32_API;

PWS2_32_API Loadws2_32Api();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\utils\events.cpp ===
//*************************************************************
//
//  Events.c    -   Routines to handle the event log
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include "profmgr.hxx"

//
//  XPSP1 specific
//
#include "xpsp1res.h"

extern CUserProfile cUserProfileManager;

HANDLE  hEventLog = NULL;
TCHAR   EventSourceName[] = TEXT("Userenv");
INT_PTR APIENTRY ErrorDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL GetShareName(LPTSTR lpDir, LPTSTR *lppShare);

//*************************************************************
//
//  InitializeEvents()
//
//  Purpose:    Opens the event log
//
//  Parameters: void
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/17/95     ericflo    Created
//
//*************************************************************

BOOL InitializeEvents (void)
{
    //
    // Open the event source
    //

    hEventLog = RegisterEventSource(NULL, EventSourceName);

    if (hEventLog) {
        return TRUE;
    }

    DebugMsg((DM_WARNING, TEXT("InitializeEvents:  Could not open event log.  Error = %d"), GetLastError()));
    return FALSE;
}



//*************************************************************
//
//  Implementation of CEvents
//
//*************************************************************



//*************************************************************
//  CEvents::CEvents
//  Purpose:    Constructor
//
//  Parameters:
//      dwFlags - Error, Warning or informational
//      dwId    - Id of the eventlog msg
//
//
//  allocates a default sized array for the messages
//*************************************************************

#define DEF_ARG_SIZE 10

CEvents::CEvents(DWORD dwFlags, DWORD dwId ) :
                          m_cStrings(0), m_cAllocated(0), m_bInitialised(FALSE),
                          m_dwEventType(dwFlags), m_dwId(dwId), m_bFailed(TRUE)
{
    XLastError xe;
    //
    // Allocate a default size for the message
    //

    m_xlpStrings = (LPTSTR *)LocalAlloc(LPTR, sizeof(LPTSTR)*DEF_ARG_SIZE);
    m_cAllocated = DEF_ARG_SIZE;
    if (!m_xlpStrings) {
        DebugMsg((DM_WARNING, TEXT("CEvent::CEvent  Cannot log event, failed to allocate memory, error %d"), GetLastError()));
        return;
    }


    //
    // Initialise eventlog if it is not already initialised
    //

    if (!hEventLog) {
        if (!InitializeEvents()) {
            DebugMsg((DM_WARNING, TEXT("CEvent::CEvent  Cannot log event, no handle")));
            return;
        }
    }

    m_bInitialised = TRUE;
    m_bFailed = FALSE;
}



//*************************************************************
//  CEvents::~CEvents()
//
//  Purpose:    Destructor
//
//  Parameters: void
//
//  frees the memory
//*************************************************************

CEvents::~CEvents()
{
    XLastError xe;
    for (int i = 0; i < m_cStrings; i++)
        if (m_xlpStrings[i])
            LocalFree(m_xlpStrings[i]);
}

//*************************************************************
//
//  CEvents::ReallocArgStrings
//
//  Purpose: Reallocates the buffer for storing arguments in case
//           the buffer runs out
//
//  Parameters: void
//
//  reallocates
//*************************************************************

BOOL CEvents::ReallocArgStrings()
{
    XPtrLF<LPTSTR>  aStringsNew;
    XLastError xe;


    //
    // first allocate a larger buffer
    //

    aStringsNew = (LPTSTR *)LocalAlloc(LPTR, sizeof(LPTSTR)*(m_cAllocated+DEF_ARG_SIZE));

    if (!aStringsNew) {
        DebugMsg((DM_WARNING, TEXT("CEvent::ReallocArgStrings  Cannot add memory, error = %d"), GetLastError()));
        m_bFailed = TRUE;
        return FALSE;
    }


    //
    // copy the arguments
    //

    for (int i = 0; i < (m_cAllocated); i++) {
        aStringsNew[i] = m_xlpStrings[i];
    }

    m_xlpStrings = aStringsNew.Acquire();
    m_cAllocated+= DEF_ARG_SIZE;

    return TRUE;
}



//*************************************************************
//
//  CEvents::AddArg
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters:
//
//*************************************************************

BOOL CEvents::AddArg(LPTSTR szArg)
{
    XLastError xe;
    
    if ((!m_bInitialised) || (m_bFailed)) {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArg:  Cannot log event, not initialised or failed before")));
        return FALSE;
    }

    if (m_cStrings == m_cAllocated) {
        if (!ReallocArgStrings())
            return FALSE;
    }


    m_xlpStrings[m_cStrings] = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(szArg)+1));

    if (!m_xlpStrings[m_cStrings]) {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArg  Cannot allocate memory, error = %d"), GetLastError()));
        m_bFailed = TRUE;
        return FALSE;
    }


    lstrcpy(m_xlpStrings[m_cStrings], szArg);
    m_cStrings++;

    return TRUE;
}


//*************************************************************
//
//  CEvents::AddArg
//
//  Purpose: Add arguments appropriately truncated
//
//  Parameters: szArgFormat - sprintf format, e.g. %.500s
//
//*************************************************************

BOOL CEvents::AddArg(LPTSTR szArgFormat, LPTSTR szArg)
{
    if ((!m_bInitialised) || (m_bFailed)) {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArg:  Cannot log event, not initialised or failed before")));
        return FALSE;
    }

    if (m_cStrings == m_cAllocated) {
        if (!ReallocArgStrings())
            return FALSE;
    }


    m_xlpStrings[m_cStrings] = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(szArg)+1));

    if (!m_xlpStrings[m_cStrings]) {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArg  Cannot allocate memory, error = %d"), GetLastError()));
        m_bFailed = TRUE;
        return FALSE;
    }

    wsprintf(m_xlpStrings[m_cStrings], szArgFormat, szArg);
    m_cStrings++;

    return TRUE;
}


//*************************************************************
//
//  CEvents::AddArg
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters:
//
//*************************************************************

BOOL CEvents::AddArg(DWORD dwArg)
{
    XLastError xe;
    
    if ((!m_bInitialised) || (m_bFailed)) {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArg(dw):  Cannot log event, not initialised or failed before")));
        return FALSE;
    }

    if (m_cStrings == m_cAllocated) {
        if (!ReallocArgStrings())
            return FALSE;
    }

    // 2^32 < 10^10
    m_xlpStrings[m_cStrings] = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*20);

    if (!m_xlpStrings[m_cStrings]) {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArg  Cannot allocate memory, error = %d"), GetLastError()));
        m_bFailed = TRUE;
        return FALSE;
    }


    wsprintf(m_xlpStrings[m_cStrings], TEXT("%d"), dwArg);
    m_cStrings++;

    return TRUE;
}

//*************************************************************
//
//  CEvents::AddArgHex
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters:
//
//*************************************************************

BOOL CEvents::AddArgHex(DWORD dwArg)
{
    XLastError xe;
    
    if ((!m_bInitialised) || (m_bFailed)) {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArgHex:  Cannot log event, not initialised or failed before")));
        return FALSE;
    }

    if (m_cStrings == m_cAllocated) {
        if (!ReallocArgStrings())
            return FALSE;
    }


    m_xlpStrings[m_cStrings] = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*20);

    if (!m_xlpStrings[m_cStrings]) {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArgHex  Cannot allocate memory, error = %d"), GetLastError()));
        m_bFailed = TRUE;
        return FALSE;
    }


    wsprintf(m_xlpStrings[m_cStrings], TEXT("%#x"), dwArg);
    m_cStrings++;

    return TRUE;
}

//*************************************************************
//
//  CEvents::AddArgWin32Error
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters:
//
//*************************************************************

BOOL CEvents::AddArgWin32Error(DWORD dwArg)
{
    XLastError xe;

    if ((!m_bInitialised) || (m_bFailed))
    {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArgWin32Error:  Cannot log event, not initialised or failed before")));
        return FALSE;
    }

    if (m_cStrings == m_cAllocated)
    {
        if (!ReallocArgStrings())
            return FALSE;
    }

    if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                         0,
                         dwArg,
                         0,
                         (LPTSTR) &m_xlpStrings[m_cStrings],
                         1,
                         0 ) == 0 )
    {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArgWin32Error: Cannot log event, FormatMessage failed, %d"), GetLastError()));
        m_bFailed = TRUE;
        return FALSE;
    }
    
    m_cStrings++;

    return TRUE;
}

//*************************************************************
//
//  CEvents::AddArgLdapError
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters:
//
//*************************************************************

BOOL CEvents::AddArgLdapError(DWORD dwArg)
{
    XLastError xe;
    PLDAP_API pLdap = LoadLDAP();

    if ( pLdap )
    {
        return AddArg( pLdap->pfnldap_err2string( dwArg ) );
    }
    else
    {
        return FALSE;
    }
}

//*************************************************************
//
//  CEvents::Report
//
//  Purpose: Actually collectes all the arguments and reports it to
//           the eventlog
//
//  Parameters: void
//
//*************************************************************

BOOL CEvents::Report()
{
    XLastError xe;
    XHandle xhToken;
    PSID pSid = NULL;
    WORD wType=0;
    BOOL bResult = TRUE;

    if ((!m_bInitialised) || (m_bFailed))
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::Report:  Cannot log event, not initialised or failed before")));
        return FALSE;
    }

    //
    // Get the caller's token
    //
    if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE,
                          TRUE, &xhToken))
    {
         OpenProcessToken(GetCurrentProcess(), TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE,
                          &xhToken);
    }

    //
    // Get the caller's sid
    //
    if (xhToken)
    {
        pSid = GetUserSid(xhToken);

        if (!pSid)
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::Report:  Failed to get the sid")));
        }
    }

    if (m_dwEventType & EVENT_INFO_TYPE)
    {
        wType = EVENTLOG_INFORMATION_TYPE;
    }
    else if (m_dwEventType & EVENT_WARNING_TYPE)
    {
        wType = EVENTLOG_WARNING_TYPE;
    }
    else
    {
        wType = EVENTLOG_ERROR_TYPE;
    }

    if ( !ReportEvent(  hEventLog,
                        wType,
                        0,
                        m_dwId,
                        pSid,
                        m_cStrings,
                        0,
                        (LPCTSTR *)((LPTSTR *)m_xlpStrings),
                        0 ) )
    {
        DebugMsg((DM_WARNING,  TEXT("CEvents::Report: ReportEvent failed.  Error = %d"), GetLastError()));
        bResult = FALSE;
    }

    if (pSid)
    {
        DeleteUserSid(pSid);
    }

    return bResult;
}



LPTSTR CEvents::FormatString()
{
    LPTSTR      szMsg=NULL;
    HINSTANCE   hResSource = g_hDllInstance;

    if ((!m_bInitialised) || (m_bFailed)) {
        DebugMsg((DM_WARNING, TEXT("CEvents::Report:  Cannot log event, not initialised or failed before")));
        goto Exit;
    }

    //
    // XPSP1 specific: New message in XPSP1, load it from xpsp1res.dll
    //
    if (m_dwId == EVENT_LOGON_RUP_NOT_SECURE) 
    {
        hResSource = LoadLibraryEx(TEXT("xpsp1res.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (!hResSource)
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::FormatString:  LoadLibraryEx failed with %d"), GetLastError()));
            goto Exit;
        }
    }
    
    if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                       FORMAT_MESSAGE_FROM_HMODULE | 
                       FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       hResSource,
                       m_dwId,
                       0,
                       (LPTSTR)&szMsg,
                       0, // min number of chars
                       (va_list *)(LPTSTR *)(m_xlpStrings))) {
        
        DebugMsg((DM_WARNING,  TEXT("CEvents::FormatString: FormatMessage failed.  Error = %d"), GetLastError()));
        goto Exit;
    }

Exit:    
    if (hResSource && hResSource != g_hDllInstance)
    {
        if (!FreeLibrary(hResSource))
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::FormatString:  FreeLibrary failed with %d"), GetLastError()));
        }
    }
    return szMsg;
}



//*************************************************************
//
//  LogEvent()
//
//  Purpose:    Logs an event to the event log
//
//  Parameters: dwFlags     -   Error, Warning or informational
//              idMsg       -   Message id
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/5/98      ericflo    Created
//
//*************************************************************

int LogEvent (DWORD dwFlags, UINT idMsg, ...)
{
    XLastError xe;
    TCHAR szMsg[MAX_PATH];
    LPTSTR lpErrorMsg;
    va_list marker;
    INT iChars;
    CEvents ev(dwFlags, EVENT_ERROR);

    //
    // Load the message
    //

    if (idMsg != 0) {
        if (!LoadString (g_hDllInstance, idMsg, szMsg, ARRAYSIZE(szMsg))) {
            DebugMsg((DM_WARNING, TEXT("LogEvent:  LoadString failed.  Error = %d"), GetLastError()));
            return -1;
        }

    } else {
        lstrcpy (szMsg, TEXT("%s"));
    }


    //
    // Allocate space for the error message
    //

    lpErrorMsg = (LPTSTR) LocalAlloc (LPTR, (4 * MAX_PATH + 100) * sizeof(TCHAR));

    if (!lpErrorMsg) {
        DebugMsg((DM_WARNING, TEXT("LogEvent:  LocalAlloc failed.  Error = %d"), GetLastError()));
        return -1;
    }


    //
    // Plug in the arguments
    //

    va_start(marker, idMsg);
    iChars = wvsprintf(lpErrorMsg, szMsg, marker);

    DmAssert( iChars < (4 * MAX_PATH + 100));

    va_end(marker);

    //
    // Now add this string to the arg list
    //

    ev.AddArg(lpErrorMsg);


    //
    // report
    //

    ev.Report();

    LocalFree (lpErrorMsg);

    return 0;
}

//*************************************************************
//
//  ShutdownEvents()
//
//  Purpose:    Stops the event log
//
//  Parameters: void
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/17/95     ericflo    Created
//
//*************************************************************

BOOL ShutdownEvents (void)
{
    BOOL bRetVal = TRUE;

    if (hEventLog) {
        bRetVal = DeregisterEventSource(hEventLog);
        hEventLog = NULL;
    }

    return bRetVal;
}


//*************************************************************
//
//  ReportError()
//
//  Purpose:    Displays an error message to the user and
//              records it in the event log
//
//  Parameters: dwFlags     -   Flags. Also indicates event type.
//                              Default is Error.                   
//              dwCount     -   Number of string arguments
//              idMsg       -   Error message id
//              ...         -   String arguments
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   For EVENT_COPYERROR message we have to get the share 
//              name for the mapped drive.
//              Be careful in future, if we add a new error message with 
//              dir name in it.
//
//  History:    Date        Author     Comment
//              7/18/95     ericflo    Created
//              9/03/00     santanuc   Modified to work for client 
//
//*************************************************************


int ReportError (HANDLE hTokenUser, DWORD dwFlags, DWORD dwCount, UINT idMsg, ...)
{
    TCHAR            szMsg[MAX_PATH];
    LPTSTR           lpErrorMsg=NULL, szArg;
    va_list          marker;
    INT              iChars;
    BOOL             bImpersonated = FALSE;
    HANDLE           hOldToken;
    LPTSTR           szSidUser = NULL;
    DWORD            dwErr = ERROR_SUCCESS;
    handle_t         hIfProfileDialog;         // rpc explicit binding handle for IProfileDialog interface
    LPTSTR           lpRPCEndPoint = NULL;     // RPCEndPoint for IProfileDialog interface registered in client side
    RPC_ASYNC_STATE  AsyncHnd;                 // Async handle for making async rpc interface calls
    RPC_STATUS       status = RPC_S_OK;
    LPTSTR           lpShare = NULL;
   

    if (hTokenUser) {
        if (!ImpersonateUser(hTokenUser, &hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("ReportError: ImpersonateUser failed with error %d."), GetLastError()));
        }
        else {
            bImpersonated = TRUE;
            DebugMsg((DM_WARNING, TEXT("ReportError: Impersonating user.")));
        }
    }
    
    CEvents ev(dwFlags, idMsg);
   
    //
    // Plug in the arguments
    //

    va_start(marker, idMsg);

    for (DWORD i = 0; i < dwCount; i++) {
        szArg = va_arg(marker, LPTSTR);

        //
        // Only EVENT_COPYERROR has first two parameters as dir name. So try to replace 
        // the mapped drive with correct share name
        //

        if (idMsg == EVENT_COPYERROR && i < 2 && GetShareName(szArg, &lpShare)) {
            ev.AddArg(lpShare);
            LocalFree(lpShare);
        }
        else {
            ev.AddArg(szArg);
        }
    }

    va_end(marker);

    

    if (!(dwFlags & PI_NOUI)) {

        DWORD dwDlgTimeOut = PROFILE_DLG_TIMEOUT;
        DWORD dwSize, dwType;
        LONG lResult;
        HKEY hKey;

        //
        // Find the dialog box timeout
        //

        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               WINLOGON_KEY,
                               0,
                               KEY_READ,
                               &hKey);

        if (lResult == ERROR_SUCCESS) {

            dwSize = sizeof(DWORD);
            RegQueryValueEx (hKey,
                             TEXT("ProfileDlgTimeOut"),
                             NULL,
                             &dwType,
                             (LPBYTE) &dwDlgTimeOut,
                             &dwSize);


            RegCloseKey (hKey);
        }


        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               SYSTEM_POLICIES_KEY,
                               0,
                               KEY_READ,
                               &hKey);

        if (lResult == ERROR_SUCCESS) {

            dwSize = sizeof(DWORD);
            RegQueryValueEx (hKey,
                             TEXT("ProfileDlgTimeOut"),
                             NULL,
                             &dwType,
                             (LPBYTE) &dwDlgTimeOut,
                             &dwSize);


            RegCloseKey (hKey);
        }


        lpErrorMsg = ev.FormatString();

        if (lpErrorMsg) {
            
            DebugMsg((DM_VERBOSE, TEXT("ReportError: Logging Error <%s> \n"), lpErrorMsg));

            //
            // Display the message
            //

            szSidUser = GetSidString(hTokenUser);
            if (szSidUser) {

                //
                // Get the registered interface explicit binding handle using RPCEndPoint
                //

                if (cUserProfileManager.IsConsoleWinlogon()) {
                    lpRPCEndPoint = cUserProfileManager.GetRPCEndPoint(szSidUser);
                }
                if (lpRPCEndPoint && GetInterface(&hIfProfileDialog, lpRPCEndPoint)) {
                    DebugMsg((DM_VERBOSE, TEXT("ReportError: RPC End point %s"), lpRPCEndPoint));

                    status = RpcAsyncInitializeHandle(&AsyncHnd, sizeof(RPC_ASYNC_STATE));
                    if (status != RPC_S_OK) {
                        dwErr = status;
                        DebugMsg((DM_WARNING, TEXT("ReportError: RpcAsyncInitializeHandle failed. err = %d"), dwErr));
                    }
                    else {
                        AsyncHnd.UserInfo = NULL;                                    // App specific info, not req
                        AsyncHnd.NotificationType = RpcNotificationTypeEvent;        // Init the notification event
                        AsyncHnd.u.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
                    
                        if (AsyncHnd.u.hEvent) {
                            RpcTryExcept {
                                cliErrorDialog(&AsyncHnd, hIfProfileDialog, dwDlgTimeOut, lpErrorMsg);
                            }
                            RpcExcept(1) {
                                dwErr = RpcExceptionCode();
                                DebugMsg((DM_WARNING, TEXT("ReportError: Calling ErrorDialog took exception. err = %d"), dwErr));
                            }
                            RpcEndExcept

                            DebugMsg((DM_VERBOSE, TEXT("ReportError: waiting on rpc async event")));
                            if (WaitForSingleObject(AsyncHnd.u.hEvent, (dwDlgTimeOut + 10)*1000) == WAIT_OBJECT_0) {
                                RpcAsyncCompleteCall(&AsyncHnd, (PVOID)&dwErr);
                            }
                            else {
                                dwErr = GetLastError();
                                RpcAsyncCancelCall(&AsyncHnd, TRUE);
                                DebugMsg((DM_WARNING, TEXT("ReportError: Timeout occurs. Client not responding"), dwErr));
                            }

                            // Release the resource

                            CloseHandle(AsyncHnd.u.hEvent);
                        }
                        else {
                            dwErr = GetLastError();
                            DebugMsg((DM_VERBOSE, TEXT("ReportError: create event failed error %d"), dwErr));
                        }
                    }

                    if (dwErr != ERROR_SUCCESS) {
                        DebugMsg((DM_WARNING, TEXT("ReportError: fail to show message error %d"), GetLastError()));
                    }

                    ReleaseInterface(&hIfProfileDialog);  // Release the binding handle
                }
                DeleteSidString(szSidUser);
            }
            else {
                DebugMsg((DM_WARNING, TEXT("ReportError: Unable to get SID string from token.")));
            }

            if (!lpRPCEndPoint) {

                //
                // This can happen in two case :
                //     1. We are in console winlogon process.
                //     2. ReportError get called from some public api which we expose.
                //

                ErrorDialogEx(dwDlgTimeOut, lpErrorMsg);
            }
        }
    }


    //
    // Report the event to the eventlog
    //

    ev.Report();

    if (lpErrorMsg) 
        LocalFree (lpErrorMsg);

    if (bImpersonated)
        RevertToUser(&hOldToken);

    return 0;
}

//*************************************************************
//
//  ErrorDialogEx()
//
//  Purpose:    Call Dialog box procedure for displaying error message
//
//  Parameters: dwTimeOut - Timeout in secs
//              lpErrMsg  - Error Message
//
//  Return:     None
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/27/00    santanuc   Created
//
//*************************************************************
void ErrorDialogEx(DWORD dwTimeOut, LPTSTR lpErrMsg)
{
    ERRORSTRUCT es;

    es.dwTimeOut = dwTimeOut;
    es.lpErrorText = lpErrMsg;

    DebugMsg((DM_VERBOSE, TEXT("ErrorDialogEx: Calling DialogBoxParam")));
    DialogBoxParam (g_hDllInstance, MAKEINTRESOURCE(IDD_ERROR),
                    NULL, ErrorDlgProc, (LPARAM)&es);
}

//*************************************************************
//
//  ErrorDlgProc()
//
//  Purpose:    Dialog box procedure for the error dialog
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/22/96     ericflo    Created
//
//*************************************************************

INT_PTR APIENTRY ErrorDlgProc (HWND hDlg, UINT uMsg,
                            WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuffer[10];
    static DWORD dwErrorTime;

    switch (uMsg) {

        case WM_INITDIALOG:
           {
           DebugMsg((DM_VERBOSE, TEXT("ErrorDlgProc:: DialogBoxParam")));
           LPERRORSTRUCT lpES = (LPERRORSTRUCT) lParam;

           SetForegroundWindow(hDlg);
           CenterWindow (hDlg);
           SetDlgItemText (hDlg, IDC_ERRORTEXT, lpES->lpErrorText);

           dwErrorTime = lpES->dwTimeOut;

           if (dwErrorTime > 0) {
               wsprintf (szBuffer, TEXT("%d"), dwErrorTime);
               SetDlgItemText (hDlg, IDC_TIMEOUT, szBuffer);
               SetTimer (hDlg, 1, 1000, NULL);
           }
           return TRUE;
           }

        case WM_TIMER:

           if (dwErrorTime >= 1) {

               dwErrorTime--;
               wsprintf (szBuffer, TEXT("%d"), dwErrorTime);
               SetDlgItemText (hDlg, IDC_TIMEOUT, szBuffer);

           } else {

               //
               // Time's up.  Dismiss the dialog.
               //

               PostMessage (hDlg, WM_COMMAND, IDOK, 0);
           }
           break;

        case WM_COMMAND:

          switch (LOWORD(wParam)) {

              case IDOK:
                  if (HIWORD(wParam) == BN_KILLFOCUS) {
                      KillTimer (hDlg, 1);
                      ShowWindow(GetDlgItem(hDlg, IDC_TIMEOUT), SW_HIDE);
                      ShowWindow(GetDlgItem(hDlg, IDC_TIMETITLE), SW_HIDE);

                  } else if (HIWORD(wParam) == BN_CLICKED) {
                      KillTimer (hDlg, 1);
                      EndDialog(hDlg, TRUE);
                  }
                  break;

              case IDCANCEL:
                  KillTimer (hDlg, 1);
                  EndDialog(hDlg, FALSE);
                  break;

              default:
                  break;

          }
          break;

    }

    return FALSE;
}


//*************************************************************
//
//  GetShareName()
//
//  Purpose:    Returns the complete share name by unmapping the 
//              drive letter in lpDir
//
//  Parameters: lpDir    -  Dir name to be unmapped
//              lppShare -  Expanded dir name with share
//
//  Return:     TRUE  : if success
//              FALSE : otherwise
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/29/00    santanuc   Created
//
//*************************************************************
BOOL GetShareName(LPTSTR lpDir, LPTSTR *lppShare)
{
    PFNWNETGETCONNECTION  pfnWNetGetConnection;
    HMODULE               hWNetLib = NULL;
    TCHAR                 szDrive[3];
    DWORD                 dwSize = 0, dwErr;
    BOOL                  bRetVal = FALSE;

    if (lpDir[1] != TEXT(':')) {
        goto Exit;
    }

    if (!(hWNetLib = LoadLibrary(TEXT("mpr.dll")))) {
        DebugMsg((DM_WARNING, TEXT("GetShareName: LoadLibrary failed with %d"), GetLastError()));
        goto Exit;
    }
    pfnWNetGetConnection = (PFNWNETGETCONNECTION)GetProcAddress(hWNetLib, "WNetGetConnectionW");
    if (!pfnWNetGetConnection) {
        DebugMsg((DM_WARNING, TEXT("GetShareName: GetProcAddress failed with %d"), GetLastError()));
        goto Exit;
    }
        
    szDrive[0] = lpDir[0];
    szDrive[1] = TEXT(':');
    szDrive[2] = TEXT('\0');

    // First get the size required to hold the share name
    dwErr = (*pfnWNetGetConnection)(szDrive, NULL, &dwSize);

    if (dwErr == ERROR_MORE_DATA) {
        dwSize += lstrlen(lpDir);  // Add the size for rest of the path name
        *lppShare = (LPTSTR)LocalAlloc(LPTR, dwSize*sizeof(TCHAR));
        if (!*lppShare) {
            DebugMsg((DM_WARNING, TEXT("GetShareName: Failed to alloc memory with %d"), GetLastError()));
            goto Exit;
        }
        dwErr = (*pfnWNetGetConnection)(szDrive, *lppShare, &dwSize);
        if (dwErr == NO_ERROR) {
            lstrcat(*lppShare, lpDir+2); // Add the rest of the path name
            bRetVal = TRUE;
            goto Exit;
        }
        else {
            DebugMsg((DM_WARNING, TEXT("GetShareName: WNetGetConnection returned error %d"), dwErr));
        }

        LocalFree(*lppShare);
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("GetShareName: WNetGetConnection initially returned error %d"), dwErr));
    }

Exit:

    if (hWNetLib) {
        FreeLibrary(hWNetLib);
    }

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\utils\debug.h ===
//*************************************************************
//
//  Debugging functions header file
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************



//
// Debug Levels
//

#define DL_NONE     0x00000000
#define DL_NORMAL   0x00000001
#define DL_VERBOSE  0x00000002
#define DL_LOGFILE  0x00010000
#define DL_DEBUGGER 0x00020000

extern DWORD dwDebugLevel;
extern DWORD dwRsopLoggingLevel;  // Rsop logging setting


//
// Debug message types
//

#define DM_WARNING  0
#define DM_ASSERT   1
#define DM_VERBOSE  2


//
// Debug macros
// To avoid certain unexpected problems DebugMsg is changed to this form.
// This will prevent compilation of the construct like "if (!test) DebugMsg(x); else ..."
// unless DebugMsg(x) is enclosed under curly braces.
//

#define DebugMsg(x) { if (dwDebugLevel != DL_NONE) { _DebugMsg x ; } }


//
// Debug function proto-types
//


void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...);


#define SETUP_LOAD    1
#define WINLOGON_LOAD 2
void InitDebugSupport( DWORD dwLoadFlags );


#if DBG

#define DmAssert(x) if (!(x)) \
                        _DebugMsg(DM_ASSERT,TEXT("Userenv.dll assertion ") TEXT(#x) TEXT(" failed\n"));

#else

#define DmAssert(x)

#endif // DBG

#if defined(__cplusplus)
extern "C"
#endif
BOOL RsopLoggingEnabled();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\utils\locator.h ===
//***********************************************

//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//  WMI interface class
//
//  History:    10-Mar-00   SitaramR    Created
//
//*************************************************************

#include "windows.h"
#include "ole2.h"
#include "rsopdbg.h"
#include <initguid.h>
#include <wbemcli.h>

class CLocator
{

public:

    CLocator()    {}

    IWbemLocator  * GetWbemLocator();
    IWbemServices * GetPolicyConnection();
    IWbemServices * GetUserConnection();
    IWbemServices * GetMachConnection();

private:

    XInterface<IWbemLocator>   m_xpWbemLocator;
    XInterface<IWbemServices>  m_xpPolicyConnection;
    XInterface<IWbemServices>  m_xpUserConnection;
    XInterface<IWbemServices>  m_xpMachConnection;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\utils\locator.cpp ===
//*************************************************************
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//  WMI interfae class
//
//  History:    10-Mar-00   SitaramR    Created
//
//*************************************************************

#include "uenv.h"
#include "locator.h"


extern CDebug CDbgCommon;

//*************************************************************
//
//  CLocator::GetWbemLocator
//
//  Purpose:    Returns the WbemLocator pointer
//
//*************************************************************

IWbemLocator *CLocator::GetWbemLocator()
{
    XLastError  xe;

    if ( m_xpWbemLocator == NULL ) {

        OLE32_API *pOle32Api = LoadOle32Api();
        if ( pOle32Api == NULL ) {
            dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                           TEXT("CLocator::GetWbemLocator: Load of ole32.dll failed") );
            xe = GetLastError();
            return NULL;
        }

        HRESULT hr = pOle32Api->pfnCoCreateInstance(CLSID_WbemLocator,
                                                    0,
                                                    CLSCTX_INPROC_SERVER,
                                                    IID_IWbemLocator,
                                                    (LPVOID *) &m_xpWbemLocator);
        if(FAILED(hr)) {
            dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                         TEXT("CLocator::GetWbemLocator: CoCreateInstance failed with 0x%x"), hr );
            xe = hr;
            return NULL;
        }
    }

    return m_xpWbemLocator;
}


//*************************************************************
//
//  CLocator::GetPolicyConnection
//
//  Purpose:    Returns the WbemServices ptr to root\policy
//
//*************************************************************

IWbemServices *CLocator::GetPolicyConnection()
{
    XLastError  xe;

    if ( m_xpPolicyConnection == NULL ) {

        IWbemLocator *pWbemLocator = GetWbemLocator();
        if ( pWbemLocator == NULL ) {
            xe = GetLastError();
            return NULL;
        }
										
        XBStr xbstrNamespace = L"\\\\.\\Root\\policy";

        if(!xbstrNamespace) {
            dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                         TEXT("CLocator::GetPolicyConnection: Failed to allocate memory") );
            xe = GetLastError();
            return NULL;
        }

        HRESULT hr = pWbemLocator->ConnectServer(xbstrNamespace,
                                                 NULL,
                                                 NULL,
                                                 0L,
                                                 0L,
                                                 NULL,
                                                 NULL,
                                                 &m_xpPolicyConnection);
        if(FAILED(hr)) {
             dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                         TEXT("CLocator::GetPolicyConnection: ConnectServer failed with 0x%x"), hr );
            xe = hr;
            return NULL;
        }


        hr = CoSetProxyBlanket((IUnknown *)m_xpPolicyConnection, RPC_C_AUTHN_DEFAULT,
                               RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, RPC_C_AUTHN_LEVEL_DEFAULT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, NULL, 
                               EOAC_DYNAMIC_CLOAKING /* | EOAC_NO_CUSTOM_MARSHAL */);

        if (FAILED(hr)) {
            dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                        TEXT("CLocator::GetPolicyConnection: CoSetProxyBlanket failed with 0x%x"), hr );
           xe = hr;
           m_xpPolicyConnection = NULL;
           return NULL;
        }
    }

    return m_xpPolicyConnection;
}



//*************************************************************
//
//  CLocator::GetUserConnection
//
//  Purpose:    Returns the WbemServices ptr to root\User
//
//*************************************************************

IWbemServices *CLocator::GetUserConnection()
{
    if ( m_xpUserConnection == NULL ) {

        IWbemLocator *pWbemLocator = GetWbemLocator();
        if ( pWbemLocator == NULL )
            return NULL;

        XBStr xbstrNamespace = L"root\\User";

        if(!xbstrNamespace) {
            dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                         TEXT("CLocator::GetUserConnection: Failed to allocate memory") );
            return NULL;
        }

        HRESULT hr = pWbemLocator->ConnectServer(xbstrNamespace,
                                                 NULL,
                                                 NULL,
                                                 0L,
                                                 0L,
                                                 NULL,
                                                 NULL,
                                                 &m_xpUserConnection);
        if(FAILED(hr)) {
             dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                         TEXT("CLocator::GetUserConnection: ConnectServer failed with 0x%x"), hr );
            return NULL;
        }
    }

    return m_xpUserConnection;
}



//*************************************************************
//
//  CLocator::GetMachConnection
//
//  Purpose:    Returns the WbemServices ptr to root\Mach
//
//*************************************************************

IWbemServices *CLocator::GetMachConnection()
{
    if ( m_xpMachConnection == NULL ) {

        IWbemLocator *pWbemLocator = GetWbemLocator();
        if ( pWbemLocator == NULL )
            return NULL;

        XBStr xbstrNamespace = L"root\\Computer";

        if(!xbstrNamespace) {
            dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                         TEXT("CLocator::GetMachConnection: Failed to allocate memory") );
            return NULL;
        }

        HRESULT hr = pWbemLocator->ConnectServer(xbstrNamespace,
                                                 NULL,
                                                 NULL,
                                                 0L,
                                                 0L,
                                                 NULL,
                                                 NULL,
                                                 &m_xpMachConnection);
        if(FAILED(hr)) {
             dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                         TEXT("CLocator::GetMachConnection: ConnectServer failed with 0x%x"), hr );
            return NULL;
        }
    }

    return m_xpMachConnection;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\utils\sid.h ===
//*************************************************************
//
//  Header file for Sid.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#ifdef __cplusplus
extern "C" {
#endif

LPTSTR GetSidString(HANDLE UserToken);
VOID DeleteSidString(LPTSTR SidString);
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid);

#ifdef __cplusplus
}
#endif

PSID GetUserSid (HANDLE UserToken);
VOID DeleteUserSid(PSID Sid);
NTSTATUS LoadSidAuthFromString (const WCHAR* pString, PSID_IDENTIFIER_AUTHORITY pSidAuth);
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue);
NTSTATUS GetDomainSidFromDomainRid(PSID pSid, DWORD dwRid, PSID *ppNewSid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\utils\dllload.cpp ===
//*************************************************************
//
//  DLL loading functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"

//
// file global variables containing pointers to APIs and
// loaded modules
//

NETAPI32_API    g_NetApi32Api;
SECUR32_API     g_Secur32Api;
LDAP_API        g_LdapApi;
ICMP_API        g_IcmpApi;
WSOCK32_API     g_WSock32Api;
DS_API          g_DsApi;
SHELL32_API     g_Shell32Api;
SHLWAPI_API     g_ShlwapiApi;
OLE32_API       g_Ole32Api;
GPTEXT_API      g_GpTextApi;
IPHLPAPI_API    g_IpHlpApi;
WS2_32_API      g_ws2_32Api;

CRITICAL_SECTION *g_ApiDLLCritSec;

//*************************************************************
//
//  InitializeAPIs()
//
//  Purpose:    initializes API structures for delay loaded
//              modules
//
//  Parameters: none
//
//
//  Return:     none
//
//*************************************************************

void InitializeAPIs( void )
{
    ZeroMemory( &g_NetApi32Api, sizeof( NETAPI32_API ) );
    ZeroMemory( &g_Secur32Api,  sizeof( SECUR32_API ) );
    ZeroMemory( &g_LdapApi,     sizeof( LDAP_API ) );
    ZeroMemory( &g_IcmpApi,     sizeof( ICMP_API ) );
    ZeroMemory( &g_WSock32Api,  sizeof( WSOCK32_API ) );
    ZeroMemory( &g_DsApi,       sizeof( DS_API ) );
    ZeroMemory( &g_Shell32Api,  sizeof( SHELL32_API ) );
    ZeroMemory( &g_ShlwapiApi,  sizeof( SHLWAPI_API ) );
    ZeroMemory( &g_Ole32Api,    sizeof( OLE32_API ) );
    ZeroMemory( &g_GpTextApi,   sizeof( GPTEXT_API ) );
}

//*************************************************************
//
//  InitializeApiDLLsCritSec()
//
//  Purpose:    initializes a CRITICAL_SECTION for synch'ing
//              DLL loads
//
//  Parameters: none
//
//
//  Return:     ERROR_SUCCESS if successful
//              An error if it fails.
//
//*************************************************************

DWORD InitializeApiDLLsCritSec( void )
{
    CRITICAL_SECTION *pCritSec     = NULL;
    DWORD             result       = ERROR_SUCCESS;
    BOOL              fInitialized = FALSE;
    CRITICAL_SECTION *pInitial;

    // If the critical section already exists, return.
    if (g_ApiDLLCritSec != NULL)
        return ERROR_SUCCESS;

    // Allocate memory for the critial section.
    pCritSec = (CRITICAL_SECTION *) LocalAlloc( LMEM_FIXED,
                                                sizeof(CRITICAL_SECTION) );
    if (pCritSec == NULL)
    {
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    // Initialize the critical section.  Using the flag 0x80000000
    // preallocates the event so that EnterCriticalSection can only
    // throw timeout exceptions.
    __try
    {
        if (!InitializeCriticalSectionAndSpinCount( pCritSec, 0x80000000 ))
            result = GetLastError();
        else
            fInitialized = TRUE;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        result = ERROR_NOT_ENOUGH_MEMORY;
    }
    if (result != ERROR_SUCCESS)
        goto Exit;

    // Save the critical section.
    pInitial = (CRITICAL_SECTION *) InterlockedCompareExchangePointer(
        (void **) &g_ApiDLLCritSec, (void *) pCritSec, NULL );

    // If the InterlockedCompareExchange succeeded, don't free the
    // critical section just allocated.
    if (pInitial == NULL)
        pCritSec = NULL;

Exit:
    if (pCritSec != NULL)
    {
        if (fInitialized)
            DeleteCriticalSection( pCritSec );
        LocalFree( pCritSec );
    }
    return result;
}

//*************************************************************
//
//  CloseApiDLLsCritSec()
//
//  Purpose:    clean up CRITICAL_SECTION for synch'ing
//              DLL loads
//
//  Parameters: none
//
//
//  Return:     none
//
//*************************************************************

void CloseApiDLLsCritSec( void )
{
    if (g_ApiDLLCritSec != NULL)
    {
        DeleteCriticalSection( g_ApiDLLCritSec );
        LocalFree( g_ApiDLLCritSec );
        g_ApiDLLCritSec = NULL;
    }
}

//*************************************************************
//
//  LoadNetAPI32()
//
//  Purpose:    Loads netapi32.dll
//
//  Parameters: pNETAPI32 - pointer to a NETAPI32_API structure to
//                         initialize
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

PNETAPI32_API LoadNetAPI32 ()
{
    BOOL bResult = FALSE;
    PNETAPI32_API pNetAPI32 = &g_NetApi32Api;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pNetAPI32->hInstance ) {
        //
        // module is already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );

        return pNetAPI32;
    }

    pNetAPI32->hInstance = LoadLibrary (TEXT("netapi32.dll"));

    if (!pNetAPI32->hInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadNetAPI32:  Failed to load netapi32 with %d."),
                 GetLastError()));
        goto Exit;
    }


    pNetAPI32->pfnDsGetDcName = (PFNDSGETDCNAME) GetProcAddress (pNetAPI32->hInstance,
#ifdef UNICODE
                                                                 "DsGetDcNameW");
#else
                                                                 "DsGetDcNameA");
#endif

    if (!pNetAPI32->pfnDsGetDcName) {
        DebugMsg((DM_WARNING, TEXT("LoadNetAPI32:  Failed to find DsGetDcName with %d."),
                 GetLastError()));
        goto Exit;
    }


    pNetAPI32->pfnDsGetSiteName = (PFNDSGETSITENAME) GetProcAddress (pNetAPI32->hInstance,
#ifdef UNICODE
                                                                     "DsGetSiteNameW");
#else
                                                                     "DsGetSiteNameA");
#endif

    if (!pNetAPI32->pfnDsGetSiteName) {
        DebugMsg((DM_WARNING, TEXT("LoadNetAPI32:  Failed to find DsGetSiteName with %d."),
                 GetLastError()));
        goto Exit;
    }


    pNetAPI32->pfnDsRoleGetPrimaryDomainInformation = (PFNDSROLEGETPRIMARYDOMAININFORMATION)GetProcAddress (pNetAPI32->hInstance,
                                                       "DsRoleGetPrimaryDomainInformation");

    if (!pNetAPI32->pfnDsRoleGetPrimaryDomainInformation) {
        DebugMsg((DM_WARNING, TEXT("LoadNetAPI32:  Failed to find pfnDsRoleGetPrimaryDomainInformation with %d."),
                 GetLastError()));
        goto Exit;
    }


    pNetAPI32->pfnDsRoleFreeMemory = (PFNDSROLEFREEMEMORY)GetProcAddress (pNetAPI32->hInstance,
                                                                          "DsRoleFreeMemory");

    if (!pNetAPI32->pfnDsRoleFreeMemory) {
        DebugMsg((DM_WARNING, TEXT("LoadNetAPI32:  Failed to find pfnDsRoleFreeMemory with %d."),
                 GetLastError()));
        goto Exit;
    }


    pNetAPI32->pfnNetApiBufferFree = (PFNNETAPIBUFFERFREE) GetProcAddress (pNetAPI32->hInstance,
                                                                           "NetApiBufferFree");

    if (!pNetAPI32->pfnNetApiBufferFree) {
        DebugMsg((DM_WARNING, TEXT("LoadNetAPI32:  Failed to find NetApiBufferFree with %d."),
                 GetLastError()));
        goto Exit;
    }


    pNetAPI32->pfnNetUserGetGroups = (PFNNETUSERGETGROUPS) GetProcAddress (pNetAPI32->hInstance,
                                                                           "NetUserGetGroups");

    if (!pNetAPI32->pfnNetUserGetGroups) {
        DebugMsg((DM_WARNING, TEXT("LoadNetAPI32:  Failed to find NetUserGetGroups with %d."),
                 GetLastError()));
        goto Exit;
    }


    pNetAPI32->pfnNetUserGetInfo = (PFNNETUSERGETINFO) GetProcAddress (pNetAPI32->hInstance,
                                                                      "NetUserGetInfo");

    if (!pNetAPI32->pfnNetUserGetInfo) {
        DebugMsg((DM_WARNING, TEXT("LoadNetAPI32:  Failed to find NetUserGetInfo with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("netapi32.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pNetAPI32->hInstance ) {
            FreeLibrary( pNetAPI32->hInstance );
        }
        ZeroMemory( pNetAPI32, sizeof( NETAPI32_API ) );
        pNetAPI32 = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pNetAPI32;
}


//*************************************************************
//
//  LoadSecur32()
//
//  Purpose:    Loads secur32.dll
//
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

PSECUR32_API LoadSecur32 ()
{
    BOOL bResult = FALSE;
    PSECUR32_API pSecur32 = &g_Secur32Api;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pSecur32->hInstance ) {
        //
        // module is already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );

        return pSecur32;
    }

    //
    // Load secur32.dll
    //

    pSecur32->hInstance = LoadLibrary (TEXT("secur32.dll"));

    if (!pSecur32->hInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to load secur32 with %d."),
                 GetLastError()));
        goto Exit;
    }

    pSecur32->pfnGetUserNameEx = (PFNGETUSERNAMEEX)GetProcAddress (pSecur32->hInstance,
#ifdef UNICODE
                                        "GetUserNameExW");
#else
                                        "GetUserNameExA");
#endif


    if (!pSecur32->pfnGetUserNameEx) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find GetUserNameEx with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnGetComputerObjectName = (PFNGETCOMPUTEROBJECTNAME)GetProcAddress (pSecur32->hInstance,
#ifdef UNICODE
                                        "GetComputerObjectNameW");
#else
                                        "GetComputerObjectNameA");
#endif


    if (!pSecur32->pfnGetComputerObjectName) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find GetComputerObjectName with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnTranslateName = (PFNTRANSLATENAME)GetProcAddress (pSecur32->hInstance,
#ifdef UNICODE
                                        "TranslateNameW");
#else
                                        "TranslateNameA");
#endif


    if (!pSecur32->pfnTranslateName) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find TranslateName with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnAcceptSecurityContext = (ACCEPT_SECURITY_CONTEXT_FN)GetProcAddress (pSecur32->hInstance,
                                        "AcceptSecurityContext");

    if (!pSecur32->pfnAcceptSecurityContext) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find AcceptSecurityContext with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnAcquireCredentialsHandle = (ACQUIRE_CREDENTIALS_HANDLE_FN)GetProcAddress (pSecur32->hInstance,
#ifdef UNICODE
                                        "AcquireCredentialsHandleW");
#else
                                        "AcquireCredentialsHandleA");
#endif


    if (!pSecur32->pfnAcquireCredentialsHandle) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find AcquireCredentialsHandle with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnDeleteSecurityContext = (DELETE_SECURITY_CONTEXT_FN)GetProcAddress (pSecur32->hInstance,
                                        "DeleteSecurityContext");

    if (!pSecur32->pfnDeleteSecurityContext) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find DeleteSecurityContext with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnFreeContextBuffer = (FREE_CONTEXT_BUFFER_FN)GetProcAddress (pSecur32->hInstance,
                                        "FreeContextBuffer");

    if (!pSecur32->pfnFreeContextBuffer) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find FreeContextBuffer with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnFreeCredentialsHandle = (FREE_CREDENTIALS_HANDLE_FN)GetProcAddress (pSecur32->hInstance,
                                        "FreeCredentialsHandle");

    if (!pSecur32->pfnFreeCredentialsHandle) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find FreeCredentialsHandle with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnInitializeSecurityContext = (INITIALIZE_SECURITY_CONTEXT_FN)GetProcAddress (pSecur32->hInstance,
#ifdef UNICODE
                                        "InitializeSecurityContextW");
#else
                                        "InitializeSecurityContextA");
#endif


    if (!pSecur32->pfnInitializeSecurityContext) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find InitializeSecurityContext with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnQuerySecurityContextToken = (QUERY_SECURITY_CONTEXT_TOKEN_FN)GetProcAddress (pSecur32->hInstance,
                                        "QuerySecurityContextToken");

    if (!pSecur32->pfnQuerySecurityContextToken) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find QuerySecurityContextToken with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnQuerySecurityPackageInfo = (QUERY_SECURITY_PACKAGE_INFO_FN)GetProcAddress (pSecur32->hInstance,
#ifdef UNICODE
                                        "QuerySecurityPackageInfoW");
#else
                                        "QuerySecurityPackageInfoA");
#endif


    if (!pSecur32->pfnQuerySecurityPackageInfo) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find QuerySecurityPackageInfo with %d."),
                 GetLastError()));
        goto Exit;
    }



    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("secur32.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pSecur32->hInstance ) {
            FreeLibrary( pSecur32->hInstance );
        }
        ZeroMemory( pSecur32, sizeof( SECUR32_API ) );
        pSecur32 = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pSecur32;
}


//*************************************************************
//
//  LoadLDAP()
//
//  Purpose:    Loads wldap32.dll
//
//  Parameters: pLDAP - pointer to a  LDAP_API structure to
//                      initialize
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

PLDAP_API LoadLDAP ()
{
    BOOL bResult = FALSE;
    PLDAP_API pLDAP = &g_LdapApi;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pLDAP->hInstance ) {
        //
        // module is already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );

        return pLDAP;
    }

    //
    // Load wldap32.dll
    //

    pLDAP->hInstance = LoadLibrary (TEXT("wldap32.dll"));

    if (!pLDAP->hInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to load wldap32 with %d."),
                 GetLastError()));
        goto Exit;
    }

    pLDAP->pfnldap_open = (PFNLDAP_OPEN) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_openW");
#else
                                        "ldap_openA");
#endif

    if (!pLDAP->pfnldap_open) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_open with %d."),
                 GetLastError()));
        goto Exit;
    }

    pLDAP->pfnldap_init = (PFNLDAP_INIT) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_initW");
#else
                                        "ldap_initA");
#endif

    if (!pLDAP->pfnldap_init) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_init with %d."),
                 GetLastError()));
        goto Exit;
    }

    pLDAP->pfnldap_connect = (PFNLDAP_CONNECT) GetProcAddress (pLDAP->hInstance,
                                        "ldap_connect");

    if (!pLDAP->pfnldap_connect) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_connect with %d."),
                 GetLastError()));
        goto Exit;
    }

    pLDAP->pfnldap_bind_s = (PFNLDAP_BIND_S) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_bind_sW");
#else
                                        "ldap_bind_sA");
#endif

    if (!pLDAP->pfnldap_bind_s) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_bind_s with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_search_s = (PFNLDAP_SEARCH_S) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_search_sW");
#else
                                        "ldap_search_sA");
#endif

    if (!pLDAP->pfnldap_search_s) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_search_s with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_search_ext_s = (PFNLDAP_SEARCH_EXT_S) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_search_ext_sW");
#else
                                        "ldap_search_ext_sA");
#endif

    if (!pLDAP->pfnldap_search_ext_s) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_search_ext_s with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_get_values = (PFNLDAP_GET_VALUES) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_get_valuesW");
#else
                                        "ldap_get_valuesA");
#endif

    if (!pLDAP->pfnldap_get_values) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_get_values with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_value_free = (PFNLDAP_VALUE_FREE) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_value_freeW");
#else
                                        "ldap_value_freeA");
#endif

    if (!pLDAP->pfnldap_value_free) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_value_free with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_get_values_len = (PFNLDAP_GET_VALUES_LEN) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_get_values_lenW");
#else
                                        "ldap_get_values_lenA");
#endif

    if (!pLDAP->pfnldap_get_values_len) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_get_values_len with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_value_free_len = (PFNLDAP_VALUE_FREE_LEN) GetProcAddress (pLDAP->hInstance,
                                        "ldap_value_free_len");

    if (!pLDAP->pfnldap_value_free_len) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_value_free_len with %d."),
                 GetLastError()));
        goto Exit;
    }

    pLDAP->pfnldap_msgfree = (PFNLDAP_MSGFREE) GetProcAddress (pLDAP->hInstance,
                                        "ldap_msgfree");

    if (!pLDAP->pfnldap_msgfree) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_msgfree with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_unbind = (PFNLDAP_UNBIND) GetProcAddress (pLDAP->hInstance,
                                        "ldap_unbind");

    if (!pLDAP->pfnldap_unbind) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_unbind with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnLdapGetLastError = (PFNLDAPGETLASTERROR) GetProcAddress (pLDAP->hInstance,
                                        "LdapGetLastError");

    if (!pLDAP->pfnLdapGetLastError) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find pfnLdapGetLastError with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_first_entry = (PFNLDAP_FIRST_ENTRY) GetProcAddress (pLDAP->hInstance,
                                        "ldap_first_entry");

    if (!pLDAP->pfnldap_first_entry) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_first_entry with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_next_entry = (PFNLDAP_NEXT_ENTRY) GetProcAddress (pLDAP->hInstance,
                                        "ldap_next_entry");

    if (!pLDAP->pfnldap_next_entry) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_next_entry with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_get_dn = (PFNLDAP_GET_DN) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_get_dnW");
#else
                                        "ldap_get_dnA");
#endif

    if (!pLDAP->pfnldap_get_dn) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_get_dn with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_set_option = (PFNLDAP_SET_OPTION) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_set_optionW");
#else
                                        "ldap_set_option");
#endif

    if (!pLDAP->pfnldap_set_option) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_set_option with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_memfree = (PFNLDAP_MEMFREE) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_memfreeW");
#else
                                        "ldap_memfreeA");
#endif

    if (!pLDAP->pfnldap_memfree) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_memfree with %d."),
                 GetLastError()));
        goto Exit;
    }

    
    pLDAP->pfnLdapMapErrorToWin32 = (PFNLDAPMAPERRORTOWIN32) GetProcAddress (pLDAP->hInstance,
                                        "LdapMapErrorToWin32");

    if (!pLDAP->pfnLdapMapErrorToWin32) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find LdapMapErrorToWin32 with %d."),
                 GetLastError()));
        goto Exit;
    }

    pLDAP->pfnldap_err2string = (PFNLDAP_ERR2STRING) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_err2stringW");
#else
                                        "ldap_err2stringA");
#endif

    if (!pLDAP->pfnldap_err2string) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_err2string with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("wldap32.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pLDAP->hInstance ) {
            FreeLibrary( pLDAP->hInstance );
        }
        ZeroMemory( pLDAP, sizeof( LDAP_API ) );

        pLDAP = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pLDAP;
}


//*************************************************************
//
//  LoadIcmp()
//
//  Purpose:    Loads cmp.dll
//
//  Parameters: pIcmp - pointer to a ICMP_API structure to
//                         initialize
//
//
//  Return:     ERROR_SUCCESS if successful
//              result if an error occurs
//
//*************************************************************

DWORD LoadIcmp ( PICMP_API *pIcmpOut )
{
    DWORD     dwResult = ERROR_SUCCESS;
    PICMP_API pIcmp    = &g_IcmpApi;

    *pIcmpOut = NULL;
    dwResult = InitializeApiDLLsCritSec();
    if (dwResult != ERROR_SUCCESS)
        return dwResult;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pIcmp->hInstance ) {
        //
        // module already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );

        *pIcmpOut = pIcmp;
        return ERROR_SUCCESS;
    }

    pIcmp->hInstance = LoadLibrary (TEXT("icmp.dll"));

    if (!pIcmp->hInstance) {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadIcmp:  Failed to load icmp with %d."),
                 GetLastError()));
        goto Exit;
    }


    pIcmp->pfnIcmpCreateFile = (PFNICMPCREATEFILE) GetProcAddress (pIcmp->hInstance,
                                                                   "IcmpCreateFile");

    if (!pIcmp->pfnIcmpCreateFile) {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadIcmp:  Failed to find IcmpCreateFile with %d."),
                 GetLastError()));
        goto Exit;
    }


    pIcmp->pfnIcmpCloseHandle = (PFNICMPCLOSEHANDLE) GetProcAddress (pIcmp->hInstance,
                                                                   "IcmpCloseHandle");

    if (!pIcmp->pfnIcmpCloseHandle) {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadIcmp:  Failed to find IcmpCloseHandle with %d."),
                 GetLastError()));
        goto Exit;
    }


    pIcmp->pfnIcmpSendEcho = (PFNICMPSENDECHO) GetProcAddress (pIcmp->hInstance,
                                                                   "IcmpSendEcho");

    if (!pIcmp->pfnIcmpSendEcho) {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadIcmp:  Failed to find IcmpSendEcho with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

Exit:

    if (dwResult != ERROR_SUCCESS) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("icmp.dll")); ev.AddArgWin32Error(dwResult); ev.Report();

        if ( pIcmp->hInstance ) {
            FreeLibrary( pIcmp->hInstance );
        }
        ZeroMemory( pIcmp, sizeof( ICMP_API ) );

        pIcmp = 0;
    }
    else
        *pIcmpOut = pIcmp;

    LeaveCriticalSection( g_ApiDLLCritSec );

    return dwResult;
}


//*************************************************************
//
//  LoadWSock()
//
//  Purpose:    Loads cmp.dll
//
//  Parameters: pWSock32 - pointer to a WSOCK32_API structure to
//                         initialize
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

PWSOCK32_API LoadWSock32 ()
{
    BOOL bResult = FALSE;
    PWSOCK32_API pWSock32 = &g_WSock32Api;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pWSock32->hInstance ) {
        //
        // module already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );

        return pWSock32;
    }

    pWSock32->hInstance = LoadLibrary (TEXT("wsock32.dll"));

    if (!pWSock32->hInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadWSock32:  Failed to load wsock32 with %d."),
                 GetLastError()));
        goto Exit;
    }


    pWSock32->pfninet_addr = (LPFN_INET_ADDR) GetProcAddress (pWSock32->hInstance,
                                                                   "inet_addr");

    if (!pWSock32->pfninet_addr) {
        DebugMsg((DM_WARNING, TEXT("LoadWSock32:  Failed to find inet_addr with %d."),
                 GetLastError()));
        goto Exit;
    }


    pWSock32->pfngethostbyname = (LPFN_GETHOSTBYNAME) GetProcAddress (pWSock32->hInstance,
                                                                   "gethostbyname");

    if (!pWSock32->pfngethostbyname) {
        DebugMsg((DM_WARNING, TEXT("LoadWSock32:  Failed to find gethostbyname with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("wsock32.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pWSock32->hInstance ) {
            FreeLibrary( pWSock32->hInstance );
        }
        ZeroMemory( pWSock32, sizeof( WSOCK32_API ) );

        pWSock32 = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pWSock32;
}

//*************************************************************
//
//  LoadDSAPI()
//
//  Purpose:    Loads ntdsapi.dll
//
//  Parameters: pDSApi - pointer to a DS_API structure to initialize
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

PDS_API LoadDSApi()
{
    BOOL bResult = FALSE;
    PDS_API pDSApi = &g_DsApi;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pDSApi->hInstance ) {
        //
        // module already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );

        return pDSApi;
    }

    pDSApi->hInstance = LoadLibrary (TEXT("ntdsapi.dll"));

    if (!pDSApi->hInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadDSApi:  Failed to load ntdsapi with %d."),
                 GetLastError()));
        goto Exit;
    }


    pDSApi->pfnDsCrackNames = (PFN_DSCRACKNAMES) GetProcAddress (pDSApi->hInstance,
#ifdef UNICODE
                                                                 "DsCrackNamesW");
#else
                                                                 "DsCrackNamesA");
#endif

    if (!pDSApi->pfnDsCrackNames) {
        DebugMsg((DM_WARNING, TEXT("LoadDSApi:  Failed to find DsCrackNames with %d."),
                 GetLastError()));
        goto Exit;
    }


    pDSApi->pfnDsFreeNameResult = (PFN_DSFREENAMERESULT) GetProcAddress (pDSApi->hInstance,
#ifdef UNICODE
                                                                 "DsFreeNameResultW");
#else
                                                                 "DsFreeNameResultA");
#endif

    if (!pDSApi->pfnDsFreeNameResult) {
        DebugMsg((DM_WARNING, TEXT("LoadDSApi:  Failed to find DsFreeNameResult with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("ntdsapi.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pDSApi->hInstance ) {
            FreeLibrary( pDSApi->hInstance );
        }
        ZeroMemory( pDSApi, sizeof( DS_API ) );

        pDSApi = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pDSApi;
}

//*************************************************************
//
//  LoadShell32Api()
//
//  Purpose:    Loads shell32.dll
//
//  Parameters: pointer to hold SHELL32_API
//
//  Return:     ERROR_SUCCESS if successful
//              error code if not successful
//
//*************************************************************

DWORD LoadShell32Api( PSHELL32_API *ppShell32Api )
{
    DWORD        dwErr;
    PSHELL32_API pShell32Api = &g_Shell32Api;

    dwErr = InitializeApiDLLsCritSec();
    if (dwErr != ERROR_SUCCESS)
        return dwErr;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pShell32Api->hInstance ) {
        //
        // module already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );
        *ppShell32Api = pShell32Api;

        return ERROR_SUCCESS;
    }

    pShell32Api->hInstance = LoadLibrary (TEXT("shell32.dll"));

    if (!pShell32Api->hInstance) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to load ntdsapi with %d."),
                 GetLastError()));
        goto Exit;
    }


    pShell32Api->pfnShChangeNotify = (PFNSHCHANGENOTIFY) GetProcAddress (pShell32Api->hInstance, "SHChangeNotify");

    if (!pShell32Api->pfnShChangeNotify) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to find SHChangeNotify with %d."),
                 GetLastError()));
        goto Exit;
    }

    pShell32Api->pfnShGetSpecialFolderPath = (PFNSHGETSPECIALFOLDERPATH) GetProcAddress (pShell32Api->hInstance,
#ifdef UNICODE
                                                                 "SHGetSpecialFolderPathW");
#else
                                                                 "SHGetSpecialFolderPathA");
#endif

    if (!pShell32Api->pfnShGetSpecialFolderPath) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to find SHGetSpecialFolderPath with %d."),
                 GetLastError()));
        goto Exit;
    }

    pShell32Api->pfnShGetFolderPath = (PFNSHGETFOLDERPATH) GetProcAddress (pShell32Api->hInstance,
#ifdef UNICODE
                                                                 "SHGetFolderPathW");
#else
                                                                 "SHGetFolderPathA");
#endif


    if (!pShell32Api->pfnShGetFolderPath) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to find SHGetFolderPath with %d."),
                 GetLastError()));
        goto Exit;
    }


    pShell32Api->pfnShSetFolderPath = (PFNSHSETFOLDERPATH) GetProcAddress (pShell32Api->hInstance,
#ifdef UNICODE
                                                                 (LPCSTR)SHSetFolderW_Ord);
#else
                                                                 (LPCSTR)SHSetFolderA_Ord);
#endif

    if (!pShell32Api->pfnShSetFolderPath) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to find SHSetFolderPath with %d."),
                 GetLastError()));
        goto Exit;
    }


    pShell32Api->pfnShSetLocalizedName = (PFNSHSETLOCALIZEDNAME)
      GetProcAddress (pShell32Api->hInstance, "SHSetLocalizedName");

    if (!pShell32Api->pfnShSetLocalizedName) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to find SHSetLocalizedName with %d."),
                 GetLastError()));
        goto Exit;
    }


    //
    // Success
    //

    dwErr = ERROR_SUCCESS;

Exit:

    if (dwErr != ERROR_SUCCESS) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("shell32.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pShell32Api->hInstance ) {
            FreeLibrary( pShell32Api->hInstance );
        }
        ZeroMemory( pShell32Api, sizeof( SHELL32_API ) );

        pShell32Api = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );
    *ppShell32Api = pShell32Api;

    return dwErr;
}


//*************************************************************
//
//  LoadShwapiAPI()
//
//  Purpose:    Loads shlwapi.dll
//
//  Parameters: none
//
//  Return:     pointer to SHLWAPI_API
//
//*************************************************************

PSHLWAPI_API LoadShlwapiApi()
{
    BOOL bResult = FALSE;
    PSHLWAPI_API pShlwapiApi = &g_ShlwapiApi;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pShlwapiApi->hInstance ) {
        //
        // module already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );

        return pShlwapiApi;
    }

    pShlwapiApi->hInstance = LoadLibrary (TEXT("shlwapi.dll"));

    if (!pShlwapiApi->hInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to load ntdsapi with %d."),
                 GetLastError()));
        goto Exit;
    }


    pShlwapiApi->pfnPathGetArgs = (PFNPATHGETARGS) GetProcAddress (pShlwapiApi->hInstance,
#ifdef UNICODE
                                                                 "PathGetArgsW");
#else
                                                                 "PathGetArgsA");
#endif

    if (!pShlwapiApi->pfnPathGetArgs) {
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to find PathGetArgs with %d."),
                 GetLastError()));
        goto Exit;
    }

    pShlwapiApi->pfnPathUnquoteSpaces = (PFNPATHUNQUOTESPACES) GetProcAddress (pShlwapiApi->hInstance,
#ifdef UNICODE
                                                                 "PathUnquoteSpacesW");
#else
                                                                 "PathUnquoteSpacesA");
#endif

    if (!pShlwapiApi->pfnPathUnquoteSpaces) {
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to find PathUnquoteSpaces with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("shlwapi.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pShlwapiApi->hInstance ) {
            FreeLibrary( pShlwapiApi->hInstance );
        }
        ZeroMemory( pShlwapiApi, sizeof( SHLWAPI_API ) );

        pShlwapiApi = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pShlwapiApi;
}


//*************************************************************
//
//  LoadOle32Api()
//
//  Purpose:    Loads ole32.dll
//
//  Parameters: none
//
//  Return:     pointer to OLE32_API
//
//*************************************************************

POLE32_API LoadOle32Api()
{
    BOOL bResult = FALSE;
    OLE32_API *pOle32Api = &g_Ole32Api;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pOle32Api->hInstance ) {
        //
        // module already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );
        return pOle32Api;
    }

    pOle32Api->hInstance = LoadLibrary (TEXT("ole32.dll"));

    if (!pOle32Api->hInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadOle32Api:  Failed to load ole32.dll with %d."),
                 GetLastError()));
        goto Exit;
    }

    pOle32Api->pfnCoCreateInstance = (PFNCOCREATEINSTANCE) GetProcAddress (pOle32Api->hInstance,
                                                                           "CoCreateInstance");
    if (!pOle32Api->pfnCoCreateInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadOle32Api:  Failed to find CoCreateInstance with %d."),
                 GetLastError()));
        goto Exit;
    }

    pOle32Api->pfnCoInitializeEx = (PFNCOINITIALIZEEX) GetProcAddress (pOle32Api->hInstance,
                                                                       "CoInitializeEx");
    if (!pOle32Api->pfnCoInitializeEx) {
        DebugMsg((DM_WARNING, TEXT("LoadOle32Api:  Failed to find CoInitializeEx with %d."),
                 GetLastError()));
        goto Exit;
    }

    pOle32Api->pfnCoUnInitialize = (PFNCOUNINITIALIZE) GetProcAddress (pOle32Api->hInstance,
                                                                        "CoUninitialize");
    if (!pOle32Api->pfnCoUnInitialize) {
        DebugMsg((DM_WARNING, TEXT("LoadOle32Api:  Failed to find CoUnInitialize with %d."),
                 GetLastError()));
        goto Exit;
    }

    pOle32Api->pfnCoCreateGuid = (PFNCOCREATEGUID) GetProcAddress (pOle32Api->hInstance,
                                                                   "CoCreateGuid");
    if (!pOle32Api->pfnCoCreateGuid) {
        DebugMsg((DM_WARNING, TEXT("LoadOle32Api:  Failed to find CoCreateGuid with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("ole32.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pOle32Api->hInstance ) {
            FreeLibrary( pOle32Api->hInstance );
        }

        ZeroMemory( pOle32Api, sizeof( OLE32_API ) );
        pOle32Api = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pOle32Api;
}



//*************************************************************
//
//  LoadGpTextApi()
//
//  Purpose:    Loads gptext.dll
//
//  Parameters: none
//
//  Return:     pointer to GPTEXT_API
//
//*************************************************************

GPTEXT_API * LoadGpTextApi()
{
    BOOL bResult = FALSE;
    GPTEXT_API *pGpTextApi = &g_GpTextApi;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pGpTextApi->hInstance ) {
        //
        // module already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );
        return pGpTextApi;
    }

    pGpTextApi->hInstance = LoadLibrary (TEXT("gptext.dll"));

    if (!pGpTextApi->hInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadGpTextApi:  Failed to load gptext.dll with %d."),
                 GetLastError()));
        goto Exit;
    }

    pGpTextApi->pfnScrRegGPOListToWbem = (PFNSCRREGGPOLISTTOWBEM) GetProcAddress (pGpTextApi->hInstance,
                                                                  "ScrRegGPOListToWbem");
    if (!pGpTextApi->pfnScrRegGPOListToWbem) {
        DebugMsg((DM_WARNING, TEXT("LoadGpTextApi:  Failed to find ScrRegGPOListToWbem with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("gptext.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pGpTextApi->hInstance ) {
            FreeLibrary( pGpTextApi->hInstance );
        }

        ZeroMemory( pGpTextApi, sizeof( GPTEXT_API ) );
        pGpTextApi = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pGpTextApi;
}

PIPHLPAPI_API LoadIpHlpApi()
{
    bool bResult = false;
    PIPHLPAPI_API pIpHlpApi = &g_IpHlpApi;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pIpHlpApi->hInstance )
    {
        //
        // module is already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );

        return pIpHlpApi;
    }

    pIpHlpApi->hInstance = LoadLibrary( L"iphlpapi.dll" );

    if ( !pIpHlpApi->hInstance )
    {
        DebugMsg((DM_WARNING, L"LoadIpHlpApi:  Failed to load iphlpapi with %d.", GetLastError()));
        goto Exit;
    }

    pIpHlpApi->pfnGetBestInterface = (PFNGETBESTINTERFACE) GetProcAddress( pIpHlpApi->hInstance, "GetBestInterface" );

    if ( !pIpHlpApi->pfnGetBestInterface )
    {
        DebugMsg((DM_WARNING, L"LoadIpHlpApi:  Failed to find GetBestInterface with %d.", GetLastError()));
        goto Exit;
    }

    pIpHlpApi->pfnGetIfEntry = (PFNGETIFENTRY) GetProcAddress (pIpHlpApi->hInstance, "GetIfEntry" );

    if ( !pIpHlpApi->pfnGetIfEntry )
    {
        DebugMsg((DM_WARNING, L"LoadIpHlpApi:  Failed to find GetIfEntry with %d.", GetLastError()));
        goto Exit;
    }

    pIpHlpApi->pfnGetAdapterIndex = (PFNGETADAPTERINDEX) GetProcAddress (pIpHlpApi->hInstance, "GetAdapterIndex" );

    if ( !pIpHlpApi->pfnGetAdapterIndex )
    {
        DebugMsg((DM_WARNING, L"LoadIpHlpApi:  Failed to find GetAdapterIndex with %d.", GetLastError()));
        goto Exit;
    }

    bResult = true;
Exit:

    if ( !bResult )
    {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);

        ev.AddArg( L"iphlpapi.dll" );
        ev.AddArgWin32Error( GetLastError() );
        ev.Report();

        if ( pIpHlpApi->hInstance )
        {
            FreeLibrary( pIpHlpApi->hInstance );
        }
        ZeroMemory( pIpHlpApi, sizeof( IPHLPAPI_API ) );
        pIpHlpApi = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pIpHlpApi;
}

//*************************************************************
//
//  Loadws2_32Api()
//
//  Purpose:    Loads ws2_32.dll
//
//  Parameters: none
//
//  Return:     pointer to WS2_32_API
//
//*************************************************************

WS2_32_API * Loadws2_32Api()
{
    BOOL bResult = FALSE;
    WS2_32_API *pws2_32Api = &g_ws2_32Api;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pws2_32Api->hInstance ) {
        //
        // module already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );
        return pws2_32Api;
    }

    pws2_32Api->hInstance = LoadLibrary (TEXT("ws2_32.dll"));

    if (!pws2_32Api->hInstance) {
        DebugMsg((DM_WARNING, TEXT("Loadws2_32Api:  Failed to load ws2_32.dll with %d."),
                 GetLastError()));
        goto Exit;
    }

    pws2_32Api->pfnWSALookupServiceBegin = (PFNWSALOOKUPSERVICEBEGIN) GetProcAddress (pws2_32Api->hInstance,
                                                                  "WSALookupServiceBeginW");
    if (!pws2_32Api->pfnWSALookupServiceBegin) {
        DebugMsg((DM_WARNING, TEXT("Loadws2_32Api:  Failed to find WSALookupServiceBegin with %d."),
                 GetLastError()));
        goto Exit;
    }

    pws2_32Api->pfnWSALookupServiceNext = (PFNWSALOOKUPSERVICENEXT) GetProcAddress (pws2_32Api->hInstance,
                                                                  "WSALookupServiceNextW");
    if (!pws2_32Api->pfnWSALookupServiceNext) {
        DebugMsg((DM_WARNING, TEXT("Loadws2_32Api:  Failed to find WSALookupServiceNext with %d."),
                 GetLastError()));
        goto Exit;
    }

    pws2_32Api->pfnWSALookupServiceEnd = (PFNWSALOOKUPSERVICEEND) GetProcAddress (pws2_32Api->hInstance,
                                                                  "WSALookupServiceEnd");
    if (!pws2_32Api->pfnWSALookupServiceEnd) {
        DebugMsg((DM_WARNING, TEXT("Loadws2_32Api:  Failed to find WSALookupServiceEnd with %d."),
                 GetLastError()));
        goto Exit;
    }

    pws2_32Api->pfnWSAStartup = (PFNWSASTARTUP) GetProcAddress (pws2_32Api->hInstance,
                                                                  "WSAStartup");
    if (!pws2_32Api->pfnWSAStartup) {
        DebugMsg((DM_WARNING, TEXT("Loadws2_32Api:  Failed to find WSAStartup with %d."),
                 GetLastError()));
        goto Exit;
    }

    pws2_32Api->pfnWSACleanup = (PFNWSACLEANUP) GetProcAddress (pws2_32Api->hInstance,
                                                                  "WSACleanup");
    if (!pws2_32Api->pfnWSACleanup) {
        DebugMsg((DM_WARNING, TEXT("Loadws2_32Api:  Failed to find WSACleanup with %d."),
                 GetLastError()));
        goto Exit;
    }

    pws2_32Api->pfnWSAGetLastError = (PFNWSAGETLASTERROR) GetProcAddress (pws2_32Api->hInstance,
                                                                  "WSAGetLastError");
    if (!pws2_32Api->pfnWSAGetLastError) {
        DebugMsg((DM_WARNING, TEXT("Loadws2_32Api:  Failed to find WSAGetLastError with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("ws2_32.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pws2_32Api->hInstance ) {
            FreeLibrary( pws2_32Api->hInstance );
        }

        ZeroMemory( pws2_32Api, sizeof( WS2_32_API ) );
        pws2_32Api = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pws2_32Api;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\utils\events.h ===
//*************************************************************
//
//  Events.h    -   header file for events.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************


#ifdef __cplusplus
extern "C" {
#endif

// Events type
#define EVENT_ERROR_TYPE      0x00010000
#define EVENT_WARNING_TYPE    0x00020000
#define EVENT_INFO_TYPE       0x00040000


BOOL InitializeEvents (void);
int LogEvent (DWORD dwFlags, UINT idMsg, ...);
BOOL ShutdownEvents (void);
int ReportError (HANDLE hTokenUser, DWORD dwFlags, DWORD dwArgCount, UINT idMsg, ... );


#ifdef __cplusplus
}
#endif


#ifdef __cplusplus

#include "smartptr.h"

class CEvents
{
    private:
        DWORD           m_dwEventType;  // the kind of error to log
        DWORD           m_dwId;         // id of the msg
        XPtrLF<LPTSTR>  m_xlpStrings;   // Array to store arguments
        WORD            m_cStrings;     // Number of elements already in the array
        WORD            m_cAllocated;   // Number of elements allocated
        BOOL            m_bInitialised; // Initialised ?
        BOOL            m_bFailed;      // Failed in processing ?

        // Not implemented.
        CEvents(const CEvents& x);
        CEvents& operator=(const CEvents& x);


        BOOL ReallocArgStrings();


    public:
        CEvents(DWORD bError, DWORD dwId );
        BOOL AddArg(LPTSTR szArg);
        BOOL AddArg(LPTSTR szArgFormat, LPTSTR szArg );
        BOOL AddArg(DWORD dwArg);
        BOOL AddArgHex(DWORD dwArg);
        BOOL AddArgWin32Error(DWORD dwArg);
        BOOL AddArgLdapError(DWORD dwArg);
        BOOL Report();
        LPTSTR FormatString();
        ~CEvents();
};

typedef struct _ERRORSTRUCT {
    DWORD   dwTimeOut;
    LPTSTR  lpErrorText;
} ERRORSTRUCT, *LPERRORSTRUCT;


void ErrorDialogEx(DWORD dwTimeOut, LPTSTR lpErrMsg);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\utils\profstr.cpp ===
//*************************************************************
//
//  Private Profile APIs wrapper to deal with long names
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-2000
//  All rights reserved
//
//*************************************************************


#include "uenv.h"

#define CREATE_FILE_MAX_PATH    MAX_PATH
#define LONG_LOCAL_PATH_PREFIX  TEXT("\\\\?\\")
#define LONG_PATH_PREFIX_LEN    8

#define IS_LONG_FILE_NAME(lpFileName) ((lpFileName[0] == TEXT('\\')) && (lpFileName[1] == TEXT('\\')) && (lpFileName[2] == TEXT('?')))


//*************************************************************
//  ConvertToLongPath()
//
//  Purpose:    converts the given absolute path to long path names
//
//  Parameters:
//
//
//  Return:
//      True if successful, False otherwise. GetLastError for more details
//
//  Comments:
//
//*************************************************************


BOOL ConvertToLongPath(LPCTSTR lpFileName, LPTSTR lpLongName)
{
    //
    // Convert the path to long path..
    //

    if (!IS_LONG_FILE_NAME(lpFileName) &&
           (lstrlen(lpFileName) >= CREATE_FILE_MAX_PATH)) {

        //
        // Path is less than MAX_PATH or it is already a long path name
        //

        if (IsUNCPath(lpFileName)) {
            lstrcpy(lpLongName, LONG_UNC_PATH_PREFIX);
            lstrcat(lpLongName, lpFileName+1);
        }
        else {
            lstrcpy(lpLongName, LONG_LOCAL_PATH_PREFIX);
            lstrcat(lpLongName, lpFileName);
        }
    }
    else {
        lstrcpy(lpLongName, lpFileName);
    }

    return TRUE;
}


//*************************************************************
//  GetIniTmpFileName()
//
//  Purpose:    gets a temp file name to copy down the ini file
//
//  Parameters:
//
//
//  Return:
//      True if successful, False otherwise. GetLastError for more details
//
//  Comments:
//
//*************************************************************

BOOL GetIniTmpFileName(LPTSTR szTempFile)
{
    XPtrLF<TCHAR>  xTmpPath;
    DWORD dwSizeRequired;

    szTempFile[0] = TEXT('\0');

    xTmpPath = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*MAX_PATH);

    if (!xTmpPath) {
        DebugMsg((DM_WARNING, TEXT("GetIniTmpFileName: Couldn't allocate memory for tmpfile path")));
        return FALSE;
    }


    //
    // get the temp path
    //

    dwSizeRequired = GetTempPath(MAX_PATH, xTmpPath);

    if (dwSizeRequired == 0) {
        DebugMsg((DM_WARNING, TEXT("GetIniTmpFileName: Couldn't gettemppath. Error %d"), GetLastError()));
        return FALSE;
    }


    if (dwSizeRequired >= MAX_PATH) {

        //
        // retry with a larger buffer
        //

        xTmpPath = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*dwSizeRequired);

        if (!xTmpPath) {
            DebugMsg((DM_WARNING, TEXT("GetIniTmpFileName: Couldn't allocate memory for tmpfile path(2)")));
            return FALSE;
        }


        dwSizeRequired = GetTempPath(dwSizeRequired, xTmpPath);

        if (dwSizeRequired == 0) {
            DebugMsg((DM_WARNING, TEXT("GetIniTmpFileName: Couldn't gettemppath. Error %d"), GetLastError()));
            return FALSE;
        }
    }


    //
    // Now get a temp file in the temp directory
    //

    if (!GetTempFileName(xTmpPath, TEXT("ini"), 0, szTempFile)) {
        DebugMsg((DM_WARNING, TEXT("GetIniTmpFileName: Couldn't gettempfilename. Error - %d"), GetLastError()));
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  MyGetPrivateProfileString()
//
//  Purpose:    A version of PrivateProfileString that takes long UNC Path
//
//  Parameters:
//
//
//  Return:
//      True if successful, False otherwise. GetLastError for more details
//
//  Comments:
//
//  This returns TRUE or false based on whether it managed to read
//  successfully. In a case where it fails it will copy the default to
//  the output string GetLastError for more details
//*************************************************************

DWORD MyGetPrivateProfileString(LPCTSTR lpAppName, LPCTSTR lpKeyName,
                                LPCTSTR lpDefault, LPTSTR lpReturnedString,
                                DWORD nSize,       LPCTSTR lpFileName)
{
    XPtrLF<TCHAR>  xSrcBuf;
    TCHAR   szTempFile[MAX_PATH+1];
    DWORD   dwSize;
    DWORD   dwRet=0;

    //
    // copy the default string first
    //

    lstrcpy(lpReturnedString, lpDefault);

    //
    // get the temp file name
    //

    if (!GetIniTmpFileName(szTempFile)) {
        return 0;
    }


    xSrcBuf = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(lpFileName)+1+LONG_PATH_PREFIX_LEN));

    if (!xSrcBuf) {
        DebugMsg((DM_WARNING, TEXT("MyGetPrivateProfileString: Couldn't allocate memory for filename")));
        return 0;
    }

    //
    // Convert the given path to a long name..
    //

    ConvertToLongPath(lpFileName, xSrcBuf);


    DebugMsg((DM_VERBOSE, TEXT("MyGetPrivateProfileString: Reading from File <%s>"), xSrcBuf));

    //
    // copy the ini file to the local path
    //

    if (!CopyFile(xSrcBuf, szTempFile, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("MyGetPrivateProfileString: Couldn't copy file to temp file. Error %d"), GetLastError()));
        return 0;
    }


    //
    // Now call the proper API
    //

    dwRet = GetPrivateProfileString(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, szTempFile);

    //
    // Delete it once we are done
    //

    DeleteFile(szTempFile);

    DebugMsg((DM_VERBOSE, TEXT("MyGetPrivateProfileString: Read value %s from File <%s>"), lpReturnedString, xSrcBuf));


    return dwRet;
}


//*************************************************************
//
//  MyGetPrivateProfileInt()
//
//  Purpose:    A version of PrivateProfileInt that takes long UNC Path
//
//  Parameters:
//
//
//  Return:
//      True if successful, False otherwise. GetLastError for more details
//
//  Comments:
//
//  This returns TRUE or false based on whether it managed to read
//  successfully. In a case where it fails it will copy the default to
//  the output string GetLastError for more details
//*************************************************************

UINT MyGetPrivateProfileInt(LPCTSTR lpAppName, LPCTSTR lpKeyName,
                            INT nDefault, LPCTSTR lpFileName)
{
    XPtrLF<TCHAR>  xSrcBuf;
    TCHAR   szTempFile[MAX_PATH+1];
    DWORD   dwSize, dwSizeRequired;
    UINT    uRet=nDefault;

    if (!GetIniTmpFileName(szTempFile)) {
        return 0;
    }


    xSrcBuf = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(lpFileName)+1+LONG_PATH_PREFIX_LEN));

    if (!xSrcBuf) {
        DebugMsg((DM_WARNING, TEXT("MyGetPrivateProfileString: Couldn't allocate memory for filename")));
        return 0;
    }

    ConvertToLongPath(lpFileName, xSrcBuf);


    DebugMsg((DM_VERBOSE, TEXT("MyGetPrivateProfileString: Reading from File <%s>"), xSrcBuf));

    if (!CopyFile(xSrcBuf, szTempFile, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("MyGetPrivateProfileString: Couldn't copy file to temp file. Error %d"), GetLastError()));
        return 0;
    }


    uRet = GetPrivateProfileInt(lpAppName, lpKeyName, nDefault, szTempFile);

    DeleteFile(szTempFile);

    DebugMsg((DM_VERBOSE, TEXT("MyGetPrivateProfileString: Read value %d from File <%s>"), uRet, xSrcBuf));


    return uRet;
}


//*************************************************************
//
//  MyWritePrivateProfileString()
//
//  Purpose:    A version of PrivateProfileString that takes long UNC Path
//
//  Parameters:
//
//
//  Return:
//      True if successful, False otherwise. GetLastError for more details
//
//  Comments:
//
//  This returns TRUE or false based on whether it managed to read
//  successfully. In a case where it fails it will copy the default to
//  the output string GetLastError for more details
//*************************************************************

DWORD MyWritePrivateProfileString( LPCTSTR  lpAppName, LPCTSTR lpKeyName,
                                   LPTSTR   lpString,  LPCTSTR lpFileName)
{
    XPtrLF<TCHAR>  xSrcBuf;
    TCHAR   szTempFile[MAX_PATH+1];
    DWORD   dwSize, dwSizeRequired, dwRet=0;


    if (!GetIniTmpFileName(szTempFile)) {
        return 0;
    }

    xSrcBuf = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(lpFileName)+1+LONG_PATH_PREFIX_LEN));

    if (!xSrcBuf) {
        DebugMsg((DM_WARNING, TEXT("MyWritePrivateProfileString: Couldn't allocate memory for filename")));
        return 0;
    }

    ConvertToLongPath(lpFileName, xSrcBuf);

    DebugMsg((DM_VERBOSE, TEXT("MyWritePrivateProfileString: Writing to File <%s>"), xSrcBuf));

    if (!CopyFile(xSrcBuf, szTempFile, FALSE)) {
        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            DebugMsg((DM_WARNING, TEXT("MyWritePrivateProfileString: Couldn't copy file to temp file. Error %d"), GetLastError()));
            return 0;
        }
    }


    if (!(dwRet = WritePrivateProfileString(lpAppName, lpKeyName, lpString, szTempFile))) {
        DebugMsg((DM_WARNING, TEXT("MyWritePrivateProfileString: Couldn't Write to temp file. Error %d"), GetLastError()));
        goto Exit;
    }

    if (!CopyFile(szTempFile, xSrcBuf, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("MyWritePrivateProfileString: Couldn't copy temp ini file to <%s> file. Error %d"), xSrcBuf, GetLastError()));
        goto Exit;
    }


    DeleteFile(szTempFile);
    return dwRet;

Exit:
    DeleteFile(szTempFile);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\utils\sid.c ===
//*************************************************************
//
//  SID management functions.
//
//  THESE FUNCTIONS ARE WINDOWS NT SPECIFIC!!!!!
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"

/***************************************************************************\
* GetSidString
*
* Allocates and returns a string representing the sid of the current user
* The returned pointer should be freed using DeleteSidString().
*
* Returns a pointer to the string or NULL on failure.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
LPTSTR GetSidString(HANDLE UserToken)
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;
    LPTSTR lpEnd;
#ifndef UNICODE
    STRING String;
#endif

    //
    // Get the user sid
    //

    UserSid = GetUserSid(UserToken);
    if (UserSid == NULL) {
        DebugMsg((DM_WARNING, TEXT("GetSidString: GetUserSid returned NULL")));
        return NULL;
    }

    //
    // Convert user SID to a string.
    //

    NtStatus = RtlConvertSidToUnicodeString(
                            &UnicodeString,
                            UserSid,
                            (BOOLEAN)TRUE // Allocate
                            );
    //
    // We're finished with the user sid
    //

    DeleteUserSid(UserSid);

    //
    // See if the conversion to a string worked
    //

    if (!NT_SUCCESS(NtStatus)) {
        DebugMsg((DM_WARNING, TEXT("GetSidString: RtlConvertSidToUnicodeString failed, status = 0x%x"),
                 NtStatus));
        return NULL;
    }

#ifdef UNICODE


    return(UnicodeString.Buffer);

#else

    //
    // Convert the string to ansi
    //

    NtStatus = RtlUnicodeStringToAnsiString(&String, &UnicodeString, TRUE);
    RtlFreeUnicodeString(&UnicodeString);
    if (!NT_SUCCESS(NtStatus)) {
        DebugMsg((DM_WARNING, TEXT("GetSidString: RtlUnicodeStringToAnsiString failed, status = 0x%x"),
                 status));
        return NULL;
    }


    return(String.Buffer);

#endif

}


/***************************************************************************\
* DeleteSidString
*
* Frees up a sid string previously returned by GetSidString()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteSidString(LPTSTR SidString)
{

#ifdef UNICODE
    UNICODE_STRING String;

    RtlInitUnicodeString(&String, SidString);

    RtlFreeUnicodeString(&String);
#else
    ANSI_STRING String;

    RtlInitAnsiString(&String, SidString);

    RtlFreeAnsiString(&String);
#endif

}



/***************************************************************************\
* GetUserSid
*
* Allocs space for the user sid, fills it in and returns a pointer. Caller
* The sid should be freed by calling DeleteUserSid.
*
* Note the sid returned is the user's real sid, not the per-logon sid.
*
* Returns pointer to sid or NULL on failure.
*
* History:
* 26-Aug-92 Davidc      Created.
\***************************************************************************/
PSID GetUserSid (HANDLE UserToken)
{
    PTOKEN_USER pUser, pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;


    //
    // Allocate space for the user info
    //

    pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);


    if (pUser == NULL) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
                  BytesRequired));
        return NULL;
    }


    //
    // Read in the UserInfo
    //

    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {

        //
        // Allocate a bigger buffer and try again.
        //

        pTemp = LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
        if (pTemp == NULL) {
            DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
                      BytesRequired));
            LocalFree (pUser);
            return NULL;
        }

        pUser = pTemp;

        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if (!NT_SUCCESS(status)) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to query user info from user token, status = 0x%x"),
                  status));
        LocalFree(pUser);
        return NULL;
    }


    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if (pSid == NULL) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
                  BytesRequired));
        LocalFree(pUser);
        return NULL;
    }


    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if (!NT_SUCCESS(status)) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: RtlCopySid Failed. status = %d"),
                  status));
        LocalFree(pSid);
        pSid = NULL;
    }


    return pSid;
}


/***************************************************************************\
* DeleteUserSid
*
* Deletes a user sid previously returned by GetUserSid()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteUserSid(PSID Sid)
{
    LocalFree(Sid);
}


//+--------------------------------------------------------------------------
//
//  Function:   AllocateAndInitSidFromString
//
//  Synopsis:   given the string representation of a SID, this function
//              allocate and initializes a SID which the string represents
//              For more information on the string representation of SIDs
//              refer to ntseapi.h & ntrtl.h
//
//  Arguments:  [in] lpszSidStr : the string representation of the SID
//              [out] pSID : the actual SID structure created from the string
//
//  Returns:    STATUS_SUCCESS : if the sid structure was successfully created
//              or an error code based on errors that might occur
//
//  History:    10/6/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid)
{
    WCHAR *     pSidStr = 0;
    WCHAR*      pString = 0;
    NTSTATUS    Status;
    WCHAR*      pEnd = 0;
    int         count;
    BYTE        SubAuthCount;
    DWORD       SubAuths[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    ULONG       n;
    SID_IDENTIFIER_AUTHORITY Auth;

    pSidStr = LocalAlloc(LPTR, (lstrlen (lpszSidStr) + 1)*sizeof(WCHAR));;
    if (!pSidStr)
    {
        Status = STATUS_NO_MEMORY;
        goto AllocAndInitSidFromStr_End;
    }

    lstrcpy (pSidStr, lpszSidStr);
    pString = pSidStr;
    *ppSid = NULL;

    count = 0;
    do
    {
        pString = wcschr (pString, '-');
        if (NULL == pString)
            break;
        count++;
        pString++;
    } while (1);

    SubAuthCount = (BYTE)(count - 2);
    if (0 > SubAuthCount || 8 < SubAuthCount)
    {
        Status = ERROR_INVALID_SID;
        goto AllocAndInitSidFromStr_End;
    }

    pString = wcschr (pSidStr, L'-');
    pString++;
    pString = wcschr (pString, L'-'); //ignore the revision #
    pString++;
    pEnd = wcschr (pString, L'-');   //go to the beginning of subauths.
    if (NULL != pEnd) *pEnd = L'\0';

    Status = LoadSidAuthFromString (pString, &Auth);

    if (STATUS_SUCCESS != Status)
        goto AllocAndInitSidFromStr_End;

    for (count = 0; count < SubAuthCount; count++)
    {
        pString = pEnd + 1;
        pEnd = wcschr (pString, L'-');
        if (pEnd)
            *pEnd = L'\0';
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (STATUS_SUCCESS != Status)
            goto AllocAndInitSidFromStr_End;
        SubAuths[count] = n;
    }

    Status = RtlAllocateAndInitializeSid (&Auth, SubAuthCount,
                                          SubAuths[0], SubAuths[1], SubAuths[2],
                                          SubAuths[3], SubAuths[4], SubAuths[5],
                                          SubAuths[6], SubAuths[7], ppSid);

AllocAndInitSidFromStr_End:
    if (pSidStr)
        LocalFree( pSidStr );
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   LoadSidAuthFromString
//
//  Synopsis:   given a string representing the SID authority (as it is
//              normally represented in string format, fill the SID_AUTH..
//              structure. For more details on the format of the string
//              representation of the sid authority, refer to ntseapi.h and
//              ntrtl.h
//
//  Arguments:  [in] pString : pointer to the unicode string
//              [out] pSidAuth : pointer to the SID_IDENTIFIER_AUTH.. that is
//                              desired
//
//  Returns:    STATUS_SUCCESS if it succeeds
//              or an error code
//
//  History:    9/29/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS LoadSidAuthFromString (const WCHAR* pString,
                                PSID_IDENTIFIER_AUTHORITY pSidAuth)
{
    size_t len;
    int i;
    NTSTATUS Status;
    const ULONG LowByteMask = 0xFF;
    ULONG n;

    len = lstrlenW (pString);

    if (len > 2 && 'x' == pString[1])
    {
        //this is in hex.
        //so we must have exactly 14 characters
        //(2 each for each of the 6 bytes) + 2 for the leading 0x
        if (14 != len)
        {
            Status = ERROR_INVALID_SID;
            goto LoadAuthEnd;
        }

        for (i=0; i < 6; i++)
        {
            pString += 2;   //we need to skip the leading 0x
            pSidAuth->Value[i] = (UCHAR)(((pString[0] - L'0') << 4) +
                                         (pString[1] - L'0'));
        }
    }
    else
    {
        //this is in decimal
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (Status != STATUS_SUCCESS)
            goto LoadAuthEnd;

        pSidAuth->Value[0] = pSidAuth->Value[1] = 0;
        for (i = 5; i >=2; i--, n>>=8)
            pSidAuth->Value[i] = (UCHAR)(n & LowByteMask);
    }

    Status = STATUS_SUCCESS;

LoadAuthEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetIntfromUnicodeString
//
//  Synopsis:   converts a unicode string into an integer
//
//  Arguments:  [in] szNum : the number represented as a unicode string
//              [in] Base : the base in which the resultant int is desired
//              [out] pValue : pointer to the integer representation of the
//                             number
//
//  Returns:    STATUS_SUCCESS if successful.
//              or some other error code
//
//  History:    9/29/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue)
{
    WCHAR * pwszNumStr = 0;
    UNICODE_STRING StringW;
    size_t len;
    NTSTATUS Status;

    len = lstrlen (szNum);
    pwszNumStr = LocalAlloc( LPTR, (len + 1) * sizeof(WCHAR));

    if (!pwszNumStr)
    {
        Status = STATUS_NO_MEMORY;
        goto GetNumEnd;
    }

    lstrcpy (pwszNumStr, szNum);
    StringW.Length = len * sizeof(WCHAR);
    StringW.MaximumLength = StringW.Length + sizeof (WCHAR);
    StringW.Buffer = pwszNumStr;

    Status = RtlUnicodeStringToInteger (&StringW, Base, pValue);

GetNumEnd:
    if (pwszNumStr)
        LocalFree( pwszNumStr );
    return Status;
}


//*************************************************************
//
//  GetDomainSidFromRid()
//
//  Purpose:    Given one domain sid, constructs another domain sid
//              by replacing the tail by the passed in Rid
//
//  Parameters: pSid            -   Given Domain Sid
//              dwRid           -   Domain Rid
//              ppNewSid        -   Pointer to the New Sid
//
//  Return:     ERROR_SUCCESS on Success
//              FALSE if an error occurs
//
//  Comments:
//      Sid returned must be freed using FreeSid.
//
//  History:    Date        Author     Comment
//              6/6/95      ericflo    Created
//
//*************************************************************

NTSTATUS GetDomainSidFromDomainRid(PSID pSid, DWORD dwRid, PSID *ppNewSid)
{
    
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority;
    // pointer to identifier authority
    BYTE      nSubAuthorityCount, i;                   // count of subauthorities
    DWORD     dwSubAuthority[8]={0,0,0,0,0,0,0,0};     // subauthority 
    PUCHAR    pSubAuthCount;
    DWORD    *pdwSubAuth;
    NTSTATUS  Status=ERROR_SUCCESS;
    
    DmAssert(IsValidSid(pSid));
    
    //
    // Will fail only if passed in sid is invalid and in the case 
    // the returned value is undefined. 
    //
    
    pIdentifierAuthority = RtlIdentifierAuthoritySid(pSid);
    
    //
    // get the count of subauthorities
    //

    pSubAuthCount = RtlSubAuthorityCountSid (pSid);
    
    if (!pSubAuthCount) {
        Status = ERROR_INVALID_SID;
        goto Exit;
    }
    
    nSubAuthorityCount = *pSubAuthCount;
    
    //
    // get each of the subauthorities
    //

    for (i = 0; i < (nSubAuthorityCount-1); i++) {
        pdwSubAuth = RtlSubAuthoritySid(pSid, i);
        
        if (!pdwSubAuth) {
            Status = ERROR_INVALID_SID;
            goto Exit;
        }
        
        dwSubAuthority[i] = *pdwSubAuth;
    }
    
    dwSubAuthority[i] = dwRid;

    //
    // Allocate a sid with these..
    //

    Status = RtlAllocateAndInitializeSid(
                pIdentifierAuthority,
                nSubAuthorityCount,
                dwSubAuthority[0],
                dwSubAuthority[1],
                dwSubAuthority[2],
                dwSubAuthority[3],
                dwSubAuthority[4],
                dwSubAuthority[5],
                dwSubAuthority[6],
                dwSubAuthority[7],
                ppNewSid
                );
    
Exit:

    // Sid, All Done
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userinit\helpmsg.h ===
#ifndef __Helpmsg_h__
#define __Helpmsg_h__

#ifdef __cplusplus
extern "C" {
#endif



int HelpMessageBox(
  HINSTANCE hInst,
  HWND hWnd,          // handle to owner window
  LPCTSTR lpText,     // text in message box
  LPCTSTR lpCaption,  // message box title
  UINT uType,         // message box style
  LPTSTR szHelpLine
);

#ifdef __cplusplus
}
#endif

#endif // __Helpmsg_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\utils\util.h ===
//*************************************************************
//
//  Header file for Util.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************


#define FreeProducedString(psz) if((psz) != NULL) {LocalFree(psz);} else

LPWSTR ProduceWFromA(LPCSTR pszA);
LPSTR ProduceAFromW(LPCWSTR pszW);
LPTSTR CheckSlash (LPTSTR lpDir);
LPTSTR CheckSemicolon (LPTSTR lpDir);
BOOL Delnode (LPTSTR lpDir);
UINT CreateNestedDirectory(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
UINT CreateNestedDirectoryEx(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, BOOL bInheritEncryption);
BOOL GetProfilesDirectoryEx(LPTSTR lpProfilesDir, LPDWORD lpcchSize, BOOL bExpand);
BOOL GetDefaultUserProfileDirectoryEx (LPTSTR lpProfileDir, LPDWORD lpcchSize, BOOL bExpand);
BOOL GetAllUsersProfileDirectoryEx (LPTSTR lpProfileDir, LPDWORD lpcchSize, BOOL bExpand);
int StringToInt(LPTSTR lpNum);
BOOL RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey);
BOOL DeleteAllValues(HKEY hKey);
BOOL MakeFileSecure (LPTSTR lpFile, DWORD dwOtherSids);
BOOL GetSpecialFolderPath (INT csidl, LPTSTR lpPath);
BOOL GetFolderPath (INT csidl, HANDLE hToken, LPTSTR lpPath);
BOOL SetFolderPath (INT csidl, HANDLE hToken, LPTSTR lpPath);
void CenterWindow (HWND hwnd);
BOOL UnExpandSysRoot(LPCTSTR lpFile, LPTSTR lpResult);
LPTSTR AllocAndExpandEnvironmentStrings(LPCTSTR lpszSrc);
void IntToString( INT i, LPTSTR sz);
BOOL IsUserAGuest(HANDLE hToken);
BOOL IsUserAnAdminMember(HANDLE hToken);
BOOL IsUserALocalSystemMember(HANDLE hToken);
BOOL IsUserAnInteractiveUser(HANDLE hToken);
BOOL MakeRegKeySecure(HANDLE hToken, HKEY hKeyRoot, LPTSTR lpKeyName);
BOOL FlushSpecialFolderCache (void);
BOOL CheckForVerbosePolicy (void);
int ExtractCSIDL(LPCTSTR pcszPath, LPTSTR* ppszUsualPath);
LPTSTR MyGetDomainName (VOID);
LPTSTR MyGetUserName (EXTENDED_NAME_FORMAT  NameFormat);
LPTSTR MyGetUserNameEx (EXTENDED_NAME_FORMAT  NameFormat);
LPTSTR MyGetComputerName (EXTENDED_NAME_FORMAT  NameFormat);
void StringToGuid( TCHAR *szValue, GUID *pGuid );
void GuidToString( const GUID *pGuid, TCHAR * szValue );
BOOL ValidateGuid( TCHAR *szValue );
INT CompareGuid( GUID *pGuid1, GUID *pGuid2 );
BOOL ImpersonateUser (HANDLE hNewUser, HANDLE *hOldUser);
BOOL RevertToUser (HANDLE *hUser);
BOOL RegCleanUpValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName);
BOOL CreateSecureAdminDirectory (LPTSTR lpDirectory, DWORD dwOtherSids);
BOOL AddPowerUserAce (LPTSTR lpFile);
void ClosePingCritSec(void);
PISECURITY_DESCRIPTOR MakeGenericSecurityDesc();
LPTSTR GetUserGuid(HANDLE hToken);
LPTSTR GetOldSidString(HANDLE hToken, LPTSTR lpKeyName);
BOOL SetOldSidString(HANDLE hToken, LPTSTR lpSidString, LPTSTR lpKeyName);
LPTSTR GetErrString(DWORD dwErr, LPTSTR szErr);
LONG RegRenameKey(HKEY hKeyRoot, LPTSTR lpSrcKey, LPTSTR lpDestKey);
BOOL IsNullGUID (GUID *pguid);
BOOL GetMachineRole (LPINT piRole);
BOOL IsUNCPath(LPCTSTR lpPath);
LPTSTR MakePathUNC(LPTSTR pwszFile, LPTSTR szComputerName);
LPTSTR SupportLongFileName (LPTSTR lpDir, LPDWORD lpWrkDirSize);
BOOL SecureNestedDir (LPTSTR lpDir, PSECURITY_DESCRIPTOR pDirSd, PSECURITY_DESCRIPTOR pFileSd);
BOOL SetEnvironmentVariableInBlock(PVOID *pEnv, LPTSTR lpVariable,
                                   LPTSTR lpValue, BOOL bOverwrite);
DWORD ExpandUserEnvironmentStrings(PVOID pEnv, LPCTSTR lpSrc,
                                   LPTSTR lpDst, DWORD nSize);
LPTSTR ConvertToShareName(LPTSTR lpShare);
DWORD AbleToBypassCSC(HANDLE hTokenUser, LPCTSTR lpDir, LPTSTR *lppCscBypassedPath, TCHAR *cpDrive);
void CancelCSCBypassedConnection(HANDLE hTokenUser, TCHAR cDrive);
LPTSTR GetUserNameFromSid(LPTSTR lpSid);
int GetNetworkName( LPWSTR* pszName, DWORD dwAdapterIndex );

//
// Flags used to specify additional that needs to be present in ACEs
//
#define OTHERSIDS_EVERYONE             1
#define OTHERSIDS_POWERUSERS           2

#ifndef MAX
#define MAX(a,b) (((a)>(b))?(a):(b))
#endif

#ifndef MIN
#define MIN(a,b) (((a)<(b))?(a):(b))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userinit\gposcript.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include "SmartPtr.h"
#include "strings.h"

extern "C"
{
void PrependToPath( LPWSTR, LPWSTR*);
void PathUnquoteSpaces( LPWSTR );
void UpdateUserEnvironment();
BOOL RegDelnode( HKEY, LPWSTR );
LPWSTR GetSidString( HANDLE UserToken );
void DeleteSidString( LPWSTR SidString );
};

#define GPO_SCRIPTS_KEY L"Software\\Policies\\Microsoft\\Windows\\System\\Scripts"
#define GP_STATE_KEY    L"Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\State"
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#define SCRIPT          L"Script"
#define PARAMETERS      L"Parameters"
#define EXECTIME        L"ExecTime"
#define GPOID           L"GPO-ID"
#define SOMID           L"SOM-ID"
#define FILESYSPATH     L"FileSysPath"

#define SCR_STARTUP     L"Startup"
#define SCR_SHUTDOWN    L"Shutdown"
#define SCR_LOGON       L"Logon"
#define SCR_LOGOFF      L"Logoff"

LPTSTR
CheckSlash (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

BOOL
RegDelnodeRecurse (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    LPTSTR lpEnd;
    LONG lResult;
    DWORD dwSize;
    TCHAR szName[MAX_PATH];
    HKEY hKey;
    FILETIME ftWrite;

    //
    // First, see if we can delete the key without having
    // to recurse.
    //


    lResult = RegDeleteKey(hKeyRoot, lpSubKey);

    if (lResult == ERROR_SUCCESS) {
        return TRUE;
    }


    lResult = RegOpenKeyEx (hKeyRoot, lpSubKey, 0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }


    lpEnd = CheckSlash(lpSubKey);

    //
    // Enumerate the keys
    //

    dwSize = MAX_PATH;
    lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                           NULL, NULL, &ftWrite);

    if (lResult == ERROR_SUCCESS) {

        do {

            lstrcpy (lpEnd, szName);

            if (!RegDelnodeRecurse(hKeyRoot, lpSubKey)) {
                break;
            }

            //
            // Enumerate again
            //

            dwSize = MAX_PATH;

            lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                                   NULL, NULL, &ftWrite);


        } while (lResult == ERROR_SUCCESS);
    }

    lpEnd--;
    *lpEnd = TEXT('\0');


    RegCloseKey (hKey);


    //
    // Try again to delete the key
    //

    lResult = RegDeleteKey(hKeyRoot, lpSubKey);

    if (lResult == ERROR_SUCCESS) {
        return TRUE;
    }

    return FALSE;
}

BOOL
RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    TCHAR szDelKey[2 * MAX_PATH];


    lstrcpy (szDelKey, lpSubKey);

    return RegDelnodeRecurse(hKeyRoot, szDelKey);

}

PSID
GetUserSid( HANDLE UserToken )
{
    XPtrLF<TOKEN_USER> pUser;
    PTOKEN_USER pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;

    //
    // Allocate space for the user info
    //
    pUser = (PTOKEN_USER) LocalAlloc( LMEM_FIXED, BytesRequired );
    if ( !pUser )
    {
        return 0;
    }

    //
    // Read in the UserInfo
    //
    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if ( status == STATUS_BUFFER_TOO_SMALL )
    {
        //
        // Allocate a bigger buffer and try again.
        //
        pTemp = (PTOKEN_USER) LocalReAlloc( pUser, BytesRequired, LMEM_MOVEABLE );
        if ( !pTemp )
        {
            return 0;
        }

        pUser = pTemp;
        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if ( !NT_SUCCESS(status) )
    {
        return 0;
    }

    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if ( !pSid )
    {
        return NULL;
    }

    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    if ( !NT_SUCCESS(status) )
    {
        LocalFree(pSid);
        pSid = 0;
    }

    return pSid;
}

LPWSTR
GetSidString( HANDLE UserToken )
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;

    //
    // Get the user sid
    //
    UserSid = GetUserSid( UserToken );
    if ( !UserSid )
    {
        return 0;
    }

    //
    // Convert user SID to a string.
    //
    NtStatus = RtlConvertSidToUnicodeString(&UnicodeString,
                                            UserSid,
                                            (BOOLEAN)TRUE ); // Allocate
    LocalFree( UserSid );

    if ( !NT_SUCCESS(NtStatus) )
    {
        return 0;
    }

    return UnicodeString.Buffer ;
}

void
DeleteSidString( LPWSTR SidString )
{
    UNICODE_STRING String;

    RtlInitUnicodeString( &String, SidString );
    RtlFreeUnicodeString( &String );
}

typedef BOOL  (*PFNSHELLEXECUTEEX)(LPSHELLEXECUTEINFO lpExecInfo);

DWORD
ExecuteScript(  LPWSTR  szCmdLine,
                LPWSTR  szArgs,
                LPWSTR  szWorkingDir,
                BOOL    bSync,
                BOOL    bHide,
                BOOL    bRunMin,
                LPWSTR  szType,
                PFNSHELLEXECUTEEX pfnShellExecuteEx,
                HANDLE  hEventLog )
{
    WCHAR   szCmdLineEx[MAX_PATH];
    WCHAR   szArgsEx[3 * MAX_PATH];
    WCHAR   szCurDir[MAX_PATH];
    LPWSTR  szOldPath = 0;
    BOOL    bResult;
    DWORD   dwError;
    SHELLEXECUTEINFO ExecInfo;

    if ( GetSystemDirectory( szCurDir, ARRAYSIZE( szCurDir ) ) )
    {
        SetCurrentDirectory( szCurDir );
    }

    //
    // Expand the command line and args
    //
    ExpandEnvironmentStrings( szCmdLine, szCmdLineEx, ARRAYSIZE(szCmdLineEx) );
    ExpandEnvironmentStrings( szArgs, szArgsEx, ARRAYSIZE(szArgsEx) );

    //
    // Put the working directory on the front of the PATH
    // environment variable
    //
    PrependToPath( szWorkingDir, &szOldPath );

    //
    // Run the script
    //
    PathUnquoteSpaces( szCmdLineEx );

    ZeroMemory(&ExecInfo, sizeof(ExecInfo));
    ExecInfo.cbSize = sizeof(ExecInfo);
    ExecInfo.fMask = SEE_MASK_DOENVSUBST |
                     SEE_MASK_FLAG_NO_UI |
                     SEE_MASK_NOZONECHECKS |
                     SEE_MASK_NOCLOSEPROCESS;
    ExecInfo.lpFile = szCmdLineEx;
    ExecInfo.lpParameters = !szArgsEx[0] ? 0 : szArgsEx;
    ExecInfo.lpDirectory = szWorkingDir;

    if ( bHide )
    {
        ExecInfo.nShow = SW_HIDE;
    }
    else
    {
        ExecInfo.nShow = (bRunMin ? SW_SHOWMINNOACTIVE : SW_SHOWNORMAL );
    }

    bResult = pfnShellExecuteEx( &ExecInfo );
    dwError = GetLastError();

    //
    // Put the PATH environment variable back the way it was
    //
    if ( szOldPath )
    {
        SetEnvironmentVariable( L"PATH", szOldPath );
        LocalFree( szOldPath );
        szOldPath = 0;
    }

    if ( bResult )
    {
        dwError = 0;
        if (bSync)
        {
            WaitForSingleObject(ExecInfo.hProcess, INFINITE);
            UpdateUserEnvironment();
        }
        CloseHandle(ExecInfo.hProcess);
    }
    else
    {
        if ( hEventLog != 0 )
        {
            LPWSTR szMsgBuf[2] = { (LPTSTR) ExecInfo.lpFile, 0 };

            FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           0,
                           dwError,
                           0,
                           (LPTSTR) (&szMsgBuf[1]),
                           1,
                           0);

            ReportEvent(hEventLog,
                        EVENTLOG_ERROR_TYPE,
                        0,
                        SHELLEXEC_ERROR,
                        0,
                        2,
                        0,
                        (LPCTSTR*) &szMsgBuf,
                        0);
            if ( szMsgBuf[1] )
            {
                LocalFree( szMsgBuf[1] );
            }
        }
    }

    return dwError;
}

ScrExecGPOFromReg(  HKEY hKeyGPO,
                    HKEY hKeyStateGPO,
                    BOOL bSync,
                    BOOL bHidden,
                    BOOL bRunMin,
                    LPWSTR  szType,
                    PFNSHELLEXECUTEEX pfnShellExecuteEx,
                    HANDLE  hEventLog )
{
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   cSubKeys = 0;
    WCHAR   szFileSysPath[3*MAX_PATH];
    DWORD   dwType;
    DWORD   dwSize;

    //
    // FILESYSPATH
    // 
    dwType = REG_SZ;
    dwSize = sizeof( szFileSysPath );
    dwError = RegQueryValueEx(  hKeyGPO,
                                FILESYSPATH,
                                0,
                                &dwType,
                                (LPBYTE) szFileSysPath,
                                &dwSize );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    wcscat( szFileSysPath, L"\\Scripts\\" );
    wcscat( szFileSysPath, szType );

    //
    // get the numer of Scripts
    //
    dwError = RegQueryInfoKey(  hKeyGPO,
                                0,
                                0,
                                0,
                                &cSubKeys,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0 );
    if ( dwError == ERROR_SUCCESS )
    {
        //
        // for every Script
        //
        for ( DWORD dwIndex = 0 ; dwIndex < cSubKeys ; dwIndex++ )
        {
            XKey    hKeyScript;
            XKey    hKeyStateScript;
            WCHAR   szTemp[32];

            dwError = RegOpenKeyEx( hKeyStateGPO,
                                    _itow( dwIndex, szTemp, 16 ),
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hKeyStateScript );
            if ( dwError != ERROR_SUCCESS )
            {
                return dwError;
            }
                                        
            //
            // open the Script key (we need only read perms)
            //
            dwError = RegOpenKeyEx( hKeyGPO,
                                    szTemp,
                                    0,
                                    KEY_READ,
                                    &hKeyScript );
            if ( dwError != ERROR_SUCCESS )
            {
                return dwError;
            }

            WCHAR   szScript[MAX_PATH];
            WCHAR   szParameters[MAX_PATH];
            SYSTEMTIME  execTime;

            //
            // script
            // 
            dwType = REG_SZ;
            dwSize = sizeof( szScript );
            dwError = RegQueryValueEx(  hKeyScript,
                                        SCRIPT,
                                        0,
                                        &dwType,
                                        (LPBYTE) szScript,
                                        &dwSize );
            if ( dwError != ERROR_SUCCESS )
            {
                break;
            }

            //
            // parameters
            // 
            dwType = REG_SZ;
            dwSize = sizeof( szParameters );
            dwError = RegQueryValueEx(  hKeyScript,
                                        PARAMETERS,
                                        0,
                                        &dwType,
                                        (LPBYTE) szParameters,
                                        &dwSize );
            if ( dwError != ERROR_SUCCESS )
            {
                break;
            }

            //
            // execute script
            //
            GetSystemTime( &execTime );
            dwError = ExecuteScript(szScript,
                                    szParameters,
                                    szFileSysPath,
                                    bSync,
                                    bHidden,
                                    bRunMin,
                                    szType,
                                    pfnShellExecuteEx,
                                    hEventLog );
            if ( dwError != ERROR_SUCCESS )
            {
                ZeroMemory( &execTime, sizeof( execTime ) );
            }

            //
            // write exec time
            // 
            RegSetValueEx(  hKeyStateScript,
                            EXECTIME,
                            0,
                            REG_QWORD,
                            (LPBYTE) &execTime,
                            sizeof( execTime ) );
        }
    }

    return dwError;
}

extern "C" DWORD
ScrExecGPOListFromReg(  LPWSTR szType,
                        BOOL bMachine,
                        BOOL bSync,
                        BOOL bHidden,
                        BOOL bRunMin,
                        HANDLE  hEventLog )
{
    DWORD   dwError = ERROR_SUCCESS;
    WCHAR   szBuffer[MAX_PATH];
    XKey    hKeyType;
    XKey    hKeyState;
    XKey    hKeyStateType;

    //
    // create the following key
    // HKLM\Software\Microsoft\Windows\CurrentVersion\Group Policy\State\<Target>\Scripts\<Type>
    //
    wcscpy( szBuffer, GP_STATE_KEY L"\\" );
    if ( bMachine )
    {
        wcscat( szBuffer, L"Machine\\Scripts" );
    }
    else
    {
        XHandle hToken;

        if ( !OpenProcessToken( GetCurrentProcess(),
                                TOKEN_ALL_ACCESS,
                                &hToken ) )
        {
            return GetLastError();
        }

        LPWSTR szSid = GetSidString( hToken );

        if ( !szSid )
        {
            return GetLastError();
        }

        wcscat( szBuffer, szSid );
        wcscat( szBuffer, L"\\Scripts" );
        DeleteSidString( szSid );
    }

    //
    // state
    //
    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            szBuffer,
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyState );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    dwError = RegOpenKeyEx( hKeyState,
                            szType,
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyStateType );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // construct "Software\\Policies\\Microsoft\\Windows\\System\\Scripts\\<Type>
    //
    wcscpy( szBuffer, GPO_SCRIPTS_KEY L"\\" );
    wcscat( szBuffer, szType );

    //
    // open the key
    //
    dwError = RegOpenKeyEx( bMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                            szBuffer,
                            0,
                            KEY_READ,
                            &hKeyType );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }
    DWORD   cSubKeys = 0;

    //
    // get the numer of GPOs
    //
    dwError = RegQueryInfoKey(  hKeyType,
                                0,
                                0,
                                0,
                                &cSubKeys,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0 );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    HINSTANCE hShell32;
    PFNSHELLEXECUTEEX pfnShellExecuteEx;

    hShell32 = LoadLibrary( L"shell32.dll" );

    if ( hShell32 )
    {
        pfnShellExecuteEx = (PFNSHELLEXECUTEEX) GetProcAddress( hShell32, "ShellExecuteExW" );
        if ( !pfnShellExecuteEx )
        {
            return GetLastError();
        }
    }

    //
    // for every GPO
    //
    for ( DWORD dwIndex = 0 ; dwIndex < cSubKeys ; dwIndex++ )
    {
        XKey hKeyGPO;
        XKey hKeyStateGPO;

        //
        // open the state GPO key
        //
        dwError = RegOpenKeyEx( hKeyStateType,
                                _itow( dwIndex, szBuffer, 16 ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyStateGPO );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // open the policy GPO key (we need only read perms)
        //
        dwError = RegOpenKeyEx( hKeyType,
                                szBuffer,
                                0,
                                KEY_READ,
                                &hKeyGPO );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // execute all scripts in the GPO
        //
        DWORD dwExecError;
        dwExecError = ScrExecGPOFromReg(hKeyGPO,
                                        hKeyStateGPO,
                                        bSync,
                                        bHidden,
                                        bRunMin,
                                        szType,
                                        pfnShellExecuteEx,
                                        hEventLog );
        if ( dwExecError != ERROR_SUCCESS )
        {
            dwError = dwExecError;
        }
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\userenv\utils\util.c ===
//*************************************************************
//
//  Utility functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include <iphlpapi.h>
#include <winsock2.h>
#include <mswsock.h>

#define SMB_PROVIDER L"Microsoft Windows Network"

INT g_iMachineRole = -1;
LPVOID g_lpTestData = NULL;
CRITICAL_SECTION *g_PingCritSec;
LPCTSTR c_szUNCFilePrefix = TEXT("\\\\?\\UNC\\");
LPCTSTR c_szLocalFilePrefix = TEXT("\\\\?\\");
const DWORD c_dwLocalFilePrefixLen = sizeof(c_szLocalFilePrefix) / sizeof(TCHAR); // Length of szLocalFilePrefix in unit of TCHAR.

//
// Local function proto-types
//

DWORD IsSlowLink (HKEY hKeyRoot, LPTSTR lpDCAddress, BOOL *bSlow, DWORD* pdwAdapterIndex );
DWORD GetNetworkProvider(NETRESOURCE *psNR);

#ifdef __cplusplus
extern "C" {
#endif

DWORD APIENTRY
NPAddConnection3ForCSCAgent(
    HWND            hwndOwner,
    LPNETRESOURCE   lpNetResource,
    LPTSTR          pszPassword,
    LPTSTR          pszUserName,
    DWORD           dwFlags,
    BOOL            *lpfIsDfsConnect
    );

DWORD APIENTRY
NPCancelConnectionForCSCAgent (
    LPCTSTR         szName,
    BOOL            fForce 
    );

#ifdef __cplusplus
}
#endif

DWORD
GetGroupPolicyNetworkName( LPWSTR szNetworkName, LPDWORD pdwByteCount )
{
    HKEY    hKey;
    DWORD   dwError = ERROR_SUCCESS;

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            L"Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History",
                            0,
                            KEY_READ,
                            &hKey );
    if ( dwError == ERROR_SUCCESS )
    {
        DWORD dwType = REG_SZ;
        
        dwError = RegQueryValueEx(  hKey,
                                    L"NetworkName",
                                    0,
                                    &dwType,
                                    (LPBYTE) szNetworkName,
                                    pdwByteCount );
        RegCloseKey (hKey);
    }

    return 0;
}

int
GetNetworkName( LPWSTR* pszName, DWORD dwAdapterIndex )
{
    int iError;
    WSAQUERYSET restrictions;
    GUID WsMobilityServiceClassGuid = NLA_SERVICE_CLASS_GUID;
    WSADATA wsaData;
    HANDLE hQuery;
    PWSAQUERYSET    pResult = 0;
    DWORD           length;
    BOOL            bFinish = FALSE;
    PWS2_32_API     pWS2_32 = Loadws2_32Api();
    PIPHLPAPI_API   pIpHlpApi = LoadIpHlpApi();

    if ( !pWS2_32 )
    {
        return GetLastError();
    }

    if ( !pIpHlpApi )
    {
        return GetLastError();
    }

    //
    // Initialize Winsock
    //
    iError = pWS2_32->pfnWSAStartup( MAKEWORD(2, 2), &wsaData );
    if ( iError )
    {
        return iError;
    }

    //
    // Initialize the query for network names
    //
    ZeroMemory(&restrictions, sizeof(restrictions));
    restrictions.dwSize = sizeof(restrictions);
    restrictions.lpServiceClassId = &WsMobilityServiceClassGuid;
    restrictions.dwNameSpace = NS_NLA;

    //
    // Make sure we do not ask for the blobs that take a long time to get
    //
    if ( pWS2_32->pfnWSALookupServiceBegin( &restrictions, LUP_NOCONTAINERS, &hQuery ) )
    {
        iError = pWS2_32->pfnWSAGetLastError();
        pWS2_32->pfnWSACleanup();
        return iError;
    }

    //
    // Start loop of getting network names
    //
    while ( !bFinish )
    {
        int error;
        length = 0;

        //
        // Do call twice, first to get size of buffer for second call
        //
        error = pWS2_32->pfnWSALookupServiceNext( hQuery, 0, &length, 0 );
        iError = pWS2_32->pfnWSAGetLastError();
        if ( iError != WSAEFAULT && iError != WSA_E_NO_MORE )
        {
            break;
        }

        pResult = (PWSAQUERYSET) LocalAlloc( LPTR, length );
        if ( !pResult )
        {
            iError = GetLastError();
            break;
        }

        //
        // Get a network name
        //
        if ( !pWS2_32->pfnWSALookupServiceNext( hQuery, 0, &length, pResult ) )
        {
            if ( pResult->lpBlob )
            {
                int next;
                NLA_BLOB *blob = (NLA_BLOB *)pResult->lpBlob->pBlobData;

                do {
                    //
                    // We are looking for the blob containing the network GUID
                    //
                    if ( blob->header.type == NLA_INTERFACE )
                    {
                        //
                        // "\\DEVICE\\TCPIP_" + "{GUID"
                        //
                        WCHAR szAdapter[64];
                        DWORD dwAdapter;

                        //
                        // Convert guid to device name
                        //
                        wcscpy( szAdapter, L"\\DEVICE\\TCPIP_");
                        MultiByteToWideChar(CP_ACP,
                                            0,
                                            (LPCSTR)blob->data.interfaceData.adapterName,
                                            -1,
                                            szAdapter + 14,
                                            ARRAYSIZE(szAdapter)-14 );

                        //
                        // Get the index for the network
                        //
                        if ( pIpHlpApi->pfnGetAdapterIndex( szAdapter, &dwAdapter ) == NO_ERROR )
                        {
                            //
                            // Is it the index we are after
                            //
                            if ( dwAdapterIndex == dwAdapter && pResult->lpszServiceInstanceName )
                            {
                                //
                                // Yes, copy the network name into the buffer
                                //
                                DWORD dwSize = sizeof( WCHAR ) * ( wcslen(pResult->lpszServiceInstanceName) + 1 );
                                *pszName = (LPWSTR) LocalAlloc( LPTR, dwSize );
                                if ( !*pszName )
                                {
                                    iError = GetLastError();
                                }
                                else
                                {
                                    wcscpy( *pszName, pResult->lpszServiceInstanceName );
                                    bFinish = TRUE;
                                    iError = 0;
                                }
                            }
                        }
                    }

                    //
                    // There maybe multiple blobs for each interface so make sure we find them all
                    //
                    next = blob->header.nextOffset;
                    blob = (NLA_BLOB *)(((char *)blob) + next);

                } while ( next );
            }

            LocalFree( pResult );
        }
        else
        {
            iError = pWS2_32->pfnWSAGetLastError();
            if ( iError == WSA_E_NO_MORE )
            {
                iError = 0;
            }
            LocalFree( pResult );
            break;
        }
    }

    //
    // tidy up
    //
    pWS2_32->pfnWSALookupServiceEnd( hQuery );
    pWS2_32->pfnWSACleanup();
    return iError;
}

//*************************************************************
//
//  ProduceWFromA()
//
//  Purpose:    Creates a buffer for a Unicode string and copies
//              the ANSI text into it (converting in the process)
//
//  Parameters: pszA    -   ANSI string
//
//
//  Return:     Unicode pointer if successful
//              NULL if an error occurs
//
//  Comments:   The caller needs to free this pointer.
//
//
//  History:    Date        Author     Comment
//              5/24/95     ericflo    Ported
//
//*************************************************************

LPWSTR ProduceWFromA(LPCSTR pszA)
{
    LPWSTR pszW;
    int cch;

    if (!pszA)
        return (LPWSTR)pszA;

    cch = MultiByteToWideChar(CP_ACP, 0, pszA, -1, NULL, 0);

    if (cch == 0)
        cch = 1;

    pszW = LocalAlloc(LPTR, cch * sizeof(WCHAR));

    if (pszW) {
        if (!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszA, -1, pszW, cch)) {
            LocalFree(pszW);
            pszW = NULL;
        }
    }

    return pszW;
}

//*************************************************************
//
//  ProduceAFromW()
//
//  Purpose:    Creates a buffer for an ANSI string and copies
//              the Unicode text into it (converting in the process)
//
//  Parameters: pszW    -   Unicode string
//
//
//  Return:     ANSI pointer if successful
//              NULL if an error occurs
//
//  Comments:   The caller needs to free this pointer.
//
//
//  History:    Date        Author     Comment
//              5/24/95     ericflo    Ported
//
//*************************************************************

LPSTR ProduceAFromW(LPCWSTR pszW)
{
    LPSTR pszA;
    int cch;

    if (!pszW)
        return (LPSTR)pszW;

    cch = WideCharToMultiByte(CP_ACP, 0, pszW, -1, NULL, 0, NULL, NULL);

    if (cch == 0)
        cch = 1;

    pszA = LocalAlloc(LPTR, cch * sizeof(char));

    if (pszA) {
         if (!WideCharToMultiByte(CP_ACP, 0, pszW, -1, pszA, cch, NULL, NULL)) {
            LocalFree(pszA);
            pszA = NULL;
        }
    }

    return pszA;
}


//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

//*************************************************************
//
//  CheckSemicolon()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericlfo    Created
//
//*************************************************************
LPTSTR CheckSemicolon (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT(';')) {
        *lpEnd =  TEXT(';');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}



//*************************************************************
//
//  Delnode_Recurse()
//
//  Purpose:    Recursive delete function for Delnode
//
//  Parameters: lpDir   -   Full Directory Path. 
//              dwSize  -   Allocated size of the working buffer
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/10/95     ericflo    Created
//
// Notes:
//  This function modifies the working buffer. 
//  This doesn't maintain the right error code. It ignores all
//  errors and tries to delete as much as possible..
//
//*************************************************************

BOOL Delnode_Recurse (LPTSTR lpDir, DWORD dwSize)
{
    BOOL bOwn = FALSE, bRetVal = FALSE;
    LPTSTR lpEnd = NULL, lpWrkDir = NULL;
    WIN32_FIND_DATA fd;
    HANDLE hFile;
    DWORD dwWrkDirSize;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Entering, lpDir = <%s>"), lpDir));


    //
    // Each filename or a directory has to be less than MAX_PATH in the worst case.
    // So make sure that we have at least MAX_PATH + 2 (for a slash and '\0'
    // space left in the working buffer case.
    //
    // In the normal case, when we have a path of length ~MAX_PATH it will do only 
    // 1 allocation
    //


    if ((DWORD)(lstrlen(lpDir) + MAX_PATH+2) > (dwSize)) {
        
        dwWrkDirSize = dwSize+2*MAX_PATH;
        lpWrkDir = (LPWSTR)LocalAlloc(LPTR, dwWrkDirSize*sizeof(TCHAR));
        if (!lpWrkDir) {
            DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: Couldn't allocate memory for working buffer. Error - %d"), GetLastError()));
            goto Exit;
        }

        lstrcpy(lpWrkDir, lpDir);
        bOwn = TRUE;

    }
    else {
        lpWrkDir = lpDir;
        dwWrkDirSize = dwSize;
    }


    //
    // Attach a Slash the end if required
    //

    lpEnd = CheckSlash(lpWrkDir);
    lstrcat(lpEnd, c_szStarDotStar);


    //
    // Find the first file
    //

    hFile = FindFirstFile(lpWrkDir, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

        if ((GetLastError() == ERROR_FILE_NOT_FOUND) || (GetLastError() == ERROR_PATH_NOT_FOUND)) {
            bRetVal = TRUE;
            goto Exit;
        } else {
            DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: FindFirstFile failed.  Error = %d"),
                     GetLastError()));
            goto Exit;
        }
    }


    do {
        //
        //  Verbose output
        //

        DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: FindFile found:  <%s>"),
                 fd.cFileName));

        //
        // Check for "." and ".."
        //

        if (!lstrcmpi(fd.cFileName, c_szDot)) {
            continue;
        }

        if (!lstrcmpi(fd.cFileName, c_szDotDot)) {
            continue;
        }

        lstrcpyn(lpEnd, fd.cFileName, MAX_PATH);


        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Found a directory.
            //
            if (fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
            {
                DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: Found a reparse point <%s>,  Will not recurse into it!"), lpWrkDir));
            }
            else
            {
                Delnode_Recurse(lpWrkDir, dwWrkDirSize);

                //
                // ignore errors and go ahead..
                //

                lstrcpyn(lpEnd, fd.cFileName, MAX_PATH);
            }


            if (fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                fd.dwFileAttributes &= ~FILE_ATTRIBUTE_READONLY;
                SetFileAttributes (lpWrkDir, fd.dwFileAttributes);
            }


            if (!RemoveDirectory (lpWrkDir)) {
                DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: Failed to delete directory <%s>.  Error = %d"),
                        lpWrkDir, GetLastError()));
            }

        } else {

            //
            // We found a file.  Set the file attributes,
            // and try to delete it.
            //

            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)) {
                SetFileAttributes (lpWrkDir, FILE_ATTRIBUTE_NORMAL);
            }

            if (!DeleteFile (lpWrkDir)) {
                DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: Failed to delete <%s>.  Error = %d"),
                        fd.cFileName, GetLastError()));
            }

        }


        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, &fd));


    //
    // Close the search handle
    //

    FindClose(hFile);

    //
    // Success.
    //

    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Leaving <%s>"), lpDir));

    bRetVal = TRUE;

Exit:
    if (bOwn) 
        LocalFree(lpWrkDir);
    
    return bRetVal;
}


//*************************************************************
//
//  Delnode()
//
//  Purpose:    Recursive function that deletes files and
//              directories.
//
//  Parameters: lpDir   -   Directory
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/23/95     ericflo    Created
//              6/27/00     santanuc   modified to allow deletion of file with path length > MAX_PATH
//
//*************************************************************

BOOL Delnode (LPTSTR lpDir)
{
    LPTSTR lpWrkDir = NULL;
    DWORD dwWrkDirSize;
    BOOL   bRetVal = FALSE;

    lpWrkDir = SupportLongFileName(lpDir, &dwWrkDirSize);

    if (!lpWrkDir) {
        DebugMsg((DM_WARNING, TEXT("Delnode: Failed to Allocate memory.  Error = %d"),
                GetLastError()));
        goto Exit;
    }

    if (!Delnode_Recurse (lpWrkDir, dwWrkDirSize)) {
        DebugMsg((DM_WARNING, TEXT("Delnode: Delnode recurse failed with error %d"),
                GetLastError()));
    }
        
    if (!RemoveDirectory (lpDir)) {
        DWORD dwError;

        dwError = GetLastError();

        if ((dwError != ERROR_FILE_NOT_FOUND) &&
            (dwError != ERROR_PATH_NOT_FOUND)) {
            DebugMsg((DM_VERBOSE, TEXT("Delnode: Failed to delete directory <%s>.  Error = %d"),
                    lpDir, dwError));
        }

        goto Exit;
    }

    bRetVal = TRUE;

    DebugMsg((DM_VERBOSE, TEXT("Delnode: Deleted directory <%s> successfully."), lpDir));

Exit:
    
    if (lpWrkDir) {
        LocalFree(lpWrkDir);
    }

    return bRetVal;
}



//*************************************************************
//
//  CreateSystemDirectory()
//
//  Purpose:    A directory with system bit turned on can be created using 
//              CreateSystemDirectory.
//
//              This API causes a system directory with the specified pathname to be
//              created.  If the underlying file system supports security on files
//              and directories, then the SecurityDescriptor argument is applied to
//              the new directory.
//
//              This call is similar to DOS (int 21h, function 39h) and OS/2's
//              DosCreateDir.
//
//
//  Parameters: lpPathName - Supplies the pathname of the system directory to be created.
//              lpSecurityAttributes - An optional parameter that, if present, and
//                         supported on the target file system supplies a security
//                         descriptor for the new directory.
//
//
//  Return:     TRUE - The operation was successful.
//              FALSE/NULL - The operation failed. Extended error status is available
//                           using GetLastError.
//
//  Comments:   This function is exactly same as CreateDirectory API with the exception 
//              that the directory is created using attribute FILE_ATTRIBUTE_SYSTEM.
//              This allows newly created directory to not inherit the encryption property 
//              from parent directory if the parent directory is encrypted.
//
//  History:    Date        Author     Comments 
//              07/18/00    santanuc   To avoid deadlock situation when Documents and Settings
//                                     directory is encrypted.
//
//*************************************************************

BOOL CreateSystemDirectory(LPCTSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    ULONG dwErrorCode;

    TranslationStatus = RtlDosPathNameToNtPathName_U( lpPathName,
                                                      &FileName,
                                                      NULL,
                                                      &RelativeName);

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

    //
    // dont create a directory unless there is room in the directory for
    // at least an 8.3 name. This way everyone will be able to delete all
    // files in the directory by using del *.* which expands to path+\*.*
    //

    if ( FileName.Length > ((MAX_PATH-12)<<1) ) {
        DWORD L;
        LPWSTR lp;

        if ( !(lpPathName[0] == '\\' && lpPathName[1] == '\\' &&
               lpPathName[2] == '?' && lpPathName[3] == '\\') ) {
            L = GetFullPathNameW(lpPathName,0,NULL,&lp);
            if ( !L || L+12 > MAX_PATH ) {
                RtlFreeHeap(RtlProcessHeap(), 0,FileName.Buffer);
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                return FALSE;
            }
        }
    }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
    }
    else {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes( &Obja,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                RelativeName.ContainingDirectory,
                                NULL );

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
    }
 
    // Creating the directory with attribute FILE_ATTRIBUTE_SYSTEM to avoid inheriting encryption 
    // property from parent directory

    Status = NtCreateFile( &Handle,
                           FILE_LIST_DIRECTORY | SYNCHRONIZE,
                           &Obja,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_SYSTEM,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_CREATE,
                           FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                           NULL,
                           0L );

    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    if ( NT_SUCCESS(Status) ) {
        NtClose(Handle);
        return TRUE;
    }
    else {
        if ( RtlIsDosDeviceName_U((LPWSTR)lpPathName) ) {
            Status = STATUS_NOT_A_DIRECTORY;
        }

        // Since RtlNtStatusToDosError function can't convert STATUS_TIMEOUT, we have to 
        // do it explicitly

        if (Status == STATUS_TIMEOUT) {
            SetLastError(ERROR_TIMEOUT);
        }
        else {
            dwErrorCode = RtlNtStatusToDosError( Status );
            SetLastError( dwErrorCode );  
        }
        return FALSE;
    }
}


//*************************************************************
//
//  CreateNestedDirectory()
//
//  Purpose:    Creates a subdirectory and all it's parents
//              if necessary using CreateNestedDirectoryEx. 
//
//  Parameters: lpDirectory -   Directory name
//              lpSecurityAttributes    -   Security Attributes
//
//  Return:     > 0 if successful
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/18/00     santanuc   Created
//
//*************************************************************

UINT CreateNestedDirectory(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    // Call CreateNestedDirectoryEx with inherit encryption property
    return CreateNestedDirectoryEx(lpDirectory, lpSecurityAttributes, TRUE);
}

//*************************************************************
//
//  CreateNestedDirectoryEx()
//
//  Purpose:    Creates a subdirectory and all it's parents
//              if necessary. 
//
//  Parameters: lpDirectory -   Directory name
//              lpSecurityAttributes    -   Security Attributes
//              bInheritEncryption - Flag indicating whether newly created directory should inherit
//                                   encryption property from parent directory.
//
//  Return:     > 0 if successful
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/08/95     ericflo    Created
//              7/18/00     santanuc   added a new flag bInheritEncryption to avoid deadlock when 
//                                     Documents and Settings directory is encrypted.
//
//*************************************************************

UINT CreateNestedDirectoryEx(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, BOOL bInheritEncryption)
{
    TCHAR szDirectory[2*MAX_PATH];
    LPTSTR lpEnd;
    WIN32_FILE_ATTRIBUTE_DATA fad;


    //
    // Check for NULL pointer
    //

    if (!lpDirectory || !(*lpDirectory)) {
        DebugMsg((DM_WARNING, TEXT("CreateNestedDirectory:  Received a NULL pointer.")));
        return 0;
    }


    //
    // Test if the directory exists already
    //

    if (GetFileAttributesEx (lpDirectory, GetFileExInfoStandard, &fad)) {
        if (fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            return ERROR_ALREADY_EXISTS;
        } else {
            SetLastError(ERROR_ACCESS_DENIED);
            return 0;
        }
    }


    //
    // First, see if we can create the directory without having
    // to build parent directories.
    //

    if ( bInheritEncryption ) {
        if (CreateDirectory (lpDirectory, lpSecurityAttributes)) 
            return 1;
    }
    else {
        if (CreateSystemDirectory (lpDirectory, lpSecurityAttributes)) {
            SetFileAttributes(lpDirectory, FILE_ATTRIBUTE_NORMAL);  // turn off the system attribute
            return 1;
        }
    }


    //
    // No luck, copy the string to a buffer we can munge
    //

    lstrcpy (szDirectory, lpDirectory);


    //
    // Find the first subdirectory name
    //

    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {

        //
        // Skip the first two slashes
        //

        lpEnd += 2;

        //
        // Find the slash between the server name and
        // the share name.
        //

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Skip the slash, and find the slash between
        // the share name and the directory name.
        //

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Leave pointer at the beginning of the directory.
        //

        lpEnd++;


    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!GetFileAttributesEx (szDirectory, GetFileExInfoStandard, &fad)) {

                if ( bInheritEncryption ) {
                    if (!CreateDirectory (szDirectory, lpSecurityAttributes)) {
                        DebugMsg((DM_WARNING, TEXT("CreateNestedDirectory:  CreateDirectory failed with %d."), GetLastError()));
                        return 0;
                    }
                }

                else {
                    if (!CreateSystemDirectory (szDirectory, lpSecurityAttributes)) {
                        DebugMsg((DM_WARNING, TEXT("CreateNestedDirectory:  CreateDirectory failed with %d."), GetLastError()));
                        return 0;
                    }
                    else
                        SetFileAttributes(szDirectory, FILE_ATTRIBUTE_NORMAL); // turn off the system attribute
                }

            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    //
    // Create the final directory
    //

    if ( bInheritEncryption ) {
        if (CreateDirectory (lpDirectory, lpSecurityAttributes)) 
            return 1;
    }
    else {
        if (CreateSystemDirectory (lpDirectory, lpSecurityAttributes)) {
            SetFileAttributes(lpDirectory, FILE_ATTRIBUTE_NORMAL); // turn off the system attribute
            return 1;
        }
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    