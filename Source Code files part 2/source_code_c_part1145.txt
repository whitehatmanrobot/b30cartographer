ismatch");
		// hash mismatch - something very wrong
		hr = CRYPT_E_HASH_VALUE;
		goto exit;
	}
	
exit:
	return hr;
}

// this should only be called once
HRESULT 
CHTTPFileSource::SetSourcePath(LPCWSTR wzSourceFilePath)
{
	// keep the source path

	HRESULT hr=S_OK;
	WCHAR* p;

	// copy and avoid buffer overflows
	wcsncpy(wzSourcePath, wzSourceFilePath, MAX_URL_LENGTH-1);
	wzSourcePath[MAX_URL_LENGTH-1] = L'\0';

	// strip out the filename portion of the filepath
	p = UrlFindFileName(wzSourcePath);
	if ((p-wzSourcePath) >= MAX_URL_LENGTH)
	{
		hr = CO_E_PATHTOOLONG;
		goto exit;
	}
	else if (p <= wzSourcePath)
	{
		// this file path has no filename in it or is invalid (eg. root)
		hr = E_INVALIDARG;
		goto exit;
	}
	
	*(p-1) = L'\0';

exit:
	if (FAILED(hr))
		wzSourcePath[0] = L'\0';

	return hr;
}

// returning the local app root path with all directories created
HRESULT
CHTTPFileSource::BuildLocalAppRootHierarchy(APPNAME* pAppName, LPWSTR wzLocalAppRoot)
{
	// BUGBUG: this pretty much duplicates CUNCFileSource::BuildLocalAppRootHierarchy(,)
	// build from wzSourcePath
	
	HRESULT hr=S_OK;
	int len = wcslen(wzSourcePath);
	DWORD dwLen = MAX_URL_LENGTH-1;
	WCHAR wzHostName[MAX_URL_LENGTH];
	WCHAR wzAppDir[MAX_PATH];

	if (len <8)
	{
		/* must be at least http://a */
		hr = E_INVALIDARG;
		goto exit;
	}

	if (FAILED(hr = UrlGetPart(wzSourcePath, wzHostName, &dwLen, URL_PART_HOSTNAME, 0)))
	{
		// what is this?!
		hr = E_FAIL;
		goto exit;
	}

	// 1 get default local root
	if (FAILED(hr=GetDefaultLocalRoot(wzLocalAppRoot)))
		goto exit;

	// 2 append part of source path as the app root
	if (FAILED(hr=GetAppDir(pAppName, wzAppDir)))
		goto exit;

	if (!PathAppend(wzLocalAppRoot, wzAppDir))
	{
		hr = E_FAIL;
		goto exit;
	}
	
	// 3 create the directories
	if (FAILED(hr=CreatePathHierarchy(wzLocalAppRoot)))
	{
		goto exit;
	}

exit:
	if (FAILED(hr))
		wzLocalAppRoot[0] = L'\0';

	return hr;
}

// returning the source file path from a filename
HRESULT 
CHTTPFileSource::GetFullFilePath(LPCWSTR wzFilename, LPWSTR wzFullFilePath)
{
	// wzFilename cannot = L'\0'
	// wzFullFilePath must be of length MAX_URL_LENGTH

	HRESULT hr=S_OK;

	if (wzSourcePath[0] == L'\0')
	{
		// source path not set
		hr = E_UNEXPECTED;
		goto exit;
	}

	wcscpy(wzFullFilePath, wzSourcePath);
	if (!UrlAppend(wzFullFilePath, wzFilename))
	{
		hr = E_FAIL;
		//goto exit;
	}

exit:
	return hr;

}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
ProcessUrl(LPCWSTR wzRefFilePath, LPCWSTR wzRefRealFilename, APPNAME* pAppName, LPWSTR wzCodebase)
{
	HRESULT hr=S_OK;
	CHTTPFileSource httpfs;
	WCHAR wzLocalPath[MAX_PATH];
	WCHAR *p = NULL;

	// step 1: check the commandline argument's extension -  somewhat optional
	if ((_wcsicmp(PathFindExtension(wzRefRealFilename), SHORTCUTFILEEXT) != 0) ||
		!PathIsURL(wzCodebase) || //!PathFileExists(wzRefFilePath) || not work w/ UNC source
		UrlIsFileUrl(wzCodebase) || UrlIsOpaque(wzCodebase))	// BUGBUG? :check http:// too
	{
		hr = E_INVALIDARG; // file ext mismatch OR is a file:// or path is not an URL AND file not exist
		goto exit;
	}

	// step 2: get the shortcut file and the .manifest file
	if (FAILED(hr = httpfs.SetSourcePath(wzCodebase)))
		goto exit;

	if (FAILED(hr = httpfs.BuildLocalAppRootHierarchy(pAppName, wzLocalPath)))
		goto exit;

	if(!PathAppend(wzLocalPath, wzRefRealFilename))
	{
		hr = E_FAIL;
DbgMsg(L"path for .app fails");
		goto exit;
	}

	// get file via CopyFile
	if (FAILED(hr = httpfs.GetFile(wzRefFilePath, wzLocalPath)))  // ignore E_UNEXPECTED?
	{
DbgMsg(L"get .app fails");
		goto exit;
	}

	*PathFindFileName(wzLocalPath) = L'\0';
	p = UrlFindFileName(wzCodebase);
	if (p == wzCodebase || !PathAppend(wzLocalPath, p))
	{
		hr = E_FAIL;
DbgMsg(L"path for .manifest fails");
		goto exit;
	}

	if (FAILED(hr = httpfs.GetFile(p, wzLocalPath, NULL)))  // ignore E_UNEXPECTED?
	{
DbgMsg(L"get .manifest fails");
		goto exit;
	}

	// step 3: process the .manifest file
	if (FAILED(hr = ProcessAppManifest(wzLocalPath, &httpfs, pAppName)))
		goto exit;

exit:
	if (hr == E_ABORT)
		MsgShow(L"Operation aborted.");
	else if (FAILED(hr))
		MsgShow(L"Error Encountered.");
	else
	{
		// if SUCCEEDED
		// do not overwrite if shortcut exists. ignore error
		// note: this should probably be done only in the "1st install" case
		//    - ie. need feedback from ProcessAppManifest()
		CopyToStartMenu(wzRefFilePath, wzRefRealFilename, FALSE);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
ProcessUNC(LPCWSTR wzRefFilePath, LPCWSTR wzRefRealFilename, APPNAME* pAppName, LPWSTR wzCodebase)
{
	// BUGBUG: this pretty much duplicates ProcessUrl

	HRESULT hr=S_OK;
	CUNCFileSource uncfs;
	WCHAR wzLocalPath[MAX_PATH];
	WCHAR *p = NULL;

	// step 1: check the commandline argument's extension -  somewhat optional
	if ((_wcsicmp(PathFindExtension(wzRefRealFilename), SHORTCUTFILEEXT) != 0) ||
		(!PathIsUNC(wzCodebase) && !PathFileExists(wzCodebase)))
	{
		hr = E_INVALIDARG; // file ext mismatch OR (path is not an UNC AND file not exist(ie. not local))
		goto exit;
	}

	// step 2: get the shortcut file and the .manifest file
	if (FAILED(hr = uncfs.SetSourcePath(wzCodebase)))
		goto exit;

	if (FAILED(hr = uncfs.BuildLocalAppRootHierarchy(pAppName, wzLocalPath)))
		goto exit;

	if(!PathAppend(wzLocalPath, wzRefRealFilename))
	{
		hr = E_FAIL;
DbgMsg(L"path for .app fails");
		goto exit;
	}

	if (FAILED(hr = uncfs.GetFile(wzRefFilePath, wzLocalPath)))  // ignore E_UNEXPECTED?
	{
DbgMsg(L"get .app fails");
		goto exit;
	}

	*PathFindFileName(wzLocalPath) = L'\0';
	p = PathFindFileName(wzCodebase);
	if (p == wzCodebase || !PathAppend(wzLocalPath, p))
	{
		hr = E_FAIL;
DbgMsg(L"path for .manifest fails");
		goto exit;
	}

	if (FAILED(hr = uncfs.GetFile(p, wzLocalPath, NULL)))  // ignore E_UNEXPECTED?
	{
DbgMsg(L"get .manifest fails");
		goto exit;
	}

	// step 3: process the .manifest file
	if (FAILED(hr = ProcessAppManifest(wzLocalPath, &uncfs, pAppName)))
		goto exit;

exit:
	if (hr == E_ABORT)
		MsgShow(L"Operation aborted.");
	else if (FAILED(hr))
		MsgShow(L"Error Encountered.");
	else
	{
		// if SUCCEEDED
		// do not overwrite if shortcut exists. ignore error
		// note: this should probably be done only in the "1st install" case
		//    - ie. need feedback from ProcessAppManifest()
		CopyToStartMenu(wzRefFilePath, wzRefRealFilename, FALSE);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

int __cdecl wmain( int argc, wchar_t *argv[], wchar_t *envp[] )
{
	BOOL isRefFileTemp = FALSE;
	LPWSTR pwzRef = NULL;
	LPWSTR pwzRefRealFilename = NULL;
	WCHAR wzCodebase[MAX_URL_LENGTH];
	APPNAME appName;

	// BUGBUG: ** a hack to hide the console window when starts **
	//- should convert this to a window-less WinMain app
	ShowWindow(GetConsoleWindow(), SW_HIDE);

	if (argc < 2)
	{
		MsgShow(L"No commandline argument specified");
		goto exit;
	}

	if (PathFileExists(argv[1]) || PathIsUNC(argv[1]))
	{
		// ref local or on a UNC
		pwzRef = argv[1];

		pwzRefRealFilename = PathFindFileName(argv[1]);
		if (pwzRefRealFilename == argv[1])
		{
			MsgShow(L"Invalid file path");
			goto exit;
		}
	}
	else if (PathIsURL(argv[1]))
	{
		// ref is from a URL
		if (argc < 3)
		{
			// arguments: <url to .app> <local path to a copy of .app as a .tmp>
			// msg ambiguity is intented
			MsgShow(L"Invalid argument");
			goto exit;
		}

		// should only be called this way by the mimefilter
		// if so, the ref file is a temp file that has to be deleted
		pwzRef = argv[2];

		// note: will delete the file named by argv[2], the temp ref file
		isRefFileTemp = TRUE;

		pwzRefRealFilename = UrlFindFileName(argv[1]);
		if (pwzRefRealFilename == argv[1])
		{
			MsgShow(L"Invalid file path");
			goto exit;
		}
	}
	else
	{
		MsgShow(L"Invalid commandline argument specified");
		goto exit;
	}

	wzCodebase[0] = L'\0';
	appName._wzDisplayName[0] = L'\0';
	appName._wzName[0] = L'\0';
	appName._wzVersion[0] = L'\0';
	appName._wzCulture[0] = L'\0';
	appName._wzPKT[0] = L'\0';

	// parse the shortcut to get the codebase
	if (FAILED(ProcessRef(pwzRef, &appName, wzCodebase)))
	{
		MsgShow(L".app file processing fails");
		goto exit;
	}

	if (PathIsURL(wzCodebase))
	{
		// note: this basically allows a ref file on a UNC pointing to
		//  app files on a web server. possible security risk?
		//  security token is still computed from the codebase,
		//  ie, URL, though

		// ignore return value
		ProcessUrl(pwzRef, pwzRefRealFilename, &appName, wzCodebase);

	} 
	else // default is UNC/local path (PathIsUNC(wzCodebase))
	{
		// note: this allows a ref file on a web server
		//  to run something from the disk or UNC. security?
		//  security token is still computed from the codebase,
		//  ie, UNC, though

		// ignore return value
		ProcessUNC(pwzRef, pwzRefRealFilename, &appName, wzCodebase);
	}

exit:
	if (isRefFileTemp)
	{
		if (argv[2][0] != L'\0')
    	{
    		// ignore return value
	        DeleteFile(argv[2]);
    	}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\inc\md5.h ===
#ifndef MD5_H
#define MD5_H

#ifdef __alpha
typedef unsigned int uint32;
#else
typedef unsigned long uint32;
#endif

struct MD5Context {
        uint32 buf[4];
        uint32 bits[2];
        unsigned char in[64];
};

//extern void MD5Init();
void MD5Init(struct MD5Context *ctx);
//extern void MD5Update();
void MD5Update(struct MD5Context *ctx, unsigned char *buf, unsigned len);
//extern void MD5Final();
void MD5Final(unsigned char digest[16], struct MD5Context *ctx);
//extern void MD5Transform();
void MD5Transform(uint32 buf[4], uint32 in[16]);

#endif /* !MD5_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\dll\md5.cpp ===
/*
 * This code implements the MD5 message-digest algorithm.
 * The algorithm is due to Ron Rivest.	This code was
 * written by Colin Plumb in 1993, no copyright is claimed.
 * This code is in the public domain; do with it what you wish.
 *
 * Equivalent code is available from RSA Data Security, Inc.
 * This code has been tested against that, and is equivalent,
 * except that you don't need to include two pages of legalese
 * with every copy.
 *
 * To compute the message digest of a chunk of bytes, declare an
 * MD5Context structure, pass it to MD5Init, call MD5Update as
 * needed on buffers full of bytes, and then call MD5Final, which
 * will fill a supplied 16-byte array with the digest.
 */

/* Brutally hacked by John Walker back from ANSI C to K&R (no
   prototypes) to maintain the tradition that Netfone will compile
   with Sun's original "cc". */
/* Changed by Felix Cheung back to ANSI C */

#include <memory.h>		 /* for memcpy() */
#include "md5.h"

#ifdef sgi
#define HIGHFIRST
#endif

#ifdef sun
#define HIGHFIRST
#endif

#ifndef HIGHFIRST
#define byteReverse(buf, len)	/* Nothing */
#else
/*
 * Note: this code is harmless on little-endian machines.
 */
void byteReverse(unsigned char *buf, unsigned longs)
{
    uint32 t;
    do {
	t = (uint32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
	    ((unsigned) buf[1] << 8 | buf[0]);
	*(uint32 *) buf = t;
	buf += 4;
    } while (--longs);
}
#endif

/*
 * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
 * initialization constants.
 */
void MD5Init(struct MD5Context *ctx)
{
    ctx->buf[0] = 0x67452301;
    ctx->buf[1] = 0xefcdab89;
    ctx->buf[2] = 0x98badcfe;
    ctx->buf[3] = 0x10325476;

    ctx->bits[0] = 0;
    ctx->bits[1] = 0;
}

/*
 * Update context to reflect the concatenation of another buffer full
 * of bytes.
 */
void MD5Update(struct MD5Context *ctx, unsigned char *buf, unsigned len)
{
    uint32 t;

    /* Update bitcount */

    t = ctx->bits[0];
    if ((ctx->bits[0] = t + ((uint32) len << 3)) < t)
	ctx->bits[1]++; 	/* Carry from low to high */
    ctx->bits[1] += len >> 29;

    t = (t >> 3) & 0x3f;	/* Bytes already in shsInfo->data */

    /* Handle any leading odd-sized chunks */

    if (t) {
	unsigned char *p = (unsigned char *) ctx->in + t;

	t = 64 - t;
	if (len < t) {
	    memcpy(p, buf, len);
	    return;
	}
	memcpy(p, buf, t);
	byteReverse(ctx->in, 16);
	MD5Transform(ctx->buf, (uint32 *) ctx->in);
	buf += t;
	len -= t;
    }
    /* Process data in 64-byte chunks */

    while (len >= 64) {
	memcpy(ctx->in, buf, 64);
	byteReverse(ctx->in, 16);
	MD5Transform(ctx->buf, (uint32 *) ctx->in);
	buf += 64;
	len -= 64;
    }

    /* Handle any remaining bytes of data. */

    memcpy(ctx->in, buf, len);
}

/*
 * Final wrapup - pad to 64-byte boundary with the bit pattern 
 * 1 0* (64-bit count of bits processed, MSB-first)
 */
void MD5Final(unsigned char digest[16], struct MD5Context *ctx)
{
    unsigned count;
    unsigned char *p;

    /* Compute number of bytes mod 64 */
    count = (ctx->bits[0] >> 3) & 0x3F;

    /* Set the first char of padding to 0x80.  This is safe since there is
       always at least one byte free */
    p = ctx->in + count;
    *p++ = 0x80;

    /* Bytes of padding needed to make 64 bytes */
    count = 64 - 1 - count;

    /* Pad out to 56 mod 64 */
    if (count < 8) {
	/* Two lots of padding:  Pad the first block to 64 bytes */
	memset(p, 0, count);
	byteReverse(ctx->in, 16);
	MD5Transform(ctx->buf, (uint32 *) ctx->in);

	/* Now fill the next block with 56 bytes */
	memset(ctx->in, 0, 56);
    } else {
	/* Pad block to 56 bytes */
	memset(p, 0, count - 8);
    }
    byteReverse(ctx->in, 14);

    /* Append length in bits and transform */
    ((uint32 *) ctx->in)[14] = ctx->bits[0];
    ((uint32 *) ctx->in)[15] = ctx->bits[1];

    MD5Transform(ctx->buf, (uint32 *) ctx->in);
    byteReverse((unsigned char *) ctx->buf, 4);
    memcpy(digest, ctx->buf, 16);
    memset(ctx, 0, sizeof(ctx));        /* In case it's sensitive */
}


/* The four core functions - F1 is optimized somewhat */

/* #define F1(x, y, z) (x & y | ~x & z) */
#define F1(x, y, z) (z ^ (x & (y ^ z)))
#define F2(x, y, z) F1(z, x, y)
#define F3(x, y, z) (x ^ y ^ z)
#define F4(x, y, z) (y ^ (x | ~z))

/* This is the central step in the MD5 algorithm. */
#define MD5STEP(f, w, x, y, z, data, s) \
	( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )

/*
 * The core of the MD5 algorithm, this alters an existing MD5 hash to
 * reflect the addition of 16 longwords of new data.  MD5Update blocks
 * the data and converts bytes into longwords for this routine.
 */
void MD5Transform(uint32 buf[4], uint32 in[16])
{
    register uint32 a, b, c, d;

    a = buf[0];
    b = buf[1];
    c = buf[2];
    d = buf[3];

    MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
    MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
    MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
    MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
    MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
    MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
    MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
    MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
    MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
    MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
    MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
    MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
    MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
    MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
    MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
    MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

    MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
    MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
    MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
    MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
    MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
    MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
    MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
    MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
    MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
    MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
    MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
    MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
    MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
    MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
    MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
    MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

    MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
    MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
    MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
    MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
    MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
    MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
    MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
    MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
    MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
    MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
    MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
    MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
    MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
    MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
    MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
    MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

    MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
    MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
    MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
    MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
    MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
    MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
    MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
    MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
    MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
    MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
    MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
    MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
    MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
    MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
    MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
    MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);

    buf[0] += a;
    buf[1] += b;
    buf[2] += c;
    buf[3] += d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\inc\util.h ===
#pragma once
#ifndef UTIL_H
#define UTIL_H

#include <windows.h>

#ifndef UNICODE
#define UNICODE
#define _UNICODE
#endif

int inline MsgShow(LPCWSTR msg)
{
	return MessageBox(NULL, msg, L"Message",  MB_OK|MB_ICONINFORMATION|MB_TASKMODAL);
}

int inline MsgAskYN(LPCWSTR msg)
{
	return MessageBox(NULL, msg, L"Note!", MB_YESNO|MB_ICONQUESTION|MB_TASKMODAL);
}

// for debugging
int inline DbgMsg(LPCWSTR msg)
{
	return MessageBox(NULL, msg, L"debug message...",  MB_OK|MB_TASKMODAL);
}

//
// Return last Win32 error as an HRESULT.
//
// inline only to save having another .c file for this
inline HRESULT
GetLastWin32Error()
{
    // Win 95 can return 0, even when there's an error.
    DWORD dw = GetLastError();
    return dw ? HRESULT_FROM_WIN32(dw) : E_FAIL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\inc\version.h ===
/**
 * Version strings for Project Manifest
 * 
 * Copyright (c) 2000 Microsoft Corporation
 */

// Standard version includes

#pragma once

#include <winver.h>
#include <ntverp.h>

//
// APP Version
//
// Version numbers can be assigned in newbuild.cmd
//

#ifndef APP_VER_MAJORVERSION
#define APP_VER_MAJORVERSION 1
#endif

#ifndef APP_VER_MINORVERSION
#define APP_VER_MINORVERSION 0
#endif

#ifndef APP_VER_PRODUCTBUILD
#define APP_VER_PRODUCTBUILD 0
#endif

#ifndef APP_VER_PRODUCTBUILD_QFE
#define APP_VER_PRODUCTBUILD_QFE 0
#endif

//
// Allow a component to override values in individual rc files
// by checking if these are already defined
//
#ifndef APP_VER_PRODUCTNAME_STR
#define APP_VER_PRODUCTNAME_STR      "Microsoft (R) Application"
#endif

#ifndef APP_VER_INTERNALNAME_STR
#define APP_VER_INTERNALNAME_STR     "APP"
#endif

// the following two are defined in individual RC files:
//      APP_VER_ORIGINALFILENAME_STR
//      APP_VER_FILEDESCRIPTION_STR

//
// Don't edit the remainder of this file to change version values.
// Edit above instead.
//

#if APPBLDTYPE_FREE
#define APP_BLDTYPE_STR     "Free"
#elif APPBLDTYPE_ICECAP
#define APP_BLDTYPE_STR     "Icecap"
#elif APPBLDTYPE_RETAIL
#define APP_BLDTYPE_STR     "Retail"
#else //APPBLDTYPE_DEBUG
#define APP_BLDTYPE_STR     "Debug"
#endif

//
// undefine these values as some are defined in sdk\inc\ntverp.h
//

#ifdef VER_MAJORVERSION
#undef VER_MAJORVERSION
#endif

#ifdef VER_MINORVERSION
#undef VER_MINORVERSION
#endif

#ifdef VER_PRODUCTBUILD
#undef VER_PRODUCTBUILD
#endif

#ifdef VER_PRODUCTBUILD_QFE
#undef VER_PRODUCTBUILD_QFE
#endif

#ifdef VER_PRODUCTNAME_STR
#undef VER_PRODUCTNAME_STR
#endif

#ifdef VER_INTERNALNAME_STR
#undef VER_INTERNALNAME_STR
#endif

#ifdef VER_ORIGINALFILENAME_STR
#undef VER_ORIGINALFILENAME_STR
#endif

#ifdef VER_FILEDESCRIPTION_STR
#undef VER_FILEDESCRIPTION_STR
#endif

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif

#ifdef VER_FILEVERSION_STR
#undef VER_FILEVERSION_STR
#endif

#ifdef VER_FILEVERSION
#undef VER_FILEVERSION
#endif

#ifdef VER_FILETYPE
#undef VER_FILETYPE
#endif

#ifdef VER_FILESUBTYPE
#undef VER_FILESUBTYPE
#endif

#define VER_MAJORVERSION         APP_VER_MAJORVERSION
#define VER_MINORVERSION         APP_VER_MINORVERSION
#define VER_PRODUCTBUILD         APP_VER_PRODUCTBUILD
#define VER_PRODUCTBUILD_QFE     APP_VER_PRODUCTBUILD_QFE

#define VER_PRODUCTNAME_STR      APP_VER_PRODUCTNAME_STR
#define VER_INTERNALNAME_STR     APP_VER_INTERNALNAME_STR
#define VER_ORIGINALFILENAME_STR APP_VER_ORIGINALFILENAME_STR
#define VER_FILEDESCRIPTION_STR  APP_VER_FILEDESCRIPTION_STR

#define CONCAT5HELPER(a, b, c, d, e)      #a "." #b "." #c "." #d " " e
#define CONCAT5(a, b, c, d, e)            CONCAT5HELPER(a, b, c, d, e)

#define CONCAT5HELPER_L(a, b, c, d, e)    L ## #a L"." L ## #b L"." L ## #c L"." L ## #d L" " L ## e
#define CONCAT5_L(a, b, c, d, e)          CONCAT5HELPER_L(a, b, c, d, e)

#define VER_PRODUCTVERSION_STR   CONCAT5(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, APP_BLDTYPE_STR)
#define VER_PRODUCTVERSION_STR_L CONCAT5_L(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, APP_BLDTYPE_STR)

#define VER_PRODUCTVERSION       VER_MAJORVERSION,VER_MINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#define VER_FILEVERSION_STR      CONCAT5(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, APP_BLDTYPE_STR)
#define VER_FILEVERSION_STR_L    CONCAT5_L(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, APP_BLDTYPE_STR)

#define VER_FILEVERSION          VER_MAJORVERSION,VER_MINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          VFT2_UNKNOWN


// Standard NT build defines

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\mangen\md5.cpp ===
// this is the only way we can compile with another file in ../../dll/ ??

#include "../../dll/md5.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\mimefilt\manmime.cpp ===
//
// Copyright (c) 2001 Microsoft Corporation
//
//

#include "afilter.h"

HINSTANCE g_DllInstance = NULL;
LONG      g_cRef=0;

//----------------------------------------------------------------------------
BOOL WINAPI DllMain( HINSTANCE hInst, DWORD dwReason, LPVOID pvReserved )
{
    HRESULT hr = S_OK;
    BOOL    ret = TRUE;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        // remember the instance
        g_DllInstance = hInst;
        DisableThreadLibraryCalls(hInst);
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

//exit:
    return ret;
}

//----------------------------------------------------------------------------

STDAPI DllRegisterServer(void)
{
   return S_OK;
}


STDAPI DllUnregisterServer(void)
{
    return S_OK;
}


// ----------------------------------------------------------------------------
// DllAddRef
// ----------------------------------------------------------------------------
ULONG DllAddRef(void)
{
    return (ULONG)InterlockedIncrement(&g_cRef);
}

// ----------------------------------------------------------------------------
// DllRelease
// ----------------------------------------------------------------------------
ULONG DllRelease(void)
{
    return (ULONG)InterlockedDecrement(&g_cRef);
}

// ----------------------------------------------------------------------------

STDAPI
DllCanUnloadNow()
{
    return g_cRef > 0 ? S_FALSE : S_OK;
}

// ----------------------------------------------------------------------------

HRESULT 
GetAppMimeFilterClassObject(REFIID iid, void** ppv)
{
    HRESULT hr = S_OK;

	hr = E_OUTOFMEMORY;
	CAppMimeFilterClassFactory *pAppMimeFilterClassFactory = new CAppMimeFilterClassFactory();//rclsid); 
	if (pAppMimeFilterClassFactory != NULL)
	{
	    hr = pAppMimeFilterClassFactory->QueryInterface(iid, ppv); 
	    pAppMimeFilterClassFactory->Release(); 
	}

    return hr;
}

// ----------------------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID *ppv)
{
    HRESULT hr = S_OK;

    if (clsid == CLSID_AppMimeFilter)
    {
        hr = GetAppMimeFilterClassObject(iid, ppv);
    }
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\shortcut\appdll.cpp ===
//
// Copyright (c) 2001 Microsoft Corporation
//
//

#include "appshcut.h"

HINSTANCE g_DllInstance = NULL;
LONG      g_cRef=0;

//----------------------------------------------------------------------------

BOOL WINAPI DllMain( HINSTANCE hInst, DWORD dwReason, LPVOID pvReserved )
{
    BOOL    ret = TRUE;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        // remember the instance
        g_DllInstance = hInst;
        DisableThreadLibraryCalls(hInst);
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return ret;
}

//----------------------------------------------------------------------------

STDAPI DllRegisterServer(void)
{
	// BUGBUG: should implement the registerserver
	return S_OK;
}


STDAPI DllUnregisterServer(void)
{
	// BUGBUG: should implement the unregisterserver
	return S_OK;
}


// ----------------------------------------------------------------------------
// DllAddRef
// ----------------------------------------------------------------------------

ULONG DllAddRef(void)
{
    return (ULONG)InterlockedIncrement(&g_cRef);
}

// ----------------------------------------------------------------------------
// DllRelease
// ----------------------------------------------------------------------------

ULONG DllRelease(void)
{
    return (ULONG)InterlockedDecrement(&g_cRef);
}

// ----------------------------------------------------------------------------

STDAPI
DllCanUnloadNow()
{
    return g_cRef > 0 ? S_FALSE : S_OK;
}

// ----------------------------------------------------------------------------

HRESULT 
GetAppShortcutClassObject(REFIID iid, void** ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

	CAppShortcutClassFactory *pAppShortcutClassFactory = new CAppShortcutClassFactory();
	if (pAppShortcutClassFactory != NULL)
	{
	    hr = pAppShortcutClassFactory->QueryInterface(iid, ppv); 
	    pAppShortcutClassFactory->Release(); 
	}

    return hr;
}

// ----------------------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID *ppv)
{
    HRESULT hr = S_OK;

    if (clsid == CLSID_AppShortcut)
    {
        hr = GetAppShortcutClassObject(iid, ppv);
    }
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\mimefilt\afilter.cpp ===
//
// Copyright (c) 2001 Microsoft Corporation
//
//

#include "util.h"
#include "afilter.h"
#include <stdio.h> // for _snwprintf

// {2B3C580C-9BE6-44c5-9BB5-558F7EEF58E2}
static const GUID CLSID_AppMimeFilter = 
{ 0x2b3c580c, 0x9be6, 0x44c5, { 0x9b, 0xb5, 0x55, 0x8f, 0x7e, 0xef, 0x58, 0xe2 } };

extern ULONG DllAddRef(void);
extern ULONG DllRelease(void);

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

CAppMimeFilterClassFactory::CAppMimeFilterClassFactory()
{
	_cRef = 1;
}

// ----------------------------------------------------------------------------

HRESULT
CAppMimeFilterClassFactory::QueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IClassFactory)
    {
        *ppv = (IClassFactory *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

// ----------------------------------------------------------------------------

ULONG
CAppMimeFilterClassFactory::AddRef()
{
    return (ULONG) InterlockedIncrement(&_cRef); //DllAddRef(); 
}

ULONG
CAppMimeFilterClassFactory::Release()
{
	LONG ulCount = InterlockedDecrement(&_cRef); //DllRelease();

	if (ulCount <= 0)
	{
		delete this;
		//DllRelease();
	}

    return (ULONG) ulCount;
}

HRESULT
CAppMimeFilterClassFactory::LockServer(BOOL lock)
{
    return (lock ? 
            DllAddRef() : //InterlockedIncrement(&g_PtpObjectCount) : 
            DllRelease()); //InterlockedDecrement(&g_PtpObjectCount));
}

// ----------------------------------------------------------------------------

HRESULT
CAppMimeFilterClassFactory::CreateInstance(IUnknown* pUnkOuter, REFIID iid, void** ppv)
{
    HRESULT hr = S_OK;
    CAppMimeFilter *pAppMimeFilter = NULL;

    if (pUnkOuter && iid != IID_IUnknown)
    {
    	hr = E_INVALIDARG;
    	goto exit;
    }

    pAppMimeFilter = new CAppMimeFilter();
    if (pAppMimeFilter == NULL)
    {
    	hr = E_OUTOFMEMORY;
    	goto exit;
    }

    if (iid == IID_IUnknown)
    {
        *ppv = (IInternetProtocol *)pAppMimeFilter;
        pAppMimeFilter->AddRef();
    }
    else
    {
        hr = pAppMimeFilter->QueryInterface(iid, ppv);
        if (FAILED(hr))
        	goto exit;
    }

exit:
    if (pAppMimeFilter)
        pAppMimeFilter->Release();

    return hr;
}

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

#define BUFFER_READ_SIZE 2048
static BYTE g_buffer[BUFFER_READ_SIZE + sizeof(WCHAR)];

// ----------------------------------------------------------------------------
// CAppMimeFilter

CAppMimeFilter::CAppMimeFilter()
{
	_cRef = 1;
	_fFirstRead = TRUE;
	_fReadDone = FALSE;
	_pOutgoingProtSink = NULL;
	_pIncomingProt = NULL;
	_grfSTI = 0;

	_wzUrl[0] = L'\0';
	_wzTempFile[0] = L'\0';
	_hFile = 0; //INVALID_HANDLE_VALUE;
}

CAppMimeFilter::~CAppMimeFilter()
{
	if (_pIncomingProt)
	{
		_pIncomingProt->Release();
		_pIncomingProt = NULL;
	}

	if (_pOutgoingProtSink)
	{
		_pOutgoingProtSink->Release();
		_pOutgoingProtSink = NULL;
	}

	CloseTempFile();	// ignore return value
}

// ----------------------------------------------------------------------------

HRESULT
CAppMimeFilter::QueryInterface(REFIID iid,  void** ppv)
{
    *ppv = NULL;

    if (iid == IID_IInternetProtocol ||
        iid == IID_IInternetProtocolRoot ||
        iid == IID_IUnknown)
    {
        *ppv = (IInternetProtocol *)this;
    }
    else if (iid == IID_IInternetProtocolSink)
    {
        *ppv = (IInternetProtocolSink *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

// ----------------------------------------------------------------------------

ULONG
CAppMimeFilter::AddRef()
{
    return (ULONG) InterlockedIncrement(&_cRef);
}

ULONG
CAppMimeFilter::Release()
{
	LONG ulCount = InterlockedDecrement(&_cRef);

	if (ulCount <= 0)
	{
		delete this;
	}

    return (ULONG) ulCount;
}

// ----------------------------------------------------------------------------
// IInternetProtocol interface

HRESULT
CAppMimeFilter::Start(
        LPCWSTR wzUrl,
        IInternetProtocolSink *pIProtSink,
        IInternetBindInfo *pIBindInfo,
        DWORD grfSTI,
        DWORD dwReserved)
{
	HRESULT hr = E_FAIL;
	_grfSTI      = grfSTI;

	if (!(grfSTI & PI_FILTER_MODE))
    {
        hr = E_INVALIDARG;
    }
    else
    {
    	WCHAR* string[1];
    	ULONG ulCount = 0;

    	string[0] = NULL;
		// copy the URL
		// wzUrl is the mime Content Type for plug mime filter
		// so have to get the real url this way
    	if (FAILED(hr=pIBindInfo->GetBindString(BINDSTRING_URL, string, 1, &ulCount)))
    		goto exit;

		if (wcslen(string[0]) + 1 > MAX_URL_LENGTH)
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        wcscpy(_wzUrl, string[0]);

		// get the protocol pointer from reserved pointer
        PROTOCOLFILTERDATA* ProtFiltData = (PROTOCOLFILTERDATA*) dwReserved;
		if (NULL != _pIncomingProt)
		{
			hr = E_UNEXPECTED;
			goto exit;
		}
		
		if (NULL == ProtFiltData->pProtocol)
		{
			// !! We can't do anything without an interface to read from
			hr = E_INVALIDARG;
			goto exit;
		}

        _pIncomingProt = ProtFiltData->pProtocol;
        _pIncomingProt->AddRef();

        // hold onto the sink as well
		if (NULL != _pOutgoingProtSink)
		{
			hr = E_UNEXPECTED;
			goto exit;
		}

        _pOutgoingProtSink = pIProtSink;
        _pOutgoingProtSink->AddRef();

		_fFirstRead = TRUE;

        hr = S_OK;
    }

exit:
	return hr;
}

HRESULT
CAppMimeFilter::Continue(PROTOCOLDATA *pProtData)
{
	if (NULL == _pIncomingProt)
		return E_UNEXPECTED;

	return _pIncomingProt->Continue(pProtData);
}

HRESULT
CAppMimeFilter::Abort(HRESULT hrReason,DWORD dwOptions)
{
	if (NULL == _pIncomingProt)
		return E_UNEXPECTED;

	return _pIncomingProt->Abort(hrReason, dwOptions);
}

HRESULT
CAppMimeFilter::Terminate(DWORD dwOptions)
{
	HRESULT hr = S_OK;

	// Release the sink
	if (_pOutgoingProtSink)
		_pOutgoingProtSink->Release();

	if (NULL == _pIncomingProt)
		return E_UNEXPECTED;

	hr = _pIncomingProt->Terminate(dwOptions);

	return hr;
}

HRESULT
CAppMimeFilter::Suspend()
{
	if (NULL == _pIncomingProt)
		return E_UNEXPECTED;

	return _pIncomingProt->Suspend();
}

HRESULT
CAppMimeFilter::Resume()
{
	if (NULL == _pIncomingProt)
		return E_UNEXPECTED;

	return _pIncomingProt->Resume();
}

HRESULT
CAppMimeFilter::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
	HRESULT hr = S_OK;
	HRESULT hrFromProt;

	BYTE* pbuff = g_buffer;
	ULONG cbReadFromProt;
	DWORD cbWritten = 0;

	// retrieve requested amount of data from protocol handler
	hrFromProt = _pIncomingProt->Read((void*)pbuff, BUFFER_READ_SIZE, &cbReadFromProt);
	if (E_PENDING != hrFromProt) // may have some extra data in our buffer, so continue
	{
		if (FAILED(hrFromProt))
			return hrFromProt;
		else 
		{
			// write data to a temp file
			if (cbReadFromProt > 0)
			{
				if (_fFirstRead)
				{
					if (FAILED(hr=OpenTempFile()))
						goto exit;

					_fFirstRead = FALSE;
				}
		        if ( !WriteFile(_hFile, pbuff, cbReadFromProt, &cbWritten, NULL) || 
		             cbWritten != cbReadFromProt )
		        {
		            hr = GetLastWin32Error();
		            goto exit;
		        }
			}
			
			// prot handler will let us know when there is no more data left
			if (S_FALSE == hrFromProt)
			{
				// Read() can be called multiple times after it is done (and Prot Handler will return S_FALSE)
				// this ensure the followings are called once only
				if (!_fReadDone)
				{
				    STARTUPINFO si;
				    PROCESS_INFORMATION pi;
				    WCHAR wzCmdLine[MAX_PATH];

					if (FAILED(hr=CloseTempFile()))
						goto exit;

			        if (_snwprintf(wzCmdLine, sizeof(wzCmdLine),
								L"manhost.exe \"%s\" \"%s\"", _wzUrl, _wzTempFile) < 0)
			        {
						hr = CO_E_PATHTOOLONG;
						goto exit;
					}

				    ZeroMemory(&si, sizeof(si));
				    ZeroMemory(&pi, sizeof(pi));
				    si.cb = sizeof(si);

					// see note on wmain() in manhost.cpp
				    if(!CreateProcess(NULL, wzCmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
				    {
				        hr = GetLastWin32Error();
				    }

				    if(pi.hThread) CloseHandle(pi.hThread);
				    if(pi.hProcess) CloseHandle(pi.hProcess);

					_fReadDone = TRUE;

					// note: this few lines must follow the CreateProcess
					if (FAILED(hr))
						goto exit;
				}
			}
		}
	}

    // switch the MIME type here. BUGBUG? why?
	_pOutgoingProtSink->ReportProgress(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, CONTENT_TYPE);

exit:
	return hr;
}

HRESULT
CAppMimeFilter::Seek(
        LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER *plibNewPosition)
{
	return E_NOTIMPL;
}

HRESULT
CAppMimeFilter::LockRequest(DWORD dwOptions)
{
	return S_OK;
}

HRESULT
CAppMimeFilter::UnlockRequest()
{
	return S_OK;
}

// ----------------------------------------------------------------------------
// IInternetProtocolSink interface
HRESULT
CAppMimeFilter::Switch(PROTOCOLDATA __RPC_FAR *pProtocolData)
{
	if (NULL == _pOutgoingProtSink)
		return E_UNEXPECTED;

	return _pOutgoingProtSink->Switch(pProtocolData);
}

HRESULT
CAppMimeFilter::ReportProgress(ULONG ulStatusCode, LPCWSTR szStatusText)
{
	if (NULL == _pOutgoingProtSink)
		return E_UNEXPECTED;

	return _pOutgoingProtSink->ReportProgress(ulStatusCode, szStatusText);
}

HRESULT
CAppMimeFilter::ReportData(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax)
{
	if (NULL == _pOutgoingProtSink)
		return E_UNEXPECTED;

	return _pOutgoingProtSink->ReportData(grfBSCF, ulProgress, ulProgressMax);
}

HRESULT
CAppMimeFilter::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR szResult)
{
	if (NULL == _pOutgoingProtSink)
		return E_UNEXPECTED;

	return _pOutgoingProtSink->ReportResult(hrResult, dwError, szResult);
}

// ----------------------------------------------------------------------------

HRESULT
CAppMimeFilter::OpenTempFile()
{
	HRESULT hr = S_OK;
    HANDLE hTempFile;

    static WCHAR wzTempPath[MAX_PATH+32] = {0};

    if (!wzTempPath[0])
    {
        if (GetTempPath(MAX_PATH, wzTempPath) == 0)
        {
        	hr = GetLastWin32Error();
        	goto exit;
        }
    }

	if (_wzTempFile[0] == L'\0')
	{
	    if (GetTempFileName(wzTempPath, L"ASF", 0, _wzTempFile))	// app shortcut file
	    {
	        // the file should be deleted afterwards
	        DWORD dwFileAtr = FILE_ATTRIBUTE_TEMPORARY;

			// see note in processurl() in manhost.cpp
	        hTempFile = CreateFile(_wzTempFile, GENERIC_WRITE,FILE_SHARE_READ, NULL,CREATE_ALWAYS,dwFileAtr, NULL);
	        if (hTempFile == INVALID_HANDLE_VALUE)
	        {
	            _hFile = 0;
	            hr = GetLastWin32Error();
	            goto exit;
	        }
	        else
	        {
	            _pOutgoingProtSink->ReportProgress(BINDSTATUS_CACHEFILENAMEAVAILABLE, _wzTempFile);
	            _hFile = hTempFile;
	        }
	    }
	}

exit:
    return hr;
}

HRESULT
CAppMimeFilter::CloseTempFile()
{
    HRESULT hr = E_FAIL;

    if (_hFile)
    {
        CloseHandle(_hFile);
        _hFile = 0;
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\mangen\mangen.cpp ===
#include <shlwapi.h>
#include <stdio.h> // for _snprintf
#include "md5.h"
#include "dll.h" // for HASHLENGTH 32; HASHSTRINGLENGTH	HASHLENGTH+1

#ifdef _UNICODE
#error this program should not be compiled with UNICODE
#endif // _UNICODE
#ifdef _MBCS
#error this program should not be compiled with MBCS
#endif // _MBCS

// Note: this is not really a WCHAR/Unicode/UTF implementation!

// ???? UTF-8?
// BUGBUG: Files are never saved as UTF-8 encoding and format
const char szHeader1[] = { "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n<application xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">\r\n<description>" };
const char szHeader2[] = { "</description>\r\n<applicationIdentity \r\n" };
const char szEndheader[] = { "\r\n/> \r\n<application>\r\n" };
const char szFileprefix[] = { "\t<file name=\""};
const char szHashprefix[] = { "\"\r\n\t\t  hash=\"" };
const char szHashpostfix[] = { "\" />\r\n" };
const char szEndfile[] = { "\t</file>\r\n</application>" };

const char szDefaultdescription[] = { "Description of the app goes here" };

//assume not unicode file, use ReadFile()  then cast it as char[]

/////////////////////////////////////////////////////////////////////////////////////////////////

void getHash(const char* szFilename, char* szHash)
{
	HANDLE hFile;
	DWORD dwLength;

    unsigned char buffer[16384], signature[HASHLENGTH/2];
    struct MD5Context md5c;
	int i;
    char* p;

	// minimal error checking here...
	if (szHash == NULL)
		goto exit;

	szHash[0] = '\0';
		
    MD5Init(&md5c);

    hFile = CreateFile(szFilename, GENERIC_READ, 0, NULL, 
                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if(hFile == INVALID_HANDLE_VALUE)
    {
//            hr = GetLastWin32Error();
    	printf("Open file error during hashing\n");
        goto exit;
    }

    ZeroMemory(buffer, sizeof(buffer));

    while ( ReadFile (hFile, buffer, sizeof(buffer), &dwLength, NULL) && dwLength )
    {
	    MD5Update(&md5c, buffer, (unsigned) dwLength);
    }
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

	// note: the next few lines should follow the previous ReadFile()
    if (dwLength != 0)
    {
    	printf("Read error during hashing\n");
    	goto exit;
    }

    MD5Final(signature, &md5c);

    // convert hash from byte array to hex
    p = szHash;
	for (int i = 0; i < sizeof(signature); i++)
	{
	    // BUGBUG?: format string 0 does not work w/ X according to MSDN? why is this working?
        sprintf(p, "%02X", signature[i]);
        p += 2;
	}

exit:
   if (hFile != INVALID_HANDLE_VALUE)
       CloseHandle(hFile);
   hFile = INVALID_HANDLE_VALUE;
   
   return;
}

/////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT write(HANDLE hFile, const char* string)
{
	HRESULT hr = S_OK;
	DWORD dwLength = strlen(string);  //????
	DWORD dwWritten = 0;
	
    if ( !WriteFile(hFile, string, dwLength, &dwWritten, NULL) || dwWritten != dwLength)
    {
    	printf("Manifest file write error\n");
        hr = E_FAIL;
    }

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// szPath is the path and name of the directory w/o the last '\'
// szPath, szPathFromAppRoot will be used/modified during runs
HRESULT doFiles(HANDLE hFile, char* szPath, char* szPathFromAppRoot)
{
// find all files, in all sub dir, get hash, output

	HRESULT hr = S_OK;
	char szSearchPath[MAX_PATH];
	HANDLE hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA fdFile;
	DWORD dwLastError = 0;
	BOOL fNeedSetCurrentDir = TRUE;

	// this has trailing "\*"
    if (_snprintf(szSearchPath, MAX_PATH, "%s\\*", szPath) < 0)
    {
    	hr = CO_E_PATHTOOLONG;
		printf("Error: Search path too long\n");
    	goto exit;
    }

	hFind = FindFirstFile(szSearchPath, &fdFile);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		hr = E_FAIL; //GetLastWin32Error();
		printf("Find file error\n");
		goto exit;
	}

	while (dwLastError != ERROR_NO_MORE_FILES)
	{
		// ignore "." and ".."
		if (strcmp(fdFile.cFileName, ".") != 0 && strcmp(fdFile.cFileName, "..") != 0)
		{
			if ((fdFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
			{
				// recurse into dirs
				char* p = NULL;

				if (!PathAppend(szPath, fdFile.cFileName))
				{
					hr = E_FAIL;
					printf("Path append error\n");
					goto exit;
				}

				if (szPathFromAppRoot[0] == '\0')
					strncpy(szPathFromAppRoot, fdFile.cFileName, MAX_PATH-1);
				else if (!PathAppend(szPathFromAppRoot, fdFile.cFileName))
				{
					hr = E_FAIL;
					printf("Path append error\n");
					goto exit;
				}

				if (FAILED(hr=doFiles(hFile, szPath, szPathFromAppRoot)))
					goto exit;

				p = PathFindFileName(szPath);
				if (p <= szPath)
				{
					// this should not happen!
					hr = E_FAIL;
					printf("Path error\n");
					goto exit;
				}
				*(p-1) = '\0';

				p = PathFindFileName(szPathFromAppRoot);
				if (p <= szPathFromAppRoot)
				{
					szPathFromAppRoot[0] = '\0';
				}
				else
					*(p-1) = '\0';

				fNeedSetCurrentDir = TRUE;
			}
			else
			{
				char szHash[HASHSTRINGLENGTH];

				if (fNeedSetCurrentDir)
				{
					if (!SetCurrentDirectory(szPath))
					{
						hr = E_FAIL; //GetLastWin32Error();
						printf("Set current directory error\n");
						goto exit;
					}
						
					fNeedSetCurrentDir = FALSE;
				}

				// get hash from that file in the current dir
				getHash(fdFile.cFileName, szHash);

				// write into the manifest file
				if (FAILED(write(hFile, szFileprefix)))
					goto exit;

				// path to the file from app root
				if (szPathFromAppRoot[0] != '\0')
				{
					if (FAILED(write(hFile, szPathFromAppRoot)))
						goto exit;
					if (FAILED(write(hFile, "\\")))
						goto exit;
				}

				if (FAILED(write(hFile, fdFile.cFileName)))
					goto exit;

				if (FAILED(write(hFile, szHashprefix)))
					goto exit;

				if (FAILED(write(hFile, szHash)))
					goto exit;

				if (FAILED(write(hFile, szHashpostfix)))
					goto exit;
			}
		}

		if (!FindNextFile(hFind, &fdFile))
		{
			dwLastError = GetLastError();
			continue;
		}
	}

exit:
	if (hFind != INVALID_HANDLE_VALUE)
	{
		if (!FindClose(hFind))
		{
			hr = E_FAIL; //GetLastWin32Error();
			printf("Find handle close error\n");
		}
	}

	return hr;

}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

int __cdecl main( int argc, char *argv[ ], char *envp[ ] )
{
    HANDLE hFile, hFImport;
    DWORD dwRead, dwWritten, dwAttrib;
	unsigned char buffer[256]; //1024];
	char* pszExt = NULL;
	char szManifestName[MAX_PATH];
	char szAppDir[MAX_PATH];
	char szPathFromAppDir[MAX_PATH]; // relative from app dir - temp use only
	// ???? need to check path are current and sub dir of current ??? or not? - see known issues

	szPathFromAppDir[0] = '\0';
	if (argc < 4)
	{
		printf("mangen usage-\n\t mangen manifest_name app_name_import_file app_dir [description]\n");
		goto exit;
	}

	if (PathIsRelative(argv[3]))
	{
		// findfirstfile findnextfile will not work if path is relative...?
		printf("Error: App dir should not be relative\n");
		goto exit;
	}

	if (!PathCanonicalize(szAppDir, argv[3]))
	{
		printf("App dir canonicalize error\n");
		goto exit;
	}

	dwAttrib = GetFileAttributes(szAppDir);
	if (!PathFileExists(argv[2]) || dwAttrib == (DWORD)-1 || (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) == 0)
	{
		printf("Error: Invalid arguments\n");
		goto exit;
	}

	pszExt = PathFindExtension(argv[1]);
	if (strcmp(pszExt, ".manifest") != 0)
	{
	    if (_snprintf(szManifestName, MAX_PATH, "%s.manifest", argv[1]) < 0)
	    {
	    	printf("Invalid manifest name/extension, error adding extension\n");
	    	goto exit;
		}
	}
	else
		strcpy(szManifestName, argv[1]);

	if (PathFileExists(szManifestName))
	{
		int ch = 0;
		
    	printf("Manifest file exists! Overwrite(y/N)?");
    	ch = getwchar();
    	if (ch != 'Y' && ch != 'y')
    		goto exit;

    	printf("\n");
	}

	// always overwrite...
    hFile = CreateFile(szManifestName, GENERIC_WRITE, 0, NULL, 
			CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    // Failed to open the disk file
    if(hFile == INVALID_HANDLE_VALUE)
    {
    	printf("Manifest file open error\n");
    	goto exit;
    }

	if (FAILED(write(hFile, szHeader1)))
		goto exit;

	if (argc >= 5)
	{
		if (FAILED(write(hFile, argv[4])))
			goto exit;
	}
	else
	{
		if (FAILED(write(hFile, szDefaultdescription)))
			goto exit;
	}

	if (FAILED(write(hFile, szHeader2)))
		goto exit;

    hFImport= CreateFile(argv[2], GENERIC_READ, 0, NULL, 
			OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    // Failed to open the disk file
    if(hFImport == INVALID_HANDLE_VALUE)
    {
    	printf("Import file open error\n");
    	goto exit;
    }

    while(ReadFile(hFImport, buffer, sizeof(buffer), &dwRead, NULL) && dwRead != 0)
    {
        // Write bytes to the disk file
        if ( !WriteFile(hFile, buffer, dwRead, &dwWritten, NULL) || dwWritten != dwRead)
        {
	    	printf("Manifest file write error during import\n");
            goto exit;
        }
    }

	// note: the next few lines should follow the previous ReadFile()
	if (dwRead != 0)
    {
    	printf("Read error during import\n");
    	goto exit;
    }

	if (FAILED(write(hFile, szEndheader)))
		goto exit;

	if (FAILED(doFiles(hFile, szAppDir, szPathFromAppDir)))
		goto exit;

	if (FAILED(write(hFile, szEndfile)))
		goto exit;

	printf("* Manifest generated successfully *\n");

exit:
    if (hFImport != INVALID_HANDLE_VALUE)
        CloseHandle(hFImport);
    hFImport = INVALID_HANDLE_VALUE;

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\shortcut\appshcut.cpp ===
//
// Copyright (c) 2001 Microsoft Corporation
//
//

#include "appshcut.h"

// {b95ec110-5c3e-433c-b969-701c10521ef2}
static const GUID CLSID_AppShortcut = 
{ 0xb95ec110, 0x5c3e, 0x433c, { 0xb9, 0x69, 0x70, 0x1c, 0x10, 0x52, 0x1e, 0xf2 } };

extern ULONG DllAddRef(void);
extern ULONG DllRelease(void);

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

CAppShortcutClassFactory::CAppShortcutClassFactory()
{
	_cRef = 1;
}

// ----------------------------------------------------------------------------

HRESULT
CAppShortcutClassFactory::QueryInterface(REFIID iid, void **ppv)
{
	HRESULT hr = S_OK;

    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IClassFactory)
    {
        *ppv = (IClassFactory *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    ((IUnknown *)*ppv)->AddRef();

exit:
    return hr;
}

// ----------------------------------------------------------------------------

ULONG
CAppShortcutClassFactory::AddRef()
{
    return (ULONG) InterlockedIncrement(&_cRef);
}

ULONG
CAppShortcutClassFactory::Release()
{
	LONG ulCount = InterlockedDecrement(&_cRef);

	if (ulCount <= 0)
	{
		delete this;
	}

    return (ULONG) ulCount;
}

HRESULT
CAppShortcutClassFactory::LockServer(BOOL lock)
{
    return (lock ? 
            DllAddRef() :
            DllRelease());
}

// ----------------------------------------------------------------------------

HRESULT
CAppShortcutClassFactory::CreateInstance(IUnknown* pUnkOuter, REFIID iid, void** ppv)
{
    HRESULT hr = S_OK;
    CAppShortcut *pAppShortcut = NULL;

	*ppv = NULL;

    if (pUnkOuter && iid != IID_IUnknown)
    {
    	hr = CLASS_E_NOAGGREGATION;
    	goto exit;
    }

    pAppShortcut = new CAppShortcut();
    if (pAppShortcut == NULL)
    {
    	hr = E_OUTOFMEMORY;
    	goto exit;
    }

    if (iid == IID_IUnknown)
    {
        *ppv = (IShellLink *)pAppShortcut;
        pAppShortcut->AddRef();
    }
    else
    {
        hr = pAppShortcut->QueryInterface(iid, ppv);
        if (FAILED(hr))
        	goto exit;
    }

exit:
    if (pAppShortcut)
        pAppShortcut->Release();

    return hr;
}

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

CAppShortcut::CAppShortcut()
	: RefCount()
{
	// Don't validate this until after construction.

	m_dwFlags = APPSHCUT_FL_NOTDIRTY;
	m_pwzShortcutFile = NULL;
	m_pwzPath = NULL;
	m_pwzDesc = NULL;
	m_pwzIconFile = NULL;
	m_niIcon = 0;
	m_pwzWorkingDirectory = NULL;
	m_nShowCmd = DEFAULTSHOWCMD;
	m_wHotkey = 0;

	m_pappRefInfo = NULL;

	return;
}

CAppShortcut::~CAppShortcut(void)
{
	if (m_pwzShortcutFile)
	{
		delete m_pwzShortcutFile;
		m_pwzShortcutFile = NULL;
	}

	if (m_pwzPath)
	{
		delete m_pwzPath;
		m_pwzPath = NULL;
	}

	if (m_pwzDesc)
	{
		delete m_pwzDesc;
		m_pwzDesc = NULL;
	}

	if (m_pwzIconFile)
	{
		delete m_pwzIconFile;
		m_pwzIconFile = NULL;
		m_niIcon = 0;
	}

	if (m_pwzWorkingDirectory)
	{
		delete m_pwzWorkingDirectory;
		m_pwzWorkingDirectory = NULL;
	}

	if (m_pappRefInfo)
	{
		delete m_pappRefInfo;
		m_pappRefInfo = NULL;
	}

	RefCount::~RefCount();

	return;
}


ULONG STDMETHODCALLTYPE CAppShortcut::AddRef(void)
{
	ULONG ulcRef;

	ulcRef = RefCount::AddRef();

	return(ulcRef);
}


ULONG STDMETHODCALLTYPE CAppShortcut::Release(void)
{
	ULONG ulcRef;

	ulcRef = RefCount::Release();

	return(ulcRef);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::QueryInterface(REFIID riid,
                                                           PVOID *ppvObject)
{
	HRESULT hr = S_OK;

	if (riid == IID_IExtractIcon)
	{
	  *ppvObject = (IExtractIcon*)this;
	}
	else if (riid == IID_IPersist)
	{
	  *ppvObject = (IPersist*)(IPersistFile*)this;
	}
	else if (riid == IID_IPersistFile)
	{
	  *ppvObject = (IPersistFile*)this;
	}
	else if (riid == IID_IShellExtInit)
	{
	  *ppvObject = (IShellExtInit*)this;
	}
	else if (riid == IID_IShellLink)
	{
	  *ppvObject = (IShellLink*)this;
	}
	else if (riid == IID_IShellPropSheetExt)
	{
	  *ppvObject = (IShellPropSheetExt*)this;
	}
	else if (riid == IID_IQueryInfo)
	{
	  *ppvObject = (IQueryInfo*)this;
	}
	else if (riid == IID_IUnknown)
	{
	  *ppvObject = (IUnknown*)(IShellLink*)this;
	}
	else
	{
	  *ppvObject = NULL;
	  hr = E_NOINTERFACE;
	}

	if (hr == S_OK)
	  AddRef();

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\shortcut\appshcut.h ===
#pragma once
#ifndef _APPSHCUT_DLL_H
#define _APPSHCUT_DLL_H

#include <objbase.h>
#include <windows.h>

#include <shlobj.h>
#include "refcount.hpp"

// AppShortcut flags

typedef enum _appshcutflags
{
	APPSHCUT_FL_NOTDIRTY	= 0x0000,
	APPSHCUT_FL_DIRTY		= 0x0001,

	ALL_APPSHCUT_FLAGS   //= APPSHCUT_FL_DIRTY
}
APPSHCUTFLAGS;

#define APPTYPE_UNDEF			0
#define APPTYPE_NETASSEMBLY		1	// .NetAssembly
#define APPTYPE_WIN32EXE		2	// Win32Executable

#define DEFAULTSHOWCMD			SW_NORMAL


// BUGBUG?: revise length restrictions

#define DISPLAYNAMESTRINGLENGTH		26
#define NAMESTRINGLENGTH			26
#define VERSIONSTRINGLENGTH			16	// 10.10.1234.1234
#define CULTURESTRINGLENGTH			3	// en
#define PKTSTRINGLENGTH				17
#define TYPESTRINGLENGTH			20

#define MAX_URL_LENGTH				2084 // same as INTERNET_MAX_URL_LENGTH+1 from wininet.h


struct APPREFINFO
{
	// app ref/name
	WCHAR			_wzDisplayName[DISPLAYNAMESTRINGLENGTH];
	WCHAR			_wzName[NAMESTRINGLENGTH];
	WCHAR			_wzVersion[VERSIONSTRINGLENGTH];
	WCHAR			_wzCulture[CULTURESTRINGLENGTH];
	WCHAR			_wzPKT[PKTSTRINGLENGTH];

	// app info
	// this is slightly different from APPNAME in dll.h of the manifest.dll project!
	WCHAR			_wzEntryFileName[MAX_PATH];	// used in parsing only
	WCHAR			_wzCodebase[MAX_URL_LENGTH];
	int				_fAppType;

	// shortcut specific stuff, used in parsing only
	WCHAR			_pwzIconFile[MAX_URL_LENGTH]; //??? MAX_PATH
	int				_niIcon;
	int				_nShowCmd;
	WORD			_wHotkey;
};


// Clases and interfaces

class CAppShortcutClassFactory : public IClassFactory
{
public:
	CAppShortcutClassFactory		();

	// IUnknown Methods
	STDMETHOD_    (ULONG, AddRef)	();
	STDMETHOD_    (ULONG, Release)	();
	STDMETHOD     (QueryInterface)	(REFIID, void **);

	// IClassFactory Moethods
	STDMETHOD     (LockServer)		(BOOL);
	STDMETHOD     (CreateInstance)	(IUnknown*,REFIID,void**);

protected:
	long			_cRef;
};

// AppShortcut Shell extension

class CAppShortcut : public RefCount,
					public IExtractIcon,
					public IPersistFile,
					public IShellExtInit,
					public IShellLink,
					public IShellPropSheetExt,
					public IQueryInfo
{
public:
	CAppShortcut(void);
	~CAppShortcut(void);

	// IUnknown methods

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
	ULONG   STDMETHODCALLTYPE AddRef(void);
	ULONG   STDMETHODCALLTYPE Release(void);

	// IExtractIcon methods

	HRESULT STDMETHODCALLTYPE GetIconLocation(UINT uFlags, LPWSTR pwzIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags);
	HRESULT STDMETHODCALLTYPE Extract(LPCWSTR pcwzFile, UINT uIconIndex, HICON* phiconLarge, HICON* phiconSmall, UINT ucIconSize);

	// IPersist method

	HRESULT STDMETHODCALLTYPE GetClassID(CLSID* pclsid);

	// IPersistFile methods

	HRESULT STDMETHODCALLTYPE IsDirty(void);
	HRESULT STDMETHODCALLTYPE Save(LPCOLESTR pcwszFileName, BOOL bRemember);
	HRESULT STDMETHODCALLTYPE SaveCompleted(LPCOLESTR pcwszFileName);
	HRESULT STDMETHODCALLTYPE Load(LPCOLESTR pcwszFileName, DWORD dwMode);
	HRESULT STDMETHODCALLTYPE GetCurFile(LPOLESTR *ppwszFileName);

	// IShellExtInit method

	HRESULT STDMETHODCALLTYPE Initialize(LPCITEMIDLIST pcidlFolder, IDataObject* pidobj, HKEY hkeyProgID);

	// IShellLink methods

	HRESULT STDMETHODCALLTYPE SetPath(LPCWSTR pcwzPath);
	HRESULT STDMETHODCALLTYPE GetPath(LPWSTR pwzFile, int ncFileBufLen, PWIN32_FIND_DATA pwfd, DWORD dwFlags);
	HRESULT STDMETHODCALLTYPE SetRelativePath(LPCWSTR pcwzRelativePath, DWORD dwReserved);
	HRESULT STDMETHODCALLTYPE SetIDList(LPCITEMIDLIST pcidl);
	HRESULT STDMETHODCALLTYPE GetIDList(LPITEMIDLIST *ppidl);
	HRESULT STDMETHODCALLTYPE SetDescription(LPCWSTR pcwzDescription);
	HRESULT STDMETHODCALLTYPE GetDescription(LPWSTR pwzDescription, int ncDesciptionBufLen);
	HRESULT STDMETHODCALLTYPE SetArguments(LPCWSTR pcwzArgs);
	HRESULT STDMETHODCALLTYPE GetArguments(LPWSTR pwzArgs, int ncArgsBufLen);
	HRESULT STDMETHODCALLTYPE SetWorkingDirectory(LPCWSTR pcwzWorkingDirectory);
	HRESULT STDMETHODCALLTYPE GetWorkingDirectory(LPWSTR pwzWorkingDirectory, int ncbLen);
	HRESULT STDMETHODCALLTYPE SetHotkey(WORD wHotkey);
	HRESULT STDMETHODCALLTYPE GetHotkey(PWORD pwHotkey);
	HRESULT STDMETHODCALLTYPE SetShowCmd(int nShowCmd);
	HRESULT STDMETHODCALLTYPE GetShowCmd(PINT pnShowCmd);
	HRESULT STDMETHODCALLTYPE SetIconLocation(LPCWSTR pcwzIconFile, int niIcon);
	HRESULT STDMETHODCALLTYPE GetIconLocation(LPWSTR pwzIconFile, int ncbLen, PINT pniIcon);
	HRESULT STDMETHODCALLTYPE Resolve(HWND hwnd, DWORD dwFlags);

	// IShellPropSheetExt methods

	HRESULT STDMETHODCALLTYPE AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
	HRESULT STDMETHODCALLTYPE ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam);

	// IQueryInfo methods

	HRESULT STDMETHODCALLTYPE GetInfoFlags(DWORD *pdwFlags);
	HRESULT STDMETHODCALLTYPE GetInfoTip(DWORD dwFlags, LPWSTR *ppwszTip);

	// other get/set methods (used by prop sheet)

	HRESULT STDMETHODCALLTYPE SetDisplayName(LPCWSTR pcwzDisplayName);
	HRESULT STDMETHODCALLTYPE GetDisplayName(LPWSTR pwzDisplayName, int ncbLen);
	HRESULT STDMETHODCALLTYPE SetName(LPCWSTR pcwzName);
	HRESULT STDMETHODCALLTYPE GetName(LPWSTR pwzName, int ncbLen);
	HRESULT STDMETHODCALLTYPE SetVersion(LPCWSTR pcwzVersion);
	HRESULT STDMETHODCALLTYPE GetVersion(LPWSTR pwzVersion, int ncbLen);
	HRESULT STDMETHODCALLTYPE SetCulture(LPCWSTR pcwzCulture);
	HRESULT STDMETHODCALLTYPE GetCulture(LPWSTR pwzCulture, int ncbLen);
	HRESULT STDMETHODCALLTYPE SetPKT(LPCWSTR pcwzPKT);
	HRESULT STDMETHODCALLTYPE GetPKT(LPWSTR pwzPKT, int ncbLen);
	HRESULT STDMETHODCALLTYPE SetCodebase(LPCWSTR pcwzCodebase);
	HRESULT STDMETHODCALLTYPE GetCodebase(LPWSTR pwzCodebase, int ncbLen);
	HRESULT STDMETHODCALLTYPE SetAppType(int nAppType);
	HRESULT STDMETHODCALLTYPE GetAppType(PINT pnAppType);

	// other methods

	HRESULT STDMETHODCALLTYPE GetCurFile(LPWSTR pwzFile, UINT ucbLen);
	HRESULT STDMETHODCALLTYPE Dirty(BOOL bDirty);

private:
	DWORD m_dwFlags;

	LPWSTR m_pwzShortcutFile;
	LPWSTR m_pwzPath;
	LPWSTR m_pwzDesc;
	LPWSTR m_pwzIconFile;
	int      m_niIcon;
	LPWSTR m_pwzWorkingDirectory;
	int      m_nShowCmd;
	WORD   m_wHotkey;

	// for IPersistFile and IShellPropSheetExt func, some elements
	//  of this struct are needed (but not all), some are duplicated above
	// BUGBUG: need an alternate implementation!
	APPREFINFO* m_pappRefInfo;
};

extern const GUID CLSID_AppShortcut;

#endif // _APPSHCUT_DLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\shortcut\refcount.hpp ===
/*
 * refcount.hpp - RefCount class description.
 */

#pragma once

#include <objbase.h>
#include <windows.h>

/* Types
 ********/

/* Classes
 **********/

class RefCount
{
private:
   ULONG m_ulcRef;

public:
   RefCount(void);
   // Virtual destructor defers to destructor of derived class.
   virtual ~RefCount(void);

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
};
DECLARE_STANDARD_TYPES(RefCount);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\shortcut\extricon.cpp ===
/*
 * extricon.cpp - IExtractIcon implementation for App Shortcut class.
 */


/* Headers
 **********/

#include "project.hpp"
#include <stdio.h> // for _snwprintf

/* Global Constants
 *******************/

const WCHAR g_cwzDefaultIconKey[]	= L"AppShortcutFile\\DefaultIcon";

const HKEY g_hkeySettings			= HKEY_CLASSES_ROOT;

/* Module Constants
 *******************/

const WCHAR s_cwzGenericIconFile[]	= L"appsc.dll";

const int s_ciGenericIconFileIndex	= 0;


void TrimString(PWSTR pwzTrimMe, PCWSTR pwzTrimChars)
{
	PWSTR pwz = pwzTrimMe;;
	PWSTR pwzStartMeat = NULL;

	if ( !pwzTrimMe || !pwzTrimChars )
		goto exit;

	// Trim leading characters.

	while (*pwz && wcschr(pwzTrimChars, *pwz))
	{
		//CharNext(pwz);
		if (*pwz != L'\0')	// this really will not be false...
			pwz++;
	}

	pwzStartMeat = pwz;

	// Trim trailing characters.

	if (*pwz)
	{
		pwz += wcslen(pwz);

		//CharPrev(pwzStartMeat, pwz);
		if (pwz != pwzStartMeat)	// this check is not really necessary...
			pwz--;

		if (pwz > pwzStartMeat)
		{
			while (wcschr(pwzTrimChars, *pwz))
			{
				//CharPrev(pwzStartMeat, pwz);
				if (pwz != pwzStartMeat)	// this really will not be false...
					pwz--;
			}

			//CharNext(pwz);
			if (*pwz != L'\0')	// this check is not really necessary...
				pwz++;

			ASSERT(pwz > pwzStartMeat);

			*pwz = L'\0';
		}
	}

	// Relocate stripped string.

	if (*pwzStartMeat && pwzStartMeat > pwzTrimMe)
		// (+ 1) for null terminator.
		// BUGBUG?: is this going to bite us later?
		MoveMemory(pwzTrimMe, pwzStartMeat, (wcslen(pwzStartMeat)+1) * sizeof(WCHAR));
	else if (!*pwzStartMeat)
		pwzTrimMe[0] = L'\0';
	else
		ASSERT(pwzStartMeat == pwzTrimMe);

exit:
	return;
}

/*
** TrimWhiteSpace()
**
** Trims leading and trailing white space from a string in place.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
void TrimWhiteSpace(PWSTR pwzTrimMe)
{
	TrimString(pwzTrimMe, g_cwzWhiteSpace);

	// TrimString() validates pwzTrimMe on output.

	return;
}

/*
** StringToInt()
**
**
** Arguments:
**
** Returns:  0 if string parses to 0 
**              or string does not represent an int
**              or string ptr is NULL
**
** Side Effects:  none
**
** Stops at first non-digit character encountered.
** note: this does not accept positive int as "+5", no overflow/underflow check either
*/
// BUGBUG?: should use CRT's strtol/wcstol instead?
int StringToInt(PCWSTR pcwz)
{
	int nResult = 0;
	BOOL bNegative = FALSE;

	if (pcwz == NULL)
		goto exit;
	else if (*pcwz == L'-')
	{
		bNegative = TRUE;
		pcwz++;
	}
	else
		bNegative = FALSE;

	while (iswdigit(*pcwz))
	{
		ASSERT(nResult <= INT_MAX / 10);
		nResult *= 10;
		ASSERT(nResult <= INT_MAX - (*pcwz - L'0'));
		nResult += *pcwz++ - L'0';
	}

	// nResult may be any value.

exit:
	return(bNegative ? - nResult : nResult);
}

/*
** GetRegKeyValue()
**
** Retrieves the data from a registry key's value.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
LONG GetRegKeyValue(HKEY hkeyParent, PCWSTR pcwzSubKey,
                                   PCWSTR pcwzValue, PDWORD pdwValueType,
                                   PBYTE pbyteBuf, PDWORD pdwcbBufLen)
{
	LONG lResult;
	HKEY hkeySubKey;

	ASSERT(IS_VALID_HANDLE(hkeyParent, KEY));
	ASSERT(! pcwzSubKey || ! pcwzValue || ! pdwValueType || ! pbyteBuf);

	lResult = RegOpenKeyEx(hkeyParent, pcwzSubKey, 0, KEY_QUERY_VALUE,
			&hkeySubKey);

	if (lResult == ERROR_SUCCESS)
	{
		LONG lResultClose;

		lResult = RegQueryValueEx(hkeySubKey, pcwzValue, NULL, pdwValueType,
				pbyteBuf, pdwcbBufLen);

		lResultClose = RegCloseKey(hkeySubKey);

		if (lResult == ERROR_SUCCESS)
			lResult = lResultClose;
	}

	return(lResult);
}

/*
** GetRegKeyStringValue()
**
** Retrieves the data from a registry key's string value.
**
** Arguments:
**
** Returns: ERROR_CANTREAD if not string
**
** Side Effects:  none
*/
LONG GetRegKeyStringValue(HKEY hkeyParent, PCWSTR pcwzSubKey,
                                         PCWSTR pcwzValue, PWSTR pwzBuf,
                                         PDWORD pdwcbBufLen)
{
	LONG lResult;
	DWORD dwValueType;

	// GetRegKeyValue() will verify the parameters.

	lResult = GetRegKeyValue(hkeyParent, pcwzSubKey, pcwzValue, &dwValueType,
			(PBYTE)pwzBuf, pdwcbBufLen);

	if (lResult == ERROR_SUCCESS &&	dwValueType != REG_SZ)
		lResult = ERROR_CANTREAD;

	return(lResult);
}


/*
** GetDefaultRegKeyValue()
**
** Retrieves the data from a registry key's default string value.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
LONG GetDefaultRegKeyValue(HKEY hkeyParent, PCWSTR pcwzSubKey,
                                          PWSTR pwzBuf, PDWORD pdwcbBufLen)
{
	// GetRegKeyStringValue() will verify the parameters.

	return(GetRegKeyStringValue(hkeyParent, pcwzSubKey, NULL, pwzBuf,
			pdwcbBufLen));
}

/***************************** Private Functions *****************************/

/*
** ParseIconEntry()
**
**
** Arguments:
**
** Returns:       S_OK if icon entry parsed successfully.
**                S_FALSE if not (empty string).
**                (get 0 if icon index empty, or
**                 if icon index parsing fails)
**
** Side Effects:  The contents of pwzIconEntry are modified.
**
*/
HRESULT ParseIconEntry(LPWSTR pwzIconEntry, PINT pniIcon)
{
	HRESULT hr = S_OK;
	LPWSTR pwzComma;

	// caller GetGenericIcon() will verify the parameters.

	pwzComma = wcschr(pwzIconEntry, L',');

	if (pwzComma)
	{
		*pwzComma++ = L'\0';
		TrimWhiteSpace(pwzComma);

		if (pwzComma[0] == L'\0')
			*pniIcon = 0;
		else
			*pniIcon = StringToInt(pwzComma);
	}
	else
	{
		*pniIcon = 0;
	}

	TrimWhiteSpace(pwzIconEntry);

	if (pwzIconEntry[0] == L'\0')
	{
		hr = S_FALSE;
	}

	ASSERT(IsValidIconIndex(hr, pwzIconEntry, MAX_PATH, *pniIcon));

	return(hr);
}


/*
** GetFallBackGenericIcon()
**
**
** Arguments:
**
** Returns:       S_OK if fallback generic icon information retrieved
**                successfully.
**                E_FAIL if not.
**
** Side Effects:  none
*/
HRESULT GetFallBackGenericIcon(LPWSTR pwzIconFile,
                                               UINT ucbIconFileBufLen,
                                               PINT pniIcon)
{
	HRESULT hr = S_OK;

	// Fall back to first icon in this module.
	// caller GetGenericIcon() will verify the parameters.

	if (ucbIconFileBufLen >= ( sizeof(s_cwzGenericIconFile) / sizeof(WCHAR) ))
	{
		wcscpy(pwzIconFile, s_cwzGenericIconFile);
		*pniIcon = s_ciGenericIconFileIndex;

	}
	else
	{
		hr = E_FAIL;
	}

	ASSERT(IsValidIconIndex(hr, pwzIconFile, ucbIconFileBufLen, *pniIcon));

	return(hr);
}


/*
** GetGenericIcon()
**
**
** Arguments:
**
** Returns:       S_OK if generic icon information retrieved successfully.
**                Otherwise error (E_FAIL).
**
** Side Effects:  none
*/
// assumptions: always structure the reg key value and fallback path so that the iconfile
//       can be found by the shell!!
//       should also consider making it a fully qualify path
//       finally the iconfile must exist
HRESULT GetGenericIcon(LPWSTR pwzIconFile,
                                       UINT ucbIconFileBufLen, PINT pniIcon)
{
	HRESULT hr = S_OK;
	DWORD dwcbLen = ucbIconFileBufLen;

	// caller GetIconLocation() will verify parameters

	ASSERT(IS_VALID_HANDLE(g_hkeySettings, KEY));

	if (GetDefaultRegKeyValue(g_hkeySettings, g_cwzDefaultIconKey, pwzIconFile, &dwcbLen)
			== ERROR_SUCCESS)
		hr = ParseIconEntry(pwzIconFile, pniIcon);
	else
	{
		// no icon entry
		hr = S_FALSE;
	}

	if (hr == S_FALSE)
		hr = GetFallBackGenericIcon(pwzIconFile, ucbIconFileBufLen, pniIcon);

	ASSERT(IsValidIconIndex(hr, pwzIconFile, ucbIconFileBufLen, *pniIcon));

	return(hr);
}


/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE CAppShortcut::GetIconLocation(UINT uInFlags,
                                                      LPWSTR pwzIconFile,
                                                      UINT ucbIconFileBufLen,
                                                      PINT pniIcon,
                                                      PUINT puOutFlags)
{
	// is there any pref hit by doing this logic/probing here?
	//  maybe this can be done in IPersistFile::Load instead?

	// always attempt to return S_OK or S_FALSE
	// only exception is that one case of E_INVALIDARG right below
	HRESULT hr=S_OK;

	if (!pwzIconFile || !pniIcon || ucbIconFileBufLen <= 0)
	{
		// should this return S_FALSE anyway so that the default shell icon is used?
		hr = E_INVALIDARG;
		goto exit;
	}

	if (IS_FLAG_CLEAR(uInFlags, GIL_OPENICON))
	{
		// .. this get the path ...
		hr = GetIconLocation(pwzIconFile, ucbIconFileBufLen, pniIcon);

		if (hr == S_OK && GetFileAttributes(pwzIconFile) == (DWORD)-1)
		{
			// if the file specified by iconfile does not exist, try again in working dir
			// it can be a relative path...

			// see note in shlink.cpp for string array size
			LPWSTR pwzWorkingDir = new WCHAR[ucbIconFileBufLen];

			hr = GetWorkingDirectory(pwzWorkingDir, ucbIconFileBufLen);
			if (hr != S_OK)
				hr = S_FALSE;
			else
			{
				LPWSTR pwzPath = new WCHAR[ucbIconFileBufLen];

				// working dir does not end w/ '\'
				_snwprintf(pwzPath, ucbIconFileBufLen, L"%s\\%s", pwzWorkingDir, pwzIconFile);

				if (GetFileAttributes(pwzPath) == (DWORD)-1)
					hr = S_FALSE;
				else
					wcscpy(pwzIconFile, pwzPath);

				delete pwzPath;
			}

			delete pwzWorkingDir;
		}

		// BUGBUG?: change to '!= S_OK'?
		// no need because GetIconLocation(,,) only returns S_OK/S_FALSE here
		if (hr == S_FALSE)
		{
			if (m_pwzPath)
			{
				// no icon file, use the entry point...
				// BUGBUG?: passing NULL as PWIN32_FIND_DATA will assert..
				hr = GetPath(pwzIconFile, ucbIconFileBufLen, NULL, SLGP_SHORTPATH); //?????? 0);
				if (hr != S_OK || GetFileAttributes(pwzIconFile) == (DWORD)-1)
					hr = S_FALSE;

				*pniIcon = 0;
			}
			/*else
				hr = S_FALSE;*/

			if (hr == S_FALSE)
			{
				// ... there's nothing?
				// Use generic URL icon.

				// see assumptions on GetGenericIcon()
				hr = GetGenericIcon(pwzIconFile, ucbIconFileBufLen, pniIcon);

				if (FAILED(hr))
					// worst case: ask shell to use its generic icon
					hr = S_FALSE;
			}
		}
	}
	else
		// No "open look" icon.
		hr = S_FALSE;

	if (hr != S_OK)
	{
		// see shelllink?
		if (ucbIconFileBufLen > 0)
			*pwzIconFile = L'\0';

		*pniIcon = 0;
	}

exit:
	if (puOutFlags)
		*puOutFlags = 0;
	// ignore puOutFlags == NULL case

	ASSERT(IsValidIconIndex(hr, pwzIconFile, ucbIconFileBufLen, *pniIcon))// &&

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::Extract(LPCWSTR pcwzIconFile,
                                                    UINT uiIcon,
                                                    HICON* phiconLarge,
                                                    HICON* phiconSmall,
                                                    UINT ucIconSize)
{
	HRESULT hr;

	ASSERT(IsValidIconIndex(S_OK, pcwzIconFile, MAX_PATH, uiIcon));

	// FEATURE: Validate ucIconSize here.

	if (phiconLarge)
		*phiconLarge = NULL;
	if (phiconSmall)
		*phiconSmall = NULL;

	// Use caller's default implementation of ExtractIcon().
	// GetIconLocation() should return good path and index

	hr = S_FALSE;

	ASSERT((hr == S_OK &&
		IS_VALID_HANDLE(*phiconLarge, ICON) &&
		IS_VALID_HANDLE(*phiconSmall, ICON)) ||
		(hr != S_OK &&
		! *phiconLarge &&
		! *phiconSmall));

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\shortcut\debbase.h ===
/*
 * debbase.h - Base debug macros and their retail translations.
 */


// BUGBUG: this should be fixed/beef up

/* Macros
 *********/

/* debug assertion macro */

/*
 * ASSERT() may only be used as a statement, not as an expression.
 *
 * E.g.,
 *
 * ASSERT(pszRest);
 */

#ifdef DEBUG

#define ASSERT(exp) \
   if (exp) \
      ; \
   else \
      ERROR_OUT(("assertion failed '%s'", (LPCWSTR)#exp))

#else

#define ASSERT(exp)

#endif   /* DEBUG */

/* debug evaluation macro */

/*
 * EVAL() may only be used as a logical expression.
 *
 * E.g.,
 *
 * if (EVAL(exp))
 *    bResult = TRUE;
 */

/*#ifdef DEBUG

#define EVAL(exp) \
   ((exp) || \
    (ERROR_OUT(("evaluation failed '%s'", (LPCWSTR)#exp)), 0))

#else
*/
#define EVAL(exp) \
   ((exp) != 0)

/*#endif*/   /* DEBUG */

/* handle validation macros */

extern BOOL IsValidHWND(HWND);

#ifdef DEBUG

extern BOOL IsValidHANDLE(HANDLE);
extern BOOL IsValidHEVENT(HANDLE);
extern BOOL IsValidHFILE(HANDLE);
extern BOOL IsValidHGLOBAL(HGLOBAL);
extern BOOL IsValidHMENU(HMENU);
extern BOOL IsValidHICON(HICON);
extern BOOL IsValidHINSTANCE(HINSTANCE);
extern BOOL IsValidHKEY(HKEY);
extern BOOL IsValidHMODULE(HMODULE);
extern BOOL IsValidHPROCESS(HANDLE);
extern BOOL IsValidHTEMPLATEFILE(HANDLE);

#endif

#ifdef DEBUG

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (ERROR_OUT(("invalid H" #type " - %#08lx", (hnd))), FALSE))

#else

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\shortcut\refcount.cpp ===
/*
 * refcount.cpp - RefCount class implementation.
 */


/* Headers
 **********/

#include "project.hpp" // for ULONG_MAX...
#include "refcount.hpp"

extern ULONG DllAddRef(void);
extern ULONG DllRelease(void);

/********************************** Methods **********************************/


RefCount::RefCount(void)
{
	// Don't validate this until after initialization.

	m_ulcRef = 1;
	DllAddRef();

	return;
}


RefCount::~RefCount(void)
{
	// m_ulcRef may be any value.

	DllRelease();

	return;
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
	ULONG ulRet = 0;

	// this is really bad... returns an error of some kind
	if(m_ulcRef >= ULONG_MAX)
	{
		ulRet = 0;
		goto exit;
	}

	m_ulcRef++;

	ulRet = m_ulcRef;
exit:
	return(ulRet);
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
	ULONG ulcRef;

	if (m_ulcRef > 0)
		m_ulcRef--;

	ulcRef = m_ulcRef;

	if (! ulcRef)
		delete this;

	return(ulcRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\shortcut\project.hpp ===
/*
 * project.hpp - project header file for Application Shortcut Shell
 *               extension DLL.
 */

// * note: debug check/code incomplete.
//#define DEBUG

/* Common Headers
 *****************/

#define INC_OLE2				// for windows.h
#define CONST_VTABLE			// for objbase.h

#ifndef WIN32_LEAN_AND_MEAN		// NT builds define this for us
#define WIN32_LEAN_AND_MEAN		// for windows.h
#endif							//  WIN32_LEAN_AND_MEAN

#define NOSERVICE
#define NOMCX
#define NOIME
#define NOSOUND
#define NOCOMM
#define NOKANJI
#define NORPC
#define NOPROXYSTUB
#define NOIMAGE
#define NOTAPE 
   
#include <windows.h>

#include <shellapi.h>

#include <limits.h>				// for ULONG_MAX

#ifdef __cplusplus
extern "C" {					// Assume C declarations for C++.
#endif   /* __cplusplus */

#include "debbase.h"

#ifdef __cplusplus
}								// End of extern "C" {.
#endif   /* __cplusplus */



/* Project Headers
 ******************/

#include <appshcut.h>
#include "refcount.hpp"

// bit flag manipulation ---

#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))
#define CLEAR_FLAG(dwAllFlags, dwFlag)    ((dwAllFlags) &= (~dwFlag))

#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))
#define IS_FLAG_CLEAR(dwAllFlags, dwFlag) (! (IS_FLAG_SET(dwAllFlags, dwFlag)))

#define E_FILE_NOT_FOUND         MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)
#define E_PATH_NOT_FOUND         MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_PATH_NOT_FOUND)

#define ARRAY_ELEMENTS(rg)                (sizeof(rg) / sizeof((rg)[0]))

// util stuff ---

HRESULT GetLastWin32Error();

const WCHAR g_cwzWhiteSpace[]		= L" \t";
const WCHAR g_cwzPathSeparators[]	= L":/\\";
const WCHAR g_cwzEmptyString[]		= L"";

extern BOOL AnyNonWhiteSpace(LPCWSTR pcsz);

// debug stuff ---

extern BOOL IsValidPath(PCWSTR pcwzPath);
extern BOOL IsValidPathResult(HRESULT hr, PCWSTR pcwzPath, UINT ucbPathBufLen);
extern BOOL IsValidIconIndex(HRESULT hr, PCWSTR pcwzIconFile, UINT ucbIconFileBufLen, int niIcon);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\shortcut\infotip.cpp ===
/*
 * infotip.cpp - IQueryInfo implementation
 */


/* Headers
 **********/

#include "project.hpp"
#include <stdio.h>    // for _snwprintf
#include "resource.h"

const UINT s_ucMaxNameLen		= 20;
const UINT s_ucMaxTypeLen		= 10;
const UINT s_ucMaxLocationLen	= 15;
const UINT s_ucMaxCodebaseLen	= 15;

// see GetInfoTip() for how the tip string/string-length is assembled
const UINT s_ucMaxTipLen		= s_ucMaxNameLen+s_ucMaxTypeLen+s_ucMaxLocationLen \
								+s_ucMaxCodebaseLen+DISPLAYNAMESTRINGLENGTH \
								+TYPESTRINGLENGTH+MAX_PATH+MAX_URL_LENGTH+8;

extern HINSTANCE g_DllInstance;

// ----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CAppShortcut::GetInfoFlags(DWORD *pdwFlags)
{
	if (!pdwFlags)
		*pdwFlags = 0;

	return S_OK; //E_NOTIMPL?
}

// ----------------------------------------------------------------------------

// BUGBUG?: maybe replace the use of g_cwzEmptyString with L"(unknown)"?
HRESULT STDMETHODCALLTYPE CAppShortcut::GetInfoTip(DWORD dwFlags, LPWSTR *ppwszTip)
{
	HRESULT hr = S_OK;
  	LPMALLOC lpMalloc = NULL;

  	WCHAR wzTip[s_ucMaxTipLen];
  	WCHAR wzNameHint[s_ucMaxNameLen];
  	WCHAR wzTypeHint[s_ucMaxTypeLen];
  	WCHAR wzLocationHint[s_ucMaxLocationLen];
  	WCHAR wzCodebaseHint[s_ucMaxCodebaseLen];
	WCHAR wzAppTypes[IDS_APPTYPE_WIN32EXE-IDS_APPTYPE_NETASSEMBLY+1][TYPESTRINGLENGTH];

	LPWSTR pwzName = (m_pwzDesc ? m_pwzDesc : (LPWSTR) g_cwzEmptyString);
	LPWSTR pwzLocation = (m_pwzPath ? m_pwzPath : (LPWSTR) g_cwzEmptyString);
	LPWSTR pwzAppType = (LPWSTR) g_cwzEmptyString;
	LPWSTR pwzCodebase = (LPWSTR) g_cwzEmptyString;

	// dwFlags ignored

	if (ppwszTip)
		*ppwszTip = NULL;
	else
	{
		hr = E_INVALIDARG;
		goto exit;
	}

	// Allocate a shell memory object.
	hr = SHGetMalloc (&lpMalloc);
	if (FAILED (hr))
		goto exit;

	wzTip[0] = L'\0';

	// load resources
	if (!LoadString(g_DllInstance, IDS_TIP_NAME, wzNameHint, s_ucMaxNameLen))
	{
		// do not fail
		wzNameHint[0] = L'\0';
	}

	if (!LoadString(g_DllInstance, IDS_TIP_TYPE, wzTypeHint, s_ucMaxTypeLen))
	{
		// do not fail
		wzTypeHint[0] = L'\0';
	}

	if (!LoadString(g_DllInstance, IDS_TIP_LOCATION, wzLocationHint, s_ucMaxLocationLen))
	{
		// do not fail
		wzLocationHint[0] = L'\0';
	}

	if (!LoadString(g_DllInstance, IDS_TIP_CODEBASE, wzCodebaseHint, s_ucMaxCodebaseLen))
	{
		// do not fail
		wzCodebaseHint[0] = L'\0';
	}

	// note: this has to match the resource string ordering
	for (int i = IDS_APPTYPE_NETASSEMBLY; i <= IDS_APPTYPE_WIN32EXE; i++)
	{
		if (!LoadString(g_DllInstance, i, wzAppTypes[i-IDS_APPTYPE_NETASSEMBLY], TYPESTRINGLENGTH))
		{
			// do not fail
			wzAppTypes[i-IDS_APPTYPE_NETASSEMBLY][0] = L'\0';
		}
	}

	if (m_pappRefInfo)
	{
		// note: this has to match above LoadString order for app types
		if (m_pappRefInfo->_fAppType == APPTYPE_NETASSEMBLY)
			pwzAppType = wzAppTypes[0];
		else if (m_pappRefInfo->_fAppType == APPTYPE_WIN32EXE)
			pwzAppType = wzAppTypes[IDS_APPTYPE_WIN32EXE-IDS_APPTYPE_NETASSEMBLY];
		/*else
			pwzAppType = (LPWSTR) g_cwzEmptyString;*/

		pwzCodebase = m_pappRefInfo->_wzCodebase;
	}
	//else
		// some thing wrong, but do not fail still

	
	// ignore error
	// BUGBUG?: "(null)" is displayed if m_pwzDesc or m_pwzPath == NULL...
	_snwprintf(wzTip, s_ucMaxTipLen, L"%s %s\n%s %s\n%s %s\n%s %s",
		wzNameHint, pwzName, wzTypeHint, pwzAppType, wzLocationHint, pwzLocation, wzCodebaseHint, pwzCodebase);
		
	// Get some memory
	*ppwszTip = (LPWSTR) lpMalloc->Alloc ((wcslen(wzTip)+1)*sizeof(WCHAR));
	if (! *ppwszTip)
	{
		hr = E_OUTOFMEMORY;
		goto exit; // Error - could not allocate memory
	}

	wcscpy(*ppwszTip, wzTip);

exit:
	if (lpMalloc)
		lpMalloc->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\shortcut\persist.cpp ===
/*
 * persist.cpp - IPersist, IPersistFile implementations for
 *               App Shortcut class.
 */


/* Headers
 **********/

#include "project.hpp" // for GetLastWin32Error
#include <stdio.h>    // for _snwprintf

/* Global Constants
 *******************/

const WCHAR g_cwzDefaultFileNamePrompt[]  = L"*.app";

// ----------------------------------------------------------------------------

bool
PathAppend(LPWSTR wzDest, LPCWSTR wzSrc)
{
	// shlwapi PathAppend-like
	bool bRetVal = TRUE;
	int iPathLen = 0;
	static WCHAR wzWithSeparator[] = L"\\%s";
	static WCHAR wzWithoutSeparator[] = L"%s";

	if (!wzDest || !wzSrc)
	{
		bRetVal = FALSE;
		goto exit;
	}

	iPathLen = wcslen(wzDest);

    if (_snwprintf(wzDest+iPathLen, MAX_PATH-iPathLen, 
    	(wzDest[iPathLen-1] == L'\\' ? wzWithoutSeparator : wzWithSeparator), wzSrc) < 0)
	{
		bRetVal = FALSE;
	}

exit:
	return bRetVal;
}

// ----------------------------------------------------------------------------

#define LOCALROOTNAME		L"Application Store"

// ----------------------------------------------------------------------------

STDAPI
GetDefaultLocalRoot(LPWSTR wzPath)
{
	// wzPath should be of length MAX_PATH
	HRESULT hr = S_OK;

	if(GetEnvironmentVariable(L"ProgramFiles", wzPath, MAX_PATH-wcslen(LOCALROOTNAME)-1) == 0)  //????????
	{
		hr = CO_E_PATHTOOLONG;
		goto exit;
	}

	if (!PathAppend(wzPath, LOCALROOTNAME))
	{
		hr = E_FAIL;
		//goto exit;
	}

exit:
	return hr;
}

// ----------------------------------------------------------------------------

STDAPI
GetAppDir(APPREFINFO* pAPPREFINFO, LPWSTR wzPath)
{
	// wzPath should be of length MAX_PATH
	HRESULT hr = S_OK;

    if (_snwprintf(wzPath, MAX_PATH, L"%s\\%s\\%s\\%s",
    	pAPPREFINFO->_wzPKT, pAPPREFINFO->_wzName, pAPPREFINFO->_wzVersion, pAPPREFINFO->_wzCulture) < 0)
    {
    	hr = CO_E_PATHTOOLONG;
    }

    return hr;
}

// ----------------------------------------------------------------------------

// BUGBUG: hacked up parsing code
void
ParseRef(char* szRef, APPREFINFO* pAPPREFINFO)
{
    char    *token;
    char    seps[] = " </>=\"\t\n\r";
    BOOL	fSkipNextToken = FALSE;

    // parsing code - limitation: 1. does not work w/ space in field, even if enclosed w/ quotes
    //  2. szRef will be modified!
    token = strtok( szRef, seps );
    while( token != NULL )
    {
       // While there are tokens
		if (!_stricmp(token, "displayname"))
		{
	        for (int i = 0; i < DISPLAYNAMESTRINGLENGTH; i++)
            {
                if (*(token+13+i) == '\"')
                {
                    // BUGBUG: 13 == strlen("displayname="")
                    *(token+13+i) = '\0';
                    _snwprintf(pAPPREFINFO->_wzDisplayName, i+1, L"%S", token+13);

                    // BUGBUG? a hack
                    token = strtok( token+i+14, seps);

					fSkipNextToken = TRUE;
                    break;
                }
	        }
		}
		else if (!_stricmp(token, "name"))
		{
			token = strtok( NULL, seps );
            _snwprintf(pAPPREFINFO->_wzName, NAMESTRINGLENGTH, L"%S", token);
		}
		else if (!_stricmp(token, "version"))
		{
			token = strtok( NULL, seps );
            _snwprintf(pAPPREFINFO->_wzVersion, VERSIONSTRINGLENGTH, L"%S", token);
		}
		else if (!_stricmp(token, "culture"))
		{
			token = strtok( NULL, seps );
            _snwprintf(pAPPREFINFO->_wzCulture, CULTURESTRINGLENGTH, L"%S", token);
		}
		else if (!_stricmp(token, "publickeytoken"))
		{
			token = strtok( NULL, seps );
            _snwprintf(pAPPREFINFO->_wzPKT, PKTSTRINGLENGTH, L"%S", token);
		}
		else if (!_stricmp(token, "type"))
		{
			token = strtok( NULL, seps );
			if (!_stricmp(token, ".NetAssembly"))
				pAPPREFINFO->_fAppType = APPTYPE_NETASSEMBLY;
			else if (!_stricmp(token, "Win32Executable"))
				pAPPREFINFO->_fAppType = APPTYPE_WIN32EXE;
		}
		else if (!_stricmp(token, "entrypoint"))
		{
			token = strtok( NULL, seps );
            _snwprintf(pAPPREFINFO->_wzEntryFileName, MAX_PATH, L"%S", token);
		}
		else if (!_stricmp(token, "codebase"))
		{
	        for (int i = 0; i < MAX_URL_LENGTH; i++)
            {
                if (*(token+10+i) == '\"')
                {
                    // BUGBUG: 10 == strlen("codebase="")
                    *(token+10+i) = '\0';
                    _snwprintf(pAPPREFINFO->_wzCodebase, i+1, L"%S", token+10);

                    // BUGBUG? a hack
                    token = strtok( token+i+11, seps);
                    // now  token == "newhref" && *(token-1) == '/'

					fSkipNextToken = TRUE;                    
                    break;
                }
            }
            // BUGBUG: ignoring > MAX_URL_LENGTH case here... may mess up later if the URL contain a "keyword"
		}
		else if (!_stricmp(token, "iconfile"))
		{
	        for (int i = 0; i < MAX_URL_LENGTH; i++)
            {
                if (*(token+10+i) == '\"')
                {
                    // BUGBUG: 10 == strlen("iconfile="")
                    *(token+10+i) = '\0';
                    _snwprintf(pAPPREFINFO->_pwzIconFile, i+1, L"%S", token+10);

                    // BUGBUG? a hack
                    token = strtok( token+i+11, seps);

					fSkipNextToken = TRUE;
                    break;
                }
	        }
		}
		else if (!_stricmp(token, "iconindex"))
		{
			char *szStopstring;
   
			token = strtok( NULL, seps );
            pAPPREFINFO->_niIcon = (int) strtol( token, &szStopstring, 10);
		}
		else if (!_stricmp(token, "hotkey"))
		{
			char *szStopstring;
   
			token = strtok( NULL, seps );

			// hotkey is stored as an integer... need validation check here...
			pAPPREFINFO->_wHotkey = (int) strtol( token, &szStopstring, 10);
		}
		else if (!_stricmp(token, "showcommand"))
		{
			token = strtok( NULL, seps );
			if (!_stricmp(token, "maximized"))
			{
				pAPPREFINFO->_nShowCmd = SW_SHOWMAXIMIZED;
			}
			else if (!_stricmp(token, "minimized"))
			{
				pAPPREFINFO->_nShowCmd = SW_SHOWMINIMIZED;
			}
			else
			{
				pAPPREFINFO->_nShowCmd = SW_SHOWNORMAL;
			}
		}
       //else
       // ignore others for now

    // Get next token...
	if (!fSkipNextToken)
	   token = strtok( NULL, seps );
	else
		fSkipNextToken = FALSE;

    }

}

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

// Note: 1. remember to do HeapFree on the the ptr *szData!
//       2. *szData must be initialized to NULL else this func will attempt to free it 1st
HRESULT
ReadShortcut(HANDLE hHeap, LPCWSTR wzFilePath, char** ppszData)
{
	HRESULT hr = S_OK;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwLength;
    DWORD dwFileSize;

	// BUGBUG? should it be freed? or do HeapValidate()?
    if (*ppszData)
    {
		if (HeapFree(hHeap, 0, *ppszData) == 0)
		{
			hr = GetLastWin32Error();
			goto exit;
    	}
    }

	hFile = CreateFile(wzFilePath, GENERIC_READ, 0, NULL, 
                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if(hFile == INVALID_HANDLE_VALUE)
    {
        hr = GetLastWin32Error();
        goto exit;
    }

    // BUGBUG: this won't work properly if the file is too large
    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == INVALID_FILE_SIZE)
    {
        hr = GetLastWin32Error();
        goto exit;
    }

	// allocate memory
	*ppszData = (char*) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwFileSize);
	if (*ppszData == NULL)
	{
		hr = E_FAIL;
		goto exit;
	}

	// read the file in a whole
	if (ReadFile(hFile, *ppszData, dwFileSize, &dwLength, NULL) == 0)
	{
		hr = GetLastWin32Error();
    	goto exit;
	}

	if (dwLength != dwFileSize)
	{
		hr = E_FAIL;
		goto exit;
	}

    //*((*ppszData) + dwLength) = '\0';  memory was zero-ed out when allocated

exit:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
	
	return hr;
}

// ----------------------------------------------------------------------------

STDAPI 
ProcessRef(LPCWSTR wzRefLocalFilePath, APPREFINFO* pAPPREFINFO)
{
	HRESULT hr = S_OK;
	char* psz = NULL;
	static HANDLE hHeap = INVALID_HANDLE_VALUE;  //pref?
	
    if (hHeap == INVALID_HANDLE_VALUE)
	{
		hHeap = GetProcessHeap();
		if (hHeap == NULL)
		{
			hHeap = INVALID_HANDLE_VALUE;
			hr = E_FAIL;
			goto exit;
		}
	}

	if (FAILED(hr=ReadShortcut(hHeap, wzRefLocalFilePath, &psz)))
		goto exit;

	ParseRef(psz, pAPPREFINFO);

exit:
    if (psz)
    {
		if (HeapFree(hHeap, 0, psz) == 0)
		{
			hr = GetLastWin32Error();
    	}
    }

	return hr;
}

// ----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CAppShortcut::GetCurFile(LPWSTR pwzFile,
                                                       UINT ucbLen)
{
	HRESULT hr=S_OK;

	if (m_pwzShortcutFile)
	{
		wcsncpy(pwzFile, m_pwzShortcutFile, ucbLen-1);
		pwzFile[ucbLen-1] = L'\0';
	}
	else
		hr = S_FALSE;

	ASSERT(hr == S_OK ||
			hr == S_FALSE);

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::Dirty(BOOL bDirty)
{
	HRESULT hr=S_OK;

	if (bDirty)
	{
		SET_FLAG(m_dwFlags, APPSHCUT_FL_DIRTY);
		//m_dwFlags = APPSHCUT_FL_DIRTY;
	}
	else
	{
		CLEAR_FLAG(m_dwFlags, APPSHCUT_FL_DIRTY);
		//m_dwFlags = APPSHCUT_FL_NOTDIRTY;
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::GetClassID(CLSID* pclsid)
{
	HRESULT hr=S_OK;

	if (pclsid == NULL)
		hr = E_INVALIDARG;
	else
		*pclsid = CLSID_AppShortcut;

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::IsDirty(void)
{
	HRESULT hr;

	if (IS_FLAG_SET(m_dwFlags, APPSHCUT_FL_DIRTY))
	//if (m_dwFlags == APPSHCUT_FL_DIRTY)
		// modified
		hr = S_OK;
	else
		// not modified
		hr = S_FALSE;

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::Save(LPCOLESTR pcwszFile,
                                                 BOOL bRemember)
{
	// BUGBUG: no save for now!
	return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CAppShortcut::SaveCompleted(LPCOLESTR pcwszFile)
{
	// BUGBUG: no save for now!
	return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CAppShortcut::Load(LPCOLESTR pcwszFile,
                                                 DWORD dwMode)
{
   HRESULT hr = S_OK;
   WCHAR wzWorkingDir[MAX_PATH];
   WCHAR wzAppDir[MAX_PATH];

	// FEATURE: Validate dwMode here.
	// FEAUTRE: Implement dwMode flag support.

	if (!pcwszFile)
	{
		hr = E_INVALIDARG;
		goto exit;
	}

	// BUGBUG?: this shouldn't be called more than once?
	if (m_pwzWorkingDirectory)
	{
		hr = E_FAIL;
		goto exit;
	}

	// store the shortcut file name
	if (m_pwzShortcutFile)
		delete m_pwzShortcutFile;

	// (+ 1) for null terminator.
    m_pwzShortcutFile = new(WCHAR[wcslen(pcwszFile) + 1]);
    if (m_pwzShortcutFile)
    {
    	wcscpy(m_pwzShortcutFile, pcwszFile);
    }
    else
    {
    	hr = E_OUTOFMEMORY;
    	goto exit;
    }

	if (m_pappRefInfo)
		delete m_pappRefInfo;

	m_pappRefInfo = new APPREFINFO;
	if (!m_pappRefInfo)
    {
    	hr = E_OUTOFMEMORY;
    	goto exit;
    }

	m_pappRefInfo->_wzDisplayName[0] = L'\0';
	m_pappRefInfo->_wzName[0] = L'\0';
	m_pappRefInfo->_wzVersion[0] = L'\0';
	m_pappRefInfo->_wzCulture[0] = L'\0';
	m_pappRefInfo->_wzPKT[0] = L'\0';
	m_pappRefInfo->_wzEntryFileName[0] = L'\0';
	m_pappRefInfo->_wzCodebase[0] = L'\0';
	m_pappRefInfo->_fAppType = APPTYPE_UNDEF;
	m_pappRefInfo->_pwzIconFile[0] = L'\0';
	m_pappRefInfo->_niIcon = 0;
	m_pappRefInfo->_nShowCmd = SW_SHOWNORMAL;
	m_pappRefInfo->_wHotkey = 0;

	if (FAILED(hr=ProcessRef(pcwszFile, m_pappRefInfo)))
		goto exit;

	if (m_pappRefInfo->_wzName[0] == L'\0' ||
			m_pappRefInfo->_wzVersion[0] == L'\0' ||
			m_pappRefInfo->_wzCulture[0] == L'\0' ||
			m_pappRefInfo->_wzPKT[0] == L'\0')
	{
		// can't continue (no app dir), 'cos otherwise unknown behavior
		// BUGBUG: should check/code to ensure some continue to work
		//    w/o the complete name, eg. shell icon path, part of infotip
		hr = E_FAIL;
		goto exit;
	}

    if (FAILED(hr=GetDefaultLocalRoot(wzWorkingDir)))
    	goto exit;

    if (FAILED(hr=GetAppDir(m_pappRefInfo, wzAppDir)))
    	goto exit;

	if (!PathAppend(wzWorkingDir, wzAppDir))
	{
		hr = E_FAIL;
		goto exit;
	}

	if (FAILED(hr=SetWorkingDirectory(wzWorkingDir)))
		goto exit;

	// default is normal
	if (FAILED(hr=SetShowCmd(m_pappRefInfo->_nShowCmd)))
		goto exit;

	if (m_pappRefInfo->_wzEntryFileName[0] != L'\0')
	{
		// like .lnk or .url, entry point is under wzWorkingDir
		// 'path' is the target file of the shortcut, ie. the entry point of the app in this case
		if (!PathAppend(wzWorkingDir, m_pappRefInfo->_wzEntryFileName))
		{
			hr = E_FAIL;
			goto exit;
		}

		if (FAILED(hr=SetPath(wzWorkingDir)))
			goto exit;

		// note: wzWorkingDir is now modified!
	}
	//else
	// ... if no entry point leave it blank so that the default icon will be used

	if (m_pappRefInfo->_wzDisplayName[0] != L'\0')
		if (FAILED(hr=SetDescription(m_pappRefInfo->_wzDisplayName)))
			goto exit;

	if (m_pappRefInfo->_pwzIconFile[0] != L'\0')
		if (FAILED(hr=SetIconLocation(m_pappRefInfo->_pwzIconFile, m_pappRefInfo->_niIcon)))
		goto exit;

	if (m_pappRefInfo->_wHotkey != 0)
		if (FAILED(hr=SetHotkey(m_pappRefInfo->_wHotkey)))
			goto exit;

exit:
   return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::GetCurFile(LPOLESTR *ppwszFile)
{
	HRESULT hr = S_OK;
	LPOLESTR pwszTempFile;

	if (ppwszFile == NULL)
	{
		hr = E_INVALIDARG;
		goto exit;
	}
	// BUGBUG?: ensure *ppwszFile NULL?

	if (m_pwzShortcutFile)
	{
		pwszTempFile = m_pwzShortcutFile;
	}
	else
	{
		pwszTempFile = (LPWSTR) g_cwzDefaultFileNamePrompt;

		hr = S_FALSE;
	}

	*ppwszFile = (LPOLESTR) CoTaskMemAlloc((wcslen(pwszTempFile) + 1) * sizeof(*pwszTempFile));

	if (*ppwszFile)
		wcscpy(*ppwszFile, pwszTempFile);
	else
		hr = E_OUTOFMEMORY;

exit:
	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\shortcut\propsht.cpp ===
/*
 * propsht.cpp - IPropSheetExt implementation for App Shortcut class.
 */



// * NOTE!!: this code is incomplete. Also error checking (any leak?),
// *        restructuring (for better coding/efficiency) to be done.




// * this file uses CharNext etc as it needs User32 anyway *

/* Headers
 **********/

#include "project.hpp"

#include <prsht.h>

#include "resource.h"

extern "C" WINSHELLAPI int   WINAPI PickIconDlg(HWND hwnd, LPWSTR pwzIconPath, UINT cbIconPath, int *piIconIndex);

extern HINSTANCE g_DllInstance;

/* Types
 ********/

// Application Shortcut property sheet data

typedef enum _appshcutpropsheetpgs
{
	APPSHCUT_PS_APPSHCUT_PAGE	= 0x0000,
	APPSHCUT_PS_APPREF_PAGE 		= 0x0001,

	ALL_APPSHCUT_PS_PAGES
}
APPSHCUTPSPAGES;

typedef struct _asps
{
	CAppShortcut* pappshcut;

	WCHAR rgchIconFile[MAX_PATH];

	int niIcon;

	APPSHCUTPSPAGES eCurPage;
}
ASPS;
DECLARE_STANDARD_TYPES(ASPS);

typedef ASPS* PASPS;

/* Module Constants
 *******************/

// Tray notification window class

//copied from shell32!
#define WNDCLASS_TRAYNOTIFY     L"Shell_TrayWnd"    //internal_win40
const WCHAR s_cwzTrayNotificationClass[]  = WNDCLASS_TRAYNOTIFY;

// HACKHACK: WMTRAY_SCREGISTERHOTKEY and WMTRAY_SCUNREGISTERHOTKEY are stolen
// from shelldll\link.c.
typedef const UINT CUINT;
CUINT WMTRAY_SCREGISTERHOTKEY			= (WM_USER + 233);
CUINT WMTRAY_SCUNREGISTERHOTKEY			= (WM_USER + 234);

// show commands - N.b., the order of these constants must match the order of
// the corresponding IDS_ string table constants.

const UINT s_ucMaxShowCmdLen			= MAX_PATH;
const UINT s_ucMaxTypeLen				= TYPESTRINGLENGTH;

const int s_rgnShowCmds[] =
{
	SW_SHOWNORMAL,
	SW_SHOWMINNOACTIVE,
	SW_SHOWMAXIMIZED
};

// this ordering has to match the strings in the resource file, 
// the strings has to be in sync with the parsing code in persist.cpp
const int s_rgnType[] =
{
	APPTYPE_NETASSEMBLY,
	APPTYPE_WIN32EXE
};

/*
** ExtractFileName()
**
** Extracts the file name from a path name.
**
** Arguments:     pcwzPathName - path string from which to extract file name
**
** Returns:       Pointer to file name in path string.
**
** Side Effects:  none
*/
#define BACKSLASH		L'/'
#define SLASH			L'\\'
#define COLON			L':'
#define IS_SLASH(ch)	((ch) == SLASH || (ch) == BACKSLASH)
PCWSTR ExtractFileName(PCWSTR pcwzPathName)
{
	PCWSTR pcwzLastComponent;
	PCWSTR pcwz;

	for (pcwzLastComponent = pcwz = pcwzPathName; *pcwz; pcwz = CharNext(pcwz))
	{
		if (IS_SLASH(*pcwz) || *pcwz == COLON)
			pcwzLastComponent = CharNext(pcwz);
	}

	ASSERT(IsValidPath(pcwzLastComponent));

	return(pcwzLastComponent);
}

/***************************** Private Functions *****************************/


UINT CALLBACK ASPSCallback(HWND hwnd, UINT uMsg,
                    LPPROPSHEETPAGE ppsp)
{
	// this is called after ASPS_DlgProc WM_DESTROY (ie. ASPS_Destroy)
	// this func should do the frees/releases

	UINT uResult = TRUE;
	PASPS pasps = (PASPS)(ppsp->lParam);

	// uMsg may be any value.

	ASSERT(! hwnd ||
		IS_VALID_HANDLE(hwnd, WND));

	switch (uMsg)
	{
		case PSPCB_CREATE:
			// from MSDN: A dialog box for a page is being created.
			// Return nonzero to allow it to be created, or zero to prevent it.
			break;

		case PSPCB_RELEASE:
			// ???? need checking if NULL

			pasps->pappshcut->Release();

			// free the ASPS structure, this is created in AddASPS
			// delete only after the ref is removed
			delete pasps;
			ppsp->lParam = NULL;

			break;

		default:
			// ignore other msg - unhandled
			break;
	}

	return(uResult);
}


void SetASPSIcon(HWND hdlg, HICON hicon)
{
	HICON hiconOld;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));
	ASSERT(IS_VALID_HANDLE(hicon, ICON));

	hiconOld = (HICON)SendDlgItemMessage(hdlg, IDD_ICON, STM_SETICON,
		(WPARAM)hicon, 0);

	if (hiconOld)
		DestroyIcon(hiconOld);

	return;
}


void SetASPSFileNameAndIcon(HWND hdlg)
{
	HRESULT hr;
	CAppShortcut* pappshcut;
	WCHAR rgchFile[MAX_PATH];

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pappshcut = ((PASPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pappshcut;

	hr = pappshcut->GetCurFile(rgchFile, sizeof(rgchFile) / sizeof(WCHAR));

	if (hr == S_OK)
	{
		SHFILEINFO shfi;
		DWORD_PTR dwResult;

		dwResult = SHGetFileInfo(rgchFile, 0, &shfi, sizeof(shfi),
			(SHGFI_DISPLAYNAME | SHGFI_ICON));

		if (dwResult)
		{
			LPWSTR pwzFileName;

			pwzFileName = (LPWSTR)ExtractFileName(shfi.szDisplayName);

			EVAL(SetDlgItemText(hdlg, IDD_NAME, pwzFileName));

			SetASPSIcon(hdlg, shfi.hIcon);
		}
		else
		{
			hr = E_FAIL;

		}
	}


	if (hr != S_OK)
		EVAL(SetDlgItemText(hdlg, IDD_NAME, g_cwzEmptyString));

	return;
}


void SetASPSWorkingDirectory(HWND hdlg)
{
	CAppShortcut* pappshcut;
	HRESULT hr;
	WCHAR rgchWorkingDirectory[MAX_PATH];

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pappshcut = ((PASPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pappshcut;

	hr = pappshcut->GetWorkingDirectory(rgchWorkingDirectory,
			sizeof(rgchWorkingDirectory) / sizeof(WCHAR));

	if (hr == S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_START_IN, rgchWorkingDirectory));
	}
	else
	{
		EVAL(SetDlgItemText(hdlg, IDD_START_IN, g_cwzEmptyString));
	}

	return;
}


void InitASPSHotkey(HWND hdlg)
{
	CAppShortcut* pappshcut;
	WORD wHotkey;
	HRESULT hr;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	// Set hotkey combinations.

	SendDlgItemMessage(hdlg, IDD_HOTKEY, HKM_SETRULES,
		(HKCOMB_NONE | HKCOMB_A | HKCOMB_C | HKCOMB_S),
		(HOTKEYF_CONTROL | HOTKEYF_ALT));

	// Set current hotkey.

	pappshcut = ((PASPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pappshcut;

	hr = pappshcut->GetHotkey(&wHotkey);
	SendDlgItemMessage(hdlg, IDD_HOTKEY, HKM_SETHOTKEY, wHotkey, 0);

	return;
}


void InitASPSShowCmds(HWND hdlg)
{
	int niShowCmd;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	for (niShowCmd = IDS_SHOW_NORMAL;
		niShowCmd <= IDS_SHOW_MAXIMIZED;
		niShowCmd++)
	{
		WCHAR rgchShowCmd[s_ucMaxShowCmdLen];

		if (LoadString(g_DllInstance, niShowCmd, rgchShowCmd,	//MLLoadStringA
			s_ucMaxShowCmdLen))//sizeof(rgchShowCmd)))
		{
			SendDlgItemMessage(hdlg, IDD_SHOW_CMD, CB_ADDSTRING, 0,
				(LPARAM)rgchShowCmd);
		}
	}

	return;
}


void SetASPSShowCmd(HWND hdlg)
{
	CAppShortcut* pappshcut;
	int nShowCmd;
	int i;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pappshcut = ((PASPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pappshcut;

	pappshcut->GetShowCmd(&nShowCmd);

	for (i = 0; i < ARRAY_ELEMENTS(s_rgnShowCmds); i++)
	{
		if (s_rgnShowCmds[i] == nShowCmd)
			break;
	}

	if (i >= ARRAY_ELEMENTS(s_rgnShowCmds))
	{
		ASSERT(i == ARRAY_ELEMENTS(s_rgnShowCmds));

		i = 0; // default is 0 == 'normal'
	}

	SendDlgItemMessage(hdlg, IDD_SHOW_CMD, CB_SETCURSEL, i, 0);

	return;
}


void SetASPSDisplayName(HWND hdlg)
{
	CAppShortcut* pappshcut;
	HRESULT hr;
	WCHAR rgchString[DISPLAYNAMESTRINGLENGTH];

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pappshcut = ((PASPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pappshcut;

	hr = pappshcut->GetDisplayName(rgchString, sizeof(rgchString) / sizeof(WCHAR));

	if (hr == S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_DISPLAY_NAME, rgchString));
	}
	else
	{
		EVAL(SetDlgItemText(hdlg, IDD_DISPLAY_NAME, g_cwzEmptyString));
	}

	return;
}


void SetASPSName(HWND hdlg)
{
	CAppShortcut* pappshcut;
	HRESULT hr;
	WCHAR rgchString[NAMESTRINGLENGTH];

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pappshcut = ((PASPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pappshcut;

	hr = pappshcut->GetName(rgchString, sizeof(rgchString) / sizeof(WCHAR));

	if (hr == S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_NAME, rgchString));
	}
	else
	{
		EVAL(SetDlgItemText(hdlg, IDD_NAME, g_cwzEmptyString));
	}

	return;
}


void SetASPSVersion(HWND hdlg)
{
	CAppShortcut* pappshcut;
	HRESULT hr;
	WCHAR rgchString[VERSIONSTRINGLENGTH];

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pappshcut = ((PASPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pappshcut;

	hr = pappshcut->GetVersion(rgchString, sizeof(rgchString) / sizeof(WCHAR));

	if (hr == S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_VERSION, rgchString));
	}
	else
	{
		EVAL(SetDlgItemText(hdlg, IDD_VERSION, g_cwzEmptyString));
	}

	return;
}


void SetASPSCulture(HWND hdlg)
{
	CAppShortcut* pappshcut;
	HRESULT hr;
	WCHAR rgchString[CULTURESTRINGLENGTH];

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pappshcut = ((PASPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pappshcut;

	hr = pappshcut->GetCulture(rgchString, sizeof(rgchString) / sizeof(WCHAR));

	if (hr == S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_CULTURE, rgchString));
	}
	else
	{
		EVAL(SetDlgItemText(hdlg, IDD_CULTURE, g_cwzEmptyString));
	}

	return;
}


void SetASPSPKT(HWND hdlg)
{
	CAppShortcut* pappshcut;
	HRESULT hr;
	WCHAR rgchString[PKTSTRINGLENGTH];

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pappshcut = ((PASPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pappshcut;

	hr = pappshcut->GetPKT(rgchString, sizeof(rgchString) / sizeof(WCHAR));

	if (hr == S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_PKT, rgchString));
	}
	else
	{
		EVAL(SetDlgItemText(hdlg, IDD_PKT, g_cwzEmptyString));
	}

	return;
}


void SetASPSCodebase(HWND hdlg)
{
	CAppShortcut* pappshcut;
	HRESULT hr;
	WCHAR rgchString[MAX_URL_LENGTH];

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pappshcut = ((PASPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pappshcut;

	hr = pappshcut->GetCodebase(rgchString, sizeof(rgchString) / sizeof(WCHAR));

	if (hr == S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_CODEBASE, rgchString));
	}
	else
	{
		EVAL(SetDlgItemText(hdlg, IDD_CODEBASE, g_cwzEmptyString));
	}

	return;
}


void SetASPSEntrypoint(HWND hdlg)
{
	CAppShortcut* pappshcut;
	HRESULT hr;
	WCHAR rgchString[MAX_PATH];

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pappshcut = ((PASPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pappshcut;

	hr = pappshcut->GetPath(rgchString, sizeof(rgchString) / sizeof(WCHAR), NULL, 0);

	if (hr == S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_ENTRYPOINT, rgchString));
	}
	else
	{
		EVAL(SetDlgItemText(hdlg, IDD_ENTRYPOINT, g_cwzEmptyString));
	}

	return;
}


void InitASPSType(HWND hdlg)
{
	int i;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	for (i = IDS_APPTYPE_NETASSEMBLY; i <= IDS_APPTYPE_WIN32EXE; i++)
	{
		WCHAR rgchString[s_ucMaxTypeLen];

		if (LoadString(g_DllInstance, i, rgchString, s_ucMaxTypeLen))//sizeof(rgchShowCmd)))  //MLLoadStringA
		{
			SendDlgItemMessage(hdlg, IDD_TYPE, CB_ADDSTRING, 0, (LPARAM)rgchString);
		}
	}

	return;
}


void SetASPSType(HWND hdlg)
{
	CAppShortcut* pappshcut;
	int nType;
	int i;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pappshcut = ((PASPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pappshcut;

	pappshcut->GetAppType(&nType);

	for (i = 0; i < ARRAY_ELEMENTS(s_rgnType); i++)
	{
		if (s_rgnType[i] == nType)
			break;
	}

	if (i >= ARRAY_ELEMENTS(s_rgnType))
	{
		ASSERT(i == ARRAY_ELEMENTS(s_rgnType));

		// not found! this clears the edit control - there's no default for this
		// note: InjectASPSData has to handle this special case... as CB_ERR...
		i = -1;
	}

	SendDlgItemMessage(hdlg, IDD_TYPE, CB_SETCURSEL, i, 0);

	return;
}


BOOL ASPS_InitDialog(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
	// wparam may be any value.

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	// this set PROPSHEETPAGE struct to DWLP_USER
	SetWindowLongPtr(hdlg, DWLP_USER, lparam);

	// Initialize control contents.

	if (((PASPS)(((PROPSHEETPAGE*)lparam)->lParam))->eCurPage == APPSHCUT_PS_APPSHCUT_PAGE)
	{
		SetASPSFileNameAndIcon(hdlg);

		// note: need limits on all editbox!
		SetASPSDisplayName(hdlg);

		SendDlgItemMessage(hdlg, IDD_CODEBASE, EM_LIMITTEXT, MAX_URL_LENGTH - 1, 0);
		SetASPSCodebase(hdlg);

		InitASPSType(hdlg);
		SetASPSType(hdlg);

		SendDlgItemMessage(hdlg, IDD_ENTRYPOINT, EM_LIMITTEXT, MAX_PATH - 1, 0);
		SetASPSEntrypoint(hdlg);

		SendDlgItemMessage(hdlg, IDD_START_IN, EM_LIMITTEXT, MAX_PATH - 1, 0);
		SetASPSWorkingDirectory(hdlg);

		InitASPSHotkey(hdlg);

		InitASPSShowCmds(hdlg);
		SetASPSShowCmd(hdlg);
	}
	else if (((PASPS)(((PROPSHEETPAGE*)lparam)->lParam))->eCurPage == APPSHCUT_PS_APPREF_PAGE)
	{
		// note: need limits on all editbox!
		SetASPSDisplayName(hdlg);
		SetASPSName(hdlg);
		SetASPSVersion(hdlg);
		SetASPSCulture(hdlg);
		SetASPSPKT(hdlg);
	}
	// else do nothing?

	return(TRUE);
}


BOOL ASPS_Destroy(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
	// ASPSCallback is called after this func. The remaining frees/releases are there

	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	SetWindowLongPtr(hdlg, DWLP_USER, NULL);

	return(TRUE);
}


void ASPSChanged(HWND hdlg)
{
	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	PropSheet_Changed(GetParent(hdlg), hdlg);

	return;
}


HRESULT ChooseIcon(HWND hdlg)
{
	HRESULT hr;
	PASPS pasps;
	CAppShortcut* pappshcut;
	WCHAR rgchTempIconFile[MAX_PATH];
	int niIcon;
	UINT uFlags;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pasps = (PASPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam);
	pappshcut = pasps->pappshcut;

	if (pappshcut->GetIconLocation(0, rgchTempIconFile,
			sizeof(rgchTempIconFile)/sizeof(WCHAR), &niIcon, &uFlags) != S_OK)
	{
		rgchTempIconFile[0] = '\0';
		niIcon = 0;
	}

	ASSERT(wcslen(rgchTempIconFile) < (sizeof(rgchTempIconFile)/sizeof(WCHAR)));

	// a private shell32.dll export (by ordinal)...
	if (PickIconDlg(hdlg, rgchTempIconFile, sizeof(rgchTempIconFile), &niIcon))	//??? sizeof
	{
		ASSERT(wcslen(rgchTempIconFile) < (sizeof(pasps->rgchIconFile)/sizeof(WCHAR)));
		wcscpy(pasps->rgchIconFile, rgchTempIconFile);
		pasps->niIcon = niIcon;

		hr = S_OK;
	}
	else
	{
		hr = E_FAIL;
	}

	return(hr);
}


void UpdateASPSIcon(HWND hdlg)
{
	PASPS pasps;
	HICON hicon;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pasps = (PASPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam);
	ASSERT(pasps->rgchIconFile[0]);

	hicon = ExtractIcon(g_DllInstance, pasps->rgchIconFile, pasps->niIcon);

	if (hicon)
		SetASPSIcon(hdlg, hicon);

	return;
}


BOOL ASPS_Command(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
	BOOL bMsgHandled = FALSE;
	WORD wCmd;

	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	wCmd = HIWORD(wparam);

	switch (LOWORD(wparam))
	{
		case IDD_CODEBASE:
		case IDD_HOTKEY:
		case IDD_ENTRYPOINT:
		case IDD_START_IN:
		case IDD_DISPLAY_NAME:
		case IDD_NAME:
		case IDD_VERSION:
		case IDD_CULTURE:
		case IDD_PKT:
				if (wCmd == EN_CHANGE)
				{
					ASPSChanged(hdlg);

					bMsgHandled = TRUE;
				}
				break;

		case IDD_SHOW_CMD:
		case IDD_TYPE:
				if (wCmd == LBN_SELCHANGE)
				{
					ASPSChanged(hdlg);

					bMsgHandled = TRUE;
				}
				break;

		case IDD_CHANGE_ICON:
				// Ignore return value.
				if (ChooseIcon(hdlg) == S_OK)
				{
					UpdateASPSIcon(hdlg);
					ASPSChanged(hdlg);
				}
				bMsgHandled = TRUE;
				break;

		default:
				break;
	}

	return(bMsgHandled);
}


HRESULT InjectASPSData(HWND hdlg)
{
	// BUGBUG: TODO: this function should validate the user's changes...

	HRESULT hr = S_OK;
	PASPS pasps;
	CAppShortcut* pappshcut;
	LPWSTR pwzURL;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pasps = (PASPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam);
	pappshcut = pasps->pappshcut;

	return(hr);
}


HRESULT ASPSSave(HWND hdlg)
{
	HRESULT hr;
	CAppShortcut* pappshcut;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pappshcut = ((PASPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pappshcut;

	if (pappshcut->IsDirty() == S_OK)
	{
		// BUGBUG: TODO: IPersistFile::Save is not implemented
		hr = pappshcut->Save((LPCOLESTR)NULL, FALSE);
	}
	else
	{
		hr = S_OK;
	}

	return(hr);
}


BOOL ASPS_Notify(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
	BOOL bMsgHandled = FALSE;

	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	switch (((NMHDR*)lparam)->code)
	{
		case PSN_APPLY:
			SetWindowLongPtr(hdlg, DWLP_MSGRESULT, ASPSSave(hdlg) == S_OK ?
			                PSNRET_NOERROR :
			                PSNRET_INVALID_NOCHANGEPAGE);
			bMsgHandled = TRUE;
			break;

		case PSN_KILLACTIVE:
			SetWindowLongPtr(hdlg, DWLP_MSGRESULT, FAILED(InjectASPSData(hdlg)));
			bMsgHandled = TRUE;
			break;

		default:
			break;
	}

	return(bMsgHandled);
}


INT_PTR CALLBACK ASPS_DlgProc(HWND hdlg, UINT uMsg, WPARAM wparam,
                    LPARAM lparam)
{
	INT_PTR bMsgHandled = FALSE;

	// uMsg may be any value.
	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	switch (uMsg)
	{
		case WM_INITDIALOG:
			bMsgHandled = ASPS_InitDialog(hdlg, wparam, lparam);
			break;

		case WM_DESTROY:
			bMsgHandled = ASPS_Destroy(hdlg, wparam, lparam);
			break;

		case WM_COMMAND:
			bMsgHandled = ASPS_Command(hdlg, wparam, lparam);
			break;

		case WM_NOTIFY:
			bMsgHandled = ASPS_Notify(hdlg, wparam, lparam);
			break;

		default:
			break;
	}

	return(bMsgHandled);
}


HRESULT AddASPS(CAppShortcut* pappshcut,
                 LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lparam)
{
	HRESULT hr = S_OK;
	PASPS pasps;
	PROPSHEETPAGE psp;
	HPROPSHEETPAGE hpsp;

	PASPS pasps2;
	PROPSHEETPAGE psp2;
	HPROPSHEETPAGE hpsp2;

	// lparam may be any value.

	// this is deleted in ASPSCallback
	pasps = new ASPS;
	ZeroMemory(pasps, sizeof(*pasps));

	psp.dwSize = sizeof(psp);
	psp.dwFlags = (PSP_DEFAULT | PSP_USECALLBACK);
	psp.hInstance = g_DllInstance; //MLGetHinst();
	psp.pszTemplate = MAKEINTRESOURCE(DLG_APP_SHORTCUT_PROP_SHEET);
	psp.pfnDlgProc = &ASPS_DlgProc;
	psp.pfnCallback = &ASPSCallback;
	psp.lParam = (LPARAM)pasps;
	psp.hIcon = 0;			// not used
	psp.pszTitle = NULL;	// not used
	psp.pcRefParent = 0;	// not used

	pasps->pappshcut = pappshcut;
	pasps->eCurPage = APPSHCUT_PS_APPSHCUT_PAGE; // page 1

	// will psp be copied in this func? else this won't work...!!????????
	hpsp = CreatePropertySheetPage(&psp);

	if (hpsp)
	{
		if ((*pfnAddPage)(hpsp, lparam))
		{
			pappshcut->AddRef();
		}
		else
		{
			DestroyPropertySheetPage(hpsp);
			hr = E_FAIL;
			goto exit;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}

	// this is deleted in ASPSCallback
	pasps2 = new ASPS;
	ZeroMemory(pasps2, sizeof(*pasps2));

	psp2.dwSize = sizeof(psp2);
	psp2.dwFlags = (PSP_DEFAULT | PSP_USECALLBACK);
	psp2.hInstance = g_DllInstance; //MLGetHinst();
	psp2.pszTemplate = MAKEINTRESOURCE(DLG_APP_SHORTCUT_PROP_SHEET_APPNAME);
	psp2.pfnDlgProc = &ASPS_DlgProc;
	psp2.pfnCallback = &ASPSCallback;
	psp2.lParam = (LPARAM)pasps2;
	psp2.hIcon = 0;			// not used
	psp2.pszTitle = NULL;	// not used
	psp2.pcRefParent = 0;	// not used

	pasps2->pappshcut = pappshcut;
	pasps2->eCurPage = APPSHCUT_PS_APPREF_PAGE; // page 2

	// will psp be copied in this func? else this won't work...!!????????
	hpsp2 = CreatePropertySheetPage(&psp2);

	if (hpsp2)
	{
		if ((*pfnAddPage)(hpsp2, lparam))
		{
			pappshcut->AddRef();
		}
		else
		{
			DestroyPropertySheetPage(hpsp2);
			hr = E_FAIL;
			goto exit;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}

exit:
	return(hr);
}


/****************************** Public Functions *****************************/


BOOL RegisterGlobalHotkey(WORD wOldHotkey, WORD wNewHotkey,
                      LPCWSTR pcwzPath)
{
	// BUGBUG?: does this work??

	BOOL bResult = FALSE;
	HWND hwndTray;

	ASSERT(! wOldHotkey || IsValidHotkey(wOldHotkey));
	ASSERT(! wNewHotkey || IsValidHotkey(wNewHotkey));
	ASSERT(IsValidPath(pcwzPath));

	hwndTray = FindWindow(s_cwzTrayNotificationClass, 0);

	if (hwndTray)
	{
		if (wOldHotkey)
		{
			SendMessage(hwndTray, WMTRAY_SCUNREGISTERHOTKEY, wOldHotkey, 0);
		}

		if (wNewHotkey)
		{
			ATOM atom = GlobalAddAtom(pcwzPath);
			ASSERT(atom);
			if (atom)
			{
				SendMessage(hwndTray, WMTRAY_SCREGISTERHOTKEY, wNewHotkey, (LPARAM)atom);
				GlobalDeleteAtom(atom);
			}
		}

		bResult = TRUE;
	}
	/*else
	{
		bResult = FALSE;
	}*/

	return(bResult);
}

/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE CAppShortcut::Initialize(LPCITEMIDLIST pcidlFolder,
                              IDataObject* pido,
                              HKEY hkeyProgID)
{
	HRESULT hr;
	STGMEDIUM stgmed;
	FORMATETC fmtetc = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
	ASSERT(NULL != pido);
	ASSERT(IS_VALID_HANDLE(hkeyProgID, KEY));

	hr = pido->GetData(&fmtetc, &stgmed);
	if (hr == S_OK)
	{
		WCHAR wzPath[MAX_PATH];
		if (DragQueryFile((HDROP)stgmed.hGlobal, 0, wzPath, sizeof(wzPath)/sizeof(*wzPath)))
		{
			//mode is ignored for now
			hr = Load(wzPath, 0);
		}
		// else path len > MAX_PATH or other error

		ReleaseStgMedium(&stgmed);
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage,
                         LPARAM lparam)
{
	HRESULT hr;

	// lparam may be any value.

	hr = AddASPS(this, pfnAddPage, lparam);

	// BUGBUG: why this does not work?
	// From MSDN:
	//With version 4.71 and later, you can request that a particular property
	//sheet page be displayed first, instead of the default page. To do so,
	//return the one-based index of the desired page. For example, if you
	//want the second of three pages displayed, the return value should be 2.
	//Note that this return value is a request. The property sheet may still
	//display the default page. --> see doc for AddPages()
	if (SUCCEEDED(hr))
		hr = HRESULT(4); // or 3??

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::ReplacePage(UINT uPageID,
                      LPFNADDPROPSHEETPAGE pfnReplaceWith,
                      LPARAM lparam)
{
	HRESULT hr;

	// lparam may be any value.
	// uPageID may be any value.

	hr = E_NOTIMPL;

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::SetDisplayName(LPCWSTR pcwzDisplayName)
{
	// BUGBUG: not much checking is done!

	BOOL bChanged = FALSE;
	LPWSTR pwzOriString = NULL;
	LPWSTR pwzNewString = (LPWSTR) pcwzDisplayName;

	ASSERT(! pwzNewString);

	if (!m_pappRefInfo)
		return (E_FAIL);

	pwzOriString = m_pappRefInfo->_wzDisplayName;

	// ... this checks if all space in string...
	if (! AnyNonWhiteSpace(pwzNewString))
		pwzNewString = NULL;

	bChanged = ! ((! pwzNewString && ! pwzOriString) ||
				(pwzNewString && pwzOriString &&
				 ! wcscmp(pwzNewString, pwzOriString)));

	if (bChanged)
	{
		if (pwzNewString)
		{
			wcsncpy(pwzOriString, pwzNewString, DISPLAYNAMESTRINGLENGTH-1);
			pwzOriString[DISPLAYNAMESTRINGLENGTH-1] = L'\0';
		}
		else
			pwzOriString[0] = L'\0';

		Dirty(TRUE);
	}

	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::GetDisplayName(LPWSTR pwzDisplayName, int ncbLen)
{
	HRESULT hr;

	if (!m_pappRefInfo)
		return (E_FAIL);

	if (m_pappRefInfo->_wzDisplayName)
	{
		if ((int) wcslen(m_pappRefInfo->_wzDisplayName) < ncbLen)
		{
			wcsncpy(pwzDisplayName, m_pappRefInfo->_wzDisplayName, ncbLen-1);
			pwzDisplayName[ncbLen-1] = L'\0';

			hr = S_OK;
		}
		else
			hr = E_FAIL;
	}
	else
	{
		if (ncbLen > 0)
			pwzDisplayName = L'\0';

		hr = S_FALSE;
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::SetName(LPCWSTR pcwzName)
{
	// BUGBUG: not much checking is done!

	BOOL bChanged = FALSE;
	LPWSTR pwzOriString = NULL;
	LPWSTR pwzNewString = (LPWSTR) pcwzName;

	ASSERT(! pwzNewString);

	if (!m_pappRefInfo)
		return (E_FAIL);

	pwzOriString = m_pappRefInfo->_wzName;
   
	// ... this checks if all space in string...
	if (! AnyNonWhiteSpace(pwzNewString))
		pwzNewString = NULL;

	bChanged = ! ((! pwzNewString && ! pwzOriString) ||
		(pwzNewString && pwzOriString &&
		! wcscmp(pwzNewString, pwzOriString)));

	if (bChanged)
	{
		if (pwzNewString)
		{
			wcsncpy(pwzOriString, pwzNewString, NAMESTRINGLENGTH-1);
			pwzOriString[NAMESTRINGLENGTH-1] = L'\0';
		}
		else
			pwzOriString[0] = L'\0';

		Dirty(TRUE);
	}

	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::GetName(LPWSTR pwzName, int ncbLen)
{
	HRESULT hr;

	if (!m_pappRefInfo)
		return (E_FAIL);

	if (m_pappRefInfo->_wzName)
	{
		if ((int) wcslen(m_pappRefInfo->_wzName) < ncbLen)
		{
			wcsncpy(pwzName, m_pappRefInfo->_wzName, ncbLen-1);
			pwzName[ncbLen-1] = L'\0';

			hr = S_OK;
		}
		else
			hr = E_FAIL;
	}
	else
	{
		if (ncbLen > 0)
			pwzName = L'\0';

		hr = S_FALSE;
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::SetVersion(LPCWSTR pcwzVersion)
{
	// BUGBUG: not much checking is done!

	BOOL bChanged = FALSE;
	LPWSTR pwzOriString = NULL;
	LPWSTR pwzNewString = (LPWSTR) pcwzVersion;

	ASSERT(! pwzNewString);

	if (!m_pappRefInfo)
		return (E_FAIL);

	pwzOriString = m_pappRefInfo->_wzVersion;
   
	// ... this checks if all space in string...
	if (! AnyNonWhiteSpace(pwzNewString))
		pwzNewString = NULL;

	bChanged = ! ((! pwzNewString && ! pwzOriString) ||
		(pwzNewString && pwzOriString &&
		! wcscmp(pwzNewString, pwzOriString)));

	if (bChanged)
	{
		if (pwzNewString)
		{
			wcsncpy(pwzOriString, pwzNewString, VERSIONSTRINGLENGTH-1);
			pwzOriString[VERSIONSTRINGLENGTH-1] = L'\0';
		}
		else
			pwzOriString[0] = L'\0';

		Dirty(TRUE);
	}

	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::GetVersion(LPWSTR pwzVersion, int ncbLen)
{
	HRESULT hr;

	if (!m_pappRefInfo)
		return (E_FAIL);

	if (m_pappRefInfo->_wzVersion)
	{
		if ((int) wcslen(m_pappRefInfo->_wzVersion) < ncbLen)
		{
			wcsncpy(pwzVersion, m_pappRefInfo->_wzVersion, ncbLen-1);
			pwzVersion[ncbLen-1] = L'\0';

			hr = S_OK;
		}
		else
			hr = E_FAIL;
	}
	else
	{
		if (ncbLen > 0)
			pwzVersion = L'\0';

		hr = S_FALSE;
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::SetCulture(LPCWSTR pcwzCulture)
{
	// BUGBUG: not much checking is done!

	BOOL bChanged = FALSE;
	LPWSTR pwzOriString = NULL;
	LPWSTR pwzNewString = (LPWSTR) pcwzCulture;

	ASSERT(! pwzNewString);

	if (!m_pappRefInfo)
		return (E_FAIL);

	pwzOriString = m_pappRefInfo->_wzCulture;

	// ... this checks if all space in string...
	if (! AnyNonWhiteSpace(pwzNewString))
		pwzNewString = NULL;

	bChanged = ! ((! pwzNewString && ! pwzOriString) ||
				(pwzNewString && pwzOriString &&
				! wcscmp(pwzNewString, pwzOriString)));

	if (bChanged)
	{
		if (pwzNewString)
		{
			wcsncpy(pwzOriString, pwzNewString, CULTURESTRINGLENGTH-1);
			pwzOriString[CULTURESTRINGLENGTH-1] = L'\0';
		}
		else
			pwzOriString[0] = L'\0';

		Dirty(TRUE);
	}

	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::GetCulture(LPWSTR pwzCulture, int ncbLen)
{
	HRESULT hr;

	if (!m_pappRefInfo)
		return (E_FAIL);

	if (m_pappRefInfo->_wzCulture)
	{
		if ((int) wcslen(m_pappRefInfo->_wzCulture) < ncbLen)
		{
			wcsncpy(pwzCulture, m_pappRefInfo->_wzCulture, ncbLen-1);
			pwzCulture[ncbLen-1] = L'\0';

			hr = S_OK;
		}
		else
			hr = E_FAIL;
	}
	else
	{
		if (ncbLen > 0)
			pwzCulture = L'\0';

		hr = S_FALSE;
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::SetPKT(LPCWSTR pcwzPKT)
{
	// BUGBUG: not much checking is done!

	BOOL bChanged = FALSE;
	LPWSTR pwzOriString = NULL;
	LPWSTR pwzNewString = (LPWSTR) pcwzPKT;

	ASSERT(! pwzNewString);

	if (!m_pappRefInfo)
		return (E_FAIL);

	pwzOriString = m_pappRefInfo->_wzPKT;

	// ... this checks if all space in string...
	if (! AnyNonWhiteSpace(pwzNewString))
		pwzNewString = NULL;

	bChanged = ! ((! pwzNewString && ! pwzOriString) ||
			(pwzNewString && pwzOriString &&
			 ! wcscmp(pwzNewString, pwzOriString)));

	if (bChanged)
	{
		if (pwzNewString)
		{
			wcsncpy(pwzOriString, pwzNewString, PKTSTRINGLENGTH-1);
			pwzOriString[PKTSTRINGLENGTH-1] = L'\0';
		}
		else
			pwzOriString[0] = L'\0';

		Dirty(TRUE);
	}

	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::GetPKT(LPWSTR pwzPKT, int ncbLen)
{
	HRESULT hr;

	if (!m_pappRefInfo)
		return (E_FAIL);

	if (m_pappRefInfo->_wzPKT)
	{
		if ((int) wcslen(m_pappRefInfo->_wzPKT) < ncbLen)
		{
			wcsncpy(pwzPKT, m_pappRefInfo->_wzPKT, ncbLen-1);
			pwzPKT[ncbLen-1] = L'\0';

			hr = S_OK;
		}
		else
			hr = E_FAIL;
	}
	else
	{
		if (ncbLen > 0)
			pwzPKT = L'\0';

		hr = S_FALSE;
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::SetCodebase(LPCWSTR pcwzCodebase)
{
	// BUGBUG: not much checking is done!

	BOOL bChanged = FALSE;
	LPWSTR pwzOriString = NULL;
	LPWSTR pwzNewString = (LPWSTR) pcwzCodebase;

	ASSERT(! pwzNewString);

	if (!m_pappRefInfo)
		return (E_FAIL);

	pwzOriString = m_pappRefInfo->_wzCodebase;
   
	// ... this checks if all space in string...
	if (! AnyNonWhiteSpace(pwzNewString))
		pwzNewString = NULL;

	bChanged = ! ((! pwzNewString && ! pwzOriString) ||
				(pwzNewString && pwzOriString &&
				! wcscmp(pwzNewString, pwzOriString)));

	if (bChanged)
	{
		if (pwzNewString)
		{
			wcsncpy(pwzOriString, pwzNewString, MAX_URL_LENGTH-1);
			pwzOriString[MAX_URL_LENGTH-1] = L'\0';
		}
		else
			pwzOriString[0] = L'\0';

		Dirty(TRUE);
	}

	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::GetCodebase(LPWSTR pwzCodebase, int ncbLen)
{
	HRESULT hr;

	if (!m_pappRefInfo)
		return (E_FAIL);

	if (m_pappRefInfo->_wzCodebase)
	{
		if ((int) wcslen(m_pappRefInfo->_wzCodebase) < ncbLen)
		{
			wcsncpy(pwzCodebase, m_pappRefInfo->_wzCodebase, ncbLen-1);
			pwzCodebase[ncbLen-1] = L'\0';

			hr = S_OK;
		}
		else
			hr = E_FAIL;
	}
	else
	{
		if (ncbLen > 0)
			pwzCodebase = L'\0';

		hr = S_FALSE;
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::SetAppType(int nAppType)
{
	if (!m_pappRefInfo)
		return (E_FAIL);

	if (nAppType != m_pappRefInfo->_fAppType)
	{
		m_pappRefInfo->_fAppType = nAppType;

		Dirty(TRUE);
	}

	return(S_OK);
}

HRESULT STDMETHODCALLTYPE CAppShortcut::GetAppType(PINT pnAppType)
{
	if (!m_pappRefInfo)
		return (E_FAIL);

	*pnAppType = m_pappRefInfo->_fAppType;

	return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\shortcut\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by applc.rc
//
#define IDD_NAME                        200
#define IDD_HOTKEY                      1000
#define IDD_START_IN                    3002
#define IDD_ICON                        3301
#define IDD_LINE_1                      3327
#define IDD_LINE_2                      3328
#define IDD_CHANGE_ICON                 3407
#define IDD_SHOW_CMD                    3408
#define IDC_STATIC                      -1
#define DLG_APP_SHORTCUT_PROP_SHEET_APPNAME 101
#define IDD_CODEBASE                    1001
#define IDD_VERSION                     1002
#define IDD_CULTURE                     1003
#define DLG_APP_SHORTCUT_PROP_SHEET     1040
#define IDD_TYPE                        3303
#define IDD_ENTRYPOINT                  3304
#define IDD_DISPLAY_NAME                3305
#define IDD_PKT                         3306
#define IDS_APPTYPE_NETASSEMBLY			3307 // # must be in order
#define IDS_APPTYPE_WIN32EXE			3308
#define IDS_SHOW_NORMAL                 1 // # must be in order
#define IDS_SHOW_MINIMIZED              2
#define IDS_SHOW_MAXIMIZED              3
#define IDS_TIP_NAME                      4
#define IDS_TIP_TYPE                      5
#define IDS_TIP_LOCATION                  6
#define IDS_TIP_CODEBASE                 7

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\warning.h ===
#pragma warning(disable:4511) /* copy constructor could not be generated */
#pragma warning(disable:4663) /* template syntax change for explicit specification */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\shortcut\util.cpp ===
#include "project.hpp"

// * note: debug check/code incomplete.

// ----------------------------------------------------------------------------

//
// Return last Win32 error as an HRESULT.
//
HRESULT
GetLastWin32Error()
{
    // Win 95 can return 0, even when there's an error.
    DWORD dw = GetLastError();
    return dw ? HRESULT_FROM_WIN32(dw) : E_FAIL;
}

// ----------------------------------------------------------------------------

/*----------------------------------------------------------
Purpose: Returns an integer value specifying the length of
         the substring in psz that consists entirely of 
         characters in pszSet.  If psz begins with a character
         not in pszSet, then this function returns 0.

         This is a DBCS-safe version of the CRT strspn().  

Returns: see above
Cond:    --
*/
/*int StrSpnW(LPCWSTR psz, LPCWSTR pszSet)
{
	LPCWSTR pszT;
	LPCWSTR pszSetT;

	ASSERT(psz);
	ASSERT(pszSet);

	// Go thru the string to be inspected 

	for (pszT = psz; *pszT; pszT++)
    {
	    // Go thru the char set

	    for (pszSetT = pszSet; *pszSetT != *pszT; pszSetT++)
	    {
	        if (0 == *pszSetT)
	        {
	            // Reached end of char set without finding a match
	            return (int)(pszT - psz);
	        }
	    }
    }

	return (int)(pszT - psz);
}*/

// find leading spaces
BOOL AnyNonWhiteSpace(PCWSTR pcwz)
{
   ASSERT(! pcwz );

   return(pcwz ? wcsspn(pcwz, g_cwzWhiteSpace) < wcslen(pcwz) : FALSE);	// use (size_t) StrSpnW as above?
}

// ----------------------------------------------------------------------------

BOOL IsValidPath(PCWSTR pcwzPath)
{
   // FEATURE: Beef up path validation.

   return(EVAL((UINT)wcslen(pcwzPath) < MAX_PATH));
}

BOOL IsValidPathResult(HRESULT hr, PCWSTR pcwzPath,
                                   UINT ucbPathBufLen)
{
   return((hr == S_OK &&
           EVAL(IsValidPath(pcwzPath)) &&
           EVAL((UINT)wcslen(pcwzPath) < ucbPathBufLen)) ||
          (hr != S_OK &&
           EVAL(! ucbPathBufLen ||
                ! pcwzPath ||
                ! *pcwzPath)));
}

BOOL IsValidIconIndex(HRESULT hr, PCWSTR pcwzIconFile,
                                  UINT ucbIconFileBufLen, int niIcon)
{
   return(EVAL(IsValidPathResult(hr, pcwzIconFile, ucbIconFileBufLen)) &&
          EVAL(hr == S_OK ||
               ! niIcon));
}

// ----------------------------------------------------------------------------

BOOL IsValidHWND(HWND hwnd)
{
   // Ask User if this is a valid window.

   return(IsWindow(hwnd));
}

#ifdef DEBUG

BOOL IsValidHANDLE(HANDLE hnd)
{
   return(EVAL(hnd != INVALID_HANDLE_VALUE));
}

BOOL IsValidHEVENT(HANDLE hevent)
{
   return(IsValidHANDLE(hevent));
}

BOOL IsValidHFILE(HANDLE hf)
{
   return(IsValidHANDLE(hf));
}

BOOL IsValidHGLOBAL(HGLOBAL hg)
{
   return(IsValidHANDLE(hg));
}

BOOL IsValidHMENU(HMENU hmenu)
{
   return(IsValidHANDLE(hmenu));
}

BOOL IsValidHINSTANCE(HINSTANCE hinst)
{
   return(IsValidHANDLE(hinst));
}

BOOL IsValidHICON(HICON hicon)
{
   return(IsValidHANDLE(hicon));
}

BOOL IsValidHKEY(HKEY hkey)
{
   return(IsValidHANDLE(hkey));
}

BOOL IsValidHMODULE(HMODULE hmod)
{
   return(IsValidHANDLE(hmod));
}

BOOL IsValidHPROCESS(HANDLE hprocess)
{
   return(IsValidHANDLE(hprocess));
}

BOOL IsValidHTEMPLATEFILE(HANDLE htf)
{
   return(IsValidHANDLE(htf));
}

BOOL IsValidShowCmd(int nShow)
{
   BOOL bResult;

   switch (nShow)
   {
      case SW_HIDE:
      case SW_MINIMIZE:
      case SW_MAXIMIZE:
      case SW_RESTORE:
      case SW_SHOW:
      case SW_SHOWNORMAL:
      case SW_SHOWDEFAULT:
      case SW_SHOWMINIMIZED:
      case SW_SHOWMAXIMIZED:
      case SW_SHOWNOACTIVATE:
      case SW_SHOWMINNOACTIVE:
      case SW_SHOWNA:
      case SW_FORCEMINIMIZE:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidShowCmd(): Invalid show command %d.",
                    nShow));
         break;
   }

   return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\shortcut\version.h ===
/**
 * Version strings for Project App Shortcut
 * 
 * Copyright (c) 2001 Microsoft Corporation
 */

// Standard version includes

#pragma once

#include <winver.h>
#include <ntverp.h>

//
// APP Version
//
// Version numbers can be assigned in newbuild.cmd
//

#ifndef APP_VER_MAJORVERSION
#define APP_VER_MAJORVERSION 1
#endif

#ifndef APP_VER_MINORVERSION
#define APP_VER_MINORVERSION 0
#endif

#ifndef APP_VER_PRODUCTBUILD
#define APP_VER_PRODUCTBUILD 0
#endif

#ifndef APP_VER_PRODUCTBUILD_QFE
#define APP_VER_PRODUCTBUILD_QFE 0
#endif

//
// Allow a component to override values in individual rc files
// by checking if these are already defined
//
#ifndef APP_VER_PRODUCTNAME_STR
#define APP_VER_PRODUCTNAME_STR      "Microsoft (R) Application Shortcut Support"
#endif

#ifndef APP_VER_INTERNALNAME_STR
#define APP_VER_INTERNALNAME_STR     "APPSC"
#endif

// the followings are defined in individual RC files:
//      APP_VER_ORIGINALFILENAME_STR
//      APP_VER_FILEDESCRIPTION_STR

//
// Don't edit the remainder of this file to change version values.
// Edit above instead.
//

#if APPBLDTYPE_FREE
#define APP_BLDTYPE_STR     "Free"
#elif APPBLDTYPE_ICECAP
#define APP_BLDTYPE_STR     "Icecap"
#elif APPBLDTYPE_RETAIL
#define APP_BLDTYPE_STR     "Retail"
#else //APPBLDTYPE_DEBUG
#define APP_BLDTYPE_STR     "Debug"
#endif

//
// undefine these values as some are defined in sdk\inc\ntverp.h
//

#ifdef VER_MAJORVERSION
#undef VER_MAJORVERSION
#endif

#ifdef VER_MINORVERSION
#undef VER_MINORVERSION
#endif

#ifdef VER_PRODUCTBUILD
#undef VER_PRODUCTBUILD
#endif

#ifdef VER_PRODUCTBUILD_QFE
#undef VER_PRODUCTBUILD_QFE
#endif

#ifdef VER_PRODUCTNAME_STR
#undef VER_PRODUCTNAME_STR
#endif

#ifdef VER_INTERNALNAME_STR
#undef VER_INTERNALNAME_STR
#endif

#ifdef VER_ORIGINALFILENAME_STR
#undef VER_ORIGINALFILENAME_STR
#endif

#ifdef VER_FILEDESCRIPTION_STR
#undef VER_FILEDESCRIPTION_STR
#endif

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif

#ifdef VER_FILEVERSION_STR
#undef VER_FILEVERSION_STR
#endif

#ifdef VER_FILEVERSION
#undef VER_FILEVERSION
#endif

#ifdef VER_FILETYPE
#undef VER_FILETYPE
#endif

#ifdef VER_FILESUBTYPE
#undef VER_FILESUBTYPE
#endif

#define VER_MAJORVERSION         APP_VER_MAJORVERSION
#define VER_MINORVERSION         APP_VER_MINORVERSION
#define VER_PRODUCTBUILD         APP_VER_PRODUCTBUILD
#define VER_PRODUCTBUILD_QFE     APP_VER_PRODUCTBUILD_QFE

#define VER_PRODUCTNAME_STR      APP_VER_PRODUCTNAME_STR
#define VER_INTERNALNAME_STR     APP_VER_INTERNALNAME_STR
#define VER_ORIGINALFILENAME_STR APP_VER_ORIGINALFILENAME_STR
#define VER_FILEDESCRIPTION_STR  APP_VER_FILEDESCRIPTION_STR

#define CONCAT5HELPER(a, b, c, d, e)      #a "." #b "." #c "." #d " " e
#define CONCAT5(a, b, c, d, e)            CONCAT5HELPER(a, b, c, d, e)

#define CONCAT5HELPER_L(a, b, c, d, e)    L ## #a L"." L ## #b L"." L ## #c L"." L ## #d L" " L ## e
#define CONCAT5_L(a, b, c, d, e)          CONCAT5HELPER_L(a, b, c, d, e)

#define VER_PRODUCTVERSION_STR   CONCAT5(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, APP_BLDTYPE_STR)
#define VER_PRODUCTVERSION_STR_L CONCAT5_L(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, APP_BLDTYPE_STR)

#define VER_PRODUCTVERSION       VER_MAJORVERSION,VER_MINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#define VER_FILEVERSION_STR      CONCAT5(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, APP_BLDTYPE_STR)
#define VER_FILEVERSION_STR_L    CONCAT5_L(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, APP_BLDTYPE_STR)

#define VER_FILEVERSION          VER_MAJORVERSION,VER_MINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          VFT2_UNKNOWN
//#define VER_FILESUBTYPE             VFT_UNKNOWN


// Standard NT build defines

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\sources.inc ===
all_hack: all

RELATIVE_DEPTH=..\$(RELATIVE_DEPTH)
TARGETPATH=obj

# This goes along with the binplace alternative formerly used.
#TARGETPATH=$(RELATIVE_DEPTH)obj

USE_MSVCRT=1
USE_NATIVE_EH=1
MSC_WARNING_LEVEL=-W4 -WX

ATL_VER=30
USE_STATIC_ATL=1

FUSION_PATH=$(BASEDIR)\base\win32\fusion
SXAPW_PATH=$(FUSION_PATH)\appweek

SXAPW_LIB_PATH=$(SXAPW_PATH)\$(O)
SXAPW_LIB_LIB=$(SXAPW_PATH)\common\$(O)\sxapwlib.lib
SXAPW_STDINC_LIB=$(SXAPW_PATH)\stdinc\$(O)\sxapwstdinc.lib
SXAPW_GUIDS_LIB=$(SXAPW_PATH)\idl\$(O)\sxapwguids.lib

#
# This would put all binaries in the same directory, which has its good points.
#
#SXAPW_LIB_PATH_DEST=$(SXAPW_PATH)\obj
#SXAPW_LIB_LIB=$(SXAPW_LIB_PATH_DEST)\sxapwlib.lib
#SXAPW_STDINC_LIB=$(SXAPW_LIB_PATH_DEST)\sxapwstdinc.lib
#SXAPW_GUIDS_LIB=$(SXAPW_LIB_PATH_DEST)\sxapwguids.lib

#
# Use binplace to "union" the files into the same directories, because
# that way we can do "category binds" based on subdirectories off the .exe,
# but then we do a little funky so that the symbols are next to the next binaries.
#
BINPLACE_PLACEFILE=$(SXAPW_PATH)\placefil.txt
_NTTREE=$(SXAPW_PATH).ignore
_NTTREE_NO_SPLIT=$(SXAPW_PATH)

DLLENTRY=SxApwDllMain

PROJECT_COMPILER_WARNINGS = -FI$(FUSION_PATH)\fusionwarnings.h -FI$(SXAPW_PATH)\warning.h

#
# Avoid ever putting generated files next to sources.
# Always put generated sources in processor specific obj directories.
# Don't put them in processor independent directories, so you can to concurrent builds.
#
MIDL_TLBDIR=$(O)
PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

INCLUDES=\
 $(SXAPW_PATH)\inc;\
 $(SXAPW_PATH)\idl;\
 $(SXAPW_PATH)\idl\$(O);\
 $(O); \

PRECOMPILED_OPTION=/Yustdinc.h /Fp$(SXAPW_PATH)\stdinc\$(O)\stdinc.pch
PRECOMPILED_TARGET=$(SXAPW_PATH)\stdinc\$(O)\stdinc.pch
PRECOMPILED_CXX=1

SXS_NO_BINPLACE=1

#
# Jon found that clean builds were deleting the shared .pch but not
# recreating them. This addresses that, and other build.exe shortcomings..
# (building from below the root doesn't build dependencies).
#
!if "$(TARGETNAME)"!="sxapwstdinc"
$(SXAPW_PATH)\stdinc\$(O)\stdinc.pch $(SXAPW_STDINC_LIB):
    cd $(SXAPW_PATH)\stdinc && build -Z
!endif

!if "$(TARGETNAME)"!="sxapwguids"
$(SXAPW_GUIDS_LIB) :
    cd $(SXAPW_PATH)\idl && build -Z
!endif

!if "$(TARGETNAME)"!="sxapwlib"
$(SXAPW_LIB_LIB):
    cd $(SXAPW_PATH)\common && build -Z
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\common\context.cpp ===
#include "stdinc.h"

HRESULT SxApwHmoduleFromAddress(void* p, HMODULE* phModule)
{
    HRESULT hr = S_OK;
    MEMORY_BASIC_INFORMATION mbi;
    SIZE_T size;

    size = VirtualQuery(p, &mbi, sizeof(mbi));
    if (size < sizeof(mbi))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    *phModule = (HMODULE)mbi.AllocationBase;
Exit:
    return hr;
}

HRESULT SxApwHmoduleFromObject(IUnknown* punk, HMODULE* phModule)
/*
This assumes no marshaling!
*/
{
    return SxApwHmoduleFromAddress(*reinterpret_cast<void**>(punk), phModule);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\app\manifest\util\shortcut\shlink.cpp ===
/*
 * shlink.cpp - IShellLink implementation for CAppShortcut class.
 */


// note: BUGBUG?
// from MSDN, it's unclear that for the GetX methods the len arguments
// are counting the terminating NULL or not.
// "size of the buffer pointed by szX"
// so here, and other methods, assume they do -ie. wcslen(s) + L'\0'

/* Headers
 **********/

#include "project.hpp"

/* Types
 ********/

/*typedef enum isl_getpath_flags
{
   // flag combinations

   ALL_ISL_GETPATH_FLAGS   = (SLGP_SHORTPATH |
                              SLGP_UNCPRIORITY)
}
ISL_GETPATH_FLAGS;*/

/*
** FullyQualifyPath()
**
** Fully qualifies a path.
**
** Arguments:
**
** Returns:       S_OK
**
**               E_FILE_NOT_FOUND
**               HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
**
** Side Effects:  none
*/
HRESULT FullyQualifyPath(LPCWSTR pcwzPath,
                                     LPWSTR pwzFullyQualifiedPath,
                                     UINT ucFullyQualifiedPathBufLen)
{
	HRESULT hr = E_FILE_NOT_FOUND;
	PWSTR pszFileName = NULL;
	DWORD dwLen = 0;
		
	if (!pcwzPath || !pwzFullyQualifiedPath || ucFullyQualifiedPathBufLen == 0)
		goto exit;

	// Any path separators?

	if (! wcspbrk(pcwzPath, g_cwzPathSeparators))
	{
		// No.  Search for file.
		dwLen = SearchPath(NULL, pcwzPath, NULL, ucFullyQualifiedPathBufLen,
				pwzFullyQualifiedPath, &pszFileName);

		if (dwLen > ucFullyQualifiedPathBufLen)
		{
			hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		}
		else if (dwLen > 0)
		{
			hr = S_OK;
		}
	}

	if (hr != S_OK)
	{
		dwLen = GetFullPathName(pcwzPath, ucFullyQualifiedPathBufLen,
				pwzFullyQualifiedPath, &pszFileName);

		if (dwLen > ucFullyQualifiedPathBufLen)
		{
			hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		}
		else if (dwLen > 0)
		{
			hr = S_OK;
		}
	}

	if (hr != S_OK)
	{
		pwzFullyQualifiedPath = L'\0';
	}

	ASSERT(hr == S_OK ||
				(hr == E_FILE_NOT_FOUND &&
				 (! ucFullyQualifiedPathBufLen ||
				 ! *pwzFullyQualifiedPath)) ||
				(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) &&
				 dwLen > ucFullyQualifiedPathBufLen));

exit:
	return(hr);
}


/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE CAppShortcut::SetPath(LPCWSTR pcwzPath)
{
	HRESULT hr = S_OK;
	WCHAR rgchNewPath[MAX_PATH];
	BOOL bChanged = FALSE;
	LPWSTR pwzOriPath = (LPWSTR) pcwzPath; // still, pwzOriPath shouldn't be modified
	LPWSTR pwzFixedPath = NULL;

	ASSERT(! pwzOriPath)

	// ... this checks if all space in string...
	if (! AnyNonWhiteSpace(pwzOriPath))
		pwzOriPath = NULL;

	if (pwzOriPath)
	{
		LPWSTR pwzFileName;

		// this ignores "If the lpBuffer buffer is too small, the return value is the size
		//  of the buffer, in WCHARs, required to hold the path"
		if (GetFullPathName(pwzOriPath, sizeof(rgchNewPath)/sizeof(WCHAR),
					rgchNewPath, &pwzFileName) > 0)
			pwzOriPath = rgchNewPath;
		else
			hr = GetLastWin32Error();
	}

	if (hr == S_OK)
	{
		bChanged = ! ((! pwzOriPath && ! m_pwzPath) ||
				(pwzOriPath && m_pwzPath &&
				! wcscmp(pwzOriPath, m_pwzPath)));

		if (bChanged && pwzOriPath)
		{
			 // (+ 1) for null terminator.

			pwzFixedPath = new(WCHAR[wcslen(pwzOriPath) + 1]);

			if (pwzFixedPath)
				wcscpy(pwzFixedPath, pwzOriPath);
			else
				hr = E_OUTOFMEMORY;
		}
	}

	if (hr == S_OK && bChanged)
	{
		if (m_pwzPath)
			delete m_pwzPath;

		m_pwzPath = pwzFixedPath;

		Dirty(TRUE);
   }

	ASSERT(hr == S_OK || FAILED(hr));

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::GetPath(LPWSTR pwzFile,
                                                    int ncFileBufLen,
                                                    PWIN32_FIND_DATA pwfd,
                                                    DWORD dwFlags)
{
	HRESULT hr = S_OK;

	ASSERT(NULL == pwfd);
	// Ignore dwFlags.

	if (pwfd)
		ZeroMemory(pwfd, sizeof(*pwfd));

	if (m_pwzPath)
	{
		if (pwzFile == NULL || ncFileBufLen <= 0)
			hr = E_INVALIDARG;
		else
		{
			wcsncpy(pwzFile, m_pwzPath, ncFileBufLen-1);
			pwzFile[ncFileBufLen-1] = L'\0';
		}
	}
	else
	{
		if (ncFileBufLen > 0 && pwzFile != NULL)
			*pwzFile = L'\0';

		hr = S_FALSE;
	}

	ASSERT((hr == S_OK && ncFileBufLen < 1) ||
			(hr == S_FALSE && 
			(ncFileBufLen < 1 || ! *pwzFile)));

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::SetRelativePath(LPCWSTR pcwzRelativePath,
                                                      DWORD dwReserved)
{
	HRESULT hr;

	// dwReserved may be any value.

	hr = E_NOTIMPL;

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::SetIDList(LPCITEMIDLIST pcidl)
{
	HRESULT hr;

	hr = E_NOTIMPL;

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::GetIDList(LPITEMIDLIST *ppidl)
{
	HRESULT hr;

	if (ppidl != NULL)
		*ppidl = NULL;

	hr = E_NOTIMPL;

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::SetDescription(LPCWSTR pcwzDescription)
{
	HRESULT hr = S_OK;
	BOOL bDifferent;
	LPWSTR pwzNewDesc = NULL;

	// Set m_pwzDesc to description.

	bDifferent = ! ((! pcwzDescription && ! m_pwzDesc) ||
				(pcwzDescription && m_pwzDesc &&
				! wcscmp(pcwzDescription, m_pwzDesc)));

	if (bDifferent && pcwzDescription)
	{
		// (+ 1) for null terminator.

		pwzNewDesc = new(WCHAR[wcslen(pcwzDescription) + 1]);

		if (pwzNewDesc)
			wcscpy(pwzNewDesc, pcwzDescription);
		else
			hr = E_OUTOFMEMORY;
	}

	if (hr == S_OK && bDifferent)
	{
		if (m_pwzDesc)
			delete m_pwzDesc;

		m_pwzDesc = pwzNewDesc;

		Dirty(TRUE);
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::GetDescription(LPWSTR pwzDescription,
                                                      int ncDesciptionBufLen)
{
	HRESULT hr = S_OK;

	// Get description from m_pwzDesc.

	if (m_pwzDesc)
	{
		if (pwzDescription == NULL || ncDesciptionBufLen <= 0)
			hr = E_INVALIDARG;
		else
		{
			wcsncpy(pwzDescription, m_pwzDesc, ncDesciptionBufLen-1);
			pwzDescription[ncDesciptionBufLen-1] = L'\0';
		}
	}
	else
	{
		if (ncDesciptionBufLen > 0 && pwzDescription != NULL)
			pwzDescription = L'\0';
	}

	ASSERT(hr == S_OK &&
		(ncDesciptionBufLen <= 0 ||
		EVAL(wcslen(pwzDescription) < ncDesciptionBufLen)));

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::SetArguments(LPCWSTR pcwzArgs)
{
   HRESULT hr;

   hr = E_NOTIMPL;

   return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::GetArguments(LPWSTR pwzArgs,
                                                         int ncArgsBufLen)
{
   HRESULT hr;

   if (ncArgsBufLen > 0 && pwzArgs != NULL)
      *pwzArgs = L'\0';

   hr = E_NOTIMPL;

   return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::SetWorkingDirectory(LPCWSTR pcwzWorkingDirectory)
{
	HRESULT hr = S_OK;
	WCHAR rgchNewPath[MAX_PATH];
	BOOL bChanged = FALSE;
	LPWSTR pwzOriWorkingDirectory = (LPWSTR) pcwzWorkingDirectory; // still, pwzOriWorkingDirectory shouldn't be modified
	LPWSTR pwzFixedWorkingDirectory = NULL;

	ASSERT(! pwzOriWorkingDirectory)

	// ... this checks if all space in string...
	if (! AnyNonWhiteSpace(pwzOriWorkingDirectory))
		pwzOriWorkingDirectory = NULL;

	if (pwzOriWorkingDirectory)
	{
		LPWSTR pwzFileName;

		// this ignores "If the lpBuffer buffer is too small, the return value is the size
		//  of the buffer, in WCHARs, required to hold the path"
		if (GetFullPathName(pwzOriWorkingDirectory, sizeof(rgchNewPath)/sizeof(WCHAR),
					rgchNewPath, &pwzFileName) > 0)
			pwzOriWorkingDirectory = rgchNewPath;
		else
			hr = GetLastWin32Error();
	}

	if (hr == S_OK)
	{
		bChanged = ! ((! pwzOriWorkingDirectory && ! m_pwzWorkingDirectory) ||
				(pwzOriWorkingDirectory && m_pwzWorkingDirectory &&
				! wcscmp(pwzOriWorkingDirectory, m_pwzWorkingDirectory)));

		if (bChanged && pwzOriWorkingDirectory)
		{
			// (+ 1) for null terminator.

			pwzFixedWorkingDirectory = new(WCHAR[wcslen(pwzOriWorkingDirectory) + 1]);

			if (pwzFixedWorkingDirectory)
				wcscpy(pwzFixedWorkingDirectory, pwzOriWorkingDirectory);
			else
				hr = E_OUTOFMEMORY;
		}
	}

	if (hr == S_OK && bChanged)
	{
		if (m_pwzWorkingDirectory)
			delete m_pwzWorkingDirectory;

		m_pwzWorkingDirectory = pwzFixedWorkingDirectory;

		Dirty(TRUE);
	}

	ASSERT(hr == S_OK || FAILED(hr));

	return(hr);
}

HRESULT STDMETHODCALLTYPE CAppShortcut::GetWorkingDirectory(LPWSTR pwzWorkingDirectory,
                                                int ncbWorkingDirectoryBufLen)
{
	HRESULT hr = S_OK;

	if (m_pwzWorkingDirectory)
	{
		if (pwzWorkingDirectory == NULL || ncbWorkingDirectoryBufLen <= 0)
			hr = E_INVALIDARG;
		else
		{
			wcsncpy(pwzWorkingDirectory, m_pwzWorkingDirectory,
				ncbWorkingDirectoryBufLen-1);
			pwzWorkingDirectory[ncbWorkingDirectoryBufLen-1] = L'\0';
		}
	}
	else
	{
		if (ncbWorkingDirectoryBufLen > 0 && pwzWorkingDirectory != NULL)
			*pwzWorkingDirectory = L'\0';

		hr = S_FALSE;
	}

	ASSERT(IsValidPathResult(hr, pwzWorkingDirectory, ncbWorkingDirectoryBufLen));
	ASSERT(hr == S_OK ||
		hr == S_FALSE);

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::SetHotkey(WORD wHotkey)
{
	HRESULT hr=S_OK;

	ASSERT(! wHotkey)

	if (wHotkey != m_wHotkey)
	{
		m_wHotkey = wHotkey;
		
		Dirty(TRUE);
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::GetHotkey(PWORD pwHotkey)
{
	HRESULT hr=S_OK;

	if (pwHotkey == NULL)
		hr = E_INVALIDARG;
	else
		*pwHotkey = m_wHotkey;

	ASSERT(! *pwHotkey)

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::SetShowCmd(int nShowCmd)
{
	HRESULT hr=S_OK;

	ASSERT(IsValidShowCmd(nShowCmd));

	if (nShowCmd != m_nShowCmd)
	{
		m_nShowCmd = nShowCmd;

		Dirty(TRUE);
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::GetShowCmd(PINT pnShowCmd)
{
	HRESULT hr=S_OK;

	if (pnShowCmd == NULL)
		hr = E_INVALIDARG;
	else
		*pnShowCmd = m_nShowCmd;

	ASSERT(IsValidShowCmd(m_nShowCmd));

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::SetIconLocation(LPCWSTR pcwzIconFile,
                                                            int niIcon)
{
	HRESULT hr = S_OK;
	BOOL bNewNonWhiteSpace;
	WCHAR rgchNewPath[MAX_PATH];  // ok even if not initialized... see code below

	ASSERT(IsValidIconIndex(pcwzIconFile ? S_OK : S_FALSE, pcwzIconFile, MAX_PATH, niIcon));

	bNewNonWhiteSpace = AnyNonWhiteSpace(pcwzIconFile);

	// is this necessary? shell seems to do that internally anyway
	if (bNewNonWhiteSpace)
		hr = FullyQualifyPath(pcwzIconFile, rgchNewPath, sizeof(rgchNewPath)/sizeof(WCHAR));

	if (hr == S_OK)
	{
		WCHAR rgchOldPath[MAX_PATH];
		int niOldIcon;
		UINT uFlags;

		hr = GetIconLocation(0, rgchOldPath, sizeof(rgchOldPath)/sizeof(WCHAR), &niOldIcon,
			&uFlags);

		// should this continue even if there's error getting icon location??
		if (SUCCEEDED(hr))
		{
			BOOL bOldNonWhiteSpace;
			BOOL bChanged = FALSE;
			LPWSTR pwzNewIconFile = NULL;
			int niNewIcon = 0;

			bOldNonWhiteSpace = AnyNonWhiteSpace(rgchOldPath);

			ASSERT(! *rgchOldPath || bOldNonWhiteSpace);

			// check
			bChanged = ((! bOldNonWhiteSpace && bNewNonWhiteSpace) ||
				(bOldNonWhiteSpace && ! bNewNonWhiteSpace) ||
				(bOldNonWhiteSpace && bNewNonWhiteSpace &&
				(wcscmp(rgchOldPath, rgchNewPath) != 0 ||
				niIcon != niOldIcon)));

			// clear hr
			hr = S_OK;
			if (bChanged && bNewNonWhiteSpace)
			{
				// (+ 1) for null terminator.

				// BUGBUG: slightly not optimize as it makes a copy even if only the index changes
				pwzNewIconFile = new(WCHAR[wcslen(rgchNewPath) + 1]);

				if (pwzNewIconFile)
				{
					wcscpy(pwzNewIconFile, rgchNewPath);
					niNewIcon = niIcon;
				}
				else
					hr = E_OUTOFMEMORY;
			}
 
			if (hr == S_OK && bChanged)
			{
				if (m_pwzIconFile)
					delete m_pwzIconFile;

				m_pwzIconFile = pwzNewIconFile;
				m_niIcon = niNewIcon;

				Dirty(TRUE);
			}
		}
	}

	ASSERT(hr == S_OK ||
		hr == E_OUTOFMEMORY ||
		hr == E_FILE_NOT_FOUND);

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::GetIconLocation(LPWSTR pwzIconFile,
                                                         int ncbIconFileBufLen,
                                                         PINT pniIcon)
{
	HRESULT hr=S_OK;

	// this ignores icon index (even if set) if icon file path is not
	if (m_pwzIconFile)
	{
		if (pwzIconFile == NULL || ncbIconFileBufLen <= 0)
			hr = E_INVALIDARG;
		else
		{
			wcsncpy(pwzIconFile, m_pwzIconFile, ncbIconFileBufLen-1);
			pwzIconFile[ncbIconFileBufLen-1] = L'\0';

			if (pniIcon == NULL)
				hr = E_INVALIDARG;
			else
				*pniIcon = m_niIcon;
			
		}
	}
	else
	{
		if (ncbIconFileBufLen > 0 && pwzIconFile != NULL)
			*pwzIconFile = L'\0';

		if (pniIcon != NULL)
			*pniIcon = 0;

		hr = S_FALSE;
	}

	ASSERT(IsValidIconIndex(hr, pwzIconFile, ncbIconFileBufLen, *pniIcon));

	return(hr);
}


HRESULT STDMETHODCALLTYPE CAppShortcut::Resolve(HWND hwnd, DWORD dwFlags)
{
	HRESULT hr;

	ASSERT(IS_VALID_HANDLE(hwnd, WND));

	// BUGBUG?: check dwFlags

	hr = S_OK;

	// BUGBUG?: should this check the shortcut and do the UI/update/save?

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\common\stdinc.h ===
#include "SxApwStdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\dmgr\cdmgr.cpp ===
#include "stdinc.h"
#include "cdmgr.h"
#include "SxApwCreate.h"

static ATL::CComModule Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(__uuidof(CSxApwDataManager), CSxApwDataManager)
END_OBJECT_MAP()

ATL::CComModule* GetModule() { return &Module; }
ATL::_ATL_OBJMAP_ENTRY* GetObjectMap() { return ObjectMap; }
const CLSID* GetTypeLibraryId() { return NULL; }

HRESULT STDMETHODCALLTYPE
CSxApwDataManager::CreateDataSource(
    PCWSTR type,
    ISxApwDataSource** ppsource
    )
{
    HRESULT hr;
    CLSID   clsid;
    ATL::CComPtr<ISxApwDataSource> view;
    
    if (FAILED(hr = CLSIDFromString(const_cast<PWSTR>(type), &clsid)))
        goto Exit;

    if (FAILED(hr = SxApwCreateObject(clsid, ppsource)))
        goto Exit;

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\dsources\sources.inc ===
RELATIVE_DEPTH=..\$(RELATIVE_DEPTH)
!include ..\$(RELATIVE_DEPTH)\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\common\dload.cpp ===
#include "stdinc.h"

FARPROC
WINAPI
SxApwGetKernel32ProcAddress(
    PCSTR pszProcName
    )
{
    static HMODULE hmodKernel32;
    if (hmodKernel32 == NULL)
    {
        hmodKernel32 = GetModuleHandleW(L"Kernel32.dll");
        if (hmodKernel32 == NULL)
            return NULL;
    }
    return GetProcAddress(hmodKernel32, pszProcName);
}

BOOL
WINAPI
SxApwActivateActCtx(
    HANDLE hActCtx,
    ULONG_PTR *lpCookie
    )
{
    typedef BOOL (WINAPI* PFN)(HANDLE hActCtx, ULONG_PTR *lpCookie);
    static PFN pfn;
    if (pfn == NULL)
    {
        pfn = reinterpret_cast<PFN>(SxApwGetKernel32ProcAddress("ActivateActCtx"));
        if (pfn == NULL)
            return FALSE;
    }
    return pfn(hActCtx, lpCookie);
}

BOOL
WINAPI
SxApwDeactivateActCtx(
    DWORD dwFlags,
    ULONG_PTR ulCookie
    )
{
    typedef BOOL (WINAPI* PFN)(DWORD dwFlags, ULONG_PTR ulCookie);
    static PFN pfn;
    if (pfn == NULL)
    {
        pfn = reinterpret_cast<PFN>(SxApwGetKernel32ProcAddress("DeactivateActCtx"));
        if (pfn == NULL)
            return FALSE;
    }
    return pfn(dwFlags, ulCookie);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\dmgr\cdmgr.h ===
/*
*/
#pragma once

class __declspec(uuid(CLSID_CSxApwDataManager_declspec_uuid))
CSxApwDataManager
:
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwDataManager, &__uuidof(CSxApwDataManager)>,
    public ISxApwDataManager
{
public:

    CSxApwDataManager() { }

    BEGIN_COM_MAP(CSxApwDataManager)
	    COM_INTERFACE_ENTRY(ISxApwDataManager)
    END_COM_MAP()

    DECLARE_NO_REGISTRY();

    HRESULT STDMETHODCALLTYPE
    CreateDataSource(
        PCWSTR type,
        ISxApwDataSource**
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\dmgr\stdinc.h ===
#include "SxApwStdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\common\dllmain.cpp ===
#include "stdinc.h"

ATL::_ATL_OBJMAP_ENTRY* GetObjectMap();
const CLSID* GetTypeLibraryId();

extern "C"
BOOL WINAPI _DllMainCRTStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);

extern "C"
BOOL WINAPI SxApwDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fSuccess = FALSE;
    if (!_DllMainCRTStartup(hInstance, dwReason, lpReserved))
        goto Exit;
    switch (dwReason)
    {
    default:
        break;
    case DLL_PROCESS_ATTACH:
        GetModule()->Init(GetObjectMap(), hInstance, GetTypeLibraryId());
        DisableThreadLibraryCalls(hInstance);
        break;
    case DLL_PROCESS_DETACH:
        GetModule()->Term();
        break;
    }
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

STDAPI DllCanUnloadNow(void)
{
    return (GetModule()->GetLockCount()==0) ? S_OK : S_FALSE;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    const CLSID* pclsid = &rclsid;
    if (rclsid == GUID_NULL)
    { // this is a category bind to a .dll path, take the first clsid
        pclsid = GetObjectMap()->pclsid;
    }
    return GetModule()->GetClassObject(*pclsid, riid, ppv);
}

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    //return GetModule()->RegisterServer(TRUE);
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    //return GetModule()->UnregisterServer(TRUE);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\common\create.cpp ===
#include "stdinc.h"
#include "SxApwHandle.h"
#include "SxApwCreate.h"

typedef HRESULT (STDMETHODCALLTYPE* PFN_DLL_GET_CLASS_OBJECT)(REFCLSID rclsid, REFIID riid, LPVOID* ppv);

HRESULT
SxApwCreateObject(
    REFCLSID   rclsid,
    REFIID     riid,
    void**     pp
    )
/*
Strategy:
  Enumerate .dlls in the same directory as the .exe, calling DllGetClassObject on each, etc..
  This is subject to change.

  This code is presently shared both by the host and the managers...maybe this is wrong.
*/
{
    HRESULT hr = E_FAIL;
    CFindFile findFile;
    WCHAR     exePath[MAX_PATH];
    WIN32_FIND_DATAW findData;
    PWSTR filePart;

    GetModuleFileName(GetModule()->m_hInst, exePath, RTL_NUMBER_OF(exePath));
    filePart = 1 + wcsrchr(exePath, '\\');
    wcscpy(filePart, L"*.dll");

    if (findFile.Win32Create(exePath, &findData))
    {
        do
        {
            PCWSTR dot = wcsrchr(findData.cFileName, '.');
            if (dot != NULL && _wcsicmp(dot, L".dll") == 0)
            {
                CDynamicLinkLibrary dll;
                PFN_DLL_GET_CLASS_OBJECT pfn;
                ATL::CComPtr<IClassFactory> classFactory;

                wcscpy(filePart, findData.cFileName);
                IFFALSE_WIN32TOHR_EXIT(hr, dll.Win32Create(exePath));
                if ( !dll.GetProcAddress( "DllGetClassObject", &pfn ) )
                {
                    if ( ::GetLastError() == ERROR_PROC_NOT_FOUND )
                        continue;
                    else
                    {
                        DWORD LastError = ::GetLastError();
                        
                        TRACE_WIN32_FAILURE( GetProcAddress );
                        hr = HRESULT_FROM_WIN32( LastError );
                        goto Exit;
                    }
                }

                if (FAILED(hr = pfn(rclsid, __uuidof(classFactory), reinterpret_cast<void**>(&classFactory))))
                    continue;
                if (FAILED(hr = classFactory->CreateInstance(NULL, riid, pp)))
                    continue;
                // hold the .dll open
                dll.Detach();
                goto Exit;
            }
        } while (FindNextFileW(findFile, &findData));
    }

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\dsources\db\stdinc.h ===
#include "SxApwStdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\dsources\dir\stdinc.h ===
#include "SxApwStdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\dsources\db\cdb.h ===
/*
*/
#pragma once

#include "idsource.h"
#include "SxApwHandle.h"

#include <adoid.h>
#include <adoint.h>
#include <icrsint.h>
#include <oledb.h>

#include <string>

class __declspec(uuid(CLSID_CSxApwDbDataSource_declspec_uuid))
CSxApwDbDataSource
:
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwDbDataSource, &__uuidof(CSxApwDbDataSource)>,
    public ISxApwDataSource
{
public:

    CSxApwDbDataSource() { }
    virtual ~CSxApwDbDataSource() { }

    BEGIN_COM_MAP(CSxApwDbDataSource)
	    COM_INTERFACE_ENTRY(ISxApwDataSource)
    END_COM_MAP()

    DECLARE_NO_REGISTRY();

    STDMETHOD(SetSite)(
        ISxApwHost* host
        ) { m_host = host; return S_OK; }

    STDMETHOD(RunQuery)(
        LPCWSTR query
        );

    STDMETHOD(StopQuery)(
        ) { return S_OK; }

private:
    ATL::CComPtr<ISxApwHost>    m_host;

    CSxApwDbDataSource(const CSxApwDbDataSource&); // not implemented
    void operator=(const CSxApwDbDataSource&); // not implemented
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\dsources\db\cdb.cpp ===
#include "stdinc.h"
#include "cdb.h"
#include <limits.h>
#include <vector>

static ATL::CComModule Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(__uuidof(CSxApwDbDataSource), CSxApwDbDataSource)
END_OBJECT_MAP()

ATL::CComModule* GetModule() { return &Module; }
ATL::_ATL_OBJMAP_ENTRY* GetObjectMap() { return ObjectMap; }
const CLSID* GetTypeLibraryId() { return NULL; }

#define IF_FAILED_EXIT(hr)  if (FAILED(hr)) { goto Exit; }

/*
    query is passed in as "<DSN>|<SELECT stmt>"
*/
STDMETHODIMP
CSxApwDbDataSource::RunQuery(
    PCWSTR query
    )
{
    std::vector<CSxApwAdoColumnInfo> schema;
    C_ASSERT(sizeof(CSxApwAdoColumnInfo) == sizeof(SxApwColumnInfo));
    std::wstring            datasource;
    std::wstring            sql;
    std::wstring            tmp(query);
    std::wstring::size_type pos = tmp.find(L"|");

    if (std::wstring::npos != pos)
    {
        datasource = tmp.substr(0, pos);
        sql = tmp.substr(pos + 1);
    }

    CComBSTR                        bstrConnection(datasource.c_str());
    const BSTR                      bstrEmpty = NULL;
    VARIANT_BOOL                    vbIsEOF;
    ATL::CComVariant                strSelect(sql.c_str());
    LONG                            lCount = 0;
    std::vector<LPWSTR>             row;
    std::vector<ATL::CComVariant>   values;
    ATL::CComPtr<Fields>            pFields;
    ATL::CComPtr<_Connection>       pConnection;
	ATL::CComPtr<_Recordset>        pRecordset;
    LONG                            j = 0;
    HRESULT                         hr = E_FAIL;

	IF_FAILED_EXIT(hr = pConnection.CoCreateInstance(CLSID_CADOConnection));
	IF_FAILED_EXIT(hr = pRecordset.CoCreateInstance(CLSID_CADORecordset));

    IF_FAILED_EXIT(hr = pConnection->put_ConnectionString(bstrConnection));
	IF_FAILED_EXIT(hr = pConnection->put_ConnectionTimeout(30));
	IF_FAILED_EXIT(hr = pConnection->Open(bstrEmpty, bstrEmpty, bstrEmpty, NULL));

    IF_FAILED_EXIT(pRecordset->Open(strSelect,
        ATL::CComVariant(static_cast<IDispatch*>(pConnection)),
        adOpenStatic, adLockReadOnly, adCmdText));

    IF_FAILED_EXIT(pRecordset->MoveFirst());
    IF_FAILED_EXIT(pRecordset->get_EOF(&vbIsEOF));

    IF_FAILED_EXIT(hr = pRecordset->get_Fields(&pFields));
    IF_FAILED_EXIT(hr = pFields->get_Count(&lCount));

    row.resize(lCount);
    values.resize(lCount);
    schema.resize(lCount);

    // save the schema
    for (j = 0; j < lCount; j++)
    {
        ATL::CComPtr<Field> pField;

        IF_FAILED_EXIT(hr = pFields->get_Item(ATL::CComVariant(j), &pField));
        IF_FAILED_EXIT(hr = pField->get_Name(const_cast<BSTR*>(&schema[j].m.Name)));
        schema[j].m.IsNumber = FALSE;
    }
    hr = m_host->InformSchema(&schema[0].m, static_cast<int>(schema.size()));
    schema.clear();

    // get all rows
    while (!vbIsEOF)
    {
//        IF_FAILED_EXIT(hr = pRecordset->get_Fields(&pFields));
        for (j = 0; j < lCount; j++)
        {
            ATL::CComVariant    v;
            ATL::CComPtr<Field> pField;

            IF_FAILED_EXIT(hr = pFields->get_Item(ATL::CComVariant(j), &pField));
            IF_FAILED_EXIT(hr = values[j].Clear());
            IF_FAILED_EXIT(hr = pField->get_Value(&v));
            if (v.vt != VT_NULL)
            {
                IF_FAILED_EXIT(hr = ::VariantChangeType(&v, &v, VARIANT_LOCALBOOL, VT_BSTR));
            }
            else
            {
                v = L"";
            }
            values[j] = v;
            row[j] = values[j].bstrVal;
        }
        IF_FAILED_EXIT(hr = m_host->OnNextRow(lCount, &row[0]));
        IF_FAILED_EXIT(hr = pRecordset->MoveNext());
        IF_FAILED_EXIT(hr = pRecordset->get_EOF(&vbIsEOF));
    }

    hr = S_OK;
Exit:
    if (pRecordset != NULL)
        pRecordset->Close();
    if (pConnection != NULL)
        pConnection->Close();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\dsources\dir\cdir.cpp ===
#include "stdinc.h"
#include "cdir.h"
#include <limits.h>
#include "SxApwHandle.h"

static ATL::CComModule Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(__uuidof(CSxApwDirDataSource), CSxApwDirDataSource)
END_OBJECT_MAP()

ATL::CComModule* GetModule() { return &Module; }
ATL::_ATL_OBJMAP_ENTRY* GetObjectMap() { return ObjectMap; }
const CLSID* GetTypeLibraryId() { return NULL; }

STDMETHODIMP
CSxApwDirDataSource::RunQuery(
    PCWSTR query
    )
{
    /*
    Just run the query synchronously.
    */
    CFindFile           findFile;
    WIN32_FIND_DATAW    findData;
    WCHAR               fullPath[MAX_PATH];
    PWSTR               filePart;
    LARGE_INTEGER       li;
    WCHAR               sizeString[sizeof(__int64) * CHAR_BIT];
    const PCWSTR        row[] = { fullPath, sizeString };
    const static SxApwColumnInfo s_rgColumnInfo[] =
    {
        { L"Name", FALSE },
        { L"Size", TRUE  },
    };

    m_host->InformSchema(s_rgColumnInfo, NUMBER_OF(s_rgColumnInfo));

    wcscpy(fullPath, query);
    filePart = 1 + wcsrchr(fullPath, '\\');
    if (findFile.Win32Create(query, &findData))
    {
        do
        {
            wcscpy(filePart, findData.cFileName);
            li.LowPart = findData.nFileSizeLow;
            li.HighPart = findData.nFileSizeHigh;
            _i64tow(li.QuadPart, sizeString, 10);

            m_host->OnNextRow(NUMBER_OF(row), row);

        } while (FindNextFileW(findFile, &findData));
    }
    m_host->OnQueryDone();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\childfrm.cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//

#include "stdinc.h"
#include "host.h"
#include "ChildFrm.h"
#include "HostDoc.h"
#include "SettingsDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
	ON_COMMAND(ID_SETTINGS, OnSettings)
	ON_COMMAND(ID_DATASOURCE1, OnDataSource1)
	ON_COMMAND(ID_DATASOURCE2, OnDataSource2)
	ON_COMMAND(ID_DATASOURCE3, OnDataSource3)
	ON_UPDATE_COMMAND_UI(ID_DATASOURCE1, OnUpdateDataSource1)
	ON_UPDATE_COMMAND_UI(ID_DATASOURCE2, OnUpdateDataSource2)
	ON_UPDATE_COMMAND_UI(ID_DATASOURCE3, OnUpdateDataSource3)
	ON_COMMAND(ID_GDIPLUS, OnGdiPlus)
	ON_UPDATE_COMMAND_UI(ID_GDIPLUS, OnUpdateGdiPlus)
	ON_COMMAND(ID_COMCTRL, OnComCtrl)
	ON_UPDATE_COMMAND_UI(ID_COMCTRL, OnUpdateComCtrl)
	ON_COMMAND(ID_PRIVATE_ASSEMBLY, OnPrivateAssembly)
	ON_UPDATE_COMMAND_UI(ID_PRIVATE_ASSEMBLY, OnUpdatePrivateAssembly)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
    m_nDataSource = 0;
    m_nUIObject = 0;
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	if( !CMDIChildWnd::PreCreateWindow(cs) )
		return FALSE;

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers

void CChildFrame::OnSettings() 
{
	CHostDoc * pDoc = (CHostDoc *) GetActiveDocument();

	// TODO: Add your command handler code here
	CSettingsDlg dlg;
	dlg.m_sPath = pDoc->m_sPath;
	dlg.m_sDBName = pDoc->m_sDBName;
	dlg.m_sDBQuery = pDoc->m_sDBQuery;
	if (dlg.DoModal() == IDOK)
	{
		pDoc->m_sPath = dlg.m_sPath;
		pDoc->m_sDBName = dlg.m_sDBName;
		pDoc->m_sDBQuery = dlg.m_sDBQuery;
	}
}


///////////////////////////////////////////////////////////////////////////
void CChildFrame::OnDataSource1() 
{
	m_nDataSource = 1;
    Action();
}


///////////////////////////////////////////////////////////////////////////
void CChildFrame::OnDataSource2() 
{
    m_nDataSource = 2;
    Action();
}


///////////////////////////////////////////////////////////////////////////
void CChildFrame::OnDataSource3() 
{
	m_nDataSource = 3;
    Action();
}


///////////////////////////////////////////////////////////////////////////
void CChildFrame::OnGdiPlus() 
{
	m_nUIObject = 1;
    Action();
}


///////////////////////////////////////////////////////////////////////////
void CChildFrame::OnComCtrl() 
{
	m_nUIObject = 2;
    Action();
}


///////////////////////////////////////////////////////////////////////////
void CChildFrame::OnPrivateAssembly() 
{
	m_nUIObject = 3;
    Action();
}


///////////////////////////////////////////////////////////////////////////
void CChildFrame::OnUpdateDataSource1(CCmdUI* pCmdUI) 
{
    pCmdUI->SetCheck( FALSE );
	CHostDoc * pDoc = (CHostDoc *) GetActiveDocument();

	BOOL bShow = (pDoc->m_sPath.GetLength() > 0);
	pCmdUI->Enable( bShow );
	if ( bShow )
	{
		pCmdUI->SetCheck(m_nDataSource == 1);
	}
}


///////////////////////////////////////////////////////////////////////////
void CChildFrame::OnUpdateDataSource2(CCmdUI* pCmdUI) 
{
    pCmdUI->SetCheck( FALSE );
	CHostDoc * pDoc = (CHostDoc *) GetActiveDocument();

	BOOL bShow = ((pDoc->m_sDBName.GetLength() > 0) && (pDoc->m_sDBQuery.GetLength() > 0));
	pCmdUI->Enable( bShow );
	if ( bShow )
	{
		pCmdUI->SetCheck(m_nDataSource == 2);
	}
}


///////////////////////////////////////////////////////////////////////////
void CChildFrame::OnUpdateDataSource3(CCmdUI* pCmdUI) 
{
    pCmdUI->SetCheck( FALSE );
	pCmdUI->Enable( FALSE );
//	pCmdUI->SetCheck(m_nDataSource == 3);
}


///////////////////////////////////////////////////////////////////////////
void CChildFrame::OnUpdateGdiPlus(CCmdUI* pCmdUI) 
{
    pCmdUI->SetCheck( FALSE );
	CHostDoc * pDoc = (CHostDoc *) GetActiveDocument();
	BOOL bShow = ((pDoc->m_sPath.GetLength() > 0) 
               || ((pDoc->m_sDBName.GetLength() > 0) && (pDoc->m_sDBQuery.GetLength() > 0)));
	pCmdUI->Enable( bShow );
    if ( bShow)
    {
    	pCmdUI->SetCheck(m_nUIObject == 1);
    }
}


///////////////////////////////////////////////////////////////////////////
void CChildFrame::OnUpdateComCtrl(CCmdUI* pCmdUI) 
{
    pCmdUI->SetCheck( FALSE );
	CHostDoc * pDoc = (CHostDoc *) GetActiveDocument();
	BOOL bShow = ((pDoc->m_sPath.GetLength() > 0) 
               || ((pDoc->m_sDBName.GetLength() > 0) && (pDoc->m_sDBQuery.GetLength() > 0)));
	pCmdUI->Enable( bShow );
    if ( bShow)
    {
    	pCmdUI->SetCheck(m_nUIObject == 2);
    }
}


///////////////////////////////////////////////////////////////////////////
void CChildFrame::OnUpdatePrivateAssembly(CCmdUI* pCmdUI) 
{
    pCmdUI->SetCheck( FALSE );
	CHostDoc * pDoc = (CHostDoc *) GetActiveDocument();
	BOOL bShow = ((pDoc->m_sPath.GetLength() > 0) 
               || ((pDoc->m_sDBName.GetLength() > 0) && (pDoc->m_sDBQuery.GetLength() > 0)));
	pCmdUI->Enable( bShow );
    if ( bShow)
    {
    	pCmdUI->SetCheck(m_nUIObject == 3);
    }
}


///////////////////////////////////////////////////////////////////////////
void CChildFrame::Action()
{
    CString sQuery;
    sQuery.Empty();

    // Get Application and current document pointers
    CHostApp * pApp = (CHostApp *) AfxGetApp();
	CHostDoc * pDoc = (CHostDoc *) GetActiveDocument();

    switch ( m_nDataSource )
    {
    case 1:
        sQuery = pDoc->m_sPath;
        break;
    case 2:
        sQuery.Format(L"%s;|%s", pDoc->m_sDBName, pDoc->m_sDBQuery);
        break;
    case 3:
        break;
    default:
        sQuery = pDoc->m_sPath;
        break;
    }

	pApp->m_host.DSQuery(m_nDataSource, m_nUIObject, sQuery, this->GetSafeHwnd());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\dsources\dir\cdir.h ===
/*
*/
#pragma once

#include "idsource.h"

class __declspec(uuid(CLSID_CSxApwDirDataSource_declspec_uuid))
CSxApwDirDataSource
:
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwDirDataSource, &__uuidof(CSxApwDirDataSource)>,
    public ISxApwDataSource
{
public:
    CSxApwDirDataSource() { }

    BEGIN_COM_MAP(CSxApwDirDataSource)
	    COM_INTERFACE_ENTRY(ISxApwDataSource)
    END_COM_MAP()

    DECLARE_NO_REGISTRY();

    STDMETHOD(SetSite)(
        ISxApwHost* host
        ) { m_host = host; return S_OK; }

    STDMETHOD(RunQuery)(
        LPCWSTR query
        );

    STDMETHOD(StopQuery)(
        ) { return S_OK; }

private:
    ATL::CComPtr<ISxApwHost> m_host;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\chost.h ===
/*
*/
#pragma once

#include "ihost.h"
#include <vector>
#include "iuiview.h"
#include "SxApwComPtr.h"
#include "idsource.h"

class __declspec(uuid(CLSID_CSxApwHost_declspec_uuid))
CSxApwHost
:
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwHost, &__uuidof(CSxApwHost)>,
    public ISxApwHost
{
    typedef std::vector<CSxApwComPtr<ISxApwUiView> > Views_t;
    Views_t m_views;

public:

	CSxApwHost() { }

	BEGIN_COM_MAP(CSxApwHost)
		COM_INTERFACE_ENTRY(ISxApwHost)
	END_COM_MAP()

	DECLARE_NO_REGISTRY();

    STDMETHOD(SetDataSource)(
        LPCWSTR datasource
        );

    STDMETHOD(CreateView)(
        LPCWSTR viewstr
        );

    STDMETHOD(DestroyView)(
        LPCWSTR viewstr
        ) { return S_OK; }

    STDMETHOD(RunQuery)(
        LPCWSTR query
        );

	STDMETHOD(OnNextRow)(
        int     nColumns,
		const LPCWSTR columns[]
		);

	STDMETHOD(OnRowCountEstimateAvailable)(
		int
		);

    STDMETHOD(OnQueryDone)(
        ) { return S_OK; }

    STDMETHOD(OnQueryStart)(
        ) { return S_OK; }

    STDMETHOD(InformSchema)(
        const SxApwColumnInfo  rgColumnInfo[],
        int                    nColumnCount
        );

    HRESULT DSQuery(int nDataSourceType, int nViewType, PCWSTR query, HWND hWnd);

	HRESULT Main();

    CSxApwComPtr<ISxApwDataSource>  m_dataSource;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\chost.cpp ===
#include "stdinc.h"
#include <string>
#include <vector>
#include <fstream>
#include <iostream>
#include "SxApwHandle.h"
#include "SxApwCreate.h"
#include "SxApwComPtr.h"
#include "chost.h"

#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))

const static
PCWSTR s_dbQueries[] =
{
    L"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=\\\\fusiontest\\sxs\\appweek\\nwind.mdb;"
            L"|SELECT * from employees",
    L"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=\\\\fusiontest\\sxs\\appweek\\nwind.mdb;"
            L"|SELECT title from employees",
};

std::wstring MultiByteToWideChar( const std::string& source )
{
    std::vector<WCHAR> wch;
    wch.resize( MultiByteToWideChar( CP_ACP, 0, source.data(), source.size(), NULL, 0 ) );
    MultiByteToWideChar( CP_ACP, 0, source.data(), source.size(), &wch.front(), wch.size() );

    return std::wstring( wch.begin(), wch.end() );
}

STDMETHODIMP
CSxApwHost::OnRowCountEstimateAvailable(
	int nRows
	)
{
    /*
    just multiplex/broadcast the data across all the views..
    */
    for (Views_t::const_iterator i = m_views.begin(); i != m_views.end() ; ++i)
    {
        (*i)->OnRowCountEstimateAvailable(nRows);
    }
    return S_OK;
}

STDMETHODIMP
CSxApwHost::OnNextRow(
    int     nColumns,
	const PCWSTR* columns
	)
{
    /*
    just multiplex/broadcast the data across all the views..
    */
    for (Views_t::const_iterator i = m_views.begin(); i != m_views.end() ; ++i)
    {
        (*i)->OnNextRow(nColumns, columns);
    }
    return S_OK;
}

STDMETHODIMP
CSxApwHost::InformSchema(
    const SxApwColumnInfo  rgColumnInfo[],
    int                    nColumnCount
    )
{
    /*
    just multiplex/broadcast the data across all the views..
    */
    for (Views_t::const_iterator i = m_views.begin(); i != m_views.end() ; ++i)
    {
        (*i)->InformSchema(rgColumnInfo, nColumnCount);
    }
    return S_OK;
}

STDMETHODIMP
CSxApwHost::SetDataSource(
    LPCWSTR datasource
    )
{
    HRESULT hr;

    if (FAILED(hr = SxApwCreateObject(datasource, SXAPW_CREATEOBJECT_NOWRAP, m_dataSource)))
        goto Exit;
Exit:
    return hr;
}

STDMETHODIMP
CSxApwHost::CreateView(
    LPCWSTR view
    )
{
    HRESULT hr;
    CSxApwComPtr<ISxApwUiView> iview;
    HWND hWnd = NULL /* UNDONE */;

    if (FAILED(hr = SxApwCreateObject(view, SXAPW_CREATEOBJECT_NOWRAP, iview)))
        goto Exit;
    if (FAILED(hr = iview->CreateWindow(hWnd)))
        goto Exit;
    m_views.push_back(iview);
Exit:
    return hr;
}

STDMETHODIMP
CSxApwHost::RunQuery(
    LPCWSTR query
    )
{
    HRESULT hr;

    if (FAILED(hr = m_dataSource->RunQuery(query)))
        goto Exit;
Exit:
    return hr;
}

HRESULT CSxApwHost::Main()
{
    std::ifstream    inStream;

    HRESULT hr;
    CSxApwComPtr<ISxApwDataSource>  dirSource;
    CSxApwComPtr<ISxApwDataSource>  dbSource;

    if (FAILED(hr = SetDataSource(CLSID_CSxApwDirDataSource_brace_stringW)))
        goto Exit;
    if (FAILED(hr = SetDataSource(CLSID_CSxApwDbDataSource_brace_stringW)))
        goto Exit;

    if (FAILED(hr = CreateView(CLSID_CSxApwStdoutView_brace_stringW)))
        goto Exit;

    if (FAILED(hr = dirSource->SetSite(this)))
        goto Exit;
    if (FAILED(hr = dirSource->RunQuery(L"C:\\*")))
        goto Exit;


    inStream.open("dbqueries.txt");
    if (!inStream.is_open())
    {
        hr = E_FAIL;
        goto Exit;
    }

    while (!inStream.eof())
    {
        std::string  line;
        std::getline(inStream, line);
        if (line.empty())
        {
            break;
        }
        std::wstring wLine = MultiByteToWideChar(line);
        if (FAILED(hr = dbSource->SetSite(this)))
            goto Exit;
        if (FAILED(hr = dbSource->RunQuery(wLine.c_str())))
            goto Exit;
    }

Exit:
    return hr;
}


//
// DSQuery
///////////////////////////////////////////////////////////////////////////
HRESULT CSxApwHost::DSQuery(int nDataSourceType, int nViewType, PCWSTR query, HWND hWnd)
{
	HRESULT hr;
	const static PCWSTR dataSourceClsIds[] =
        { CLSID_CSxApwDirDataSource_brace_stringW, CLSID_CSxApwDbDataSource_brace_stringW };
	const static PCWSTR viewClsIds[] =
        { CLSID_CSxApwGDIPlusView_brace_stringW, CLSID_CSxApwEditView_brace_stringW, CLSID_CSxApwStdoutView_brace_stringW, CLSID_CSxApwComctl32View_brace_stringW };

	nDataSourceType -= 1;
	if (nDataSourceType >= 0 && nDataSourceType < NUMBER_OF(dataSourceClsIds))
	{
		if (FAILED(hr = SetDataSource(dataSourceClsIds[nDataSourceType])))
		{
			goto Exit;
		}
	}
	else
	{
		hr = E_INVALIDARG;
		goto Exit;
	}

    nViewType -= 1;
    if ( (nViewType >= 0) && (nViewType < NUMBER_OF(viewClsIds)) )
    {
        if (FAILED(hr = CreateView(viewClsIds[nViewType])))
	        goto Exit;
    }
    else
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

	if (FAILED(hr = m_dataSource->SetSite(this)))
		goto Exit;

	if (FAILED(hr = m_dataSource->RunQuery(query)))
		goto Exit;

Exit:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\childfrm.h ===
// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDFRM_H__E012AF52_B9AA_447F_9BC5_FA792380A85F__INCLUDED_)
#define AFX_CHILDFRM_H__E012AF52_B9AA_447F_9BC5_FA792380A85F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
	afx_msg void OnSettings();
	afx_msg void OnDataSource1();
	afx_msg void OnDataSource2();
	afx_msg void OnDataSource3();
	afx_msg void OnUpdateDataSource1(CCmdUI* pCmdUI);
	afx_msg void OnUpdateDataSource2(CCmdUI* pCmdUI);
	afx_msg void OnUpdateDataSource3(CCmdUI* pCmdUI);
	afx_msg void OnGdiPlus();
	afx_msg void OnUpdateGdiPlus(CCmdUI* pCmdUI);
	afx_msg void OnComCtrl();
	afx_msg void OnUpdateComCtrl(CCmdUI* pCmdUI);
	afx_msg void OnPrivateAssembly();
	afx_msg void OnUpdatePrivateAssembly(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	void Action();
	int m_nDataSource;
	int m_nUIObject;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDFRM_H__E012AF52_B9AA_447F_9BC5_FA792380A85F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\hostdoc.cpp ===
// hostDoc.cpp : implementation of the CHostDoc class
//

#include "stdinc.h"
#include "host.h"
#include "hostDoc.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHostDoc

IMPLEMENT_DYNCREATE(CHostDoc, CDocument)

BEGIN_MESSAGE_MAP(CHostDoc, CDocument)
	//{{AFX_MSG_MAP(CHostDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHostDoc construction/destruction

CHostDoc::CHostDoc()
{
	// TODO: add one-time construction code here

}

CHostDoc::~CHostDoc()
{
}

BOOL CHostDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)
    m_sPath = L"";
	m_sDBName = L"";
    m_sDBQuery = L"";

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CHostDoc serialization

void CHostDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
		ar << m_sPath;
		ar << m_sDBName;
		ar << m_sDBQuery;
	}
	else
	{
		// TODO: add loading code here
		ar >> m_sPath;
		ar >> m_sDBName;
		ar >> m_sDBQuery;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CHostDoc diagnostics

#ifdef _DEBUG
void CHostDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CHostDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CHostDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\hostview.cpp ===
// hostView.cpp : implementation of the CHostView class
//

#include "stdinc.h"
#include "host.h"
#include "hostDoc.h"
#include "hostView.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHostView

IMPLEMENT_DYNCREATE(CHostView, CView)

BEGIN_MESSAGE_MAP(CHostView, CView)
	//{{AFX_MSG_MAP(CHostView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHostView construction/destruction

CHostView::CHostView()
{
	// TODO: add construction code here

}

CHostView::~CHostView()
{
}

BOOL CHostView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CHostView drawing

void CHostView::OnDraw(CDC* pDC)
{
	CHostDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	// TODO: add draw code for native data here
}

/////////////////////////////////////////////////////////////////////////////
// CHostView diagnostics

#ifdef _DEBUG
void CHostView::AssertValid() const
{
	CView::AssertValid();
}

void CHostView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CHostDoc* CHostView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CHostDoc)));
	return (CHostDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CHostView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdinc.h"
#include "host.h"
#include "MainFrm.h"
#include "HostDoc.h"
#include "SettingsDlg.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CMDIFrameWnd::PreCreateWindow(cs) )
		return FALSE;
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\hostview.h ===
// hostView.h : interface of the CHostView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_HOSTVIEW_H__C02F0896_31D8_47D6_B021_A2A0DA9F6483__INCLUDED_)
#define AFX_HOSTVIEW_H__C02F0896_31D8_47D6_B021_A2A0DA9F6483__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CHostView : public CView
{
protected: // create from serialization only
	CHostView();
	DECLARE_DYNCREATE(CHostView)

// Attributes
public:
	CHostDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHostView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHostView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CHostView)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in hostView.cpp
inline CHostDoc* CHostView::GetDocument()
   { return (CHostDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HOSTVIEW_H__C02F0896_31D8_47D6_B021_A2A0DA9F6483__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\host.h ===
// host.h : main header file for the HOST application
//

#include "ihost.h"
#include "chost.h"
#include "idsource.h"

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CHostApp:
// See host.cpp for the implementation of this class
//

class CHostApp : public CWinApp
{
public:
	CHostApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHostApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation
	//{{AFX_MSG(CHostApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	public:
    	ATL::CComObject<CSxApwHost>		m_host;
        CSxApwComPtr<ISxApwDataSource>  m_dataSource;
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\hostdoc.h ===
// hostDoc.h : interface of the CHostDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_HOSTDOC_H__3EEEAED0_B73F_4D0F_A260_3A3DF9773606__INCLUDED_)
#define AFX_HOSTDOC_H__3EEEAED0_B73F_4D0F_A260_3A3DF9773606__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CHostDoc : public CDocument
{
protected: // create from serialization only
	CHostDoc();
	DECLARE_DYNCREATE(CHostDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHostDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	CString m_sDBName;
	CString m_sDBQuery;
	CString m_sPath;
	virtual ~CHostDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CHostDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HOSTDOC_H__3EEEAED0_B73F_4D0F_A260_3A3DF9773606__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\host.cpp ===
// host.cpp : Defines the class behaviors for the application.
//

#include "stdinc.h"
#include "host.h"
#include "MainFrm.h"
#include "ChildFrm.h"
#include "hostDoc.h"
#include "hostView.h"
#include "SxApwHandle.h"
#include "SxApwCreate.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static ATL::CComModule Module;

BEGIN_OBJECT_MAP(ObjectMap)
/*
    OBJECT_ENTRY(__uuidof(CSxApwHostThunk), CSxApwHostThunk)
    OBJECT_ENTRY(__uuidof(CSxApwDataSourceThunk), CSxApwDataSourceThunk)
    OBJECT_ENTRY(__uuidof(CSxApwUiViewThunk), CSxApwUiViewThunk)
    OBJECT_ENTRY(__uuidof(CSxApwHostThunk), CSxApwHostThunk)
*/
END_OBJECT_MAP()

ATL::CComModule* GetModule() { return &Module; }
ATL::_ATL_OBJMAP_ENTRY* GetObjectMap() { return ObjectMap; }
const CLSID* GetTypeLibraryId() { return NULL; }

/////////////////////////////////////////////////////////////////////////////
// CHostApp

BEGIN_MESSAGE_MAP(CHostApp, CWinApp)
	//{{AFX_MSG_MAP(CHostApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHostApp construction

CHostApp::CHostApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CHostApp object

CHostApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CHostApp initialization

BOOL CHostApp::InitInstance()
{
	CoInitialize(NULL);
	_Module.Init(ObjectMap, GetModuleHandleW(NULL));

	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(L"Local AppWizard-Generated Applications");

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CMultiDocTemplate* pDocTemplate;
	pDocTemplate = new CMultiDocTemplate(
		IDR_HOSTTYPE,
		RUNTIME_CLASS(CHostDoc),
		RUNTIME_CLASS(CChildFrame), // custom MDI child frame
		RUNTIME_CLASS(CHostView));
	AddDocTemplate(pDocTemplate);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// Enable drag/drop open
	m_pMainWnd->DragAcceptFiles();

	// Enable DDE Execute open
	EnableShellOpen();
	RegisterShellFileTypes(TRUE);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The main window has been initialized, so show and update it.
	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CHostApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CHostApp message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(MAINFRM_H)
#define MAINFRM_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
public:
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(MAINFRM_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by host.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_HOSTTYPE                    129
#define IDD_SETTINGS_DLG                130
#define IDC_DATASOURCE1_EDIT            1000
#define IDC_DB_FILE                     1000
#define IDC_QUERY1_EDIT                 1001
#define IDC_DB_QUERY                    1001
#define IDC_DIR_PATH                    1002
#define ID_DATASOURCE1                  32771
#define ID_DATASOURCE2                  32772
#define ID_DATASOURCE3                  32773
#define ID_GDIPLUS                      32774
#define ID_COMCTRL                      32775
#define ID_PRIVATE_ASSEMBLY             32776
#define ID_SETTINGS                     32777
#define ID_HOST_ACTCTX                  32778

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        131
#define _APS_NEXT_COMMAND_VALUE         32779
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\stdinc.h ===
#include "SxApwStdincMfc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\settingsdlg.cpp ===
// SettingsDlg.cpp : implementation file
//

#include "stdinc.h"
#include "host.h"
#include "SettingsDlg.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSettingsDlg dialog


CSettingsDlg::CSettingsDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSettingsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSettingsDlg)
	m_sDBName = L"";
	m_sDBQuery = L"";
	m_sPath = L"";
	//}}AFX_DATA_INIT
}


void CSettingsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSettingsDlg)
	DDX_Text(pDX, IDC_DB_FILE, m_sDBName);
	DDX_Text(pDX, IDC_DB_QUERY, m_sDBQuery);
	DDX_Text(pDX, IDC_DIR_PATH, m_sPath);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSettingsDlg, CDialog)
	//{{AFX_MSG_MAP(CSettingsDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSettingsDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\settingsdlg.h ===
#if !defined(AFX_SETTINGSDLG_H__9D7A8A15_FE41_4948_9F22_B70E221DE6CA__INCLUDED_)
#define AFX_SETTINGSDLG_H__9D7A8A15_FE41_4948_9F22_B70E221DE6CA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SettingsDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSettingsDlg dialog

class CSettingsDlg : public CDialog
{
// Construction
public:
	CSettingsDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSettingsDlg)
	enum { IDD = IDD_SETTINGS_DLG };
	CString	m_sDBName;
	CString	m_sDBQuery;
	CString	m_sPath;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSettingsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSettingsDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SETTINGSDLG_H__9D7A8A15_FE41_4948_9F22_B70E221DE6CA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__3ECC5181_50D0_47C0_9598_7E3D42C537EA__INCLUDED_)
#define AFX_STDAFX_H__3ECC5181_50D0_47C0_9598_7E3D42C537EA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#include "atlbase.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3ECC5181_50D0_47C0_9598_7E3D42C537EA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host1\stdinc.h ===
#include "SxApwStdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host1\chost.h ===
/*
*/
#pragma once

#include "ihost.h"

class __declspec(uuid(CLSID_CSxApwHost_declspec_uuid))
CSxApwHost
:
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwHost, &__uuidof(CSxApwHost)>,
    public ISxApwHost
{
public:
    CSxApwHost() { }

    BEGIN_COM_MAP(CSxApwHost)
	    COM_INTERFACE_ENTRY(ISxApwHost)
    END_COM_MAP()

    DECLARE_NO_REGISTRY();

    STDMETHODIMP
	EstimateRowCount(
		int
		);

	STDMETHODIMP
	OnNextRow(
        int     nColumns,
		const PCWSTR columns[]
		);

    HRESULT Main();

    typedef std::vector<CSxApwComPtr<ISxApwUiView> > Views_t;
    Views_t m_views;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host1\chost.cpp ===
#include "stdinc.h"
#include "SxApwHandle.h"
#include "SxApwCreate.h"
#include <string>
#include <vector>
#include <fstream>
#include <iostream>
#include "idsource.h"
#include "chost.h"

static ATL::CComModule Module;

BEGIN_OBJECT_MAP(ObjectMap)
    //OBJECT_ENTRY(__uuidof(CSxApwHost), CSxApwHost)
END_OBJECT_MAP()

ATL::CComModule* GetModule() { return &Module; }
ATL::_ATL_OBJMAP_ENTRY* GetObjectMap() { return ObjectMap; }
const CLSID* GetTypeLibraryId() { return NULL; }


std::wstring MultiByteToWideChar( const std::string& source )
{
    std::vector<WCHAR> wch;
    wch.resize( MultiByteToWideChar( CP_ACP, 0, source.data(), source.size(), NULL, 0 ) );
    MultiByteToWideChar( CP_ACP, 0, source.data(), source.size(), &wch.front(), wch.size() );

    return std::wstring( wch.begin(), wch.end() );
}


STDMETHODIMP
CSxApwHost::EstimateRowCount(
	int
	)
{
    /* just ignore it */
    return S_OK;
}

STDMETHODIMP
CSxApwHost::OnNextRow(
    int     nColumns,
	const PCWSTR columns[]
	)
{
    /*
    just multiplex/broadcast the data across all the views..
    */
    for (Views_t::const_iterator i = m_views.begin(); i != m_views.end() ; ++i)
    {
        (*i)->OnNextRow(nColumns, columns);
    }
    return S_OK;
}

HRESULT CSxApwHost::Main()
{
    HRESULT hr;
    ATL::CComPtr<ISxApwDataSource>  dirSource;
    ATL::CComPtr<ISxApwDataSource>  dbSource;
    std::ifstream    inStream;

    if (FAILED(hr = SetDataSource(CLSID_CSxApwDirDataSource_brace_stringW)))
        goto Exit;
    dirSource = m_dataSource;
    m_dataSource.Release();
    if (FAILED(hr = SetDataSource(CLSID_CSxApwDbDataSource_brace_stringW)))
        goto Exit;
    dbSource = m_dataSource;
    m_dataSource.Release();

    if (FAILED(hr = CreateView(CLSID_CSxApwStdoutView_brace_stringW, NULL)))
        goto Exit;

    if (FAILED(hr = dirSource->SetSite(this)))
        goto Exit;
    if (FAILED(hr = dirSource->RunQuery(L"C:\\*")))
        goto Exit;

    inStream.open("dbqueries.txt");
    if (!inStream.is_open())
    {
        hr = E_FAIL;
        goto Exit;
    }

    while (!inStream.eof())
    {
        std::string  line;
        std::getline(inStream, line);
        if (line.empty())
        {
            break;
        }
        std::wstring wLine = MultiByteToWideChar(line);
        if (FAILED(hr = dbSource->SetSite(this)))
            goto Exit;
        if (FAILED(hr = dbSource->RunQuery(wLine.c_str())))
            goto Exit;
    }

Exit:
    return hr;
}

int __cdecl main()
{
    CoInitialize(NULL);
    _Module.Init(ObjectMap, GetModuleHandleW(NULL));
    ATL::CComObject<CSxApwHost> host;
    host.Main();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host2\3host2.h ===
/*
*/
#pragma once

#include "mshtml.h"
#include "ihost.h"
#include "SxApwComPtr.h"
#include "atlwin.h"
#include <vector>
#include "FusionTrace.h"
#include "iuiview.h"
#include "SxApwWin.h"
#include "mshtmdid.h"
#include "comdef.h"
#include "exdisp.h"

extern _ATL_FUNC_INFO s_OnClickSignature;

class __declspec(uuid(CLSID_CSxApwHost_declspec_uuid))
CSxApwHost
:
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwHost, &__uuidof(CSxApwHost)>,
    public ISxApwHost,
    //public IDispatch,
    //public CSxApwHtmlEventSink
    public ATL::IDispEventSimpleImpl<1, CSxApwHost, &DIID_HTMLElementEvents2>,
    public ATL::IDispEventSimpleImpl<2, CSxApwHost, &DIID_HTMLElementEvents2>
{
    typedef ATL::IDispEventSimpleImpl<1, CSxApwHost, &DIID_HTMLElementEvents2> EventDisp1;
    typedef ATL::IDispEventSimpleImpl<2, CSxApwHost, &DIID_HTMLElementEvents2> EventDisp2;
public:

	CSxApwHost() { }

	BEGIN_COM_MAP(CSxApwHost)
		COM_INTERFACE_ENTRY(ISxApwHost)
		//COM_INTERFACE_ENTRY(IDispatch)
	END_COM_MAP()

	DECLARE_NO_REGISTRY();

    void __stdcall OnClick1()
    {
        printf("%s\n", __FUNCTION__);
    }

    void __stdcall OnClick2()
    {
        printf("%s\n", __FUNCTION__);
    }

    BEGIN_SINK_MAP(CSxApwHost)
       //SINK_ENTRY(1, DISPID_HTMLELEMENTEVENTS2_ONCLICK, OnClick1)
       //SINK_ENTRY(2, DISPID_HTMLELEMENTEVENTS2_ONCLICK, OnClick2)
       SINK_ENTRY_INFO(1, DIID_HTMLElementEvents2, DISPID_HTMLELEMENTEVENTS2_ONCLICK, OnClick1, &s_OnClickSignature)
       SINK_ENTRY_INFO(2, DIID_HTMLElementEvents2, DISPID_HTMLELEMENTEVENTS2_ONCLICK, OnClick2, &s_OnClickSignature)
    END_SINK_MAP()

    virtual void OnClick()
    {
    }

    STDMETHOD(SetDataSource)(
        LPCWSTR
        );

    STDMETHOD(CreateView)(
        LPCWSTR
        );

    STDMETHOD(DestroyView)(
        LPCWSTR
        ) { return S_OK; }

    STDMETHOD(RunQuery)(
        LPCWSTR
        );

	STDMETHOD(OnNextRow)(
        int     nColumns,
		const LPCWSTR columns[]
		);

	STDMETHOD(OnRowCountEstimateAvailable)(
		int
		);

    STDMETHOD(OnQueryDone)(
        ) { return S_OK; }

    STDMETHOD(InformSchema)(
        const SxApwColumnInfo  rgColumnInfo[],
        int                    nColumnCount
        );

	HRESULT Main();

private:
    typedef std::vector<CSxApwComPtr<ISxApwUiView> > Views_t;
    Views_t m_views;
    CSxApwComPtr<ISxApwDataSource> m_dataSource;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host2\4host2.h ===
/*
*/
#pragma once

#include "mshtml.h"
#include "ihost.h"
#include "SxApwComPtr.h"
#include "atlwin.h"
#include <vector>
#include "FusionTrace.h"
#include "iuiview.h"
#include "SxApwWin.h"
#include "mshtmdid.h"
#include "comdef.h"
#include "exdisp.h"

extern _ATL_FUNC_INFO s_OnClickSignature;

class __declspec(uuid(CLSID_CSxApwHost_declspec_uuid))
CSxApwHost
:
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwHost, &__uuidof(CSxApwHost)>,
    public ISxApwHost,
    //public CSxApwHtmlEventSink
    public IDispatch
    //public ATL::IDispEventSimpleImpl<1, CSxApwHost, &DIID_HTMLElementEvents2>,
    //public ATL::IDispEventSimpleImpl<2, CSxApwHost, &DIID_HTMLElementEvents2>
{
public:
    //typedef ATL::IDispEventSimpleImpl<1, CSxApwHost, &DIID_HTMLElementEvents2> EventDisp1;
    //typedef ATL::IDispEventSimpleImpl<2, CSxApwHost, &DIID_HTMLElementEvents2> EventDisp2;

	CSxApwHost() { }

	BEGIN_COM_MAP(CSxApwHost)
		COM_INTERFACE_ENTRY(ISxApwHost)
		COM_INTERFACE_ENTRY(IDispatch)
	END_COM_MAP()

	DECLARE_NO_REGISTRY();

    void __stdcall F1()
    {
        printf("%s\n", __FUNCTION__);
    }

    void __stdcall F2()
    {
        printf("%s\n", __FUNCTION__);
    }

    STDMETHOD(Invoke)(
        DISPID      dispId, 
        REFIID      riid,
        LCID        lcid, 
        WORD        wFlags, 
        DISPPARAMS* pDispParams, 
        VARIANT*    pVarResult, 
        EXCEPINFO*  pExcepInfo, 
        UINT*       puArgErr 
        )
    {
        switch (dispId)
        {
        case 1:
            F1();
            break;
        case 2:
            F2();
            break;
        }
        return S_OK;
    }


    STDMETHOD(GetTypeInfoCount)(
        UINT* pcinto
        )
    {
        *pcinto = 0;
        return S_OK;
    }

    STDMETHOD(GetTypeInfo)(
        UINT        iTInfo, 
        LCID        lcid, 
        ITypeInfo** ppTInfo
        )
    {
        *ppTInfo = NULL;
        return E_NOTIMPL;
    }

    STDMETHOD(GetIDsOfNames)(
        REFIID  iid,
        PWSTR*  rgpszNames,
        UINT    cNames,
        LCID    lcid,
        DISPID* rgDispId
        )
    {
        //
        // Simple: find a run of decimal digits in each name, and convert it.
        //
        UINT i;
        for (i = 0 ; i != cNames ; ++i)
        {
            rgDispId[i] = _wtoi(rgpszNames[i] + wcscspn(rgpszNames[i], L"0123456789"));
        }
        return S_OK;
    }

    /*
    BEGIN_SINK_MAP(CSxApwHost)
       //SINK_ENTRY(1, DISPID_HTMLELEMENTEVENTS2_ONCLICK, OnClick1)
       //SINK_ENTRY(2, DISPID_HTMLELEMENTEVENTS2_ONCLICK, OnClick2)
       SINK_ENTRY_INFO(1, DIID_HTMLElementEvents2, DISPID_HTMLELEMENTEVENTS2_ONCLICK, F1, &s_OnClickSignature)
       SINK_ENTRY_INFO(2, DIID_HTMLElementEvents2, DISPID_HTMLELEMENTEVENTS2_ONCLICK, F2, &s_OnClickSignature)
    END_SINK_MAP()
    */

    STDMETHOD(SetDataSource)(
        LPCWSTR
        );

    STDMETHOD(CreateView)(
        LPCWSTR
        );

    STDMETHOD(DestroyView)(
        LPCWSTR
        ) { return S_OK; }

    STDMETHOD(RunQuery)(
        LPCWSTR
        );

	STDMETHOD(OnNextRow)(
        int     nColumns,
		const LPCWSTR columns[]
		);

	STDMETHOD(OnRowCountEstimateAvailable)(
		int
		);

    STDMETHOD(OnQueryDone)(
        ) { return S_OK; }

    STDMETHOD(InformSchema)(
        const SxApwColumnInfo  rgColumnInfo[],
        int                    nColumnCount
        );

	HRESULT Main();

private:
    typedef std::vector<CSxApwComPtr<ISxApwUiView> > Views_t;
    Views_t m_views;
    CSxApwComPtr<ISxApwDataSource> m_dataSource;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host2\host2.h ===
/*
*/
#pragma once

#include <set>
#include <assert.h>
#include <string>
#include "mshtml.h"
#include "ihost.h"
#include "SxApwComPtr.h"
#include "atlwin.h"
#include "FusionTrace.h"
#include "iuiview.h"
#include "SxApwWin.h"
#include "HostFrame.h"

extern _ATL_FUNC_INFO s_OnClickSignature;

class __declspec(uuid(CLSID_CSxApwHost_declspec_uuid))
CSxApwHost
:
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwHost, &__uuidof(CSxApwHost)>,
    public ISxApwHost
{
public:
	CSxApwHost() { }

	BEGIN_COM_MAP(CSxApwHost)
		COM_INTERFACE_ENTRY(ISxApwHost)
	END_COM_MAP()

	DECLARE_NO_REGISTRY();

    STDMETHOD(SetDataSource)(
        LPCWSTR
        );

    STDMETHOD(CreateView)(
        LPCWSTR
        );

    STDMETHOD(DestroyView)(
        LPCWSTR
        );

    STDMETHOD(RunQuery)(
        LPCWSTR
        );

	STDMETHOD(OnNextRow)(
        int     nColumns,
		const LPCWSTR columns[]
		);

	STDMETHOD(OnRowCountEstimateAvailable)(
		int
		);

    STDMETHOD(OnQueryDone)(
        );

    STDMETHOD(InformSchema)(
        const SxApwColumnInfo  rgColumnInfo[],
        int                    nColumnCount
        );

	HRESULT Main();

private:
    void MdiTile();

    class CView
    {
    public:
        CView() { }
        ~CView() { }

        CView(const CView& that) :
            m_string(that.m_string)
        {
            assert(that.m_axMdiChild.m_hWnd == NULL);
            assert(that.m_iuiview == NULL);
        }

        void operator=(const CView& that)
        {
            this->m_string = that.m_string;
            assert(this->m_axMdiChild.m_hWnd == NULL);
            assert(that.m_axMdiChild.m_hWnd == NULL);
            assert(this->m_iuiview == NULL);
            assert(that.m_iuiview == NULL);
        }

        bool operator<(const CView& that) const
        {
            return _wcsicmp(this->m_string.c_str(), that.m_string.c_str()) < 0;
        }

        std::wstring                m_string;
        CSxApwHostAxMdiChild        m_axMdiChild;
        CSxApwComPtr<ISxApwUiView>  m_iuiview;
    };

    typedef std::set<CView>         CViews;
    typedef std::pair<CViews::iterator, bool> CViewsConditionalInsertPair;

    CViews                          m_views;
    CSxApwComPtr<ISxApwDataSource>  m_dataSource;
    CSxApwHostMdiClient             m_mdiClient;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host2\create.h ===
#pragma once

#include "ihost.h"
#include "ithunk.h"
#include "idsource.h"
#include "iuiview.h"

HRESULT
SxApwHostCreateObject(
    REFCLSID   rclsid,
    REFIID     riid,
    DWORD      dwFlags,
    void**     pp
    );

/*
an acceptable error from CreateActCtx
*/
BOOL
SxApwIsErrorResourceNotFound(
    DWORD dwError
    );

class CSxApwActCtxHandle;
class CSxApwActCtxScope;

class CSxApwActCtxHandle : public CFusionActCtxHandle
{
private:
    typedef CFusionActCtxHandle Base;
public:
    CSxApwActCtxHandle() { }
    CSxApwActCtxHandle(HANDLE handle) : Base(handle) { }
    ~CSxApwActCtxHandle() { }

    void operator=(HANDLE handle) { Base::operator=(handle); }

    HRESULT HrCreate(const std::wstring& dllPath)
    {
        HRESULT hr = S_OK;
        ACTCTXW actCtx;
        BOOL    fResourceNotFound = FALSE;
        actCtx.cbSize = sizeof(actCtx);
        actCtx.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
        actCtx.lpResourceName = MAKEINTRESOURCE(3); // magic number
        actCtx.lpSource = dllPath.c_str();
        IFFALSE_WIN32TOHR_EXIT(hr, Win32Create(&actCtx)
            || (fResourceNotFound = SxApwIsErrorResourceNotFound(::GetLastError())));
        if (fResourceNotFound)
            Base::operator=(static_cast<HANDLE>(NULL));
        hr = S_OK;
    Exit:
        return hr;
    }
};

template <typename T>
class CSxApwThunk
{
public:
    CSxApwThunk() { }
    ~CSxApwThunk()
    {
        //hack/leak/undone/garbage
        //if (m_actctxHandle != NULL)
        //    SxApwReleaseActCtx(m_actctxHandle->GetCPlusPlusObject());
    }

    STDMETHOD(InitThunk)(
        IUnknown*           underlyingUnknown,
        HANDLE              actctxHandle
        )
    {
        m_underlying = underlyingUnknown;
        m_actctxHandle = actctxHandle;
        return S_OK;
    }

protected:
    CSxApwComPtr<T>         m_underlying;
    CSxApwActCtxHandle      m_actctxHandle;

private:
    CSxApwThunk(const CSxApwThunk&);    // intentially not implemented
    void operator=(const CSxApwThunk&); // intentially not implemented
};

class __declspec(uuid(CLSID_CSxApwHostThunk_declspec_uuid)) CSxApwHostThunk :
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwHostThunk, &__uuidof(CSxApwHostThunk)>,
    public ISxApwHost,
    public ISxApwThunk,
    public CSxApwThunk<ISxApwHost>
{
    typedef CSxApwThunk<ISxApwHost> CSxApwThunk;
public:

    BEGIN_COM_MAP(CSxApwHostThunk)
	    COM_INTERFACE_ENTRY(ISxApwHost)
	    COM_INTERFACE_ENTRY(ISxApwThunk)
	    COM_INTERFACE_ENTRY(CSxApwHostThunk)
    END_COM_MAP()

    DECLARE_NO_REGISTRY();

    CSxApwHostThunk() { }
    ~CSxApwHostThunk() { }

    typedef ISxApwHost ThunkedInterface;

    STDMETHOD(InitThunk)(
        IUnknown*           underlyingUnknown,
        HANDLE              actctxHandle
        ) { return CSxApwThunk::InitThunk(underlyingUnknown, actctxHandle); }

    STDMETHOD(RunQuery)(
        LPCWSTR
        );

    STDMETHOD(SetDataSource)(
        LPCWSTR
        );

    STDMETHOD(CreateView)(
        LPCWSTR
        );

    STDMETHOD(DestroyView)(
        LPCWSTR
        );

    STDMETHOD(OnQueryDone)(
        );

    STDMETHOD(InformSchema)(
        const SxApwColumnInfo   rgColumnInfo[],
        int                     nColumns
        );

	STDMETHOD(OnNextRow)(
		int     nColumns,
		const LPCWSTR columns[]
		);

	STDMETHOD(OnRowCountEstimateAvailable)(
		int nRowCountEstimate
		);

private:
    CSxApwHostThunk(const CSxApwHostThunk&);    // intentially not implemented
    void operator=(const CSxApwHostThunk&);     // intentially not implemented
};

class __declspec(uuid(CLSID_CSxApwDataSourceThunk_declspec_uuid)) CSxApwDataSourceThunk :
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwDataSourceThunk, &__uuidof(CSxApwDataSourceThunk)>,
    public ISxApwDataSource,
    public ISxApwThunk,
    public CSxApwThunk<ISxApwDataSource>
{
    typedef CSxApwThunk<ISxApwDataSource> CSxApwThunk;
public:
    BEGIN_COM_MAP(CSxApwDataSourceThunk)
	    COM_INTERFACE_ENTRY(ISxApwDataSource)
        COM_INTERFACE_ENTRY(ISxApwThunk)
    END_COM_MAP()

    DECLARE_NO_REGISTRY();

    typedef ISxApwDataSource ThunkedInterface;

    CSxApwDataSourceThunk() { }
    ~CSxApwDataSourceThunk() { }

    STDMETHOD(InitThunk)(
        IUnknown*           underlyingUnknown,
        HANDLE              actctxHandle
        ) { return CSxApwThunk::InitThunk(underlyingUnknown, actctxHandle); }

    STDMETHOD(SetSite)(
        ISxApwHost* host
        );

    STDMETHOD(RunQuery)(
        LPCWSTR query
        );

    STDMETHOD(StopQuery)(
        );

private:
    CSxApwDataSourceThunk(const CSxApwDataSourceThunk&);    // intentially not implemented
    void operator=(const CSxApwDataSourceThunk&);       // intentially not implemented
};

class __declspec(uuid(CLSID_CSxApwUiViewThunk_declspec_uuid)) CSxApwUiViewThunk :
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwUiViewThunk, &__uuidof(CSxApwUiViewThunk)>,
    public ISxApwUiView,
    public ISxApwThunk,
    public CSxApwThunk<ISxApwUiView>
{
    typedef CSxApwThunk<ISxApwUiView> CSxApwThunk;
public:

    typedef ISxApwUiView ThunkedInterface;

    BEGIN_COM_MAP(CSxApwUiViewThunk)
	    COM_INTERFACE_ENTRY(ISxApwUiView)
        COM_INTERFACE_ENTRY(ISxApwThunk)
    END_COM_MAP()

    DECLARE_NO_REGISTRY();

    CSxApwUiViewThunk() { }
    ~CSxApwUiViewThunk() { }

    STDMETHOD(InitThunk)(
        IUnknown*           underlyingUnknown,
        HANDLE              actctxHandle
        ) { return CSxApwThunk::InitThunk(underlyingUnknown, actctxHandle); }

    STDMETHOD(SetSite)(
        ISxApwHost* host
        );

    STDMETHOD(CreateWindow)(
        HWND hWnd
        );

	STDMETHOD(OnNextRow)(
		int     nColumns,
		const LPCWSTR* prgszColumns
		);

	STDMETHOD(OnRowCountEstimateAvailable)(
		int nRowCountEstimate
		);

	STDMETHOD(OnQueryStart)(
		);

	STDMETHOD(OnQueryDone)(
		);

    STDMETHOD(InformSchema)(
        const SxApwColumnInfo   rgColumnInfo[],
        int                     nColumns
        );
private:
    CSxApwUiViewThunk(const CSxApwUiViewThunk&);    // intentially not implemented
    void operator=(const CSxApwUiViewThunk&);       // intentially not implemented
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host2\host2.cpp ===
#include "stdinc.h"
#include <string>
#include "ihost.h"
#include "ithunk.h"
#include "idsource.h"
#include "iuiview.h"
#include "atlhost.h"
#include "SxApwHandle.h"
#include "SxApwCreate.h"
#include "HostFrame.h"
#include "host2.h"
#include "create.h"
#include "resource.h"

using namespace std;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static ATL::CComModule Module;

_ATL_FUNC_INFO s_OnClickSignature = {CC_STDCALL, VT_EMPTY, 0 };

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(__uuidof(CSxApwHost), CSxApwHost)
    OBJECT_ENTRY(__uuidof(CSxApwHostThunk), CSxApwHostThunk)
    OBJECT_ENTRY(__uuidof(CSxApwDataSourceThunk), CSxApwDataSourceThunk)
    OBJECT_ENTRY(__uuidof(CSxApwUiViewThunk), CSxApwUiViewThunk)
END_OBJECT_MAP()

ATL::CComModule* GetModule() { return &Module; }
ATL::_ATL_OBJMAP_ENTRY* GetObjectMap() { return ObjectMap; }
const CLSID* GetTypeLibraryId() { return NULL; }

STDMETHODIMP
CSxApwHost::OnRowCountEstimateAvailable(
	int nRows
	)
{
    /*
    just multiplex/broadcast the data across all the views..
    */
    for (CViews::const_iterator i = m_views.begin(); i != m_views.end() ; ++i)
    {
        i->m_iuiview->OnRowCountEstimateAvailable(nRows);
    }
    return S_OK;
}

STDMETHODIMP
CSxApwHost::OnNextRow(
    int     nColumns,
	const PCWSTR* columns
	)
{
    /*
    just multiplex/broadcast the data across all the views..
    */
    for (CViews::const_iterator i = m_views.begin(); i != m_views.end() ; ++i)
    {
        i->m_iuiview->OnNextRow(nColumns, columns);
    }
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
CSxApwHost::InformSchema(
    const SxApwColumnInfo  rgColumnInfo[],
    int                    nColumnCount
    )
{
    /*
    just multiplex/broadcast the data across all the views..
    */
    for (CViews::const_iterator i = m_views.begin(); i != m_views.end() ; ++i)
    {
        i->m_iuiview->InformSchema(rgColumnInfo, nColumnCount);
    }
    return S_OK;
}

STDMETHODIMP
CSxApwHost::SetDataSource(
    LPCWSTR datasource
    )
{
    HRESULT hr;

    if (FAILED(hr = SxApwHostCreateObject(datasource, SXAPW_CREATEOBJECT_WRAP, m_dataSource)))
        goto Exit;
    if (FAILED(hr = m_dataSource->SetSite(this)))
        goto Exit;
Exit:
    return hr;
}

STDMETHODIMP
CSxApwHost::DestroyView(
    LPCWSTR viewstr
    )
{
    HRESULT hr = S_OK;
    CView key;
    key.m_string = viewstr;
    CViews::iterator i = m_views.find(key);
    if (i == m_views.end())
    {
        hr = S_OK;
        goto Exit;
    }
    i->m_axMdiChild.DestroyWindow();
    m_views.erase(i);
    MdiTile();
    hr = S_OK;
Exit:
    return hr;
}

void CSxApwHost::MdiTile()
{
    SendMessageW(m_mdiClient, WM_MDITILE, MDITILE_VERTICAL, 0);
    //SendMessageW(m_mdiClient, WM_MDITILE, MDITILE_HORIZONTAL, 0);
}

STDMETHODIMP
CSxApwHost::CreateView(
    LPCWSTR viewstr
    )
{
    HRESULT                     hr = 0;
    RECT                        rc = { 0 };
    MDICREATESTRUCT             mdiCreateStruct = { 0 };
    CREATESTRUCT                createStruct = { 0 };

    wstring                     sTemp;
    wstring                     sTitle;

    sTemp.assign( viewstr );
    if (sTemp.find( L"comctl32_v6") != wstring::npos )
    {
        sTitle.assign(L"ComCtl32 v6");
    }
    else
        if (sTemp.find( L"comctl32_v5") != wstring::npos )
        {
            sTitle.assign(L"ComCtl32 v5");
        }
        else
            if (sTemp.find( L"comctl32") != wstring::npos )
            {
                sTitle.assign(L"ComCtl32");
            }
            else
                if (sTemp.find( L"sxapwedit") != wstring::npos )
                {
                    sTitle.assign(L"SxS ApW Edit");
                }
                else
                    if (sTemp.find( L"sxapwstdout") != wstring::npos )
                    {
                        sTitle.assign(L"SxS ApW StdOut");
                    }
                    else
                    {
                        sTitle.assign(L"Views and Sources");
                    }


    CView key;
    key.m_string = viewstr;
    CViewsConditionalInsertPair p = m_views.insert(key);

    if (!p.second)
    {
        hr = S_OK;
        goto Exit;
    }

    CView& view = *p.first;
    IFFALSE_WIN32TOHR_EXIT(hr, m_mdiClient.GetClientRect(&rc));
    createStruct.lpCreateParams = &mdiCreateStruct;
    IFFALSE_WIN32TOHR_EXIT(hr, view.m_axMdiChild.Create(m_mdiClient, rc, sTitle.c_str(), 0, 0, 0, &createStruct));
    view.m_axMdiChild.ShowWindow(SW_SHOWDEFAULT);

    if (FAILED(hr = SxApwHostCreateObject(viewstr, SXAPW_CREATEOBJECT_WRAP, view.m_iuiview)))
        goto Exit;
    if (FAILED(hr = view.m_iuiview->SetSite(this)))
        goto Exit;
    if (FAILED(hr = view.m_iuiview->CreateWindow(view.m_axMdiChild)))
        goto Exit;
    MdiTile();
Exit:
    return hr;
}

STDMETHODIMP
CSxApwHost::OnQueryDone(
    )
{
    HRESULT hr = S_OK;

    for (CViews::const_iterator i = m_views.begin(); i != m_views.end() ; ++i)
        i->m_iuiview->OnQueryDone();

    return hr;
}

STDMETHODIMP
CSxApwHost::RunQuery(
    LPCWSTR query
    )
{
    HRESULT hr = S_OK;

    for (CViews::const_iterator i = m_views.begin(); i != m_views.end() ; ++i)
        i->m_iuiview->OnQueryStart();
    if (FAILED(hr = m_dataSource->RunQuery(query)))
        goto Exit;
Exit:
    return hr;
}

HRESULT CSxApwHost::Main()
{
    HRESULT                                 hr = 0;
    RECT                                    rc = { 0 };
    CREATESTRUCT                            createStruct =  { 0 };
    CLIENTCREATESTRUCT                      clientCreateStruct = { 0 };
    int                                     bRet = 0;
    MSG                                     msg = { 0 };
    CSxApwHostFrame                         frameWindow;

	CoInitialize(NULL);
	GetComModule()->Init(ObjectMap, GetModuleHandleW(NULL));

    IFFALSE_WIN32TOHR_EXIT(hr, frameWindow.Create(NULL, ATL::CWindow::rcDefault, L"Fusion Win32 App Team AppWeek"));
    frameWindow.AddMenu();
    frameWindow.ShowWindow(SW_SHOWDEFAULT);

    IFFALSE_WIN32TOHR_EXIT(hr, frameWindow.GetClientRect(&rc));
    IFFALSE_WIN32TOHR_EXIT(hr, m_mdiClient.Create(frameWindow, rc, L"2", 0, 0, 0, &clientCreateStruct));
    frameWindow.m_hClient = m_mdiClient.m_hWnd;
    m_mdiClient.ShowWindow(SW_SHOWDEFAULT);

    if (FAILED(hr = CreateView(CLSID_CSxApwControllerView_brace_stringW)))
        goto Exit;

    while ((bRet = GetMessageW(&msg, NULL, 0, 0)) != 0
            && bRet != -1
            && msg.message != WM_QUIT
            )
    {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
    hr = S_OK;
Exit:
    return hr;
}

int __cdecl main()
{
    // leak for now..
    ATL::CComObject<CSxApwHost>* host = new ATL::CComObject<CSxApwHost>;
    host->AddRef();
    host->Main();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host2\create.cpp ===
#include "stdinc.h"
#include <string>
#include <assert.h>
#include <string.h>
#include <set>
#include "ihost.h"
#include "ithunk.h"
#include "idsource.h"
#include "iuiview.h"
#include "SxApwHandle.h"
#include "SxApwCreate.h"
#include "SxApwContext.h"
#include "SxApwComPtr.h"
#include "SxApwDLoad.h"
#include "create.h"

typedef HRESULT (STDMETHODCALLTYPE* PFN_DLL_GET_CLASS_OBJECT)(REFCLSID rclsid, REFIID riid, LPVOID* ppv);

BOOL
SxApwIsErrorResourceNotFound(
    DWORD dwError
    )
{
    if (
           dwError == ERROR_RESOURCE_DATA_NOT_FOUND
        || dwError == ERROR_RESOURCE_TYPE_NOT_FOUND
        || dwError == ERROR_RESOURCE_NAME_NOT_FOUND
        || dwError == ERROR_RESOURCE_LANG_NOT_FOUND
        )
    {
        return TRUE;
    }
    return FALSE;
}

HRESULT
SxApwWrapComObject(
    CSxApwActCtxHandle&   actctx,
    REFIID                riid,
    IUnknown*             punk,
    void**                ppv
    );

template <typename T, typename U>
inline HRESULT
SxApwWrapComObject(
    CSxApwActCtxHandle&   actctx,
    T                     t,
    U                     u
    )
{
    assert(__uuidof(T) == __uuidof(U));
    return SxApwWrapComObject(actctx, __uuidof(T), t, u);
}

class CSxApwActCtxScope : public CFusionActCtxScope
{
private:
    typedef CFusionActCtxScope Base;
public:
    ~CSxApwActCtxScope() { }
    CSxApwActCtxScope() { }
    CSxApwActCtxScope(const CSxApwActCtxHandle& handle) { Init(handle); }
    CSxApwActCtxScope(HANDLE handle)                    { Init(handle); }

    void Init(HANDLE handle)
    {
        if (!Base::Win32Activate(handle))
            OutputDebugStringA("Error ignored in " __FUNCTION__ "\n");
    }
};

STDMETHODIMP
CSxApwHostThunk::InformSchema(
    const SxApwColumnInfo rgColumnInfo[],
    int   nColumns
    )
{
    CSxApwActCtxScope actctxScope(m_actctxHandle);
    return m_underlying->InformSchema(rgColumnInfo, nColumns);
}

STDMETHODIMP
CSxApwHostThunk::OnQueryDone(
    )
{
    CSxApwActCtxScope actctxScope(m_actctxHandle);
    return m_underlying->OnQueryDone();
}

STDMETHODIMP
CSxApwHostThunk::OnRowCountEstimateAvailable(
    int nRows
    )
{
    CSxApwActCtxScope actctxScope(m_actctxHandle);
    return m_underlying->OnRowCountEstimateAvailable(nRows);
}

STDMETHODIMP
CSxApwHostThunk::OnNextRow(
    int nColumns,
    const LPCWSTR rgpszColumns[]
    )
{
    CSxApwActCtxScope actctxScope(m_actctxHandle);
    return m_underlying->OnNextRow(nColumns, rgpszColumns);
}

STDMETHODIMP CSxApwHostThunk::DestroyView(
    LPCWSTR x
    )
{
    CSxApwActCtxScope actctxScope(m_actctxHandle);
    return m_underlying->DestroyView(x);
}

STDMETHODIMP CSxApwHostThunk::CreateView(
    LPCWSTR x
    )
{
    CSxApwActCtxScope actctxScope(m_actctxHandle);
    return m_underlying->CreateView(x);
}

STDMETHODIMP
CSxApwHostThunk::RunQuery(
    LPCWSTR query
    )
{
    CSxApwActCtxScope actctxScope(m_actctxHandle);
    return m_underlying->RunQuery(query);
}

STDMETHODIMP
CSxApwHostThunk::SetDataSource(
    LPCWSTR datasource
    )
{
    CSxApwActCtxScope actctxScope(m_actctxHandle);
    return m_underlying->SetDataSource(datasource);
}

STDMETHODIMP
CSxApwDataSourceThunk::SetSite(
    ISxApwHost* host
    )
{
    HRESULT hr = S_OK;
    CSxApwComPtr<ISxApwHost> hostThunk;
    CSxApwActCtxHandle actctxHandleNull(NULL);

    if (FAILED(hr = SxApwWrapComObject(actctxHandleNull, host, &hostThunk)))
        return hr;

    CSxApwActCtxScope actctxScope(m_actctxHandle);
    hr = m_underlying->SetSite(hostThunk);
    return hr;
}

STDMETHODIMP
CSxApwDataSourceThunk::RunQuery(
    LPCWSTR query
    )
{
    CSxApwActCtxScope actctxScope(m_actctxHandle);
    return m_underlying->RunQuery(query);
}

STDMETHODIMP
CSxApwDataSourceThunk::StopQuery(
    )
{
    CSxApwActCtxScope actctxScope(m_actctxHandle);
    return m_underlying->StopQuery();
}


STDMETHODIMP
CSxApwUiViewThunk::InformSchema(
    const SxApwColumnInfo rgColumnInfo[],
    int                    nColumns
    )
{
    CSxApwActCtxScope actctxScope(m_actctxHandle);
    return m_underlying->InformSchema(rgColumnInfo, nColumns);
}

STDMETHODIMP
CSxApwUiViewThunk::SetSite(
    ISxApwHost* host
    )
{
    HRESULT hr = S_OK;
    CSxApwComPtr<ISxApwHost> hostThunk;
    CSxApwActCtxHandle actctxHandleNull(NULL);

    if (FAILED(hr = SxApwWrapComObject(actctxHandleNull, host, &hostThunk)))
        return hr;

    CSxApwActCtxScope actctxScope(m_actctxHandle);
    hr = m_underlying->SetSite(hostThunk);
    return hr;
}

STDMETHODIMP
CSxApwUiViewThunk::CreateWindow(
    HWND hWnd
    )
{
    CSxApwActCtxScope actctxScope(m_actctxHandle);
    return m_underlying->CreateWindow(hWnd);
}

STDMETHODIMP
CSxApwUiViewThunk::OnNextRow(
	int     nColumns,
	const LPCWSTR* prgszColumns
	)
{
    CSxApwActCtxScope actctxScope(m_actctxHandle);
    return m_underlying->OnNextRow(nColumns, prgszColumns);
}

STDMETHODIMP
CSxApwUiViewThunk::OnRowCountEstimateAvailable(
	int nRowCountEstimate
	)
{
    CSxApwActCtxScope actctxScope(m_actctxHandle);
    return m_underlying->OnRowCountEstimateAvailable(nRowCountEstimate);
}

STDMETHODIMP
CSxApwUiViewThunk::OnQueryStart(
	)
{
    CSxApwActCtxScope actctxScope(m_actctxHandle);
    return m_underlying->OnQueryStart();
}

STDMETHODIMP
CSxApwUiViewThunk::OnQueryDone(
	)
{
    CSxApwActCtxScope actctxScope(m_actctxHandle);
    return m_underlying->OnQueryDone();
}

class CInterfaceClassPair
{
public:
    const IID*   piid;
    const CLSID* pclsid;
};
const static CInterfaceClassPair g_interfaceClassPairs[] =
{
#define X(x) { &__uuidof(x::ThunkedInterface), &__uuidof(x) },
    X(CSxApwDataSourceThunk)
    X(CSxApwUiViewThunk)
    X(CSxApwHostThunk)
#undef X
};

HRESULT
SxApwWrapComObject(
    CSxApwActCtxHandle&     actctx,
    REFIID                  riid,
    IUnknown*               punk,
    void**                  ppv
    )
{
    HRESULT hr = S_OK;
    ULONG i;
    ATL::CComQIPtr<ISxApwThunk> isAlreadyThunked(punk);
    ATL::CComQIPtr<ISxApwThunk> thunk;

    if (isAlreadyThunked != NULL)
    {
        hr = punk->QueryInterface(riid, ppv);
        goto Exit;
    }

    if (static_cast<HANDLE>(actctx) == NULL)
    {
        WCHAR path[MAX_PATH];
        HMODULE hModule = NULL;

        if (FAILED(hr = SxApwHmoduleFromObject(punk, &hModule)))
            goto Exit;
        IFFALSE_WIN32TOHR_EXIT(hr, GetModuleFileNameW(hModule, path, NUMBER_OF(path)));
        if (FAILED(hr = actctx.HrCreate(path)))
            goto Exit;
    }

    for (i = 0 ; i != NUMBER_OF(g_interfaceClassPairs) ; ++i)
    {
        if (*g_interfaceClassPairs[i].piid == riid)
        {
            if (FAILED(hr = SxApwHostCreateObject(*g_interfaceClassPairs[i].pclsid, SXAPW_CREATEOBJECT_NOWRAP, &thunk)))
                goto Exit;
            if (FAILED(hr = thunk->InitThunk(punk, actctx)))
                goto Exit;
            actctx.Detach();
            hr = thunk->QueryInterface(riid, ppv); // extra addref cycle, trying to avoid 0
            goto Exit;
        }
    }
    OutputDebugStringA("object not wrapped\n");
    hr = S_OK;
Exit:
    return hr;
}

HRESULT
SxApwHostCreateObject(
    PCWSTR   psz,
    REFIID   riid,
    DWORD    dwFlags,
    void**   ppv
    )
{
    HRESULT hr;
    CLSID   clsid;
    PCWSTR  dot;

    if ((dot = wcsrchr(psz, '.')) != NULL
        && _wcsicmp(dot, L".dll") == 0
        )
    {
        //
        // category bind, pass NULL clsid, DllGetClassObject tries the first
        // entry in the map
        //
        const PCWSTR                dllPath = psz;
        CDynamicLinkLibrary         dll;
        CSxApwComPtr<IClassFactory> classFactory;
        CSxApwComPtr<IUnknown>      unk;
        CSxApwActCtxHandle          actctxHandle;
        CSxApwActCtxScope           actctxScope;
        PFN_DLL_GET_CLASS_OBJECT    pfnDllGetClassObject;

        if (dwFlags & SXAPW_CREATEOBJECT_WRAP)
        {
            if (FAILED(hr = actctxHandle.HrCreate(dllPath)))
                goto Exit;
            actctxScope.Init(actctxHandle);
        }
        IFFALSE_WIN32TOHR_EXIT(hr, dll.Win32Create(dllPath));
        IFFALSE_WIN32TOHR_EXIT(hr, dll.GetProcAddress("DllGetClassObject", &pfnDllGetClassObject));
        if (FAILED(hr = pfnDllGetClassObject(GUID_NULL, __uuidof(classFactory), &classFactory)))
            goto Exit;
        if (FAILED(hr = classFactory->CreateInstance(NULL, riid, &unk)))
            goto Exit;
        if (dwFlags & SXAPW_CREATEOBJECT_WRAP)
        {
            if (FAILED(hr = SxApwWrapComObject(actctxHandle, riid, unk, ppv)))
                goto Exit;
        }
        else
        {
            *ppv = unk.Detach();
        }
        dll.Detach(); // leak the dll
        hr = S_OK;
        goto Exit;
    }
    else
    {
        if (FAILED(hr = CLSIDFromString(const_cast<PWSTR>(psz), &clsid)))
            goto Exit;
        if (FAILED(hr = SxApwHostCreateObject(clsid, riid, dwFlags, ppv)))
            goto Exit;
    }
    hr = S_OK;
Exit:
    return hr;
}

HRESULT
SxApwHostCreateObject(
    REFCLSID   rclsid,
    REFIID     riid,
    DWORD      dwFlags,
    void**     ppv
    )
/*
Strategy:
  Enumerate .dlls in the same directory as the .exe, calling DllGetClassObject on each, etc..
  This is subject to change.

  This code is presently shared both by the host and the managers...maybe this is wrong.
*/
{
    HRESULT                     hr = E_FAIL;
    CFindFile                   findFile;
    WCHAR                       exePath[MAX_PATH];
    WCHAR                       dllPath[MAX_PATH];
    HMODULE                     exeHandle;
    WIN32_FIND_DATAW            findData;
    PWSTR                       filePart;

    IFFALSE_WIN32TOHR_EXIT(hr, exeHandle = GetModuleHandleW(NULL));
    IFFALSE_WIN32TOHR_EXIT(hr, GetModuleFileNameW(exeHandle, exePath, RTL_NUMBER_OF(exePath)));
    wcscpy(dllPath, exePath);
    filePart = 1 + wcsrchr(dllPath, '\\');
    wcscpy(filePart, L"sxapw*.dll");

    //
    // enumerate .dlls in the .exe's directory and try any that export DllGetClassObject
    //
    if (findFile.Win32Create(dllPath, &findData))
    {
        bool fCheckedExe = false;
        bool fCheckExe = false;
        do
        {
            CDynamicLinkLibrary         dll;
            CSxApwComPtr<IClassFactory> classFactory;
            CSxApwActCtxHandle          actctxHandle;
            CSxApwActCtxScope           actctxScope;
            PFN_DLL_GET_CLASS_OBJECT    pfnDllGetClassObject;
            CSxApwComPtr<IUnknown> unk;
            //
            // we ought to check the exe first instead of last, and independent of if
            // if there are any .dlls..
            //
            if (fCheckExe)
            {
                fCheckedExe = true;
                wcscpy(dllPath, exePath);
            }
            else
            {
                wcscpy(filePart, findData.cFileName);
            }

            if (dwFlags & SXAPW_CREATEOBJECT_WRAP)
            {
                if (FAILED(hr = actctxHandle.HrCreate(dllPath)))
                    goto Exit;
                actctxScope.Init(actctxHandle);
            }
            IFFALSE_WIN32TOHR_EXIT(hr, dll.Win32Create(dllPath));
            if (dll.GetProcAddress("DllGetClassObject", &pfnDllGetClassObject))
            {
                if (FAILED(hr = pfnDllGetClassObject(rclsid, __uuidof(classFactory), &classFactory)))
                    continue;
            }
            else
            {
                const DWORD LastError = ::GetLastError();
                if (LastError != ERROR_PROC_NOT_FOUND)
                {
                    TRACE_WIN32_FAILURE(GetProcAddress);
                    hr = HRESULT_FROM_WIN32(LastError);
                    goto Exit;
                }
                if (dll != GetModule()->GetModuleInstance())
                {
                    continue;
                }
                if (FAILED(hr = GetModule()->GetClassObject(rclsid, __uuidof(classFactory), &classFactory)))
                    continue;
            }
            if (FAILED(hr = classFactory->CreateInstance(NULL, riid, &unk)))
                continue;
            if (dwFlags & SXAPW_CREATEOBJECT_WRAP)
            {
                if (FAILED(hr = SxApwWrapComObject(actctxHandle, riid, unk, ppv)))
                    goto Exit;
            }
            else
            {
                *ppv = unk.Detach();
            }
            dll.Detach(); // leak the .dll
            hr = S_OK;
            goto Exit;
        } while (FindNextFileW(findFile, &findData) || (!fCheckedExe && (fCheckExe = true)));
    }
    hr = REGDB_E_CLASSNOTREG;
Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host2\hostframe.h ===
#pragma once
#include "atlwin.h"
#include "resource.h"

class CSxApwHostFrame : public ATL::CWindowImpl<CSxApwHostFrame, ATL::CWindow, ATL::CFrameWinTraits>
{
public:
    BEGIN_MSG_MAP(CSxApwHostFrame)
    	MESSAGE_HANDLER( WM_SIZE,	OnSize )
    	COMMAND_ID_HANDLER( IDM_CASCADE, OnTileCascade )
    	COMMAND_ID_HANDLER( IDM_HORTILE, OnTileHorizontal )
    	COMMAND_ID_HANDLER( IDM_VERTILE, OnTileVertical )
    	COMMAND_ID_HANDLER( IDM_APP_EXIT, OnAppExit )
    END_MSG_MAP()

    CSxApwHostFrame() { }
    ~CSxApwHostFrame() { }

    void AddMenu();

    LRESULT OnSize( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

    LRESULT OnTileCascade( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    LRESULT OnTileHorizontal( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    LRESULT OnTileVertical( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    LRESULT OnAppExit( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    HWND m_hClient;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host2\stdinc.h ===
#pragma warning(disable:4189) /* local initialized, but not used, in ATL */
#define SxApwCreateObject SxApwHostCreateObject
#include "SxApwStdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host2\hostframe.cpp ===
#include "stdinc.h"
#include "FusionTrace.h"
#include "hostframe.h"


void CSxApwHostFrame::AddMenu()
{
	HMENU hMenu = CreateMenu();

    HMENU hPopupMenu = CreateMenu();
    AppendMenu( hPopupMenu, MF_STRING, IDM_APP_EXIT, L"E&xit" );
    AppendMenu( hMenu, MF_POPUP, (UINT_PTR)hPopupMenu, L"&File");

    hPopupMenu = CreateMenu();
    AppendMenu( hPopupMenu, MF_STRING, IDM_CASCADE, L"&Cascade" );
    AppendMenu( hPopupMenu, MF_STRING, IDM_HORTILE, L"Tile &Horizontal" );
    AppendMenu( hPopupMenu, MF_STRING, IDM_VERTILE, L"Tile &Vertical" );
    AppendMenu( hMenu, MF_POPUP, (UINT_PTR)hPopupMenu, L"&Windows");
  
    BOOL bResult = SetMenu(hMenu);
    DrawMenuBar();
}

LRESULT CSxApwHostFrame::OnSize( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    RECT rc;
    GetClientRect ( &rc );
//    ::SetWindowPos(m_hClient, rc.left, rc.top, (
//    ::RedrawWindow(m_hClient, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ALLCHILDREN);

    CWindow fooWin;
    fooWin.Attach( m_hClient );
    fooWin.ResizeClient( (rc.right - rc.left), (rc.bottom - rc.top), TRUE);
    fooWin.Detach();
 
    return 0;
}


LRESULT CSxApwHostFrame::OnTileCascade( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    ::SendMessageW( m_hClient, WM_MDICASCADE, MDITILE_ZORDER, 0 );

    return 0;
}


LRESULT CSxApwHostFrame::OnTileHorizontal( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    ::SendMessageW( m_hClient, WM_MDITILE, MDITILE_HORIZONTAL, 0 );

    return 0;
}


LRESULT CSxApwHostFrame::OnTileVertical( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    ::SendMessageW( m_hClient, WM_MDITILE, MDITILE_VERTICAL, 0 );

    return 0;
}


LRESULT CSxApwHostFrame::OnAppExit( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	PostMessageW ( WM_QUIT, 0, 0 );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\idl\guids.c ===
/*
include "idsource.h"
include "ihost.h"
include "iuiview.h"
*/

#define INITGUID
#include "guiddef.h"
#include "SxApwGuids.h"

#define EVAL(x) x

CLSID CLSID_CSxApwStdoutView    = EVAL(SXAPW_GUID_DATA_TO_STRUCT_INITIALIZER CLSID_CSxApwStdoutView_data);
CLSID CLSID_CSxApwDirDataSource = EVAL(SXAPW_GUID_DATA_TO_STRUCT_INITIALIZER CLSID_CSxApwDirDataSource_data);
CLSID CLSID_CSxApwDbDataSource  = EVAL(SXAPW_GUID_DATA_TO_STRUCT_INITIALIZER CLSID_CSxApwDbDataSource_data);

#include "adoguids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\inc\sxapwcontext.h ===
/*
*/

#pragma once

class CSxApwContext
{
public:
    CSxApwContext();
    ~CSxApwContext();

    HRESULT Init(HANDLE ActCtxHandle);
};

/*
These functions are not sufficient. Someone still has to map from HMODULE to HANDLE, and
not just keep creating a new one.
*/
HRESULT SxApwHmoduleFromAddress(void* p, HMODULE* phModule);
HRESULT SxApwHmoduleFromObject(IUnknown* punk, HMODULE* phModule);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\host2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by host2.rc
//
#define IDS_STRING1                     1

// Frame window menu commands
#define IDM_CASCADE						101
#define IDM_HORTILE						102
#define IDM_VERTILE						103
#define IDM_APP_EXIT					104


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\inc\sxapwcomptr.h ===
#pragma once

#include "atlbase.h"

template <typename T> class CSxApwComPtr;

/* like what FusionHandle does */
template <typename T>
class CSmartPointerPointerOrDumbPointerPointerOrVoidPointerPointer
{
public:
    CSmartPointerPointerOrDumbPointerPointerOrVoidPointerPointer(CSxApwComPtr<T>* p) : m(p) { }
    operator CSxApwComPtr<T>*() { return m; }
    operator T**() { return &(*m).p; }
    operator void**() { return reinterpret_cast<void**>(operator T**()); }

    CSxApwComPtr<T>* m;
};

template <typename T>
class CSxApwComPtr : public ATL::CComQIPtr<T>
{
private:
    typedef ATL::CComQIPtr<T> Base;
public:
    ~CSxApwComPtr() { }
    CSxApwComPtr(const CSxApwComPtr& that) : Base(that) { }
    CSxApwComPtr(T* pt = NULL) : Base(pt) { }
    void operator=(T* pt) { Base::operator=(pt); }
    CSxApwComPtr(IUnknown* pt) : Base(pt) { }
    void operator=(IUnknown* pt) { Base::operator=(pt); }
    T* operator->() const { return Base::operator->(); }

    CSmartPointerPointerOrDumbPointerPointerOrVoidPointerPointer<T> operator&()
    {
        return CSmartPointerPointerOrDumbPointerPointerOrVoidPointerPointer<T>(this);
    }
};

//Specialization to make it work
template<>
class CSxApwComPtr<IUnknown> : public ATL::CComQIPtr<IUnknown, &IID_IUnknown>
{
private:
    typedef T IUnknown;
    typedef ATL::CComQIPtr<IUnknown, &IID_IUnknown> Base;
public:
    ~CSxApwComPtr() { }
    CSxApwComPtr(const CSxApwComPtr& that) : Base(that) { }
    CSxApwComPtr(T* pt = NULL) : Base(pt) { }
    void operator=(T* pt) { Base::operator=(pt); }
    T* operator->() const { return Base::operator->(); }

    CSmartPointerPointerOrDumbPointerPointerOrVoidPointerPointer<T> operator&()
    {
        return CSmartPointerPointerOrDumbPointerPointerOrVoidPointerPointer<T>(this);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\inc\fusiontrace.h ===
#pragma once

#include <stdio.h>

#define IFFALSE_WIN32TOHR_EXIT(h,x) \
    do { if (!(x)) { (h) = HRESULT_FROM_WIN32(GetLastError()); goto Exit; } } while(0)

#define IFFAILED_EXIT(x) \
    do { if ((x) != S_OK) goto Exit; } while(0)

#define FN_TRACE_WIN32(f) ((f) = FALSE)
#define FN_TRACE_HR(h) ((h) = E_FAIL)
#define TRACE_WIN32_FAILURE(x) (fprintf(stderr, "%s failed\n", #x))
#define TRACE_WIN32_FAILURE_ORIGINATION(x) TRACE_WIN32_FAILURE(x)
#define IFW32FALSE_EXIT(x) \
    do { if ( !(x) ) { TRACE_WIN32_FAILURE(x); goto Exit; } } while (0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\inc\sxapwdload.h ===
#pragma once

BOOL
WINAPI
SxApwActivateActCtx(
    HANDLE hActCtx,
    ULONG_PTR *lpCookie
    );

BOOL
WINAPI
SxApwDeactivateActCtx(
    DWORD dwFlags,
    ULONG_PTR ulCookie
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\inc\sxapwcreate.h ===
#pragma once

#define SXAPW_CREATEOBJECT_NOWRAP                    0x0001
#define SXAPW_CREATEOBJECT_WRAP                      0x0002

/* The rest are not implemented, because they complicate caching; we cache per .dll. *  /
define SXAPW_CREATEOBJECT_WRAP_USE_SELF             0x0002 /* based on resource id 3 in the dll *  /
define SXAPW_CREATEOBJECT_WRAP_USE_CURRENT          0x0004 /* not implemented, would GetCurrentActCtx *  /
define SXAPW_CREATEOBJECT_WRAP_USE_SPECIFIED        0x0008 /* not implemented, would take another parameter *  /
define SXAPW_CREATEOBJECT_WRAP_USE_PROCESS_DEFAULT  0x0010 /* use process default *  /
define SXAPW_CREATEOBJECT_WRAP_USE_EMPTY            0x0020 /* not implemented *  /
*/

#define SXAPW_PROCESS_DEFAULT_ACTCTX_HANDLE (NULL)

HRESULT
SxApwCreateObject(
    REFCLSID   rclsid,
    REFIID     riid,
    DWORD      dwFlags,
    void**     pp
    );

HRESULT
SxApwCreateObject(
    LPCWSTR    something,
    REFIID     riid,
    DWORD      dwFlags,
    void**     pp
    );

template <typename T>
inline HRESULT
SxApwCreateObject(
    LPCWSTR             something,
    DWORD               dwFlags,
    ATL::CComPtr<T>&    p
    )
{
    return SxApwCreateObject(something, __uuidof(T), dwFlags, reinterpret_cast<void**>(&p));
}

template <typename T>
inline HRESULT
SxApwCreateObject(
    LPCWSTR             something,
    DWORD               dwFlags,
    ATL::CComQIPtr<T>&    p
    )
{
    return SxApwCreateObject(something, __uuidof(T), dwFlags, reinterpret_cast<void**>(&p));
}

template <typename T>
inline HRESULT
SxApwCreateObject(
    LPCWSTR something,
    DWORD   dwFlags,
    T**     pp
    )
{
    return SxApwCreateObject(something, __uuidof(T), dwFlags, reinterpret_cast<void**>(pp));
}

template <typename T>
inline HRESULT
SxApwCreateObject(
    REFCLSID            rclsid,
    DWORD               dwFlags,
    ATL::CComPtr<T>&    p
    )
{
    return SxApwCreateObject(rclsid, __uuidof(T), dwFlags, reinterpret_cast<void**>(&p));
}

template <typename T>
inline HRESULT
SxApwCreateObject(
    REFCLSID            rclsid,
    DWORD               dwFlags,
    ATL::CComQIPtr<T>&  p
    )
{
    return SxApwCreateObject(rclsid, __uuidof(T), dwFlags, reinterpret_cast<void**>(&p));
}

template <typename T>
inline HRESULT
SxApwCreateObject(
    REFCLSID    rclsid,
    DWORD       dwFlags,
    T**         pp
    )
{
    return SxApwCreateObject(rclsid, __uuidof(T), dwFlags, reinterpret_cast<void**>(pp));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\inc\sxapwguids.h ===
/*
All guids appear in this file, and only once.
No guids appear anywhere else.
All forms of guids can be generated from this file, using the
  macros in SxApwGuidDataToXxx.h.
This helps greatly in the ability to reguid.
*/

#if !defined(SXAPW_GUIDS_H_INCLUDED_)
#define SXAPW_GUIDS_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#include "SxApwGuidDataToXxx.h"
#if defined(__midl)
cpp_quote("#if !defined(SXAPW_GUIDS_H_INCLUDED_)")
cpp_quote("#include \"SxApwGuids.h\"")
cpp_quote("#endif")
#endif

#define IID_ISxApwDataSource_data               (00a41643, 0ead, 11d5, b0, 62, 00, 30, 48, 21, 53, 71)
#define IID_ISxApwUiView_data                   (00a41645, 0ead, 11d5, b0, 62, 00, 30, 48, 21, 53, 71)
#define IID_ISxApwHost_data                     (00a41647, 0ead, 11d5, b0, 62, 00, 30, 48, 21, 53, 71)
#define IID_ISxApwThunk_data                    (9c23f0c6, 0ed7, 11d5, ac, 84, 00, 30, 48, 21, 53, 71)
#define IID_ISxApwActCtxHandle_data             (9c23f0c7, 0ed7, 11d5, ac, 84, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxApwHost_data                   (9c23f0ba, 0ed7, 11d5, ac, 84, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxApwDirDataSource_data          (9c23f0be, 0ed7, 11d5, ac, 84, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxApwDbDataSource_data           (f8dce200, 2c6f, 4fe9, 9d, 0b, 7d, 63, 1c, 69, 16, a0)
#define CLSID_CSxApwStdoutView_data             (9c23f0c0, 0ed7, 11d5, ac, 84, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxApwEditView_data               (9c23f0c1, 0ed7, 11d5, ac, 84, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxApwDUserView_data              (e4e31d14, b575, 4c4e, 8a, df, ab, 68, 06, 8e, 6d, da)
#define CLSID_CSxApwComctl32View_data           (2B7269D7, 7F82, 44d8, B5, 34, C1, CD, 96, 5F, 59, 9D)
#define CLSID_CSxApwGDIPlusView_data            (9c23f0c5, 0ed7, 11d5, ac, 84, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxApwUiViewThunk_data            (9c23f0c2, 0ed7, 11d5, ac, 84, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxApwDataSourceThunk_data        (9c23f0c3, 0ed7, 11d5, ac, 84, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxApwHostThunk_data              (9c23f0c4, 0ed7, 11d5, ac, 84, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxApwActCtxHandle_data           (9c23f0c8, 0ed7, 11d5, ac, 84, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxApwControllerView_data         (906a551b, 1571, 11d5, b0, 65, 00, 30, 48, 21, 53, 71)

/*
 (906a551c, 1571, 11d5, b0, 65, 00, 30, 48, 21, 53, 71)
 (906a551d, 1571, 11d5, b0, 65, 00, 30, 48, 21, 53, 71)
 (906a551e, 1571, 11d5, b0, 65, 00, 30, 48, 21, 53, 71)
 (906a551f, 1571, 11d5, b0, 65, 00, 30, 48, 21, 53, 71)
 (906a5520, 1571, 11d5, b0, 65, 00, 30, 48, 21, 53, 71)
 (906a5521, 1571, 11d5, b0, 65, 00, 30, 48, 21, 53, 71)
 (906a5522, 1571, 11d5, b0, 65, 00, 30, 48, 21, 53, 71)
 (906a5523, 1571, 11d5, b0, 65, 00, 30, 48, 21, 53, 71)
*/

#define IID_ISxApwHost_midl                     SXAPW_GUID_DATA_TO_DASHED IID_ISxApwHost_data
#define IID_ISxApwThunk_midl                    SXAPW_GUID_DATA_TO_DASHED IID_ISxApwThunk_data

#define IID_ISxApwDataSource_midl               SXAPW_GUID_DATA_TO_DASHED              IID_ISxApwDataSource_data
#define IID_ISxApwDataSource_struct_initialize  SXAPW_GUID_DATA_TO_STRUCT_INITIALIZER  IID_ISxApwDataSource_data

#define IID_ISxApwUiView_midl                   SXAPW_GUID_DATA_TO_DASHED               IID_ISxApwUiView_data
#define IID_ISxApwUiView_struct_initialize      SXAPW_GUID_DATA_TO_STRUCT_INITIALIZER   IID_ISxApwUiView_data

#define IID_ISxApwActCtxHandle_midl             SXAPW_GUID_DATA_TO_DASHED               IID_ISxApwActCtxHandle_data

#define CLSID_CSxApwHost_midl                   SXAPW_GUID_DATA_TO_DASHED CLSID_CSxApwHost_data
#define CLSID_CSxApwHost_declspec_uuid          SXAPW_GUID_DATA_TO_DASHED_STRING CLSID_CSxApwHost_data

#define CLSID_CSxApwDirDataSource_midl          SXAPW_GUID_DATA_TO_DASHED CLSID_CSxApwDirDataSource_data
#define CLSID_CSxApwDirDataSource_declspec_uuid SXAPW_GUID_DATA_TO_DASHED_STRING CLSID_CSxApwDirDataSource_data

#define CLSID_CSxApwDbDataSource_midl           SXAPW_GUID_DATA_TO_DASHED CLSID_CSxApwDbDataSource_data
#define CLSID_CSxApwDbDataSource_declspec_uuid  SXAPW_GUID_DATA_TO_DASHED_STRING CLSID_CSxApwDbDataSource_data

#define CLSID_CSxApwDirDataSource_brace_stringW SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING_W CLSID_CSxApwDirDataSource_data
#define CLSID_CSxApwDbDataSource_brace_stringW  SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING_W CLSID_CSxApwDbDataSource_data

#define CLSID_CSxApwStdoutView_declspec_uuid    SXAPW_GUID_DATA_TO_DASHED_STRING          CLSID_CSxApwStdoutView_data
#define CLSID_CSxApwStdoutView_brace_stringW    SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING_W CLSID_CSxApwStdoutView_data

#define CLSID_CSxApwEditView_declspec_uuid      SXAPW_GUID_DATA_TO_DASHED_STRING          CLSID_CSxApwEditView_data
#define CLSID_CSxApwEditView_brace_stringW      SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING_W CLSID_CSxApwEditView_data

#define CLSID_CSxApwGDIPlusView_declspec_uuid   SXAPW_GUID_DATA_TO_DASHED_STRING          CLSID_CSxApwGDIPlusView_data
#define CLSID_CSxApwGDIPlusView_brace_stringW   SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING_W CLSID_CSxApwGDIPlusView_data

#define CLSID_CSxApwDUserView_declspec_uuid     SXAPW_GUID_DATA_TO_DASHED_STRING          CLSID_CSxApwDUserView_data
#define CLSID_CSxApwDUserView_brace_stringW     SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING_W CLSID_CSxApwDUserView_data

#define CLSID_CSxApwComctl32View_declspec_uuid  SXAPW_GUID_DATA_TO_DASHED_STRING          CLSID_CSxApwComctl32View_data
#define CLSID_CSxApwComctl32View_brace_stringW  SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING_W CLSID_CSxApwComctl32View_data

#define CLSID_CSxApwUiViewThunk_declspec_uuid       SXAPW_GUID_DATA_TO_DASHED_STRING        CLSID_CSxApwUiViewThunk_data
#define CLSID_CSxApwDataSourceThunk_declspec_uuid   SXAPW_GUID_DATA_TO_DASHED_STRING        CLSID_CSxApwDataSourceThunk_data
#define CLSID_CSxApwHostThunk_declspec_uuid         SXAPW_GUID_DATA_TO_DASHED_STRING        CLSID_CSxApwHostThunk_data
#define CLSID_CSxApwActCtxHandle_declspec_uuid      SXAPW_GUID_DATA_TO_DASHED_STRING        CLSID_CSxApwActCtxHandle_data
#define CLSID_CSxApwControllerView_declspec_uuid    SXAPW_GUID_DATA_TO_DASHED_STRING        CLSID_CSxApwControllerView_data
#define CLSID_CSxApwControllerView_brace_stringW    SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING_W   CLSID_CSxApwControllerView_data

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\inc\sxapwhandle.h ===
#pragma once

#define FUSION_INC_FUSIONTRACE_H_INCLUDED_
#define _FUSION_INC_DEBMACRO_H_INCLUDED_
#define _FUSION_INC_SXSEXCEPTIONHANDLING_H_INCLUDED_
#define FUSION_INC_FUSIONHEAP_H_INCLUDED_
#define FUSION_ARRAYHELP_H_INCLUDED_
#define FUSION_INC_FUSIONBUFFER_H_INCLUDED_
#define FUSION_INC_FUSIONLASTWIN32ERROR_H_INCLUDED_
#define ASSERT_NTC(x) ASSERT(x)
#define VERIFY_NTC(x) (x)

inline DWORD FusionpGetLastWin32Error(void)
{
    return ::GetLastError();
}

inline void FusionpGetLastWin32Error(
    DWORD *pdwLastError
    )
{
    *pdwLastError = ::FusionpGetLastWin32Error();
}

inline VOID FusionpSetLastWin32Error(DWORD dw)
{
    ::SetLastError(dw);
}

class CBaseStringBuffer { };

#include "fusiontrace.h"
#include "../../inc/CSxsPreserveLastError.h"
#include "../../inc/FusionHandle.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\inc\sxapwguiddatatoxxx.h ===
/*-----------------------------------------------------------------------------
Microsoft SXAPW

Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

@doc external
@module SxApwGuidDataToXxx.h

Macros to convert "guid data", of the
form (3f32766f, 2d94, 444d, bf,32,2f,32,9c,71,d4,08), to all of the various
needed forms:
  3f32766f-2d94-444d-bf32-2f329c71d408                               SXAPW_GUID_DATA_TO_DASHED
 '3f32766f-2d94-444d-bf32-2f329c71d408'                              SXAPW_GUID_DATA_TO_DASHED_CHAR
 "3f32766f-2d94-444d-bf32-2f329c71d408"                              SXAPW_GUID_DATA_TO_DASHED_STRING
 {3f32766f-2d94-444d-bf32-2f329c71d408}                              SXAPW_GUID_DATA_TO_BRACED_DASHED
'{3f32766f-2d94-444d-bf32-2f329c71d408}'                             SXAPW_GUID_DATA_TO_BRACED_DASHED_CHAR
"{3f32766f-2d94-444d-bf32-2f329c71d408}"                             SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING
{0x3f32766f,0x2d94,0x444d,{0xbf,0x32,0x2f,0x32,0x9c,0x71,0xd4,0x08}} SXAPW_GUID_DATA_TO_STRUCT_INITIALIZER

@owner JayKrell
-----------------------------------------------------------------------------*/
#if !defined(SXAPW_GUID_DATA_TO_XXX_H_INCLUDED_)
#define SXAPW_GUID_DATA_TO_XXX_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#include "SxApwPreprocessorPaste.h"
#include "SxApwPreprocessorStringize.h"
#include "SxApwPreprocessorCharize.h"

/*-----------------------------------------------------------------------------
I need to investigate more, but present usage is:

SXAPW_GUID_DATA_TO_DASHED_STRING : __declpec(uuid())
SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING : also works with__declpec(uuid())
SXAPW_GUID_DATA_TO_BRACED_DASHED : in .rgs files (unquoted)
SXAPW_GUID_DATA_TO_STRUCT_INITIALIZER : would be used in .ctc files
SXAPW_GUID_DATA_TO_BRACED_DASHED_CHAR : used in .rgs files (quoted)

-----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
Name: SXAPW_GUID_DATA_TO_STRUCT_INITIALIZER
@macro
This macro does like:
SXAPW_GUID_DATA_TO_STRUCT_INITIALIZER(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> { 0x80f3e6ba, 0xd9b2, 0x4c41, { 0xae, 0x90, 0x63, 0x93, 0xda, 0xce, 0xac, 0x2a } }

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
SXAPW_GUID_DATA_TO_STRUCT_INITIALIZER\
( \
	dwData1,  \
	 wData2,  \
	 wData3,  \
	bData4_0, \
	bData4_1, \
	bData4_2, \
	bData4_3, \
	bData4_4, \
	bData4_5, \
	bData4_6, \
	bData4_7  \
) \
{ \
	SxApwPreprocessorPaste2(0x, dwData1), \
	SxApwPreprocessorPaste2(0x,  wData2), \
	SxApwPreprocessorPaste2(0x,  wData3), \
	{ \
		SxApwPreprocessorPaste2(0x, bData4_0), \
		SxApwPreprocessorPaste2(0x, bData4_1), \
		SxApwPreprocessorPaste2(0x, bData4_2), \
		SxApwPreprocessorPaste2(0x, bData4_3), \
		SxApwPreprocessorPaste2(0x, bData4_4), \
		SxApwPreprocessorPaste2(0x, bData4_5), \
		SxApwPreprocessorPaste2(0x, bData4_6), \
		SxApwPreprocessorPaste2(0x, bData4_7)  \
	} \
}

/*-----------------------------------------------------------------------------
Name: SXAPW_GUID_DATA_TO_DASHED
@macro
This macro does like:
SXAPW_GUID_DATA_TO_DASHED(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> 80f3e6ba-d9b2-4c41-ae90-6393daceac2a

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
SXAPW_GUID_DATA_TO_DASHED\
( \
	dwData1,  \
	 wData2,  \
	 wData3,  \
	bData4_0, \
	bData4_1, \
	bData4_2, \
	bData4_3, \
	bData4_4, \
	bData4_5, \
	bData4_6, \
	bData4_7  \
) \
SxApwPreprocessorPaste15(dwData1,-,wData2,-,wData3,-,bData4_0,bData4_1,-,bData4_2,bData4_3,bData4_4,bData4_5,bData4_6,bData4_7)

// without braces

/*-----------------------------------------------------------------------------
Name: SXAPW_GUID_DATA_TO_DASHED_STRING
@macro
SXAPW_GUID_DATA_TO_DASHED_STRING(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> "80f3e6ba-d9b2-4c41-ae90-6393daceac2a"

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
SXAPW_GUID_DATA_TO_DASHED_STRING\
( \
	dw1,  \
	 w2,  \
	 w3,  \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	SxApwPreprocessorStringize(SXAPW_GUID_DATA_TO_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7))

/*-----------------------------------------------------------------------------
Name: SXAPW_GUID_DATA_TO_DASHED_CHAR
@macro
SXAPW_GUID_DATA_TO_DASHED_CHAR(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> '80f3e6ba-d9b2-4c41-ae90-6393daceac2a'

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
SXAPW_GUID_DATA_TO_DASHED_CHAR\
( \
	dw1,  \
	 w2,  \
	 w3,  \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	SxApwPreprocessorCharize(SXAPW_GUID_DATA_TO_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7))

// with braces

/*-----------------------------------------------------------------------------
Name: SXAPW_GUID_DATA_TO_BRACED_DASHED
@macro
SXAPW_GUID_DATA_TO_BRACED_DASHED(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> {80f3e6ba-d9b2-4c41-ae90-6393daceac2a}

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
SXAPW_GUID_DATA_TO_BRACED_DASHED\
( \
	dw1, \
	 w2, \
	 w3, \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	SxApwPreprocessorPaste3({,SXAPW_GUID_DATA_TO_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7),})

/*-----------------------------------------------------------------------------
Name: SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING
@macro
SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> "{80f3e6ba-d9b2-4c41-ae90-6393daceac2a}"

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING\
( \
	dw1, \
	 w2, \
	 w3, \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	SxApwPreprocessorStringize(SXAPW_GUID_DATA_TO_BRACED_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7))

/*-----------------------------------------------------------------------------
Name: SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING_W
@macro
SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING_W(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> L"{80f3e6ba-d9b2-4c41-ae90-6393daceac2a}"

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING_W(dw1, w2, w3, b0, b1, b2, b3, b4, b5, b6, b7) \
	SxApwPreprocessorPaste(L, SXAPW_GUID_DATA_TO_BRACED_DASHED_STRING(dw1, w2, w3, b0, b1, b2, b3, b4, b5, b6, b7))

/*-----------------------------------------------------------------------------
Name: SXAPW_GUID_DATA_TO_BRACED_DASHED_CHAR
@macro
SXAPW_GUID_DATA_TO_BRACED_DASHED_CHAR(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> '{80f3e6ba-d9b2-4c41-ae90-6393daceac2a}'

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
SXAPW_GUID_DATA_TO_BRACED_DASHED_CHAR\
( \
	dw1, \
	 w2, \
	 w3, \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	SxApwPreprocessorCharize(SXAPW_GUID_DATA_TO_BRACED_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7))

#endif /* SXAPW_GUID_DATA_TO_XXX_H_INCLUDED_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\inc\sxapwmycontext.h ===
/*
*/

#pragma once

class CSxApwMyContext //: public CSxApwTheirContext
{
    typedef CSxApwTheirContext Base;
public:
    CSxApwMyContext();
    ~CSxApwMyContext();

    HRESULT Init();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\inc\sxapwhtmleventsink.h ===
#pragma once
#include "atlwin.h"

class CSxApwHtmlEventSink : public IDispatch
{
public:
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {
        return E_NOTIMPL;
    }
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    {
        return E_NOTIMPL;
    }
    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
            LCID lcid, DISPID* rgdispid)
    {
        return E_NOTIMPL;
    }

    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, UINT* puArgErr)
    {
        HRESULT hr = S_OK;

        switch ( dispidMember )
        {
        case DISPID_HTMLELEMENTEVENTS2_ONCLICK:
            OnClick();
        default:
            /* add more as needed */
            break;
        }
        return hr;
    }

    virtual void OnClick() { }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\inc\sxapwpreprocessorstringize.h ===
/*-----------------------------------------------------------------------------
Microsoft SXAPW

Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

@doc external
@module SxApwPreprocessorStringize.h

@owner JayKrell
-----------------------------------------------------------------------------*/
#if !defined(VS_COMMON_INC_SXAPW_PREPROCESSORSTRINGIZE_H_INCLUDED_) // {
#define VS_COMMON_INC_SXAPW_PREPROCESSORSTRINGIZE_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#include "SxApwPreprocessorPaste.h"

#define SxApwPrivatePreprocessorStringize(x) # x

/*-----------------------------------------------------------------------------
Name: SxApwPreprocessorStringize, SxApwPreprocessorStringizeW
@macro
These macros simply stringize their parameter, after evaluating it;
it is evaluated so that
define A B
SxApwPreprocessorStringize(A) -> "B" instead of "A"
SxApwPreprocessorStringizeW(A) -> L"B" instead of L"A"
@owner JayKrell
-----------------------------------------------------------------------------*/
#define SxApwPreprocessorStringize(x) SxApwPrivatePreprocessorStringize(x)
#define SxApwPreprocessorStringizeW(x) SxApwPreprocessorPaste(L, SxApwPrivatePreprocessorStringize(x))

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\inc\sxapwstdincmfc.h ===
#undef _ATL_STATIC_REGISTRY
#if !defined(UNICODE)
#define UNICODE
#endif
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#if defined(ASSERT)
#undef ASSERT
#endif
#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
#include "afxwin.h"         // MFC core and standard components
#include "afxext.h"         // MFC extensions
#include "afxdisp.h"        // MFC Automation classes
#include "afxdtctl.h"		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include "afxcmn.h"			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#include "windows.h"
#include "atlbase.h"
ATL::CComModule* GetModule();
#define _Module (*GetModule())
#include "atlcom.h"
#include "atlbase.h"
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\inc\sxapwstdinc.h ===
#include "yvals.h"
#pragma warning(disable:4511) /* copy constructor could not be generated */
#pragma warning(disable:4663) /* template syntax change for explicit specification */
#undef _ATL_STATIC_REGISTRY
#if !defined(UNICODE)
#define UNICODE
#endif
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "windows.h"
#include "atlbase.h"
ATL::_ATL_OBJMAP_ENTRY* GetObjectMap();
ATL::CComModule* GetModule();
#define GetComModule GetModule
#define _Module (*GetModule())
#include "atlcom.h"
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\inc\sxapwwin.h ===
#pragma once
#include "atlwin.h"


class CSxApwHostMdiClient : public ATL::CWindowImpl<CSxApwHostMdiClient>
{
public:
    BEGIN_MSG_MAP(CSxApwHostMdiClient)
    END_MSG_MAP()

    DECLARE_WND_SUPERCLASS(NULL, L"MdiClient")

    CSxApwHostMdiClient() { }
    ~CSxApwHostMdiClient() { }
};

class CSxApwHostMdiChild : public ATL::CWindowImpl<CSxApwHostMdiChild, ATL::CWindow, ATL::CMDIChildWinTraits>
{
public:
    BEGIN_MSG_MAP(CSxApwHostMdiChild)
    END_MSG_MAP()

    // CWindowImpl doesn't have a constructor from HWND, which leads to
    // a compilation error.
    // compiler ICE
    //CSxApwHostMdiChild(HWND hwnd) : ATL::CWindow(hwnd) { }
    CSxApwHostMdiChild(HWND hwnd) { Attach(hwnd); }
    CSxApwHostMdiChild() { }
    ~CSxApwHostMdiChild() { }
};

class CSxApwHostAxMdiChild : public ATL::CAxWindowT<CSxApwHostMdiChild>
{
public:
    BEGIN_MSG_MAP(CSxApwHostAxMdiChild)
    END_MSG_MAP()

    CSxApwHostAxMdiChild(HWND hwnd) { Attach(hwnd); }
    CSxApwHostAxMdiChild() { }
    ~CSxApwHostAxMdiChild() { }

	HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        //
        // Skip CAxWindowT's Create, and get WindowImpl's, which ors in the
        // traits's styles.
        //
        return CSxApwHostMdiChild::Create(hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\inc\sxapwpreprocessorcharize.h ===
/*-----------------------------------------------------------------------------
Microsoft SXAPW

Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

@doc external
@module PreprocessorCharize.h

@owner JayKrell
-----------------------------------------------------------------------------*/
#if !defined(VS_COMMON_INC_SXAPW_PREPROCESSORCHARIZE_H_INCLUDED_) // {
#define VS_COMMON_INC_SXAPW_PREPROCESSORCHARIZE_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#include "SxApwPreprocessorPaste.h"

#define SxApwPrivatePreprocessorCharize(x) #@ x

/*-----------------------------------------------------------------------------
Name: SxApwPreprocessorCharize, SxApwPreprocessorCharizeW
@macro
These macros simply charize their parameter, after evaluating it;
it is evaluated so that
define A B
SxApwPreprocessorCharize(A) -> 'B' instead of 'A'
SxApwPreprocessorCharizeW(A) -> 'B' instead of L'A'
@owner JayKrell
-----------------------------------------------------------------------------*/
#define SxApwPreprocessorCharize(x) SxApwPrivatePreprocessorCharize(x)
#define SxApwPreprocessorCharizeW(x) SxApwPreprocessorPaste(L, SxApwPrivatePreprocessorCharize(x))

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\inc\sxapwpreprocessorpaste.h ===
/*-----------------------------------------------------------------------------
Microsoft SXAPW

Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

@doc external
@module SxApwPreprocessorPaste.h

@owner JayKrell
-----------------------------------------------------------------------------*/
#if !defined(VS_COMMON_INC_SXAPW_PREPROCESSORPASTE_H_INCLUDED_) // {
#define VS_COMMON_INC_SXAPW_PREPROCESSORPASTE_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#define SxApwPrivatePreprocessorPaste(x, y) x ## y

/*-----------------------------------------------------------------------------
Name: SxApwPreprocessorPaste2, SxApwPreprocessorPaste3, etc.
@macro
These macros paste together n tokens, where n is in the name of the macro.
A level of evaluation is inserted as well.

define A 1
define B 2

SxApwPreprocessorPaste2(A, B) -> 12
@owner JayKrell
-----------------------------------------------------------------------------*/

// These are synonyms.
#define SxApwPreprocessorPaste(x, y)  SxApwPrivatePreprocessorPaste(x, y)
#define SxApwPreprocessorPaste2(x, y) SxApwPrivatePreprocessorPaste(x, y)

#define SxApwPreprocessorPaste3(x, y, z) SxApwPreprocessorPaste(SxApwPreprocessorPaste(x, y), z)
#define SxApwPreprocessorPaste4(w, x, y, z) SxApwPreprocessorPaste(SxApwPreprocessorPaste3(w, x, y), z)
#define SxApwPreprocessorPaste5(v, w, x, y, z) SxApwPreprocessorPaste(SxApwPreprocessorPaste4(v, w, x, y), z)
#define SxApwPreprocessorPaste6(u, v, w, x, y, z) SxApwPreprocessorPaste(SxApwPreprocessorPaste5(u, v, w, x, y), z)

#define SxApwPreprocessorPaste15(a1,a2,a3,a4,a5,a6,a7,a8,a9,a,b,c,d,e,f) \
	SxApwPreprocessorPaste3 \
	( \
		SxApwPreprocessorPaste5(a1,a2,a3,a4,a5), \
		SxApwPreprocessorPaste5(a6,a7,a8,a9,a), \
		SxApwPreprocessorPaste5(b,c,d,e,f) \
	)

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uimgr\stdinc.h ===
#include "SxApwStdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\sources.inc ===
RELATIVE_DEPTH=..\$(RELATIVE_DEPTH)
!include ..\$(RELATIVE_DEPTH)\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\stdinc\empty.cpp ===
#include "stdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\stdinc\stdinc.h ===
#include "SxApwStdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\comctl32\stdinc.h ===
#include "SxApwStdincMfc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\comctl32\ccomctl32.h ===
/*
*/
#pragma once

#include "iuiview.h"
#include <string>
#include <atlwin.h>
#include "resource.h"
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>

class __declspec(uuid(CLSID_CSxApwComctl32View_declspec_uuid))
CSxApwComctl32View
:
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwComctl32View, &__uuidof(CSxApwComctl32View)>,
    public ATL::CWindowImpl<CSxApwComctl32View>,
    public ISxApwUiView    
{
public:
    CSxApwComctl32View() { }

    BEGIN_COM_MAP(CSxApwComctl32View)
	    COM_INTERFACE_ENTRY(ISxApwUiView)
    END_COM_MAP()

    DECLARE_NO_REGISTRY();

    BEGIN_MSG_MAP(CSxApwComctl32View)
        MESSAGE_HANDLER(WM_CONTEXTMENU,     OnContextMenu)
        MESSAGE_HANDLER(WM_SIZE,            OnSize)
        COMMAND_ID_HANDLER(IDM_LARGE_ICONS, CmdSwitchListView)
        COMMAND_ID_HANDLER(IDM_SMALL_ICONS, CmdSwitchListView)
        COMMAND_ID_HANDLER(IDM_LIST,        CmdSwitchListView)
        COMMAND_ID_HANDLER(IDM_REPORT,      CmdSwitchListView)
    END_MSG_MAP()

public: 
    STDMETHOD(SetSite)(
        ISxApwHost* host
        )
    {
        m_host = host;
        return S_OK;
    }

    STDMETHOD(CreateWindow)(
        HWND hWnd
        );

	STDMETHOD(OnNextRow)(
		int     nColumns,
		const LPCWSTR rgpszColumns[]
		);

	STDMETHOD(OnRowCountEstimateAvailable)(
		int
		)
    {return S_OK; }

	STDMETHOD(OnQueryStart)(
		)
    { 
        ListView_DeleteAllItems(m_comctl32); 
        return S_OK; 
    }

	STDMETHOD(OnQueryDone)(
		)
    {        
        return S_OK; 
    }

    STDMETHOD(InformSchema)(
        const SxApwColumnInfo   rgColumnInfo[],
        int                     nColumns
        )
    { return S_OK; }

    STDMETHOD (ResizeListViewCW)(
        ATL::CWindow hwndListView, 
        ATL::CWindow hwndParent
        );

    STDMETHOD (ResizeListView)(
        HWND hwndListView, 
        HWND hwndParent
        );

    STDMETHOD (InitImageList)(
        HWND hwndListView
        );

    STDMETHOD (InitViewColumns)(
        HWND hwndListView
        );

    STDMETHOD (GetDisplayInfoBasedOnFileName)(
        int & iIconIndex, 
        PWSTR pwszFiletype,         
        const LPCWSTR filename
        );

    STDMETHOD (GetDevIconBasedonEmailalias)(
        int & iIconIndex, 
        const LPCWSTR emailalias
        );

    STDMETHOD (FormatFileSizeInfo)(
        WCHAR pwszFileSize[], 
        const LPCWSTR pszFileSize
        );

    void UpdateMenu(HMENU hMenu);
    void SwitchView(DWORD dwView);

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);   
    LRESULT CmdSwitchListView(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);


    ATL::CComPtr<ISxApwHost>    m_host;
    ATL::CWindow m_comctl32;

};


// Display Info For Files
typedef struct _FILETYPEVIAFILEEXT_ {
    WCHAR *FileExt;
    WCHAR *FileType;
}FILETYPEVIAFILEEXT;

#define TOTAL_ICON_COUNT_FOR_FILE_INFO_DISPLAY 11
#define ICON_INEX_GENERAL_FILE          9
#define ICON_INEX_GENERAL_DIRECTORY     10

// Display Info For RAID
#define TOTAL_ICON_COUNT_FOR_DEV 5

//global variable
int g_DataBaseType = 0;

#define ID_LISTVIEW  2000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\comctl32\sources.inc ===
RELATIVE_DEPTH=..\$(RELATIVE_DEPTH)
!include ..\$(RELATIVE_DEPTH)\sources.inc

TARGETTYPE=DYNLINK
DLLDEF=..\ccomctl32.def

SOURCES=  \
 ..\ccomctl32.cpp \
 ..\ccomctl32.rc \

LINKLIBS=\
 $(SXAPW_LIB_LIB)  \
 $(SXAPW_STDINC_LIB) \
 $(SXAPW_GUIDS_LIB) \

TARGETLIBS=\
 $(SDK_LIB_PATH)\kernel32.lib \
 $(SDK_LIB_PATH)\user32.lib \
 $(SDK_LIB_PATH)\comctl32.lib \
 $(SDK_LIB_PATH)\oleaut32.lib \
 $(SDK_LIB_PATH)\uuid.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uimgr\cuimgr.h ===
/*
*/
#pragma once

#include "iuimgr.h"
#include "iuiview.h"
#include <vector>

class __declspec(uuid(CLSID_CSxApwUiManager_declspec_uuid))
CSxApwUiManager
:
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwUiManager, &__uuidof(CSxApwUiManager)>,
    public ISxApwUiManager
{
    typedef std::vector<ATL::CAdapt<ATL::CComPtr<ISxApwUiView> > > Views_t;
    Views_t m_views;

public:

    CSxApwUiManager() { }

    BEGIN_COM_MAP(CSxApwUiManager)
	    COM_INTERFACE_ENTRY(ISxApwUiManager)
    END_COM_MAP()

    DECLARE_NO_REGISTRY();

    HRESULT STDMETHODCALLTYPE
    CreateView(
        PCWSTR type,
        HWND hWnd
        );

	HRESULT STDMETHODCALLTYPE
	NextRow(
    	int     nColumns,
		const LPCWSTR* columns
		);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\comctl32\ccomctl32.cpp ===
#include "stdinc.h"
#include "ccomctl32.h"
#include "windows.h"
#include <stdio.h>
#include "FusionTrace.h"

#define FUSION_APPWEEK_UIVIEWER_DISPLAY_FILE_INFO 0 
static FILETYPEVIAFILEEXT MatchTable_FileTypeViaFileExt[]= 
{  
    { L".cpp",  L"C++ Source File"},    // index 0 
    { L".c",    L"C Source File"},      // index 1
    { L".h",    L"C Header File"},      // index 2
    { L".def",  L"DEF File"},           // index 3
    { L".err",  L"ERR File"},           // index 4
    { L".ico",  L"Icon"},               // index 5
    { L".inc",  L"INC File"},           // index 6
    { L".rc",   L"Resource Template"},  // index 7
    { L".log",  L"Text Document"}       // index 8
};

static ATL::CComModule Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(__uuidof(CSxApwComctl32View), CSxApwComctl32View)
END_OBJECT_MAP()

ATL::CComModule* GetModule() { return &Module; }
ATL::_ATL_OBJMAP_ENTRY* GetObjectMap() { return ObjectMap; }
const CLSID* GetTypeLibraryId() { return NULL; }
const HINSTANCE GetInstance() { return GetModule()->GetModuleInstance(); }



STDMETHODIMP 
CSxApwComctl32View::ResizeListViewCW(
    ATL::CWindow listview, 
    ATL::CWindow parent)
{
    HRESULT hr = S_OK; 
    RECT rc;
    IFFALSE_WIN32TOHR_EXIT(hr, parent.GetClientRect(&rc));

    IFFALSE_WIN32TOHR_EXIT(hr, listview.MoveWindow(
                rc.left,
                rc.top,
                rc.right - rc.left,
                rc.bottom - rc.top,
                TRUE));
    hr = S_OK; 

Exit:
    return hr;

}

STDMETHODIMP 
CSxApwComctl32View::ResizeListView(
    HWND hwndListView, 
    HWND hwndParent)
{
    ATL::CWindow parent(hwndParent);
    ATL::CWindow listview(hwndListView);

    return ResizeListViewCW(listview, parent);

}

void CSxApwComctl32View::SwitchView(DWORD dwView)
{
    DWORD dwStyle = m_comctl32.GetWindowLong(GWL_STYLE);

    m_comctl32.SetWindowLong(GWL_STYLE, (dwStyle & ~LVS_TYPEMASK) | dwView);
    ResizeListViewCW(m_comctl32, m_comctl32.GetParent());

    return;
}

LRESULT CSxApwComctl32View::CmdSwitchListView(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    switch (wID)  // 
    {
        case IDM_LARGE_ICONS:
            SwitchView(LVS_ICON);
            break;
     
         case IDM_SMALL_ICONS:
            SwitchView(LVS_SMALLICON);
            break;
     
         case IDM_LIST:
            SwitchView(LVS_LIST);
            break;
     
         case IDM_REPORT:
            SwitchView(LVS_REPORT);
            break;
         
    }

    return hr; 
    
}

void CSxApwComctl32View::UpdateMenu(HMENU hMenu)
{
    UINT  uID = 0 ;
    DWORD dwStyle;

    //uncheck all of these guys
    CheckMenuItem(hMenu, IDM_LARGE_ICONS,  MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hMenu, IDM_SMALL_ICONS,  MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hMenu, IDM_LIST,  MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItem(hMenu, IDM_REPORT,  MF_BYCOMMAND | MF_UNCHECKED);

    //check the appropriate view menu item
    dwStyle = m_comctl32.GetWindowLongW(GWL_STYLE);
    switch(dwStyle & LVS_TYPEMASK)
       {
       case LVS_ICON:
          uID = IDM_LARGE_ICONS;
          break;
      
       case LVS_SMALLICON:
          uID = IDM_SMALL_ICONS;
          break;
      
       case LVS_LIST:
          uID = IDM_LIST;
          break;
   
       case LVS_REPORT:
          uID = IDM_REPORT;
          break;
       }
    CheckMenuRadioItem(hMenu, IDM_LARGE_ICONS, IDM_REPORT, uID,  MF_BYCOMMAND | MF_CHECKED);

}

LRESULT CSxApwComctl32View::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HMENU menu = LoadMenuW(GetInstance(), MAKEINTRESOURCEW(IDM_CONTEXT_MENU));
    HMENU listcontextmenu = GetSubMenu(menu, 0);

    UpdateMenu(listcontextmenu);

    TrackPopupMenu(
            listcontextmenu,
            TPM_LEFTALIGN | TPM_RIGHTBUTTON,
            GET_X_LPARAM(lParam),
            GET_Y_LPARAM(lParam),
            0,
            *this,
            NULL);

    DestroyMenu(menu);    

    return 0;
}

LRESULT CSxApwComctl32View::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ATL::CWindow parent = m_comctl32.GetParent();
    return ResizeListViewCW(m_comctl32, parent);
}


STDMETHODIMP 
CSxApwComctl32View::InitImageList(HWND hwndListView)
{
    DWORD       iconNum;
    HIMAGELIST  himlSmall;
    HIMAGELIST  himlLarge;    

    if (g_DataBaseType == FUSION_APPWEEK_UIVIEWER_DISPLAY_FILE_INFO)     
        iconNum = TOTAL_ICON_COUNT_FOR_FILE_INFO_DISPLAY; 
    else
        iconNum = TOTAL_ICON_COUNT_FOR_DEV; 

    himlSmall = ImageList_Create(16, 16, ILC_COLORDDB | ILC_MASK, iconNum, 0);
    himlLarge = ImageList_Create(32, 32, ILC_COLORDDB | ILC_MASK, iconNum, 0);

    if (himlSmall && himlLarge)
    {
       HICON hIcon;
       if (g_DataBaseType == FUSION_APPWEEK_UIVIEWER_DISPLAY_FILE_INFO)
       {    
           //set up the small image list
           for ( DWORD i = IDI_ICON_FILE_START; i <= IDI_ICON_FILE_END; i++)
           {
               hIcon = static_cast<HICON>(LoadImage(GetInstance(), MAKEINTRESOURCE(i), IMAGE_ICON, 16, 16, LR_VGACOLOR));
               ImageList_AddIcon(himlSmall, hIcon);

               //set up the large image list
               hIcon = LoadIcon(GetInstance(), MAKEINTRESOURCE(i));
               ImageList_AddIcon(himlLarge, hIcon);
           }
       }
       else 
       {

           for ( DWORD i = IDB_BITMAP_DEV_START; i <= IDB_BITMAP_DEV_END; i++)
           {
                hIcon = static_cast<HICON>(LoadImage(GetInstance(), MAKEINTRESOURCE(i), IMAGE_ICON, 16, 16, LR_VGACOLOR));
                ImageList_AddIcon(himlSmall, hIcon);
                //set up the large image list
                hIcon = LoadIcon(GetInstance(), MAKEINTRESOURCE(i));
                ImageList_AddIcon(himlLarge, hIcon);
           }
       }
       
       ListView_SetImageList(hwndListView, himlSmall, LVSIL_SMALL);
       ListView_SetImageList(hwndListView, himlLarge, LVSIL_NORMAL);
    }
    return S_OK;
}

STDMETHODIMP 
CSxApwComctl32View::InitViewColumns(
    HWND hwndListView
    )
{
    HRESULT     hr = S_OK;
    LV_COLUMN   lvColumn;
    DWORD       index;
    WCHAR       szText[20]; 
    DWORD       iIndexStart, iIndexEnd;

    //empty the list
    ListView_DeleteAllItems(hwndListView);

    //initialize the rgpszColumns
    ZeroMemory(&lvColumn, sizeof(lvColumn));
    lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.cx = 120;
    lvColumn.pszText = szText;

    if (g_DataBaseType == FUSION_APPWEEK_UIVIEWER_DISPLAY_FILE_INFO)
    {
        iIndexStart = IDS_FILE_COLUMN_START;
        iIndexEnd   = IDS_FILE_COLUMN_END;
    }
    else
    {
        iIndexStart = IDS_RAID_COLUMN_START;
        iIndexEnd   = IDS_RAID_COLUMN_END;
    }
    
    for (index = iIndexStart; index <= iIndexEnd; index++)
    {
        lvColumn.iSubItem = index;
        LoadString(GetInstance(), index, szText, sizeof(szText));    
        if (ListView_InsertColumn(hwndListView, index, &lvColumn) == -1)
        {
            hr = E_FAIL;
            goto Exit;
        }
    }
Exit:
    return hr;
}

STDMETHODIMP
CSxApwComctl32View::CreateWindow(
    HWND hwndParent
    )
{
    HRESULT     hr = S_OK;
    HWND        hwndListView;

    IFFALSE_WIN32TOHR_EXIT(
        hr,
        hwndListView = CreateWindowEx(   
                WS_EX_CLIENTEDGE,          
                 WC_LISTVIEW,               
                 L"",                       
                 WS_TABSTOP | WS_CHILD | WS_BORDER | WS_VISIBLE | LVS_SORTASCENDING | LVS_REPORT,
                 0, 0, 0, 0,
                 hwndParent,                 // parent
                 (HMENU)ID_LISTVIEW,        // ID
                 NULL,                      // instance
                 NULL));                    // no extra data        
    
    IFFAILED_EXIT(hr = ResizeListView(hwndListView, hwndParent));
    IFFAILED_EXIT(hr = InitImageList(hwndListView));
    IFFAILED_EXIT(hr = InitViewColumns(hwndListView));

    m_comctl32.Attach(hwndListView);

#undef SubclassWindow
    this->SubclassWindow(hwndParent);

    hr = S_OK;
Exit:
    return hr;
}


STDMETHODIMP
CSxApwComctl32View::GetDisplayInfoBasedOnFileName(int & iIconIndex, PWSTR pwszFileType, const LPCWSTR pwszFileName)
{
    // get icon and file type string
    DWORD dwAttrib = GetFileAttributes(pwszFileName);
    if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) 
    {
        wcscpy(pwszFileType, L"Dir");        
        iIconIndex = IDI_DIR - IDI_ICON_FILE_START; 
    }
    else 
    {       
        WCHAR * p = wcsrchr(pwszFileName, L'.');
        pwszFileType[0] = L'\0';
        if (p == NULL) 
        {
            wcscpy(pwszFileType, L"File");
            iIconIndex = ICON_INEX_GENERAL_FILE;
        }
        else
        {
            for (DWORD i=0; i < sizeof(MatchTable_FileTypeViaFileExt) / sizeof(FILETYPEVIAFILEEXT); i++) 
            {
                if (wcscmp(p, MatchTable_FileTypeViaFileExt[i].FileExt) == 0 ) 
                { 
                    wcscpy(pwszFileType, MatchTable_FileTypeViaFileExt[i].FileType);
                    iIconIndex = i;
                    break;
                }
            }
        }
        if (pwszFileType[0] == L'\0')
        {   
            wsprintf(pwszFileType, L"%s File", p++);
            iIconIndex = ICON_INEX_GENERAL_FILE;
        }
    }

    return S_OK;
}

STDMETHODIMP
CSxApwComctl32View::GetDevIconBasedonEmailalias(int & iIconIndex, const LPCWSTR emailalias)
{
    if (wcscmp(emailalias, L"jaykrell") == 0 ) 
        iIconIndex = 0;
    else if (wcscmp(emailalias, L"jonwis") == 0 )
        iIconIndex = 1;
    else if (wcscmp(emailalias, L"mgrier") == 0 )
        iIconIndex = 2;
    else if (wcscmp(emailalias, L"xiaoyuw") == 0 )
        iIconIndex = 3;
    else
        iIconIndex = 4;

    return S_OK;
}

STDMETHODIMP
CSxApwComctl32View::FormatFileSizeInfo(WCHAR pwszFileSize[], const LPCWSTR pszFileSize)
{
   int iSize= _wtol(pszFileSize);
   if (iSize < 1000)
       wcscpy(pwszFileSize, L"1K");
   else
       wsprintf(pwszFileSize, L"%dK", iSize / 1000);

    return S_OK;
}


STDMETHODIMP
CSxApwComctl32View::OnNextRow(
	int   nColumns,
    const LPCWSTR rgpszColumns[]
	)
{
    LVITEM lvItem;
    ZeroMemory(&lvItem, sizeof(lvItem));
    int iIconIndex, iItemIndex;
    HRESULT hr; 

    if (g_DataBaseType == FUSION_APPWEEK_UIVIEWER_DISPLAY_FILE_INFO)
    {
        
        WCHAR pwszFileType[MAX_PATH];
        WCHAR pwszFileSize[MAX_PATH];
        const LPCWSTR pszFullFileName = rgpszColumns[0];
        PWSTR pszPartialFileName = wcsrchr(pszFullFileName, L'\\');
        if (pszPartialFileName != NULL)
            pszPartialFileName++;
        if (pszPartialFileName == NULL)
            pszPartialFileName = const_cast<LPWSTR>(pszFullFileName);

        IFFAILED_EXIT(hr = GetDisplayInfoBasedOnFileName(iIconIndex, pwszFileType, pszFullFileName));
        if (::GetFileAttributesW(pszFullFileName) & FILE_ATTRIBUTE_DIRECTORY)
            pwszFileSize[0] = L'\0';  // dir 
        else 
            FormatFileSizeInfo(pwszFileSize, rgpszColumns[1]);

        lvItem.mask = LVIF_TEXT | LVIF_IMAGE;        
        lvItem.pszText = pszPartialFileName;
        lvItem.iItem = 0;
        lvItem.iSubItem = 0;
        lvItem.iImage = iIconIndex;
        iItemIndex = ListView_InsertItem(m_comctl32, &lvItem);

        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = iItemIndex;
        lvItem.pszText = pwszFileSize;
        lvItem.iSubItem = 1;
        ListView_SetItem(m_comctl32, &lvItem);

        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = iItemIndex;
        lvItem.pszText = pwszFileType;
        lvItem.iSubItem = 2;
        ListView_SetItem(m_comctl32, &lvItem);
    }
    else
    {
        GetDevIconBasedonEmailalias(iIconIndex, rgpszColumns[0]);

        lvItem.mask = LVIF_TEXT | LVIF_IMAGE;        
        lvItem.pszText = const_cast<LPWSTR>(rgpszColumns[0]);
        lvItem.iItem = 0;
        lvItem.iSubItem = 0;
        lvItem.iImage = iIconIndex;
        iItemIndex = ListView_InsertItem(m_comctl32, &lvItem);

        for (int i=1; i<nColumns; i++)
        {
            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = iItemIndex;
            lvItem.pszText = const_cast<LPWSTR>(rgpszColumns[i]);
            lvItem.iSubItem = i;
            ListView_SetItem(m_comctl32, &lvItem);
        }
    }
    hr = S_OK;
Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\comctl32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ccomctl32.rc
//
#define IDS_APPTITLE                    1

#define IDS_FILE_COLUMN_START           2
#define IDS_FILEINFO_COLUMN_NAME        2
#define IDS_FILEINFO_COLUMN_SIZE        3
#define IDS_FILEINFO_COLUMN_TYPE        4
#define IDS_FILE_COLUMN_END             4

#define IDS_RAID_COLUMN_START           5
#define IDS_RAID_ASSIGNEDTO             5
#define IDS_RAID_BUGID                  6
#define IDS_RAID_BUGTITLE               7
#define IDS_RAID_COLUMN_END             7

#define IDD_ABOUT                       100
#define IDM_EXIT                        100
#define IDI_MAINICON                    101
#define IDM_ABOUT                       101
#define IDM_MAIN_MENU                   102
#define IDM_CONTEXT_MENU                103
#define ID_FILE_INSERT                  103

#define IDI_ICON_FILE_START             114
#define IDI_CPP                         114
#define IDI_C                           115
#define IDI_H                           116
#define IDI_DEF                         117
#define IDI_ERR                         118
#define IDI_ICO                         119
#define IDI_INC                         120
#define IDI_RC                          121
#define IDI_LOG                         122
#define IDI_FILE                        123
#define IDI_DIR                         124
#define IDI_ICON_FILE_END               124

#define IDB_BITMAP_DEV_START            130
#define IDB_BITMAP_xiaoyuw              130
#define IDB_BITMAP_jaykrell             131
#define IDB_BITMAP_jonwis               132
#define IDB_BITMAP_mgrier               133
#define IDB_BITMAP_otherpeople          134
#define IDB_BITMAP_DEV_END              134
#define IDM_LARGE_ICONS                 200
#define IDM_SMALL_ICONS                 201
#define IDM_LIST                        202
#define IDM_REPORT                      203

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         104
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\controller\stdinc.h ===
#include "SxApwStdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uimgr\cuimgr.cpp ===
#include "stdinc.h"
#include "cuimgr.h"
#include "SxApwCreate.h"

static ATL::CComModule Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(__uuidof(CSxApwUiManager), CSxApwUiManager)
END_OBJECT_MAP()

ATL::CComModule* GetModule() { return &Module; }
ATL::_ATL_OBJMAP_ENTRY* GetObjectMap() { return ObjectMap; }
const CLSID* GetTypeLibraryId() { return NULL; }

HRESULT STDMETHODCALLTYPE
CSxApwUiManager::CreateView(
    PCWSTR type, /* progid, clsid, dllpath, whatever.. */
    HWND hWnd
    )
{
    HRESULT hr;
    CLSID   clsid;
    ATL::CComPtr<ISxApwUiView> view;
    
    if (FAILED(hr = CLSIDFromString(const_cast<PWSTR>(type), &clsid)))
        goto Exit;

    if (FAILED(hr = SxApwCreateObject(clsid, view)))
        goto Exit;

    if (FAILED(hr = view->SetParentWindow(hWnd)))
        goto Exit;

    m_views.push_back(view);

Exit:
    return hr;
}

HRESULT STDMETHODCALLTYPE
CSxApwUiManager::NextRow(
	int     nColumns,
	const PCWSTR* columns
	)
{
    /*
    just multiplex/broadcast the data across all the views..
    */
    for (Views_t::const_iterator i = m_views.begin(); i != m_views.end() ; ++i)
    {
        static_cast<const ATL::CComPtr<ISxApwUiView>&>(*i)->NextRow(nColumns, columns);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\controller\1ui.cpp ===
#include "stdinc.h"
#include "Ui.h"
#include <stdio.h>
#include "FusionTrace.h"

static ATL::CComModule Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(__uuidof(CSxApwUiView), CSxApwUiView)
END_OBJECT_MAP()

ATL::CComModule* GetModule() { return &Module; }
ATL::_ATL_OBJMAP_ENTRY* GetObjectMap() { return ObjectMap; }
const CLSID* GetTypeLibraryId() { return NULL; }

STDMETHODIMP
CSxApwUiView::CreateWindow(
    HWND hwndParent
    )
{
    HRESULT             hr = S_OK;
    RECT                rc;
    CDynamicLinkLibrary dll;
    ATL::CWindow        parent(hwndParent);
    HWND                hwnd;
    HMODULE             exeHandle;
    WCHAR               exePath[MAX_PATH];
    PWSTR               filePart;
    CFindFile           findFile;
    DWORD               dwGroup;
    std::vector<std::wstring> strings;
    int                 i;

    IFFALSE_WIN32TOHR_EXIT(hr, parent.GetClientRect(&rc));
    IFFALSE_WIN32TOHR_EXIT(hr, parent.ScreenToClient(&rc));

    IFFALSE_WIN32TOHR_EXIT(hr, exeHandle = GetModuleHandleW(NULL));

    IFFALSE_EXIT(GetModuleFileName(exeHandle, exePath, RTL_NUMBER_OF(exePath)));
    filePart = 1 + wcsrchr(exePath, '\\');
    wcscpy(filePart, L"datasources\\");
    filePart = filePart + wcslen(filePart);
    wcscpy(filePart, L"sxapw*.dll");

    strings.clear();
    if (findFile.Win32Create(exePath, &findData))
    {
        do
        {
            strings.push_back(findData.cFileName);
        } while (FindNextFileW(findFile, &findData));
    }
    dwGroup = WS_GROUP;
    IFFALSE_WIN32TOHR_EXIT(
        hr,
        hwnd = CreateWindow(
            L"Button",
            NULL,
            WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON | dwGroup
            0, 0, rc.right - rc.left, rc.bottom - rc.top,
            parent,
            NULL,
            NULL,
            NULL
            ));
    dwGroup = 0;

Exit:
    return hr;
}

STDMETHODIMP
CSxApwUiView::Draw(
    )
{
    printf("CSxApwUiView::Draw\n");
    return S_OK;
}

STDMETHODIMP
CSxApwUiView::NextRow(
	int     nColumns,
    const LPCWSTR* columns
	)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\controller\controller.cpp ===
#include "stdinc.h"
#include <stdio.h>
#include "atlhost.h"
#include "controller.h"
#include "FusionTrace.h"

#pragma warning(disable:4018) /* signed/unsigned mismatch */
#pragma warning(disable:4189)

#define IFFALSE_EXIT(x) do { if (!(x)) goto Exit; } while(0)

static ATL::CComModule Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(__uuidof(CSxApwControllerView), CSxApwControllerView)
END_OBJECT_MAP()

ATL::CComModule* GetModule() { return &Module; }
ATL::_ATL_OBJMAP_ENTRY* GetObjectMap() { return ObjectMap; }
const CLSID* GetTypeLibraryId() { return NULL; }

std::wstring DoubleSlashes(const std::wstring& s)
{
    std::wstring t;
    t.reserve(s.size() + 10);
    for (std::wstring::const_iterator i = s.begin() ; i != s.end() ; ++i)
    {
        if (*i == '\\')
        {
            t += L"\\\\";
        }
        else
        {
            t += *i;
        }
    }
    return t;
}

STDMETHODIMP
CSxApwControllerView::CreateWindow(
    HWND hwndParent
    )
{
    HRESULT             hr = S_OK;
    RECT                rc = { 0 };
    ATL::CWindow        parent(hwndParent);
    HMODULE             exeHandle = 0;
    WCHAR               path[MAX_PATH];
    PWSTR               exeFilePart = 0;
    PWSTR               pluginFilePart = 0;
    CFindFile           findFile;
    WIN32_FIND_DATAW    findData;
    std::vector<std::wstring> datasources;
    std::vector<std::wstring> views;
    int                 i = 0;
    std::wstring        html;
    int                 nview;
    int                 ndatasource;
    ATL::CAxWindow      axWindow;

    IFFALSE_WIN32TOHR_EXIT(hr, parent.GetClientRect(&rc));
    IFFALSE_WIN32TOHR_EXIT(hr, parent.ScreenToClient(&rc));

    IFFALSE_WIN32TOHR_EXIT(hr, exeHandle = GetModuleHandleW(NULL));

    IFFALSE_EXIT(GetModuleFileName(exeHandle, path, RTL_NUMBER_OF(path)));
    exeFilePart = 1 + wcsrchr(path, '\\');

    wcscpy(exeFilePart, L"views\\");
    pluginFilePart = exeFilePart + wcslen(exeFilePart);
    wcscpy(pluginFilePart, L"sxapw*.dll");
    if (findFile.Win32Create(path, &findData))
    {
        do
        {
            wcscpy(pluginFilePart, findData.cFileName);
            views.push_back(path);
        } while (FindNextFileW(findFile, &findData));
    }

    wcscpy(exeFilePart, L"sources\\");
    pluginFilePart = exeFilePart + wcslen(exeFilePart);
    wcscpy(pluginFilePart, L"sxapw*.dll");
    if (findFile.Win32Create(path, &findData))
    {
        do
        {
            wcscpy(pluginFilePart, findData.cFileName);
            datasources.push_back(path);
        } while (FindNextFileW(findFile, &findData));
    }

    axWindow.Attach(hwndParent);

    html.reserve(MAX_PATH * (datasources.size() * 2 + views.size() * 2));
    html += L"MSHTML:\n";

    //html += L"<form>\n";
    html += L"<table style=\"background:url(";
    *exeFilePart = 0;
    html += path;
    html += L"RedMoonDesert.jpeg);color:white\">\n";
    html += L"<tr><td>\n";
    html += L"<table border=1 style=\"background:url(";
    html += path;
    html += L"RedMoonDesert.jpeg);color:white\">\n";
    nview = 0;
    ndatasource = 0;
    html += L" <tr><th>data sources</th><th>data views</th></tr>";

    while (nview < views.size() || ndatasource < datasources.size())
    {
        html += L"  <tr><td>";
        if (ndatasource < datasources.size())
        {
            html += L"<input type=\"radio\" name=\"a\" ";
            html += L"onClick='window.external.F1(\"" + DoubleSlashes(datasources[ndatasource]) + L"\")'";
            html += L">";
            html += 1 + wcsrchr(datasources[ndatasource].c_str(), '\\');
            ndatasource += 1;
        }
        html += L"</td><td>\n";
        if (nview < views.size())
        {
            html += L"<input type=\"checkbox\" value=\"0\" ";
            html += L"onClick='window.external.F2(\"" + DoubleSlashes(views[nview]) + L"\", (++value) & 1)'";
            //html += L"onClick='alert((++value) & 1)'";
            html += L">";
            html += 1 + wcsrchr(views[nview].c_str(), '\\');
            nview += 1;
        }
        html += L"</td></tr>\n";
    }
    html += L"</table>";

    html += L"<p>";
    html += L"<input type=\"text\" name=\"query\">";

    html += L"<p>";
    html += L"<input type=\"submit\" value=\"Run Query\" ";
    html += L"onClick='window.external.F3(query.value)'";
    //html += L"onClick='alert(query.value)'";
    html += L">";

    html += L"<input type=\"submit\" value=\"Quit\" ";
    html += L"onClick='window.external.F4()'";
    html += L">";

    html += L"</table>";
    //html += L"</form>\n";

    printf("%ls\n", html.c_str());
    if (FAILED(hr = axWindow.CreateControl(html.c_str())))
        goto Exit;

    axWindow.SetExternalDispatch(this);
Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\duser\cduser.h ===
/*
*/
#pragma once

#include "iuiview.h"
#include "duser.h"
#include "comutil.h"
#include "rowobject.h"


class __declspec(uuid(CLSID_CSxApwDUserView_declspec_uuid))
CSxApwDUserView : public ISxApwUiView
{
private:
    HWND m_hOurParentWnd;
    LONG m_ulRefCount;

#if DUI_NEEDS_OWN_THREAD
    HANDLE m_hThreadHandle;
    HANDLE m_hThreadGoing;
    DWORD m_dwThreadId;
#endif

    DirectUI::Element* m_hMasterElement;
    
    HRESULT InternalCreateUI();
    HRESULT InternalDestroyUI();
    HRESULT InternalSetNextRow( IViewRow* pNextRow );

    CSxApwDUserView();
    virtual ~CSxApwDUserView();

#if DUI_NEEDS_OWN_THREAD
    static DWORD WINAPI CALLBACK ThisViewThreadCallback( LPVOID pvContext );
    DWORD ThisViewThreadCallback();
#endif

    friend class CDUserViewFactory;
    
public:


    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID* ppvObject );
    
    STDMETHOD(SetParentWindow)( HWND hWnd );
    STDMETHOD(Draw)(void);
	STDMETHOD(NextRow)( int nColumns, const LPCWSTR* columns );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\controller\controller.h ===
/*
*/
#pragma once

#include "iuiview.h"
#include <string>
#include "atlwin.h"
#include <vector>
#include "SxApwHandle.h"
#include "SxApwWin.h"

class __declspec(uuid(CLSID_CSxApwControllerView_declspec_uuid))
CSxApwControllerView
:
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwControllerView, &__uuidof(CSxApwControllerView)>,
    public ATL::CWindowImpl<CSxApwControllerView>,
    public ISxApwUiView,
    public IDispatch
{
public:

    CSxApwControllerView() { }

    BEGIN_COM_MAP(CSxApwControllerView)
	    COM_INTERFACE_ENTRY(ISxApwUiView)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

    BEGIN_MSG_MAP(CSxApwControllerView)
    END_MSG_MAP()

    DECLARE_NO_REGISTRY();

    void __stdcall F1(BSTR bstrDataSourceDll)
    {
        m_host->SetDataSource(bstrDataSourceDll);
    }

    void __stdcall F2(BSTR bstrViewDll, long show)
    {
        if (show)
        {
            m_host->CreateView(bstrViewDll);
        }
        else
        {
            m_host->DestroyView(bstrViewDll);
        }
    }

    void __stdcall F3(BSTR bstrQuery)
    {
        m_host->RunQuery(bstrQuery);
    }

    void __stdcall F4()
    {
        PostQuitMessage(0);
    }

    STDMETHOD(Invoke)(
        DISPID      dispId, 
        REFIID      riid,
        LCID        lcid, 
        WORD        wFlags, 
        DISPPARAMS* pDispParams, 
        VARIANT*    pVarResult, 
        EXCEPINFO*  pExcepInfo, 
        UINT*       puArgErr 
        )
    {
        switch (dispId)
        {
        case 1:
            F1(pDispParams->rgvarg[0].bstrVal);
            break;
        case 2:
            F2(pDispParams->rgvarg[1].bstrVal, pDispParams->rgvarg[0].lVal);
            break;
        case 3:
            F3(pDispParams->rgvarg[0].bstrVal);
            break;
        case 4:
            F4();
            break;
        }
        return S_OK;
    }


    STDMETHOD(GetTypeInfoCount)(
        UINT* pcinto
        )
    {
        *pcinto = 0;
        return S_OK;
    }

    STDMETHOD(GetTypeInfo)(
        UINT        iTInfo, 
        LCID        lcid, 
        ITypeInfo** ppTInfo
        )
    {
        *ppTInfo = NULL;
        return E_NOTIMPL;
    }

    STDMETHOD(GetIDsOfNames)(
        REFIID  iid,
        PWSTR*  rgpszNames,
        UINT    cNames,
        LCID    lcid,
        DISPID* rgDispId
        )
    {
        //
        // Simple: find a run of decimal digits in each name, and convert it.
        //
        UINT i;
        for (i = 0 ; i != cNames ; ++i)
        {
            rgDispId[i] = _wtoi(rgpszNames[i] + wcscspn(rgpszNames[i], L"0123456789"));
        }
        return S_OK;
    }

    STDMETHOD(SetSite)(
        ISxApwHost* host
        )
    {
        m_host = host;
        return S_OK;
    }

    STDMETHOD(CreateWindow)(
        HWND hWnd
        );

	STDMETHOD(OnNextRow)(
		int     nColumns,
		const LPCWSTR* columns
		)
    {return S_OK; }

	STDMETHOD(OnRowCountEstimateAvailable)(
		int
		)
    {return S_OK; }

	STDMETHOD(OnQueryStart)(
		)
    {return S_OK; }

	STDMETHOD(OnQueryDone)(
		)
    {return S_OK; }

    STDMETHOD(InformSchema)(
        const SxApwColumnInfo   rgColumnInfo[],
        int                     nColumns
        )
    {return S_OK; }

    ATL::CComPtr<ISxApwHost>      m_host;
    std::vector<CContainedWindow> m_checkbuttonsViews;
    std::vector<CContainedWindow> m_radioButtonsSources;
    ATL::CContainedWindow         m_editQuery;
    ATL::CContainedWindow         m_buttonRun;
    ATL::CAxWindow                m_axWindow;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\duser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by duser.rc
//
#define IDM_MAINMENU                    101
#define IDI_DUSERFORM                   102
#define IDM_EXIT                        40001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\duser\cduser.cpp ===
#include "stdinc.h"
#include "local-stdinc.h"
#include "cduser.h"
#include "duser.h"
#include <stdio.h>


#define SAPW_DU_SET_PARENT_WINDOW           ( WM_USER + 1 )
#define SAPW_DU_TEARDOWN_INSTANCE           ( WM_USER + 2 )
#define SAPW_DU_NEXT_ROW                     ( WM_USER + 3 )
#define SAPW_DU_DRAW_REQUEST                 ( WM_USER + 4 )


class CRowObjectRowElement : public DirectUI::Element
{
    IViewRow *m_pContainedColumns;

    HRESULT ReCreateUI();

public:
    CRowObjectRowElement();
    ~CRowObjectRowElement();

    virtual HRESULT SetDatasource( IViewRow* );
    virtual HRESULT Initialize();
};

CRowObjectRowElement::CRowObjectRowElement()
    : m_pContainedColumns( NULL )
{
}

CRowObjectRowElement::~CRowObjectRowElement()
{
    SetDatasource( NULL );
    this->DestroyAll();
}

HRESULT
CRowObjectRowElement::SetDatasource( IViewRow* pRowSource )
{
    HRESULT hr = E_FAIL;

    if ( m_pContainedColumns != NULL )
    {
        m_pContainedColumns->Release();
        m_pContainedColumns = NULL;
    }

    m_pContainedColumns = pRowSource;

    if ( m_pContainedColumns != NULL )
    {
        hr = ReCreateUI();
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}


HRESULT
CRowObjectRowElement::ReCreateUI()
{
    HRESULT hr = E_FAIL;
    DirectUI::Layout *OurLayout = NULL;
    int iColumns = 0;

    //
    // Clear all stored UI first
    //
    this->DestroyAll();

    //
    // Construct the gridded layout of this object first
    //
    if ( FAILED( hr = m_pContainedColumns->get_Count( &iColumns ) ) )
        goto Exit;

    hr = DirectUI::GridLayout::Create( 1, iColumns, &OurLayout );
    if ( FAILED( hr ) )
        goto Exit;

    //
    // Then toss in a text label for each
    //
    for ( int i = 1; i <= iColumns; i++ )
    {
        DirectUI::Element *pElement = NULL;
        BSTR bstTemp;
        
        if ( FAILED( hr = DirectUI::Element::Create( 0, &pElement ) ) )
        {
            this->DestroyAll();
            goto Exit;
        }

        // 
        // Get, copy, send, etc.
        //
        hr = this->m_pContainedColumns->get_Value( i, &bstTemp );
        if ( SUCCEEDED( hr ) && ( bstTemp != NULL ) )
        {
            hr = pElement->SetContentString( bstTemp );

            if ( SUCCEEDED( hr ) )
            {
                hr = this->Add( pElement );
                if ( FAILED( hr ) )
                    break;
            }
            
            SysFreeString( bstTemp );
        }
    }

    hr = S_OK;

Exit:
    if ( FAILED( hr ) )
    {
        this->DestroyAll();
    }
    return hr;
}


HRESULT
CRowObjectRowElement::Initialize()
{
    HRESULT hr = E_FAIL;
    
    if ( FAILED(hr = DirectUI::Element::Initialize(0)) )
        return hr;

    return hr;
}


CSxApwDUserView::CSxApwDUserView()
: m_hOurParentWnd( NULL ), m_hMasterElement( NULL ),
#if DUI_NEEDS_OWN_THREAD  
  m_hThreadHandle( INVALID_HANDLE_VALUE ), m_dwThreadId( 0 ),
#endif  
  m_ulRefCount( 1 )
{

    //
    // Spin a thread for this object
    //
#if DUI_NEEDS_OWN_THREAD
    m_hThreadGoing = CreateEvent( NULL, FALSE, FALSE, NULL );

    m_hThreadHandle = CreateThread(
        NULL,
        0,
        CSxApwDUserView::ThisViewThreadCallback,
        this,
        0,
        &m_dwThreadId
    );

    ASSERT( m_hThreadHandle != INVALID_HANDLE_VALUE );

    //
    // We really do have to wait for the thread to get going
    //
    WaitForSingleObject( m_hThreadGoing, INFINITE );
    CloseHandle( m_hThreadGoing );
#else
    ASSERT( ConstructGadgets() );
#endif    

}


CSxApwDUserView::~CSxApwDUserView()
{
#if DUI_NEEDS_OWN_THREAD
    ASSERT( m_hThreadHandle == INVALID_HANDLE_VALUE );
#endif    
}




HRESULT
CSxApwDUserView::InternalCreateUI()
{
    HRESULT hr = E_FAIL;
    DirectUI::Value* pvLayout = NULL;

    //
    // No current UI, must have master window to start with.
    //
    ASSERT( m_hMasterElement == NULL );
    ASSERT( m_hOurParentWnd != NULL );

    //
    // Create the directUI top-level Element object
    //
    hr = DirectUI::HWNDElement::Create( m_hOurParentWnd, true, 0, &this->m_hMasterElement );
    if ( FAILED( hr ) )
        goto Exit;

    //
    // Create this row-layout object so we can just toss things into it, then set the container
    // as the host.
    //
    int __params[] = { -1, 0, 3 };
    
    if ( FAILED( hr = DirectUI::RowLayout::Create( 3, __params, &pvLayout ) ) )
        goto Exit;

    hr = this->m_hMasterElement->SetValue( 
        DirectUI::Element::LayoutProp, 
        PI_Local, 
        pvLayout
    );

    if ( FAILED( hr ) )
        goto Exit;

    hr = S_OK;

Exit:
    if ( FAILED(hr) )
    {
        InternalDestroyUI();
    }

    return hr;
}




HRESULT
CSxApwDUserView::InternalDestroyUI()
{
    HRESULT hr = E_FAIL;

    if ( m_hMasterElement == NULL )
    {
        hr = S_OK;
    }
    else
    {
        hr = m_hMasterElement->DestroyAll();
        m_hMasterElement = NULL;
    }

    return hr;
}



STDMETHODIMP
CSxApwDUserView::SetParentWindow(
    HWND hWnd/*hWnd*/
    )
{
    HRESULT hr = S_OK;

#if DUI_NEEDS_OWN_THREAD
    BOOL bOk;
    ASSERT( m_dwThreadId != 0 );    
    bOk = PostThreadMessageW( m_dwThreadId, SAPW_DU_SET_PARENT_WINDOW, (WPARAM)hWnd, NULL );
    ASSERT( bOk );
#else

    if ( SUCCEEDED( hr = InternalDestroyUI() ) )
    {
        m_hOurParentWnd = hWnd;
        hr = InternalCreateUI();
    }

#endif
    return hr;
}

class CRowObject;

#if DUI_NEEDS_OWN_THREAD

DWORD
CSxApwDUserView::ThisViewThreadCallback()
{
    MSG msg;
    BOOL bConstructed = ConstructGadgets();
    BOOL bOk;

    ASSERT( bConstructed );

    //
    // Cheeseball method of making sure that this thread has started before we let the
    // constructor continue.
    //
    PeekMessage( &msg, NULL, 0, 0, PM_NOREMOVE );
    SetEvent( this->m_hThreadGoing );

    while ( ( bOk = GetMessage( &msg, NULL, 0, 0 ) ) != 0 )
    {
        TranslateMessage( &msg );

        //
        // If this is a "set parent window" message, then we have to disconnect from our
        // current UI, reconstruct the new UI, and go about our business.
        //
        if ( msg.message == SAPW_DU_SET_PARENT_WINDOW )
        {
            //
            // Detsroy our current UI
            //
            if ( SUCCEEDED( InternalDestroyUI() ) )
            {
                //
                // And if we're setting to a new HWND, reconstruct the UI around
                // it.
                //
                if ( m_hOurParentWnd != (HWND)msg.wParam )
                {
                    m_hOurParentWnd = (HWND)msg.wParam;
                    InternalCreateUI();
                }
            }
        }
        else if ( msg.message == SAPW_DU_TEARDOWN_INSTANCE )
        {
            this->InternalDestroyUI();
            break;
        }
        else if ( msg.message == SAPW_DU_NEXT_ROW )
        {
            CRowObject* pRowObject = (CRowObject*)msg.wParam;
            this->InternalSetNextRow( pRowObject );
        }
        else
        {
            DispatchMessage( &msg );
        }
    }

    return 0;
    
}



DWORD WINAPI CALLBACK
CSxApwDUserView::ThisViewThreadCallback( LPVOID pvContext )
{
    DWORD dwRetValue = 0;
    
    __try
    {
        dwRetValue = ((CSxApwDUserView*)pvContext)->ThisViewThreadCallback();
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        DebugBreak();
    }

    return dwRetValue;
}

#endif

HRESULT
CSxApwDUserView::InternalSetNextRow( IViewRow* pRow )
{
    CRowObjectRowElement *pElement = NULL;
    HRESULT hr = E_FAIL;

    //
    // Add this next row to the table-view gadget
    //
    if ( pRow == NULL )
        return E_INVALIDARG;

    pElement = new CRowObjectRowElement();
    hr = pElement->Initialize();

    if ( FAILED( hr = pElement->Initialize() ) )
        goto Exit;

    pRow->AddRef();
     if ( FAILED( hr = pElement->SetDatasource( pRow ) ) )
        goto Exit;

    hr = m_hMasterElement->Add( pElement );
    if ( SUCCEEDED( hr ) )
        pElement = NULL;

    hr = S_OK;

Exit:
    if ( pElement != NULL )
    {
        delete pElement;
        pElement = NULL;
    }

    if ( pRow != NULL )
        pRow->Release();
        
    return hr;
}


STDMETHODIMP
CSxApwDUserView::Draw(
    )
{
#if DUI_NEEDS_OWN_THREAD
    BOOL b = PostThreadMessageW( m_dwThreadId, SAPW_DU_DRAW_REQUEST, NULL, NULL );
    ASSERT( b );
    return b ? S_OK : E_FAIL;
#else
    return S_OK;
#endif    
}



STDMETHODIMP
CSxApwDUserView::NextRow(
	int     nColumns,
    const LPCWSTR* columns
	)
{
    CRowObject *Row = new CRowObject();
    HRESULT hr = S_OK;

    Row->set_Count( nColumns, TRUE );
    
    for ( int i = 0; i < nColumns; i++ )
    {
        if ( FAILED( hr = Row->set_Value( i + 1, _bstr_t(columns[i]) ) ) )
        {
            ASSERT( FALSE );
            break;
        }
            
    }

    if ( hr == S_OK )
    {
#if DUI_NEEDS_OWN_THREAD
        if ( !PostThreadMessageW( m_dwThreadId, SAPW_DU_NEXT_ROW, (WPARAM)Row, NULL ) )
        {
            ASSERT( FALSE );
            hr = E_FAIL;
        }
#else        
        hr = this->InternalSetNextRow( Row );
#endif
    }

    return hr;
}



ULONG STDMETHODCALLTYPE 
CSxApwDUserView::AddRef()
{
    return ::InterlockedIncrement( &m_ulRefCount );
}




ULONG STDMETHODCALLTYPE 
CSxApwDUserView::Release()
{
    ULONG ulRefCount = ::InterlockedDecrement( &m_ulRefCount );
    if ( ulRefCount == 0 )
    {
#if DUI_NEEDS_OWN_THREAD
        if ( !PostThreadMessageW( m_dwThreadId, SAPW_DU_TEARDOWN_INSTANCE, NULL, NULL ) )
        {
            ASSERT( FALSE );
        }
        WaitForSingleObject( m_hThreadHandle, INFINITE );
        m_hThreadHandle = INVALID_HANDLE_VALUE;
#endif        
        delete this;
    }
    return ulRefCount;
}




HRESULT STDMETHODCALLTYPE 
CSxApwDUserView::QueryInterface( 
    REFIID riid, 
    LPVOID* ppvObject 
)
{
    HRESULT hr = S_OK;

    if ( ppvObject )
        *ppvObject = NULL;
    else
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if ( riid == IID_IUnknown ) 
    {
        AddRef();
        *ppvObject = (IUnknown*)this;
    } 
    else if ( riid == __uuidof(ISxApwUiView) ) 
    {
        AddRef();
        *ppvObject = (ISxApwUiView*)this;
    } 
    else 
    {
        hr = E_NOINTERFACE;
    }

Exit:
    return hr;
    
}

static CHAR chVeryVeryLargeAssertionBuffer[4096];

VOID 
FailAssertion( 
    PCSTR pszFile, 
    PCSTR pszFunction, 
    int iLine, 
    PCSTR pszExpr 
)
{
    static const CHAR szAssertionFormatter[] = "\n*** Assertion failed: %s\n*** At %s(%d) in %s\n";
    
    _snprintf( 
        chVeryVeryLargeAssertionBuffer, 
        NUMBER_OF(chVeryVeryLargeAssertionBuffer),
        szAssertionFormatter, 
        pszExpr, 
        pszFile, 
        iLine, 
        pszFunction 
    );
    
    OutputDebugStringA( chVeryVeryLargeAssertionBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\edit\stdinc.h ===
#include "SxApwStdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\duser\rowobject.h ===
#pragma once

class __declspec(uuid("4065c728-35e0-4f47-ab1a-f1bc2346501b"))
IViewRow : public IUnknown
{
public:
    virtual HRESULT get_Value( /*in*/ int iWhichColumn, /*out,retval*/ BSTR* pbstColumnValue ) = 0;
    virtual HRESULT get_Count( /*out,retval*/ int* piColumnCount  ) = 0;
};


class __declspec(uuid("b0f49322-2f03-490c-b6a0-55d7f1efe719"))
IWriteableViewRow : public IViewRow
{
public:
    virtual HRESULT set_Value( /*in*/ int iWhichColumn, /*in*/ BSTR bstColumnValue ) = 0;
    virtual HRESULT set_Count( /*in*/ int iColumnCount, /*in*/ BOOL bClipExtraColumns ) = 0;
};


class CRowObject : public IWriteableViewRow
{
    CRITICAL_SECTION m_csColumnDataLock;
    int m_iColumnCount, m_iMaxColumns;
    _bstr_t *m_pbstColumnData;
    LONG m_lRefCount;

    HRESULT EnsureColumnSize( int iColumnsRequired );
    HRESULT Lock();
    HRESULT UnLock();

public:

    CRowObject();
    ~CRowObject();
    
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, void** ppvObject );
    
    virtual HRESULT get_Value( /*in*/ int iWhichColumn, /*out,retval*/ BSTR* pbstColumnValue );
    virtual HRESULT set_Value( /*in*/ int iWhichColumn, /*out,retval*/ BSTR pbstColumnValue );
    virtual HRESULT get_Count( /*out,retval*/ int* piColumnCount  );
    virtual HRESULT set_Count( /*out,retval*/ int piColumnCount, BOOL bClipExtras  );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\duser\local-stdinc.h ===
#define UNICODE
#include "windows.h"
#include "winnt.h"
#include "windows.h"
#include "duser.h"
#include "dusercore.h"
#include "duserutil.h"
#include "dusermotion.h"
#include "resource.h"
#include "comutil.h"
#include "directui.h"

using namespace DirectUI;
using namespace DUser;

#define DUI_NEEDS_OWN_THREAD 0

#pragma warning ( disable: 4127 )

extern HINSTANCE    g_hiThisDllInstance;
extern HDCONTEXT   g_hDUserContext;

#define DUSER_WINDOW_CLASS (L"SxsApwDUserWindowClass")
#define DUSER_WINDOW_TITLE (LL"Winfuse App-week DirectUser UI Plugin")

BOOL ConstructGadgets();


VOID FailAssertion( PCSTR pszFile, PCSTR pszFunction, int iLine, PCSTR pszExpr );
#define ASSERT(x) if ( !(x) ) { FailAssertion( __FILE__, __FUNCTION__, __LINE__, #x ); DebugBreak(); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\duser\rowobject.cpp ===
#include "stdinc.h"
#include "local-stdinc.h"
#include "RowObject.h"

void __stdcall _com_issue_error( HRESULT hr )
{
    ASSERT( hr != S_OK );
    throw hr;
}


CRowObject::CRowObject() : m_iColumnCount(0), m_iMaxColumns(0), m_pbstColumnData(NULL), 
    m_lRefCount(1)
{
    ::InitializeCriticalSection( &this->m_csColumnDataLock );
}

HRESULT
CRowObject::EnsureColumnSize( int iColumns )
{
    HRESULT hr = E_FAIL;

    this->Lock();
    __try
    {
        if ( ( iColumns > m_iMaxColumns ) || ( m_pbstColumnData == NULL ) )
        {
            _bstr_t *pbstNewData = new _bstr_t[iColumns];

            if ( m_pbstColumnData != NULL )
            {
                for ( int i = 0; i < m_iMaxColumns; i++ )
                    pbstNewData[i] = m_pbstColumnData[i];
                delete[] m_pbstColumnData;
            }
            
            m_pbstColumnData = pbstNewData;
            m_iMaxColumns = iColumns;
        }
    }
    __finally
    {
        this->UnLock();
    }

    return hr;
}

CRowObject::~CRowObject() 
{
    this->Lock();
    if ( m_pbstColumnData )
    {
        delete [] m_pbstColumnData;
        m_pbstColumnData = NULL;
        m_iColumnCount = 0;
        m_iMaxColumns = 0;
    }
    ::LeaveCriticalSection( &m_csColumnDataLock );
    ::DeleteCriticalSection( &m_csColumnDataLock );
}

ULONG STDMETHODCALLTYPE 
CRowObject::AddRef() { return ::InterlockedIncrement( &m_lRefCount ); }

ULONG STDMETHODCALLTYPE 
CRowObject::Release() { 
    ULONG lRC = ::InterlockedDecrement( &m_lRefCount );
    if ( lRC == 0 )
        delete this;
    return lRC;
}

HRESULT STDMETHODCALLTYPE 
CRowObject::QueryInterface( REFIID riid, void** ppvObject ) {
    if ( ppvObject == NULL )
        return E_INVALIDARG;
    else
        *ppvObject = NULL;

    if ( riid == __uuidof(IViewRow) ) {
        *ppvObject = (IViewRow*)this;
    } else if ( riid == __uuidof( IWriteableViewRow ) ) {
        *ppvObject = (IWriteableViewRow*)this;
    } else if ( riid == __uuidof( IUnknown ) ) {
        *ppvObject = (IUnknown*)this;
    } else return E_NOINTERFACE;

    if ( *ppvObject ) {
        ((IUnknown*)*ppvObject)->AddRef();
    }

    return S_OK;
    
}

HRESULT
CRowObject::set_Count( int iTotalColumns, BOOL bClipOffRemaining )
{
    HRESULT hr = E_FAIL;

    this->Lock();
    __try
    {
        //
        // bClipOffRemaining is apocryphal, and was suppose to be an optimization
        // to allow pruning of the table size.  Now, it's just "there"
        //
        if ( FAILED( hr = this->EnsureColumnSize( iTotalColumns ) ) )
            __leave;
            
        m_iColumnCount = iTotalColumns;
    }
    __finally
    {
        this->UnLock();
    }

    return hr;
}


HRESULT
CRowObject::set_Value( int iWhichColumn, BSTR bstColumnValue )
{
    HRESULT hr = E_FAIL;

    if ( ( iWhichColumn == 0 ) || ( bstColumnValue == NULL ) )
        return E_INVALIDARG;

    this->Lock();
    __try
    {
        if ( iWhichColumn > this->m_iColumnCount )
        {
            this->EnsureColumnSize( iWhichColumn );
        }

        this->m_pbstColumnData[iWhichColumn - 1] = bstColumnValue;
        if ( iWhichColumn > m_iColumnCount ) m_iColumnCount = iWhichColumn;
        hr = S_OK;
    }
    __finally
    {
        this->UnLock();
    }

    return hr;
    
}

HRESULT 
CRowObject::get_Value( int iWhichColumn, BSTR* pbstColumnValue )
{
    HRESULT hr = E_FAIL;

    if ( pbstColumnValue == NULL )
        return E_INVALIDARG;
    else
        *pbstColumnValue = NULL;

    if ( iWhichColumn == 0 )
        return E_INVALIDARG;

    this->Lock();
    __try
    {
        if ( iWhichColumn > this->m_iColumnCount )
        {
            hr = E_INVALIDARG;
            __leave;
        }
        else if ( m_pbstColumnData == NULL )
        {
            __leave;
        }
        else
        {
            *pbstColumnValue = m_pbstColumnData[iWhichColumn-1].copy();
            hr = S_OK;
        }
    }
    __finally
    {
        this->UnLock();
    }

    return hr;
}

HRESULT 
CRowObject::get_Count( int* piColumnCount )
{
    HRESULT hr = E_FAIL;

    if ( piColumnCount == NULL )
        return E_INVALIDARG;
    else
        *piColumnCount = 0;

    this->Lock();
    __try
    {
        *piColumnCount = this->m_iColumnCount;
        hr = S_OK;
    }
    __finally
    {
        this->UnLock();
    }

    return hr;
}


HRESULT
CRowObject::Lock() 
{ 
    ::EnterCriticalSection( &this->m_csColumnDataLock );
    return S_OK; 
}

HRESULT
CRowObject::UnLock()
{
    ::LeaveCriticalSection( &this->m_csColumnDataLock );
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\edit\edit.cpp ===
#include "stdinc.h"
#include "edit.h"
#include <stdio.h>
#include "FusionTrace.h"

static ATL::CComModule Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(__uuidof(CSxApwEditView), CSxApwEditView)
END_OBJECT_MAP()

ATL::CComModule* GetModule() { return &Module; }
ATL::_ATL_OBJMAP_ENTRY* GetObjectMap() { return ObjectMap; }
const CLSID* GetTypeLibraryId() { return NULL; }

STDMETHODIMP
CSxApwEditView::CreateWindow(
    HWND hwndParent
    )
{
    HRESULT hr = S_OK;
    RECT rc;
    ATL::CWindow parent(hwndParent);
    HWND hwnd;

    IFFALSE_WIN32TOHR_EXIT(hr, parent.GetClientRect(&rc));
    IFFALSE_WIN32TOHR_EXIT(hr, parent.ScreenToClient(&rc)); // GetLastError wrong on Win9x

    IFFALSE_WIN32TOHR_EXIT(
        hr,
        hwnd = CreateWindowW(
            L"Edit",
            NULL,
            WS_CHILD | WS_VISIBLE | ES_MULTILINE | ES_AUTOVSCROLL,
            0, 0, rc.right - rc.left, rc.bottom - rc.top,
            parent,
            NULL,
            NULL,
            NULL
            ));
    m_edit.Attach(hwnd);
    hr = S_OK;
Exit:
    return hr;
}

STDMETHODIMP
CSxApwEditView::OnNextRow(
	int     nColumns,
	const LPCWSTR rgpszColumns[]
	)
{
    for (int i = 0 ; i < nColumns ; i++)
    {
        m_string.append(rgpszColumns[i]);
        m_string.append((i == nColumns - 1) ? L"\r\n" : L" ");
    }
    m_edit.SetWindowText(m_string.c_str());
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\gdiplus\sources.inc ===
RELATIVE_DEPTH=..\$(RELATIVE_DEPTH)
!include ..\$(RELATIVE_DEPTH)\sources.inc

INCLUDES=$(INCLUDES);$(SDK_INC_PATH)\gdiplus

TARGETTYPE=DYNLINK
DLLDEF=..\gdiplvw.def

DLLENTRY=SxApwGdiPlVwDllMain

USE_STL=1

SOURCES=  \
 ..\gdiplvw.cpp \
 ..\dllmain.cpp \
 ..\gdiplvw.rc

LINKLIBS=\
 $(SXAPW_LIB_LIB)  \
 $(SXAPW_STDINC_LIB) \
 $(SXAPW_GUIDS_LIB)

TARGETLIBS=\
 $(SDK_LIB_PATH)\kernel32.lib \
 $(SDK_LIB_PATH)\oleaut32.lib \
 $(SDK_LIB_PATH)\user32.lib   \
 $(SDK_LIB_PATH)\gdiplus.lib  \
 $(SDK_LIB_PATH)\uuid.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\gdiplus\gdiplvw.h ===
/*
*/
#pragma once

#include "iuiview.h"
#include <string>
#include "atlwin.h"
#include <gdiplus.h>

using namespace Gdiplus;
using namespace std;

class __declspec(uuid(CLSID_CSxApwGDIPlusView_declspec_uuid))
CSxApwGDIPlusView
:
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwGDIPlusView, &__uuidof(CSxApwGDIPlusView)>,
    public ATL::CWindowImpl<CSxApwGDIPlusView>,
    public ISxApwUiView    
{
public:

    CSxApwGDIPlusView() { }
    ~CSxApwGDIPlusView() { GdiplusShutdown(gdiplusToken); }

    BEGIN_COM_MAP(CSxApwGDIPlusView)
	    COM_INTERFACE_ENTRY(ISxApwUiView)
    END_COM_MAP()

    DECLARE_NO_REGISTRY();

    BEGIN_MSG_MAP(CSxApwGDIPlusView)
        MESSAGE_HANDLER(WM_PAINT, OnPaint)
    END_MSG_MAP()

public:

    STDMETHOD(SetSite)(
        ISxApwHost* host
        )
    {
        m_host = host;
        return S_OK;
    }

    STDMETHOD(CreateWindow)(
        HWND hWnd
        );

	STDMETHOD(OnNextRow)(
		int           nColumns,
		const LPCWSTR rgpszColumns[]
		);

	STDMETHOD(OnRowCountEstimateAvailable)(
		int
		)
    { 
        return S_OK; 
    }

	STDMETHOD(OnQueryStart)(
		)
    { 
        m_FoundInterestingData = false;
        m_wstring.erase();
        return S_OK; 
    }

	STDMETHOD(OnQueryDone)(
		)
    {   
        if ( m_wstring.length() == 0 )
            m_wstring.assign(L"Empty String");
        m_gdiplus.RedrawWindow();
        return S_OK; 
    }

    STDMETHOD(InformSchema)(
        const SxApwColumnInfo   rgColumnInfo[],
        int                     nColumns
        )
    {
        return S_OK;
    }

    LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    ATL::CComPtr<ISxApwHost>    m_host;
    ATL::CWindow                m_gdiplus;
    wstring                     m_wstring;

    GdiplusStartupInput gdiplusStartupInput;
    ULONG_PTR           gdiplusToken;
    bool                m_FoundInterestingData;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\stdout\stdinc.h ===
#include "SxApwStdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\edit\edit.h ===
/*
*/
#pragma once

#include "iuiview.h"
#include <string>
#include "atlwin.h"

class __declspec(uuid(CLSID_CSxApwEditView_declspec_uuid))
CSxApwEditView
:
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwEditView, &__uuidof(CSxApwEditView)>,
    public ISxApwUiView
{
public:

    CSxApwEditView() { }

    BEGIN_COM_MAP(CSxApwEditView)
	    COM_INTERFACE_ENTRY(ISxApwUiView)
    END_COM_MAP()

    DECLARE_NO_REGISTRY();

    STDMETHOD(SetSite)(
        ISxApwHost* host
        )
    {
        m_host = host;
        return S_OK;
    }

    STDMETHOD(CreateWindow)(
        HWND hWnd
        );

	STDMETHOD(OnNextRow)(
		int     nColumns,
		const LPCWSTR rgpszColumns[]
		);

	STDMETHOD(OnRowCountEstimateAvailable)(
		int
		)
    {return S_OK; }

	STDMETHOD(OnQueryStart)(
		)
    { m_string.erase(); return S_OK; }

	STDMETHOD(OnQueryDone)(
		)
    { m_string.erase(); return S_OK; }

    STDMETHOD(InformSchema)(
        const SxApwColumnInfo   rgColumnInfo[],
        int                     nColumns
        )
    {return S_OK; }

    ATL::CComPtr<ISxApwHost>    m_host;
    ATL::CWindow                m_edit;
    std::wstring                m_string;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\gdiplus\stdinc.h ===
#include "SxApwStdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\gdiplus\dllmain.cpp ===
#include "stdinc.h"
#include "gdiplvw.h"

ATL::_ATL_OBJMAP_ENTRY* GetObjectMap();
const CLSID* GetTypeLibraryId();

extern wstring gTitle;

extern "C"
BOOL WINAPI _DllMainCRTStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);

extern "C"
BOOL WINAPI SxApwGdiPlVwDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    HANDLE ActivationContextHandle;
    WCHAR szFileName[500];
    wstring strTemp;

    BOOL fSuccess = FALSE;
    if (!_DllMainCRTStartup(hInstance, dwReason, lpReserved))
        goto Exit;

    switch (dwReason)
    {
    default:
        break;

    case DLL_PROCESS_ATTACH:
        GetModule()->Init(GetObjectMap(), hInstance, GetTypeLibraryId());
        DisableThreadLibraryCalls(hInstance);

        gTitle.assign(L"GDI Plus - ");

        ActivationContextHandle = NULL;

        GetCurrentActCtx(&ActivationContextHandle);

        if ( ActivationContextHandle )
        {
            GetModuleFileName(GetModuleHandle(L"GdiPlus"), szFileName, sizeof(szFileName));
            strTemp.assign(szFileName);

            if ( strTemp.find(L"views\\Microsoft.Windows.GdiPlus") != wstring::npos )
                gTitle.append(L"Private Assembly");
            else
                gTitle.append(L"Side-by-Side (Global) Assembly");
            ReleaseActCtx(ActivationContextHandle);
        }
        else
            gTitle.append(L"System Default");
        
        break;

    case DLL_PROCESS_DETACH:
        GetModule()->Term();
        break;
    }
    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\stdout\cstdout.cpp ===
#include "stdinc.h"
#include "cstdout.h"
#include <stdio.h>

static ATL::CComModule Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(__uuidof(CSxApwStdoutView), CSxApwStdoutView)
END_OBJECT_MAP()

ATL::CComModule* GetModule() { return &Module; }
ATL::_ATL_OBJMAP_ENTRY* GetObjectMap() { return ObjectMap; }
const CLSID* GetTypeLibraryId() { return NULL; }

STDMETHODIMP
CSxApwStdoutView::InformSchema(
    const SxApwColumnInfo   rgColumnInfo[],
    int                     nColumns
    )
{
    int i;
    int length = 0;
    printf("column headings:\n");
    for (i = 0 ; i < nColumns ; i++)
    {
        length += printf("%ls%c", rgColumnInfo[i].Name, (i == nColumns - 1) ? '\n' : ' ');
    }
    while (--length > 0)
        printf("=");
    return S_OK;
}

STDMETHODIMP
CSxApwStdoutView::OnNextRow(
	int             nColumns,
	const LPCWSTR   rgpszColumns[]
	)
{
    int i;
    for (i = 0 ; i < nColumns ; i++)
    {
        printf("%ls%c", rgpszColumns[i], (i == nColumns - 1) ? '\n' : ' ');
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\gdiplus\gdiplvw.cpp ===
#include "stdinc.h"
#include "gdiplvw.h"
#include "FusionTrace.h"

static ATL::CComModule Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(__uuidof(CSxApwGDIPlusView), CSxApwGDIPlusView)
END_OBJECT_MAP()

ATL::CComModule* GetModule() { return &Module; }
ATL::_ATL_OBJMAP_ENTRY* GetObjectMap() { return ObjectMap; }
const CLSID* GetTypeLibraryId() { return NULL; }

wstring gTitle;

STDMETHODIMP
CSxApwGDIPlusView::CreateWindow(
    HWND hwndParent
    )
{
    HRESULT hr = S_OK;

    m_gdiplus.Attach(hwndParent);

    m_wstring.erase();

    // Initialize GDI+
    GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);

#undef SubclassWindow
    this->SubclassWindow(hwndParent);

    m_gdiplus.SetWindowText(gTitle.c_str());
    return hr;
}


STDMETHODIMP
CSxApwGDIPlusView::OnNextRow(
	int   nColumns,
    const LPCWSTR rgpszColumns[]
	)
{
    wstring str;

    if ( m_FoundInterestingData )
        return S_OK;

    if ( nColumns > 0 )
        m_wstring.assign(rgpszColumns[0]);

    for ( int i = 1; i < nColumns; i++ )
    {
        str.assign(rgpszColumns[i]);
        if ( str.length() > m_wstring.length() )
            m_wstring.assign(str);
    }

    if ( m_wstring.length() > 10 )
        m_FoundInterestingData = true;

    return S_OK;
}

LRESULT CSxApwGDIPlusView::OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    PAINTSTRUCT ps;

    HDC hdc = m_gdiplus.BeginPaint(&ps);

    int len = (int)m_wstring.length();

    if ( len == 0 )
    {
        m_gdiplus.EndPaint(&ps);
        return 0;
    }

    Rect rect, rect1, rect2, rect1a, rect2a;
    Graphics  grfx(hdc);
    GraphicsPath grfxPath;
    FontFamily fF(L"Arial");
    Point pt(20,20);
    StringFormat strF(0);

    WCHAR *psz = new WCHAR[len + 1];
    m_wstring.copy(psz, len);
    psz[len] = L'\0';
    grfxPath.AddString(psz, len, &fF, FontStyleBold, 48, pt, &strF);
    grfxPath.GetBounds(&rect);

    rect1 = rect;
    rect1.Width = rect.Width/2;
    rect1a = rect1;
    rect1a.Width = 1;

    rect2 = rect;
    rect2.X = rect1.X + rect1.Width;
    rect2.Width = rect.Width - rect1.Width;
    rect2a = rect2;
    rect2a.Width = 1;

    LinearGradientBrush brush1(rect1, Color(255,0,255,0), Color(255,255,0,0),
                               LinearGradientModeHorizontal);
    LinearGradientBrush brush2(rect2, Color(255,255,0,0), Color(255,0,0,255),
                               LinearGradientModeHorizontal);

    SolidBrush brush1a(Color(255,0,255,0));
    SolidBrush brush2a(Color(255,255,0,0));

    grfx.SetClip(&grfxPath);
    grfx.FillRectangle(&brush1, rect1);
    grfx.FillRectangle(&brush1a, rect1a);
    grfx.FillRectangle(&brush2, rect2);
    grfx.FillRectangle(&brush2a, rect2a);

    m_gdiplus.EndPaint(&ps);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\appweek\uiviews\stdout\cstdout.h ===
/*
*/
#pragma once

#include "iuiview.h"

class __declspec(uuid(CLSID_CSxApwStdoutView_declspec_uuid))
CSxApwStdoutView
:
    public ATL::CComObjectRootEx<CComSingleThreadModel>,
    public ATL::CComCoClass<CSxApwStdoutView, &__uuidof(CSxApwStdoutView)>,
    public ISxApwUiView
{
public:

    CSxApwStdoutView() { }

    BEGIN_COM_MAP(CSxApwStdoutView)
	    COM_INTERFACE_ENTRY(ISxApwUiView)
    END_COM_MAP()

    DECLARE_NO_REGISTRY();

    STDMETHOD(SetSite)(
        ISxApwHost* host
        )
    {
        m_host = host;
        return S_OK;
    }

    STDMETHOD(CreateWindow)(
        HWND hWnd
        )
    {return S_OK; }

	STDMETHOD(OnNextRow)(
		int     nColumns,
		const LPCWSTR rgpszColumns[]
		);

	STDMETHOD(OnRowCountEstimateAvailable)(
		int
		)
    {return S_OK; }

	STDMETHOD(OnQueryStart)(
		)
    {return S_OK; }

	STDMETHOD(OnQueryDone)(
		)
    {return S_OK; }

    STDMETHOD(InformSchema)(
        const SxApwColumnInfo   rgColumnInfo[],
        int                     nColumns
        );

    ATL::CComPtr<ISxApwHost>      m_host;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\debugexts\actctxdump.cpp ===
#include "windows.h"
#define KDEXT_64BIT
#include "dbghelp.h"
#include "wdbgexts.h"
#include "stdlib.h"
#include "stdio.h"
#include "sxstypes.h"
#include "fusiondbgext.h"



DECLARE_API(actctxdata)
{
    ULONG64 ActCtxData = 0;

    if (*args)
    {
        ActCtxData = GetExpression(args);
    }
    else
    {
        if (!GetActiveActivationContextData(&ActCtxData))
        {
            dprintf("Unable to find activation context data for this process at the moment.\n");
            return;
        }
    }

    DumpActCtxData(NULL, ActCtxData, 0xFFFFFFFF);
}

DECLARE_API(actctx)
{
    //
    // This finds the currently-active PACTIVATION_CONTEXT for the thread, or
    // dumps the one indicated as a parameter
    //

    ULONG64 ActiveActCtx = 0;

    if (*args)
    {
        ActiveActCtx = GetExpression(args);
    }
    else
    {
        ULONG64 ulTebAddress;
        ULONG64 ulActiveStackFrame;
        GetTebAddress(&ulTebAddress);

        GetFieldValue(ulTebAddress, "nt!TEB", "ActivationContextStack.ActiveFrame", ulActiveStackFrame);
        if (!ulActiveStackFrame)
        {
            dprintf("There is no current activation context stack frame.  Try !actctxdata instead.\n");
            return;
        }

        GetFieldValue(ulActiveStackFrame, "nt!RTL_ACTIVATION_CONTEXT_STACK_FRAME", "ActivationContext", ActiveActCtx);
        if (!ActiveActCtx)
        {
            dprintf("The activation context stack frame at %p doesn't point to a valid activation context object.\n", ActiveActCtx);
            return;
        }
    }

    DumpActCtx(ActiveActCtx, 0xFFFF);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\debugexts\actctxstack.cpp ===
#include "windows.h"
#define KDEXT_64BIT
#include "wdbgexts.h"
#include "stdlib.h"
#include "stdio.h"
#include "fusiondbgext.h"

DECLARE_API( actctxstack )
{

    ULONG64 ulTebAddress = 0;
    ULONG ulStackFlags = 0;
    ULONG64 ulTopOfRtlFrameList = 0;
    ULONG ulNextCookie = 0;

    GetTebAddress( &ulTebAddress );

    GetFieldValue( ulTebAddress, "nt!TEB", "ActivationContextStack.Flags", ulStackFlags );
    GetFieldValue( ulTebAddress, "nt!TEB", "ActivationContextStack.ActiveFrame", ulTopOfRtlFrameList );
    GetFieldValue( ulTebAddress, "nt!TEB", "ActivationContextStack.NextCookieSequenceNumber", ulNextCookie );

    dprintf(
        "Current activation stack information in TEB %p:\n"
        "   Flags               : 0x%08lx\n"
        "   ActiveFrame         : 0x%p\n"
        "   NextCookieSequence  : 0x%08lx\n",
        ulTebAddress,
        ulStackFlags,
        ulTopOfRtlFrameList,
        ulNextCookie);

    DumpActCtxStackFullStack( ulTopOfRtlFrameList );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\debugexts\sources.inc ===
FUSION_BUILD_TYPE=WIN
!include $(PROJECT_ROOT)\win32\fusion\fusion.inc
MSC_WARNING_LEVEL = -W3 -WX
MAJORCOMP=fusion
MINORCOMP=debugexts

SOURCES_USED=$(SOURCES_USED) ..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\debugexts\dllmain.cpp ===
#include "windows.h"
#include "wdbgexts.h"
#include <ntverp.h>
#include <dbghelp.h>

EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG SavedMajorVersion;
ULONG SavedMinorVersion;

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

//
// Routine called by debugger after load
//
VOID
CheckVersion(
    VOID
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\debugexts\fusiondbgext.h ===
#pragma once

#include "sxstypes.h"

#define DUMPACTCTX_HEADER           (0x00000001)
#define DUMPACTCTX_DATA             (0x00000002)
#define DUMPACTCTXDATA_FLAG_FULL    (0x00010000)
#define NUMBER_OF(x) ( (sizeof(x) / sizeof(*x) ) )

typedef struct PRIVATE_ACTIVATION_CONTEXT {
    LONG RefCount;
    ULONG Flags;
    ULONG64 ActivationContextData; // _ACTIVATION_CONTEXT_DATA
    ULONG64 NotificationRoutine; // PACTIVATION_CONTEXT_NOTIFY_ROUTINE
    ULONG64 NotificationContext;
    ULONG SentNotifications[8];
    ULONG DisabledNotifications[8];
    ULONG64 StorageMap; // ASSEMBLY_STORAGE_MAP
    PVOID InlineStorageMapEntries[32]; // PASSEMBLY_STORAGE_MAP_ENTRY
} PRIVATE_ACTIVATION_CONTEXT;

// then the unicode string struct is probably not defined either
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;


BOOL
DumpActivationContextStackFrame(
	PCSTR pcsLineHeader,
    ULONG64 ulStackFrameAddress,
    ULONG ulDepth,
    DWORD dwFlags
    );

BOOL
DumpActCtxData(
    PCSTR LineHeader,
    const ULONG64 ActCtxDataAddressInDebugeeSpace,
    ULONG ulFlags
    );

BOOL
DumpActCtx(
    const ULONG64 ActCtxAddressInDebugeeSpace,
    ULONG   ulFlags
    );

BOOL
GetActiveActivationContextData(
    PULONG64 pulActiveActCtx
    );

BOOL
DumpActCtxStackFullStack(
    ULONG64 ulFirstStackFramePointer
    );

VOID
DbgExtPrintActivationContextData(
    BOOL fFull,
    PCACTIVATION_CONTEXT_DATA Data,
    PCWSTR rbuffPLP
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\debugexts\dumputils.cpp ===
#include "windows.h"
#include "sxstypes.h"
#define KDEXT_64BIT
#include "wdbgexts.h"
#include "fusiondbgext.h"

#define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_RELEASE_ON_DEACTIVATION     (0x00000001)
#define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NO_DEACTIVATE               (0x00000002)
#define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST                (0x00000004)
#define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED              (0x00000008)

BOOL
DumpActivationContextStackFrame(
    PCSTR pcsLineHeader,
    ULONG64 ulStackFrameAddress,
    ULONG ulDepth,
    DWORD dwFlags
    )
{

    ULONG64 ulPreviousPtr = 0;
    ULONG64 ulActivationContextPointer = 0;
    ULONG ulFrameFlags = 0;

    if (!pcsLineHeader) pcsLineHeader = "";

    GetFieldValue(ulStackFrameAddress, "nt!_RTL_ACTIVATION_CONTEXT_STACK_FRAME", "Previous", ulPreviousPtr);
    GetFieldValue(ulStackFrameAddress, "nt!_RTL_ACTIVATION_CONTEXT_STACK_FRAME", "ActivationContext", ulActivationContextPointer);
    GetFieldValue(ulStackFrameAddress, "nt!_RTL_ACTIVATION_CONTEXT_STACK_FRAME", "Flags", ulFrameFlags);

    dprintf(
        "%sActivation stack frame @ 0x%p (depth %ld):\n"
        "%s   Previous            : 0x%p\n"
        "%s   ActivationContext   : 0x%p\n"
        "%s   Flags               : 0x%08lx ",
        pcsLineHeader, ulStackFrameAddress, ulDepth,
        pcsLineHeader, ulPreviousPtr,
        pcsLineHeader, ulActivationContextPointer,
        pcsLineHeader, ulFrameFlags);

    if (ulFrameFlags != 0)
    {
        dprintf("(");
        if (ulFrameFlags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_RELEASE_ON_DEACTIVATION)
            dprintf("ReleaseOnDeactivate ");

        if (ulFrameFlags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NO_DEACTIVATE)
            dprintf("NoDeactivate ");

        if (ulFrameFlags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST)
            dprintf("OnFreeList");


        if (ulFrameFlags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED)
            dprintf("HeapAllocated ");

        dprintf(")");
    }
    dprintf ("\n");

    return 0;

}


BOOL
DumpActCtxStackFullStack(
    ULONG64 ulFirstStackFramePointer
    )
{
    ULONG ulDepth = 0;
    ULONG64 ulStackFramePtr = ulFirstStackFramePointer;

    while (ulStackFramePtr)
    {
        DumpActivationContextStackFrame("   ", ulStackFramePtr, ulDepth++, 0xffff);
        GetFieldValue(ulStackFramePtr, "nt!_RTL_ACTIVATION_CONTEXT_STACK_FRAME", "Previous", ulStackFramePtr);
        if (CheckControlC() || (ulStackFramePtr == 0))
            break;
    }

    return TRUE;
}



BOOL
DumpActCtxData(
    PCSTR LineHeader,
    const ULONG64 ActCtxDataAddressInDebugeeSpace,
    ULONG ulFlags
    )
{
    //
    // ACTIVATION_CONTEXT_DATA is a self-referential type, so dumping it is
    // easy once it's all in memory.
    //
    ACTIVATION_CONTEXT_DATA ActData;
    BYTE *pbActualData = NULL;
    BOOL fOk = FALSE;
    ULONG cbRead = 0;

    if (!LineHeader) LineHeader = "";

    if (!ReadMemory(ActCtxDataAddressInDebugeeSpace, &ActData, sizeof(ActData), &cbRead) ||
        (cbRead != sizeof(ActData)))
    {
        dprintf(
            "%sFailed reading ACTIVATION_CONTEXT_DATA @ %p , or wrong kind of block is there.\n",
            LineHeader,
            ActCtxDataAddressInDebugeeSpace);
        goto Exit;
    }

    //
    // Let's create a blob of memory that can hold the whole thing, then
    //
    pbActualData = new BYTE[ActData.TotalSize];
    if (!pbActualData)
    {
        dprintf(
            "%sUnable to allocate %d bytes to store activation context data\n",
            LineHeader,
            ActData.TotalSize);
        goto Exit;
    }

    //
    // And re-read from the debugee
    //
    if (!ReadMemory(ActCtxDataAddressInDebugeeSpace, pbActualData, ActData.TotalSize, &cbRead) ||
        (cbRead != ActData.TotalSize))
    {
        dprintf(
            "%sUnable to read in %d bytes from %p as an activation context object?\n",
            LineHeader,
            ActData.TotalSize,
            ActCtxDataAddressInDebugeeSpace);
        goto Exit;
    }

    DbgExtPrintActivationContextData( 
        (ulFlags & DUMPACTCTXDATA_FLAG_FULL) == DUMPACTCTXDATA_FLAG_FULL,
        (PCACTIVATION_CONTEXT_DATA)pbActualData,
        L"   "
        );

    fOk = TRUE;
Exit:
    if (pbActualData)
        delete[] pbActualData;

    return fOk;

}




BOOL
DumpActCtx(
    const ULONG64 ActCtxAddressInDebugeeSpace,
    ULONG   ulFlags
    )
{
    ULONG64 ActCtxAddr = ActCtxAddressInDebugeeSpace;
    ULONG64 ulSymbolOffset = 0;
    PRIVATE_ACTIVATION_CONTEXT prvContextFilled = { 0 };
    CHAR NotificationSymbol[1024] = { 0 };
    BOOL fOk = FALSE;
    int i = 0;

#define GET_FIELD(a, fn, dst) { GetFieldData((a), "nt!_ACTIVATION_CONTEXT", #fn, sizeof((dst).##fn), (PVOID)&((dst).##fn)); }
    GET_FIELD(ActCtxAddr, Flags, prvContextFilled);
    GET_FIELD(ActCtxAddr, RefCount, prvContextFilled);
    GET_FIELD(ActCtxAddr, ActivationContextData, prvContextFilled);
    GET_FIELD(ActCtxAddr, NotificationRoutine, prvContextFilled);
    GET_FIELD(ActCtxAddr, NotificationContext, prvContextFilled);
    // GET_FIELD(ActCtxAddr, SentNotifications, prvContextFilled);
    // GET_FIELD(ActCtxAddr, DisabledNotifications, prvContextFilled);
    // GET_FIELD(ActCtxAddr, StorageMap, prvContextFilled);
    // GET_FIELD(ActCtxAddr, InlineStorageMapEntries, prvContextFilled);
#undef GET_FIELD


    dprintf(
        "Activation context structure @ 0x%p\n"
        "   RefCount                 %d\n"
        "   Flags                    0x%08x\n"
        "   ActivationContextData    0x%p\n",
        ActCtxAddressInDebugeeSpace,
        (LONG)prvContextFilled.RefCount,
        (ULONG)prvContextFilled.Flags,
        (PVOID)prvContextFilled.ActivationContextData);

    if (ulFlags & DUMPACTCTX_DATA)
    {
//        if (!DumpActCtxData("   ", (ULONG64)prvContextFilled.ActivationContextData, ulFlags))
//            goto Exit;
        DumpActCtxData("   ", (ULONG64)prvContextFilled.ActivationContextData, ulFlags);
    }

    //
    // This icky gunk is to print out a symbol name properly...
    //
    dprintf("   NotificationRoutine      0x%p ", prvContextFilled.NotificationRoutine);
    GetSymbol((ULONG64)prvContextFilled.NotificationRoutine, NotificationSymbol, &ulSymbolOffset);
    if (strlen(NotificationSymbol))
    {
        dprintf("(%s" , NotificationSymbol);
        if (ulSymbolOffset)
            dprintf("+0x%p", ulSymbolOffset);
        dprintf(")");
    }
    dprintf("\n");


    dprintf("   NotificationContext      0x%p\n", prvContextFilled.NotificationContext);

    dprintf("   SentNotifications        [");
    for (i = 0; i < NUMBER_OF(prvContextFilled.SentNotifications); i++)
    {
        if (i) dprintf(" ");
        dprintf("%d", prvContextFilled.SentNotifications[i]);
    }
    dprintf("]\n");

    dprintf("   DisabledNotifications    [");
    for (i = 0; i < NUMBER_OF(prvContextFilled.DisabledNotifications); i++)
    {
        if (i) dprintf(" ");
        dprintf("%d", prvContextFilled.DisabledNotifications[i]);
    }
    dprintf("]\n");

    {
        ULONG ulFlags, ulCount;
        ULONG64 ulMapAddress;

        GetFieldValue(ActCtxAddressInDebugeeSpace, "_ACTIVATION_CONTEXT", "StorageMap.Flags", ulFlags);
        GetFieldValue(ActCtxAddressInDebugeeSpace, "_ACTIVATION_CONTEXT", "StorageMap.AssemblyCount", ulCount);
        GetFieldValue(ActCtxAddressInDebugeeSpace, "_ACTIVATION_CONTEXT", "StorageMap.AssemblyArray", ulMapAddress);
        dprintf(
            "   StorageMap (Flags = 0x%08lx Count = %d MapArray = %p)\n",
            ulFlags,
            ulCount,
            ulMapAddress);
    }

    fOk = TRUE;

    return fOk;
}


BOOL
GetActiveActivationContextData(
    PULONG64 pulActiveActCtx
    )
{
    ULONG64 ulTebAddress = 0, ulPebAddress = 0;
    ULONG64 ulTebActiveFrameAddress = 0;
    //
    // The algorithm is like this:
    // - Look at Teb.ActivationContextStack.ActiveFrame.ActivationContext.  If this is
    //   nonzero, stop looking.
    // - Now look at the process default activation context in Peb.ActivationContextData.
    //   If this is nonzero, stop looking.
    // - Look at the system default act ctx data, in Peb.SystemDefaultActivationContextData
    //   If this is nonzero, stop looking.
    // - Didn't find any active activation context data? Fooey.
    //

    *pulActiveActCtx = 0;

    GetTebAddress(&ulTebAddress);
    GetPebAddress(0, &ulPebAddress);

    if (ulTebAddress != NULL)
    {
        // Look at the active stack frame in the teb
        GetFieldValue(ulTebAddress, "nt!TEB", "ActivationContextStack.ActiveFrame", ulTebActiveFrameAddress);
        if (ulTebActiveFrameAddress)
        {
            ULONG64 ulActivationContextFrame;

            // Get the pointer to the active activation context itself
            GetFieldValue(
                ulTebActiveFrameAddress,
                "nt!_RTL_ACTIVATION_CONTEXT_STACK_FRAME",
                "ActivationContext",
                ulActivationContextFrame);
            // If that was valid, then ask for the pointer to the activation context data
            if (ulActivationContextFrame)
            {
                GetFieldValue(
                    ulActivationContextFrame,
                    "nt!ACTIVATION_CONTEXT",
                    "ActivationContextData",
                    *pulActiveActCtx);
                return TRUE;
            }
            // Is this really requesting the process default?
            else if (ulActivationContextFrame == NULL)
            {
                // Then get it and return
                GetFieldValue(ulPebAddress, "nt!PEB", "ActivationContextData", *pulActiveActCtx);
                return TRUE;
            }
        }
    }

    //
    // Still nothing, so go look at the process default directly
    //
    GetFieldValue(ulPebAddress, "nt!PEB", "ActivationContextData", *pulActiveActCtx);
    if (*pulActiveActCtx)
    {
        return TRUE;
    }

    //
    // Otherwise...
    //
    GetFieldValue(ulPebAddress, "nt!PEB", "SystemDefaultActivationContextData", *pulActiveActCtx);
    return (*pulActiveActCtx ? TRUE : FALSE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\debugexts\dumpers.cpp ===
#include "initguid.h"
#include "windows.h"
#include "sxstypes.h"
#define KDEXT_64BIT
#include "wdbgexts.h"
#include "fusiondbgext.h"
#include "sxsapi.h"
#include "stdlib.h"
#include "stdio.h"
#include "cguid.h"

extern const IID GUID_NULL = { 0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
#define PRINTABLE(_ch) (isprint((_ch)) ? (_ch) : '.')

class CSimpleBaseString
{
protected:
    PWSTR m_pwszBuffer;
    ULONG m_ulBufferSize;
    ULONG m_ulCch;

    CSimpleBaseString( PWSTR buff, ULONG ulBaseCch )
        : m_pwszBuffer(buff), m_ulBufferSize(ulBaseCch), m_ulCch(0)
    {
        m_pwszBuffer[0] = UNICODE_NULL;
    }

 public:

    virtual ~CSimpleBaseString() { };
    virtual void EnsureSize( ULONG ulCch ) = 0;

    void AssignFill( WCHAR ch, ULONG ulCch )
    {
        EnsureSize( ulCch + 1);
        PWSTR pws = m_pwszBuffer;
        while ( ulCch-- )
            *pws++ = ch;
        *pws = UNICODE_NULL;
    }

    void Format( PCWSTR pcwszFormat, ... )
    {
        va_list val;
        va_start(val, pcwszFormat);
        FormatVa(pcwszFormat, val);
        va_end(val);
    }

    void FormatVa( PCWSTR pcwszFormat, va_list val )
    {
        ULONG ulCch = _vscwprintf(pcwszFormat, val);
        EnsureSize(ulCch+1);
        m_ulCch = _vsnwprintf(this->m_pwszBuffer, m_ulBufferSize, pcwszFormat, val);
        m_pwszBuffer[ulCch] = UNICODE_NULL;
    }

    void Clear()
    {
        m_pwszBuffer[0] = UNICODE_NULL;
        m_ulCch = 0;
    }

    void Left( ULONG ulCch )
    {
        if ( ulCch < m_ulCch )
        {
            m_pwszBuffer[ulCch] = UNICODE_NULL;
            m_ulCch = ulCch;
        }
    }

    operator const PWSTR() const { return m_pwszBuffer; }
    operator PWSTR() { return m_pwszBuffer; }

    void Append(PUNICODE_STRING pus) { Append(pus->Buffer, pus->Length / sizeof(WCHAR)); }
    void Append( PCWSTR pcwsz ) { Append( pcwsz, ::wcslen(pcwsz) ); }
    void Append( PCWSTR pcwsz, ULONG ulCch ) {
        EnsureSize( ulCch + Cch() + 1);
        wcsncat(m_pwszBuffer, pcwsz, ulCch);
        m_pwszBuffer[m_ulCch += ulCch] = UNICODE_NULL;
    }

    void Assign(PCWSTR pcwsz) { Assign( pcwsz, ::wcslen(pcwsz) ); }
    void Assign(PCWSTR pcwsz, ULONG ulCch) {
        EnsureSize(ulCch + 1);
        wcsncpy(m_pwszBuffer, pcwsz, ulCch);
        m_pwszBuffer[m_ulCch = ulCch] = UNICODE_NULL;
    }

    ULONG Cch() { return m_ulCch; }    
};

template<int nChars = 256>
class CSimpleInlineString : public CSimpleBaseString
{
protected:
    WCHAR m_wchInlineBuffer[nChars];

    CSimpleInlineString( const CSimpleInlineString& );
    CSimpleInlineString& operator=( const CSimpleInlineString& );
    
public:
    CSimpleInlineString() : CSimpleBaseString(m_wchInlineBuffer, nChars) {
    }
    
    ~CSimpleInlineString()
    {
        Clear();
    }

    void EnsureSize(ULONG ulCch)
    {
        if ( m_ulBufferSize < ulCch )
        {
            PWSTR pwszNew = new WCHAR[ulCch];
            wcscpy(pwszNew, m_pwszBuffer);
            if ( m_pwszBuffer != m_wchInlineBuffer )
                delete[] m_pwszBuffer;
            m_pwszBuffer = pwszNew;
            m_ulBufferSize = ulCch;
        }
    }

};

typedef CSimpleInlineString<256> CSimpleString;
typedef CSimpleInlineString<64> CSmallSimpleString;

class CStringPrefixer
{
    CSimpleBaseString &m_str;
    ULONG m_ulStartingCch;
    ULONG m_adds;
    
public:
    CStringPrefixer( CSimpleBaseString &src ) : m_str(src), m_adds(0) {
        m_ulStartingCch = m_str.Cch();
    }
    ~CStringPrefixer() { m_str.Left(m_ulStartingCch); };

    void Add() { m_str.Append(L"   ", 3); m_adds++; }
    void Remove() { if ( m_adds > 0 ) { m_str.Left(m_str.Cch() - 3); m_adds--; } }
};

VOID
FormatThreadingModel( ULONG ulModel, CSimpleBaseString& buff )
{
    #define STRING_AND_LENGTH(x) (x), (NUMBER_OF(x) - 1)
    
    const static struct
    {
        ULONG ThreadingModel;
        WCHAR String[10];
        ULONG Cch;
    } gs_rgTMMap[] =
    {
        { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_APARTMENT, STRING_AND_LENGTH(L"Apartment") },
        { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_FREE, STRING_AND_LENGTH(L"Free") },
        { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_SINGLE, STRING_AND_LENGTH(L"Single") },
        { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_BOTH, STRING_AND_LENGTH(L"Both") },
        { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_NEUTRAL, STRING_AND_LENGTH(L"Neutral") },
    };

    SIZE_T c;
    for ( c = 0; c < NUMBER_OF(gs_rgTMMap); c++ )
    {
        if ( gs_rgTMMap[c].ThreadingModel == ulModel )
            buff.Assign(gs_rgTMMap[c].String, gs_rgTMMap[c].Cch);
    }

    if ( c == NUMBER_OF(gs_rgTMMap) ) buff.Assign(L"");
    
}

VOID
FormatGUID( const GUID& rcGuid, CSimpleBaseString& buff )
{
    buff.Format(
        L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
        rcGuid.Data1, 
        rcGuid.Data2, 
        rcGuid.Data3, 
        rcGuid.Data4[0], 
        rcGuid.Data4[1], 
        rcGuid.Data4[2], 
        rcGuid.Data4[3], 
        rcGuid.Data4[4], 
        rcGuid.Data4[5], 
        rcGuid.Data4[6], 
        rcGuid.Data4[7]);
}

VOID
FormatFileTime( LARGE_INTEGER ft, CSimpleBaseString& buff )
{
}

VOID
PrintBlob( PVOID pvBlob, SIZE_T cbBlob, PCWSTR prefix )
{
    CSimpleString buffTotal, buffSingle;
    DWORD Offset = 0;
    PBYTE pbBlob = (PBYTE)pvBlob;

    while ( cbBlob >= 16 )
    {
        buffSingle.Format(
            L"%ls%08lx: %02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x "
            L"(%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c)\n",
            prefix,
            Offset,
            pbBlob[0], pbBlob[1], pbBlob[2], pbBlob[3], pbBlob[4], pbBlob[5], pbBlob[6], pbBlob[7], 
            pbBlob[8], pbBlob[9], pbBlob[0xa], pbBlob[0xb], pbBlob[0xc], pbBlob[0xd], pbBlob[0xe], pbBlob[0xf],
            PRINTABLE(pbBlob[0]), PRINTABLE(pbBlob[1]), PRINTABLE(pbBlob[2]), PRINTABLE(pbBlob[3]), PRINTABLE(pbBlob[4]), PRINTABLE(pbBlob[5]), PRINTABLE(pbBlob[6]), PRINTABLE(pbBlob[7]), 
            PRINTABLE(pbBlob[8]), PRINTABLE(pbBlob[9]), PRINTABLE(pbBlob[0xa]), PRINTABLE(pbBlob[0xb]), PRINTABLE(pbBlob[0xc]), PRINTABLE(pbBlob[0xd]), PRINTABLE(pbBlob[0xe]), PRINTABLE(pbBlob[0xf]));
        buffTotal.Append(buffSingle);
        pbBlob += 16;
        cbBlob -= 16;
        Offset += 16;
    }

    if ( cbBlob != 0 )
    {
        CSmallSimpleString left, right;
        WCHAR rgTemp2[16]; // arbitrary big enough size
        bool First = true;
        ULONG i;
        BYTE *pb = pbBlob;

        // init output buffers
        left.Format(L"%ls%08lx:", prefix, Offset);
        right.Assign(L" (",2);

        for (i=0; i<16; i++)
        {
            if (cbBlob > 0)
            {
                // left
                ::_snwprintf(rgTemp2, NUMBER_OF(rgTemp2), L"%ls%02x", First ? L" " : L"-", pb[i]);
                First = false;
                left.Append(rgTemp2);

                // right
                ::_snwprintf(rgTemp2, NUMBER_OF(rgTemp2), L"%c", PRINTABLE(pb[i]));
                right.Append(rgTemp2);

                cbBlob--;
            }
            else
            {
                left.Append(L"   ", 3);
            }
        }

        right.Append(L")\n");
        buffTotal.Append(left, left.Cch());
        buffTotal.Append(right, right.Cch());
    }

    dprintf("%ls", static_cast<PCWSTR>(buffTotal));
    
}

void
OutputString( PCWSTR pcwszFormat, ... )
{
    va_list val;
    CSimpleString ssFormatted;

    va_start(val, pcwszFormat);
    ssFormatted.FormatVa(pcwszFormat, val);
    dprintf("%ls", static_cast<PCWSTR>(ssFormatted));
    va_end(val);
}

#define PRINTABLE(_ch) (isprint((_ch)) ? (_ch) : '.')

#if defined(FUSION_WIN) || defined(FUSION_WIN2000)
#define wnsprintfW _snwprintf
#define wnsprintfA _snprintf
#endif

typedef struct _FUSION_FLAG_FORMAT_MAP_ENTRY
{
    DWORD m_dwFlagMask;
    PCWSTR m_pszString;
    ULONG m_cchString;
    PCWSTR m_pszShortString;
    ULONG m_cchShortString;
    DWORD m_dwFlagsToTurnOff; // enables more generic flags first in map hiding more specific combinations later
} FUSION_FLAG_FORMAT_MAP_ENTRY, *PFUSION_FLAG_FORMAT_MAP_ENTRY;
typedef struct _FUSION_FLAG_FORMAT_MAP_ENTRY FUSION_FLAG_FORMAT_MAP_ENTRY, *PFUSION_FLAG_FORMAT_MAP_ENTRY;
typedef const FUSION_FLAG_FORMAT_MAP_ENTRY *PCFUSION_FLAG_FORMAT_MAP_ENTRY;


#define DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(_x, _ss) { _x, L ## #_x, NUMBER_OF(L ## #_x) - 1, L ## _ss, NUMBER_OF(_ss) - 1, _x },


BOOL
FusionpFormatFlags(
    DWORD dwFlagsToFormat,
    bool fUseLongNames,
    SIZE_T cMapEntries,
    PCFUSION_FLAG_FORMAT_MAP_ENTRY prgMapEntries,
    CSimpleBaseString &pwszString
    )
{
    SIZE_T i;
    BOOL fSuccess = FALSE;

    pwszString.Clear();
    
    for (i=0; i<cMapEntries; i++)
    {
        // What the heck does a flag mask of 0 mean?
        if ((prgMapEntries[i].m_dwFlagMask != 0) &&
            ((dwFlagsToFormat & prgMapEntries[i].m_dwFlagMask) == prgMapEntries[i].m_dwFlagMask))
        {
            // we have a winner...
            if ( pwszString.Cch() )
            {
                if (fUseLongNames) {
                    pwszString.Append(L" | ", 3);
                } else {
                    pwszString.Append(L", ", 2);
                }
            }

            if (fUseLongNames) {
                pwszString.Append(prgMapEntries[i].m_pszString, prgMapEntries[i].m_cchString);
            } else {
                pwszString.Append(prgMapEntries[i].m_pszShortString, prgMapEntries[i].m_cchShortString);
            }

            if (prgMapEntries[i].m_dwFlagsToTurnOff != 0)
                dwFlagsToFormat &= ~(prgMapEntries[i].m_dwFlagsToTurnOff);
            else
                dwFlagsToFormat &= ~(prgMapEntries[i].m_dwFlagMask);
        }
    }

    if (dwFlagsToFormat != 0)
    {
        WCHAR rgwchHexBuffer[16];
        ULONG nCharsWritten = wnsprintfW(rgwchHexBuffer, NUMBER_OF(rgwchHexBuffer), L"0x%08lx", dwFlagsToFormat);

        if ( pwszString.Cch() == 0 ) pwszString.Append(L", ", 2);
        pwszString.Append(rgwchHexBuffer, nCharsWritten);
    }

    // if we didn't write anything; at least say that.
    if ( pwszString.Cch() == 0 )
    {
        pwszString.Assign(L"<none>", 6);
    }

    fSuccess = TRUE;
    return fSuccess;
}

/*
Declaration of dumpers are moved from the relatively public sxsp.h
to here to contain their use.

These functions should be preceded by FusionpDbgWouldPrintAtFilterLevel calls
and surrounded by __try/__except(EXCEPTION_EXECUTE_HANDLER)

These function can consume a lot of stack, and time, when their output
ultimately doesn't go anywhere, and they overflow the small commited stack
in csrss under stress.
*/

VOID
DbgExtPrintActivationContextDataTocEntry(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_ENTRY Entry,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextDataTocSections(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Data,
    const GUID *ExtensionGuid,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextDataTocSection(
    bool fFull,
    PVOID Section,
    SIZE_T Length,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextDataExtendedTocHeader(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER Data,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextDataExtendedTocEntry(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextDataExtendedTocSections(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER Data,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintClrSurrogateTable(
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    );



VOID
DbgExtPrintActivationContextDataExtendedTocEntrySections(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Data,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextStringSection(
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Data,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextGuidSection(
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Data,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextBinarySection(
    bool fFull,
    PVOID Data,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintAssemblyInformation(
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    );

VOID
DbgExtPrintDllRedirection(
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    );

VOID
DbgExtPrintWindowClassRedirection(
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    );

VOID
DbgExtPrintComServerRedirection(
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    );

VOID
DbgExtPrintComProgIdRedirection(
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    );

VOID
DbgExtPrintComInterfaceRedirection(
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    );

VOID
DbgExtPrintActivationContextDataAssemblyRoster(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER Data,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextDataTocHeader(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Data,
    CSimpleBaseString &rbuffPLP
    );

VOID
pDbgPrintActivationContextData(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Data,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CStringPrefixer Prefixer(rbuffPLP);

    if (fFull)
    {
        CSmallSimpleString ssOutput;

        ssOutput.Format(
            L"%lsActivation Context Data %p\n"
            L"%ls   Magic = 0x%08lx (%lu)\n"
            L"%ls   HeaderSize = %d (0x%lx)\n"
            L"%ls   FormatVersion = %d\n",
            PLP, Data,
            PLP, Data->Magic, Data->Magic,
            PLP, Data->HeaderSize, Data->HeaderSize,
            PLP, Data->FormatVersion);
        OutputString(L"%ls", static_cast<PCWSTR>(ssOutput));

        ssOutput.Format(
            L"%ls   TotalSize = %d (0x%lx)\n"
            L"%ls   DefaultTocOffset = %d (0x%lx) (-> %p)\n"
            L"%ls   ExtendedTocOffset = %d (0x%lx) (-> %p)\n",
            PLP, Data->TotalSize, Data->TotalSize,
            PLP, Data->DefaultTocOffset, Data->DefaultTocOffset, (Data->DefaultTocOffset == 0) ? NULL : (PVOID) (((ULONG_PTR) Data) + Data->DefaultTocOffset),
            PLP, Data->ExtendedTocOffset, Data->ExtendedTocOffset, (Data->ExtendedTocOffset == 0) ? NULL : (PVOID) (((ULONG_PTR) Data) + Data->ExtendedTocOffset));
        OutputString(L"%ls", static_cast<PCWSTR>(ssOutput));

        ssOutput.Format(
            L"%ls   AssemblyRosterOffset = %d (0x%lx) (-> %p)\n",
            PLP, Data->AssemblyRosterOffset, Data->AssemblyRosterOffset, (Data->AssemblyRosterOffset == 0) ? NULL : (PVOID) (((ULONG_PTR) Data) + Data->AssemblyRosterOffset));
        OutputString(L"%ls", static_cast<PCWSTR>(ssOutput));
        
    }
    else
    {
        // !fFull
        OutputString(
            L"%lsActivation Context Data %p (brief output)\n",
            PLP, Data);
    }

    Prefixer.Add();

    if (Data->AssemblyRosterOffset != 0)
        ::DbgExtPrintActivationContextDataAssemblyRoster(
            
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) Data) + Data->AssemblyRosterOffset),
            rbuffPLP);

    if (Data->DefaultTocOffset != 0)
        ::DbgExtPrintActivationContextDataTocHeader(
            
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Data) + Data->DefaultTocOffset),
            rbuffPLP);

    if (Data->ExtendedTocOffset != 0)
        ::DbgExtPrintActivationContextDataExtendedTocHeader(
            
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER) (((ULONG_PTR) Data) + Data->ExtendedTocOffset),
            rbuffPLP);

    // That's it for the header information.  Now start dumping the sections...
    if (Data->DefaultTocOffset != 0)
        ::DbgExtPrintActivationContextDataTocSections(
            
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Data) + Data->DefaultTocOffset),
            NULL,
            rbuffPLP);

    if (Data->ExtendedTocOffset != 0)
        ::DbgExtPrintActivationContextDataExtendedTocSections(
            
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER) (((ULONG_PTR) Data) + Data->ExtendedTocOffset),
            rbuffPLP);
}

VOID
DbgExtPrintActivationContextData(
    BOOL fFull,
    PCACTIVATION_CONTEXT_DATA Data,
    PCWSTR rbuffPLP
    )
{
    CSimpleInlineString<256> rbuffPrefix;
    rbuffPrefix.Assign(rbuffPLP);
    pDbgPrintActivationContextData( !!fFull, Data, rbuffPrefix);
}

VOID
DbgExtPrintActivationContextDataAssemblyRoster(
    
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER Data,
    CSimpleBaseString &rbuffPLP
    )
{
    ULONG i;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY Entry;
    CSmallSimpleString buffFlags;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION AssemblyInformation = NULL;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgAssemblyRosterEntryFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID, "Invalid")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_ROOT, "Root")
    };

    PCWSTR PLP = rbuffPLP;

    if (fFull)
        OutputString(
            L"%lsACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER %p\n"
            L"%ls   HeaderSize = %lu (0x%lx)\n"
            L"%ls   EntryCount = %lu (0x%lx)\n"
            L"%ls   FirstEntryOffset = %ld (0x%lx)\n",
            PLP, Data,
            PLP, Data->HeaderSize, Data->HeaderSize,
            PLP, Data->EntryCount, Data->EntryCount,
            PLP, Data->FirstEntryOffset, Data->FirstEntryOffset);
    else
        OutputString(
            L"%lsAssembly Roster (%lu assemblies)\n"
            L"%lsIndex | Assembly Name (Flags)\n",
            PLP, Data->EntryCount - 1,
            PLP);

    for (i=0; i<Data->EntryCount; i++)
    {
        Entry = ((PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset)) + i;

        UNICODE_STRING s;

        if (Entry->AssemblyNameOffset != 0)
        {
            s.Length = (USHORT) Entry->AssemblyNameLength;
            s.MaximumLength = s.Length;
            s.Buffer = (PWSTR) (((ULONG_PTR) Base) + Entry->AssemblyNameOffset);
        }
        else
        {
            s.Length = 0;
            s.MaximumLength = 0;
            s.Buffer = NULL;
        }

        ::FusionpFormatFlags(Entry->Flags, fFull, NUMBER_OF(s_rgAssemblyRosterEntryFlags), s_rgAssemblyRosterEntryFlags, buffFlags);

        if (Entry->AssemblyInformationOffset != NULL)
            AssemblyInformation = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION) (((ULONG_PTR) Base) + Entry->AssemblyInformationOffset);
        else
            AssemblyInformation = NULL;

        if (fFull)
        {
            OutputString(
                L"%ls   ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY %p [#%d]\n"
                L"%ls      Flags = 0x%08lx (%ls)\n"
                L"%ls      PseudoKey = %lu\n",
                PLP, Entry, i,
                PLP, Entry->Flags, static_cast<PCWSTR>(buffFlags),
                PLP, Entry->PseudoKey);

            OutputString(
                L"%ls      AssemblyNameOffset = %lu (0x%lx) \"%wZ\"\n"
                L"%ls      AssemblyNameLength = %lu (0x%lx) \n"
                L"%ls      AssemblyInformationOffset = %lu (0x%lx) (-> %p)\n"
                L"%ls      AssemblyInformationLength = %lu (0x%lx)\n",
                PLP, Entry->AssemblyNameOffset, Entry->AssemblyNameOffset, &s,
                PLP, Entry->AssemblyNameLength, Entry->AssemblyNameLength,
                PLP, Entry->AssemblyInformationOffset, Entry->AssemblyInformationOffset, AssemblyInformation,
                PLP, Entry->AssemblyInformationLength, Entry->AssemblyInformationLength);
        }
        else
        {
            if (i != 0)
                OutputString(
                    L"%ls%5lu | %wZ (%ls)\n",
                    PLP, i, &s, static_cast<PCWSTR>(buffFlags));
        }
    }
}

VOID
DbgExtPrintActivationContextDataTocHeader(
    
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Data,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallSimpleString buffFlags;
    ULONG i;
    PCACTIVATION_CONTEXT_DATA_TOC_ENTRY FirstEntry = NULL;

    if (PLP == NULL)
        PLP = L"";

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_TOC_HEADER_DENSE, "Dense")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_TOC_HEADER_INORDER, "Inorder")
    };

    ::FusionpFormatFlags(Data->Flags, fFull, NUMBER_OF(s_rgFlags), s_rgFlags, buffFlags);

    if (Data->FirstEntryOffset != 0)
        FirstEntry = (PCACTIVATION_CONTEXT_DATA_TOC_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset);

    if (fFull)
    {
        OutputString(
            L"%lsACTIVATION_CONTEXT_DATA_TOC_HEADER %p\n"
            L"%ls   HeaderSize = %d (0x%lx)\n"
            L"%ls   EntryCount = %d\n"
            L"%ls   FirstEntryOffset = %d (0x%lx) (-> %p)\n"
            L"%ls   Flags = 0x%08lx (%ls)\n",
            PLP, Data,
            PLP, Data->HeaderSize, Data->HeaderSize,
            PLP, Data->EntryCount,
            PLP, Data->FirstEntryOffset, Data->FirstEntryOffset, FirstEntry,
            PLP, Data->Flags, static_cast<PCWSTR>(buffFlags));
    }

    if (FirstEntry != NULL)
    {
        CStringPrefixer prefixer(rbuffPLP);

        prefixer.Add();
        for (i=0; i<Data->EntryCount; i++)
            ::DbgExtPrintActivationContextDataTocEntry( fFull, Base, &FirstEntry[i], rbuffPLP);
    }

}

VOID
DbgExtPrintActivationContextDataTocSections(
    
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Data,
    const GUID *ExtensionGuid,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CStringPrefixer Prefixer(rbuffPLP);

    if (Data->FirstEntryOffset != 0)
    {
        PCACTIVATION_CONTEXT_DATA_TOC_ENTRY Entries = (PCACTIVATION_CONTEXT_DATA_TOC_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset);
        ULONG i;

        for (i=0; i<Data->EntryCount; i++)
        {
            if (Entries[i].Offset != 0)
            {
                PVOID Section = (PVOID) (((ULONG_PTR) Base) + Entries[i].Offset);
                CSmallSimpleString buffSectionId;
                PCSTR pszSectionName = "<untranslatable>";

                if (ExtensionGuid != NULL)
                {
                    WCHAR rgchBuff[sizeof(LONG)*8];

                    FormatGUID(*ExtensionGuid, buffSectionId);
                    buffSectionId.Append(L".", 1);
                    swprintf(rgchBuff, L"%u", Entries[i].Id);
                    buffSectionId.Append(rgchBuff, ::wcslen(rgchBuff));
                }
                else
                {
                    WCHAR rgchBuff[255];

#define MAP_ENTRY(_x, _y) case _x: if (fFull) pszSectionName = #_x; else pszSectionName = _y; break;

                    switch (Entries[i].Id)
                    {
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION, "Assembly Information")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "DLL Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "Window Class Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION, "COM Server Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION, "COM Interface Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION, "COM Type Library Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION, "COM ProgId Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE, "Win32 Global Object Name Redirection")
                    }

                    if (pszSectionName != NULL)
                        swprintf(rgchBuff, L"%u (%ls)", Entries[i].Id, pszSectionName);
                    else
                        swprintf(rgchBuff, L"%u", Entries[i].Id);

                    buffSectionId.Append(rgchBuff, ::wcslen(rgchBuff));
                }

                ::DbgExtPrintActivationContextDataTocSection(
                    fFull,
                    Section,
                    Entries[i].Length,
                    ExtensionGuid,
                    Entries[i].Id,
                    pszSectionName,
                    rbuffPLP);
            }
        }
    }
}

VOID
DbgExtPrintActivationContextDataTocSection(
    
    bool fFull,
    PVOID Section,
    SIZE_T Length,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CSimpleBaseString &rbuffPLP
    )
{
    if ((Length > sizeof(ULONG)) &&
        (*((ULONG *) Section) == ACTIVATION_CONTEXT_STRING_SECTION_MAGIC))
        ::DbgExtPrintActivationContextStringSection(
            
            fFull,
            (PCACTIVATION_CONTEXT_STRING_SECTION_HEADER) Section,
            ExtensionGuid,
            SectionId,
            SectionName,
            rbuffPLP);
    else if ((Length > sizeof(ULONG)) &&
             (*((ULONG *) Section) == ACTIVATION_CONTEXT_GUID_SECTION_MAGIC))
    {
        ::DbgExtPrintActivationContextGuidSection(
            
            fFull,
            (PCACTIVATION_CONTEXT_GUID_SECTION_HEADER) Section,
            ExtensionGuid,
            SectionId,
            SectionName,
            rbuffPLP);
    }
    else if ( SectionId != 0 )
    {
        ::DbgExtPrintActivationContextBinarySection(
            
            fFull,
            Section,
            Length,
            rbuffPLP);
    }
}

VOID
DbgExtPrintActivationContextDataTocEntry(
    
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_ENTRY Entry,
    CSimpleBaseString &rbuffPLP
    )
{
    PVOID SectionData = NULL;
    PCSTR pszFormat = "<untranslated format>";
    PCWSTR PLP = rbuffPLP;

    if (!fFull)
        return;

    if (PLP == NULL)
        PLP = L"";

    if (Entry->Offset != 0)
        SectionData = (PVOID) (((ULONG_PTR) Base) + Entry->Offset);

#define MAP_FORMAT(_x, _sn) \
case _x: \
    if (fFull) \
        pszFormat = #_x; \
    else \
        pszFormat = _sn; \
    break;

    switch (Entry->Format)
    {
    MAP_FORMAT(ACTIVATION_CONTEXT_SECTION_FORMAT_UNKNOWN, "user defined");
    MAP_FORMAT(ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE, "string table");
    MAP_FORMAT(ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE, "guid table");
    }

    if (fFull)
    {
        OutputString(
            L"%lsACTIVATION_CONTEXT_DATA_TOC_ENTRY %p\n"
            L"%ls   Id = %u\n"
            L"%ls   Offset = %lu (0x%lx) (-> %p)\n"
            L"%ls   Length = %lu (0x%lx)\n"
            L"%ls   Format = %lu (%s)\n",
            PLP, Entry,
            PLP, Entry->Id,
            PLP, Entry->Offset, Entry->Offset, SectionData,
            PLP, Entry->Length, Entry->Length,
            PLP, Entry->Format, pszFormat);
    }
    else
    {
        PCSTR pszName = "<No name associated with id>";

        switch (Entry->Id)
        {
        case ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION: pszName = "Assembly Information"; break;
        case ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION: pszName = "Dll Redirection"; break;
        case ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION: pszName = "Window Class Redirection"; break;
        case ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION: pszName = "COM Server Redirection"; break;
        case ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION: pszName = "COM Interface Redirection"; break;
        case ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION: pszName = "COM Type Library Redirection"; break;
        case ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION: pszName = "COM ProgId Redirection"; break;
        case ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE: pszName = "Win32 Global Object Name Redirection"; break;
        case ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES: pszName = "CLR Surrogate Redirection"; break;
        }

        OutputString(
            L"%ls%7lu | %s (%s)\n",
            PLP, Entry->Id, pszName, pszFormat);
    }

}

VOID
DbgExtPrintActivationContextDataExtendedTocHeader(
    
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER Data,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CStringPrefixer Prefixer(rbuffPLP);
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry = NULL;
    ULONG i;

    if (PLP == NULL)
        PLP = L"";

    if (Data->FirstEntryOffset != NULL)
    {
        Prefixer.Add();
        Entry = (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset);
    }

    PLP = rbuffPLP;
    OutputString(
        L"%lsACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER %p\n"
        L"%ls   HeaderSize = %d\n"
        L"%ls   EntryCount = %d\n"
        L"%ls   FirstEntryOffset = %d (->%p)\n"
        L"%ls   Flags = 0x%08lx\n",
        PLP, Data,
        PLP, Data->HeaderSize,
        PLP, Data->EntryCount,
        PLP, Data->FirstEntryOffset, Entry,
        PLP, Data->Flags);


    if (Entry != NULL)
    {
        for (i=0; i<Data->EntryCount; i++)
            ::DbgExtPrintActivationContextDataExtendedTocEntry(
                
                fFull,
                Base,
                &Entry[i],
                rbuffPLP);
    }
}

VOID
DbgExtPrintActivationContextDataExtendedTocEntry(
    
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CStringPrefixer Prefixer(rbuffPLP);
    CSmallSimpleString buffFormattedGUID;
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Toc = NULL;

    if (PLP == NULL)
        PLP = L"";

    if (Entry->TocOffset != 0)
    {
        Prefixer.Add();
        Toc = (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Base) + Entry->TocOffset);
        PLP = rbuffPLP;
    }

    FormatGUID(Entry->ExtensionGuid, buffFormattedGUID);

    OutputString(
        L"%lsACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY %p\n"
        L"%ls   ExtensionGuid = %ls\n"
        L"%ls   TocOffset = %d (-> %p)\n"
        L"%ls   Length = %d\n",
        PLP, Entry,
        PLP, static_cast<PCWSTR>(buffFormattedGUID),
        PLP, Entry->Length);

    if (Toc != NULL)
        ::DbgExtPrintActivationContextDataTocHeader( fFull, Base, Toc, rbuffPLP);
}

VOID
DbgExtPrintActivationContextDataExtendedTocSections(
    
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER Data,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CStringPrefixer prefixer(rbuffPLP);
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry = NULL;
    ULONG i;

    if (PLP == NULL)
        PLP = L"";

    if (Data->FirstEntryOffset != NULL)
    {
        prefixer.Add();
        Entry = (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset);
        PLP = rbuffPLP;
    }

    if (Entry != NULL)
    {
        for (i=0; i<Data->EntryCount; i++)
            ::DbgExtPrintActivationContextDataExtendedTocEntrySections(
                
                fFull,
                Base,
                &Entry[i],
                rbuffPLP);
    }
}

VOID
DbgExtPrintActivationContextDataExtendedTocEntrySections(
    
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CStringPrefixer Prefixer(rbuffPLP);
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Toc = NULL;

    if (PLP == NULL)
        PLP = L"";

    if (Entry->TocOffset != 0)
    {
        Prefixer.Add();
        PLP = rbuffPLP;
        Toc = (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Base) + Entry->TocOffset);
    }

    if (Toc != NULL)
    {
        CSmallSimpleString buffFormattedGUID;

        FormatGUID(Entry->ExtensionGuid, buffFormattedGUID);
        OutputString(
            L"%lsSections for extension GUID %ls (Extended TOC entry %p)\n",
            PLP, static_cast<PCWSTR>(buffFormattedGUID), Entry);

        ::DbgExtPrintActivationContextDataTocSections( fFull, Base, Toc, &Entry->ExtensionGuid, rbuffPLP);
    }
}

VOID
DbgExtPrintActivationContextBinarySection(
    bool fFull,
    PVOID Data,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CStringPrefixer Prefixer(rbuffPLP);

    if (PLP == NULL)
        PLP = L"";

    OutputString(
        L"%lsBinary section %p (%d bytes)\n",
        PLP, Data, Length);

    if (Length != 0)
    {
        Prefixer.Add();
        PrintBlob( Data, Length, rbuffPLP);
    }
}

VOID
DbgExtPrintActivationContextStringSection(
    
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Data,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CStringPrefixer Prefixer(rbuffPLP);
    CSmallSimpleString buffBriefOutput;
    CSmallSimpleString buffFlags;
    ULONG cchBriefOutputKey = 3;

    PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY ElementList = NULL;
    PCACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE SearchStructure = NULL;
    PVOID UserData = NULL;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgStringSectionFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_STRING_SECTION_CASE_INSENSITIVE, "Case Insensitive")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_STRING_SECTION_ENTRIES_IN_PSEUDOKEY_ORDER, "In PseudoKey Order")
    };

    if (PLP == NULL)
        PLP = L"";

    if (Data->ElementListOffset != 0)
        ElementList = (PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY) (((ULONG_PTR) Data) + Data->ElementListOffset);

    if (Data->SearchStructureOffset != 0)
        SearchStructure = (PCACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE) (((ULONG_PTR) Data) + Data->SearchStructureOffset);

    if (Data->UserDataOffset != 0)
        UserData = (PVOID) (((ULONG_PTR) Data) + Data->UserDataOffset);

    ::FusionpFormatFlags(Data->Flags, fFull, NUMBER_OF(s_rgStringSectionFlags), s_rgStringSectionFlags, buffFlags);

    if (fFull)
    {
        OutputString(
            L"%lsACTIVATION_CONTEXT_STRING_SECTION_HEADER %p\n"
            L"%ls   Magic = 0x%08lx\n"
            L"%ls   HeaderSize = %lu (0x%lx)\n"
            L"%ls   FormatVersion = %lu\n"
            L"%ls   DataFormatVersion = %u\n"
            L"%ls   Flags = 0x%08lx (%ls)\n",
            PLP, Data,
            PLP, Data->Magic,
            PLP, Data->HeaderSize, Data->HeaderSize,
            PLP, Data->FormatVersion,
            PLP, Data->DataFormatVersion,
            PLP, Data->Flags, static_cast<PCWSTR>(buffFlags));

        OutputString(
            L"%ls   ElementCount = %lu\n"
            L"%ls   ElementListOffset = %lu (0x%lx) (-> %p)\n"
            L"%ls   HashAlgorithm = %lu\n"
            L"%ls   SearchStructureOffset = %lu (0x%lx) (-> %p)\n"
            L"%ls   UserDataOffset = %lu (0x%lx) (-> %p)\n"
            L"%ls   UserDataSize = %lu (0x%lx)\n",
            PLP, Data->ElementCount,
            PLP, Data->ElementListOffset, Data->ElementListOffset, ElementList,
            PLP, Data->HashAlgorithm,
            PLP, Data->SearchStructureOffset, Data->SearchStructureOffset, SearchStructure,
            PLP, Data->UserDataOffset, Data->UserDataOffset, UserData,
            PLP, Data->UserDataSize, Data->UserDataSize);

        if (UserData != NULL)
        {
            OutputString(
                L"%ls   User data at %p (%d bytes)\n",
                PLP, UserData, Data->UserDataSize);
            Prefixer.Add();
            PLP = rbuffPLP;
            PrintBlob( UserData, Data->UserDataSize, rbuffPLP);
        }
    }
    else
    {
        // let's figure out the brief output key size
        cchBriefOutputKey = 3;

        if (ElementList != NULL)
        {
            ULONG i;

            for (i=0; i<Data->ElementCount; i++)
            {
                ULONG cch = ElementList[i].KeyLength / sizeof(WCHAR);

                if (cch > cchBriefOutputKey)
                    cchBriefOutputKey = cch;
            }
        }

        if (cchBriefOutputKey > 64)
            cchBriefOutputKey = 64;

        // Abuse the brief output buffer temporarily...
        buffBriefOutput.Assign(L"Key................................................................", // 64 dots
            cchBriefOutputKey);

        OutputString(
            L"%ls%s string section (%lu entr%s; Flags: %ls)\n"
            L"%ls   %ls | Value\n",
            PLP, SectionName, Data->ElementCount, Data->ElementCount == 1 ? "y" : "ies", static_cast<PCWSTR>(buffFlags),
            PLP, static_cast<PCWSTR>(buffBriefOutput));
    }

    if (fFull && (SearchStructure != NULL))
    {
        PCACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET BucketTable = NULL;

        if (SearchStructure->BucketTableOffset != 0)
            BucketTable = (PCACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET) (((ULONG_PTR) Data) + SearchStructure->BucketTableOffset);

        OutputString(
            L"%ls   ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE %p\n"
            L"%ls      BucketTableEntryCount = %u\n"
            L"%ls      BucketTableOffset = %d (-> %p)\n",
            PLP, SearchStructure,
            PLP, SearchStructure->BucketTableEntryCount,
            PLP, SearchStructure->BucketTableOffset, BucketTable);

        if (BucketTable != NULL)
        {
            ULONG i;

            for (i=0; i<SearchStructure->BucketTableEntryCount; i++)
            {
                PLONG Entries = NULL;

                if (BucketTable[i].ChainOffset != 0)
                    Entries = (PLONG) (((ULONG_PTR) Data) + BucketTable[i].ChainOffset);

                OutputString(
                    
                    L"%ls      ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET %p\n"
                    L"%ls         ChainCount = %u\n"
                    L"%ls         ChainOffset = %d (-> %p)\n",
                    PLP, &BucketTable[i],
                    PLP, BucketTable[i].ChainCount,
                    PLP, BucketTable[i].ChainOffset, Entries);

                if (Entries != NULL)
                {
                    ULONG j;

                    for (j=0; j<BucketTable[i].ChainCount; j++)
                    {
                        PVOID Entry = NULL;

                        if (Entries[j] != 0)
                            Entry = (PVOID) (((ULONG_PTR) Data) + Entries[j]);

                        OutputString(
                            
                            L"%ls         Chain[%d] = %d (-> %p)\n",
                            PLP, j, Entries[j], Entry);
                    }
                }
            }
        }
    }

    if (ElementList != NULL)
    {
        ULONG i;

        for (i=0; i<Data->ElementCount; i++)
        {
            UNICODE_STRING s;
            PVOID EntryData = NULL;

            s.Length = static_cast<USHORT>(ElementList[i].KeyLength);
            s.MaximumLength = s.Length;
            s.Buffer = (PWSTR) (((ULONG_PTR) Data) + ElementList[i].KeyOffset);

            if (ElementList[i].Offset != 0)
                EntryData = (PVOID) (((ULONG_PTR) Data) + ElementList[i].Offset);

            if (fFull)
            {
                OutputString(
                    
                    L"%ls   ACTIVATION_CONTEXT_STRING_SECTION_ENTRY #%d - %p\n"
                    L"%ls      AssemblyRosterIndex = %u\n"
                    L"%ls      PseudoKey = %u\n",
                    PLP, i, &ElementList[i],
                    PLP, ElementList[i].AssemblyRosterIndex,
                    PLP, ElementList[i].PseudoKey);

                OutputString(
                    
                    L"%ls      String = \"%wZ\"\n"
                    L"%ls      Offset = %d (-> %p)\n"
                    L"%ls      Length = %u\n",
                    PLP, &s,
                    PLP, ElementList[i].Offset, EntryData,
                    PLP, ElementList[i].Length);
            }
            else
            {
                // Abuse the flags buffer so we can truncate the name as necessary...
                ULONG cchKey = s.Length / sizeof(WCHAR);
                PCWSTR pszKey = s.Buffer;

                if (cchKey > cchBriefOutputKey)
                {
                    pszKey += (cchKey - cchBriefOutputKey);
                    cchKey = cchBriefOutputKey;
                }

                buffFlags.AssignFill(L' ', (cchBriefOutputKey - cchKey));
                buffFlags.Append(pszKey, cchKey);

                buffBriefOutput.EnsureSize(rbuffPLP.Cch() + 3 + cchBriefOutputKey + 4);

                buffBriefOutput.Format(
                    L"%s   %s | ",
                    PLP, static_cast<PCWSTR>(buffFlags));
            }

            if (EntryData != NULL)
            {

                if (ExtensionGuid == NULL)
                {
                    CStringPrefixer Prefixer(rbuffPLP);
                    Prefixer.Add();
                    Prefixer.Add();

                    switch (SectionId)
                    {
                    default:
                        if (fFull)
                            PrintBlob( EntryData, ElementList[i].Length, rbuffPLP);
                        else
                            buffBriefOutput.Append(
                                L"<untranslatable value>",
                                22);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION:
                        ::DbgExtPrintAssemblyInformation( fFull, Data, (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION:
                        ::DbgExtPrintDllRedirection( fFull, Data, (PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION:
                        ::DbgExtPrintWindowClassRedirection( fFull, Data, (PCACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION:
                        ::DbgExtPrintComProgIdRedirection( fFull, Data, (PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    }

                }
            }

            if (!fFull)
                OutputString( L"%ls\n", static_cast<PCWSTR>(buffBriefOutput));
        }
    }
}

VOID
DbgExtPrintActivationContextGuidSection(
    
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Data,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    ULONG cchPLP = rbuffPLP.Cch();
    CSmallSimpleString buffFlags;
    CSmallSimpleString buffBriefOutput;

    PCACTIVATION_CONTEXT_GUID_SECTION_ENTRY ElementList = NULL;
    PCACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE SearchStructure = NULL;
    PVOID UserData = NULL;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgGuidSectionFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_GUID_SECTION_ENTRIES_IN_ORDER, "Inorder")
    };

    if (PLP == NULL)
        PLP = L"";

    if (Data->ElementListOffset != 0)
        ElementList = (PCACTIVATION_CONTEXT_GUID_SECTION_ENTRY) (((ULONG_PTR) Data) + Data->ElementListOffset);

    if (Data->SearchStructureOffset != 0)
        SearchStructure = (PCACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE) (((ULONG_PTR) Data) + Data->SearchStructureOffset);

    if (Data->UserDataOffset != 0)
        UserData = (PVOID) (((ULONG_PTR) Data) + Data->UserDataOffset);

    ::FusionpFormatFlags(Data->Flags, fFull, NUMBER_OF(s_rgGuidSectionFlags), s_rgGuidSectionFlags, buffFlags);

    if (fFull)
    {
        OutputString(
            
            L"%lsACTIVATION_CONTEXT_GUID_SECTION_HEADER %p\n"
            L"%ls   Magic = 0x%08lx\n"
            L"%ls   HeaderSize = %u\n"
            L"%ls   FormatVersion = %u\n"
            L"%ls   DataFormatVersion = %u\n"
            L"%ls   Flags = 0x%08lx (%ls)\n",
            PLP, Data,
            PLP, Data->Magic,
            PLP, Data->HeaderSize,
            PLP, Data->FormatVersion,
            PLP, Data->DataFormatVersion,
            PLP, Data->Flags, static_cast<PCWSTR>(buffFlags));

        OutputString(
            
            L"%ls   ElementCount = %u\n"
            L"%ls   ElementListOffset = %d (-> %p)\n"
            L"%ls   SearchStructureOffset = %d (-> %p)\n"
            L"%ls   UserDataOffset = %d (-> %p)\n"
            L"%ls   UserDataSize = %u\n",
            PLP, Data->ElementCount,
            PLP, Data->ElementListOffset, ElementList,
            PLP, Data->SearchStructureOffset, SearchStructure,
            PLP, Data->UserDataOffset, UserData,
            PLP, Data->UserDataSize);

        if (UserData != NULL)
        {
            CStringPrefixer Prefixer(rbuffPLP);

            OutputString(
                L"%ls   User data at %p (%d bytes)\n",
                PLP, UserData, Data->UserDataSize);

            Prefixer.Add();
            PrintBlob( UserData, Data->UserDataSize, rbuffPLP);
            PLP = rbuffPLP;
        }
    }
    else
    {
        OutputString(
            
            L"%ls%s guid section (%lu entr%s; Flags: %ls)\n"
            L"%ls   Key................................... | Value\n",
            PLP, SectionName, Data->ElementCount, Data->ElementCount == 1 ? "y" : "ies", static_cast<PCWSTR>(buffFlags),
            PLP);
    }

    if (fFull && (SearchStructure != NULL))
    {
        PCACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET BucketTable = NULL;

        if (SearchStructure->BucketTableOffset != 0)
            BucketTable = (PCACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET) (((ULONG_PTR) Data) + SearchStructure->BucketTableOffset);

        PLP = rbuffPLP;
        OutputString(
            
            L"%ls   ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE %p\n"
            L"%ls      BucketTableEntryCount = %u\n"
            L"%ls      BucketTableOffset = %d (-> %p)\n",
            PLP, SearchStructure,
            PLP, SearchStructure->BucketTableEntryCount,
            PLP, SearchStructure->BucketTableOffset, BucketTable);

        if (BucketTable != NULL)
        {
            ULONG i;

            for (i=0; i<SearchStructure->BucketTableEntryCount; i++)
            {
                PLONG Entries = NULL;

                if (BucketTable[i].ChainOffset != 0)
                    Entries = (PLONG) (((ULONG_PTR) Data) + BucketTable[i].ChainOffset);

                OutputString(
                    
                    L"%ls      ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET %p\n"
                    L"%ls         ChainCount = %u\n"
                    L"%ls         ChainOffset = %d (-> %p)\n",
                    PLP, &BucketTable[i],
                    PLP, BucketTable[i].ChainCount,
                    PLP, BucketTable[i].ChainOffset, Entries);

                if (Entries != NULL)
                {
                    ULONG j;

                    for (j=0; j<BucketTable[i].ChainCount; j++)
                    {
                        PVOID Entry = NULL;

                        if (Entries[j] != 0)
                            Entry = (PVOID) (((ULONG_PTR) Data) + Entries[j]);

                        OutputString(
                            
                            L"%ls         Chain[%d] = %d (-> %p)\n",
                            PLP, j, Entries[j], Entry);
                    }
                }
            }
        }
    }

    if (ElementList != NULL)
    {
        ULONG i;
        CSmallSimpleString buffFormattedGuid;

        for (i=0; i<Data->ElementCount; i++)
        {
            PVOID EntryData = NULL;

            FormatGUID(ElementList[i].Guid, buffFormattedGuid);

            if (ElementList[i].Offset != 0)
                EntryData = (PVOID) (((ULONG_PTR) Data) + ElementList[i].Offset);

            if (fFull)
            {
                OutputString(
                    
                    L"%ls   ACTIVATION_CONTEXT_GUID_SECTION_ENTRY #%d - %p\n"
                    L"%ls      Guid = %ls\n"
                    L"%ls      AssemblyRosterIndex = %u\n",
                    PLP, i, &ElementList[i],
                    PLP, static_cast<PCWSTR>(buffFormattedGuid),
                    PLP, ElementList[i].AssemblyRosterIndex);

                OutputString(
                    
                    L"%ls      Offset = %d (-> %p)\n"
                    L"%ls      Length = %u\n",
                    PLP, ElementList[i].Offset, EntryData,
                    PLP, ElementList[i].Length);
            }
            else
            {
                buffBriefOutput.EnsureSize(cchPLP + 3 + 38 + 4);
                buffBriefOutput.Format(L"%s   %38s | ", PLP, static_cast<PCWSTR>(buffFormattedGuid));
            }

            if (EntryData != NULL)
            {
                if (ExtensionGuid == NULL)
                {
                    CStringPrefixer prefixer(rbuffPLP);
                    prefixer.Add();
                    prefixer.Add();

                    switch (SectionId)
                    {
                    default:
                        PrintBlob( EntryData, ElementList[i].Length, rbuffPLP);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION:
                        ::DbgExtPrintComServerRedirection( fFull, Data, (PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION:
                        ::DbgExtPrintComInterfaceRedirection( fFull, Data, (PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES:
                        ::DbgExtPrintClrSurrogateTable(fFull, Data, (PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE)EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    }

                }
            }

            if (!fFull)
                OutputString( L"%ls\n", static_cast<PCWSTR>(buffBriefOutput));
        }
    }
}

VOID
DbgExtPrintAssemblyInformation(
    
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    UNICODE_STRING s2, s3, s5, strIdentity;
    CSmallSimpleString buffManifestLastWriteTime;
    CSmallSimpleString buffPolicyLastWriteTime;
    CSmallSimpleString buffFlags;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgAssemblyInformationFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_ASSEMBLY, "Root Assembly")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_POLICY_APPLIED, "Policy Applied")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ASSEMBLY_POLICY_APPLIED, "Assembly Policy Applied")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_POLICY_APPLIED, "Root Policy Applied")
    };

    if (PLP == NULL)
        PLP = L"";

#define GET_STRING(_var, _elem) \
    if (Entry-> _elem ## Length != 0) \
    { \
        (_var).Length = (_var).MaximumLength = static_cast<USHORT>(Entry-> _elem ## Length); \
        (_var).Buffer = reinterpret_cast<PWSTR>(((LONG_PTR) Header) + Entry-> _elem ## Offset); \
    } \
    else \
    { \
        (_var).Length = (_var).MaximumLength = 0; \
        (_var).Buffer = NULL; \
        }

    GET_STRING(s2, ManifestPath);
    GET_STRING(s3, PolicyPath);
    GET_STRING(s5, AssemblyDirectoryName);

#undef GET_STRING

    // prepare data for print

    FormatFileTime(Entry->ManifestLastWriteTime, buffManifestLastWriteTime);
    FormatFileTime(Entry->PolicyLastWriteTime, buffPolicyLastWriteTime);

    FusionpFormatFlags(Entry->Flags, fFull, NUMBER_OF(s_rgAssemblyInformationFlags), s_rgAssemblyInformationFlags, buffFlags);

    if (Entry->EncodedAssemblyIdentityOffset != 0)
    {
        strIdentity.Buffer = (PWSTR) (((ULONG_PTR) Header) + Entry->EncodedAssemblyIdentityOffset);
        strIdentity.Length = static_cast<USHORT>(Entry->EncodedAssemblyIdentityLength);
        strIdentity.MaximumLength = static_cast<USHORT>(Entry->EncodedAssemblyIdentityLength);
    }
    else
    {
        strIdentity.Buffer = NULL;
        strIdentity.Length = 0;
        strIdentity.MaximumLength = 0;
    }

    if (fFull)
    {
        OutputString(
            
            L"%lsACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION %p\n"
            L"%ls   Size = %lu\n"
            L"%ls   Flags = 0x%08lx (%ls)\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags, static_cast<PCWSTR>(buffFlags));

        OutputString(
            
            L"%ls   EncodedIdentity = %wZ\n",
            PLP, &strIdentity);

        OutputString(
            
            L"%ls   ManifestPathType = %lu\n"
            L"%ls   ManifestPath = \"%wZ\"\n",
            PLP, Entry->ManifestPathType,
            PLP, &s2);

        OutputString(
            
            L"%ls   ManifestLastWriteTime = %ls\n",
            PLP, static_cast<PCWSTR>(buffManifestLastWriteTime));

        OutputString(
            
            L"%ls   PolicyPathType = %lu\n"
            L"%ls   PolicyPath = \"%wZ\"\n"
            L"%ls   PolicyLastWriteTime = %ls\n",
            PLP, Entry->PolicyPathType,
            PLP, &s3,
            PLP, static_cast<PCWSTR>(buffPolicyLastWriteTime));

        OutputString(
            
            L"%ls   MetadataSatelliteRosterIndex = %lu\n"
            L"%ls   ManifestVersionMajor = %u\n"
            L"%ls   ManifestVersionMinor = %u\n",
            PLP, Entry->MetadataSatelliteRosterIndex,
            PLP, Entry->ManifestVersionMajor,
            PLP, Entry->ManifestVersionMinor);

        OutputString(
            
            L"%ls   AssemblyDirectoryName = \"%wZ\"\n",
            PLP, &s5);
    }
    else
    {
        // abuse buffManifestLastWriteTime
        buffManifestLastWriteTime.EnsureSize(((strIdentity.Length + s2.Length) / sizeof(WCHAR)) + 4);
        buffManifestLastWriteTime.Format(L"%wZ \"%wZ\"", &strIdentity, &s2);
        rbuffBriefOutput.Append(buffManifestLastWriteTime);
    }
}

VOID
DbgExtPrintDllRedirection(
    
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT PathSegments = NULL;
    CSmallSimpleString buffFlags;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgDllRedirectionFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_INCLUDES_BASE_NAME, "Includes Base Name")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT, "Omits Assembly Root")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND, "Req. EnvVar Expansion")
    };

    if (PLP == NULL)
        PLP = L"";

    if (Entry->PathSegmentOffset != 0)
        PathSegments = (PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT) (((ULONG_PTR) Header) + Entry->PathSegmentOffset);

    ::FusionpFormatFlags(Entry->Flags, fFull, NUMBER_OF(s_rgDllRedirectionFlags), s_rgDllRedirectionFlags, buffFlags);

    if (fFull)
    {
        OutputString(
            
            L"%lsACTIVATION_CONTEXT_DATA_DLL_REDIRECTION %p\n"
            L"%ls   Size = %u\n"
            L"%ls   Flags = 0x%08lx (%ls)\n"
            L"%ls   TotalPathLength = %u (%u chars)\n"
            L"%ls   PathSegmentCount = %u\n"
            L"%ls   PathSegmentOffset = %d (-> %p)\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags, static_cast<PCWSTR>(buffFlags),
            PLP, Entry->TotalPathLength, Entry->TotalPathLength / sizeof(WCHAR),
            PLP, Entry->PathSegmentCount,
            PLP, Entry->PathSegmentOffset, PathSegments);
    }
    else
        rbuffBriefOutput.Append(L"\"", 1);

    if (PathSegments != NULL)
    {
        ULONG i;

        for (i=0; i<Entry->PathSegmentCount; i++)
        {
            PCWSTR pwch = NULL;
            UNICODE_STRING s;

            if (PathSegments[i].Offset != 0)
            {
                pwch = (PCWSTR) (((ULONG_PTR) Header) + PathSegments[i].Offset);

                s.MaximumLength = static_cast<USHORT>(PathSegments[i].Length);
                s.Length = static_cast<USHORT>(PathSegments[i].Length);
                s.Buffer = (PWSTR) pwch;
            }
            else
            {
                s.MaximumLength = 0;
                s.Length = 0;
                s.Buffer = NULL;
            }

            if (fFull)
            {
                OutputString(
                    
                    L"%ls   ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT #%d - %p\n"
                    L"%ls      Length = %u (%u chars)\n"
                    L"%ls      Offset = %d (-> %p)\n"
                    L"%ls         \"%wZ\"\n",
                    PLP, i, &PathSegments[i],
                    PLP, PathSegments[i].Length, PathSegments[i].Length / sizeof(WCHAR),
                    PLP, PathSegments[i].Offset, pwch,
                    PLP, &s);
            }
            else
            {
                rbuffBriefOutput.Append(s.Buffer, s.Length / sizeof(WCHAR));
            }
        }
    }

    if (!fFull)
    {
        rbuffBriefOutput.Append(L"\" (Flags: ", 10);
        rbuffBriefOutput.Append(buffFlags);
        rbuffBriefOutput.Append(L")", 1);
    }
}

VOID
DbgExtPrintWindowClassRedirection(
    
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    UNICODE_STRING s1, s2;
    CSmallSimpleString buffFlags;

#if 0 // replace when the list of flags is non-empty
    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgWCRedirectionFlags[] =
    {
    };
#endif // 0

    if (PLP == NULL)
        PLP = L"";

    memset(&s1, 0, sizeof(s1));
    memset(&s2, 0, sizeof(s2));

    ::FusionpFormatFlags(
        Entry->Flags,
        fFull,
#if 0 // replace when the list of flags is nonempty
        NUMBER_OF(s_rgWCRedirectionFlags), s_rgWCRedirectionFlags,
#else
        0, NULL,
#endif
        buffFlags);

    if (Entry->VersionSpecificClassNameOffset != 0)
    {
        s1.Length = static_cast<USHORT>(Entry->VersionSpecificClassNameLength);
        s1.MaximumLength = s1.Length;
        s1.Buffer = (PWSTR) (((ULONG_PTR) Entry) + Entry->VersionSpecificClassNameOffset);
    }

    if (Entry->DllNameOffset != 0)
    {
        s2.Length = static_cast<USHORT>(Entry->DllNameLength);
        s2.MaximumLength = s2.Length;
        s2.Buffer = (PWSTR) (((ULONG_PTR) Header) + Entry->DllNameOffset);
    }

    if (fFull)
    {
        OutputString(
            
            L"%lsACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION %p\n"
            L"%ls   Size = %u\n"
            L"%ls   Flags = 0x%08lx\n"
            L"%ls   VersionSpecificClassNameLength = %u (%u chars)\n"
            L"%ls   VersionSpecificClassNameOffset = %d (-> %p)\n"
            L"%ls      \"%wZ\"\n"
            L"%ls   DllNameLength = %u (%u chars)\n"
            L"%ls   DllNameOffset = %d (-> %p)\n"
            L"%ls      \"%wZ\"\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags,
            PLP, Entry->VersionSpecificClassNameLength, Entry->VersionSpecificClassNameLength / sizeof(WCHAR),
            PLP, Entry->VersionSpecificClassNameOffset, s1.Buffer,
            PLP, &s1,
            PLP, Entry->DllNameLength, Entry->DllNameLength / sizeof(WCHAR),
            PLP, Entry->DllNameOffset, s2.Buffer,
            PLP, &s2);
    }
    else
    {
        rbuffBriefOutput.Append(s1.Buffer, s1.Length / sizeof(WCHAR));
        rbuffBriefOutput.Append(L" in ", 4);
        rbuffBriefOutput.Append(s2.Buffer, s2.Length / sizeof(WCHAR));
        rbuffBriefOutput.Append(L" (Flags: ", 9);
        rbuffBriefOutput.Append(buffFlags);
        rbuffBriefOutput.Append(L")", 1);
    }
}

VOID
DbgExtPrintComServerRedirection(
    
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallSimpleString buffConfiguredClsid;
    CSmallSimpleString buffImplementedClsid;
    CSmallSimpleString buffReferenceClsid;
    CSmallSimpleString buffTypeLibraryId;
    CSmallSimpleString buffThreadingModel;
    UNICODE_STRING s;
    UNICODE_STRING progid;

    if (PLP == NULL)
        PLP = L"";

    memset(&s, 0, sizeof(s));

    FormatGUID(Entry->ReferenceClsid, buffReferenceClsid);
    FormatGUID(Entry->ConfiguredClsid, buffConfiguredClsid);
    FormatGUID(Entry->ImplementedClsid, buffImplementedClsid);

    if (Entry->TypeLibraryId == GUID_NULL)
        buffTypeLibraryId.Assign(L"<none>", 6);
    else
        FormatGUID(Entry->TypeLibraryId, buffTypeLibraryId);

    FormatThreadingModel(Entry->ThreadingModel, buffThreadingModel);

    if (Entry->ModuleOffset != 0)
    {
        s.Length = static_cast<USHORT>(Entry->ModuleLength);
        s.MaximumLength = s.Length;
        s.Buffer = (PWSTR) (((ULONG_PTR) Header) + Entry->ModuleOffset);
    }

    if (Entry->ProgIdOffset != 0)
    {
        progid.Length = static_cast<USHORT>(Entry->ProgIdLength);
        progid.MaximumLength = progid.Length;
        progid.Buffer = (PWSTR) (((ULONG_PTR) Entry) + Entry->ProgIdOffset);
    }
    else
    {
        progid.Length = 0;
        progid.MaximumLength = 0;
        progid.Buffer = NULL;
    }

    if (fFull)
    {
        OutputString(
            
            L"%lsACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION %p\n"
            L"%ls   Size = %u\n"
            L"%ls   Flags = 0x%08lx\n"
            L"%ls   ThreadingModel = %u (%ls)\n"
            L"%ls   ReferenceClsid = %ls\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags,
            PLP, Entry->ThreadingModel, static_cast<PCWSTR>(buffThreadingModel),
            PLP, static_cast<PCWSTR>(buffReferenceClsid));

        OutputString(
            
            L"%ls   ConfiguredClsid = %ls\n"
            L"%ls   ImplementedClsid = %ls\n"
            L"%ls   TypeLibraryId = %ls\n"
            L"%ls   ModuleLength = %u (%u chars)\n"
            L"%ls   ModuleOffset = %d (-> %p)\n"
            L"%ls      \"%wZ\"\n",
            PLP, static_cast<PCWSTR>(buffConfiguredClsid),
            PLP, static_cast<PCWSTR>(buffImplementedClsid),
            PLP, static_cast<PCWSTR>(buffTypeLibraryId),
            PLP, Entry->ModuleLength, Entry->ModuleLength / sizeof(WCHAR),
            PLP, Entry->ModuleOffset, s.Buffer,
            PLP, &s);


        OutputString(
            
            L"%ls   ProgIdLength = %lu\n"
            L"%ls   ProgIdOffset = %ld (-> %p)\n"
            L"%ls      \"%wZ\"\n",
            PLP, Entry->ProgIdLength,
            PLP, Entry->ProgIdOffset, progid.Buffer,
            PLP, &progid);
    }
    else
    {
        rbuffBriefOutput.Append(buffConfiguredClsid);

        rbuffBriefOutput.Append(L" ", 1);
        rbuffBriefOutput.Append(s.Buffer, s.Length / sizeof(WCHAR));
        if (progid.Length != 0)
        {
            rbuffBriefOutput.Append(L" progid: ", 9);
            rbuffBriefOutput.Append(progid.Buffer, progid.Length / sizeof(WCHAR));
        }
    }

}

VOID
DbgExtPrintComProgIdRedirection(
    
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
//    CSmallSimpleString buffFlags;
    CSmallSimpleString buffClsid;
    const GUID *pcguid = NULL;

    if (Entry->ConfiguredClsidOffset != 0)
    {
        pcguid = (const GUID *) (((ULONG_PTR) Header) + Entry->ConfiguredClsidOffset);
        FormatGUID(*pcguid, buffClsid);
    }

    if (fFull)
    {
        OutputString(
            
            L"%lsACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION %p\n"
            L"%ls   Size = %lu (0x%lx)\n"
            L"%ls   Flags = 0x%08lx\n"
            L"%ls   ConfiguredClsidOffset = %lu (-> %p)\n"
            L"%ls      %ls\n",
            PLP, Entry,
            PLP, Entry->Size, Entry->Size,
            PLP, Entry->Flags,
            PLP, Entry->ConfiguredClsidOffset, pcguid,
            PLP, static_cast<PCWSTR>(buffClsid));
    }
    else
    {
        rbuffBriefOutput.Append(buffClsid);
    }
}

VOID
DbgExtPrintComInterfaceRedirection(
    
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallSimpleString buffProxyStubClsid32;
    CSmallSimpleString buffBaseInterface;
    CSmallSimpleString buffFlags;
    CSmallSimpleString buffTypeLibraryId;
    UNICODE_STRING s;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgComInterfaceFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_NUM_METHODS_VALID, "NumMethods Valid")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_BASE_INTERFACE_VALID, "BaseInterface Valid")
    };

    if (PLP == NULL)
        PLP = L"";

    memset(&s, 0, sizeof(s));

    FormatGUID(Entry->ProxyStubClsid32, buffProxyStubClsid32);
    FormatGUID(Entry->BaseInterface, buffBaseInterface);

    ::FusionpFormatFlags(Entry->Flags, fFull, NUMBER_OF(s_rgComInterfaceFlags), s_rgComInterfaceFlags, buffFlags);

    if (Entry->TypeLibraryId == GUID_NULL)
        buffTypeLibraryId.Assign(L"<none>", 6);
    else
        FormatGUID(Entry->TypeLibraryId, buffTypeLibraryId);

    if (Entry->NameOffset != 0)
    {
        s.Length = static_cast<USHORT>(Entry->NameLength);
        s.MaximumLength = s.Length;
        s.Buffer = (PWSTR) (((ULONG_PTR) Entry) + Entry->NameOffset);
    }

    if (fFull)
    {
        OutputString(
            
            L"%lsACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION %p\n"
            L"%ls   Size = %lu\n"
            L"%ls   Flags = 0x%08lx (%ls)\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags, static_cast<PCWSTR>(buffFlags));

        OutputString(
            
            L"%ls   ProxyStubClsid32 = %ls\n"
            L"%ls   NumMethods = %lu\n"
            L"%ls   TypeLibraryId = %ls\n",
            PLP, static_cast<PCWSTR>(buffProxyStubClsid32),
            PLP, Entry->NumMethods,
            PLP, static_cast<PCWSTR>(buffTypeLibraryId));

        OutputString(
            
            L"%ls   BaseInterface = %ls\n"
            L"%ls   NameLength = %lu (%u chars)\n"
            L"%ls   NameOffset = %lu (-> %p)\n",
            PLP, static_cast<PCWSTR>(buffBaseInterface),
            PLP, Entry->NameLength, (Entry->NameLength / sizeof(WCHAR)),
            PLP, Entry->NameOffset, s.Buffer);

        OutputString(
            
            L"%ls      \"%wZ\"\n",
            PLP, &s);
    }
    else
    {
        rbuffBriefOutput.Append(buffProxyStubClsid32);
        rbuffBriefOutput.Append(L" ", 1);
        rbuffBriefOutput.Append(s.Buffer, s.Length / sizeof(WCHAR));
    }
}

#ifndef RTL_CONSTANT_STRING
#define RTL_CONSTANT_STRING(x) { NUMBER_OF(x) - 1, NUMBER_OF(x) - 1, x }
#endif

VOID
DbgExtPrintClrSurrogateTable(
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    CSimpleInlineString<> buffGuid;
    UNICODE_STRING RuntimeVersion = RTL_CONSTANT_STRING(L"<No runtime version>");
    UNICODE_STRING TypeName = RTL_CONSTANT_STRING(L"<No type name>");

    if (PLP == NULL)
        PLP = L"";

    FormatGUID(Entry->SurrogateIdent, buffGuid);

    if (Entry->VersionOffset != 0)
    {
        RuntimeVersion.MaximumLength = RuntimeVersion.Length = static_cast<USHORT>(Entry->VersionLength);
        RuntimeVersion.Buffer = (PWSTR)(((ULONG_PTR)Entry) + Entry->VersionOffset);
    }

    if (Entry->TypeNameOffset != 0)
    {
        TypeName.MaximumLength = TypeName.Length = static_cast<USHORT>(Entry->TypeNameLength);
        TypeName.Buffer = (PWSTR)(((ULONG_PTR)Entry) + Entry->TypeNameOffset);
    }

    if (fFull)
    {
        OutputString(
            L"%SACTIVATION_CONTEXT_DATA_NDP_INTEROP %p\n"
            L"%S   Size = %u\n"
            L"%S   Flags = 0x%08lx\n"
            L"%S   SurrogateIdent = %S\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags,
            PLP, static_cast<PCWSTR>(buffGuid));

        OutputString(
            L"%S   AssemblyName [Offset %u (-> %p), Length %u] = \"%wZ\"\n"
            L"%S   RuntimeVersion [Offset %u (-> %p), Length %u] = \"%wZ\"\n",
            PLP, Entry->TypeNameOffset, TypeName.Buffer, Entry->TypeNameLength, &TypeName,
            PLP, Entry->VersionOffset, RuntimeVersion.Buffer, Entry->VersionLength, &RuntimeVersion
            );
    }
    else
    {
        rbuffBriefOutput.Append(buffGuid);
        rbuffBriefOutput.Append(L" runtime: '", NUMBER_OF(L" runtime: '")-1);
        rbuffBriefOutput.Append(&RuntimeVersion);
        rbuffBriefOutput.Append(L"' typename: '", NUMBER_OF(L"' typename: '")-1);
        rbuffBriefOutput.Append(&TypeName);
        rbuffBriefOutput.Append(L"'", 1);
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\dll\whistler\amd64sxsmk.inc ===
#
# This file is intentionally empty, see "sxsmk" in sources.
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\dll\recover.h ===
#pragma once

#include "FusionArray.h"
#include "SxsApi.h"

#define SXSRECOVER_MODE_MASK        ( 0x0000000F )
#define SXSRECOVER_NOTHING          ( 0x00000000 )
#define SXSRECOVER_MANIFEST         ( 0x00000001 )
#define SXSRECOVER_ASSEMBLYMEMBER   ( 0x00000002 )
#define SXSRECOVER_FULL_ASSEMBLY    ( SXSRECOVER_ASSEMBLYMEMBER | SXSRECOVER_MANIFEST )

enum SxsRecoveryResult
{
    Recover_OK,
    Recover_ManifestMissing,
    Recover_CatalogInvalid,
    Recover_OneOrMoreFailed,
    Recover_SourceMissing,
    Recover_Unknown
};

#if DBG
#define ENUM_TO_STRING( x ) case x: return (L#x)

inline static PCWSTR SxspRecoveryResultToString( const SxsRecoveryResult r )
{
    switch ( r )
    {
        ENUM_TO_STRING( Recover_OK );
        ENUM_TO_STRING( Recover_ManifestMissing );
        ENUM_TO_STRING( Recover_CatalogInvalid );
        ENUM_TO_STRING( Recover_OneOrMoreFailed );
        ENUM_TO_STRING( Recover_SourceMissing );
        ENUM_TO_STRING( Recover_Unknown );
    }

    return L"Bad SxsRecoveryResult value";
}
#undef ENUM_TO_STRING
#endif

class CManifestSecurityContent;
class CAssemblyRecoveryInfo;


class CRecoveryCopyQueue;

BOOL
SxspRecoverAssembly(
    IN          CAssemblyRecoveryInfo &AsmRecoverInfo,
    IN          CRecoveryCopyQueue *pRecoveryQueue,
    OUT         SxsRecoveryResult &rStatus
    );

BOOL
SxspAddAssemblyInstallationInfo(
    IN  PCWSTR  pcwszAssemblyName,
    IN  PCWSTR  pcwszCodebase,
    IN  PCWSTR  pcwszPrompt OPTIONAL,
    IN  BOOL    bHasCatalog
    );


BOOL
SxspAddAssemblyInstallationInfo(
    IN const CAssemblyRecoveryInfo& AssemblyInfo
    );

class CRecoveryCopyQueue
{
private:
    SLIST_HEADER                m_PostCopyList;
    BOOL                        m_bDoingOwnCopies;
    CManifestSecurityContent    *m_pValidateTable;
    CStringBuffer               m_sbAssemblyInstallRoot;
    CFusionArray<CStringBuffer> m_EligbleCopies;

    //
    // As the copy callback is triggered, we get pairs of source/destination
    // strings that indicate where files should be copied.  These get stored
    // in the m_PostCopyList queue, and consumed in the queue flush.  As part
    // of the installation callback, we validate that the file being copied to
    // does in fact match the hash stored in the m_pValidateTable, if it is
    // non-null.
    //
    class CQueueElement : public SINGLE_LIST_ENTRY
    {
    public:
        CStringBuffer sbSource;
        CStringBuffer sbDestination;

    private:
        CQueueElement(const CQueueElement &);
        void operator =(const CQueueElement &);
    };

    BOOL InternalCopyCallback(PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS);

public:
    CRecoveryCopyQueue( CManifestSecurityContent *pValidateSource = NULL, bool bDoOwnCopies = true);
    ~CRecoveryCopyQueue();

    BOOL Initialize();
    VOID SetManifestContentTable( CManifestSecurityContent* pSource )
        { m_pValidateTable = pSource; }

    //
    // This is in the setup phase - indicate that this item is to be copied
    // over as part of the protection copy progress.  This entry is the assembly-
    // relative name of the file in question.
    //
    BOOL AddRecoveryItem( const CStringBuffer &sbItem );
    BOOL AddRecoveryItem( const CStringBuffer *sbItems, SIZE_T cItems );

    //
    // Callback used by the copy queue functionality
    //
    static BOOL WINAPI staticCopyCallback(PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS);

    //
    // After the assembly install process completes, this function is called by
    // SxspRecoverAssembly to do the actual copies of stuff.
    //
    BOOL FlushPending( BOOL &bFullCopyQueueRecovered );

private:
    CRecoveryCopyQueue(const CRecoveryCopyQueue &);
    void operator =(const CRecoveryCopyQueue &);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\dll\whistler\exitproc.c ===
#define _KERNEL32_
#include "windows.h"

void
SxspCrtRaiseExit(
    PCSTR    pszCaller,
    int      crtError
    );

VOID
WINAPI
ExitProcess(
    IN UINT uExitCode
    )
{
    SxspCrtRaiseExit(__FUNCTION__, (int)uExitCode);
}

#if !defined(_M_IX86) && !defined(_X86_)
const extern FARPROC __imp_ExitProcess = (FARPROC)&ExitProcess;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\dll\sxsprotect.h ===
#pragma once

#include "Sxsp.h"

//
// Turn this off to fail all manifests without catalogs during the parse!
//
#define SXS_LAX_MANIFEST_VALIDATION

//
// Warning - leaving this defined will --DISABLE-- WFP-SXS.
// Define it as FALSE if you want to turn it back on.
//
#define YOU_ARE_HAVING_ANY_WIERDNESS_WITH_SFC_AND_SXS FALSE
//
// For this checkin (11/23ish/2000), we'll be leaving it turned OFF
//
// #define YOU_ARE_HAVING_ANY_WIERDNESS_WITH_SFC_AND_SXS TRUE


//
// This stuff is private!
//
#include "hashfile.h"
#include "CAssemblyRecoveryInfo.h"
#include "recover.h"

BOOL
SxspResolveAssemblyManifestPath(
    const CStringBuffer &AsmDirectoryName,
    CStringBuffer &bsManifestPath
);

BOOL
SxspIsSfcIgnoredStoreSubdir(
    PCWSTR pwszDir
);


class CProtectionRequestList;
class CStringListEntry;
class CProtectionRequestRecord;

#include "HashFile.h"
#include "FusionHash.h"

class CStringListEntry : public CAlignedSingleListEntry
{
public:
    CStringListEntry() { }

    CStringBuffer   m_sbText;
private:
    CStringListEntry(const CStringListEntry &);
    void operator =(const CStringListEntry &);
};

class CProtectionRequestRecord
{
private:
    CStringBuffer                   m_sbAssemblyName;
    CStringBuffer                   m_sbManifestPath;
    CStringBuffer                   m_sbAssemblyStore;
    CStringBuffer                   m_sbKeyValue;
    DWORD                           m_dwAction;
    PSXS_PROTECT_DIRECTORY          m_pvProtection;
    ULONG                           m_ulInRecoveryMode;
    CProtectionRequestList          *m_pParent;
    SLIST_HEADER                    m_ListHeader;
    CManifestSecurityContent        *m_pPreParsedManifest;
    BOOL                            m_bIsManPathResolved;
    BOOL                            m_bInitialized;
    CAssemblyRecoveryInfo           m_RecoverInfo;

public:

    CProtectionRequestRecord();


    inline CProtectionRequestList *GetParent() const { return m_pParent; }
    inline CAssemblyRecoveryInfo &GetRecoveryInfo() const { return m_RecoverInfo; }
    inline const CStringBuffer &GetAssemblyDirectoryName() const { return m_sbAssemblyName; }
    inline const CStringBuffer &GetChangeBasePath() const { return m_sbKeyValue; }

    inline VOID SetParent( CProtectionRequestList *pParent ) { m_pParent = pParent; };
    inline VOID MarkInRecoveryMode( BOOL inRecovery ) { SxspInterlockedExchange( &m_ulInRecoveryMode, ( inRecovery ? 1 : 0 ) ); }
    inline VOID ClearList();

    inline BOOL GetManifestContent( CManifestSecurityContent *&pManifestData );
    inline BOOL SetAssemblyName( CStringBuffer &sbNewname ) { return m_sbAssemblyName.Win32Assign( sbNewname ); }
    inline BOOL GetManifestPath( CStringBuffer &sbManPath );
    inline BOOL AddSubFile( const CStringBuffer &sbThing );
    inline BOOL PopNextFileChange( CStringBuffer &Dest );
    inline BOOL GetAssemblyStore( CStringBuffer &Dest ) { return Dest.Win32Assign( m_sbAssemblyStore ); }

    inline BOOL Initialize(
        const CStringBuffer &sbAssemblyName,
        const CStringBuffer &sbKeyString,
        CProtectionRequestList* ParentList,
        PVOID                   pvRequestRecord,
        DWORD                   dwAction
    );

    ~CProtectionRequestRecord();

private:
    CProtectionRequestRecord(const CProtectionRequestRecord &);
    void operator =(const CProtectionRequestRecord &);
};

class CRecoveryJobTableEntry
{
public:
    CRecoveryJobTableEntry() 
        : m_Result(Recover_Unknown), m_dwLastError(ERROR_SUCCESS),  m_bSuccessValue(TRUE),
          m_Subscriber(0), m_EventInstallingAssemblyComplete(INVALID_HANDLE_VALUE)
    { }

    SxsRecoveryResult   m_Result;
    DWORD               m_dwLastError;
    BOOL                m_bSuccessValue;
    ULONG               m_Subscriber;
    HANDLE              m_EventInstallingAssemblyComplete;

    VOID Initialize();
    VOID StartInstallation();
    VOID InstallationComplete( BOOL bDoneOk, SxsRecoveryResult Result, DWORD dwLastError );

    VOID WaitUntilCompleted( SxsRecoveryResult &rResult, BOOL &rbSucceededValue, DWORD &rdwErrorResult );

    ~CRecoveryJobTableEntry();
private:
    CRecoveryJobTableEntry(const CRecoveryJobTableEntry &);
    void operator =(const CRecoveryJobTableEntry &);
};

#pragma warning(disable:4324)  // structure was padded due to __declspec(align())

class CProtectionRequestList : public CCleanupBase
{
private:
    typedef CCaseInsensitiveUnicodeStringPtrTable<CProtectionRequestRecord> COurInternalTable;
    typedef CCaseInsensitiveUnicodeStringPtrTableIter<CProtectionRequestRecord> COurInternalTableIter;
    typedef CCaseInsensitiveUnicodeStringPtrTable<CRecoveryJobTableEntry> CInstallsInProgressTable;

    CRITICAL_SECTION    m_cSection;
    CRITICAL_SECTION    m_cInstallerCriticalSection;
    COurInternalTable   *m_pInternalList;
    CInstallsInProgressTable *m_pInstallsTable;

    //
    // Manifest edits are trickier, they get their own system of being handled.
    //
    SLIST_HEADER        m_ManifestEditList;
    HANDLE              m_hManifestEditHappened;
    ULONG               m_ulIsAThreadServicingManifests;

    static DWORD ProtectionNormalThreadProc( PVOID pvParam );
    static DWORD ProtectionManifestThreadProc( PVOID pvParam );
    static BOOL  ProtectionManifestThreadProcNoSEH( PVOID pvParam );

    inline BOOL ProtectionNormalThreadProcWrapped( CProtectionRequestRecord *pProtectionRequest );
    inline BOOL ProtectionManifestThreadProcWrapped();
    inline BOOL ProtectionManifestSingleManifestWorker( const CStringListEntry *pEntry );

    static PCWSTR m_arrIgnorableSubdirs[];
    static SIZE_T m_cIgnorableSubdirs;

    friend BOOL SxspConstructProtectionList();

    BOOL Initialize();

    CProtectionRequestList();

    BOOL PerformRecoveryOfAssembly(
        CAssemblyRecoveryInfo &RecoverInfo,
        CRecoveryCopyQueue* pvPotentialQueue,
        SxsRecoveryResult &Result
    );

    ~CProtectionRequestList();

public:
    static BOOL IsSfcIgnoredStoreSubdir( PCWSTR wsz );
    void DeleteYourself() { this->~CProtectionRequestList(); }
    VOID ClearProtectionItems(CProtectionRequestRecord *Asm) { FUSION_DELETE_SINGLETON( Asm ); }

    BOOL AttemptRemoveItem( CProtectionRequestRecord *AttemptRemoval );
    BOOL AddRequest( PSXS_PROTECT_DIRECTORY pProtect, PCWSTR pcwszDirName, SIZE_T cchName, DWORD dwAction );

private:
    CProtectionRequestList(const CProtectionRequestList &);
    void operator =(const CProtectionRequestList &);
};

#pragma warning(default:4324)  // structure was padded due to __declspec(align())

VOID
SxsProtectionEnableProcessing(
    BOOL bActivityEnabled
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\dll\whistler\ia64sxsmk.inc ===
#
# This file is intentionally empty, see "sxsmk" in sources.
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\dll\whistler\i386\exitprocasm.asm ===
;
; This is in assembly because assembly lets you generate arbitrarily named symbols.
;

	.386p
.model flat

extern	_ExitProcess@4:near
public	__imp__ExitProcess@4

CONST   segment
__imp__ExitProcess@4 dd _ExitProcess@4
CONST	ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\dll\whistler\termproc.c ===
#define _KERNEL32_
#include "windows.h"

void
SxspCrtRaiseExit(
    PCSTR    pszCaller,
    int      crtError
    );

BOOL
WINAPI
TerminateProcess(
    IN HANDLE hProcess,
    IN UINT uExitCode
    )
{
    SxspCrtRaiseExit(__FUNCTION__, (int)uExitCode);
    return FALSE;
}

#if !defined(_M_IX86) && !defined(_X86_)
const extern FARPROC __imp_TerminateProcess = (FARPROC)&TerminateProcess;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\dll\whistler\i386sxsmk.inc ===
#
# We pull these in directly because they are in both ntdll.lib
# and libcmt.lib and if we let link search .libs, it complains about
# duplicate symbols. ".objs beat .libs."
#
TARGETLIBS=\
  $(PROJECT_ROOT)\crts\crtw32\misc\nt\$(O)\exsup.obj \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\dll\whistler\i386\setunhandledexceptionfilterasm.asm ===
;
; This is in assembly because assembly lets you generate arbitrarily named symbols.
;

	.386p
.model flat

extern	_SetUnhandledExceptionFilter@4:near
public	__imp__SetUnhandledExceptionFilter@4

CONST   segment
__imp__SetUnhandledExceptionFilter@4 dd _SetUnhandledExceptionFilter@4
CONST	ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\dll\whistler\setunhandledexceptionfilter.c ===
#define _KERNEL32_
#include "windows.h"

LPTOP_LEVEL_EXCEPTION_FILTER
WINAPI
SetUnhandledExceptionFilter(
    LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    )
{
    /* don't do anything */
    return NULL;
}

#if !defined(_M_IX86) && !defined(_X86_)
const extern FARPROC __imp_SetUnhandledExceptionFilter = (FARPROC)&SetUnhandledExceptionFilter;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\dll\whistler\i386\termprocasm.asm ===
;
; This is in assembly because assembly lets you generate arbitrarily named symbols.
;

	.386p
.model flat

extern	_TerminateProcess@8:near
public	__imp__TerminateProcess@8

CONST   segment
__imp__TerminateProcess@8 dd _TerminateProcess@8
CONST	ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\eventlog\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:  Michael Grier

!ENDIF

MAJORCOMP=fusion
MINORCOMP=eventlog

TARGETNAME=$(FUSION_BUILD_TYPE_PREFIX)eventlog
TARGETTYPE=LIBRARY
TARGETPATH=$(FUSION_LIB_DEST)
INCLUDES=..;$(FUSION_INC_PATH);$(INCLUDES)

MC_FLAGS=-b

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

NTTARGETFILE0= \
    $(O)\Messages.hi \
    $(O)\Messages.mc \
    $(O)\Messages.h

SOURCES= \
    ..\eventlog.cpp \
    $(O)\Messages.mc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\eventlog\stdinc.h ===
#pragma once
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "fusionlastwin32error.h"
#include "fusionunused.h"
#define MAXDWORD (~(DWORD)0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\eventlog\whistler\makefile.inc ===
# makefile.inc

$(O)\MSG00409.bin : ..\Messages.x
$(O)\message.h : $(O)\Messages.mc

$(O)\Messages.hi : ..\Messages.x
	@echo Creating $@ from $?
	$(C_PREPROCESSOR_NAME) /DCPLUSPLUS_INVOKED $(C_PREPROCESSOR_FLAGS) $** > $@

$(O)\Messages.mc : ..\Messages.x
	@echo Creating $@ from $?
	$(C_PREPROCESSOR_NAME) /DMC_INVOKED $(C_PREPROCESSOR_FLAGS) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\eventlog\win2000\makefile.inc ===
# makefile.inc

$(O)\MSG00409.bin : ..\Messages.x
$(O)\message.h : $(O)\Messages.mc

$(O)\Messages.hi : ..\Messages.x
	@echo Creating $@ from $?
	$(C_PREPROCESSOR_NAME) /DCPLUSPLUS_INVOKED $(C_PREPROCESSOR_FLAGS) $** > $@

$(O)\Messages.mc : ..\Messages.x
	@echo Creating $@ from $?
	$(C_PREPROCESSOR_NAME) /DMC_INVOKED $(C_PREPROCESSOR_FLAGS) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\eventlog\eventlog.cpp ===
#include "stdinc.h"
#include "FusionEventLog.h"
#include "search.h"
#include <stdlib.h>
#include "fusionunused.h"
#include "sxsid.h"

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

const UNICODE_STRING g_strEmptyUnicodeString = { 0, 0, L""};

extern HINSTANCE g_hInstance;
HANDLE g_hEventLog = NULL;
BOOL   g_fEventLogOpenAttempted = FALSE;


// a registry key name, and appears in the EventVwr ui.
// should be localized?
// a macro is provided for easy static concatenation
#define EVENT_SOURCE L"SideBySide"

// path we put in the registry to our message file
// we might want to change this to ntdll.dll or kernel32.dll
// whatever file it is, you can't replace it while EventVwr is running, which stinks
#define MESSAGE_FILE L"%SystemRoot%\\System32\\sxs.dll"

// the non macro, string pool formed, to use for other than string concatenation
const WCHAR szEventSource[] = EVENT_SOURCE;

// same thing in another form
const static UNICODE_STRING strEventSource = CONSTANT_UNICODE_STRING(szEventSource);

// machine is assumed to be the local machine
const static UNICODE_STRING strMachine = {0, 0, NULL};

// we only actually log errors, but this is far and away the most common value in the registry
// and there doesn't seem to be a downside to using it
static const DWORD dwEventTypesSupported = (EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE);

// a registry value name
static const WCHAR szTypesSupportedName[] = L"TypesSupported";

// a registry value name
static const WCHAR szEventMessagFileName[] = L"EventMessageFile";

static const WCHAR szEventMessageFileValue[] = MESSAGE_FILE;
static const HKEY  hkeyEventLogRoot = HKEY_LOCAL_MACHINE;
#define EVENT_LOG_SUBKEY L"System\\CurrentControlSet\\Services\\EventLog\\System\\" EVENT_SOURCE

static UNICODE_STRING const* const g_rgpsEmptyStrings[] =
{
    &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString,
    &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString,
    &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString,
    &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString,
    &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString
};

/*--------------------------------------------------------------------------
call this from DllMain
--------------------------------------------------------------------------*/

BOOL
FusionpEventLogMain(
    HINSTANCE,
    DWORD dwReason,
    PVOID pvReserved
    )
{
    if ((dwReason == DLL_PROCESS_DETACH) &&
        (g_hEventLog != NULL))
    {
        ::ElfDeregisterEventSource(g_hEventLog);
        g_hEventLog = NULL;
    }
    return TRUE;
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/
CEventLogLastError::CEventLogLastError()
{
    const DWORD dwLastError = FusionpGetLastWin32Error();

    // extra string copy..
    WCHAR rgchLastError[NUMBER_OF(m_rgchBuffer)];
    rgchLastError[0] = 0;

    // I expect FormatMessage will truncate, which is acceptable.
    const DWORD dwFlags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY;
    if (::FormatMessageW(dwFlags, NULL, dwLastError, 0, rgchLastError, NUMBER_OF(rgchLastError), NULL) == 0 )
        wcscpy(rgchLastError, L"Error Message is unavailable\n");

    // Format will truncate, which is acceptable.
    //Format(L"FusionpGetLastWin32Error()=(%ld,%ls)", nLastError, rgchLastError);
    Format(L"%ls", rgchLastError);

    SetLastError(dwLastError);
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/
CEventLogLastError::CEventLogLastError(
    DWORD dwLastError
    )
{
    // extra string copy..
    WCHAR rgchLastError[NUMBER_OF(m_rgchBuffer)];
    rgchLastError[0] = 0;

    // I expect FormatMessage will truncate, which is acceptable.
    const DWORD dwFlags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY;
    if (::FormatMessageW(dwFlags, NULL, dwLastError, 0, rgchLastError, NUMBER_OF(rgchLastError), NULL) == 0)
        wcscpy(rgchLastError, L"Error Message is unavailable\n");

    // Format will truncate, which is acceptable.
    //Format(L"FusionpGetLastWin32Error()=(%ld,%ls)", nLastError, rgchLastError);
    Format(L"%ls", rgchLastError);

    SetLastError(dwLastError);
}

/*--------------------------------------------------------------------------
register ourselves in the registry on demand
FUTURE Do this in setup?
HKLM\System\CurrentControlSet\Services\EventLog\System\SideBySide
    EventMessageFile = %SystemRoot%\System32\Fusion.dll
    TypesSupported = 7
--------------------------------------------------------------------------*/

static BOOL
FusionpRegisterEventLog()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    HKEY hkey = NULL;
    BOOL fValidHkey = FALSE;
    LONG lRet = ERROR_SUCCESS;
    DWORD dwDisposition = 0;
    WCHAR szSubKey[] = EVENT_LOG_SUBKEY;

    // first see if it's there, in which case we have less to do
    lRet = ::RegOpenKeyExW(
        hkeyEventLogRoot,
        szSubKey,
        0, // reserved options
        KEY_READ | FUSIONP_KEY_WOW64_64KEY,
        &hkey);
    if (lRet == ERROR_SUCCESS)
    {
        fValidHkey = TRUE;
        goto Exit;
    }
    if (lRet != ERROR_FILE_NOT_FOUND && lRet != ERROR_PATH_NOT_FOUND)
    {
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: FusionpRegisterEventLog/RegOpenKeyExW failed %ld\n", lRet);
        goto Exit;
    }
    lRet = ::RegCreateKeyExW(
        hkeyEventLogRoot,
        szSubKey,
        0, // reserved
        NULL, // class
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS | FUSIONP_KEY_WOW64_64KEY,
        NULL, // security
        &hkey,
        &dwDisposition);
    if (lRet != ERROR_SUCCESS)
    {
        goto Exit;
    }

    fValidHkey = TRUE;
    lRet = ::RegSetValueExW(
        hkey,
        szEventMessagFileName,
        0, // reserved
        REG_EXPAND_SZ,
        reinterpret_cast<const BYTE*>(szEventMessageFileValue),
        sizeof(szEventMessageFileValue));
    if (lRet != ERROR_SUCCESS)
    {
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: FusionpRegisterEventLog/RegSetValueExW failed %ld\n", lRet);
        goto Exit;
    }

    lRet = ::RegSetValueExW(
        hkey,
        szTypesSupportedName,
        0, // reserved
        REG_DWORD,
        reinterpret_cast<const BYTE*>(&dwEventTypesSupported),
        sizeof(dwEventTypesSupported));
    if (lRet != ERROR_SUCCESS)
    {
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: FusionpRegisterEventLog/RegSetValueExW failed %ld\n", lRet);
        goto Exit;
    }
Exit:
    if (fValidHkey)
    {
        if (lRet != ERROR_SUCCESS)
        {
            if (dwDisposition == REG_CREATED_NEW_KEY)
            {
            // rollback if there definitely wasn't anything there before
                PWSTR szParentKey = szSubKey;
                LONG lSubRet = ERROR_SUCCESS;
                HKEY hkeyParent = reinterpret_cast<HKEY>(INVALID_HANDLE_VALUE);

                ASSERT(szParentKey[NUMBER_OF(szSubKey) - NUMBER_OF(szEventSource)] == L'\\');
                szParentKey[NUMBER_OF(szSubKey) - NUMBER_OF(szEventSource)] = 0;

                ::RegDeleteValueW(hkey, szEventMessagFileName);
                ::RegDeleteValueW(hkey, szTypesSupportedName);

                lSubRet = ::RegOpenKeyExW(
                    hkeyEventLogRoot,
                    szParentKey,
                    0, // reserved options
                    KEY_WRITE | FUSIONP_KEY_WOW64_64KEY,
                    &hkeyParent);
                if (lSubRet == ERROR_SUCCESS)
                {
                    ::RegDeleteKeyW(hkeyParent, szEventSource);
                    ::RegCloseKey(hkeyParent);
                }
            }
        }
        ::RegCloseKey(hkey);
        fValidHkey = FALSE;
    }

    if (lRet != ERROR_SUCCESS)
    {
        ::SetLastError(lRet);
    }
    else
        fSuccess = TRUE;

    return fSuccess;
}

/*--------------------------------------------------------------------------
convert the upper two bits of an event id to the small numbered analogous
parameter to ReportEvent
--------------------------------------------------------------------------*/
static WORD
FusionpEventIdToEventType(
    DWORD dwEventId
    )
{
    switch (dwEventId >> 30)
    {
        case STATUS_SEVERITY_SUCCESS:       return EVENTLOG_SUCCESS;
        case STATUS_SEVERITY_WARNING:       return EVENTLOG_WARNING_TYPE;
        case STATUS_SEVERITY_INFORMATIONAL: return EVENTLOG_INFORMATION_TYPE;
        case STATUS_SEVERITY_ERROR:         return EVENTLOG_ERROR_TYPE;
        default: __assume(FALSE);
    }
     __assume(FALSE);
}

/*--------------------------------------------------------------------------
a Fusion event id and its corresponding Win32 lastError
the mapping is defined in Messages.x
--------------------------------------------------------------------------*/
struct EventIdErrorPair
{
    DWORD   dwEventId;
    LONG    nError;
};

/*--------------------------------------------------------------------------
the type of function used with bsearch
--------------------------------------------------------------------------*/
typedef int (__cdecl* PFNBSearchFunction)(const void*, const void*);

/*--------------------------------------------------------------------------
a function appropriate for use with bsearch
--------------------------------------------------------------------------*/
int __cdecl
CompareEventIdErrorPair(
    const EventIdErrorPair* x,
    const EventIdErrorPair* y
    )
{
    return
          (x->dwEventId < y->dwEventId) ?  -1
        : (x->dwEventId > y->dwEventId) ?  +1
        :                                   0;
}

const static EventIdErrorPair eventIdToErrorMap[] =
{
    #include "Messages.hi" // generated from .x file, like .mc
};

/*--------------------------------------------------------------------------
find the Win32 last error corresponding to this Fusion event id
--------------------------------------------------------------------------*/
DWORD
FusionpEventIdToError(
    DWORD dwEventId
    )
{
    DWORD dwFacility = HRESULT_FACILITY(dwEventId);
    if (dwFacility < 0x100)
    { // it's actually a system event id
        ASSERT2_NTC(FALSE, "system event id in " __FUNCTION__);
        return dwEventId;
    }
    static BOOL fSortVerified = FALSE;
    static BOOL fSorted = FALSE;
    if (!fSortVerified)
    {
        ULONG i;
        for (i = 0 ; i != NUMBER_OF(eventIdToErrorMap) - 1; ++i)
        {
            if (eventIdToErrorMap[i+1].dwEventId < eventIdToErrorMap[i].dwEventId)
            {
                break;
            }
        }
        if (i != NUMBER_OF(eventIdToErrorMap) - 1)
        {
            ASSERT2_NTC(FALSE, "eventIdToErrorMap is not sorted, reverting to linear search");
            fSorted = FALSE;
        }
        else
        {
            fSorted = TRUE;
        }
        fSortVerified = TRUE;
    }
    const EventIdErrorPair* found = NULL;
    const EventIdErrorPair key = { dwEventId };
    unsigned numberOf = NUMBER_OF(eventIdToErrorMap);

    if (fSorted)
    {
        found = reinterpret_cast<const EventIdErrorPair*>(
                    bsearch(
                        &key,
                        &eventIdToErrorMap,
                        numberOf,
                        sizeof(eventIdToErrorMap[0]),
                        reinterpret_cast<PFNBSearchFunction>(CompareEventIdErrorPair)));
    }
    else
    {
        found = reinterpret_cast<const EventIdErrorPair*>(
                    _lfind(
                        &key,
                        &eventIdToErrorMap,
                        &numberOf,
                        sizeof(eventIdToErrorMap[0]),
                        reinterpret_cast<PFNBSearchFunction>(CompareEventIdErrorPair)));
    }
    if (found == NULL)
    {
#if DBG
        CANSIStringBuffer msg;
        msg.Win32Format("Event id %lx not found in eventIdToErrorMap", static_cast<ULONG>(dwEventId));
        ASSERT2_NTC(found != NULL, const_cast<PSTR>(static_cast<PCSTR>(msg)));
#endif
        return ::FusionpGetLastWin32Error();
    }
    if (found->nError != 0)
    {
        return found->nError;
    }
    return ::FusionpGetLastWin32Error();
}

/*--------------------------------------------------------------------------
open the event log on demand
confusingly, this is called "registering" an event source
--------------------------------------------------------------------------*/
static
BOOL
FusionpOpenEventLog()
{
    HANDLE hEventLog;
    NTSTATUS status;
    if (g_fEventLogOpenAttempted)
    {
        goto Exit;
    }
    if (!FusionpRegisterEventLog())
    {
        goto Exit;
    }
    status = ::ElfRegisterEventSourceW(
        const_cast<UNICODE_STRING*>(&strMachine),
        const_cast<UNICODE_STRING*>(&strEventSource),
        &hEventLog);
    if (!NT_SUCCESS(status))
    {
        if (status != RPC_NT_SERVER_UNAVAILABLE)
            ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: FusionpOpenEventLog/ElfRegisterEventSourceW failed %lx\n", static_cast<ULONG>(status));
        goto Exit;
    }
    if (InterlockedCompareExchangePointer(
        &g_hEventLog,
        hEventLog, // exchange value
        NULL // compare value
        ) != NULL) // value returned is value that was there before we called
    {
        ::ElfDeregisterEventSource(hEventLog);
        goto Exit;
    }
    g_hEventLog = hEventLog;
Exit:
    g_fEventLogOpenAttempted = TRUE;
    return (g_hEventLog != NULL);
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

HRESULT
FusionpLogError(
    DWORD dwEventId,
    const UNICODE_STRING& s1,
    const UNICODE_STRING& s2,
    const UNICODE_STRING& s3,
    const UNICODE_STRING& s4
    )
{
    UNICODE_STRING const* rgps[] = { &s1, &s2, &s3, &s4 };
    return ::FusionpLogError(dwEventId, NUMBER_OF(rgps), rgps);
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

HRESULT
FusionpLogErrorToDebugger(
    DWORD dwEventId,
    const UNICODE_STRING& s1,
    const UNICODE_STRING& s2,
    const UNICODE_STRING& s3,
    const UNICODE_STRING& s4
    )
{
    UNICODE_STRING const* rgps[] = { &s1, &s2, &s3, &s4 };
    return FusionpLogErrorToDebugger(dwEventId, NUMBER_OF(rgps), rgps);
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

HRESULT
FusionpLogErrorToEventLog(
    DWORD dwEventId,
    const UNICODE_STRING& s1,
    const UNICODE_STRING& s2,
    const UNICODE_STRING& s3,
    const UNICODE_STRING& s4
    )
{
    UNICODE_STRING const* rgps[] = { &s1, &s2, &s3, &s4 };
    return FusionpLogErrorToEventLog(dwEventId, NUMBER_OF(rgps), rgps);
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

HRESULT
FusionpLogErrorToDebugger(
    DWORD dwEventId,
    ULONG nStrings,
    UNICODE_STRING const* const* rgps
    )
{
    const LONG  lastError = FusionpEventIdToError(dwEventId);
    const HRESULT hr = HRESULT_FROM_WIN32(lastError);

    UNICODE_STRING const* rgpsManyStrings[] =
    {
        &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString,
        &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString,
        &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString,
        &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString,
        &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString
    };
    if (nStrings < NUMBER_OF(rgpsManyStrings))
    {
        memcpy(rgpsManyStrings, rgps, nStrings * sizeof(rgps[0]));
        rgps = rgpsManyStrings;
    }

    DWORD dwFormatMessageFlags = 0;
    WCHAR rgchBuffer1[300];
    WCHAR rgchBuffer2[300];
    rgchBuffer1[0] = 0;
    rgchBuffer2[0] = 0;
    DWORD dw = 0;
    static const WCHAR rgchParseContextPrefix[] = PARSE_CONTEXT_PREFIX;
    PCWSTR pszSkipFirstLine = NULL;

    // load the string from the message table,
    // substituting %n with %n!wZ!
    // the Rtl limit here is 200, but we don't expect very many in our messages
    const static PCWSTR percentZw[] = { L"%1!wZ!", L"%2!wZ!", L"%3!wZ!", L"%4!wZ!", L"%5!wZ!",
                                        L"%6!wZ!", L"%7!wZ!", L"%8!wZ!", L"%9!wZ!", L"%10!wZ!",
                                        L"%11!wZ!", L"%12!wZ!", L"%13!wZ!", L"%14!wZ!", L"%15!wZ!"
                                        L"%16!wZ!", L"%17!wZ!", L"%18!wZ!", L"%19!wZ!", L"%20!wZ!"
                                      };

    dwFormatMessageFlags = FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_FROM_HMODULE;
    dw = FormatMessageW(
        dwFormatMessageFlags,
        g_hInstance,
        dwEventId,
        0, // langid
        rgchBuffer1,
        NUMBER_OF(rgchBuffer1),
        const_cast<va_list*>(reinterpret_cast<const va_list*>(&percentZw)));
    if (dw == 0)
    {
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: FusionpLogError/FormatMessageW failed %ld\n", static_cast<long>(FusionpGetLastWin32Error()));
        goto Exit;
    }

    // do the substitutions
    dwFormatMessageFlags = FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_FROM_STRING;
    dw = FormatMessageW(
        dwFormatMessageFlags,
        rgchBuffer1,
        0, // message id
        0, // langid
        rgchBuffer2,
        NUMBER_OF(rgchBuffer2),
        reinterpret_cast<va_list*>(const_cast<UNICODE_STRING**>(rgps)));
    if (dw == 0)
    {
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: FusionpLogError/FormatMessageW failed %ld\n", static_cast<long>(FusionpGetLastWin32Error()));
        goto Exit;
    }

    //
    // acceptable hack
    //
    // The first line of parse errors is a verbose context, see Messages.x.
    // For DbgPrint we want instead file(line): on the same line instead.
    // We make that transformation here.
    //
    pszSkipFirstLine = wcschr(rgchBuffer2, '\n');
    BOOL fAreWeInOSSetupMode = FALSE;
    FusionpAreWeInOSSetupMode(&fAreWeInOSSetupMode);
    if (
        pszSkipFirstLine != NULL
        && nStrings >= PARSE_CONTEXT_INSERTS_END
        && memcmp(rgchBuffer2, rgchParseContextPrefix, sizeof(rgchParseContextPrefix)-sizeof(WCHAR)) == 0
        )
    {
        // we might fiddle with the form of the newline, so skip whatever is there
        while (wcschr(L"\r\n", *pszSkipFirstLine) != NULL)
            pszSkipFirstLine += 1;

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR | ( fAreWeInOSSetupMode ? FUSION_DBG_LEVEL_SETUPLOG : 0),
            //FUSION_DBG_LEVEL_ERROR,
            "%wZ(%wZ): %S",
            rgps[PARSE_CONTEXT_FILE - 1],
            rgps[PARSE_CONTEXT_LINE - 1],
            pszSkipFirstLine);
    }
    else
    {
        // just print it verbatim
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR | ( fAreWeInOSSetupMode ? FUSION_DBG_LEVEL_SETUPLOG : 0),
            //FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %S",
            rgchBuffer2);
    }
Exit:
    ::SetLastError(lastError);
    return hr;
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

HRESULT
FusionpLogErrorToEventLog(
    DWORD dwEventId,
    ULONG nStrings,
    UNICODE_STRING const* const* rgps
    )
{
    const LONG  lastError = FusionpEventIdToError(dwEventId);
    const HRESULT hr = HRESULT_FROM_WIN32(lastError);

    const WORD  wType = FusionpEventIdToEventType(dwEventId);
    // The use of the lower bits of the hresult facility as the event log
    // facility is my own invention, but it seems a good one.
    // ReportEvent has too many parameters, those three integers instead of one.
    const WORD  wCategory = 0/*static_cast<WORD>(HRESULT_FACILITY(dwEventId) & 0xff)*/;
    const DWORD dwDataSize = 0;
    void const* const pvRawData = NULL;
    const PSID pSecurityIdentifier = NULL;

    if (!::FusionpOpenEventLog())
    {
        //::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: FusionpOpenEventLog failed\n"); // error msg has print before exit
        goto Exit;
    }
    else
    {
        NTSTATUS status;
        status = ::ElfReportEventW(
            g_hEventLog,
            wType,
            wCategory,
            dwEventId,
            pSecurityIdentifier,
            static_cast<USHORT>(nStrings),
            dwDataSize,
            const_cast<UNICODE_STRING**>(rgps),
            const_cast<void*>(pvRawData),
            0,
            NULL,
            NULL);
        //
        // the excluded error status is because it is in the early setup time.
        //
        if (!NT_SUCCESS(status))
        {
             if (status != RPC_NT_SERVER_UNAVAILABLE)
                ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: FusionpLogError/ElfReportEventW failed %lx\n", static_cast<ULONG>(status));
            goto Exit;
        }
    }
Exit:
    ::SetLastError(lastError);
    return hr;
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

HRESULT
FusionpLogError(
    DWORD dwEventId,
    ULONG nStrings,
    UNICODE_STRING const* const* rgps
    )
{
    const HRESULT hr = FusionpLogErrorToEventLog(dwEventId, nStrings, rgps);
    const HRESULT hr2 = FusionpLogErrorToDebugger(dwEventId, nStrings, rgps);
    RETAIL_UNUSED(hr);
    RETAIL_UNUSED(hr2);
    ASSERT_NTC(hr == hr2);

    return hr;
}

HRESULT
FusionpLogParseError(
    PCWSTR FilePath,
    SIZE_T FilePathCch,
    ULONG LineNumber,
    DWORD dwLastParseError,
    const UNICODE_STRING *p1,
    const UNICODE_STRING *p2,
    const UNICODE_STRING *p3,
    const UNICODE_STRING *p4,
    const UNICODE_STRING *p5,
    const UNICODE_STRING *p6,
    const UNICODE_STRING *p7,
    const UNICODE_STRING *p8,
    const UNICODE_STRING *p9,
    const UNICODE_STRING *p10,
    const UNICODE_STRING *p11,
    const UNICODE_STRING *p12,
    const UNICODE_STRING *p13,
    const UNICODE_STRING *p14,
    const UNICODE_STRING *p15,
    const UNICODE_STRING *p16,
    const UNICODE_STRING *p17,
    const UNICODE_STRING *p18,
    const UNICODE_STRING *p19,
    const UNICODE_STRING *p20
    )
{
    const DWORD lastError = ::FusionpEventIdToError(dwLastParseError);
    const HRESULT hr = HRESULT_FROM_WIN32(lastError);

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INFO,
        "SXS.DLL: %s() entered\n", __FUNCTION__);

    //
    // FormatMessage (actually sprintf) AVs on NULL UNICODE_STRING*
    // and/or when we don't pass enough of them;
    // we can't tell it how many strings we are passing,
    // and it isn't easy to tell how many it needs,
    // so we load it up with a bunch of extra non NULL ones.
    // Besides that, we have holes to fill.
    //
    static const UNICODE_STRING s_strEmptyUnicodeString = { 0, 0, L""};
    static UNICODE_STRING const* const s_rgpsEmptyStrings[] =
    {
        &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString,
        &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString,
        &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString,
        &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString,
        &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString
    };
    UNICODE_STRING const* rgpsAll[NUMBER_OF(s_rgpsEmptyStrings)];

    memcpy(&rgpsAll, s_rgpsEmptyStrings, sizeof(rgpsAll));

#define HANDLE_STRING(_n) do { if (p ## _n != NULL) rgpsAll[_n - 1] = p ## _n; } while (0)

    HANDLE_STRING(1);
    HANDLE_STRING(2);
    HANDLE_STRING(3);
    HANDLE_STRING(4);
    HANDLE_STRING(5);
    HANDLE_STRING(6);
    HANDLE_STRING(7);
    HANDLE_STRING(8);
    HANDLE_STRING(9);
    HANDLE_STRING(10);
    HANDLE_STRING(11);
    HANDLE_STRING(12);
    HANDLE_STRING(13);
    HANDLE_STRING(14);
    HANDLE_STRING(15);
    HANDLE_STRING(16);
    HANDLE_STRING(17);
    HANDLE_STRING(18);
    HANDLE_STRING(19);
    HANDLE_STRING(20);

#undef HANDLE_STRING

    //
    // form up some "context" UNICODE_STRINGs and put them in the array of pointers
    // the first two are the ones that we always use, even for DbgPrint
    //
    CEventLogString file(FilePath, FilePathCch);
    CEventLogInteger lineNumber(LineNumber);

    rgpsAll[PARSE_CONTEXT_FILE - 1] = &file;
    rgpsAll[PARSE_CONTEXT_LINE - 1] = &lineNumber;

    ::FusionpLogErrorToEventLog(
        dwLastParseError,
        NUMBER_OF(rgpsAll),
        rgpsAll);

    // we should tell this function that it was a parse error and to do
    // the context munging, but it detects it itself imperfectly
    ::FusionpLogErrorToDebugger(dwLastParseError, NUMBER_OF(rgpsAll), rgpsAll);

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INFO,
        "SXS.DLL: %s():%#lx exited\n", __FUNCTION__, hr);

    ::SetLastError(lastError);
    return hr;
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

VOID
FusionpLogRequiredAttributeMissingParseError(
    PCWSTR SourceFilePath,
    SIZE_T SourceFileCch,
    ULONG LineNumber,
    PCWSTR ElementName,
    SIZE_T ElementNameCch,
    PCWSTR AttributeName,
    SIZE_T AttributeNameCch
    )
{
    ::FusionpLogParseError(
        SourceFilePath,
        SourceFileCch,
        LineNumber,
        MSG_SXS_XML_REQUIRED_ATTRIBUTE_MISSING,
        CEventLogString(ElementName, ElementNameCch),
        CEventLogString(AttributeName, AttributeNameCch));
}

VOID
FusionpLogInvalidAttributeValueParseError(
    PCWSTR SourceFilePath,
    SIZE_T SourceFileCch,
    ULONG LineNumber,
    PCWSTR ElementName,
    SIZE_T ElementNameCch,
    PCWSTR AttributeName,
    SIZE_T AttributeNameCch
    )
{
    ::FusionpLogParseError(
        SourceFilePath,
        SourceFileCch,
        LineNumber,
        MSG_SXS_XML_INVALID_ATTRIBUTE_VALUE,
        CEventLogString(ElementName, ElementNameCch),
        CEventLogString(AttributeName, AttributeNameCch));
}

VOID
FusionpLogInvalidAttributeValueParseError(
    PCWSTR SourceFilePath,
    SIZE_T SourceFileCch,
    ULONG LineNumber,
    PCWSTR ElementName,
    SIZE_T ElementNameCch,
    const SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE &rAttribute
    )
{
    ::FusionpLogInvalidAttributeValueParseError(
        SourceFilePath,
        SourceFileCch,
        LineNumber,
        ElementName,
        ElementNameCch,
        rAttribute.Name,
        rAttribute.NameCch);
}

VOID
FusionpLogAttributeNotAllowedParseError(
    PCWSTR SourceFilePath,
    SIZE_T SourceFileCch,
    ULONG LineNumber,
    PCWSTR ElementName,
    SIZE_T ElementNameCch,
    PCWSTR AttributeName,
    SIZE_T AttributeNameCch
    )
{
    ::FusionpLogParseError(
        SourceFilePath,
        SourceFileCch,
        LineNumber,
        MSG_SXS_XML_ATTRIBUTE_NOT_ALLOWED,
        CEventLogString(ElementName, ElementNameCch),
        CEventLogString(AttributeName, AttributeNameCch));
}

VOID
FusionpLogWin32ErrorToEventLog()
{
    DWORD dwLastError = ::FusionpGetLastWin32Error();
    if (dwLastError == 0 )
        return;
    FusionpLogError(MSG_SXS_WIN32_ERROR_MSG, CEventLogLastError(dwLastError));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\id\stdinc.h ===
#pragma once
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "fusionlastwin32error.h"
#include "fusionunused.h"
#define MAXDWORD (~(DWORD)0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\id\encdec.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sxsasmidencdec.c

Abstract:

    Implementation of the encoding/decoding support for the assembly identity data type.

Author:

    Michael Grier (MGrier) 7/28/2000

Revision History:

--*/
#include "stdinc.h"
#include <setupapi.h>
#include <sxsapi.h>
#include <stdlib.h>
#include <search.h>
#include "idp.h"
static const WCHAR s_rgHexChars[] = L"0123456789abcdef";

BOOL
SxspValidateXMLName(
    PCWSTR psz,
    SIZE_T cch,
    bool &rfValid
    );

typedef struct _CHARPAIR
{
    WCHAR wchStart;
    WCHAR wchEnd;
} CHARPAIR, *PCHARPAIR;

typedef const CHARPAIR *PCCHARPAIR;

const CHARPAIR s_rgXMLBaseChar[] =
{
    { 0x0041, 0x005a },
    { 0x0061, 0x007a },
    { 0x00c0, 0x00d6 },
    { 0x00d8, 0x00f6 },
    { 0x00f8, 0x00ff },
    { 0x0100, 0x0131 },
    { 0x0134, 0x013e },
    { 0x0141, 0x0148 },
    { 0x014a, 0x017e },
    { 0x0180, 0x01c3 },
    { 0x01cd, 0x01f0 },
    { 0x01f4, 0x01f5 },
    { 0x01fa, 0x0217 },
    { 0x0250, 0x02a8 },
    { 0x02bb, 0x02c1 },
    { 0x0386, 0x0386 },
    { 0x0388, 0x038a },
    { 0x038c, 0x038c },
    { 0x038e, 0x03a1 },
    { 0x03a3, 0x03ce },
    { 0x03d0, 0x03d6 },
    { 0x03da, 0x03da },
    { 0x03dc, 0x03dc },
    { 0x03de, 0x03de },
    { 0x03e0, 0x03e0 },
    { 0x03e2, 0x03f3 },
    { 0x0401, 0x040c },
    { 0x040e, 0x044f },
    { 0x0451, 0x045c },
    { 0x045e, 0x0481 },
    { 0x0490, 0x04c4 },
    { 0x04c7, 0x04c8 },
    { 0x04cb, 0x04cc },
    { 0x04d0, 0x04eb },
    { 0x04ee, 0x04f5 },
    { 0x04f8, 0x04f9 },
    { 0x0531, 0x0556 },
    { 0x0559, 0x0559 },
    { 0x0561, 0x0586 },
    { 0x05d0, 0x05ea },
    { 0x05f0, 0x05f2 },
    { 0x0621, 0x063a },
    { 0x0641, 0x064a },
    { 0x0671, 0x06b7 },
    { 0x06ba, 0x06be },
    { 0x06c0, 0x06ce },
    { 0x06d0, 0x06d3 },
    { 0x06d5, 0x06d5 },
    { 0x06e5, 0x06e6 },
    { 0x0905, 0x0939 },
    { 0x093d, 0x093d },
    { 0x0958, 0x0961 },
    { 0x0985, 0x098c },
    { 0x098f, 0x0990 },
    { 0x0993, 0x09a8 },
    { 0x09aa, 0x09b0 },
    { 0x09b2, 0x09b2 },
    { 0x09b6, 0x09b9 },
    { 0x09dc, 0x09dd },
    { 0x09df, 0x09e1 },
    { 0x09f0, 0x09f1 },
    { 0x0a05, 0x0a0a },
    { 0x0a0f, 0x0a10 },
    { 0x0a13, 0x0a28 },
    { 0x0a2a, 0x0a30 },
    { 0x0a32, 0x0a33 },
    { 0x0a35, 0x0a36 },
    { 0x0a38, 0x0a39 },
    { 0x0a59, 0x0a5c },
    { 0x0a5e, 0x0a5e },
    { 0x0a72, 0x0a74 },
    { 0x0a85, 0x0a8b },
    { 0x0a8d, 0x0a8d },
    { 0x0a8f, 0x0a91 },
    { 0x0a93, 0x0aa8 },
    { 0x0aaa, 0x0ab0 },
    { 0x0ab2, 0x0ab3 },
    { 0x0ab5, 0x0ab9 },
    { 0x0abd, 0x0abd },
    { 0x0ae0, 0x0ae0 },
    { 0x0b05, 0x0b0c },
    { 0x0b0f, 0x0b10 },
    { 0x0b13, 0x0b28 },
    { 0x0b2a, 0x0b30 },
    { 0x0b32, 0x0b33 },
    { 0x0b36, 0x0b39 },
    { 0x0b3d, 0x0b3d },
    { 0x0b5c, 0x0b5d },
    { 0x0b5f, 0x0b61 },
    { 0x0b85, 0x0b8a },
    { 0x0b8e, 0x0b90 },
    { 0x0b92, 0x0b95 },
    { 0x0b99, 0x0b9a },
    { 0x0b9c, 0x0b9c },
    { 0x0b9e, 0x0b9f },
    { 0x0ba3, 0x0ba4 },
    { 0x0ba8, 0x0baa },
    { 0x0bae, 0x0bb5 },
    { 0x0bb7, 0x0bb9 },
    { 0x0c05, 0x0c0c },
    { 0x0c0e, 0x0c10 },
    { 0x0c12, 0x0c28 },
    { 0x0c2a, 0x0c33 },
    { 0x0c35, 0x0c39 },
    { 0x0c60, 0x0c61 },
    { 0x0c85, 0x0c8c },
    { 0x0c8e, 0x0c90 },
    { 0x0c92, 0x0ca8 },
    { 0x0caa, 0x0cb3 },
    { 0x0cb5, 0x0cb9 },
    { 0x0cde, 0x0cde },
    { 0x0ce0, 0x0ce1 },
    { 0x0d05, 0x0d0c },
    { 0x0d0e, 0x0d10 },
    { 0x0d12, 0x0d28 },
    { 0x0d2a, 0x0d39 },
    { 0x0d60, 0x0d61 },
    { 0x0e01, 0x0e2e },
    { 0x0e30, 0x0e30 },
    { 0x0e32, 0x0e33 },
    { 0x0e40, 0x0e45 },
    { 0x0e81, 0x0e82 },
    { 0x0e84, 0x0e84 },
    { 0x0e87, 0x0e88 },
    { 0x0e8a, 0x0e8a },
    { 0x0e8d, 0x0e8d },
    { 0x0e94, 0x0e97 },
    { 0x0e99, 0x0e9f },
    { 0x0ea1, 0x0ea3 },
    { 0x0ea5, 0x0ea5 },
    { 0x0ea7, 0x0ea7 },
    { 0x0eaa, 0x0eab },
    { 0x0ead, 0x0eae },
    { 0x0eb0, 0x0eb0 },
    { 0x0eb2, 0x0eb3 },
    { 0x0ebd, 0x0ebd },
    { 0x0ec0, 0x0ec4 },
    { 0x0f40, 0x0f47 },
    { 0x0f49, 0x0f69 },
    { 0x10a0, 0x10c5 },
    { 0x10d0, 0x10f6 },
    { 0x1100, 0x1100 },
    { 0x1102, 0x1103 },
    { 0x1105, 0x1107 },
    { 0x1109, 0x1109 },
    { 0x110b, 0x110c },
    { 0x110e, 0x1112 },
    { 0x113c, 0x113c },
    { 0x113e, 0x113e },
    { 0x1140, 0x1140 },
    { 0x114c, 0x114c },
    { 0x114e, 0x114e },
    { 0x1150, 0x1150 },
    { 0x1154, 0x1155 },
    { 0x1159, 0x1159 },
    { 0x115f, 0x1161 },
    { 0x1163, 0x1163 },
    { 0x1165, 0x1165 },
    { 0x1167, 0x1167 },
    { 0x1169, 0x1169 },
    { 0x116d, 0x116e },
    { 0x1172, 0x1173 },
    { 0x1175, 0x1175 },
    { 0x119e, 0x119e },
    { 0x11a8, 0x11a8 },
    { 0x11ab, 0x11ab },
    { 0x11ae, 0x11af },
    { 0x11b7, 0x11b8 },
    { 0x11ba, 0x11ba },
    { 0x11bc, 0x11c2 },
    { 0x11eb, 0x11eb },
    { 0x11f0, 0x11f0 },
    { 0x11f9, 0x11f9 },
    { 0x1e00, 0x1e9b },
    { 0x1ea0, 0x1ef9 },
    { 0x1f00, 0x1f15 },
    { 0x1f18, 0x1f1d },
    { 0x1f20, 0x1f45 },
    { 0x1f48, 0x1f4d },
    { 0x1f50, 0x1f57 },
    { 0x1f59, 0x1f59 },
    { 0x1f5b, 0x1f5b },
    { 0x1f5d, 0x1f5d },
    { 0x1f5f, 0x1f7d },
    { 0x1f80, 0x1fb4 },
    { 0x1fb6, 0x1fbc },
    { 0x1fbe, 0x1fbe },
    { 0x1fc2, 0x1fc4 },
    { 0x1fc6, 0x1fcc },
    { 0x1fd0, 0x1fd3 },
    { 0x1fd6, 0x1fdb },
    { 0x1fe0, 0x1fec },
    { 0x1ff2, 0x1ff4 },
    { 0x1ff6, 0x1ffc },
    { 0x2126, 0x2126 },
    { 0x212a, 0x212b },
    { 0x212e, 0x212e },
    { 0x2180, 0x2182 },
    { 0x3041, 0x3094 },
    { 0x30a1, 0x30fa },
    { 0x3105, 0x312c },
    { 0xac00, 0xd7a3 },
};

BOOL
SxsComputeAssemblyIdentityEncodedSize(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN const GUID *EncodingGroup OPTIONAL,
    IN ULONG EncodingFormat,
    OUT SIZE_T *SizeOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T Size = 0;
    ULONG i;
    ULONG AttributeCount, NamespaceCount;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = NULL;

    if (SizeOut != NULL)
        *SizeOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(SizeOut != NULL);

    if (EncodingGroup != NULL)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(UnknownEncodingGroup, ERROR_SXS_UNKNOWN_ENCODING_GROUP);

    if ((EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY) &&
        (EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL))
        ORIGINATE_WIN32_FAILURE_AND_EXIT(UnknownEncodingId, ERROR_SXS_UNKNOWN_ENCODING);

    IFW32FALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    AttributeCount = AssemblyIdentity->AttributeCount;
    NamespaceCount = AssemblyIdentity->NamespaceCount;
    AttributePointerArray = AssemblyIdentity->AttributePointerArray;
    NamespacePointerArray = AssemblyIdentity->NamespacePointerArray;

    switch (EncodingFormat)
    {
    case SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY:
        // First, we know we need a header.

        Size = sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER);

        // Then a ULONG hash per attribute:
        Size += (AssemblyIdentity->AttributeCount * sizeof(ULONG));

        // Then a USHORT per namespace...
        Size += (AssemblyIdentity->NamespaceCount * sizeof(ULONG));

        // Then we need an attribute header per attribute:

        Size += AssemblyIdentity->AttributeCount * sizeof(ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER);

        // Then come the namespace strings...

        for (i=0; i<NamespaceCount; i++)
            Size += NamespacePointerArray[i]->NamespaceCch * sizeof(WCHAR);

        // Then we need space for each of the attributes' names and value.

        AttributePointerArray = AssemblyIdentity->AttributePointerArray;

        for (i=0; i<AttributeCount; i++)
        {
            INTERNAL_ERROR_CHECK(AttributePointerArray[i] != NULL);

            Size += AttributePointerArray[i]->Attribute.NameCch * sizeof(WCHAR);
            Size += AttributePointerArray[i]->Attribute.ValueCch * sizeof(WCHAR);
        }

        // We should at least be byte aligned here...
        ASSERT((Size % 2) == 0);

        // And finally pad out to a multiple of four if we are not...
        Size = (Size + 3) & ~3;

        break;

    case SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL:
        for (i=0; i<AttributeCount; i++)
        {
            PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute = AttributePointerArray[i];
            BOOL IsAssemblyName = FALSE;
            SIZE_T BytesThisAttribute = 0;

            INTERNAL_ERROR_CHECK(Attribute != NULL);

            IFW32FALSE_EXIT(SxspIsInternalAssemblyIdentityAttribute(
                                0,
                                Attribute,
                                NULL,
                                0,
                                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME,
                                NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME) - 1,
                                &IsAssemblyName));

            // It's the attribute name.  Just account for the size of the encoded value string
            IFW32FALSE_EXIT(::SxspComputeInternalAssemblyIdentityAttributeEncodedTextualSize(
                            IsAssemblyName ?
                                SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_VALUE_ONLY |
                                    SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_OMIT_QUOTES
                                    : 0,
                            Attribute,
                            &BytesThisAttribute));

            // Account for the separator character
            if (i != 0)
                Size += sizeof(WCHAR);

            Size += BytesThisAttribute;
        }

        break;
    }

    *SizeOut = Size;

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspComputeQuotedStringSize(
    IN DWORD Flags,
    IN const WCHAR *StringIn,
    IN SIZE_T Cch,
    OUT SIZE_T *BytesOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T Bytes = 0;

    if (BytesOut != NULL)
        *BytesOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(StringIn != NULL || Cch == 0);
    PARAMETER_CHECK(BytesOut != NULL);

    while (Cch != 0)
    {
        const WCHAR wch = *StringIn++;

        if (((wch >= L'A') && (wch <= L'Z')) ||
            ((wch >= L'a') && (wch <= L'z')) ||
            ((wch >= L'0') && (wch <= L'9')) ||
            (wch == L'.') ||
            (wch == L'-') ||
            (wch == L'_'))
        {
            Bytes += sizeof(WCHAR);
        }
        else
        {
            switch (wch)
            {
            case L'&':
                // &amp;
                Bytes += (5 * sizeof(WCHAR));
                break;

            case L'"':
                // &quot;
                Bytes += (6 * sizeof(WCHAR));
                break;

            case L'<':
                // &lt;
                Bytes += (4 * sizeof(WCHAR));
                break;

            case L'>':
                // &gt;
                Bytes += (4 * sizeof(WCHAR));
                break;

            case L'\'':
                // &apos;
                Bytes += (6 * sizeof(WCHAR));
                break;

            default:
                // Otherwise, it's going to be &#xn;
                if (wch < 0x10)
                    Bytes += (5 * sizeof(WCHAR));
                else if (wch < 0x100)
                    Bytes += (6 * sizeof(WCHAR));
                else if (wch < 0x1000)
                    Bytes += (7 * sizeof(WCHAR));
                else
                    Bytes += (8 * sizeof(WCHAR));
                break;
            }
        }

        Cch--;
    }

    *BytesOut = Bytes;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

#if 0

#define QUOTE_CHAR_HEADER_STRING (L"&#x")
#define QUOTE_CHAR_HEADER_STRING_CCH (NUMBER_OF(QUOTE_CHAR_HEADER_STRING) - 1)

BOOL
SxspQuoteString(
    IN DWORD dwFlags,
    IN PCWSTR pcwszStringIn,
    IN SIZE_T cbStringInCch,
    OUT PWSTR pwszStringOut,
    IN OUT SIZE_T *pcbWrittenBytes
    )
{
    FN_PROLOG_WIN32

    SIZE_T cbOutputBuffer;
    PCWSTR pcwszCursor = pcwszStringIn;
    PWSTR pwszOutputCursor = pwszStringOut;
    BOOL fInsufficient = FALSE;

    if ( pcbWrittenBytes != NULL ) {
        cbOutputBuffer = *pcbWrittenBytes;
        *pcbWrittenBytes = 0
    }

    if ( pwszStringOut == NULL )
    {
        cbOutputBuffer = NULL;
        pwszOutputCursor = NULL;
    }

    while ( ( cbStringInCch != 0 ) && ( pcwszCursor != NULL ) )
    {
        ULONG ulFoundQuoteMatch;
        SIZE_T cchReplacement;
        PCWSTR pcwszReplacement;

        const WCHAR wchThisCharacter = *pcwszCursor;

        // Some characters we know and love
        if (iswalnum(wchThisCharacter) ||
            (wchThisCharacter == L'.') ||
            (wchThisCharacter == L'_') ||
            (wchThisCharacter == L'-'))
        {
            if ( cbOutputBuffer > 0 )
            {
                *pwszOutputCursor++ = wchThisCharacter;
                cbOutputBuffer--;
            }
            (*pcbWrittenBytes)++;
            continue;
        }


#define ADD_IF_REMAINING_AND_UPDATE( target, targetcch, targetcchoutput, toadd, toaddcch ) { \
    if ( (targetcch) > (toaddcch) ) { \
        wcsncpy( target, toadd, toaddcch ); \
        (targetcch) -= (toaddcch);    }  \
    (targetcchoutput) += toaddcch; }

#define HANDLE_CASE(c, v) case (c) : \
    if (cbOutputBuffer > NUMBER_OF(v)) { \
        wcsncpy(pwszOutputCursor, (v), NUMBER_OF(v)); \
        pwszOutputCursor += NUMBER_OF(v); \
        cbOutputBuffer -= NUMBER_OF(v);\
        (*cbOutputBuffer) += NUMBER_OF(v); \
    } else fInsufficient = TRUE; \    
    break;

        switch( wchThisCharacter )
        {
        HANDLE_CASE(L'"', L"&quot;")
        HANDLE_CASE(L'&', L"&amp;")
        HANDLE_CASE(L'<', L"&lt;")
        HANDLE_CASE(L'>', L"&gt;")
        HANDLE_CASE(L'\'', L"&apos;")

#define ADD_ESCAPE_HEADER_AND_INCREMENT(h) (h)[0] = L'&'; (h)[1] = L'#'; (h)[2] = L'x'; (h) += 3;

        default:
            if (wchThisCharacter < 0x10) {
                ADD_IF_REMAINING_AND_UPDATE(
                    pwszOutputCursor,
                    cbOutputBuffer,
                    (*pcbWrittenBytes),
                    QUOTE_CHAR_HEADER_STRING,
                    QUOTE_CHAR_HEADER_STRING_CCH);

                pwszOutputCursor[0] = s_rgHexChars[wchThisCharacter & 0xf];


                APPEND_TAIL_AND_INCREMENT(
            } else if (wchThisCharacter < 0x100) {
            } else if (wchThisCharacter < 0x1000) {
            } else if (wchThisCharacter <= 0xffff) {
            }
        }

    }

    FN_EPILOG
}
#endif

BOOL
SxspDequoteString(
    IN DWORD dwFlags,
    IN PCWSTR pcwszStringIn,
    IN SIZE_T cchStringIn,
    OUT PWSTR pwszStringOut,
    OUT SIZE_T *pcchStringOut
    )
{
    FN_PROLOG_WIN32

    PCWSTR pcwszInputCursor = pcwszStringIn;
    PWSTR pwszOutputCursor = pwszStringOut;
    PCWSTR pcwszInputCursorEnd = pcwszStringIn + cchStringIn;
    SIZE_T cchOutputRemaining = 0;
    BOOL fInsufficient = FALSE;

    PARAMETER_CHECK(dwFlags == 0);

    if (pcchStringOut != NULL)
    {
        cchOutputRemaining = *pcchStringOut;
        *pcchStringOut = 0;
    }

    if (pwszStringOut != NULL)
        pwszStringOut[0] = UNICODE_NULL;

    PARAMETER_CHECK(pcchStringOut != NULL);

    //
    // reserve one wchar for trailing NULL
    //
#define APPEND_OUTPUT_CHARACTER( toadd ) { \
    if ( cchOutputRemaining > 1 ) { \
        *pwszOutputCursor++ = (toadd); \
        cchOutputRemaining--; \
        (*pcchStringOut)++; \
    } else fInsufficient = TRUE; \
}

#define CONTAINS_TAG(tag) (FusionpCompareStrings(pcwszInputCursor, cchToNextSemicolon, (tag), NUMBER_OF(tag)-1, false) == 0)

#define REPLACE_TAG( tag, newchar ) if ( CONTAINS_TAG(tag) ) { APPEND_OUTPUT_CHARACTER(newchar) }

    //
    // Zing through the input string until there's nothing left
    //
    while ((pcwszInputCursor < pcwszInputCursorEnd) && (!fInsufficient))
    {
        const WCHAR wchCurrent = *pcwszInputCursor;

        // Something we know and love?
        if (wchCurrent == L'&')
        {
            pcwszInputCursor++;
            SIZE_T cchToNextSemicolon = StringComplimentSpan(
                pcwszInputCursor,
                pcwszInputCursorEnd,
                L";");
            PCWSTR pcwszSemicolon = pcwszInputCursor + cchToNextSemicolon;

            REPLACE_TAG(L"amp", L'&')
            else REPLACE_TAG(L"quot", L'"')
            else REPLACE_TAG(L"lt", L'<')
            else REPLACE_TAG(L"gt", L'>')
            else REPLACE_TAG(L"apos", L'\'')
            // This might be an encoded character...
            else if ( cchToNextSemicolon >= 2 )
            {
                bool fIsHexString = false;
                WCHAR wchReplacement = 0;

                // The only non-chunk think accepted is the # character
                PARAMETER_CHECK(*pcwszInputCursor == L'#');

                // which means we've skipped one
                pcwszInputCursor++;

                fIsHexString = (*pcwszInputCursor == L'x') || (*pcwszInputCursor == 'X');
                if (fIsHexString) {
                    pcwszInputCursor++;
                }

                while ( pcwszInputCursor != pcwszSemicolon )
                {
                    if ( fIsHexString )
                    {
                        wchReplacement <<= 4;
                        switch ( *pcwszInputCursor++ ) {
                        case L'0' : break;
                        case L'1' : wchReplacement += 0x1; break;
                        case L'2' : wchReplacement += 0x2; break;
                        case L'3' : wchReplacement += 0x3; break;
                        case L'4' : wchReplacement += 0x4; break;
                        case L'5' : wchReplacement += 0x5; break;
                        case L'6' : wchReplacement += 0x6; break;
                        case L'7' : wchReplacement += 0x7; break;
                        case L'8' : wchReplacement += 0x8; break;
                        case L'9' : wchReplacement += 0x9; break;
                        case L'a': case L'A': wchReplacement += 0xA; break;
                        case L'b': case L'B': wchReplacement += 0xB; break;
                        case L'c': case L'C': wchReplacement += 0xC; break;
                        case L'd': case L'D': wchReplacement += 0xD; break;
                        case L'e': case L'E': wchReplacement += 0xE; break;
                        case L'f': case L'F': wchReplacement += 0xF; break;
                        default:
                            PARAMETER_CHECK(FALSE && L"wchReplacement contains a non-hex digit");
                            break;
                        }
                    }
                    else
                    {
                        wchReplacement *= 10;
                        switch ( *pcwszInputCursor++ ) {
                        case L'0' : break;
                        case L'1' : wchReplacement += 0x1; break;
                        case L'2' : wchReplacement += 0x2; break;
                        case L'3' : wchReplacement += 0x3; break;
                        case L'4' : wchReplacement += 0x4; break;
                        case L'5' : wchReplacement += 0x5; break;
                        case L'6' : wchReplacement += 0x6; break;
                        case L'7' : wchReplacement += 0x7; break;
                        case L'8' : wchReplacement += 0x8; break;
                        case L'9' : wchReplacement += 0x9; break;
                        default:
                            PARAMETER_CHECK(FALSE && "wchReplacement contains a non-decimal digit");
                            break;
                        }
                    }
                }

                APPEND_OUTPUT_CHARACTER(wchReplacement);
            }

            if (!fInsufficient) 
                pcwszInputCursor = pcwszSemicolon + 1;
        }
        // Otherwise, simply copy the character to the output string
        else
        {
            APPEND_OUTPUT_CHARACTER(wchCurrent);
            if (!fInsufficient) 
                pcwszInputCursor++;
        }
    }

    if (fInsufficient)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

    pwszStringOut[*pcchStringOut] = L'\0';

    FN_EPILOG
}

BOOL
SxspQuoteString(
    IN DWORD Flags,
    IN const WCHAR *StringIn,
    IN SIZE_T Cch,
    IN SIZE_T BufferSize,
    IN PVOID Buffer,
    OUT SIZE_T *BytesWrittenOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    WCHAR *Cursor;
    SIZE_T BytesWritten = 0;
    SIZE_T BytesLeft = BufferSize;

    if (BytesWrittenOut != NULL)
        *BytesWrittenOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(StringIn != NULL || Cch == 0);
    PARAMETER_CHECK(Buffer != NULL || BufferSize == 0);

    Cursor = (WCHAR *) Buffer;
    BytesWritten = 0;

    while (Cch != 0)
    {
        const WCHAR wch = *StringIn++;

        if (((wch >= L'A') && (wch <= L'Z')) ||
            ((wch >= L'a') && (wch <= L'z')) ||
            ((wch >= L'0') && (wch <= L'9')) ||
            (wch == L'.') ||
            (wch == L'-') ||
            (wch == L'_'))
        {
            if (BytesLeft < sizeof(WCHAR))
                ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

            *Cursor++ = wch;
            BytesLeft -= sizeof(WCHAR);
            BytesWritten += sizeof(WCHAR);
        }
        else
        {

#define HANDLE_CASE(_wch, _wstr) \
            case _wch: \
            { \
            ULONG i; \
            if (BytesLeft < (sizeof(_wstr) - sizeof(WCHAR))) \
                ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER); \
            for (i=0; i<(NUMBER_OF(_wstr) - 1); i++) \
                *Cursor++ = _wstr[i]; \
            BytesLeft -= (sizeof(_wstr) - sizeof(WCHAR)); \
            BytesWritten += (sizeof(_wstr) - sizeof(WCHAR)); \
            break; \
            }

            switch (wch)
            {
            HANDLE_CASE(L'"', L"&quot;")
            HANDLE_CASE(L'&', L"&amp;")
            HANDLE_CASE(L'<', L"&lt;")
            HANDLE_CASE(L'>', L"&gt;")
            HANDLE_CASE(L'\'', L"&apos;")

            default:
                if (wch < 0x10)
                {
                    if (BytesLeft < (5 * sizeof(WCHAR)))
                        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

                    *Cursor++ = L'&';
                    *Cursor++ = L'#';
                    *Cursor++ = L'x';
                    *Cursor++ = s_rgHexChars[wch];
                    *Cursor++ = L';';

                    BytesWritten += (5 * sizeof(WCHAR));
                    BytesLeft -= (5 * sizeof(WCHAR));
                }
                else if (wch < 0x100)
                {
                    if (BytesLeft < (6 * sizeof(WCHAR)))
                        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

                    *Cursor++ = L'&';
                    *Cursor++ = L'#';
                    *Cursor++ = L'x';
                    *Cursor++ = s_rgHexChars[(wch >> 4) & 0xf];
                    *Cursor++ = s_rgHexChars[wch & 0xf];
                    *Cursor++ = L';';

                    BytesWritten += (6 * sizeof(WCHAR));
                    BytesLeft -= (6 * sizeof(WCHAR));
                }
                else if (wch < 0x1000)
                {
                    if (BytesLeft < (7 * sizeof(WCHAR)))
                        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

                    *Cursor++ = L'&';
                    *Cursor++ = L'#';
                    *Cursor++ = L'x';
                    *Cursor++ = s_rgHexChars[(wch >> 8) & 0xf];
                    *Cursor++ = s_rgHexChars[(wch >> 4) & 0xf];
                    *Cursor++ = s_rgHexChars[wch & 0xf];
                    *Cursor++ = L';';

                    BytesWritten += (7 * sizeof(WCHAR));
                    BytesLeft -= (7 * sizeof(WCHAR));
                }
                else
                {
                    INTERNAL_ERROR_CHECK(wch <= 0xffff);

                    if (BytesLeft < (8 * sizeof(WCHAR)))
                        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

                    *Cursor++ = L'&';
                    *Cursor++ = L'#';
                    *Cursor++ = L'x';
                    *Cursor++ = s_rgHexChars[(wch >> 12) & 0xf];
                    *Cursor++ = s_rgHexChars[(wch >> 8) & 0xf];
                    *Cursor++ = s_rgHexChars[(wch >> 4) & 0xf];
                    *Cursor++ = s_rgHexChars[wch & 0xf];
                    *Cursor++ = L';';

                    BytesWritten += (8 * sizeof(WCHAR));
                    BytesLeft -= (8 * sizeof(WCHAR));
                }

                break;
            }

        }

        Cch--;
    }

    if (BytesWrittenOut != NULL)
        *BytesWrittenOut = BytesWritten;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspComputeInternalAssemblyIdentityAttributeEncodedTextualSize(
    IN DWORD Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT SIZE_T *BytesOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T Bytes = 0;
    SIZE_T BytesTemp = 0;

    if (BytesOut != NULL)
        *BytesOut = 0;

    PARAMETER_CHECK((Flags & ~(
                                SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_VALUE_ONLY |
                                SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_OMIT_QUOTES)) == 0);
    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK(BytesOut != NULL);

    Bytes = 0;
    if ((Flags & SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_VALUE_ONLY) == 0)
    {
        if (Attribute->Attribute.NamespaceCch != 0)
        {
            // Figure out the ns:n= part
            IFW32FALSE_EXIT(::SxspComputeQuotedStringSize(0, Attribute->Attribute.Namespace, Attribute->Attribute.NamespaceCch, &BytesTemp));
            Bytes += BytesTemp;
            Bytes += sizeof(WCHAR); // the ":"
        }

        IFW32FALSE_EXIT(::SxspComputeQuotedStringSize(0, Attribute->Attribute.Name, Attribute->Attribute.NameCch, &BytesTemp));
        Bytes += BytesTemp;
        Bytes += sizeof(WCHAR); // the "="
    }

    IFW32FALSE_EXIT(::SxspComputeQuotedStringSize(0, Attribute->Attribute.Value, Attribute->Attribute.ValueCch, &BytesTemp));
    Bytes += BytesTemp;

    if ((Flags & SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_OMIT_QUOTES) == 0)
        Bytes += 2 * sizeof(WCHAR); // the beginning and ending quotes

    *BytesOut = Bytes;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspEncodeInternalAssemblyIdentityAttributeAsText(
    IN DWORD Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    SIZE_T BufferSize,
    PVOID Buffer,
    SIZE_T *BytesWrittenOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T BytesWritten = 0;
    SIZE_T BytesLeft = 0;
    SIZE_T BytesThisSegment;
    WCHAR *Cursor;

    if (BytesWrittenOut != NULL)
        *BytesWrittenOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK((Buffer != NULL) || (BufferSize == 0));

    BytesWritten = 0;
    BytesLeft = BufferSize;
    Cursor = reinterpret_cast<WCHAR *>(Buffer);

    if (Attribute->Attribute.NamespaceCch != 0)
    {
        IFW32FALSE_EXIT(::SxspQuoteString(0, Attribute->Namespace->Namespace, Attribute->Namespace->NamespaceCch, BytesLeft, Cursor, &BytesThisSegment));

        INTERNAL_ERROR_CHECK(BytesThisSegment <= BytesLeft);

        Cursor = (WCHAR *) (((ULONG_PTR) Cursor) + BytesThisSegment);
        BytesLeft -= BytesThisSegment;
        BytesWritten += BytesThisSegment;

        if (BytesLeft < sizeof(WCHAR))
            ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

        *Cursor++ = L':';
        BytesLeft -= sizeof(WCHAR);
        BytesWritten += sizeof(WCHAR);
    }

    IFW32FALSE_EXIT(::SxspQuoteString(0, Attribute->Attribute.Name, Attribute->Attribute.NameCch, BytesLeft, Cursor, &BytesThisSegment));

    INTERNAL_ERROR_CHECK(BytesThisSegment <= BytesLeft);

    Cursor = (WCHAR *) (((ULONG_PTR) Cursor) + BytesThisSegment);
    BytesLeft -= BytesThisSegment;
    BytesWritten += BytesThisSegment;

    if (BytesLeft < (2 * sizeof(WCHAR)))
        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

    *Cursor++ = L'=';
    *Cursor++ = L'"';
    BytesLeft -= (2 * sizeof(WCHAR));
    BytesWritten += (2 * sizeof(WCHAR));

    IFW32FALSE_EXIT(::SxspQuoteString(0, Attribute->Attribute.Value, Attribute->Attribute.ValueCch, BytesLeft, Cursor, &BytesThisSegment));

    INTERNAL_ERROR_CHECK(BytesThisSegment <= BytesLeft);

    Cursor = (WCHAR *) (((ULONG_PTR) Cursor) + BytesThisSegment);
    BytesLeft -= BytesThisSegment;
    BytesWritten += BytesThisSegment;

    if (BytesLeft < sizeof(WCHAR))
        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

    *Cursor++ = L'"';
    BytesLeft -= sizeof(WCHAR);
    BytesWritten += sizeof(WCHAR);

    *BytesWrittenOut = BytesWritten;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspEncodeAssemblyIdentityTextually(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN SIZE_T BufferSize,
    IN PVOID Buffer,
    OUT SIZE_T *BytesWrittenOut)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG AttributeCount, NamespaceCount;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Attributes;
    PCASSEMBLY_IDENTITY_NAMESPACE *Namespaces;
    ULONG i;
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE NameInternalAttribute = NULL;
    SIZE_T BytesLeft;
    SIZE_T BytesWritten;
    PVOID Cursor;
    SIZE_T TempBytesWritten;

    if (BytesWrittenOut != NULL)
        *BytesWrittenOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(BufferSize != 0);
    PARAMETER_CHECK(Buffer != NULL);
    PARAMETER_CHECK(BytesWrittenOut != NULL);

    Cursor = Buffer;
    BytesLeft = BufferSize;
    BytesWritten = 0;

    // The root assembly identity is actually totally empty, so we'll short-circuit that case.
    AttributeCount = AssemblyIdentity->AttributeCount;
    if (AttributeCount != 0)
    {
        NamespaceCount = AssemblyIdentity->NamespaceCount;
        Attributes = AssemblyIdentity->AttributePointerArray;
        Namespaces = AssemblyIdentity->NamespacePointerArray;

        // First, let's look for the "name" attribute.
        Attribute.Flags = 0;
        Attribute.Namespace = NULL;
        Attribute.NamespaceCch = 0;
        Attribute.Name = SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME;
        Attribute.NameCch = NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME) - 1;

        IFW32FALSE_EXIT(
            ::SxspLocateInternalAssemblyIdentityAttribute(
                SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                    SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME,
                AssemblyIdentity,
                &Attribute,
                &NameInternalAttribute,
                NULL));
        INTERNAL_ERROR_CHECK(NameInternalAttribute != NULL);

        IFW32FALSE_EXIT(::SxspQuoteString(0, NameInternalAttribute->Attribute.Value, NameInternalAttribute->Attribute.ValueCch, BytesLeft, Cursor, &TempBytesWritten));
        INTERNAL_ERROR_CHECK(TempBytesWritten <= BytesLeft);

        Cursor = (PVOID) (((ULONG_PTR) Cursor) + TempBytesWritten);
        BytesLeft -= TempBytesWritten;
        BytesWritten += TempBytesWritten;

        for (i=0; i<AttributeCount; i++)
        {
            // Skip the standard "name" attribute
            if (Attributes[i] == NameInternalAttribute)
                continue;

            if (BytesLeft < sizeof(WCHAR))
                ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

            *((WCHAR *) Cursor) = L',';
            Cursor = (PVOID) (((ULONG_PTR) Cursor) + sizeof(WCHAR));
            BytesLeft -= sizeof(WCHAR);
            BytesWritten += sizeof(WCHAR);

            IFW32FALSE_EXIT(::SxspEncodeInternalAssemblyIdentityAttributeAsText(0, Attributes[i], BytesLeft, Cursor, &TempBytesWritten));
            INTERNAL_ERROR_CHECK(TempBytesWritten <= BytesLeft);

            Cursor = (PVOID) (((ULONG_PTR) Cursor) + TempBytesWritten);
            BytesLeft -= TempBytesWritten;
            BytesWritten += TempBytesWritten;
        }
    }

    *BytesWrittenOut = BytesWritten;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
SxsEncodeAssemblyIdentity(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN const GUID *EncodingGroup OPTIONAL, // use NULL to use any of the SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_* encodings
    IN ULONG EncodingFormat,
    IN SIZE_T BufferSize,
    OUT PVOID Buffer,
    OUT SIZE_T *BytesWrittenOrRequired
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T TotalSize = 0;
    PVOID Cursor = NULL;
    SIZE_T i;
    PENCODED_ASSEMBLY_IDENTITY_HEADER EncodedAssemblyIdentityHeader = NULL;
    PENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER EncodedAssemblyIdentityAttributeHeader = NULL;
    ULONG *TempULONGArrayPointer;
    SIZE_T BytesWritten = 0;
    ULONG AttributeCount, NamespaceCount;

    if (BytesWrittenOrRequired != NULL)
        *BytesWrittenOrRequired = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK((BufferSize == 0) || (Buffer != NULL));
    PARAMETER_CHECK((BufferSize != 0) || (BytesWrittenOrRequired != NULL));

    if (EncodingGroup != NULL)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(UnknownEncodingGroup, ERROR_SXS_UNKNOWN_ENCODING_GROUP);

    if ((EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY) &&
        (EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL))
        ORIGINATE_WIN32_FAILURE_AND_EXIT(UnknownEncodingId, ERROR_SXS_UNKNOWN_ENCODING);

    IFW32FALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));
    IFW32FALSE_EXIT(::SxsComputeAssemblyIdentityEncodedSize(0, AssemblyIdentity, EncodingGroup, EncodingFormat, &TotalSize));

    if (TotalSize > BufferSize)
    {
        if (BytesWrittenOrRequired != NULL)
            *BytesWrittenOrRequired = TotalSize;

        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);
    }

    AttributeCount = AssemblyIdentity->AttributeCount;
    NamespaceCount = AssemblyIdentity->NamespaceCount;

    //
    //  Let's start filling it in.
    //

    switch (EncodingFormat)
    {
    case SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY:
        BytesWritten = 0;
        Cursor = Buffer;

        EncodedAssemblyIdentityHeader = (PENCODED_ASSEMBLY_IDENTITY_HEADER) Cursor;
        Cursor = (PVOID) (((ULONG_PTR) Cursor) + sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER));
        BytesWritten += sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER);

        EncodedAssemblyIdentityHeader->HeaderSize = sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER);
        EncodedAssemblyIdentityHeader->Magic = ENCODED_ASSEMBLY_IDENTITY_HEADER_MAGIC;
        EncodedAssemblyIdentityHeader->TotalSize = static_cast<ULONG>(TotalSize);
        // turn off any flags not relevant to persisted state
        EncodedAssemblyIdentityHeader->Type = AssemblyIdentity->Type;
        EncodedAssemblyIdentityHeader->Flags = AssemblyIdentity->Flags & ~(ASSEMBLY_IDENTITY_FLAG_FROZEN);
        EncodedAssemblyIdentityHeader->EncodingFlags = 0;
        EncodedAssemblyIdentityHeader->AttributeCount = AttributeCount;
        EncodedAssemblyIdentityHeader->NamespaceCount = NamespaceCount;
        EncodedAssemblyIdentityHeader->ReservedMustBeZero1 = 0;
        EncodedAssemblyIdentityHeader->ReservedMustBeZero2 = 0;
        EncodedAssemblyIdentityHeader->ReservedMustBeZero3 = 0;
        EncodedAssemblyIdentityHeader->ReservedMustBeZero4 = 0;

        TempULONGArrayPointer = (ULONG *) Cursor;
        Cursor = (PVOID) (TempULONGArrayPointer + AttributeCount);
        BytesWritten += (AttributeCount * sizeof(ULONG));

        for (i=0; i<AttributeCount; i++)
            TempULONGArrayPointer[i] = AssemblyIdentity->AttributePointerArray[i]->WholeAttributeHash;

        // sort 'em...
        qsort(TempULONGArrayPointer, AttributeCount, sizeof(ULONG), &SxspCompareULONGsForQsort);

        TempULONGArrayPointer = (ULONG *) Cursor;
        Cursor = (PVOID) (TempULONGArrayPointer + NamespaceCount);
        BytesWritten += (sizeof(ULONG) * NamespaceCount);

        for (i=0; i<NamespaceCount; i++)
            TempULONGArrayPointer[i] = static_cast<ULONG>(AssemblyIdentity->NamespacePointerArray[i]->NamespaceCch);

        EncodedAssemblyIdentityAttributeHeader = (PENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER) Cursor;
        Cursor = (PVOID) (EncodedAssemblyIdentityAttributeHeader + AttributeCount);
        BytesWritten += (AttributeCount * sizeof(ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER));

        for (i=0; i<AttributeCount; i++)
        {
            PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = AssemblyIdentity->AttributePointerArray[i];
            ULONG NamespaceIndex;

            // Totally gross linear search to determine the namespace index.  Fortunately the common case
            // will be a single namespace for all attributes.
            for (NamespaceIndex = 0; NamespaceIndex < NamespaceCount; NamespaceIndex++)
            {
                if (AssemblyIdentity->NamespacePointerArray[NamespaceIndex] == InternalAttribute->Namespace)
                    break;
            }

            // If this assert fires, the attribute refers to a namespace that's not in the identity; bad!
            INTERNAL_ERROR_CHECK(
                (InternalAttribute->Namespace == NULL) ||
                (NamespaceIndex < NamespaceCount));

            EncodedAssemblyIdentityAttributeHeader[i].NamespaceIndex = NamespaceIndex + 1;
            EncodedAssemblyIdentityAttributeHeader[i].NameCch = static_cast<ULONG>(InternalAttribute->Attribute.NameCch);
            EncodedAssemblyIdentityAttributeHeader[i].ValueCch = static_cast<ULONG>(InternalAttribute->Attribute.ValueCch);
        }

        // so much for the fixed length stuff; write the namespaces.
        for (i=0; i<NamespaceCount; i++)
        {
            PWSTR psz = (PWSTR) Cursor;
            Cursor = (PVOID) (((ULONG_PTR) psz) + (AssemblyIdentity->NamespacePointerArray[i]->NamespaceCch * sizeof(WCHAR)));

            BytesWritten += (AssemblyIdentity->NamespacePointerArray[i]->NamespaceCch * sizeof(WCHAR));

            memcpy(
                psz,
                AssemblyIdentity->NamespacePointerArray[i]->Namespace,
                AssemblyIdentity->NamespacePointerArray[i]->NamespaceCch * sizeof(WCHAR));
        }

        // And the attributes...
        for (i=0; i<AttributeCount; i++)
        {
            PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = AssemblyIdentity->AttributePointerArray[i];
            PWSTR psz;

            psz = (PWSTR) Cursor;
            Cursor = (PVOID) (((ULONG_PTR) psz) + (InternalAttribute->Attribute.NameCch * sizeof(WCHAR)));
            BytesWritten += (InternalAttribute->Attribute.NameCch * sizeof(WCHAR));

            memcpy(
                psz,
                InternalAttribute->Attribute.Name,
                InternalAttribute->Attribute.NameCch * sizeof(WCHAR));

            psz = (PWSTR) Cursor;
            Cursor = (PVOID) (((ULONG_PTR) psz) + InternalAttribute->Attribute.ValueCch * sizeof(WCHAR));
            BytesWritten += InternalAttribute->Attribute.ValueCch * sizeof(WCHAR);

            memcpy(
                psz,
                InternalAttribute->Attribute.Value,
                InternalAttribute->Attribute.ValueCch * sizeof(WCHAR));
        }

        if ((BytesWritten % 4) != 0) {
            ASSERT((BytesWritten % 4) == sizeof(USHORT));

            *((USHORT *) Cursor) = 0;
            BytesWritten += sizeof(USHORT);
        }

        break;

    case SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL:
        IFW32FALSE_EXIT(::SxspEncodeAssemblyIdentityTextually(0, AssemblyIdentity, BufferSize, Buffer, &BytesWritten));
        break;
    }

    INTERNAL_ERROR_CHECK(BytesWritten == TotalSize);

    if (BytesWrittenOrRequired != NULL)
        *BytesWrittenOrRequired = BytesWritten;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxsDecodeAssemblyIdentity(
    ULONG Flags,
    IN const GUID *EncodingGroup,
    IN ULONG EncodingFormat,
    IN SIZE_T BufferSize,
    IN const VOID *Buffer,
    OUT PASSEMBLY_IDENTITY *AssemblyIdentityOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCENCODED_ASSEMBLY_IDENTITY_HEADER EncodedAssemblyIdentityHeader = NULL;
    PCENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER EncodedAssemblyIdentityAttributeHeader = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = NULL;
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;
    ULONG AttributeCount = 0;
    ULONG NamespaceCount = 0;
    ULONG AttributeArraySize = 0;
    ULONG NamespaceArraySize = 0;
    ULONG i;
    const ULONG *NamespaceLengthArray = NULL;
    const ULONG *AttributeHashArray = NULL;
    const WCHAR *UnicodeStringArray = NULL;

    if (AssemblyIdentityOut != NULL)
        *AssemblyIdentityOut = NULL;

    PARAMETER_CHECK((Flags & ~(SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE)) == 0);
    PARAMETER_CHECK(BufferSize >= sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER));
    PARAMETER_CHECK(Buffer != NULL);
    PARAMETER_CHECK(AssemblyIdentityOut != NULL);

    if (EncodingGroup != NULL)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(UnknownEncodingGroup, ERROR_SXS_UNKNOWN_ENCODING_GROUP);

    if ((EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY) &&
        (EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL))
        ORIGINATE_WIN32_FAILURE_AND_EXIT(UnknownEncoding, ERROR_SXS_UNKNOWN_ENCODING);

    EncodedAssemblyIdentityHeader = (PCENCODED_ASSEMBLY_IDENTITY_HEADER) Buffer;

    if ((EncodedAssemblyIdentityHeader->HeaderSize != sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER)) ||
        (EncodedAssemblyIdentityHeader->Magic != ENCODED_ASSEMBLY_IDENTITY_HEADER_MAGIC) ||
        (EncodedAssemblyIdentityHeader->TotalSize > BufferSize) ||
        (EncodedAssemblyIdentityHeader->Flags != 0) ||
        ((EncodedAssemblyIdentityHeader->Type != ASSEMBLY_IDENTITY_TYPE_DEFINITION) &&
         (EncodedAssemblyIdentityHeader->Type != ASSEMBLY_IDENTITY_TYPE_REFERENCE) &&
         (EncodedAssemblyIdentityHeader->Type != ASSEMBLY_IDENTITY_TYPE_WILDCARD)) ||
        (EncodedAssemblyIdentityHeader->EncodingFlags != 0) ||
        (EncodedAssemblyIdentityHeader->ReservedMustBeZero1 != 0) ||
        (EncodedAssemblyIdentityHeader->ReservedMustBeZero2 != 0) ||
        (EncodedAssemblyIdentityHeader->ReservedMustBeZero3 != 0) ||
        (EncodedAssemblyIdentityHeader->ReservedMustBeZero4 != 0)) {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    IFALLOCFAILED_EXIT(AssemblyIdentity = new ASSEMBLY_IDENTITY);

    NamespaceCount = EncodedAssemblyIdentityHeader->NamespaceCount;

    if (Flags & SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
    {
        NamespaceArraySize = NamespaceCount;
    }
    else if (NamespaceCount == 0)
    {
        NamespaceArraySize = 8;
    }
    else
    {
        NamespaceArraySize = (NamespaceCount + 7) & ~7;
    }

    if (NamespaceArraySize != 0)
    {
        IFALLOCFAILED_EXIT(NamespacePointerArray = new PCASSEMBLY_IDENTITY_NAMESPACE[NamespaceArraySize]);

        for (i=0; i<NamespaceArraySize; i++)
            NamespacePointerArray[i] = NULL;
    }

    AttributeCount = EncodedAssemblyIdentityHeader->AttributeCount;

    if (Flags & SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
    {
        // If we're going to freeze, just perform an exact allocation.
        AttributeArraySize = AttributeCount;
    }
    else if (AttributeCount == 0)
    {
        AttributeArraySize = 8;
    }
    else
    {
        AttributeArraySize = (AttributeCount + 7) & ~7;
    }

    if (AttributeArraySize != 0)
    {
        IFALLOCFAILED_EXIT(AttributePointerArray = new PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE[AttributeArraySize]);

        for (i=0; i<AttributeArraySize; i++)
            AttributePointerArray[i] = NULL;
    }

    AttributeHashArray = (const ULONG *) (EncodedAssemblyIdentityHeader + 1);
    NamespaceLengthArray = (const ULONG *) (AttributeHashArray + AttributeCount);
    EncodedAssemblyIdentityAttributeHeader = (PCENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER) (NamespaceLengthArray + NamespaceCount);
    UnicodeStringArray = (const WCHAR *) (EncodedAssemblyIdentityAttributeHeader + AttributeCount);

    // Start by building up those namespaces...
    for (i=0; i<NamespaceCount; i++)
    {
        ULONG NamespaceHash = 0;
        IFW32FALSE_EXIT(::FusionpHashUnicodeString(UnicodeStringArray, NamespaceLengthArray[i], &NamespaceHash, false));
        IFW32FALSE_EXIT(::SxspAllocateAssemblyIdentityNamespace(0, UnicodeStringArray, NamespaceLengthArray[i], NamespaceHash, &NamespacePointerArray[i]));
        UnicodeStringArray += NamespaceLengthArray[i];
    }

    if (AttributeCount != 0)
    {
        // and now those attributes...
        for (i=0; i<AttributeCount; i++)
        {
            const ULONG NamespaceIndex = EncodedAssemblyIdentityAttributeHeader[i].NamespaceIndex;
            const ULONG NameCch = EncodedAssemblyIdentityAttributeHeader[i].NameCch;
            const ULONG ValueCch = EncodedAssemblyIdentityAttributeHeader[i].ValueCch;
            const WCHAR * const Name = UnicodeStringArray;
            const WCHAR * const Value = &UnicodeStringArray[NameCch];

            UnicodeStringArray = &Value[ValueCch];

            IFW32FALSE_EXIT(
                ::SxspAllocateInternalAssemblyIdentityAttribute(
                    0,
                    NamespacePointerArray[NamespaceIndex],
                    Name,
                    NameCch,
                    Value,
                    ValueCch,
                    &AttributePointerArray[i]));
        }

        // sort 'em...
        qsort((PVOID) AttributePointerArray, AttributeCount, sizeof(PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE), &SxspCompareInternalAttributesForQsort);
    }

    IFW32FALSE_EXIT(::SxspHashInternalAssemblyIdentityAttributes(0, AttributeCount, AttributePointerArray, &AssemblyIdentity->Hash));

    AssemblyIdentity->Flags = 0;
    AssemblyIdentity->Type = EncodedAssemblyIdentityHeader->Type;
    AssemblyIdentity->InternalFlags = ASSEMBLY_IDENTITY_INTERNAL_FLAG_ATTRIBUTE_POINTERS_IN_SEPARATE_ALLOCATION | ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION;
    AssemblyIdentity->AttributePointerArray = AttributePointerArray;
    AssemblyIdentity->AttributeCount = AttributeCount;
    AssemblyIdentity->AttributeArraySize = AttributeArraySize;
    AssemblyIdentity->NamespacePointerArray = NamespacePointerArray;
    AssemblyIdentity->NamespaceCount = NamespaceCount;
    AssemblyIdentity->NamespaceArraySize = NamespaceArraySize;

    AttributePointerArray = NULL;
    NamespacePointerArray = NULL;

    if (Flags & SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
        AssemblyIdentity->Flags |= ASSEMBLY_IDENTITY_FLAG_FROZEN;

    *AssemblyIdentityOut = AssemblyIdentity;
    AssemblyIdentity = NULL;

    fSuccess = TRUE;

Exit:
    //
    // REVIEW: Should this be an SxsDestroyAssemblyIdentity
    //
    if (AssemblyIdentity != NULL)
        FUSION_DELETE_SINGLETON(AssemblyIdentity);

    if ((AttributeCount != 0) && (AttributePointerArray != NULL))
    {
        for (i=0; i<AttributeCount; i++)
        {
            if (AttributePointerArray[i] != NULL)
            {
                ::SxspDeallocateInternalAssemblyIdentityAttribute(AttributePointerArray[i]);
                AttributePointerArray[i] = NULL;
            }
        }

        FUSION_DELETE_ARRAY( AttributePointerArray );
    }

    if ((NamespaceCount != 0) && (NamespacePointerArray != NULL))
    {
        for (i=0; i<NamespaceCount; i++)
        {
            if (NamespacePointerArray[i] != NULL)
            {
                ::SxspDeallocateAssemblyIdentityNamespace(NamespacePointerArray[i]);
                NamespacePointerArray[i] = NULL;
            }
        }

        FUSION_DELETE_ARRAY( NamespacePointerArray );
    }

    return fSuccess;
}

int __cdecl
SxspCharPairArrayComparisonCallback(
    const void *pelem1,
    const void *pelem2
    )
{
    PCCHARPAIR pcp1 = (PCCHARPAIR) pelem1;
    PCCHARPAIR pcp2 = (PCCHARPAIR) pelem2;

    if (pcp1->wchEnd < pcp2->wchStart)
        return -1;

    if (pcp2->wchEnd < pcp1->wchStart)
        return 1;

    return 0;
}

bool
SxspIsCharInCharPairArray(
    WCHAR wch,
    PCCHARPAIR prg,
    SIZE_T n
    )
{
    CHARPAIR cp = { wch, wch };
    return (bsearch(&cp, prg, n, sizeof(CHARPAIR), &SxspCharPairArrayComparisonCallback) != NULL);
}

bool
SxspIsCharXMLBaseChar(
    WCHAR wch
    )
{
    return SxspIsCharInCharPairArray(wch, s_rgXMLBaseChar, NUMBER_OF(s_rgXMLBaseChar));
}

bool
SxspIsCharXMLIdeographic(
    WCHAR wch
    )
{
    return (
        (wch >= 0x4e00 && wch <= 0x9fa5) ||
        (wch == 0x3007) ||
        (wch >= 0x3021 && wch <= 0x3029)
        );
}

bool
SxspIsCharXMLLetter(
    WCHAR wch
    )
{
    return
        ::SxspIsCharXMLBaseChar(wch) ||
        ::SxspIsCharXMLIdeographic(wch);
}

bool
SxspIsCharXMLCombiningChar(
    WCHAR wch
    )
{
    return (
        (wch >= 0x0300 && wch <= 0x0345) ||
        (wch >= 0x0360 && wch <= 0x0361) ||
        (wch >= 0x0483 && wch <= 0x0486) ||
        (wch >= 0x0591 && wch <= 0x05a1) ||
        (wch >= 0x05a3 && wch <= 0x05b9) ||
        (wch >= 0x05bb && wch <= 0x05bd) ||
        wch == 0x05bf ||
        (wch >= 0x05c1 && wch <= 0x05c2) ||
        wch == 0x05c4 ||
        (wch >= 0x064b && wch <= 0x0652) ||
        wch == 0x0670 ||
        (wch >= 0x06d6 && wch <= 0x06dc) ||
        (wch >= 0x06dd && wch <= 0x06df) ||
        (wch >= 0x06e0 && wch <= 0x06e4) ||
        (wch >= 0x06e7 && wch <= 0x06e8) ||
        (wch >= 0x06ea && wch <= 0x06ed) ||
        (wch >= 0x0901 && wch <= 0x0903) ||
        wch == 0x093c ||
        (wch >= 0x093e && wch <= 0x094c) ||
        wch == 0x094d ||
        (wch >= 0x0951 && wch <= 0x0954) ||
        (wch >= 0x0962 && wch <= 0x0963) ||
        (wch >= 0x0981 && wch <= 0x0983) ||
        wch == 0x09bc ||
        wch == 0x09be ||
        wch == 0x09bf ||
        (wch >= 0x09c0 && wch <= 0x09c4) ||
        (wch >= 0x09c7 && wch <= 0x09c8) ||
        (wch >= 0x09cb && wch <= 0x09cd) ||
        wch == 0x09d7 ||
        (wch >= 0x09e2 && wch <= 0x09e3) ||
        wch == 0x0a02 ||
        wch == 0x0a3c ||
        wch == 0x0a3e ||
        wch == 0x0a3f ||
        (wch >= 0x0a40 && wch <= 0x0a42) ||
        (wch >= 0x0a47 && wch <= 0x0a48) ||
        (wch >= 0x0a4b && wch <= 0x0a4d) ||
        (wch >= 0x0a70 && wch <= 0x0a71) ||
        (wch >= 0x0a81 && wch <= 0x0a83) ||
        wch == 0x0abc ||
        (wch >= 0x0abe && wch <= 0x0ac5) ||
        (wch >= 0x0ac7 && wch <= 0x0ac9) ||
        (wch >= 0x0acb && wch <= 0x0acd) ||
        (wch >= 0x0b01 && wch <= 0x0b03) ||
        wch == 0x0b3c ||
        (wch >= 0x0b3e && wch <= 0x0b43) ||
        (wch >= 0x0b47 && wch <= 0x0b48) ||
        (wch >= 0x0b4b && wch <= 0x0b4d) ||
        (wch >= 0x0b56 && wch <= 0x0b57) ||
        (wch >= 0x0b82 && wch <= 0x0b83) ||
        (wch >= 0x0bbe && wch <= 0x0bc2) ||
        (wch >= 0x0bc6 && wch <= 0x0bc8) ||
        (wch >= 0x0bca && wch <= 0x0bcd) ||
        wch == 0x0bd7 ||
        (wch >= 0x0c01 && wch <= 0x0c03) ||
        (wch >= 0x0c3e && wch <= 0x0c44) ||
        (wch >= 0x0c46 && wch <= 0x0c48) ||
        (wch >= 0x0c4a && wch <= 0x0c4d) ||
        (wch >= 0x0c55 && wch <= 0x0c56) ||
        (wch >= 0x0c82 && wch <= 0x0c83) ||
        (wch >= 0x0cbe && wch <= 0x0cc4) ||
        (wch >= 0x0cc6 && wch <= 0x0cc8) ||
        (wch >= 0x0cca && wch <= 0x0ccd) ||
        (wch >= 0x0cd5 && wch <= 0x0cd6) ||
        (wch >= 0x0d02 && wch <= 0x0d03) ||
        (wch >= 0x0d3e && wch <= 0x0d43) ||
        (wch >= 0x0d46 && wch <= 0x0d48) ||
        (wch >= 0x0d4a && wch <= 0x0d4d) ||
        wch == 0x0d57 ||
        wch == 0x0e31 ||
        (wch >= 0x0e34 && wch <= 0x0e3a) ||
        (wch >= 0x0e47 && wch <= 0x0e4e) ||
        wch == 0x0eb1 ||
        (wch >= 0x0eb4 && wch <= 0x0eb9) ||
        (wch >= 0x0ebb && wch <= 0x0ebc) ||
        (wch >= 0x0ec8 && wch <= 0x0ecd) ||
        (wch >= 0x0f18 && wch <= 0x0f19) ||
        wch == 0x0f35 ||
        wch == 0x0f37 ||
        wch == 0x0f39 ||
        wch == 0x0f3e ||
        wch == 0x0f3f ||
        (wch >= 0x0f71 && wch <= 0x0f84) ||
        (wch >= 0x0f86 && wch <= 0x0f8b) ||
        (wch >= 0x0f90 && wch <= 0x0f95) ||
        wch == 0x0f97 ||
        (wch >= 0x0f99 && wch <= 0x0fad) ||
        (wch >= 0x0fb1 && wch <= 0x0fb7) ||
        wch == 0x0fb9 ||
        (wch >= 0x20d0 && wch <= 0x20dc) ||
        wch == 0x20e1 ||
        (wch >= 0x302a && wch <= 0x302f) ||
        wch == 0x3099 ||
        wch == 0x309a
        );
}

bool
SxspIsCharXMLDigit(
    WCHAR wch
    )
{
    return (
        (wch >= 0x0030 && wch <= 0x0039) ||
        (wch >= 0x0660 && wch <= 0x0669) ||
        (wch >= 0x06f0 && wch <= 0x06f9) ||
        (wch >= 0x0966 && wch <= 0x096f) ||
        (wch >= 0x09e6 && wch <= 0x09ef) ||
        (wch >= 0x0a66 && wch <= 0x0a6f) ||
        (wch >= 0x0ae6 && wch <= 0x0aef) ||
        (wch >= 0x0b66 && wch <= 0x0b6f) ||
        (wch >= 0x0be7 && wch <= 0x0bef) ||
        (wch >= 0x0c66 && wch <= 0x0c6f) ||
        (wch >= 0x0ce6 && wch <= 0x0cef) ||
        (wch >= 0x0d66 && wch <= 0x0d6f) ||
        (wch >= 0x0e50 && wch <= 0x0e59) ||
        (wch >= 0x0ed0 && wch <= 0x0ed9) ||
        (wch >= 0x0f20 && wch <= 0x0f29)
        );
}

bool
SxspIsCharXMLExtender(
    WCHAR wch
    )
{
    return (
        wch == 0x00b7 ||
        wch == 0x02d0 ||
        wch == 0x02d1 ||
        wch == 0x0387 ||
        wch == 0x0640 ||
        wch == 0x0e46 ||
        wch == 0x0ec6 ||
        wch == 0x3005 ||
        (wch >= 0x3031 && wch <= 0x3035) ||
        (wch >= 0x309d && wch <= 0x309e) ||
        (wch >= 0x30fc && wch <= 0x30fe)
        );
}

BOOL
SxspValidateXMLName(
    PCWSTR psz,
    SIZE_T cch,
    bool &rfValid
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    SIZE_T i;

    rfValid = false;

    // [4]  NameChar ::=  Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender 
    // [5]  Name ::=  (Letter | '_' | ':') (NameChar)* 

    if (cch >= 1)
    {
        WCHAR wch = psz[0];

        if (::SxspIsCharXMLLetter(wch) ||
            (wch == L'_') ||
            (wch == L':'))
        {
            for (i=1; i<cch; i++)
            {
                wch = psz[i];

                if (!::SxspIsCharXMLLetter(wch) &&
                    !::SxspIsCharXMLDigit(wch) &&
                    (wch != L'.') &&
                    (wch != L'-') &&
                    (wch != L'_') &&
                    (wch != L':') &&
                    !::SxspIsCharXMLCombiningChar(wch) &&
                    !::SxspIsCharXMLExtender(wch))
                    break;
            }

            if (i == cch)
                rfValid = true;
        }
    }

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\gencomctlt\gencomctlt.cpp ===
/*
generate comctl tool
based on gennt32t
*/
#pragma warning( disable : 4786) //disable identifier is too long for debugging error
#pragma warning( disable : 4503) //disable decorated name is too long
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
#include <sstream>
#include <set>
#include <map>

extern "C" {

#include "gen.h"

#if !defined(NUMBER_OF)
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#endif

// string to put in front of all error messages so that BUILD can find them.
const char *ErrMsgPrefix = "NMAKE :  U8603: 'GENCOMCTLT' ";

void
HandlePreprocessorDirective(
   char *p
   )
{
   ExitErrMsg(FALSE, "Preprocessor directives not allowed by gencomctlt.\n");
}

}

using namespace std;
typedef string String;

PRBTREE pFunctions = NULL;
PRBTREE pStructures = NULL;
PRBTREE pTypedefs = NULL;

void ExtractCVMHeader(PCVMHEAPHEADER pHeader) {
   pFunctions = &pHeader->FuncsList;
   pTypedefs =  &pHeader->TypeDefsList;
   pStructures =&pHeader->StructsList;
}

// globals so debugging works
PKNOWNTYPES pFunction; 
PFUNCINFO   pfuncinfo;

#if 0

#define NOTHING /* */
#define IGNORED /* */
#define NOPREFIX /* */
#define NOSUFFIX /* */

//HANDLE __stdcall MyCreateActCtx(void)
//{
//    static HANDLE Handle = INVALID_HANDLE_VALUE;

//    if (Handle == INVALID_HANDLE_VALUE)
//    {
//        WCHAR PathToManifest[MAX_PATH];
//        ACTCTXW ActCtx = {sizeof(ActCtx)};

//        SearchPathW(NULL, L"shell32.dll", NULL, NUMBER_OF(PathToManifest), PathToManifest, NULL);
//        ActCtx.lpSource = PathToManifest;

//        Handle = CreateActCtxW(&ActCtx);

//        if (Handle == INVALID_HANDLE_VALUE)
//            goto Exit;
//    }
//Exit:
//    return Handle;
//}

//BOOL MyLoadLibraryOrGetModuleHandle(PCWSTR name, HMODULE* Module)
//{
//    static HMODULE StaticModule = NULL;
//    HANDLE ActivationContext;
//    BOOL Success = FALSE;
//    ULONG Cookie = 0;
//    DWORD Error = NO_ERROR;

//    *Module = NULL;
//    if (StaticModule != NULL)
//    {
//        *Module = StaticModule;
//        Success = TRUE;
//        goto Exit;
//    }

//    ActivationContext = MyCreateActCtx();
//    if (ActivationContext == INVALID_HANDLE_VALUE)
//        goto Exit;
//    ActivateActCtx(ActivationContext, &Cookie);

//    *Module = LoadLibraryW(L"comctl32.dll");
//    if (*Module == NULL)
//        goto Exit;

//    Success = TRUE;
//Exit:
//    if (!Success && Error == NO_ERROR)
//        Error = GetLastError();
//    if (Cookie != 0)
//    {
//        if (!DeactivateActCtx(Cookie))
//        { // ?
//            if (Success)
//            {
//                Success = FALSE;
//                Error = GetLastError();
//            }
//        }
//    }
//    if (!Success)
//        SetLastError(Error);
//    return Success;
//}

//BOOL Patch(PCSTR ProcName, FARPROC* ProcAddress)
//{
//    HMODULE Module = NULL;
//    BOOL Success = FALSE;

//    *ProcAddress = NULL;
//     Success = MyLoadLibraryOrGetModuleHandle(L"comctl32.dll", &Module);
//    if (!Success)
//        goto Exit;
//    *ProcAddress = GetProcAddress(Module, ProcName);
//    if (*ProcAddress == NULL)
//        goto Exit;
//    Success = TRUE;
//Exit:
//    return Success;
//}

//#define DECLARE(ret, call, name, argNamesTypes, argNames, importType, importExtra, onError) \
//    ret (call* name) argNamesTypes ;

//#define DEFINE(ret, call, name, argNamesTypes, argNames, importType, importExtra, onError) \
//static ret call FIRST(name) argNamesTypes \
//{ \
//    static DWORD Error = NO_ERROR; \
//    if (Error != NO_ERROR) \
//    { \
//        onError(Error); \
//    } \
//    if (!Patch(importType(importExtra), (FARPROC*)&name)) \
//    { \
//        Error = GetLastError(); \
//        onError(Error); \
//    } \
//    return name argNames; \
//} \
//ret (call* name) argNamesTypes  = FIRST(name);

//#define IMPORT_BY_NAME(name, extra)    (#name)
//#define IMPORT_BY_ORDINAL(name, extra) ((const char*)(ULONG_PTR)extra)

//#define COMCTL_FUNCTIONS \
//COMCTL_FUNCTION(HRESULT, __stdcall, UninitializeFlatSB, (HWND _noname0), (_noname0), IMPORT_BY_NAME, IGNORED) \
//COMCTL_FUNCTION(BOOL, __stdcall, InitializeFlatSB, (HWND _noname0), (_noname0), IMPORT_BY_ORDINAL, 1)

//#define COMCTL_FUNCTION(ret, call, name, argNamesTypes, argNames, importType, importExtra, onError) \
//    DECLARE(ret, call, name, argNamesTypes, argNames, importType, importExtra, onError)

//COMCTL_FUNCTIONS


// HWND _noname0,
//)

DumpLib(PCWSTR filename)
{
    CreateFileW(filename, GENERIC_READ, FILE_SHARE_READ, NULL
}

#endif

void DumpFunctionDeclarationsHeader(void)
{
    //PKNOWNTYPES pFunction; 
    //PFUNCINFO   pfuncinfo;

    cout << "///////////////////////////////////////////\n";
    cout << "// This file is autogenerated by gencomctlt. \n";
    cout << "// Do not edit                             \n";
    cout << "///////////////////////////////////////////\n";
    cout << '\n' << '\n';

    cout << "#include \"windows.h\"\n";
    cout << "#include \"commctrl.h\"\n\n";

    cout << "///////////////////////////////////////////\n";
    cout << "//  Functions                            //\n";
    cout << "///////////////////////////////////////////\n";
    for (
        pFunction = pFunctions->pLastNodeInserted;
        pFunction != NULL
            && pFunction->TypeName != NULL
            && strcmp(pFunction->TypeName, "MarkerFunction_8afccfaa_27e7_45d5_8ff7_7ac0b970789d") != 0 ;
        pFunction = pFunction->Next)
    {
    /*
    for now, just like print out commctrl as a demo/test of understanding the tool
    tomorrow, print out what we actually need
    */
#if 1
        cout << pFunction->FuncRet << ' ';
        cout << pFunction->FuncMod << ' '; // __stdcall
        cout << pFunction->TypeName << "(\n"; // function name
        pfuncinfo = pFunction->pfuncinfo;
        if (pfuncinfo == NULL || pfuncinfo->sType == NULL || pfuncinfo->sName == NULL)
        {
            cout << "void";
        }
        else
        {
            for ( ; pfuncinfo != NULL ; pfuncinfo = pfuncinfo->pfuncinfoNext )
            {
                cout << ' ' << pfuncinfo->sType << ' ' << pfuncinfo->sName << ",\n";
            }
        }
        cout << ")\n";
#endif
    }
    cout << '\n' << '\n';
}

int __cdecl main(int argc, char*argv[])
{
    ExtractCVMHeader(MapPpmFile(argv[1], TRUE));
    DumpFunctionDeclarationsHeader();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\id\id.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    id.cpp

Abstract:

    Implementation of the assembly identity data type.

Author:

    Michael Grier (MGrier) 7/20/2000

Revision History:

--*/
#include "stdinc.h"
#include <setupapi.h>
#include <sxsapi.h>
#include <stdlib.h>
#include <search.h>

#include "idp.h"
#include "sxsid.h"

//
//  Power of two to which to round the number of allocated attribute
//  pointers.
//

#define ROUNDING_FACTOR_BITS (3)

#define WILDCARD_CHAR '*'

#define ENTRY(x) { x, NUMBER_OF(x) - 1 },

const static struct
{
    const WCHAR *String;
    SIZE_T Cch;
} s_rgLegalNamesNotInANamespace[] =
{
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE)
};

#undef ENTRY

BOOL
SxspValidateXMLName(
    PCWSTR psz,
    SIZE_T cch,
    bool &rfValid
    );

BOOL
SxspValidateAssemblyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK((Flags & ~(SXSP_VALIDATE_ASSEMBLY_IDENTITY_FLAGS_MAY_BE_NULL)) == 0);

    if (AssemblyIdentity == NULL)
    {
        PARAMETER_CHECK(Flags & SXSP_VALIDATE_ASSEMBLY_IDENTITY_FLAGS_MAY_BE_NULL);
    }
    else
    {
        const ULONG IdentityType = AssemblyIdentity->Type;

        PARAMETER_CHECK(
            (IdentityType == ASSEMBLY_IDENTITY_TYPE_DEFINITION) ||
            (IdentityType == ASSEMBLY_IDENTITY_TYPE_REFERENCE) ||
            (IdentityType == ASSEMBLY_IDENTITY_TYPE_WILDCARD));
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

//
//  Note!
//
//  We currently are very very restrictive on the legal characters in namespaces.
//
//  This is because the various rules for equivalences of namespaces are extremely
//  complex w.r.t. when "a" == "A" and "%Ab" == "%aB" etc.
//
//  We're side-stepping this issue by requireing everything to be lower case and
//  not permitting the "%" character.
//

const WCHAR s_rgLegalNamespaceChars[] = L"abcdefghijklmnopqrstuvwxyz0123456789.-_/\\:";
BOOL
SxspValidateAssemblyIdentityAttributeNamespace(
    IN DWORD Flags,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG i;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK((Namespace != NULL) || (NamespaceCch == 0));

    //
    //  We really should ensure that the namespace is a well-formed URI
    //

    for (i=0; i<NamespaceCch; i++)
    {
        if (wcschr(s_rgLegalNamespaceChars, Namespace[i]) == NULL)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(InvalidNamespaceURI, ERROR_SXS_INVALID_XML_NAMESPACE_URI);
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspValidateAssemblyIdentityAttributeName(
    IN DWORD Flags,
    IN const WCHAR *Name,
    IN SIZE_T NameCch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    bool fNameWellFormed = false;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK((Name != NULL) || (NameCch == 0));

    //
    //  We should ensure that Name is a well-formed XML identifier
    //
    IFW32FALSE_EXIT(::SxspValidateXMLName(Name, NameCch, fNameWellFormed));

    if (!fNameWellFormed)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(BadAttributeName, ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspValidateAssemblyIdentityAttributeValue(
    IN DWORD Flags,
    IN const WCHAR * /* Value */,
    SIZE_T /* ValueCch */
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK((Flags & ~(SXSP_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_WILDCARDS_PERMITTED)) == 0);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxsValidateAssemblyIdentityAttribute(
    DWORD Flags,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK((Flags & ~(
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_WILDCARDS_PERMITTED)) == 0);
    PARAMETER_CHECK(Attribute != NULL);

    //
    //  apply useful defaults.  Note that by default, wildcards are not permitted.
    //

    if (Flags == 0)
    {
        Flags =
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE;
    }

    // No attribute flags defined or permitted at this time.
    PARAMETER_CHECK(Attribute->Flags == 0);

    if (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE)
        IFW32FALSE_EXIT(::SxspValidateAssemblyIdentityAttributeNamespace(0, Attribute->Namespace, Attribute->NamespaceCch));

    if (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME)
        IFW32FALSE_EXIT(::SxspValidateAssemblyIdentityAttributeName(0, Attribute->Name, Attribute->NameCch));

    if (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE)
        IFW32FALSE_EXIT(::SxspValidateAssemblyIdentityAttributeValue(
                        (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_WILDCARDS_PERMITTED) ?
                            SXSP_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_WILDCARDS_PERMITTED : 0,
                         Attribute->Value,
                         Attribute->ValueCch));

    if ((Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE) &&
        (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME) &&
        (Attribute->NamespaceCch == 0))
    {
        ULONG i;
        // There is only a small set of legal attribute names when the namespace is omitted.

        for (i=0; i<NUMBER_OF(s_rgLegalNamesNotInANamespace); i++)
        {
            if (Attribute->NameCch == s_rgLegalNamesNotInANamespace[i].Cch)
            {
                if (memcmp(Attribute->Name, s_rgLegalNamesNotInANamespace[i].String, Attribute->NameCch * sizeof(WCHAR)) == 0)
                    break;
            }
        }

        if (i == NUMBER_OF(s_rgLegalNamesNotInANamespace))
        {
            // Someone had an attribute on the <assemblyIdentity> element which was not in a namespace and
            // was not listed as a builtin attribute.  Boom.
            ORIGINATE_WIN32_FAILURE_AND_EXIT(InvalidAssemblyIdentityAttribute, ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE);
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxsHashAssemblyIdentityAttribute(
    DWORD Flags,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    ULONG *HashOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG Hash = 0;
    ULONG TempHash = 0;

    if (HashOut != NULL)
        *HashOut = 0;

    if (Flags == 0)
        Flags = SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE |
                SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME |
                SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE;

    PARAMETER_CHECK((Flags & ~(SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE |
                  SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME |
                  SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE)) == 0);

    // if hash value, must hash name, if hash name, must hash namespace
    if (((Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE) && (
        (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME) == 0)) ||
        ((Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME) && (
        (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE) == 0))) {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK(HashOut != NULL);

    if (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE) {
        IFW32FALSE_EXIT(::FusionpHashUnicodeString(Attribute->Namespace, Attribute->NamespaceCch, &TempHash, true));
        Hash = TempHash;
    }
    if (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME) {
        IFW32FALSE_EXIT(::FusionpHashUnicodeString(Attribute->Name, Attribute->NameCch, &TempHash, true));
        Hash = (Hash * 65599) + TempHash;
    }

    if (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE) {
        IFW32FALSE_EXIT(::FusionpHashUnicodeString(Attribute->Value, Attribute->ValueCch, &TempHash, true));
        Hash = (Hash * 65599) + TempHash;
    }

    *HashOut = Hash;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspComputeInternalAssemblyIdentityAttributeBytesRequired(
    IN DWORD Flags,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT SIZE_T *BytesRequiredOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T BytesNeeded = 0;

    if (BytesRequiredOut != NULL)
        *BytesRequiredOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(BytesRequiredOut != NULL);
    PARAMETER_CHECK((NameCch == 0) || (Name != NULL));
    PARAMETER_CHECK((ValueCch == 0) || (Value != NULL));

    BytesNeeded = sizeof(INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE);

    // Note that we do not account for the namespace length because namespaces are pooled
    // for the identity object and come from a separate allocation.

    if ((Name != NULL) && (NameCch != 0))
        BytesNeeded += ((NameCch + 1) * sizeof(WCHAR));

    if ((Value != NULL) && (ValueCch != 0))
        BytesNeeded += ((ValueCch + 1) * sizeof(WCHAR));

    *BytesRequiredOut = BytesNeeded;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspComputeAssemblyIdentityAttributeBytesRequired(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Source,
    OUT SIZE_T *BytesRequiredOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T BytesNeeded = 0;

    if (BytesRequiredOut != NULL)
        *BytesRequiredOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Source != NULL);
    PARAMETER_CHECK(BytesRequiredOut != NULL);

    BytesNeeded = sizeof(ASSEMBLY_IDENTITY_ATTRIBUTE);

    // We do account for the namespace length here because we're presumably about
    // to copy into an ASSEMBLY_IDENTITY_ATTRIBUTE where the namespace isn't pooled.

    if (Source->NamespaceCch != 0)
        BytesNeeded += ((Source->NamespaceCch + 1) * sizeof(WCHAR));

    if (Source->NameCch != 0)
        BytesNeeded += ((Source->NameCch + 1) * sizeof(WCHAR));

    if (Source->ValueCch != 0)
        BytesNeeded += ((Source->ValueCch + 1) * sizeof(WCHAR));

    *BytesRequiredOut = BytesNeeded;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspFindAssemblyIdentityNamespaceInArray(
    IN DWORD Flags,
    IN OUT PCASSEMBLY_IDENTITY_NAMESPACE **NamespacePointerArrayPtr,
    IN OUT ULONG *NamespaceArraySizePtr,
    IN OUT ULONG *NamespaceCountPtr,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG i, j;
    ULONG NamespaceHash = 0;
    ULONG NamespaceCount;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray;
    ULONG NewNamespaceArraySize = 0;
    PCASSEMBLY_IDENTITY_NAMESPACE *NewNamespacePointerArray = NULL;
    PCASSEMBLY_IDENTITY_NAMESPACE NamespacePointer = NULL;
    PCASSEMBLY_IDENTITY_NAMESPACE NewNamespacePointer = NULL;
    ULONG NamespaceArraySize = 0;
    LONG Comparison;

    if (NamespaceOut != NULL)
        *NamespaceOut = NULL;

    PARAMETER_CHECK((Flags & ~(SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND)) == 0);
    PARAMETER_CHECK(NamespacePointerArrayPtr != NULL);
    PARAMETER_CHECK(NamespaceCountPtr != NULL);
    PARAMETER_CHECK(NamespaceArraySizePtr != NULL);
    PARAMETER_CHECK((NamespaceCch == 0) || (Namespace != NULL));

    NamespacePointerArray = *NamespacePointerArrayPtr;
    NamespaceCount = *NamespaceCountPtr;
    NamespaceArraySize = *NamespaceArraySizePtr;

    IFW32FALSE_EXIT(::FusionpHashUnicodeString(Namespace, NamespaceCch, &NamespaceHash, false));

    for (i=0; i<NamespaceCount; i++)
    {
        if (NamespaceHash <= NamespacePointerArray[i]->Hash)
            break;
    }

    // Loop through the duplicate hash values seeing if we have a match.
    while ((i < NamespaceCount) && (NamespacePointerArray[i]->Hash == NamespaceHash) && (NamespacePointerArray[i]->NamespaceCch == NamespaceCch))
    {
        NamespacePointer = NamespacePointerArray[i];

        Comparison = memcmp(Namespace, NamespacePointerArray[i]->Namespace, NamespaceCch * sizeof(WCHAR));
        if (Comparison == 0)
            break;

        NamespacePointer = NULL;
        i++;
    }

    if ((NamespacePointer == NULL) && (Flags & SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND))
    {
        // We didn't find a match.  Allocate a new one and push it into the array at the
        // appropriate location.  If the namespace isn't null.
        if (NamespaceCch != 0)
        {
            IFW32FALSE_EXIT(::SxspAllocateAssemblyIdentityNamespace(0, Namespace, NamespaceCch, NamespaceHash, &NewNamespacePointer));

            // the "i" variable is where we want to insert this one.
            if (i >= NamespaceArraySize)
            {
                NewNamespaceArraySize = NamespaceArraySize + 8;
                IFALLOCFAILED_EXIT(NewNamespacePointerArray = FUSION_NEW_ARRAY(PCASSEMBLY_IDENTITY_NAMESPACE, NewNamespaceArraySize));

                for (j=0; j<NamespaceCount; j++)
                    NewNamespacePointerArray[j] = NamespacePointerArray[j];

                while (j < NewNamespaceArraySize)
                    NewNamespacePointerArray[j++] = NULL;

                FUSION_DELETE_ARRAY(NamespacePointerArray);

                *NamespacePointerArrayPtr = NewNamespacePointerArray;
                *NamespaceArraySizePtr = NewNamespaceArraySize;

                NamespacePointerArray = NewNamespacePointerArray;
                NamespaceArraySize = NewNamespaceArraySize;

                NewNamespacePointerArray = NULL;
                NewNamespaceArraySize = 0;
            }

            ASSERT(i < NamespaceArraySize);

            for (j = NamespaceCount; j > i; j--)
                NamespacePointerArray[j] = NamespacePointerArray[j-1];

            ASSERT(j == i);

            NamespacePointerArray[i] = NewNamespacePointer;
            NamespacePointer = NewNamespacePointer;
            NewNamespacePointer = NULL;

            *NamespaceCountPtr = NamespaceCount + 1;
        }
    }

    if (NamespaceOut != NULL)
        *NamespaceOut = NamespacePointer;

    fSuccess = TRUE;

Exit:
    if (NewNamespacePointer != NULL)
        SxspDeallocateAssemblyIdentityNamespace(NewNamespacePointer);

    if (NewNamespacePointerArray != NULL)
        FUSION_DELETE_ARRAY(NewNamespacePointerArray);

    return fSuccess;
}

BOOL
SxspFindAssemblyIdentityNamespace(
    IN DWORD Flags,
    IN PASSEMBLY_IDENTITY AssemblyIdentity,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCASSEMBLY_IDENTITY_NAMESPACE NamespacePointer = NULL;

    if (NamespaceOut != NULL)
        *NamespaceOut = NULL;

    PARAMETER_CHECK((Flags & ~(SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_FLAG_ADD_IF_NOT_FOUND)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(NamespaceOut != NULL);
    PARAMETER_CHECK((Namespace != NULL) || (NamespaceCch == 0));
    IFW32FALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    IFW32FALSE_EXIT(
        ::SxspFindAssemblyIdentityNamespaceInArray(
            (Flags & SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_FLAG_ADD_IF_NOT_FOUND) ?
                SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND : 0,
            &AssemblyIdentity->NamespacePointerArray,
            &AssemblyIdentity->NamespaceArraySize,
            &AssemblyIdentity->NamespaceCount,
            Namespace,
            NamespaceCch,
            &NamespacePointer));

    *NamespaceOut = NamespacePointer;

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspAllocateAssemblyIdentityNamespace(
    IN DWORD Flags,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    IN ULONG NamespaceHash,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY_NAMESPACE NewNamespace = NULL;
    SIZE_T BytesRequired = 0;

    if (NamespaceOut != NULL)
        *NamespaceOut = NULL;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(NamespaceOut != NULL);
    PARAMETER_CHECK((Namespace != NULL) || (NamespaceHash == 0));
    PARAMETER_CHECK((Namespace != NULL) || (NamespaceCch == 0));

    BytesRequired = sizeof(ASSEMBLY_IDENTITY_NAMESPACE);

    if (NamespaceCch != 0)
        BytesRequired += (NamespaceCch + 1) * sizeof(WCHAR);

    IFALLOCFAILED_EXIT(NewNamespace = reinterpret_cast<PASSEMBLY_IDENTITY_NAMESPACE>(FUSION_RAW_ALLOC(BytesRequired, ASSEMBLY_IDENTITY_NAMESPACE)));

    NewNamespace->Flags = 0;

    if (NamespaceCch != 0)
    {
        NewNamespace->Namespace = (PWSTR) (NewNamespace + 1);
        NewNamespace->NamespaceCch = NamespaceCch;

        memcpy(
            (PVOID) NewNamespace->Namespace,
            Namespace,
            NamespaceCch * sizeof(WCHAR));

        ((PWSTR) NewNamespace->Namespace) [NamespaceCch] = L'\0';
        NewNamespace->NamespaceCch = NamespaceCch;
    }
    else
    {
        NewNamespace->Namespace = NULL;
        NewNamespace->NamespaceCch = 0;
    }

    NewNamespace->Hash = NamespaceHash;

    *NamespaceOut = NewNamespace;
    NewNamespace = NULL;

    fSuccess = TRUE;
Exit:
    if (NewNamespace != NULL)
        FUSION_RAW_DEALLOC(NewNamespace);

    return fSuccess;
}

VOID
SxspDeallocateAssemblyIdentityNamespace(
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace
    )
{
    FN_TRACE();
    // The whole thing is allocated as a single chunk...
    ASSERT(Namespace != NULL);

    if (Namespace != NULL)
        FUSION_RAW_DEALLOC((PVOID) Namespace);
}

BOOL
SxspPopulateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Destination
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PVOID Cursor = NULL;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Destination != NULL);

    Destination->Attribute.Flags = 0;
    Destination->Namespace = Namespace;

    Cursor = (PVOID) (Destination + 1);

    if (Namespace != NULL)
    {
        Destination->Attribute.Namespace = Namespace->Namespace;
        Destination->Attribute.NamespaceCch = Namespace->NamespaceCch;
    }
    else
    {
        Destination->Attribute.Namespace = NULL;
        Destination->Attribute.NamespaceCch = 0;
    }

    if ((Name != NULL) && (NameCch != 0))
    {
        Destination->Attribute.Name = (PWSTR) Cursor;
        memcpy(
            Cursor,
            Name,
            NameCch * sizeof(WCHAR));
        ((PWSTR) Destination->Attribute.Name) [NameCch] = L'\0';
        Destination->Attribute.NameCch = NameCch;
        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((NameCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        Destination->Attribute.Name = NULL;
        Destination->Attribute.NameCch = 0;
    }

    if ((Value != NULL) && (ValueCch != 0))
    {
        Destination->Attribute.Value = (PWSTR) Cursor;
        memcpy(
            Cursor,
            Value,
            ValueCch * sizeof(WCHAR));
        ((PWSTR) Destination->Attribute.Value)[ValueCch] = L'\0';
        Destination->Attribute.ValueCch = ValueCch;
        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((ValueCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        Destination->Attribute.Value = NULL;
        Destination->Attribute.ValueCch = 0;
    }

    IFW32FALSE_EXIT(::SxsHashAssemblyIdentityAttribute(0, &Destination->Attribute, &Destination->WholeAttributeHash));
    IFW32FALSE_EXIT(::SxsHashAssemblyIdentityAttribute(SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE | SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME,
                                &Destination->Attribute, &Destination->NamespaceAndNameHash));
    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspAllocateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Destination
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T BytesNeeded = 0;
    PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE NewAttribute = NULL;

    if (Destination != NULL)
        *Destination = NULL;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Destination != NULL);
    PARAMETER_CHECK((NameCch == 0) || (Name != NULL));
    PARAMETER_CHECK((ValueCch == 0) || (Value != NULL));

    IFW32FALSE_EXIT(::SxspComputeInternalAssemblyIdentityAttributeBytesRequired(0, Name, NameCch, Value, ValueCch, &BytesNeeded));
    IFALLOCFAILED_EXIT(NewAttribute = (PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE) FUSION_RAW_ALLOC(BytesNeeded, INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE));
    IFW32FALSE_EXIT(::SxspPopulateInternalAssemblyIdentityAttribute(0, Namespace, Name, NameCch, Value, ValueCch, NewAttribute));

    *Destination = NewAttribute;
    NewAttribute = NULL;

    fSuccess = TRUE;

Exit:
    if (NewAttribute != NULL)
        FUSION_RAW_DEALLOC(NewAttribute);

    return fSuccess;
}

VOID
SxspDeallocateInternalAssemblyIdentityAttribute(
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    )
{
    FN_TRACE();
    if (Attribute != NULL)
        FUSION_RAW_DEALLOC((PVOID) Attribute);
}

BOOL
SxsCompareAssemblyIdentityAttributes(
    DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute1,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute2,
    OUT ULONG *ComparisonResult
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    LONG Comparison = 0, Comparison1, Comparison2, Comparison3;

    if (Flags == 0)
        Flags = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE |
                SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME |
                SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE;

    PARAMETER_CHECK((Flags & ~(SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE |
                    SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME |
                    SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE)) == 0);
    PARAMETER_CHECK(Attribute1 != NULL);
    PARAMETER_CHECK(Attribute2 != NULL);
    PARAMETER_CHECK(ComparisonResult != NULL);

    if ( Flags & SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE) {
        Comparison1 = FusionpCompareStrings(Attribute1->Namespace, Attribute1->NamespaceCch, Attribute2->Namespace, Attribute2->NamespaceCch, false);
        if (Comparison1 != 0) { // we have get the result
            Comparison = Comparison1 ;
            goto done;
        }
    }

    if ( Flags & SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME) {
        Comparison2 = FusionpCompareStrings(Attribute1->Name, Attribute1->NameCch, Attribute2->Name, Attribute2->NameCch, false);
        if (Comparison2 != 0) { // we have get the result
            Comparison = Comparison2;
            goto done;
        }
    }

    if ( Flags & SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE){
        Comparison3 = FusionpCompareStrings(Attribute1->Value, Attribute1->ValueCch, Attribute2->Value, Attribute2->ValueCch, true);
        if (Comparison3 != 0) { // we have get the result
            Comparison = Comparison3;
            goto done;
        }
    }
    Comparison = 0;
done:
    if (Comparison < 0)
        *ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN;
    else if (Comparison == 0)
        *ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL;
    else
        *ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

int
__cdecl
SxspCompareInternalAttributesForQsort(
    const void *elem1,
    const void *elem2
    )
{
    FN_TRACE();
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE * p1 = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *)elem1;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE patt1 = *p1;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE * p2 = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *)elem2;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE patt2 = *p2;
    LONG Comparison;

    Comparison = FusionpCompareStrings(patt1->Attribute.Namespace, patt1->Attribute.NamespaceCch, patt2->Attribute.Namespace, patt2->Attribute.NamespaceCch, false);
    if (Comparison == 0)
		Comparison = FusionpCompareStrings(patt1->Attribute.Name, patt1->Attribute.NameCch, patt2->Attribute.Name, patt2->Attribute.NameCch, false);
    if (Comparison == 0)
        Comparison = FusionpCompareStrings(patt1->Attribute.Value, patt1->Attribute.ValueCch, patt2->Attribute.Value, patt2->Attribute.ValueCch, true);
    return Comparison;
}

int
__cdecl
SxspCompareULONGsForQsort(
    const void *elem1,
    const void *elem2
    )
{
    FN_TRACE();
    ULONG *pul1 = (ULONG *) elem1;
    ULONG *pul2 = (ULONG *) elem2;

    return ((LONG) *pul1) - ((LONG) *pul2);
}

BOOL
SxspCompareAssemblyIdentityAttributeLists(
    DWORD Flags,
    ULONG AttributeCount,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *List1,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *List2,
    ULONG *ComparisonResultOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL;
    ULONG i;

    if ((Flags != 0) ||
        ((AttributeCount != 0) &&
         ((List1 == NULL) ||
          (List2 == NULL))) ||
        (ComparisonResultOut == NULL))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    for (i=0; i<AttributeCount; i++)
    {
        IFW32FALSE_EXIT(::SxsCompareAssemblyIdentityAttributes(0, &List1[i]->Attribute, &List2[i]->Attribute, &ComparisonResult));

        if (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL){
            break;
        }
    }

    *ComparisonResultOut = ComparisonResult;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspHashInternalAssemblyIdentityAttributes(
    DWORD Flags,
    ULONG Count,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Attributes,
    ULONG *HashOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG Hash = 0;
    ULONG i;

    if (HashOut != NULL)
        *HashOut = 0;

    if ((Flags != 0) ||
        ((Count != 0) && (Attributes == NULL)) ||
        (HashOut == NULL))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    for (i=0; i<Count; i++)
        Hash = (Hash * 65599) + Attributes[i]->WholeAttributeHash;

    *HashOut = Hash;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

VOID SxspDbgPrintInternalAssemblyIdentityAttribute(DWORD dwflags, PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute)
{
    ::FusionpDbgPrintEx(dwflags, "Attribute: \n"
        "\tNamespace = %S, \tNamespaceCch = %d\n"
        "\tAttributeName = %S, \tAttributeNameCch = %d\n"
        "\tAttributeValue = %S, \tAttributeValueCch = %d\n\n",
        Attribute->Attribute.Namespace == NULL ? L"" : Attribute->Attribute.Namespace, Attribute->Attribute.NamespaceCch,
        Attribute->Attribute.Name == NULL ? L"" : Attribute->Attribute.Name, Attribute->Attribute.NameCch,
        Attribute->Attribute.Value == NULL ? L"" : Attribute->Attribute.Value, Attribute->Attribute.ValueCch);

    return;
}
VOID
SxspDbgPrintInternalAssemblyIdentityAttributes(DWORD dwflags, ULONG AttributeCount, PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes)
{
    for ( DWORD i=0;i<AttributeCount;i++){
        SxspDbgPrintInternalAssemblyIdentityAttribute(dwflags, Attributes[i]);
    }
    return;
}
VOID SxspDbgPrintAssemblyIdentity(DWORD dwflags, PCASSEMBLY_IDENTITY pAssemblyIdentity){
    if ( pAssemblyIdentity) {
        SxspDbgPrintInternalAssemblyIdentityAttributes(dwflags, pAssemblyIdentity->AttributeCount,
            pAssemblyIdentity->AttributePointerArray);
    }
    return;
}

VOID SxspDbgPrintAssemblyIdentityAttribute(DWORD dwflags, PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute)
{
    ::FusionpDbgPrintEx(dwflags, "Attribute: \n"
        "\tNamespace = %S, \tNamespaceCch = %d\n"
        "\tAttributeName = %S, \tAttributeNameCch = %d\n"
        "\tAttributeValue = %S, \tAttributeValueCch = %d\n\n",
        Attribute->Namespace == NULL ? L"" : Attribute->Namespace, Attribute->NamespaceCch,
        Attribute->Name == NULL ? L"" : Attribute->Name, Attribute->NameCch,
        Attribute->Value == NULL ? L"" : Attribute->Value, Attribute->ValueCch);

    return;
}
VOID
SxspDbgPrintAssemblyIdentityAttributes(DWORD dwflags, ULONG AttributeCount, PCASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes)
{
    for ( DWORD i=0;i<AttributeCount;i++){
        SxspDbgPrintAssemblyIdentityAttribute(dwflags, Attributes[i]);
    }
}

BOOL
SxsCreateAssemblyIdentity(
    DWORD Flags,
    ULONG Type,
    PASSEMBLY_IDENTITY *AssemblyIdentityOut,
    ULONG AttributeCount,
    PCASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    ULONG AttributeArraySize = 0;
    SIZE_T BytesNeeded = 0;
    ULONG i;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = NULL;
    ULONG NamespaceArraySize = 0;
    ULONG NamespaceCount = 0;

#if DBG
    ::SxspDbgPrintAssemblyIdentityAttributes(FUSION_DBG_LEVEL_VERBOSE, AttributeCount, Attributes);
#endif
    if (AssemblyIdentityOut != NULL)
        *AssemblyIdentityOut = NULL;

    if (((Flags & ~(SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)) != 0) ||
        ((Type != ASSEMBLY_IDENTITY_TYPE_DEFINITION) &&
         (Type != ASSEMBLY_IDENTITY_TYPE_REFERENCE) &&
         (Type != ASSEMBLY_IDENTITY_TYPE_WILDCARD)) ||
         ((AttributeCount != 0) && (Attributes == NULL)))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    //
    //  Validate all our inputs before we get started...
    for (i=0; i<AttributeCount; i++)
    {
        IFW32FALSE_EXIT(::SxsValidateAssemblyIdentityAttribute(0, Attributes[i]));
    }

    //
    //  If we were told that this is a frozen assembly identity, we could be super-smart and
    //  have a single allocation for the whole thing.  Instead we'll leave that optimization
    //  for a future maintainer.  We'll at least be smart enough to allocate both the
    //  assembly identity and the array of attribute pointers in a single whack tho'.
    //

    if (Flags & SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
    {
        AttributeArraySize = AttributeCount;
    }
    else
    {
        // For non-frozen identities, we'll add a rounding factor and round up for the number of
        // array elements.
        AttributeArraySize = (AttributeCount + (1 << ROUNDING_FACTOR_BITS)) & ~((1 << ROUNDING_FACTOR_BITS) - 1);
    }

    // allocate everything except namespace array
    BytesNeeded = sizeof(ASSEMBLY_IDENTITY) + (AttributeArraySize * sizeof(PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE));
    IFALLOCFAILED_EXIT(AssemblyIdentity = (PASSEMBLY_IDENTITY) FUSION_RAW_ALLOC(BytesNeeded, ASSEMBLY_IDENTITY));

    if (AttributeArraySize != 0)
    {
        AttributePointerArray = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *) (AssemblyIdentity + 1);

        // Initialize the pointers so we can clean up non-NULL ones in the error path
        for (i=0; i<AttributeArraySize; i++)
            AttributePointerArray[i] = NULL;
    }

    for (i=0; i<AttributeCount; i++)
    {
        PCASSEMBLY_IDENTITY_NAMESPACE NamespacePointer = NULL;

        IFW32FALSE_EXIT(
            ::SxspFindAssemblyIdentityNamespaceInArray(
                    SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND,
                    &NamespacePointerArray,
                    &NamespaceArraySize,
                    &NamespaceCount,
                    Attributes[i]->Namespace,
                    Attributes[i]->NamespaceCch,
                    &NamespacePointer));
        IFW32FALSE_EXIT(
            ::SxspAllocateInternalAssemblyIdentityAttribute(
                0,
                NamespacePointer,
                Attributes[i]->Name,
                Attributes[i]->NameCch,
                Attributes[i]->Value,
                Attributes[i]->ValueCch,
                &AttributePointerArray[i]));
    }

    // sort 'em.
    qsort((PVOID) AttributePointerArray, AttributeCount, sizeof(PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE), SxspCompareInternalAttributesForQsort);

    AssemblyIdentity->AttributeArraySize = AttributeArraySize;
    AssemblyIdentity->AttributeCount = AttributeCount;
    AssemblyIdentity->AttributePointerArray = AttributePointerArray;
    AssemblyIdentity->NamespaceArraySize = NamespaceArraySize;
    AssemblyIdentity->NamespaceCount = NamespaceCount;
    AssemblyIdentity->NamespacePointerArray = NamespacePointerArray;
    AssemblyIdentity->Flags = 0;
    AssemblyIdentity->InternalFlags = ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION; // namespace is allocated sperately
    AssemblyIdentity->Type = Type;
    AssemblyIdentity->HashDirty = TRUE;

    AttributePointerArray = NULL;
    NamespacePointerArray = NULL;

    IFW32FALSE_EXIT(::SxspEnsureAssemblyIdentityHashIsUpToDate(0, AssemblyIdentity));

    if (Flags & SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
        AssemblyIdentity->Flags |= ASSEMBLY_IDENTITY_FLAG_FROZEN;

    *AssemblyIdentityOut = AssemblyIdentity;
    AssemblyIdentity = NULL;

    fSuccess = TRUE;

Exit:
    if ((AttributePointerArray != NULL) && (AttributeCount != 0))
    {
        for (i=0; i<AttributeCount; i++)
            ::SxspDeallocateInternalAssemblyIdentityAttribute(AttributePointerArray[i]);
    }

    if ((NamespacePointerArray != NULL) && (NamespaceCount != 0))
    {
        for (i=0; i<NamespaceCount; i++)
            ::SxspDeallocateAssemblyIdentityNamespace(NamespacePointerArray[i]);

        FUSION_DELETE_ARRAY(NamespacePointerArray);
    }

    if (AssemblyIdentity != NULL)
    {
        FUSION_RAW_DEALLOC(AssemblyIdentity);
    }

    return fSuccess;
}

BOOL
SxsFreezeAssemblyIdentity(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if ((Flags != 0) ||
        (AssemblyIdentity == NULL))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    // We could possibly do something really interesting like realloc the whole thing but
    // instead we'll just set the flag that stops future modifications.

    AssemblyIdentity->Flags |= ASSEMBLY_IDENTITY_FLAG_FROZEN;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

VOID
SxsDestroyAssemblyIdentity(
    PASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    FN_TRACE();
    CSxsPreserveLastError ple;

    if (AssemblyIdentity == NULL)
        return;

    ULONG i;

    //
    // An identity that's created frozen (whether created new or copied from an existing identity)
    // uses a single allocation for everything.  Only free the suballocations if we're not
    // in this state.
    //

    if (!(AssemblyIdentity->InternalFlags & ASSEMBLY_IDENTITY_INTERNAL_FLAG_SINGLE_ALLOCATION_FOR_EVERYTHING))
    {
        const ULONG AttributeCount = AssemblyIdentity->AttributeCount;
        PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = AssemblyIdentity->AttributePointerArray;
        const ULONG NamespaceCount = AssemblyIdentity->NamespaceCount;
        PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = AssemblyIdentity->NamespacePointerArray;

        for (i=0; i<AttributeCount; i++)
        {
            ::SxspDeallocateInternalAssemblyIdentityAttribute((PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE) AttributePointerArray[i]);
            AttributePointerArray[i] = NULL;
        }

        for (i=0; i<NamespaceCount; i++)
        {
            ::SxspDeallocateAssemblyIdentityNamespace(NamespacePointerArray[i]);
            NamespacePointerArray[i] = NULL;
        }

        if (AssemblyIdentity->InternalFlags & ASSEMBLY_IDENTITY_INTERNAL_FLAG_ATTRIBUTE_POINTERS_IN_SEPARATE_ALLOCATION)
        {
            FUSION_DELETE_ARRAY(AttributePointerArray);
            AssemblyIdentity->AttributePointerArray = NULL;
        }

        if (AssemblyIdentity->InternalFlags & ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION)
        {
            FUSION_DELETE_ARRAY(NamespacePointerArray);
            AssemblyIdentity->NamespacePointerArray = NULL;
        }
    }

    FUSION_RAW_DEALLOC(AssemblyIdentity);

    ple.Restore();
}

BOOL
SxspCopyInternalAssemblyIdentityAttributeOut(
    DWORD Flags,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    SIZE_T BufferSize,
    PASSEMBLY_IDENTITY_ATTRIBUTE DestinationBuffer,
    SIZE_T *BytesCopiedOrRequired
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T BytesRequired = 0;
    PVOID Cursor;

    if (BytesCopiedOrRequired != NULL)
        *BytesCopiedOrRequired = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK((BufferSize == 0) || (DestinationBuffer != NULL));
    PARAMETER_CHECK((BufferSize != 0) || (BytesCopiedOrRequired != NULL));

    IFW32FALSE_EXIT(::SxspComputeAssemblyIdentityAttributeBytesRequired(0, &Attribute->Attribute, &BytesRequired));

    if (BufferSize < BytesRequired)
    {
        if (BytesCopiedOrRequired != NULL)
            *BytesCopiedOrRequired = BytesRequired;

        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);
    }

    // We must be in the clear...
    DestinationBuffer->Flags = 0;

    Cursor = (PVOID) (DestinationBuffer + 1);

    if (Attribute->Attribute.NamespaceCch != 0)
    {
        DestinationBuffer->Namespace = (PWSTR) Cursor;
        DestinationBuffer->NamespaceCch = Attribute->Attribute.NamespaceCch;

        // We always internally store the strings with a null terminating character, so just copy
        // it with the body of the string.
        memcpy(
            Cursor,
            Attribute->Attribute.Namespace,
            (Attribute->Attribute.NamespaceCch + 1) * sizeof(WCHAR));

        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((Attribute->Attribute.NamespaceCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        DestinationBuffer->Namespace = NULL;
        DestinationBuffer->NamespaceCch = 0;
    }

    if (Attribute->Attribute.NameCch != 0)
    {
        DestinationBuffer->Name = (PWSTR) Cursor;
        DestinationBuffer->NameCch = Attribute->Attribute.NameCch;

        // We always internally store the strings with a null terminating character, so just copy
        // it with the body of the string.
        memcpy(
            Cursor,
            Attribute->Attribute.Name,
            (Attribute->Attribute.NameCch + 1) * sizeof(WCHAR));

        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((Attribute->Attribute.NameCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        DestinationBuffer->Name = NULL;
        DestinationBuffer->NameCch = 0;
    }

    if (Attribute->Attribute.ValueCch != 0)
    {
        DestinationBuffer->Value = (PWSTR) Cursor;
        DestinationBuffer->ValueCch = Attribute->Attribute.ValueCch;

        // We always internally store the strings with a null terminating character, so just copy
        // it with the body of the string.
        memcpy(
            Cursor,
            Attribute->Attribute.Value,
            (Attribute->Attribute.ValueCch + 1) * sizeof(WCHAR));

        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((Attribute->Attribute.ValueCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        DestinationBuffer->Value = NULL;
        DestinationBuffer->ValueCch = 0;
    }

    if (BytesCopiedOrRequired != NULL)
    {
        *BytesCopiedOrRequired = (((ULONG_PTR) Cursor) - ((ULONG_PTR) DestinationBuffer));
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspLocateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *InternalAttributeOut,
    OUT ULONG *LastIndexSearched OPTIONAL
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    ULONG i = 0;
    ULONG AttributeCount = 0;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    ULONG ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = NULL;
    ULONG LowIndex = 0;
    ULONG HighIndexPlusOne = 0;
    ULONG CompareAttributesFlags = 0;

    if (InternalAttributeOut != NULL)
        *InternalAttributeOut = NULL;

    if (LastIndexSearched != NULL)
        *LastIndexSearched = 0;

    if (((Flags & ~(SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                    SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                    SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE |
                    SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL)) != 0) ||
        (AssemblyIdentity == NULL) ||
        (Attribute == NULL) ||
        (InternalAttributeOut == NULL))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if ((Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME) &&
        !(Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if ((Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE) &&
        !(Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if (Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE)
    {
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE;
    }

    if (Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME)
    {
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME;
    }

    if (Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE)
    {
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE;
    }

    AttributeCount = AssemblyIdentity->AttributeCount;
    AttributePointerArray = AssemblyIdentity->AttributePointerArray;

    LowIndex = 0;
    HighIndexPlusOne = AttributeCount;
    i = 0;

    while (LowIndex < HighIndexPlusOne)
    {
        i = (LowIndex + HighIndexPlusOne) / 2;

        if (i == HighIndexPlusOne)
        {
            i = LowIndex;
        }

        IFW32FALSE_EXIT(
            ::SxsCompareAssemblyIdentityAttributes(
                CompareAttributesFlags,
                Attribute,
                &AttributePointerArray[i]->Attribute,
                &ComparisonResult));

        INTERNAL_ERROR_CHECK(
            (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL) ||
            (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN) ||
            (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN));

        if (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
        {
            InternalAttribute = AttributePointerArray[i];
            break;
        }
        else if (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN)
        {
            if ( HighIndexPlusOne == i){
                i--;
                break;
            }
            else
                HighIndexPlusOne = i;
        }
        else if (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN)
        {
            if ( LowIndex == i){
                i++;
                break;
            }
            else
                LowIndex = i;
        }
    }

    // If it's equal, there's no guarantee it's the first.  Back up to find the first non-equal match
    if (InternalAttribute != NULL)
    {
        while (i > 0)
        {
            IFW32FALSE_EXIT(
                ::SxsCompareAssemblyIdentityAttributes(
                    CompareAttributesFlags,
                    Attribute,
                    &AttributePointerArray[i - 1]->Attribute,
                    &ComparisonResult));

            if (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
                break;

            i--;
            InternalAttribute = AttributePointerArray[i];
        }
    }

    if (InternalAttribute != NULL)
        *InternalAttributeOut = InternalAttribute;

    if (LastIndexSearched != NULL)
        *LastIndexSearched = i;

    // If we didn't find it, return ERROR_NOT_FOUND.
    if (((Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL) == 0) &&
        (InternalAttribute == NULL))
        ORIGINATE_WIN32_FAILURE_AND_EXIT(LocatingAssemblyIdentityAttribute, ERROR_NOT_FOUND);

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxsInsertAssemblyIdentityAttribute(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    PCASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttribute
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCASSEMBLY_IDENTITY_NAMESPACE Namespace = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE NewInternalAttribute = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *NewAttributePointerArray = NULL;
    ULONG NewAttributeArraySize = 0;
    ULONG i;
    ULONG LastIndexSearched;

    PARAMETER_CHECK((Flags & ~(SXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_OVERWRITE_EXISTING)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(AssemblyIdentityAttribute != NULL);

    IFW32FALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));
    IFW32FALSE_EXIT(::SxsValidateAssemblyIdentityAttribute(0, AssemblyIdentityAttribute));

    INTERNAL_ERROR_CHECK((AssemblyIdentity->Flags & ASSEMBLY_IDENTITY_FLAG_FROZEN) == 0);

    IFW32FALSE_EXIT(
        ::SxspFindAssemblyIdentityNamespace(
            SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_FLAG_ADD_IF_NOT_FOUND,
            AssemblyIdentity,
            AssemblyIdentityAttribute->Namespace,
            AssemblyIdentityAttribute->NamespaceCch,
            &Namespace));

    // Let's see if we can find it.
    IFW32FALSE_EXIT(
        ::SxspLocateInternalAssemblyIdentityAttribute(
            SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
            SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
            SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyIdentity,
            AssemblyIdentityAttribute,
            &InternalAttribute,
            &LastIndexSearched));

    if (InternalAttribute != NULL)
    {
        if (Flags & SXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_OVERWRITE_EXISTING)
        {
            // Ok, replace it!
            IFW32FALSE_EXIT(
                ::SxspAllocateInternalAssemblyIdentityAttribute(
                    0,
                    Namespace,
                    AssemblyIdentityAttribute->Name,
                    AssemblyIdentityAttribute->NameCch,
                    AssemblyIdentityAttribute->Value,
                    AssemblyIdentityAttribute->ValueCch,
                    &NewInternalAttribute));
            AssemblyIdentity->AttributePointerArray[LastIndexSearched] = NewInternalAttribute;
            NewInternalAttribute = NULL;

            ::SxspDeallocateInternalAssemblyIdentityAttribute(InternalAttribute);
        }
        else
        {
            // We actually wanted it to fail...
            ORIGINATE_WIN32_FAILURE_AND_EXIT(InserttingNonDuplicateAttribute, ERROR_DUP_NAME);
        }
    }
    else
    {
        IFW32FALSE_EXIT(
            ::SxspAllocateInternalAssemblyIdentityAttribute(
                0,
                Namespace,
                AssemblyIdentityAttribute->Name,
                AssemblyIdentityAttribute->NameCch,
                AssemblyIdentityAttribute->Value,
                AssemblyIdentityAttribute->ValueCch,
                &NewInternalAttribute));

        // Now we have it and we even know where to put it.  Grow the array if we need to.
        if (AssemblyIdentity->AttributeCount == AssemblyIdentity->AttributeArraySize)
        {
            NewAttributeArraySize = AssemblyIdentity->AttributeCount + 8;

            IFALLOCFAILED_EXIT(NewAttributePointerArray = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *) FUSION_RAW_ALLOC(sizeof(PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE) * NewAttributeArraySize, PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE));

            // Instead of copying the data and then shuffling, we'll copy the stuff before the insertion
            // point, fill in at the insertion point and then copy the rest.

            for (i=0; i<LastIndexSearched; i++)
                NewAttributePointerArray[i] = AssemblyIdentity->AttributePointerArray[i];

            for (i=LastIndexSearched; i<AssemblyIdentity->AttributeCount; i++)
                NewAttributePointerArray[i+1] = AssemblyIdentity->AttributePointerArray[i];

            if (AssemblyIdentity->AttributePointerArray != NULL)
                FUSION_RAW_DEALLOC((PVOID) AssemblyIdentity->AttributePointerArray);

            AssemblyIdentity->AttributePointerArray = NewAttributePointerArray;
            AssemblyIdentity->AttributeArraySize = NewAttributeArraySize;
        }
        else
        {
            // The array's big enough; shuffle the ending part of the array down one.
            for (i=AssemblyIdentity->AttributeCount; i>LastIndexSearched; i--)
                AssemblyIdentity->AttributePointerArray[i] = AssemblyIdentity->AttributePointerArray[i-1];
        }

        AssemblyIdentity->AttributePointerArray[LastIndexSearched] = NewInternalAttribute;
        NewInternalAttribute = NULL;

        AssemblyIdentity->AttributeCount++;
    }

    AssemblyIdentity->HashDirty = TRUE;

    fSuccess = TRUE;
Exit:
    if (NewInternalAttribute != NULL)
        ::SxspDeallocateInternalAssemblyIdentityAttribute(NewInternalAttribute);

    return fSuccess;
}

BOOL
SxsRemoveAssemblyIdentityAttributesByOrdinal(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    ULONG Ordinal,
    ULONG Count
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG AttributeCount;
    ULONG i;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    ULONG StopIndex;

    if ((Flags != 0) ||
        (AssemblyIdentity == NULL) ||
        (Count == 0))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    IFW32FALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    AttributeCount = AssemblyIdentity->AttributeCount;
    AttributePointerArray = AssemblyIdentity->AttributePointerArray;

    // We can't delete outside the bounds of [0 .. AttributeCount - 1]
    if ((Ordinal >= AssemblyIdentity->AttributeCount) ||
        (Count > AssemblyIdentity->AttributeCount) ||
        ((Ordinal + Count) > AssemblyIdentity->AttributeCount))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    StopIndex = Ordinal + Count;

    // Let's get rid of them!  We're going to go through the array twice; it's somewhat
    // unnecessary but in the first run, we're going to NULL out any attribute pointers
    // that we're removing and clean up namespaces that aren't in use any more.  On the
    // second pass, we'll compress the array down.  This is somewhat wasteful, but
    // in the alternative case, we end up doing "Count" shifts down of the tail of the array.

    for (i = Ordinal; i < StopIndex; i++)
    {
        PCASSEMBLY_IDENTITY_NAMESPACE Namespace = NULL;
        PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = AttributePointerArray[i];

        // If this is the last use of this namespace, keep track of it so we can
        // clean it up.

        if ((i + 1) < AttributeCount)
        {
            // If the next attribute has a different namespace, there's some possibility
            // that this attribute was the last one that used it, so we'll delete the
            // attribute then ask to get rid of the namespace if there aren't any more
            // attributes using it.
            if (AttributePointerArray[i+1]->Namespace != InternalAttribute->Namespace)
                Namespace = InternalAttribute->Namespace;
        }

        AttributePointerArray[i] = NULL;

        SxspDeallocateInternalAssemblyIdentityAttribute(InternalAttribute);

        if (Namespace != NULL)
            SxspCleanUpAssemblyIdentityNamespaceIfNotReferenced(0, AssemblyIdentity, Namespace);
    }

    for (i = StopIndex; i < AttributeCount; i++)
    {
        AttributePointerArray[i - Count] = AttributePointerArray[i];
        AttributePointerArray[i] = NULL;
    }

    AssemblyIdentity->AttributeCount -= Count;
    AssemblyIdentity->HashDirty = TRUE;
    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxsFindAssemblyIdentityAttribute(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    ULONG *OrdinalOut,
    ULONG *CountOut OPTIONAL
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG ValidateAttributeFlags = 0;
    ULONG LocateAttributeFlags = 0;
    ULONG CompareAttributesFlags = 0;
    ULONG Ordinal;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = NULL;
    ULONG AttributeCount = 0;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    ULONG i;
    ULONG ComparisonResult;

    if (OrdinalOut != NULL)
        *OrdinalOut = 0;

    if (CountOut != NULL)
        *CountOut = 0;

    if (((Flags & ~(SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS)) != 0) ||
        (AssemblyIdentity == NULL) ||
        (Attribute == NULL))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if (Flags == 0)
        Flags = SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE;

    PARAMETER_CHECK(
        ((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME) == 0) ||
        ((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE) != 0));

    PARAMETER_CHECK((Flags &
                        (SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE |
                         SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                         SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE)) != 0);

    PARAMETER_CHECK(
        ((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE) == 0) ||
        (((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME) != 0) &&
         ((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE) != 0)));

    IFW32FALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    ValidateAttributeFlags = 0;

    if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE)
    {
        ValidateAttributeFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE;
        LocateAttributeFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE;
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE;
    }

    if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME)
    {
        ValidateAttributeFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME;
        LocateAttributeFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME;
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME;
    }

    if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE)
    {
        ValidateAttributeFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE;
        LocateAttributeFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE;
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE;
    }

    IFW32FALSE_EXIT(::SxsValidateAssemblyIdentityAttribute(ValidateAttributeFlags, Attribute));

    if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS)
        LocateAttributeFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL;

    IFW32FALSE_EXIT(::SxspLocateInternalAssemblyIdentityAttribute(LocateAttributeFlags, AssemblyIdentity, Attribute, &InternalAttribute, &Ordinal));

    INTERNAL_ERROR_CHECK((InternalAttribute != NULL) || (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS));

    if (InternalAttribute != NULL)
    {
        if (CountOut != NULL)
        {
            // We found it, now let's look for how many matches we have.  We'll separately handle the three levels
            // of specificity:

            AttributeCount = AssemblyIdentity->AttributeCount;
            AttributePointerArray = AssemblyIdentity->AttributePointerArray;

            for (i = (Ordinal + 1); i<AttributeCount; i++)
            {
                PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE AnotherInternalAttribute = AttributePointerArray[i];

                if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE)
                {
                    // If the hashes are different, we're certainly different.
                    if (AnotherInternalAttribute->WholeAttributeHash != InternalAttribute->WholeAttributeHash)
                        break;
                }
                else if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME)
                {
                    // If the hashes are different, we're certainly different.
                    if (AnotherInternalAttribute->NamespaceAndNameHash != InternalAttribute->NamespaceAndNameHash)
                        break;
                }
                else
                {
                    INTERNAL_ERROR_CHECK((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE) != 0);
                    // If the hashes are different, we're certainly different.
                    if (AnotherInternalAttribute->Namespace->Hash != InternalAttribute->Namespace->Hash)
                        break;
                }

                IFW32FALSE_EXIT(
                    ::SxsCompareAssemblyIdentityAttributes(
                        CompareAttributesFlags,
                        Attribute,
                        &AnotherInternalAttribute->Attribute,
                        &ComparisonResult));

                if (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
                    break;
            }

            *CountOut = i - Ordinal;
        }

        if (OrdinalOut != NULL)
            *OrdinalOut = Ordinal;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

VOID
SxspCleanUpAssemblyIdentityNamespaceIfNotReferenced(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    PCASSEMBLY_IDENTITY_NAMESPACE Namespace
    )
{
    FN_TRACE();

    ASSERT(AssemblyIdentity != NULL);
    ASSERT(Flags == 0);

    if ((AssemblyIdentity != NULL) && (Namespace != NULL))
    {
        const ULONG AttributeCount = AssemblyIdentity->AttributeCount;
        PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = AssemblyIdentity->AttributePointerArray;
        ULONG i;

        // We could do some sort of binary search here based on the text string of the namespace since
        // the attributes are sorted first on namespace, but my guess is that a single text comparison
        // is worth a few dozen simple pointer comparisons, so the attribute array would have to be
        // pretty darned huge for the k1*O(log n) to be faster than the k2*(n) algorithm to actually
        // dominate.
        for (i=0; i<AttributeCount; i++)
        {
            const PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = AttributePointerArray[i];

            if ((InternalAttribute != NULL) &&
                (InternalAttribute->Namespace == Namespace))
                break;
        }

        if (i == AttributeCount)
        {
            // We fell through; it must be orphaned.
            const ULONG NamespaceCount = AssemblyIdentity->NamespaceCount;
            PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = AssemblyIdentity->NamespacePointerArray;

            for (i=0; i<NamespaceCount; i++)
            {
                if (NamespacePointerArray[i] == Namespace)
                    break;
            }

            // This assert should only fire if the namespace isn't actually present.
            ASSERT(i != NamespaceCount);

            if (i != NamespaceCount)
            {
                ULONG j;

                for (j=(i+1); j<NamespaceCount; j++)
                    NamespacePointerArray[j-1] = NamespacePointerArray[j];

                NamespacePointerArray[NamespaceCount - 1] = NULL;

                ::SxspDeallocateAssemblyIdentityNamespace(Namespace);

                AssemblyIdentity->NamespaceCount--;
            }
        }
    }

    AssemblyIdentity->HashDirty = TRUE;
}

BOOL
SxsGetAssemblyIdentityAttributeByOrdinal(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    ULONG Ordinal,
    SIZE_T BufferSize,
    PASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttributeBuffer,
    SIZE_T *BytesWrittenOrRequired
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (BytesWrittenOrRequired != NULL)
        *BytesWrittenOrRequired = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK((BufferSize == 0) || (AssemblyIdentityAttributeBuffer != NULL));
    PARAMETER_CHECK((BufferSize != 0) || (BytesWrittenOrRequired != NULL));
    PARAMETER_CHECK(Ordinal < AssemblyIdentity->AttributeCount);

    IFW32FALSE_EXIT(
        ::SxspCopyInternalAssemblyIdentityAttributeOut(
            0,
            AssemblyIdentity->AttributePointerArray[Ordinal],
            BufferSize,
            AssemblyIdentityAttributeBuffer,
            BytesWrittenOrRequired));

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxsDuplicateAssemblyIdentity(
    DWORD Flags,
    PCASSEMBLY_IDENTITY Source,
    PASSEMBLY_IDENTITY *Destination
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY NewIdentity = NULL;
    ULONG CreateAssemblyIdentityFlags = 0;

    if (Destination != NULL)
        *Destination = NULL;

    PARAMETER_CHECK((Flags & ~(SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE | SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_ALLOW_NULL)) == 0);
    PARAMETER_CHECK(((Flags & SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_ALLOW_NULL) != 0) || (Source != NULL));
    PARAMETER_CHECK(Destination != NULL);

    if (Flags & SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
        CreateAssemblyIdentityFlags |= SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE;

    //
    //  We depend on the Attribute field being first in the internal attribute
    //  structure below where we callously cast a pointer to an array of
    //  internal attribute pointers into a pointer to an array of attribute pointers.
    //

    ASSERT(FIELD_OFFSET(INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE, Attribute) == 0);

    if (Source != NULL)
    {
        IFW32FALSE_EXIT(
            ::SxsCreateAssemblyIdentity(
                        CreateAssemblyIdentityFlags,
                        Source->Type,
                        &NewIdentity,
                        Source->AttributeCount,
                        (PASSEMBLY_IDENTITY_ATTRIBUTE const *) Source->AttributePointerArray));
    }

    *Destination = NewIdentity;
    NewIdentity = NULL;

    fSuccess = TRUE;

Exit:
    if (NewIdentity != NULL)
        SxsDestroyAssemblyIdentity(NewIdentity);

    return fSuccess;
}

BOOL
SxsQueryAssemblyIdentityInformation(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PVOID Buffer,
    SIZE_T BufferSize,
    ASSEMBLY_IDENTITY_INFORMATION_CLASS AssemblyIdentityInformationClass
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(AssemblyIdentityInformationClass == AssemblyIdentityBasicInformation);

    IFW32FALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    switch (AssemblyIdentityInformationClass)
    {
        case AssemblyIdentityBasicInformation: {
            PASSEMBLY_IDENTITY_BASIC_INFORMATION BasicBuffer = NULL;

            if (BufferSize < sizeof(ASSEMBLY_IDENTITY_BASIC_INFORMATION))
                ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

            BasicBuffer = (PASSEMBLY_IDENTITY_BASIC_INFORMATION) Buffer;

            BasicBuffer->Flags = AssemblyIdentity->Flags;
            BasicBuffer->Type = AssemblyIdentity->Type;
            BasicBuffer->AttributeCount = AssemblyIdentity->AttributeCount;
            BasicBuffer->Hash = AssemblyIdentity->Hash;

            break;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxsEnumerateAssemblyIdentityAttributes(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    IN PSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_ENUMERATION_ROUTINE EnumerationRoutine,
    IN PVOID Context
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG AttributeCount;
    ULONG i;
    ULONG ValidateFlags = 0;
    ULONG CompareFlags = 0;

    if (((Flags & ~(SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAMESPACE |
                    SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAME |
                    SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_VALUE)) != 0) ||
        ((Flags & (SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAMESPACE |
                   SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAME |
                   SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_VALUE)) &&
         (Attribute == NULL)) ||
        (AssemblyIdentity == NULL) ||
        (EnumerationRoutine == NULL))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    IFW32FALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    if (Flags & SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAMESPACE)
    {
        ValidateFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE;
        CompareFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE;
    }

    if (Flags & SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAME)
    {
        ValidateFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME;
        CompareFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME;
    }

    if (Flags & SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_VALUE)
    {
        ValidateFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE;
        CompareFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE;
    }

    IFW32FALSE_EXIT(::SxsValidateAssemblyIdentityAttribute(ValidateFlags, Attribute));

    AttributeCount = AssemblyIdentity->AttributeCount;

    for (i=0; i<AttributeCount; i++)
    {
        PCASSEMBLY_IDENTITY_ATTRIBUTE CandidateAttribute = &AssemblyIdentity->AttributePointerArray[i]->Attribute;
        ULONG ComparisonResult = 0;

        if (CompareFlags != 0)
        {
            IFW32FALSE_EXIT(
                ::SxsCompareAssemblyIdentityAttributes(
                    CompareFlags,
                    Attribute,
                    CandidateAttribute,
                    &ComparisonResult));

            // If they're not equal, skip it!
            if (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
                continue;
        }

        (*EnumerationRoutine)(
            AssemblyIdentity,
            CandidateAttribute,
            Context);
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspIsInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    OUT BOOL *EqualsOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (EqualsOut != NULL)
        *EqualsOut = FALSE;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK(Namespace != NULL || NamespaceCch == 0);
    PARAMETER_CHECK(Name != NULL || NameCch == 0);
    PARAMETER_CHECK(EqualsOut != NULL);

    if ((NamespaceCch == Attribute->Attribute.NamespaceCch) &&
        (NameCch == Attribute->Attribute.NameCch))
    {
        if ((NamespaceCch == 0) ||
            (memcmp(Attribute->Attribute.Namespace, Namespace, NamespaceCch * sizeof(WCHAR)) == 0))
        {
            if ((NameCch == 0) ||
                (memcmp(Attribute->Attribute.Name, Name, NameCch * sizeof(WCHAR)) == 0))
            {
                *EqualsOut = TRUE;
            }
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
SxspDoesStringIndicatePolicy(
    SIZE_T cchString,
    PCWSTR pcwsz,
    BOOL &fIsPolicy
    )
{
    FN_PROLOG_WIN32;
    fIsPolicy = FALSE;

    //
    // If this type is just "policy", then it's a policy.
    //
    if (FusionpEqualStrings(pcwsz, cchString, ASSEMBLY_TYPE_POLICY, ASSEMBLY_TYPE_POLICY_CCH, false)) 
    {
        fIsPolicy = TRUE;
    }
    //
    // If this string ends in -policy, then it's a policy assembly
    //
    else if ((cchString > ASSEMBLY_TYPE_POLICY_SUFFIX_CCH) &&
        FusionpEqualStrings(
            pcwsz + (cchString - ASSEMBLY_TYPE_POLICY_SUFFIX_CCH), 
            ASSEMBLY_TYPE_POLICY_SUFFIX_CCH,
            ASSEMBLY_TYPE_POLICY_SUFFIX,
            ASSEMBLY_TYPE_POLICY_SUFFIX_CCH,
            false))
    {
        fIsPolicy = TRUE;
    }

    FN_EPILOG;

}

BOOL
SxspDetermineAssemblyType(
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    BOOL &fIsPolicyAssembly
    )
{
    FN_PROLOG_WIN32;
    PCWSTR pcwszType = NULL;
    SIZE_T cchType = 0;

    fIsPolicyAssembly = FALSE;

    PARAMETER_CHECK(pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            pAssemblyIdentity,
            &s_IdentityAttribute_type,
            &pcwszType,
            &cchType));

    IFW32FALSE_EXIT(::SxspDoesStringIndicatePolicy(cchType, pcwszType, fIsPolicyAssembly));

    FN_EPILOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\id\sources.inc ===
!IF 0
Copyright (c) 2000-2001  Microsoft Corporation
!ENDIF

MAJORCOMP=fusion
MINORCOMP=id

TARGETNAME=$(FUSION_BUILD_TYPE_PREFIX)id
TARGETTYPE=LIBRARY
TARGETPATH=$(FUSION_LIB_DEST)

INCLUDES=\
    ..;\
    $(FUSION_INC_PATH);\
    $(FUSION_PATH)\external\inc;\
    $(FUSION_PATH)\idl\$(O); \
    $(INCLUDES);\
    $(COM_INC_PATH)

SOURCES= \
    id.cpp \
    encdec.cpp \
    policy.cpp \
    sxsid.cpp

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\id\idp.h ===
#if !defined(_FUSION_ID_IDP_H_INCLUDED_)
#define _FUSION_ID_IDP_H_INCLUDED_

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    idp.h

Abstract:

    private definitions for assembly identity

Author:

    Michael Grier (MGrier) 7/27/2000

Revision History:

--*/

#pragma once

#include "debmacro.h"
#include "fusiontrace.h"
#include "fusionhashstring.h"
#include "fusionheap.h"
#include "util.h"

#include <sxstypes.h>
#include <sxsapi.h>

//
//  Power of two to which to round the number of allocated attribute
//  pointers.
//

#define ROUNDING_FACTOR_BITS (3)

#define WILDCARD_CHAR '*'

//
//  Note! Do not change this algorithm lightly.  Encoded identities stored in the
//  filesystem contain hashes using it.  Actually, just do not change it.
//

#define HASH_ALGORITHM HASH_STRING_ALGORITHM_X65599

typedef struct _ASSEMBLY_IDENTITY_NAMESPACE {
    ULONG Hash;
    DWORD Flags;
    SIZE_T NamespaceCch;
    const WCHAR *Namespace;
} ASSEMBLY_IDENTITY_NAMESPACE, *PASSEMBLY_IDENTITY_NAMESPACE;

typedef const ASSEMBLY_IDENTITY_NAMESPACE *PCASSEMBLY_IDENTITY_NAMESPACE;

//
//  Internal-use ASSEMBLY_IDENTITY_ATTRIBUTE struct that
//  also contains the hash of the attribute definition.
//

typedef struct _INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE {
    // NOTE!!! It is very important that the Attribute member appear first in this struct;
    // there are several places in the code that make this assumption.  If it is not true,
    // the code will break!
    // Note also that the Attribute's namespace string is actually allocated in common
    // for all attributes with the same namespace.
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    PCASSEMBLY_IDENTITY_NAMESPACE Namespace;
    ULONG NamespaceAndNameHash;
    ULONG WholeAttributeHash;
} INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE, *PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE;

C_ASSERT(FIELD_OFFSET(INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE, Attribute) == 0);

typedef const INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE;

#define ASSEMBLY_IDENTITY_INTERNAL_FLAG_ATTRIBUTE_POINTERS_IN_SEPARATE_ALLOCATION   (0x00000001)
#define ASSEMBLY_IDENTITY_INTERNAL_FLAG_SINGLE_ALLOCATION_FOR_EVERYTHING            (0x00000002)
#define ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION   (0x00000004)

//
//  Revelation of the ASSEMBLY_IDENTITY struct:
//

typedef struct _ASSEMBLY_IDENTITY {
    DWORD Flags;
    ULONG InternalFlags;
    ULONG Type;
    ULONG Hash;
    ULONG AttributeCount;
    ULONG AttributeArraySize; // preallocated a little larger so that we don't have to keep growing
    ULONG NamespaceCount;
    ULONG NamespaceArraySize;
    BOOL  HashDirty;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray;
} ASSEMBLY_IDENTITY;

//
//  Header for encoded/serialized assembly identities:
//

#define ENCODED_ASSEMBLY_IDENTITY_HEADER_MAGIC ((ULONG) 'dIAE')

//
//  Encoded assembly identity layout:
//
//      ENCODED_ASSEMBLY_IDENTITY_HEADER
//      <AttributeCount hashes of the attributes, sorted by the hash value>
//      <NamespaceCount ENCODED_ASSEMBLY_IDENTITY_NAMESPACE_HEADER headers, each
//          followed by the unicode namespace value>
//      <AttributeCount ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER headers, each
//          followed by the unicode attribute name and value>
//
//
//      e.g.
//
//      <begin ENCODED_ASSEMBLY_IDENTITY_HEADER>
//      00000000:   00000038            HeaderSize == sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER)
//      00000004:   'EAId'              Magic (ENCODED_ASSEMBLY_IDENTITY_HEADER_MAGIC)
//      00000008:   0000014C            TotalSize
//      0000000C:   00000000            Flags
//      00000010:   00000001            Type (1 = ASSEMBLY_IDENTITY_TYPE_DEFINITION)
//      00000014:   00000000            EncodingFlags
//      00000018:   00000001            HashAlgorithm (1 = HASH_STRING_ALGORITHM_X65599)
//      0000001C:   ????????            Logical hash value of entire identity based on hash algorithm
//                                      (algorithm described in more detail below...)
//      00000020:   00000003            AttributeCount
//      00000024:   00000002            NamespaceCount
//      00000028:   00000000            ReservedMustBeZero1
//      0000002C:   00000000            ReservedMustBeZero2
//      00000030:   00000000 00000000   ReservedMustBeZero3
//      00000038:   00000000 00000000   ReservedMustBeZero4
//      <end ENCODED_ASSEMBLY_IDENTITY_HEADER>
//      <begin sorted attribute hash list>
//      00000040:   xxxxxxxx            hash of attribute #1
//      00000044:   yyyyyyyy            hash of attribute #0 - note that yyyyyyyy >= xxxxxxxx
//      00000048:   zzzzzzzz            hash of attribute #2 - note that zzzzzzzz >= yyyyyyyy
//      <end sorted attribute hash list>
//      <begin namespace length list>
//      0000004C:   00000015            length (in Unicode chars) of namespace #1 - "http://www.amazon.com" - 21 chars = 0x00000015
//      00000050:   00000018            length (in Unicode chars) of namespace #2 - "http://www.microsoft.com" - 24 chars = 0x00000018
//      <end namespace length list>
//      <begin attribute headers>
//      <begin ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      00000054:   00000001            NamespaceIndex: 1 (http://www.amazon.com)
//      00000058:   00000004            Name length ("name" - 4 chars = 0x00000004)
//      0000005C:   00000006            Value length ("foobar" - 6 chars = 0x00000006)
//      <end ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      <begin ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      00000060:   00000002            NamespaceIndex: 2 (http://www.microsoft.com)
//      00000064:   00000004            Name length ("guid" - 4 chars = 0x00000004)
//      00000068:   00000026            Value length ("{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" - 38 chars = 0x00000026)
//      <end ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      <begin ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      0000006C:   00000002            NamespaceIndex: 2 (http://www.microsoft.com)
//      00000070:   00000004            Name length ("type" - 4 chars = 0x00000004)
//      00000074:   00000005            Value length ("win32" - 5 chars = 0x00000005)
//      <end ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      <end attribute headers>
//      <begin namespace strings>
//      00000078:   "http://www.amazon.com"
//      000000A2:   "http://www.microsoft.com"
//      <end namespace strings>
//      <begin attribute values - names and values for each attribute in series>
//      000000D2:   "name"
//      000000DA:   "foobar"
//      000000E6:   "guid"
//      000000EE:   "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"
//      0000013A:   "type"
//      00000142:   "win32"
//      <end attribute values>
//      0000014C:
//
//  Computing the whole identity hash:
//
//      The hash of the entire encoded identity is not the hash of the binary form, but
//      rather is a combination of the hashes for the various components.
//
//      For any Unicode character string, its hash is computed according to HashAlgorithm.
//      Currently this must be HASH_STRING_ALGORITHM_X65599 which is a multiply-and-
//      accumulate algorithm, implemented essentially as follows:
//
//          HashValue = 0;
//          for (i=0; i<Chars; i++)
//              HashValue = (HashValue * 65599) + OptionalToUpper(String[i]);
//
//      Note that the characters are converted to upper case.  This is somewhat in
//      conflict with the Unicode recommendation to convert to lower case for case
//      insensitive operations, but it is what the rest of the Windows NT system
//      does, so consistency matters more than doing the "right thing".
//
//      Note also that no trailing null characters are included in the hash.  This
//      is significant because of the fact that applying the loop to another character
//      even though its value is zero will significantly change the hash value.
//
//      Namespaces and attribute names are case sensitive, derived from the fact
//      that they appear in case sensitive contexts in the real world.  This is
//      unfortunate, but simpler in many ways.
//
//      Assembly identity attributes are composed of a triple of:
//          - Namespace URI (e.g. http://www.microsoft.com/schemas/side-by-side)
//          - Name (e.g. "publicKey")
//          - Value (case insensitive Unicode string)
//
//      The hash of an attribute is computed by computing the hash of the three
//      strings, and then combining them as:
//
//          AttributeHashValue = (((NamespaceHash * 65599) + NameHash) * 65599) + ValueHash
//
//      Now, sort the attributes based first on namespace, then on name then on
//      value (case sensitive, case sensitive and case insensitive respectively),
//      and combine their hashes as follows:
//
//          IdentityHash = 0;
//          for (i=0; i<AttributeCount; i++)
//              IdentityHash = (IdentityHash * 65599) + AttributeHashes[i];
//
//      IdentityHash is the value stored in the encoded header.
//
//      The attribute hash array stored in the encoded data is the attribute
//      hashes as described above.  The interesting thing is that they are stored
//      in order of ascending hash value, not in the canonical ordering for
//      attributes.
//
//      This is because a common scenario is to find an identity which has a
//      superset of a given identity.  While the actual attributes have to
//      be consulted to verify that the candidate is a true subset, non-
//      matches can be very quickly found by sorting both lists of hash
//      values and first looping over the smaller reference list, then
//      in a single pass walking the larger definition list.  Attributes present
//      in one but not in the other will be immediately noticable due to
//      the missing hashes.
//
//      As always with hashes, just because an encoded identity contains a
//      superset of the hash values in your candidate assembly reference,
//      it does not mean that the actual values appear and you must perform
//      real character string comparisons to verify containment.
//

#include <pshpack4.h>

typedef struct _ENCODED_ASSEMBLY_IDENTITY_HEADER {
    ULONG HeaderSize;           // bytes just in the header
    ULONG Magic;
    ULONG TotalSize;            // bytes for the whole encoded thing
    DWORD Flags;                // as defined for assembly identity flags
    ULONG Type;                 // type of identity - def, ref or wildcard
    ULONG EncodingFlags;        // flags describing the encoding itself
    ULONG HashAlgorithm;        // Algorithm ID for the hashes stored in the identity
    ULONG Hash;                 // Hash value of the entire identity
    ULONG AttributeCount;       // number of attributes
    ULONG NamespaceCount;       // number of distinct namespaces
    ULONG ReservedMustBeZero1;
    ULONG ReservedMustBeZero2;
    ULONGLONG ReservedMustBeZero3;
    ULONGLONG ReservedMustBeZero4;
} ENCODED_ASSEMBLY_IDENTITY_HEADER, *PENCODED_ASSEMBLY_IDENTITY_HEADER;

typedef const ENCODED_ASSEMBLY_IDENTITY_HEADER *PCENCODED_ASSEMBLY_IDENTITY_HEADER;

typedef struct _ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER {
    ULONG NamespaceIndex;       // number of the namespace for this attribute
    ULONG NameCch;              // size in Unicode characters of the name immediately following the
                                // namespace
    ULONG ValueCch;             // size in Unicode characters of the value immediately following the
                                // name.
} ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER, *PENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER;

typedef const ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER *PCENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER;

#include <poppack.h>

#define SXSP_VALIDATE_ASSEMBLY_IDENTITY_FLAGS_MAY_BE_NULL (0x00000001)

BOOL
SxspValidateAssemblyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity
    );

BOOL
SxspValidateAssemblyIdentityAttributeNamespace(
    IN DWORD Flags,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch
    );

BOOL
SxspValidateAssemblyIdentityAttributeName(
    IN DWORD Flags,
    IN const WCHAR *Name,
    IN SIZE_T NameCch
    );

#define SXSP_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_WILDCARDS_PERMITTED (0x00000001)

BOOL
SxspValidateAssemblyIdentityAttributeValue(
    IN DWORD Flags,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch
    );

BOOL
SxspComputeInternalAssemblyIdentityAttributeBytesRequired(
    IN DWORD Flags,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT SIZE_T *BytesRequiredOut
    );

BOOL
SxspComputeAssemblyIdentityAttributeBytesRequired(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Source,
    OUT SIZE_T *BytesRequiredOut
    );

#define SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND (0x00000001)

BOOL
SxspFindAssemblyIdentityNamespaceInArray(
    IN DWORD Flags,
    IN OUT PCASSEMBLY_IDENTITY_NAMESPACE **NamespacePointerArrayPtr,
    IN OUT ULONG *NamespaceArraySizePtr,
    IN OUT ULONG *NamespaceCountPtr,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    );

#define SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_FLAG_ADD_IF_NOT_FOUND (0x00000001)

BOOL
SxspFindAssemblyIdentityNamespace(
    IN DWORD Flags,
    IN struct _ASSEMBLY_IDENTITY* AssemblyIdentity,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    );

BOOL
SxspAllocateAssemblyIdentityNamespace(
    IN DWORD Flags,
    IN const WCHAR *NamespaceString,
    IN SIZE_T NamespaceCch,
    IN ULONG NamespaceHash,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    );

VOID
SxspDeallocateAssemblyIdentityNamespace(
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace
    );

BOOL
SxspPopulateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Destination
    );

BOOL
SxspAllocateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Destination
    );

VOID
SxspCleanUpAssemblyIdentityNamespaceIfNotReferenced(
    IN DWORD Flags,
    IN struct _ASSEMBLY_IDENTITY* AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace
    );

VOID
SxspDeallocateInternalAssemblyIdentityAttribute(
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    );

int
__cdecl
SxspCompareInternalAttributesForQsort(
    const void *elem1,
    const void *elem2
    );

int
__cdecl
SxspCompareULONGsForQsort(
    const void *elem1,
    const void *elem2
    );

BOOL
SxspCompareAssemblyIdentityAttributeLists(
    DWORD Flags,
    ULONG AttributeCount,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *List1,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *List2,
    ULONG *ComparisonResultOut
    );

BOOL
SxspHashInternalAssemblyIdentityAttributes(
    DWORD Flags,
    ULONG Count,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Attributes,
    ULONG *HashOut
    );

BOOL
SxspCopyInternalAssemblyIdentityAttributeOut(
    DWORD Flags,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    SIZE_T BufferSize,
    PASSEMBLY_IDENTITY_ATTRIBUTE DestinationBuffer,
    SIZE_T *BytesCopiedOrRequired
    );

BOOL
SxspIsInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    OUT BOOL *EqualsOut
    );

#define SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_VALUE_ONLY (0x00000001)
#define SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_OMIT_QUOTES (0x00000002)

BOOL
SxspComputeInternalAssemblyIdentityAttributeEncodedTextualSize(
    IN DWORD Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT SIZE_T *BytesOut
    );

#define SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE   (0x00000001)
#define SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME        (0x00000002)
#define SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE       (0x00000004)
#define SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL (0x00000008)

BOOL
SxspLocateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *InternalAttributeOut,
    OUT ULONG *LastIndexSearched OPTIONAL
    );

BOOL
SxspComputeQuotedStringSize(
    IN DWORD Flags,
    IN const WCHAR *StringIn,
    IN SIZE_T Cch,
    OUT SIZE_T *BytesOut
    );

VOID
SxspDbgPrintInternalAssemblyIdentityAttribute(
    DWORD dwflags,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    );

VOID
SxspDbgPrintInternalAssemblyIdentityAttributes(
    DWORD dwflags,
    ULONG AttributeCount,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes
    );

VOID
SxspDbgPrintAssemblyIdentityAttribute(
    DWORD dwflags,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    );

VOID
SxspDbgPrintAssemblyIdentityAttributes(
    DWORD dwflags,
    ULONG AttributeCount,
    PCASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes
    );

BOOL
SxspEnsureAssemblyIdentityHashIsUpToDate(
    DWORD dwFlags,
    PCASSEMBLY_IDENTITY AssemblyIdentity
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\id\sxsid.cpp ===
#include "stdinc.h"
#include <setupapi.h>
#include <sxsapi.h>
#include <stdlib.h>
#include <search.h>

#include "idp.h"
#include "sxsapi.h"
#include "sxsapi.h"
#include "sxsid.h"

ASSEMBLY_IDENTITY_ATTRIBUTE
SxsComposeAssemblyIdentityAttribute(
    PCWSTR pszNamespace,    SIZE_T cchNamespace,
    PCWSTR pszName,         SIZE_T cchName,
    PCWSTR pszValue,        SIZE_T cchValue)
{
    ASSEMBLY_IDENTITY_ATTRIBUTE anattribute;

    anattribute.Flags         = 0; // reserved flags : must be 0;
    anattribute.NamespaceCch  = cchNamespace;
    anattribute.NameCch       = cchName;
    anattribute.ValueCch      = cchValue;
    anattribute.Namespace     = pszNamespace;
    anattribute.Name          = pszName;
    anattribute.Value         = pszValue;

    return anattribute;
}

BOOL
SxsAssemblyIdentityIsAttributePresent(
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    PCWSTR pszNamespace,
    SIZE_T cchNamespace,
    PCWSTR pszName,
    SIZE_T cchName,
    BOOL & rfFound)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG Count = 0;
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    DWORD dwFindFlags;

    PARAMETER_CHECK(pszName != NULL);
    rfFound = FALSE;
    if ( pAssemblyIdentity == NULL)
    {
        goto Done;
    }
    // in the case of a NULL namespace, we must set the flag, too ? xiaoyuw@09/11/00
    dwFindFlags = SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE | SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME;
    Attribute = SxsComposeAssemblyIdentityAttribute(pszNamespace, cchNamespace, pszName, cchName, NULL, 0);

    if (pAssemblyIdentity){
        IFW32FALSE_EXIT(
            ::SxsFindAssemblyIdentityAttribute( // find attribute by "namespace" and "name"
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                    SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                    SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS,
                pAssemblyIdentity,
                &Attribute,
                NULL,
                &Count));
        if ( Count >0 ) { // found
            rfFound = TRUE;
        }
    }
Done:
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspSetAssemblyIdentityAttributeValue(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    const WCHAR *Value,
    SIZE_T ValueCch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    DWORD FlagsToRealInsert = 0;

    PARAMETER_CHECK((Flags & ~(SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(AttributeReference != NULL);
    PARAMETER_CHECK(Value != NULL || ValueCch == 0);

    Attribute.Flags = 0;
    Attribute.Namespace = AttributeReference->Namespace;
    Attribute.NamespaceCch = AttributeReference->NamespaceCch;
    Attribute.Name = AttributeReference->Name;
    Attribute.NameCch = AttributeReference->NameCch;
    Attribute.Value = Value;
    Attribute.ValueCch = ValueCch;

    if (Flags & SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING)
        FlagsToRealInsert |= SXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_OVERWRITE_EXISTING;

    IFW32FALSE_EXIT(::SxsInsertAssemblyIdentityAttribute(FlagsToRealInsert, AssemblyIdentity, &Attribute));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspSetAssemblyIdentityAttributeValue(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    const CBaseStringBuffer &Value
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    IFW32FALSE_EXIT(
        ::SxspSetAssemblyIdentityAttributeValue(
            Flags,
            AssemblyIdentity,
            AttributeReference,
            static_cast<PCWSTR>(Value),
            Value.Cch()));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// Action :
// 1. if (namespace, name) is provided, remove all attributes with such (namespace, name)
// 2. if (namespace, name, value), remove at most 1 attribute from assembly-identity
///////////////////////////////////////////////////////////////////////////////
BOOL
SxspRemoveAssemblyIdentityAttribute(
    DWORD Flags,
    PASSEMBLY_IDENTITY pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    ULONG Ordinal;
    ULONG Count;
    DWORD dwFindAttributeFlags = 0;

    PARAMETER_CHECK((Flags & ~(SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS)) == 0);
    PARAMETER_CHECK(pAssemblyIdentity != NULL);
    PARAMETER_CHECK(AttributeReference != NULL);

    Attribute.Flags = 0;
    Attribute.Namespace = AttributeReference->Namespace;
    Attribute.NamespaceCch = AttributeReference->NamespaceCch;
    Attribute.Name = AttributeReference->Name;
    Attribute.NameCch = AttributeReference->NameCch;

    dwFindAttributeFlags = SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE | SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME;

    // If it's OK for the attribute not to exist, set the flag in the call to find it.
    if (Flags & SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS)
        dwFindAttributeFlags |= SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS;

    IFW32FALSE_EXIT(
        ::SxsFindAssemblyIdentityAttribute(
            dwFindAttributeFlags,
            pAssemblyIdentity,
            &Attribute,
            &Ordinal,
            &Count));

    INTERNAL_ERROR_CHECK(Count <= 1);

    if (Count > 0)
    {
        IFW32FALSE_EXIT(
            ::SxsRemoveAssemblyIdentityAttributesByOrdinal(
                0,                  //  DWORD Flags,
                pAssemblyIdentity,
                Ordinal,
                Count));
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
/////////////////////////////////////////////////////////////////////////////
// if no such attribure with such (namespace and name), return FALSE with
// ::SetLastError(ERROR_NOT_FOUND);
///////////////////////////////////////////////////////////////////////////////
BOOL
SxspGetAssemblyIdentityAttributeValue(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    OUT PCWSTR *StringOut,
    OUT SIZE_T *CchOut OPTIONAL
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = NULL;
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    DWORD dwLocateFlags = SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE | SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME;

    if (StringOut != NULL)
        *StringOut = NULL;

    if (CchOut != NULL)
        *CchOut = 0;

    PARAMETER_CHECK((Flags & ~(SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(AttributeReference != NULL);

    Attribute.Flags = 0;
    Attribute.Namespace = AttributeReference->Namespace;
    Attribute.NamespaceCch = AttributeReference->NamespaceCch;
    Attribute.Name = AttributeReference->Name;
    Attribute.NameCch = AttributeReference->NameCch;

    if (Flags & SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL)
        dwLocateFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL;

    IFW32FALSE_EXIT(
        ::SxspLocateInternalAssemblyIdentityAttribute(
            dwLocateFlags,
            AssemblyIdentity,
            &Attribute,
            &InternalAttribute,
            NULL));

    if (InternalAttribute != NULL)
    {
        if (StringOut != NULL)
            *StringOut = InternalAttribute->Attribute.Value;

        if (CchOut != NULL)
            *CchOut = InternalAttribute->Attribute.ValueCch;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspGetAssemblyIdentityAttributeValue(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    OUT CBaseStringBuffer &Value
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCWSTR String = NULL;
    SIZE_T Cch = 0;

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            Flags,
            AssemblyIdentity,
            AttributeReference,
            &String,
            &Cch));

    IFW32FALSE_EXIT(Value.Win32Assign(String, Cch));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspUpdateAssemblyIdentityHash(
    DWORD dwFlags,
    PASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);

    if (AssemblyIdentity->HashDirty)
    {
        IFW32FALSE_EXIT(::SxspHashInternalAssemblyIdentityAttributes(
                            0,
                            AssemblyIdentity->AttributeCount,
                            AssemblyIdentity->AttributePointerArray,
                            &AssemblyIdentity->Hash));

        AssemblyIdentity->HashDirty = FALSE;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspEnsureAssemblyIdentityHashIsUpToDate(
    DWORD dwFlags,
    PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);

    if (AssemblyIdentity->HashDirty)
        IFW32FALSE_EXIT(::SxspUpdateAssemblyIdentityHash(0, const_cast<PASSEMBLY_IDENTITY>(AssemblyIdentity)));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
SxsHashAssemblyIdentity(
    DWORD dwFlags,
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    ULONG * pulPseudoKey
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG ulPseudoKey;

    if (pulPseudoKey)
        *pulPseudoKey = 0;

    PARAMETER_CHECK(dwFlags == 0);

    if (pAssemblyIdentity == NULL)
        ulPseudoKey = 0;
    else
    {
        IFW32FALSE_EXIT(::SxspEnsureAssemblyIdentityHashIsUpToDate(0, pAssemblyIdentity));
        ulPseudoKey = pAssemblyIdentity->Hash;
    }

    if (pulPseudoKey != NULL)
        *pulPseudoKey = ulPseudoKey;

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

// just to find whether Equal or Not
BOOL
SxsAreAssemblyIdentitiesEqual(
    DWORD dwFlags,
    PCASSEMBLY_IDENTITY pAssemblyIdentity1,
    PCASSEMBLY_IDENTITY pAssemblyIdentity2,
    BOOL *EqualOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    BOOL Equal = FALSE;

    if (EqualOut != NULL)
        *EqualOut = FALSE;

    PARAMETER_CHECK((dwFlags & ~(SXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_FLAG_ALLOW_REF_TO_MATCH_DEF)) == 0);
    PARAMETER_CHECK(pAssemblyIdentity1 != NULL);
    PARAMETER_CHECK(pAssemblyIdentity2 != NULL);
    PARAMETER_CHECK(EqualOut != NULL);

    // get hash for each assembly identity
    IFW32FALSE_EXIT(::SxspEnsureAssemblyIdentityHashIsUpToDate(0, pAssemblyIdentity1));
    IFW32FALSE_EXIT(::SxspEnsureAssemblyIdentityHashIsUpToDate(0, pAssemblyIdentity2));

    // compare hash value of two identity; it's a quick way to determine they're not equal.
    if (pAssemblyIdentity2->Hash == pAssemblyIdentity1->Hash)
    {
        // Note that two identities which differ only in their internal flags are still semantically
        // equal.
        if ((pAssemblyIdentity1->Flags ==  pAssemblyIdentity2->Flags) &&
            (pAssemblyIdentity1->Hash ==  pAssemblyIdentity2->Hash) &&
            (pAssemblyIdentity1->NamespaceCount ==  pAssemblyIdentity2->NamespaceCount) &&
            (pAssemblyIdentity1->AttributeCount ==  pAssemblyIdentity2->AttributeCount))
        {
            if (dwFlags & SXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_FLAG_ALLOW_REF_TO_MATCH_DEF)
            {
                if (((pAssemblyIdentity1->Type == ASSEMBLY_IDENTITY_TYPE_DEFINITION) ||
                     (pAssemblyIdentity1->Type == ASSEMBLY_IDENTITY_TYPE_REFERENCE)) &&
                    ((pAssemblyIdentity2->Type == ASSEMBLY_IDENTITY_TYPE_DEFINITION) ||
                     (pAssemblyIdentity2->Type == ASSEMBLY_IDENTITY_TYPE_REFERENCE)))
                {
                    // They match sufficiently...
                    Equal = TRUE;
                }
            }
            else
                Equal = (pAssemblyIdentity1->Type == pAssemblyIdentity2->Type);

            if (Equal)
            {
                ULONG ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_INVALID;

                // Reset our assumption...
                Equal = FALSE;

                IFW32FALSE_EXIT(
                    ::SxspCompareAssemblyIdentityAttributeLists(
                        0,
                        pAssemblyIdentity1->AttributeCount,
                        pAssemblyIdentity1->AttributePointerArray,
                        pAssemblyIdentity2->AttributePointerArray,
                        &ComparisonResult));

                INTERNAL_ERROR_CHECK(
                    (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN) ||
                    (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL) ||
                    (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN));

                if (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
                    Equal = TRUE;
            }
        }
    }

    *EqualOut = Equal;
    fSuccess = TRUE;

Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\id\policy.cpp ===
#include "stdinc.h"

#include "idp.h"
#include "sxsapi.h"
#include "sxsid.h"

BOOL
SxspMapAssemblyIdentityToPolicyIdentity(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PASSEMBLY_IDENTITY &PolicyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCWSTR pszTemp;
    SIZE_T cchTemp;
    PASSEMBLY_IDENTITY NewIdentity = NULL;
    CStringBuffer Name;
    bool fFirst;
    const bool fOmitEntireVersion = ((Flags & SXSP_MAP_ASSEMBLY_IDENTITY_TO_POLICY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION) != 0);
    BOOL fIsPolicy = FALSE;

    PolicyIdentity = NULL;

    PARAMETER_CHECK((Flags & ~(SXSP_MAP_ASSEMBLY_IDENTITY_TO_POLICY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != 0);

    //
    // Determine assembly type.  If this wasn't a policy assembly, then map it to one.
    //
    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(AssemblyIdentity, fIsPolicy));

    //
    // Now let's duplicate the assembly identity into a policy identity by changing the
    // name, and potentially changing the type if it was "win32" into "win32-policy"
    //
    IFW32FALSE_EXIT(
        ::SxsDuplicateAssemblyIdentity(
            0,
            AssemblyIdentity,
            &NewIdentity));

    //
    // If we're not a policy assembly, then we have to map type="" to type="policy"
    // and type="foo" to type="foo-policy"
    //
    if (!fIsPolicy)
    {
        PCWSTR pcwszOriginalType;
        SIZE_T cchOriginalType;

        IFW32FALSE_EXIT(
            ::SxspGetAssemblyIdentityAttributeValue(
                SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                AssemblyIdentity,
                &s_IdentityAttribute_type,
                &pcwszOriginalType,
                &cchOriginalType));

        if (cchOriginalType == 0)
        {
            IFW32FALSE_EXIT(
                ::SxspSetAssemblyIdentityAttributeValue(
                    SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
                    NewIdentity,
                    &s_IdentityAttribute_type,
                    ASSEMBLY_TYPE_POLICY,
                    ASSEMBLY_TYPE_POLICY_CCH));
        }
        else
        {
            CSmallStringBuffer MappedName;
            IFW32FALSE_EXIT(MappedName.Win32Assign(pcwszOriginalType, cchOriginalType));
            IFW32FALSE_EXIT(MappedName.Win32Append(ASSEMBLY_TYPE_POLICY_SUFFIX, ASSEMBLY_TYPE_POLICY_SUFFIX_CCH));

            IFW32FALSE_EXIT(
                ::SxspSetAssemblyIdentityAttributeValue(
                    SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
                    NewIdentity,
                    &s_IdentityAttribute_type,
                    MappedName));
        }
    }
    
    IFW32FALSE_EXIT(Name.Win32Assign(L"Policy.", 7));

    if (!fOmitEntireVersion)
    {
        IFW32FALSE_EXIT(
            ::SxspGetAssemblyIdentityAttributeValue(
                0,
                AssemblyIdentity,
                &s_IdentityAttribute_version,
                &pszTemp,
                &cchTemp));

        fFirst = true;

        while (cchTemp != 0)
        {
            if (pszTemp[--cchTemp] == L'.')
            {
                if (!fFirst)
                    break;

                fFirst = false;
            }
        }

        // This should not be zero; someone prior to this should have validated the version format
        // to include three dots.
        INTERNAL_ERROR_CHECK(cchTemp != 0);

        IFW32FALSE_EXIT(Name.Win32Append(pszTemp, cchTemp + 1));
    }

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            0,
            AssemblyIdentity,
            &s_IdentityAttribute_name,
            &pszTemp,
            &cchTemp));

    IFW32FALSE_EXIT(Name.Win32Append(pszTemp, cchTemp));

    IFW32FALSE_EXIT(
        ::SxspSetAssemblyIdentityAttributeValue(
            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
            NewIdentity,
            &s_IdentityAttribute_name,
            Name));

    // finally we whack the version...

    IFW32FALSE_EXIT(
        ::SxspRemoveAssemblyIdentityAttribute(
            SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS,
            NewIdentity,
            &s_IdentityAttribute_version));

    PolicyIdentity = NewIdentity;
    NewIdentity = NULL;

    fSuccess = TRUE;
Exit:
    if (NewIdentity != NULL)
    {
        ::SxsDestroyAssemblyIdentity(NewIdentity);
        NewIdentity = NULL;
    }

    return fSuccess;

}

BOOL
SxspGenerateTextuallyEncodedPolicyIdentityFromAssemblyIdentity(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    CBaseStringBuffer &rbuffEncodedIdentity,
    PASSEMBLY_IDENTITY *PolicyIdentityOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY PolicyIdentity = NULL;
    SIZE_T EncodedIdentityBytes = 0;
    CStringBufferAccessor acc;
    DWORD dwMapFlags = 0;
    SIZE_T BytesWritten;

    if (PolicyIdentityOut != NULL)
        *PolicyIdentityOut = NULL;

    PARAMETER_CHECK((Flags & ~(SXSP_GENERATE_TEXTUALLY_ENCODED_POLICY_IDENTITY_FROM_ASSEMBLY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);

    if (Flags & SXSP_GENERATE_TEXTUALLY_ENCODED_POLICY_IDENTITY_FROM_ASSEMBLY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION)
        dwMapFlags |= SXSP_MAP_ASSEMBLY_IDENTITY_TO_POLICY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION;

    IFW32FALSE_EXIT(::SxspMapAssemblyIdentityToPolicyIdentity(dwMapFlags, AssemblyIdentity, PolicyIdentity));

    IFW32FALSE_EXIT(
        ::SxsComputeAssemblyIdentityEncodedSize(
            0,
            PolicyIdentity,
            NULL,
            SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
            &EncodedIdentityBytes));

    INTERNAL_ERROR_CHECK((EncodedIdentityBytes % sizeof(WCHAR)) == 0);

    IFW32FALSE_EXIT(rbuffEncodedIdentity.Win32ResizeBuffer((EncodedIdentityBytes / sizeof(WCHAR)) + 1, eDoNotPreserveBufferContents));

    acc.Attach(&rbuffEncodedIdentity);

    IFW32FALSE_EXIT(
        ::SxsEncodeAssemblyIdentity(
            0,
            PolicyIdentity,
            NULL,
            SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
            acc.GetBufferCb(),
            acc.GetBufferPtr(),
            &BytesWritten));

    INTERNAL_ERROR_CHECK((BytesWritten % sizeof(WCHAR)) == 0);
    INTERNAL_ERROR_CHECK(BytesWritten <= EncodedIdentityBytes);

    acc.GetBufferPtr()[BytesWritten / sizeof(WCHAR)] = L'\0';

    acc.Detach();

    if (PolicyIdentityOut != NULL)
    {
        *PolicyIdentityOut = PolicyIdentity;
        PolicyIdentity = NULL; // so we don't try to clean it up in the exit path
    }

    fSuccess = TRUE;
Exit:
    if (PolicyIdentity != NULL)
        SxsDestroyAssemblyIdentity(PolicyIdentity);

    return fSuccess;
}

//
// the difference between this func and SxsHashAssemblyIdentity() is that for policy,
// version should not be calcaulated as part of hash
//
BOOL
SxspHashAssemblyIdentityForPolicy(
    IN DWORD dwFlags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT ULONG & IdentityHash)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;

    IFW32FALSE_EXIT(
        ::SxsDuplicateAssemblyIdentity(
            SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE,
            AssemblyIdentity,
            &pAssemblyIdentity));

    IFW32FALSE_EXIT(
        ::SxspRemoveAssemblyIdentityAttribute(
            SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS,
            pAssemblyIdentity,
            &s_IdentityAttribute_version));

    IFW32FALSE_EXIT(::SxsHashAssemblyIdentity(0, pAssemblyIdentity, &IdentityHash));

    fSuccess = TRUE;
Exit:
    if (pAssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\bsinkez.h ===
#pragma once
#ifndef __BSINKEZ_H_INCLUDED__
#define __BSINKEZ_H_INCLUDED__

class CBindSinkEZ : public IAssemblyBindSink
{
    public:
        CBindSinkEZ();
        virtual ~CBindSinkEZ();

        // IUnknown methods
        STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
        STDMETHODIMP_(ULONG)    AddRef();
        STDMETHODIMP_(ULONG)    Release();

        // IAssemblyBindSink
        STDMETHODIMP  OnProgress(DWORD dwNotification, HRESULT hrNotification,
                                 LPCWSTR szNotification, DWORD dwProgress,
                                 DWORD dwProgressMax, IUnknown *pUnk);

        // Helpers
        HRESULT SetEventObj(HANDLE hEvent);


    private:
        DWORD                                    _dwSig;
        ULONG                                    _cRef;

    public:
        HRESULT                                  _hrResult;
        IUnknown                                *_pUnk;

    private:
        HANDLE                                   _hEvent;
        IAssemblyBinding                        *_pBinding;


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\asynchelp.h ===
#if !defined(_FUSION_INC_ASYNCHELP_H_INCLUDED_)
#define _FUSION_INC_ASYNCHELP_H_INCLUDED_

#pragma once

class CAsyncContext : public OVERLAPPED
{
public:
    CAsyncContext() { }
    virtual ~CAsyncContext() { }

    // Public handler for async operations which are finished via an I/O completion port
    static VOID OnQueuedCompletion(HANDLE hCompletionPort, DWORD cbTransferred, ULONG_PTR ulCompletionKey, LPOVERLAPPED lpo)
    {
        CAsyncContext *pThis = reinterpret_cast<CAsyncContext *>(ulCompletionKey);
        INVOCATION_CONTEXT ic;

        ic.m_it = CAsyncContext::INVOCATION_CONTEXT::eCompletionPort;
        ic.m_dwErrorCode = ERROR_SUCCESS;
        ic.m_hCompletionPort = hCompletionPort;
        ic.m_lpo = lpo;
        ic.m_cbTransferred = cbTransferred;

        pThis->OnCompletion(ic);
    }

    // Public handler for async operations which are signalled via an APC.
    static VOID CALLBACK OnUserAPC(DWORD_PTR dwParam)
    {
        CAsyncContext *pThis = reinterpret_cast<CAsyncContext *>(dwParam);
        INVOCATION_CONTEXT ic;

        ic.m_it = CAsyncContext::INVOCATION_CONTEXT::eUserAPC;
        ic.m_dwErrorCode = ERROR_SUCCESS;

        pThis->OnCompletion(ic);
    }

    // Public handler for async operations which are signalled via a thread message
    static VOID OnThreadMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        CAsyncContext *pThis = reinterpret_cast<CAsyncContext *>(wParam);
        INVOCATION_CONTEXT ic;
        ic.m_it = CAsyncContext::INVOCATION_CONTEXT::eThreadMessage;
        ic.m_dwErrorCode = ERROR_SUCCESS;
        ic.m_uMsg = uMsg;
        ic.m_lParam = lParam;
        pThis->OnCompletion(ic);
    }

    // Public handler for async operations which are signalled via a window message
    static VOID OnWindowMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        CAsyncContext *pThis = reinterpret_cast<CAsyncContext *>(wParam);
        INVOCATION_CONTEXT ic;
        ic.m_it = CAsyncContext::INVOCATION_CONTEXT::eWindowMessage;
        ic.m_dwErrorCode = ERROR_SUCCESS;
        ic.m_hwnd = hwnd;
        ic.m_uMsg = uMsg;
        ic.m_lParam = lParam;
        pThis->OnCompletion(ic);
    }

    // Public handler for async operations which are signalled via an overlapped completion routine
    // (e.g. ReadFileEx(), WriteFileEx()).
    static VOID CALLBACK OnOverlappedCompletion(DWORD dwErrorCode, DWORD cbTransferred, LPOVERLAPPED lpo)
    {
        CAsyncContext *pThis = static_cast<CAsyncContext *>(lpo);
        INVOCATION_CONTEXT ic;
        ic.m_it = CAsyncContext::INVOCATION_CONTEXT::eOverlappedCompletionRoutine;
        ic.m_lpo = lpo;
        ic.m_dwErrorCode = dwErrorCode;
        ic.m_cbTransferred = cbTransferred;
        pThis->OnCompletion(ic);
    }

    // Call this member function when an asynch I/O completes immediately
    VOID OnImmediateCompletion(DWORD dwErrorCode, DWORD cbTransferred)
    {
        INVOCATION_CONTEXT ic;
        ic.m_it = CAsyncContext::INVOCATION_CONTEXT::eDirectCall;
        ic.m_lpo = this;
        ic.m_dwErrorCode = dwErrorCode;
        ic.m_cbTransferred = cbTransferred;
        this->OnCompletion(ic);
    }

protected:
    struct INVOCATION_CONTEXT
    {
        enum InvocationType
        {
            eCompletionPort,
            eUserAPC,
            eThreadMessage,
            eWindowMessage,
            eDirectCall,
            eOverlappedCompletionRoutine,
        } m_it;
        DWORD m_dwErrorCode;            // Win32 error code - valid for all invocation types
        HANDLE m_hCompletionPort;       // valid for: eCompletionPort
        LPOVERLAPPED m_lpo;             // valid for: eCompletionPort, eOverlappedCompletionRoutine, eDirectCall
        DWORD m_cbTransferred;          // valid for: eCompletionPort, eOverlappedCompletionRoutine, eDirectCall
        LPARAM m_lParam;                // valid for: eThreadMessage, eWindowMessage
        HWND m_hwnd;                    // valid for: eWindowMessage
        UINT m_uMsg;                    // valid for: eThreadMessage, eWindowMessage
    };

    // Derived classes override OnCompletion to do what's necessary.
    virtual VOID OnCompletion(const INVOCATION_CONTEXT &ric) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\adlmgr.h ===
#pragma once
#ifndef __ADLMGR_H_INCLUDED__
#define __ADLMGR_H_INCLUDED__

#include "dbglog.h"

#define PREFIX_HTTP                        L"http://"
#define BINPATH_LIST_DELIMITER             L';'
#define SHADOW_COPY_DIR_DELIMITER          L';'

extern const LPWSTR g_wzProbeExtension;

class CDebugLog;
class CHashNode;

class CAsmDownloadMgr : public IDownloadMgr, public ICodebaseList
{
    public:
        CAsmDownloadMgr(IAssemblyName *pNameRefSource, IApplicationContext *pAppCtx,
                        ICodebaseList *pCodebaseList, CDebugLog *pdbglog,
                        LONGLONG llFlags);
        virtual ~CAsmDownloadMgr();

        static HRESULT Create(CAsmDownloadMgr **ppadm,
                              IAssemblyName *pNameRefSource,
                              IApplicationContext *pAppCtx,
                              ICodebaseList *pCodebaseList,
                              LPCWSTR wzBTOCodebase,
                              CDebugLog *pdbglog,
                              void *pvReserved,
                              LONGLONG llFlags);

        // IUnknown methods

        STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // IDownloadMgr methods

        STDMETHODIMP PreDownloadCheck(void **ppv);
        STDMETHODIMP PreDownloadCheck2(void **ppv);
        STDMETHODIMP DoSetup(LPCWSTR wzSourceUrl, LPCWSTR wzFilePath,
                             IUnknown **ppUnk);
        STDMETHODIMP ProbeFailed(IUnknown **ppUnk);
        STDMETHODIMP ProbeFailed2(IUnknown **ppUnk);
        STDMETHODIMP IsDuplicate(IDownloadMgr *pIDLMgr);
        STDMETHODIMP_(BOOL) LogResult();

        // ICodebaseList methods

        STDMETHODIMP AddCodebase(LPCWSTR wzCodebase);
        STDMETHODIMP RemoveCodebase(DWORD dwIndex);
        STDMETHODIMP GetCodebase(DWORD dwIndex, LPWSTR wzCodebase, DWORD *pcbCodebase);
        STDMETHODIMP GetCount(DWORD *pdwCount);
        STDMETHODIMP RemoveAll();

        // Helpers

        STDMETHODIMP GetPolicyRef(IAssemblyName **ppName);

    private:
        HRESULT Init(LPCWSTR wzBTOCodebase, void *pvReserved);

        // Helpers
        HRESULT SetDefaultSID(FILETIME ftLastModified);
        HRESULT LookupFromGlobalCache(LPASSEMBLY *ppAsmOut);
        HRESULT DoSetupRFS(LPCWSTR wzFilePath, FILETIME *pftLastModified,
                           LPCWSTR wzSourceUrl, BOOL bWhereRefBind);
        HRESULT DoSetupPushToCache(LPCWSTR wzFilePath, LPCWSTR wzSourceUrl,
                                   FILETIME *pftLastModified,
                                   BOOL bWhereRefBind, BOOL bCopyModules);
#ifndef NEW_POLICY_CODE
        HRESULT GetCodebaseHint(LPWSTR wzCodebaseHint, DWORD *pdwSize);
#endif
        HRESULT GetBinPathHint(BOOL bIsShared, LPWSTR *ppwzBinPathHint);

        HRESULT SetupCAB(LPCWSTR wzFilePath, LPCWSTR wzSourceUrl, BOOL bWhereRefBind);
        HRESULT ShadowCopyDirCheck(LPCWSTR wzSourceURL);
        HRESULT CheckRunFromSource(LPCWSTR wzSourceUrl, BOOL *pbRunFromSource);

        HRESULT CheckMSIInstallAvailable() const;
        HRESULT MSIInstallAssembly(LPCWSTR wzContext, LPCWSTR wzSourceUrl, IAssembly **ppAsm);
        HRESULT SetupMSI(LPCWSTR wzFilePath);

        // Probing URL generation
        HRESULT ConstructCodebaseList(LPCWSTR wzPolicyCodebase);
        HRESULT SetupDefaultProbeList(LPCWSTR wzAppBaseStr, LPCWSTR wzProbeFileName,
                                      ICodebaseList *pCodebaseList);
        HRESULT PrepBinPaths(BOOL bIsPartial, BOOL bIsShared,
                             LPCWSTR wzNameProbe, LPWSTR *ppwzUserBinPathList);
        HRESULT PrepPrivateBinPath(LPCWSTR wzNameProbe, LPWSTR *ppwzPrivateBinPath);
        HRESULT PrepSharedBinPath(LPWSTR *ppwzSharedBinPath);
        HRESULT ConcatenateBinPaths(LPCWSTR pwzPath1, LPCWSTR pwzPath2,
                                    LPWSTR *ppwzOut);
        HRESULT ApplyHeuristics(const WCHAR *pwzHeuristics[],
                                const unsigned int uiNumHeuristics,
                                WCHAR *pwzValues[], LPCWSTR wzPrefix,
                                LPCWSTR wzExtension,
                                ICodebaseList *pCodebaseList,
                                List<CHashNode *> aHashList[]);
        HRESULT ExtractSubstitutionVars(WCHAR *pwzValues[]);
        HRESULT ExpandVariables(LPCWSTR pwzHeuristic, WCHAR *pwzValues[],
                                LPWSTR wzBuf, int iMaxLen);
        LPWSTR GetNextDelimitedString(LPWSTR *ppwzList, WCHAR wcDelimiter);
        HRESULT GenerateProbeUrls(LPCWSTR wzBinPathList, LPCWSTR wzAppBase,
                                  LPCWSTR wzExt, LPWSTR wzValues[],
                                  ICodebaseList *pCodebaseList, BOOL bIsShared);

        HRESULT CheckProbeUrlDupe(List<CHashNode *> paHashList[],
                                  LPCWSTR pwzSource) const;
        DWORD HashString(LPCWSTR pwzSource) const;

        HRESULT CreateAssembly2(LPCWSTR szPath, LPCWSTR pszURL,
                                FILETIME *pftLastModTime,
                                BOOL bRunFromSource,
                                IAssembly **ppAsmOut);

    private:
        DWORD                                       _dwSig;
        ULONG                                       _cRef;
        BOOL                                        _bDoGlobalCacheLookup;
        LONGLONG                                    _llFlags;
        LPWSTR                                      _wzBTOCodebase;
        LPWSTR                                      _wzSharedPathHint;
        IAssemblyName                              *_pNameRefSource;
        IAssemblyName                              *_pNameRefPolicy;
        IApplicationContext                        *_pAppCtx;
        IAssembly                                  *_pAsm;
        ICodebaseList                              *_pCodebaseList;
        CDebugLog                                  *_pdbglog;
};

HRESULT CreateAssembly(IApplicationContext *pAppCtx, IAssemblyName* pNameRef,
                       IAssemblyName *pNameRefPolicy,LPCOLESTR szPath, LPCOLESTR pszURL,
                       FILETIME *pftLastModTime, BOOL bRunFromSource, CDebugLog *pdbglog,
                       IAssembly **ppAsmOut);

HRESULT CheckValidAsmLocation(IAssemblyName *pNameDef, LPCWSTR wzSourceUrl,
                              IApplicationContext *pAppCtx,
                              CDebugLog *pdbglog);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\cachergn.h ===
#include "asmstrm.h"
#include "transprt.h"
#include <windows.h>
#include "dbglog.h"

#define TRANSPORT_CACHE_FLAGS_REGENERATION                  0x100
#define TRANSPORT_CACHE_REGENERATION_IDX_OFFSET             0x100
class CAssemblyCacheRegenerator
{
    protected:
        DWORD               _dwSig;
        CDebugLog           *_pdbglog;

        // for cross process locking
        HANDLE              _hRegeneratorMutex;

        // storage for lock that CDatabase::Lock returns
        HLOCK               _hlTransCacheLock[TRANSPORT_CACHE_IDX_TOTAL];
        HLOCK               _hlNameResLock;
        HLOCK               _hlNewGlobalCacheLock;

        // interface to temporary cache index files
        static IDatabase    *g_pDBNewCache[TRANSPORT_CACHE_IDX_TOTAL];
        static IDatabase    *g_pDBNewNameRes;

        // reentrancy protection flags
        BOOL                _fThisInstanceIsRegenerating;
        static DWORD         g_dwRegeneratorRunningInThisProcess;

        // which database are we regenerating
        DWORD               _dwCacheId;

        // we are regenerating NameRes (TRUE) TransCache (FALSE)
        BOOL                _fIsNameRes;

    public:

        CAssemblyCacheRegenerator(CDebugLog *pdbglog, DWORD dwCacheId, BOOL fIsNameRes);
        ~CAssemblyCacheRegenerator();

        HRESULT Init();
        HRESULT Regenerate();
        static HRESULT SetSchemaVersion(DWORD dwNewMinorVersion, DWORD dwCacheId, BOOL fIsNameRes);

    private:
        static HRESULT CreateRegenerationTransCache(DWORD dwCacheId, CTransCache **CTransCache);
        HRESULT ProcessStoreDir();
        HRESULT RegenerateGlobalCache();
        HRESULT CreateEmptyCache();
        HRESULT ProcessSubDir(LPTSTR szCurrentDir, LPTSTR szSubDir);
        HRESULT LockFusionCache();
        HRESULT UnlockFusionCache();
        HRESULT CloseCacheRegeneratedDatabase();
        //temporary method for checking whether assembly is a ZAP assembly
        HRESULT IsZAPAssembly(LPTSTR szPath, LPBOOL pfZap);
        HRESULT DeleteFilesInDirectory(LPTSTR szDirectory);


    // CCache::InsertTransCacheEntry needs access to CreateRegenerationTransCache
    friend class CCache;
};

HRESULT RegenerateCache(CDebugLog *pdbg, DWORD dwCacheId, BOOL fIsNameRes);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\cache.h ===
#pragma once
#ifndef CACHE_H
#define CACHE_H


#include "nameres.h"
#include "transprt.h"
#include "appctx.h"

// Forward declaration for friend statement.
class CAssemblyEnum;
class CScavenger;

// ---------------------------------------------------------------------------
// CCache
// static cache class
// ---------------------------------------------------------------------------
class CCache
{

    friend CAssemblyEnum;
    friend CScavenger;

public:
    // Name res apis

    // Inserts entry to name resolution cache.
    static HRESULT InsertNameResEntry(IApplicationContext *pAppCtx,
        IAssemblyName *pNameSrc, IAssemblyName *pNameTrgt);

    // Retrieves name res entry from name resolution cache.
    static HRESULT RetrieveNameResEntry(IApplicationContext *pAppCtx,
        IAssemblyName *pNameSrc, CNameRes **ppNameRes);

    // Retrieves name object target  from name resolution cache.
    static HRESULT RetrieveNameResTarget(IApplicationContext *pAppCtx,
        IAssemblyName *pNameSrc, IAssemblyName **ppNameTrgt);


    // Trans cache apis

    // Inserts entry to transport cache.

    static HRESULT InsertTransCacheEntry(IAssemblyName *pName,
        LPTSTR szPath, DWORD dwKBSize, DWORD dwFlags, DWORD dwCommitFlags, DWORD dwPinBits,
        CTransCache **ppTransCache);

    // Retrieves transport cache entry from transport cache.
    static HRESULT RetrieveTransCacheEntry(IAssemblyName *pName,
        DWORD dwFlags, CTransCache **ppTransCache);

    // Retrieves assembly in global cache with maximum
    // revision/build number based on name passed in.
    static HRESULT GetGlobalMax(IAssemblyName *pName,
        IAssemblyName **ppNameGlobal, CTransCache **ppTransCache);

    // Tests for presence of originator
    static BOOL IsStronglyNamed(IAssemblyName *pName);

    // Tests for presence of custom data
    static BOOL IsCustom(IAssemblyName *pName);


    // get assembly name object from nameres entry
    static HRESULT NameFromNameResEntry(
        CNameRes* pNRes, IAssemblyName **ppName);

    // get name res entry from name
    static HRESULT NameResEntryFromName(IApplicationContext *pAppCtx,
        IAssemblyName *pName, CNameRes **ppNameRes);

    // get trans cache entry from naming object.
    static HRESULT TransCacheEntryFromName(IAssemblyName *pName,
        DWORD dwFlags, CTransCache **ppTransCache);

    // get assembly name object from transcache entry.
    static HRESULT NameFromTransCacheEntry(
        CTransCache *pTC, IAssemblyName **ppName);

protected:

    // Determines cache index from name and flags.
    static HRESULT ResolveCacheIndex(IAssemblyName *pName,
        DWORD dwFlags, LPDWORD pdwCacheId);

    // flush NameRes entries for deleted TransCache item
    static HRESULT FlushNameResEntries(CTransCache* pDeletedTransCache);

    // safe for delete?
    static BOOL IsSafeForDeletion(CTransCache*  pTC);

};

STDAPI NukeDownloadedCache();

STDAPI DeleteAssemblyFromTransportCache( LPCTSTR lpszCmdLine, DWORD *pDelCount );

#endif // CACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\arrayhelp.h ===
#if !defined(FUSION_ARRAYHELP_H_INCLUDED_)
#define FUSION_ARRAYHELP_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <oleauto.h>
#include "fusionheap.h"
#include "fusiontrace.h"

//
//  arrayhelp.h
//
//  Helper function(s) to deal with growable arrays.
//
//  Users of this utility should provide explicit template
//  specializations for classes for which you can safely (without
//  possibility of failure) transfer the contens from a source
//  instance to a destination instance, leaving the source "empty".
//
//  If moving the data may fail, you must provide a specialization
//  of FusionCopyContents() which returns an appropriate HRESULT
//  on failure.
//
//
//  C++ note:
//
//  the C++ syntax for explicit function template specialization
//  is:
//
//  template <> BOOLEAN FusionCanMoveContents<CFoo>(CFoo *p) { UNUSED(p); return TRUE; }
//

#if !defined(FUSION_UNUSED)
#define FUSION_UNUSED(x) (x)
#endif

class CSaveErrorInfo
{
public:
    CSaveErrorInfo() : m_pIErrorInfo(NULL) { ::GetErrorInfo(0, &m_pIErrorInfo); }
    ~CSaveErrorInfo() { ::SetErrorInfo(0, m_pIErrorInfo); if (m_pIErrorInfo != NULL) m_pIErrorInfo->Release(); }
private:
    IErrorInfo *m_pIErrorInfo;
};

//
//  Alternate CSaveErrorInfo implementation for templates which want to not require
//  a link dependency on oleaut32.dll.
//

class CSaveErrorInfoNull
{
public:
    CSaveErrorInfoNull() { }
    ~CSaveErrorInfoNull() { }
};

//
//  The default implementation just does assignment which may not fail;
//  you can (and must if assignment may fail) specialize as you like to
//  do something that avoids data copies; you may assume that the source
//  element will be destroyed momentarily.
//

//
//  The FusionCanMemcpyContents() template function is used to determine
//  if a class is trivial enough that a raw byte transfer of the old
//  contents to the new contents is sufficient.  The default is that the
//  assignment operator is used as that is the only safe alternative.
//

template <typename T>
inline BOOLEAN
FusionCanMemcpyContents(
    T *ptDummyRequired = NULL
    )
{
    FUSION_UNUSED(ptDummyRequired);
    return FALSE;
}

//
//  The FusionCanMoveContents() template function is used by the array
//  copy template function to optimize for the case that it should use
//  FusionMoveContens<T>().
//
//  When overriding this function, the general rule is that if the data
//  movement may allocate memory etc. that will fail, we need to use the
//  FusionCopyContens() member function instead.
//
//  It takes a single parameter which is not used because a C++ template
//  function must take at least one parameter using the template type so
//  that the decorated name is unique.
//

template <typename T>
inline BOOLEAN
FusionCanMoveContents(
    T *ptDummyRequired = NULL
    )
{
    FUSION_UNUSED(ptDummyRequired);
    return FALSE;
}

template <> inline BOOLEAN
FusionCanMoveContents<LPWSTR>(LPWSTR  *ptDummyRequired)
{
    FUSION_UNUSED(ptDummyRequired);
    return TRUE;
}

//
//  Override FusionMoveContents<T> to be a useful implementation which
//  takes the contents of rtSource and transfers them to rtDestination.
//  The transfer may not fail (returns VOID).  The expectation is that
//  any value that was stored in rtSource are moved to rtDestination
//  and rtSource is left in a quiescent state.  E.g. any pointers to
//  objects can be simply assigned from rtSource to rtDestination and
//  then set to NULL in rtSource.  You may also assume that the destination
//  element has only had the default constructor run on it, so you
//  may choose to take shortcuts about not freeing non-NULL pointers
//  in rtDestination if you see fit.
//

template <typename T>
inline VOID
FusionMoveContents(
    T &rtDestination,
    T &rtSource
    )
{
    rtDestination = rtSource;
}

template <> inline VOID
FusionMoveContents<LPWSTR>(
    LPWSTR &rtDestination,
    LPWSTR &rtSource
    )
{
    if ( rtDestination )
        FUSION_DELETE_ARRAY(rtDestination);

    rtDestination = rtSource;
    rtSource = NULL;
}

//
//  FusionCopyContents is a default implementation of the assignment
//  operation from rtSource to rtDestination, except that it may return a
//  failure status.  Trivial classes which do define an assignment
//  operator may just use the default definition, but any copy implementations
//  which do anything non-trivial need to provide an explicit specialization
//  of FusionCopyContents<T> for their class.
//

template <typename T>
inline HRESULT
FusionCopyContents(
    T &rtDestination,
    const T &rtSource
    )
{
    rtDestination = rtSource;
    return NOERROR;
}

template <typename T>
inline BOOL
FusionWin32CopyContents(
    T &rtDestination,
    const T &rtSource
    )
{
    rtDestination = rtSource;
    return TRUE;
}

template <> inline HRESULT
FusionCopyContents<LPWSTR>(
    LPWSTR &rtDestination,
    const LPWSTR &rtSource
    )
{
    SIZE_T cch = (SIZE_T)((rtSource == NULL) ? 0 : ::wcslen(rtSource));

    if ( cch == 0) {
        rtDestination = NULL;
        return S_OK;
    }

    rtDestination = new WCHAR[cch];
    if ( ! rtDestination)
        return E_OUTOFMEMORY;

    memcpy(rtDestination, rtSource, (cch+1)*sizeof(WCHAR));

    return NOERROR;
}

//
//  FusionAllocateArray() is a helper function that performs array allocation.
//
//  It's a separate function so that users of these helpers may provide an
//  explicit specialization of the allocation/default construction mechanism
//  for an array without replacing all of FusionExpandArray().
//

template <typename T>
inline HRESULT
FusionAllocateArray(
    SIZE_T nElements,
    T *&rprgtElements
    )
{
    HRESULT hr = NOERROR;

    rprgtElements = NULL;

    T *prgtElements = NULL;

    if (nElements != 0) {
        prgtElements = new T[nElements];
        if (prgtElements == NULL) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    rprgtElements = prgtElements;
    hr = NOERROR;

Exit:
    return hr;
}

template <typename T>
inline BOOL
FusionWin32AllocateArray(
    SIZE_T nElements,
    T *&rprgtElements
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    rprgtElements = NULL;

    T *prgtElements = NULL;

    if (nElements != 0)
        IFALLOCFAILED_EXIT(prgtElements = new T[nElements]);

    rprgtElements = prgtElements;
    fSuccess = TRUE;

Exit:
    return fSuccess;
}

template <> inline HRESULT FusionAllocateArray<LPWSTR>(SIZE_T nElements, LPWSTR *&rprgtElements)
{
    HRESULT hr = NOERROR;
    SIZE_T i;

    rprgtElements = NULL;


    LPWSTR *prgtElements = NULL;

    if (nElements != 0) {
        prgtElements = new PWSTR[nElements];
        if (prgtElements == NULL) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    for ( i=0; i < nElements; i++)
        prgtElements[i] = NULL ;

    rprgtElements = prgtElements;
    hr = NOERROR;

Exit:
    return hr;
}

//
//  FusionFreeArray() is a helper function that performs array deallocation.
//
//  It's a separate function so that users of the array helper functions may
//  provide an explicit specialization of the deallocation mechanism for an
//  array of some particular type without replacing the whole of FusionExpandArray().
//
//  We include nElements in the parameters so that overridden implementations
//  may do something over the contents of the array before the deallocation.
//  The default implementation just uses operator delete[], so nElements is
//  unused.
//

template <typename T>
inline VOID
FusionFreeArray(
    SIZE_T nElements,
    T *prgtElements
    )
{
    FUSION_UNUSED(nElements);

    ASSERT_NTC((nElements == 0) || (prgtElements != NULL));

    if (nElements != 0)
        FUSION_DELETE_ARRAY(prgtElements);
}

template <> inline VOID FusionFreeArray<LPWSTR>(SIZE_T nElements, LPWSTR *prgtElements)
{
    FUSION_UNUSED(nElements);

    ASSERT_NTC((nElements == 0) || (prgtElements != NULL));

    for (SIZE_T i = 0; i < nElements; i++)
        prgtElements[i] = NULL ;

    if (nElements != 0)
        FUSION_DELETE_ARRAY(prgtElements);
}

template <typename T>
inline HRESULT
FusionResizeArray(
    T *&rprgtArrayInOut,
    SIZE_T nOldSize,
    SIZE_T nNewSize
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    T *prgtTempNewArray = NULL;

    //
    //  nMaxCopy is the number of elements currently in the array which
    //  need to have their values preserved.  If we're actually shrinking
    //  the array, it's the new size; if we're expanding the array, it's
    //  the old size.
    //
    const SIZE_T nMaxCopy = (nOldSize > nNewSize) ? nNewSize : nOldSize;

    if ((nOldSize != 0) && (rprgtArrayInOut == NULL))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // If the resize is to the same size, complain in debug builds because
    // the caller should have been smarter than to call us, but don't do
    // any actual work.
    ASSERT(nOldSize != nNewSize);
    if (nOldSize == nNewSize)
    {
        hr = NOERROR;
        goto Exit;
    }

    // Allocate the new array:
    IFCOMFAILED_EXIT(::FusionAllocateArray(nNewSize, prgtTempNewArray));

    if (::FusionCanMemcpyContents(rprgtArrayInOut)) {
        memcpy(prgtTempNewArray, rprgtArrayInOut, sizeof(T) * nMaxCopy);
    } else if (!::FusionCanMoveContents(rprgtArrayInOut)) {
        // Copy the body of the array:
        for (SIZE_T i=0; i<nMaxCopy; i++) {
            IFCOMFAILED_EXIT(::FusionCopyContents(prgtTempNewArray[i], rprgtArrayInOut[i]));
        }
    } else {
        // Move each of the elements:
        for (SIZE_T i=0; i<nMaxCopy; i++) {
            ::FusionMoveContents(prgtTempNewArray[i], rprgtArrayInOut[i]);
        }
    }

    // We're done.  Blow away the old array and put the new one in its place.
    ::FusionFreeArray(nOldSize, rprgtArrayInOut);
    rprgtArrayInOut = prgtTempNewArray;
    prgtTempNewArray = NULL;

    // Canonicalize the HRESULT we're returning so that we don't return random
    // S_FALSE or other success HRESULTs from the allocator or copy functions.
    hr = NOERROR;

Exit:

    if (prgtTempNewArray != NULL)
        ::FusionFreeArray(nNewSize, prgtTempNewArray);

    return hr;
}

template <typename T>
inline BOOL
FusionWin32ResizeArray(
    T *&rprgtArrayInOut,
    SIZE_T nOldSize,
    SIZE_T nNewSize
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    T *prgtTempNewArray = NULL;

    //
    //  nMaxCopy is the number of elements currently in the array which
    //  need to have their values preserved.  If we're actually shrinking
    //  the array, it's the new size; if we're expanding the array, it's
    //  the old size.
    //
    const SIZE_T nMaxCopy = (nOldSize > nNewSize) ? nNewSize : nOldSize;

    PARAMETER_CHECK((rprgtArrayInOut != NULL) || (nOldSize == 0));

    // If the resize is to the same size, complain in debug builds because
    // the caller should have been smarter than to call us, but don't do
    // any actual work.
    ASSERT(nOldSize != nNewSize);
    if (nOldSize != nNewSize)
    {
        // Allocate the new array:
        IFW32FALSE_EXIT(::FusionWin32AllocateArray(nNewSize, prgtTempNewArray));

        if (::FusionCanMemcpyContents(rprgtArrayInOut))
        {
            memcpy(prgtTempNewArray, rprgtArrayInOut, sizeof(T) * nMaxCopy);
        }
        else if (!::FusionCanMoveContents(rprgtArrayInOut))
        {
            // Copy the body of the array:
            for (SIZE_T i=0; i<nMaxCopy; i++)
                IFW32FALSE_EXIT(::FusionWin32CopyContents(prgtTempNewArray[i], rprgtArrayInOut[i]));
        }
        else
        {
            // Move each of the elements:
            for (SIZE_T i=0; i<nMaxCopy; i++)
            {
                ::FusionWin32CopyContents(prgtTempNewArray[i], rprgtArrayInOut[i]);
            }
        }

        // We're done.  Blow away the old array and put the new one in its place.
        ::FusionFreeArray(nOldSize, rprgtArrayInOut);
        rprgtArrayInOut = prgtTempNewArray;
        prgtTempNewArray = NULL;
    }

    fSuccess = TRUE;

Exit:
    if (prgtTempNewArray != NULL)
        ::FusionFreeArray(nNewSize, prgtTempNewArray);

    return fSuccess;
}

#define MAKE_CFUSIONARRAY_READY(Typename, CopyFunc) \
    template<> inline BOOL FusionWin32CopyContents<Typename>(Typename &rtDest, const Typename &rcSource) { \
        FN_PROLOG_WIN32 IFW32FALSE_EXIT(rtDest.CopyFunc(rcSource)); FN_EPILOG } \
    template<> inline HRESULT FusionCopyContents<Typename>(Typename &rtDest, const Typename &rcSource) { \
        HRESULT hr = E_FAIL; FN_TRACE_HR(hr); IFW32FALSE_EXIT(::FusionWin32CopyContents<Typename>(rtDest, rcSource)); FN_EPILOG } \
    template<> inline VOID FusionMoveContents<Typename>(Typename &rtDest, Typename &rcSource) { \
        FN_TRACE(); HARD_ASSERT2_ACTION(FusionMoveContents<Typename>, "FusionMoveContents not allowed in 99.44% of cases."); }

#endif // !defined(FUSION_ARRAYHELP_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\cfusionarraytypedefs.h ===
/*-----------------------------------------------------------------------------
Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

@doc external

@module CFusionArrayTypedefs.h

@owner JayK
-----------------------------------------------------------------------------*/
#if !defined(FUSION_INC_CFUSIONARRAYTYPEDEFS_H_INCLUDED_) // {
#define FUSION_INC_CFUSIONARRAYTYPEDEFS_H_INCLUDED_
#pragma once

#include <stddef.h>
#include "CFusionPointerIterator.h"

/*-----------------------------------------------------------------------------
Name: CFusionArrayTypedefs

@class

@owner JayK
-----------------------------------------------------------------------------*/
template
<
	typename type
>
class CFusionArrayTypedefs
{
public:
	// @cmember This is the type the array holds.
	//It is like std::vector<T>::value_type.
	typedef type				ValueType;

	// @cmember the type returned by GetSize
    // (size_type in the STL, and more usually size_t)
	typedef SIZE_T              SizeType;

    // @cmember the type you get subtracting iterators
    // (difference_type in the STL, and more usually ptrdiff_t)
	typedef SSIZE_T             DifferenceType;

	// @cmember
	typedef ValueType*			Pointer;
	// @cmember
	typedef const ValueType*	ConstPointer;

	// @cmember
	typedef ValueType&			Reference;
	// @cmember
	typedef const ValueType&	ConstReference;

	// @cmember
	typedef CFusionPointerIterator
	<
		ValueType,
		SSIZE_T,
		Pointer,
		Reference,
		Pointer,
		Reference
	> Iterator;

	// @cmember
	typedef CFusionPointerIterator
	<
		ValueType,
		SSIZE_T,
		ConstPointer,
		ConstReference,
		Pointer,
		Reference
	> ConstIterator;

private:
	// The compiler generates bad code when you have empty base classes.
	int m_workaroundVC7Bug76863;
};

// }

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\cfusionpointeriterator.h ===
/*-----------------------------------------------------------------------------
Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.

Copyright (c) 1994
Hewlett-Packard Company

Permission to use, copy, modify, distribute and sell this
software and its documentation for any purpose is hereby
granted without fee, provided that the above copyright notice
appear in all copies and that both that copyright notice and
this permission notice appear in supporting documentation.
Hewlett-Packard Company makes no representations about the
suitability of this software for any purpose. It is provided
"as is" without express or implied warranty.

@doc external

@module CFusionPointerIterator

@owner a-JayK
-----------------------------------------------------------------------------*/
#if !defined(FUSION_INC_CPOINTER_ITERATOR_H_INCLUDED_) // {
#define FUSION_INC_CPOINTER_ITERATOR_H_INCLUDED_
#pragma once

/*
Name: CFusionPointerIterator

@class
This is copied from std::_Ptrit, and cleaned up.

@hung i or it for iterator
@owner a-JayK
*/
template
<
	typename T,       // @tcarg the type pointed to
	typename Distance, // @tcarg usually ptrdiff_t, which is usually long or __int64
	typename Pointer, // @tcarg const or mutable
	typename Reference, // @tcarg const or mutable
	typename MutablePointer, // @tcarg never const
	typename MutableReference // @tcarg never const
>
class CFusionPointerIterator
//FUTURE : public std::iterator<std::random_access_iterator_tag, T, Distance, Pointer, Reference>
{
public:
	// @cmember
	CFusionPointerIterator(Pointer p = Pointer()) throw();
	// @cmember
	CFusionPointerIterator
	(
		const CFusionPointerIterator
		<
			T,
			Distance,
			MutablePointer,
			MutableReference,
			MutablePointer,
			MutableReference
		>&
	) throw();

	// @cmember
	Pointer PtBase() const throw();
	// @cmember
	Reference operator*() const throw();
	// @cmember
	Pointer operator->() const throw();
	// @cmember
	CFusionPointerIterator& operator++() throw();
	// @cmember
	CFusionPointerIterator operator++(int) throw();
	// @cmember
	CFusionPointerIterator& operator--() throw();
	// @cmember
	CFusionPointerIterator operator--(int) throw();

	// Why is this in xutility
	//bool operator==(int y) const throw();

	// @cmember
	bool operator==(const CFusionPointerIterator& y) const throw();
	// @cmember
	bool operator!=(const CFusionPointerIterator& y) const throw();
	// @cmember
	CFusionPointerIterator& operator+=(Distance n) throw();
	// @cmember
	CFusionPointerIterator operator+(Distance n) const throw();
	// @cmember
	CFusionPointerIterator& operator-=(Distance n) throw();
	// @cmember
	CFusionPointerIterator operator-(Distance n) const throw();
	// @cmember
	Reference operator[](Distance n) const throw();
	// @cmember
	// @cmember
	bool operator<(const CFusionPointerIterator& y) const throw();
	// @cmember
	bool operator>(const CFusionPointerIterator& y) const throw();
	// @cmember
	bool operator<=(const CFusionPointerIterator& y) const throw();
	// @cmember
	bool operator>=(const CFusionPointerIterator& y) const throw();
	// @cmember
	Distance operator-(const CFusionPointerIterator& y) const throw();

protected:
	// @cmember
	Pointer m_current;
};

// @func
template
<
	typename T, // @tfarg
	typename Distance, // @tfarg
	typename Pointer, // @tfarg
	typename Reference, // @tfarg
	typename MutablePointer, // @tfarg
	typename MutableReference // @tfarg
>
inline CFusionPointerIterator<T, Distance, Pointer, Reference, MutablePointer, MutableReference>
operator+
(
	Distance n,
	const CFusionPointerIterator
	<
		T,
		Distance,
		Pointer,
		Reference,
		MutablePointer,
		MutableReference
	>&
) throw();

#include "CFusionPointerIterator.inl"

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\crtsubst.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    crtsubst.h

Abstract:

    Maps some CRT functions to Win32 calls

Author:

    Rajeev Dujari (rajeevd) 04-Apr-1996

Revision History:

    04-Apr-1996 rajeevd
        Created
--*/
#ifndef unix
/*
   On NT, kernel32 forwards RtlMoveMemory to ntdll.
   On 95, kernel32 has RtlMoveMemory but ntdll doesn't.
   Override the NT headers forwarding at compile time.
*/
#ifdef RtlMoveMemory
#undef RtlMoveMemory
extern "C" void RtlMoveMemory (void *, const void *, unsigned long);
#endif

/* WARNING: Be careful mapping CRT strncpy to Win32 lstrcpyn.

   strncpy  (dst, "bar", 2);  // dst will get 'b', 'a'
   lstrcpyn (dst, "bar" 2);   // dst will get 'b',  0

   strncpy  (dst, "bar", 6);  // dst will get 'b', 'a', 'r', 0, 0, 0
   lstrcpyn (dst, "bar", 6);  // dst will get 'b', 'a', 'r', 0
*/

#undef free
#undef malloc
#undef memmove
#undef strdup
#undef stricmp
#undef _stricmp
#undef strlwr
#undef _strlwr
#undef strupr
#undef tolower
#undef toupper
#undef wcslen
#undef _strstr
#undef strstr
#undef _strchr
#undef strchr
#undef strrchr
#undef __atoi
#undef _atoi
#undef atoi
#undef _strncat
#undef strncat
#undef _strncpy
#undef strncpy
#undef _strnicmp
#undef strnicmp
#undef _strncmp
#undef strncmp
//#undef StrChr


#define free(ptr)         FREE_MEMORY((HLOCAL) ptr)
#define malloc(size)      ((PVOID)ALLOCATE_MEMORY(LMEM_FIXED, size))
#define memmove(m1,m2,n)  RtlMoveMemory (m1,m2,n)
#define strdup(s)         NewString(s)
#define stricmp(s1,s2)    lstrcmpi(s1,s2)
#define _stricmp(s1,s2)   lstrcmpi(s1,s2)
#define strlwr(s)         CharLower(s)
#define _strlwr(s)        CharLower(s)
#define strupr(s)         CharUpper(s)
#define tolower(c)        ((BYTE) CharLower((LPSTR) ((DWORD)((BYTE)(c) & 0xff))))
#define toupper(c)        ((BYTE) CharUpper((LPSTR) ((DWORD)((BYTE)(c) & 0xff))))
#define wcslen(s)         lstrlenW(s)
#define _strstr           StrStr
#define strstr            StrStr
//#define StrChr            PrivateStrChr
#define _strchr           StrChr
#define strchr            StrChr
#define strrchr(s, c)     StrRChr(s, NULL, c)
#define __atoi            StrToInt
#define _atoi             StrToInt
#define atoi              StrToInt
#define strncat           StrNCat
#define _strncat          StrNCat
#define strncpy           StrNCpy
#define _strncpy          StrNCpy
#define strnicmp          StrCmpNIC
#define _strnicmp         StrCmpNIC
#define strncmp           StrCmpNC
#define _strncmp          StrCmpNC

#undef itoa
#undef ultoa

//#define itoa(val,s,n)     _itoa(val,s,n)
//#define ultoa(val,s,n)    _ultoa(val,s,n)


#endif /* unix */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\cfusionpointeriterator.inl ===
/*-----------------------------------------------------------------------------
Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.

Copyright (c) 1994
Hewlett-Packard Company

Permission to use, copy, modify, distribute and sell this
software and its documentation for any purpose is hereby
granted without fee, provided that the above copyright notice
appear in all copies and that both that copyright notice and
this permission notice appear in supporting documentation.
Hewlett-Packard Company makes no representations about the
suitability of this software for any purpose. It is provided
"as is" without express or implied warranty.

@doc external

@module CFusionPointerIterator

@owner a-JayK
-----------------------------------------------------------------------------*/
#pragma once
#include "CFusionPointerIterator.h"

//namespace NVseeLibContainer
//{

/*
Name: CFusionPointerIterator::CFusionPointerIterator

@mfunc
This constructs the iterator, making it equivalent (at least its value,
not quite its interface) to the pointer passed in.

@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::CFusionPointerIterator
(
	Pointer p // @arg set the iterator to this initially.
) throw()
: m_current(p)
{
}

/*
Name: CFusionPointerIterator::CFusionPointerIterator

@mfunc
This copy constructs an iterator, but it is not necessarily
the "default" copy constructor. If the iterator is const, this
copy constructor constructs it from a non const iterator. The
reverse conversion (const to non const) is invalid and disallowed.

If the iterator is not const, this does end up being the usual
copy constructor.

@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::CFusionPointerIterator
(
	const CFusionPointerIterator
	<
		T,
		Distance,
		MutablePointer,
		MutableReference,
		MutablePointer,
		MutableReference
	>& x
) throw()
: m_current(x.PtBase())
{
}

/*
Name: CFusionPointerIterator::PtBase

@mfunc
This returns the value of the pointer underlying the iterator.
It is in std::_Ptrit, but should not be needed by clients,
but it used once internally.

@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline Pointer
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::PtBase
(
) const throw()
{
	return (m_current);
}

/*
Name: CFusionPointerIterator::operator*

@mfunc
This dereferences the iterator, which is exactly like
dereferencing the underlying pointer.

@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline Reference
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator*
(
) const throw()
{
	return (*m_current);
}

/*
Name: CFusionPointerIterator::operator->

@mfunc
This dereferences the underlying pointer, but in the way
that can be followed by the name of a member datum or
member function.

@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline Pointer
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator->
(
) const throw()
{
	return (&**this);
}

/*
Name: CFusionPointerIterator::operator++

@mfunc
This increments the iterator, and returns the new value.
It is pre increment.

@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>&
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator++
(
) throw()
{
	++m_current;
	return (*this);
}

/*
Name: CFusionPointerIterator::operator++

@mfunc
This increments the iterator, and returns the old value.
It is post increment.

@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator++
(
	int
) throw()
{
	CFusionPointerIterator tmp = *this;
	++m_current;
	return (tmp);
}

/*
Name: CFusionPointerIterator::operator--

@mfunc
This decrements the iterator, and returns the new value.
It is pre decrement.

@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>&
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator--
(
) throw()
{
	--m_current;
	return (*this);
}

/*
Name: CFusionPointerIterator::operator--

@mfunc
This decrements the iterator, and returns the old value.
It is post decrement.

@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator--
(
	int
) throw()
{
	CFusionPointerIterator tmp = *this;
	--m_current;
	return (tmp);
}

/*
Name: CFusionPointerIterator::operator==

@mfunc
This compares an iterator for equality with an integer.
It is totally type unsafe and I don't know why std::_Ptrit
provides it. Maybe for comparison to NULL?..no, that doesn't
make sense, you should only compare iterators with other iterators,
including the return value of Container::end().

@owner a-JayK
*/
/* FUTURE Why is this in xutility
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline bool
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator==(int y) const
{
	return (m_current == reinterpret_cast<Pointer>(y));
}
*/

/*
Name: CFusionPointerIterator::operator==
@mfunc
@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline bool
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator==
(
	const CFusionPointerIterator& y // @arg
) const throw()
{
	return (m_current == y.m_current);
}

/*
Name: CFusionPointerIterator::operator!=
@mfunc
@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline bool
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator!=
(
	const CFusionPointerIterator& y
) const throw()
{
	return (!(*this == y));
}

/*
Name: CFusionPointerIterator::operator+=
@mfunc
@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>&
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator+=
(
	Distance n // @arg
) throw()
{
	m_current += n;
	return (*this);
}

/*
Name: CFusionPointerIterator::operator+
@mfunc
@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator+
(
	Distance n // @arg
) const throw()
{
	return (CFusionPointerIterator(m_current + n));
}

/*
Name: CFusionPointerIterator::operator-=
@mfunc
@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>&
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator-=
(
	Distance n // @arg
) throw()
{
	m_current -= n;
	return (*this);
}

/*
Name: CFusionPointerIterator::operator-
@mfunc
@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator-
(
	Distance n // @arg
) const throw()
{
	return (CFusionPointerIterator(m_current - n));
}

/*
Name: CFusionPointerIterator::operator[]
@mfunc
@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline Reference
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator[]
(
	Distance n // @arg
) const throw()
{
	return (*(*this + n));
}

/*
Name: CFusionPointerIterator::operator<
@mfunc
@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline bool
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator<
(
	const CFusionPointerIterator& y // @arg
) const throw()
{
	return (m_current < y.m_current);
}

/*
Name: CFusionPointerIterator::operator>
@mfunc
@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline bool
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator>
(
	const CFusionPointerIterator& y // @arg
) const throw()
{
	return (y < *this);
}

/*
Name: CFusionPointerIterator::operator<=
@mfunc
@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline bool
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator<=
(
	const CFusionPointerIterator& y // @arg
) const throw()
{
	return (!(y < *this));
}

/*
Name: CFusionPointerIterator::operator>=
@mfunc
@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline bool
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator>=
(
	const CFusionPointerIterator& y // @arg
) const throw()
{
	return (!(*this < y));
}

/*
Name: CFusionPointerIterator::operator-
@mfunc
@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline Distance
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator-
(
	const CFusionPointerIterator& y // @arg
) const throw()
{
    // static_cast, say, __int64 down to int
	return static_cast<Distance>(m_current - y.m_current);
}

/*
Name: operator+
@func
@owner a-JayK
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T, Distance, Pointer, Reference, MutablePointer, MutableReference>
operator+
(
	Distance n, // @arg
	const CFusionPointerIterator<T, Distance, Pointer, Reference, MutablePointer, MutableReference>& y // @arg
) throw()
{
	return (y + n);
}

//} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\csxspreservelasterror.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    CSxsPreserveLastError.h

Abstract:

Author:

    Jay Krell (a-JayK) October 2000

Revision History:

--*/
#pragma once

#include "fusionlastwin32error.h"

//
// The idea here is to avoid hitting breakpoints on ::SetLastError
// or data breakpoints on NtCurrentTeb()->LastErrorValue.
//
class CSxsPreserveLastError
{
public:
    DWORD LastError() const { return m_dwLastError; }

    inline CSxsPreserveLastError() { ::FusionpGetLastWin32Error(&m_dwLastError); }
    inline void Restore() const { ::FusionpSetLastWin32Error(m_dwLastError); }

protected:
    DWORD m_dwLastError;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\dialogs.h ===
#ifndef __SXS_DIALOGS
#define __SXS_DIALOGS


#define IDC_STATIC                              -1
#define IDC_PROGRESS                            101
#define IDC_NET_NAME                            102
#define IDC_MEDIA_NAME                          103
#define IDC_PROMPT_TEXT                         104

#define IDC_RETRY                               150
#define IDC_INFO                                151

#define IDI_CDROM                               201
#define IDI_NETWORK                             202

#define IDS_TITLE                               301
#define IDS_ERROR_TITLE                         302
#define IDS_PROTDLL_DISABLED                    303
#define IDS_FILE_CHANGE                         304
#define IDS_CANCEL_CONFIRM                      305
#define IDS_WRONG_CD                            306
#define IDS_MORE_INFORMATION_CD                 307
#define IDS_MORE_INFORMATION_NET                308
#define IDS_WRONG_NETCD                         309
#define IDS_RESTORE_TEXT                        310
#define IDS_CACHE_TEXT                          311
#define IDS_INSTALL_PROTECTED_TEXT              312
#define IDS_CANCEL_CONFIRM_INSTALL              313
#define IDS_CANCEL_CONFIRM_CACHE                314


#define IDS_UNKNOWN                             320

#define IDD_PROGRESS                            401
#define IDD_SFC_CD_PROMPT                       402
#define IDD_SFC_NETWORK_PROMPT                  403


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\debmacro.h ===
#if !defined(_FUSION_INC_DEBMACRO_H_INCLUDED_)
#define _FUSION_INC_DEBMACRO_H_INCLUDED_

#pragma once

//
// Copyright (c) 1999-2000 Microsoft Corporation
//
// Fusion Debug Macros
//


//
// Sorry but we're way too in bed with C++ constructs etc.  You need to author
// C++ source code to interop with this header.

#if !defined(__cplusplus)
#error "You need to build Fusion sources as C++ files"
#endif // !defined(__cplusplus)

#ifndef SZ_COMPNAME
#define SZ_COMPNAME "FUSION: "
#endif

#ifndef WSZ_COMPNAME
#define WSZ_COMPNAME L"FUSION: "
#endif

#if !defined(NT_INCLUDED)
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#endif
#include "fusionlastwin32error.h"

#undef ASSERT

//
//  These definitions are always valid, regardless of whether this is a free
//  or checked build.
//

#if !defined(DPFLTR_ERROR_LEVEL)
#define DPFLTR_ERROR_LEVEL 0
#endif

#if !defined(DPFLTR_WARNING_LEVEL)
#define DPFLTR_WARNING_LEVEL 1
#endif

#if !defined(DPFLTR_TRACE_LEVEL)
#define DPFLTR_TRACE_LEVEL 2
#endif

#if !defined(DPFLTR_INFO_LEVEL)
#define DPFLTR_INFO_LEVEL 3
#endif

#if !defined(DPFLTR_MASK)
#define DPFLTR_MASK 0x80000000
#endif

//
//  Guidlines:
//
//  Use bits 0-15 for general types of issues, e.g. entry/exit tracing,
//  dumping heap usage, etc.
//
//  Use bits 16-30 for more fusion-specific kinds of topics like
//  binding diagnosis, etc.
//

#define FUSION_DBG_LEVEL_INFO           (0x00000002 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_VERBOSE        (0x00000004 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_ENTEREXIT      (0x00000008 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_ERROREXITPATH  (0x00000010 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_CONSTRUCTORS   (0x00000020 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_DESTRUCTORS    (0x00000040 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_REFCOUNTING    (0x00000080 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_HEAPALLOC      (0x00000100 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_HEAPDEALLOC    (0x00000200 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_HEAPDEBUG      (0x00000400 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_MSI_INSTALL	(0x00000800 | DPFLTR_MASK)

#define FUSION_DBG_LEVEL_POLICY         (0x00010000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_HASHTABLE      (0x00020000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_WFP            (0x00040000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_ACTCTX         (0x00080000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_XMLNAMESPACES  (0x00100000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_XMLTREE        (0x00200000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_INSTALLATION   (0x00400000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_PROBING        (0x00800000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_XMLSTREAM      (0x01000000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_SETUPLOG       (0x02000000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_NODEFACTORY    (0x04000000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_FULLACTCTX     (0x08000000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_FILECHANGENOT  (0x10000000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_LOG_ACTCTX     (0x20000000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_FREEBUILDERROR (0x40000000 | DPFLTR_MASK)

#if DBG

//
//  In DBG builds, all error level events are always shown.
//

#define FUSION_DBG_LEVEL_ERROR DPFLTR_ERROR_LEVEL

#else // DBG

//
//  In FRE builds, use an explicit mask.
//

#define FUSION_DBG_LEVEL_ERROR FUSION_DBG_LEVEL_FREEBUILDERROR

#endif // DBG

// updated when the user-mode copy of the kernel debugging flags are updated
extern "C" bool g_FusionEnterExitTracingEnabled;

bool
FusionpDbgWouldPrintAtFilterLevel(
    ULONG FilterLevel
    );

DWORD
FusionpHRESULTToWin32(
    HRESULT hr
    );

typedef struct _FRAME_INFO
{
    PCSTR pszFile;
    PCSTR pszFunction;
    INT nLine;
} FRAME_INFO, *PFRAME_INFO;

typedef const struct _FRAME_INFO *PCFRAME_INFO;

typedef struct _CALL_SITE_INFO CALL_SITE_INFO, *PCALL_SITE_INFO;
typedef const struct _CALL_SITE_INFO *PCCALL_SITE_INFO;

void __fastcall FusionpTraceWin32LastErrorFailureExV(const CALL_SITE_INFO &rCallSiteInfo, PCSTR Format, va_list Args);
void __fastcall FusionpTraceWin32LastErrorFailureOriginationExV(const CALL_SITE_INFO &rCallSiteInfo, PCSTR Format, va_list Args);

typedef struct _CALL_SITE_INFO
{
    PCSTR pszFile;
    PCSTR pszFunction;
    PCSTR pszApiName;
    INT   nLine;

    void __cdecl TraceWin32LastErrorFailureEx(PCSTR Format, ...) const
        { va_list Args; va_start(Args, Format); FusionpTraceWin32LastErrorFailureExV(*this, Format, Args); va_end(Args); }

    void __cdecl TraceWin32LastErrorFailureOriginationEx(PCSTR Format, ...) const
        { va_list Args; va_start(Args, Format); FusionpTraceWin32LastErrorFailureOriginationExV(*this, Format, Args); va_end(Args); }

} CALL_SITE_INFO, *PCALL_SITE_INFO;

bool
FusionpPopulateFrameInfo(
    FRAME_INFO &rFrameInfo,
    PCSTR pszFile,
    PCSTR pszFunction,
    INT nLine
    );

bool
__fastcall
FusionpPopulateFrameInfo(
    FRAME_INFO &rFrameInfo,
    PCTEB_ACTIVE_FRAME ptaf
    );

bool
__fastcall
FusionpGetActiveFrameInfo(
    FRAME_INFO &rFrameInfo
    );

#if _X86_
#define FUSION_DEBUG_BREAK_IN_FREE_BUILD() __asm { int 3 }
#else // _X86_
#define FUSION_DEBUG_BREAK_IN_FREE_BUILD() DebugBreak()
#endif // _X86_

//
//  Like FusionpAssertionFailed(), FusionpReportConditionAndBreak() will try to break in; if it's
//

bool FusionpReportConditionAndBreak(PCSTR pszMessage, ...);

#if DBG

// Normal macro for breaking in checked builds; make people use the nasty name
// if they're going to do the nasty thing.
#define FUSION_DEBUG_BREAK() FUSION_DEBUG_BREAK_IN_FREE_BUILD()

//
//  Assertion failure reporting internal APIs.
//
//  They return true if they were not able to issue the breakpoint; false if they were.
//

bool FusionpAssertionFailed(PCSTR pszExpression, PCSTR pszMessage = NULL, ...);
bool FusionpAssertionFailed(const FRAME_INFO &rFrameInfo, PCSTR pszExpression, PCSTR pszMessage = NULL);
bool FusionpAssertionFailed(PCSTR pszFile, PCSTR pszFunction, INT nLine, PCSTR pszExpression, PCSTR pszMessage = NULL);

//
//  Soft assertion failures are really just debug messages, but they should result in
//  bugs being filed.
//

VOID FusionpSoftAssertFailed(PCSTR pszExpression, PCSTR pszMessage = NULL);
VOID FusionpSoftAssertFailed(const FRAME_INFO &rFrameInfo, PCSTR pszExpression, PCSTR pszMessage = NULL);
VOID FusionpSoftAssertFailed(PCSTR pszFile, PCSTR pszFunction, INT nLine, PCSTR pszExpression, PCSTR pszMessage = NULL);

#define HARD_ASSERT2_ACTION(_e, _m) \
do \
{ \
    if (::FusionpAssertionFailed(__FILE__, __FUNCTION__, __LINE__, #_e, (_m))) \
    { \
        FUSION_DEBUG_BREAK();\
    } \
} while (0)

#define HARD_ASSERT2(_e, _m) \
do \
{ \
    __t.SetLine(__LINE__); \
    if (!(_e)) \
        HARD_ASSERT2_ACTION(_e, (_m)); \
} while (0)

/*
    if (__exists(__t)) \
    { \
        CNoTraceContextUsedInFrameWithTraceObject x; \
    }

*/

#define HARD_ASSERT2_NTC(_e, _m) \
do \
{ \
    if (!(_e)) \
        HARD_ASSERT2_ACTION(_e, (_m)); \
} while (0)

// Pick up the locally-scoped trace context by default
#define HARD_ASSERT(_e) HARD_ASSERT2(_e, NULL)
#define HARD_ASSERT_NTC(_e) HARD_ASSERT2_NTC(_e, NULL)

/*-----------------------------------------------------------------------------
VERIFY is like ASSERT, but it evaluates it expression in retail/free builds
too, so you can say VERIFY(CloseHandle(h)) whereas ASSERT(CloseHandle(h))
would fail to close the handle in free builds

VERIFY2 adds a message as well, like VSASSERT or ASSERTMSG, in its second parameter
-----------------------------------------------------------------------------*/

#define HARD_VERIFY(_e) HARD_ASSERT(_e)
#define HARD_VERIFY_NTC(_e) HARD_ASSERT_NTC(_e)

#define HARD_VERIFY2(_e, _m) HARD_ASSERT2(_e, _m)
#define HARD_VERIFY2_NTC(_e, _m) HARD_ASSERT2_NTC(_e, _m)

#define SOFT_ASSERT2(_e, _m) \
    do \
    { \
        __t.SetLine(__LINE__); \
        if (!(_e)) \
            ::FusionpSoftAssertFailed(__FILE__, __FUNCTION__, __LINE__, #_e, (_m)); \
    } while (0)

#define SOFT_ASSERT(_e) SOFT_ASSERT2(_e, NULL)

#define SOFT_ASSERT2_NTC(_e, _m) \
    do \
    { \
        if (!(_e)) \
            ::FusionpSoftAssertFailed(__FILE__, __FUNCTION__, __LINE__, #_e, (_m)); \
    } while (0)

#define SOFT_ASSERT_NTC(_e) SOFT_ASSERT2_NTC(_e, NULL)

#define SOFT_VERIFY(_e) SOFT_ASSERT(_e)
#define SOFT_VERIFY_NTC(_e) SOFT_ASSERT_NTC(_e)

#define SOFT_VERIFY2(_e, _m) SOFT_ASSERT2(_e, _m)
#define SOFT_VERIFY2_NTC(_e, _m) SOFT_ASSERT2_NTC(_e, _m)

#else // DBG

#define FUSION_DEBUG_BREAK() do { } while (0)
#define HARD_ASSERT(_e) /* nothing */
#define HARD_ASSERT_NTC(_e) /* nothing */
#define HARD_ASSERT2_ACTION(_e, _m) /* nothing */
#define HARD_ASSERT2(_e, _m) /* nothing */
#define HARD_ASSERT2_NTC(_e, _m) /* nothing */

#define HARD_VERIFY(_e) (_e)
#define HARD_VERIFY_NTC(_e) (_e)
#define HARD_VERIFY2(_e, _m) (_e)
#define HARD_VERIFY2_NTC(_e, _m) (_e)

#define SOFT_ASSERT(_expr)
#define SOFT_ASSERT_NTC(_e)
#define SOFT_ASSERT2(_e, _m)
#define SOFT_ASSERT2_NTC(_e, _m)

#define SOFT_VERIFY(_e) (_e)
#define SOFT_VERIFY_NTC(_e) (_e)

#define SOFT_VERIFY2(_e, _m) (_e)
#define SOFT_VERIFY2_NTC(_e, _m) (_e)

#endif // DBG

#define VERIFY(_e) HARD_VERIFY(_e)
#define VERIFY_NTC(_e) HARD_VERIFY_NTC(_e)
#define VERIFY2(_e, _m) HARD_VERIFY2(_e, _m)
#define VERIFY2_NTC(_e, _m) HARD_VERIFY2_NTC(_e, _m)

#define ASSERT(_e) HARD_ASSERT(_e)
#define ASSERT2(_e, _m) HARD_ASSERT2(_e, _m)
#define ASSERT_NTC(_e) HARD_ASSERT_NTC(_e)
#define ASSERT2_NTC(_e, _m) HARD_ASSERT2_NTC(_e, _m)

#define INTERNAL_ERROR2_ACTION(_e, _m) do { HARD_ASSERT2_ACTION(_e, _m); __t.MarkInternalError(); goto Exit; } while (0)

#define INTERNAL_ERROR_CHECK(_e) do { if (!(_e)) { INTERNAL_ERROR2_ACTION(_e, NULL); } } while (0)
#define INTERNAL_ERROR_CHECK2(_e, _m) do { if (!(_e)) { INTERNAL_ERROR2_ACTION(_e, _m); } } while (0)

// There are several win32 errors for out of memory.
// We'll always use FUSION_WIN32_ALLOCFAILED_ERROR so that if we change
// out minds about which one is right we can do it in one place.

#define FUSION_WIN32_ALLOCFAILED_ERROR ERROR_OUTOFMEMORY

/*
This is appropriate in the rare cases when you have __try/__except, which preclude
you from declaring the local FN_TRACE_WIN32 if you are compiling -GX or -EH.
*/
#define IFW32FALSE_EXIT_LIGHT(x) do { if (!(x)) { KdPrint(("SXS:"__FUNCTION__" %s failed; GetLastError() = %lu\n", #x, ::GetLastError())); goto Exit; } } while (0)

#if !defined(FUSION_CAPTURE_STACKS)
#if DBG
#define FUSION_CAPTURE_STACKS (1)
#endif // DBG
#endif // !defined(FUSION_CAPTURE_STACKS)

class CNoTraceContextUsedInFrameWithTraceObject
{
private:
    CNoTraceContextUsedInFrameWithTraceObject(); // intentionally not implemented
    ~CNoTraceContextUsedInFrameWithTraceObject(); // intentionally not implemented
};

typedef struct _SXS_STATIC_TRACE_CONTEXT
{
    TEB_ACTIVE_FRAME_CONTEXT_EX m_FrameContext;
    INT m_StartLine;
} SXS_STATIC_TRACE_CONTEXT;

typedef struct _SXS_STATIC_RELEASE_TRACE_CONTEXT
{
    SXS_STATIC_TRACE_CONTEXT m_TraceContext;
    PCSTR m_TypeName;
} SXS_STATIC_RELEASE_TRACE_CONTEXT;

class CFrame;

typedef struct _FROZEN_STACK
{
    ULONG        ulDepth;
    ULONG        ulMaxDepth;
    CFrame *pContents;
} FROZEN_STACK, *PFROZEN_STACK;

typedef enum _TRACETYPE
{
    TRACETYPE_INFO,
    TRACETYPE_CALL_START,
    TRACETYPE_CALL_EXIT_NOHRESULT,
    TRACETYPE_CALL_EXIT_HRESULT,
} TRACETYPE;

extern bool g_FusionBreakOnBadParameters;

/*
MEMORY_BASIC_INFORMATION g_SxsDllMemoryBasicInformation;
*/

VOID FusionpConvertCOMFailure(HRESULT & __hr);

int STDAPIVCALLTYPE _DebugTraceA(PCSTR pszMsg, ...);
int STDAPICALLTYPE _DebugTraceVaA(PCSTR pszMsg, va_list ap);
int STDAPIVCALLTYPE _DebugTraceW(PCWSTR pszMsg, ...);
int STDAPICALLTYPE _DebugTraceVaW(PCWSTR pszMsg, va_list ap);

int STDAPIVCALLTYPE _DebugTraceExA(DWORD dwFlags, TRACETYPE tt, HRESULT hr, PCSTR pszMsg, ...);
int STDAPICALLTYPE _DebugTraceExVaA(DWORD dwFlags, TRACETYPE tt, HRESULT hr, PCSTR pszMsg, va_list ap);
int STDAPIVCALLTYPE _DebugTraceExW(DWORD dwFlags, TRACETYPE tt, HRESULT hr, PCWSTR pszMsg, ...);
int STDAPICALLTYPE _DebugTraceExVaW(DWORD dwFlags, TRACETYPE tt, HRESULT hr, PCWSTR pszMsg, va_list ap);

void __fastcall FusionpTraceWin32LastErrorFailure(const CALL_SITE_INFO &rCallSiteInfo);
void __fastcall FusionpTraceWin32LastErrorFailureOrigination(const CALL_SITE_INFO &rCallSiteInfo);

/*
These are never used outside trace.cpp.

void FusionpTraceWin32FailureNoFormatting(const FRAME_INFO &rFrameInfo, DWORD dwWin32Status, PCSTR pszMessage);
void FusionpTraceWin32FailureNoFormatting(DWORD dwWin32Status, PCSTR pszMessage);
void FusionpTraceWin32FailureNoFormatting(PCSTR pszFile, PCSTR pszFunction, INT nLine, DWORD dwWin32Status, PCSTR pszMessage);

void FusionpTraceWin32FailureOriginationNoFormatting(const FRAME_INFO &rFrameInfo, DWORD dwWin32Status, PCSTR pszMessage);
void FusionpTraceWin32FailureOriginationNoFormatting(DWORD dwWin32Status, PCSTR pszMessage);
void FusionpTraceWin32FailureOriginationNoFormatting(PCSTR pszFile, PCSTR pszFunction, INT nLine, DWORD dwWin32Status, PCSTR pszMessage);

void FusionpTraceWin32Failure(const FRAME_INFO &rFrameInfo, DWORD dwWin32Status, PCSTR pszMessage, ...);
void FusionpTraceWin32Failure(DWORD dwWin32Status, PCSTR pszMessage, ...);
void FusionpTraceWin32Failure(PCSTR pszFile, PCSTR pszFunction, INT nLine, DWORD dwWin32Status, PCSTR pszMessage, ...);
*/

void FusionpTraceWin32FailureVa(const FRAME_INFO &rFrameInfo, DWORD dwWin32Status, PCSTR pszMsg, va_list ap);
void FusionpTraceWin32FailureVa(DWORD dwWin32Status, PCSTR pszMsg, va_list ap);
void FusionpTraceWin32FailureVa(PCSTR pszFile, PCSTR pszFunction, INT nLine, DWORD dwWin32Status, PCSTR pszMsg, va_list ap);

void FusionpTraceCOMFailure(HRESULT hrIn, PCSTR pszMsg, ...);
void FusionpTraceCOMFailureVa(HRESULT hrIn, PCSTR pszMsg, va_list ap);

void FusionpTraceCOMFailureOrigination(HRESULT hrIn, PCSTR pszMsg, ...);
void FusionpTraceCOMFailureOriginationVa(HRESULT hrIn, PCSTR pszMsg, va_list ap);

void FusionpTraceCallEntry();
void FusionpTraceCallExit();

void FusionpTraceCallCOMSuccessfulExit(HRESULT hrIn, PCSTR szFormat, ...);
void FusionpTraceCallCOMSuccessfulExitVa(HRESULT hrIn, PCSTR szFormat, va_list ap);

void FusionpTraceCallSuccessfulExit(PCSTR szFormat, ...);
void FusionpTraceCallSuccessfulExitVa(PCSTR szFormat, va_list ap);

void FusionpTraceCallWin32UnsuccessfulExit(DWORD dwLastError, PCSTR szFormat, ...);
void FusionpTraceCallWin32UnsuccessfulExitVa(DWORD dwLastError, PCSTR szFormat, va_list ap);

 void FusionpTraceCallCOMUnsuccessfulExit(HRESULT hrError, PCSTR szFormat, ...);
 void FusionpTraceCallCOMUnsuccessfulExitVa(HRESULT hrError, PCSTR szFormat, va_list ap);

void FusionpTraceAllocFailure(PCSTR pszExpression);

void FusionpTraceInvalidFlags(const FRAME_INFO &rFrameInfo, DWORD dwFlagsPassed, DWORD dwValidFlags);
void FusionpTraceInvalidFlags(PCSTR pszFile, PCSTR pszFunction, INT nLine, DWORD dwFlagsPassed, DWORD dwValidFlags);
void FusionpTraceInvalidFlags(DWORD dwFlagsPassed, DWORD dwValidFlags);

void FusionpTraceNull(PCSTR pszExpression);
void FusionpTraceZero(PCSTR pszExpression);
void FusionpTraceParameterMustNotBeNull(PCSTR pszExpression);

void FusionpTraceParameterCheck(PCSTR pszExpression);
void FusionpTraceParameterCheck(PCSTR pszFile, PCSTR pszFunction, INT nLine, PCSTR pszExpression);
void FusionpTraceParameterCheck(const FRAME_INFO &rFrame, PCSTR pszExpression);

#define FUSIONP_DUMP_STACK_FORMAT_SHORT      ( 0x00000001 )
#define FUSIONP_DUMP_STACK_FORMAT_MEDIUM     ( 0x00000002 )
#define FUSIONP_DUMP_STACK_FORMAT_LONG       ( 0x00000003 )
#define FUSIONP_DUMP_STACK_FORMAT_MASK       ( 0x00000003 )

VOID FusionpDumpStack(DWORD dwFlags, ULONG ulLevel, PCWSTR pcwszLinePrefix, ULONG ulDepth);

#if FUSION_ENABLE_FROZEN_STACK

BOOL FusionpFreezeStack(DWORD dwFlags, PFROZEN_STACK pFrozenStack);
BOOL FusionpOutputFrozenStack(DWORD dwFlags, PCSTR Prefix, PFROZEN_STACK pFrozenStack);

#endif

#define TRACEMSG(_paramlist) _DebugTraceA _paramlist

#if DBG
#define DEFINE_CURRENT_FRAME_INFO(_frame) static const FRAME_INFO _frame = { __FILE__, __FUNCTION__, __LINE__ }
#define DBG_TEXT(_x) #_x
#else
#define DEFINE_CURRENT_FRAME_INFO(_frame) static const FRAME_INFO _frame = { __FILE__, "", __LINE__ }
#define DBG_TEXT(_x) ""
#endif

#define DEFINE_CALL_SITE_INFO(_callsite, _apiname) static const CALL_SITE_INFO _callsite = { __FILE__, __FUNCTION__, DBG_TEXT(_apiname), __LINE__ }
#define DEFINE_CALL_SITE_INFO_EX(_callsite) static const CALL_SITE_INFO _callsite = { __FILE__, __FUNCTION__, "", __LINE__ }

#define TRACE_WIN32_FAILURE(_apiname) \
do \
{ \
    DEFINE_CALL_SITE_INFO(__callsite, _apiname); \
    ::FusionpTraceWin32LastErrorFailure(__callsite); \
} while (0)

#define TRACE_WIN32_FAILURE_ORIGINATION(_apiname) \
do \
{ \
    DEFINE_CALL_SITE_INFO(__callsite, _apiname); \
    ::FusionpTraceWin32LastErrorFailureOrigination(__callsite); \
} while (0)

// FusionpTraceWin32Failure(FUSION_DBG_LEVEL_ERROR, __FILE__, __LINE__, __FUNCTION__, ::FusionpGetLastWin32Error(), #_apiname)
#define TRACE_COM_FAILURE(_hresult, _apiname) ::FusionpTraceCOMFailure((_hresult), DBG_TEXT(_apiname))
#define TRACE_COM_FAILURE_ORIGINATION(_hresult, _apiname) ::FusionpTraceCOMFailureOrigination((_hresult), DBG_TEXT(_apiname))

#define TRACE_DUMP_STACK(_includetop) _DebugTraceDumpStack((_includetop))
#define TRACE_ALLOCFAILED(_e) ::FusionpTraceAllocFailure(DBG_TEXT(_e))
#define TRACE_INVALID_FLAGS(_fPassed, _fExpected) ::FusionpTraceInvalidFlags((_fPassed), (_fExpected))
#define TRACE_NULL(_e) ::FusionpTraceNull(DBG_TEXT(_e))
#define TRACE_ZERO(_e) ::FusionpTraceZero(DBG_TEXT(_e))
#define TRACE_PARAMETER_MUST_NOT_BE_NULL(_p) do { ::FusionpTraceParameterMustNotBeNull(DBG_TEXT(_p)); } while (0)
#define TRACE_PARAMETER_CHECK(_e) do { ::FusionpTraceParameterCheck(DBG_TEXT(_e)); } while (0)

//
// on DBG avoid both the code breakpoint on ::FusionpSetLastWin32Error
// and the data write breakpoint on NtCurrentTeb()->LastErrorValue
//
// on !DBG, only avoid the first (perf)
//

#if DBG

// aka Sxsp::FusionpSetLastWin32ErrorAvoidingGratuitousBreakpoints
#define SxspRestoreLastError(x) \
    ((void)                                        \
    (                                              \
          (NtCurrentTeb()->LastErrorValue != (x))  \
        ? (NtCurrentTeb()->LastErrorValue = (x))   \
        : 0                                        \
    ))

#else

#define SxspRestoreLastError(x) ((void)((NtCurrentTeb()->LastErrorValue = (x))))

#endif // DBG

class CGlobalFakeTraceContext
{
public:
    static inline void SetLastError(DWORD dwLastError) { ::FusionpSetLastWin32Error(dwLastError); }
    static inline void ClearLastError() { ::FusionpClearLastWin32Error(); }
};

__declspec(selectany) CGlobalFakeTraceContext g_GlobalFakeTraceContext;

class CFrame : public _TEB_ACTIVE_FRAME_EX
{
    friend bool
    __fastcall
    FusionpGetActiveFrameInfo(
        FRAME_INFO &rFrameInfo
        );

    friend bool
    __fastcall
    FusionpPopulateFrameInfo(
        FRAME_INFO &rFrameInfo,
        PCTEB_ACTIVE_FRAME ptaf
        );

public:
    inline CFrame(const SXS_STATIC_TRACE_CONTEXT &rc)
    {
        this->BasicFrame.Flags = TEB_ACTIVE_FRAME_FLAG_EXTENDED;
        this->BasicFrame.Previous = NULL;
        this->BasicFrame.Context = &rc.m_FrameContext.BasicContext;
        this->ExtensionIdentifier = (PVOID) (' sxS');
        m_nLine = rc.m_StartLine;
    }

    inline void BaseEnter()
    {
#if FUSION_WIN
        ::RtlPushFrame(&this->BasicFrame);
#endif // FUSION_WIN
    };

    inline void SetLine(int nLine) { m_nLine = nLine; }

    inline static void SetLastError(PTEB Teb, DWORD dwLastError) { Teb->LastErrorValue = dwLastError; }
    inline static void SetLastError(DWORD dwLastError) { ::FusionpSetLastWin32Error(dwLastError); }
    inline static DWORD GetLastError() { return ::FusionpGetLastWin32Error(); }
    inline static void ClearLastError() { ::FusionpClearLastWin32Error(); }

    inline void TraceNull(PCSTR pszExpression) const { ::FusionpTraceNull(pszExpression); }
    inline void TraceCOMFailure(HRESULT hrIn, PCSTR pszExpression) const { ::FusionpTraceCOMFailure(hrIn, pszExpression); }

    inline HRESULT ConvertCOMFailure(HRESULT hrIn) { ASSERT_NTC(FAILED(hrIn)); ::FusionpConvertCOMFailure(hrIn); ASSERT_NTC(FAILED(hrIn)); return hrIn; }

    inline ~CFrame()
    {
#if FUSION_WIN
        ::RtlPopFrame(&this->BasicFrame);
#endif
    }

protected:
    int m_nLine;

    const SXS_STATIC_TRACE_CONTEXT *GetTraceContext() const { return reinterpret_cast<const SXS_STATIC_TRACE_CONTEXT *>(BasicFrame.Context); }
    template <typename T> const T *GetTypedTraceContext() const { return static_cast<const T *>(this->GetTraceContext()); }

private:
    CFrame(const CFrame &r); // unimplemented copy constructor
    CFrame &operator =(const CFrame &r); // unimplemented assignment operator
};

class CFnTracer : public CFrame
{
public:
    inline CFnTracer(
        const SXS_STATIC_TRACE_CONTEXT &rsftc,
        BOOL fSmartPerThreadData
    ) : CFrame(rsftc)
    {
    }

    inline void Enter()
    {
        CFrame::BaseEnter();
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallEntry();
    }

    ~CFnTracer()
    {
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallExit();
    }

    void MarkInternalError() { this->SetLastError(ERROR_INTERNAL_ERROR); }
    void MarkAllocationFailed() { this->SetLastError(FUSION_WIN32_ALLOCFAILED_ERROR); }
    void MarkWin32LastErrorFailure() { ASSERT_NTC(this->GetLastError() != ERROR_SUCCESS); }
    void MarkSuccess() { }
    void ReturnValue() const { }

protected:

private:
    CFnTracer(const CFnTracer &r); // intentionally not implemented
    CFnTracer &operator =(const CFnTracer &r); // intentionally not implemented
};

template <typename T> class CFnTracerConstructor : public CFrame
{
public:
    CFnTracerConstructor(
        const SXS_STATIC_TRACE_CONTEXT &rsftc,
        PCSTR szTypeName,
        T *pThis
        ) : CFrame(rsftc),
            m_pThis(pThis),
            m_szTypeName(szTypeName)
    {
    }

    inline void Enter()
    {
        CFrame::BaseEnter();
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallEntry();
    }

    ~CFnTracerConstructor()
    {
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallExit();
    }

protected:
    const PCSTR m_szTypeName;
    T const *m_pThis;

private:
    CFnTracerConstructor &operator=(const CFnTracerConstructor &r); // intentionally not implemented
    CFnTracerConstructor(const CFnTracerConstructor &r); // intentionally not implemented
};

template <typename T> class CFnTracerDestructor : public CFrame
{
public:
    CFnTracerDestructor(
        const SXS_STATIC_TRACE_CONTEXT &rsftc,
        PCSTR szTypeName,
        T *pThis
        ) : CFrame(rsftc),
            m_pThis(pThis),
            m_szTypeName(szTypeName)
    {
    }

    inline void Enter()
    {
        CFrame::BaseEnter();
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallEntry();
    }

    ~CFnTracerDestructor()
    {
        ::FusionpTraceCallExit();
    }

protected:
    const PCSTR m_szTypeName;
    T const *m_pThis;

private:
    CFnTracerDestructor &operator=(const CFnTracerDestructor &r); // intentionally not implemented
    CFnTracerDestructor(const CFnTracerDestructor &r); // intentionally not implemented
};

template <typename T> class CFnTracerAddRef : public CFrame
{
public:
    CFnTracerAddRef(
        const SXS_STATIC_TRACE_CONTEXT &rsftc,
        PCSTR szTypeName,
        T *pThis,
        LONG &rlRefCount
        ) : CFrame(rsftc),
            m_pThis(pThis),
            m_rlRefCount(rlRefCount),
            m_szTypeName(szTypeName)
    {
    }

    CFnTracerAddRef(
        const SXS_STATIC_TRACE_CONTEXT &rsftc,
        PCSTR szTypeName,
        T *pThis,
        ULONG &rlRefCount
        ) : CFrame(rsftc),
            m_pThis(pThis),
            m_rlRefCount(*((LONG *) &rlRefCount)),
            m_szTypeName(szTypeName)
    {
    }


    inline void Enter()
    {
        CFrame::BaseEnter();
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallEntry();
    }

    ~CFnTracerAddRef()
    {
        ::FusionpTraceCallExit();
    }

protected:
    const PCSTR m_szTypeName;
    T const *m_pThis;
    LONG &m_rlRefCount;

private:
    CFnTracerAddRef &operator=(const CFnTracerAddRef &r); // intentionally not implemented
    CFnTracerAddRef(const CFnTracerAddRef &r); // intentionally not implemented
};

template <typename T> class CFnTracerRelease : public CFrame
{
public:
    CFnTracerRelease(
        const SXS_STATIC_RELEASE_TRACE_CONTEXT &rsrtc,
        T *pThis,
        LONG &rlRefCount
        ) : CFrame(rsrtc.m_TraceContext),
            m_pThis(pThis),
            m_rlRefCount(rlRefCount)
    {
    }

    CFnTracerRelease(
        const SXS_STATIC_RELEASE_TRACE_CONTEXT &rsrtc,
        T *pThis,
        ULONG &rlRefCount
        ) : CFrame(rsrtc.m_TraceContext),
            m_pThis(pThis),
            m_rlRefCount(*((LONG *) &rlRefCount))
    {
    }

    inline void Enter()
    {
        CFrame::BaseEnter();
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallEntry();
    }

    ~CFnTracerRelease()
    {
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallExit();
    }

protected:
    T const *m_pThis;
    LONG &m_rlRefCount;

private:
    CFnTracerRelease &operator=(const CFnTracerRelease &r); // intentionally not implemented
    CFnTracerRelease(const CFnTracerRelease &r); // intentionally not implemented
};

class CFnTracerHR : public CFrame
{
public:
    CFnTracerHR(
        const SXS_STATIC_TRACE_CONTEXT &rsftc,
        HRESULT &rhr
        ) : CFrame(rsftc),
        m_rhr(rhr) { }

    inline void Enter()
    {
        CFrame::BaseEnter();
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallEntry();
    }

    ~CFnTracerHR()
    {
        if (g_FusionEnterExitTracingEnabled)
        {
            const DWORD dwLastError = this->GetLastError();

            if (SUCCEEDED(m_rhr))
            {
                ::FusionpTraceCallCOMSuccessfulExit(m_rhr, NULL);
            }
            else
            {
                ::FusionpTraceCallCOMUnsuccessfulExit(m_rhr, NULL);
            }

            this->SetLastError(dwLastError);
        }
    }

    void MarkInternalError() { m_rhr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR); }
    void MarkAllocationFailed() { m_rhr = E_OUTOFMEMORY; }
    void MarkInvalidParameter() { m_rhr = E_INVALIDARG; }
    void MarkWin32LastErrorFailure() { m_rhr = HRESULT_FROM_WIN32(this->GetLastError()); ASSERT_NTC(FAILED(m_rhr)); }
    void MarkWin32Failure(DWORD dwErrorCode) { m_rhr = HRESULT_FROM_WIN32(dwErrorCode); ::FusionpConvertCOMFailure(m_rhr); ASSERT_NTC(FAILED(m_rhr)); }
    void MarkCOMFailure(HRESULT hr) { ASSERT_NTC(FAILED(hr)); ::FusionpConvertCOMFailure(hr); ASSERT_NTC(FAILED(hr)); m_rhr = hr; }
    void MarkSuccess() { m_rhr = NOERROR; }

    HRESULT ReturnValue() const { return m_rhr; }

    HRESULT &m_rhr;
private:
    CFnTracerHR &operator=(const CFnTracerHR &r); // intentionally not implemented
    CFnTracerHR(const CFnTracerHR &r); // intentionally not implemented
};

class CFnTracerWin32 : public CFrame
{
public:
    inline CFnTracerWin32(
        const SXS_STATIC_TRACE_CONTEXT &rsftc,
        BOOL &rfSucceeded
        ) : CFrame(rsftc),
            m_rfSucceeded(rfSucceeded)
    {
    }

    inline void Enter()
    {
        CFrame::BaseEnter();
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallEntry();
    }

    inline ~CFnTracerWin32()
    {
        if (g_FusionEnterExitTracingEnabled)
        {
            if (m_rfSucceeded)
                ::FusionpTraceCallSuccessfulExit(NULL);
            else
            {
                ASSERT_NTC(this->GetLastError() != ERROR_SUCCESS);
                ::FusionpTraceCallWin32UnsuccessfulExit(this->GetLastError(), NULL);
            }
        }
    }

    inline void MarkInternalError() { this->SetLastError(ERROR_INTERNAL_ERROR); m_rfSucceeded = FALSE; }
    inline void MarkAllocationFailed() { this->SetLastError(FUSION_WIN32_ALLOCFAILED_ERROR); m_rfSucceeded = FALSE; }
    inline void MarkInvalidParameter() { this->SetLastError(ERROR_INVALID_PARAMETER); m_rfSucceeded = FALSE; }
    inline void MarkSuccess() { this->SetLastError(ERROR_SUCCESS); m_rfSucceeded = TRUE; }
    inline void MarkWin32LastErrorFailure() { ASSERT_NTC(this->GetLastError() != ERROR_SUCCESS); m_rfSucceeded = FALSE; }
    inline void MarkWin32Failure(DWORD dwErrorCode) { ASSERT_NTC(dwErrorCode != ERROR_SUCCESS); this->SetLastError(dwErrorCode); m_rfSucceeded = FALSE; }
    void MarkCOMFailure(HRESULT hr) { hr = this->ConvertCOMFailure(hr); this->SetLastError(::FusionpHRESULTToWin32(hr)); m_rfSucceeded = FALSE; }

    inline BOOL ReturnValue() const { return m_rfSucceeded; }

    BOOL &m_rfSucceeded;

protected:

private:
    CFnTracerWin32 &operator=(const CFnTracerWin32 &r); // intentionally not implemented
    CFnTracerWin32(const CFnTracerWin32 &r); // intentionally not implemented
};

class CFnTracerReg : public CFrame
{
public:
    inline CFnTracerReg(
        const SXS_STATIC_TRACE_CONTEXT &rsftc,
        LONG &rlError
        ) : CFrame(rsftc),
            m_rlError(rlError)
    {
    }

    inline void Enter()
    {
        CFrame::BaseEnter();
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallEntry();
    }

    ~CFnTracerReg()
    {
        if (g_FusionEnterExitTracingEnabled)
        {
            if (m_rlError == ERROR_SUCCESS)
            {
                ::FusionpTraceCallSuccessfulExit(NULL);
            }
            else
            {
                ::FusionpTraceCallWin32UnsuccessfulExit(m_rlError, NULL);
            }
        }
    }

    void MarkInternalError() { m_rlError = ERROR_INTERNAL_ERROR; }
    void MarkAllocationFailed() { m_rlError = FUSION_WIN32_ALLOCFAILED_ERROR; }
    void MarkInvalidParameter() { m_rlError = ERROR_INVALID_PARAMETER; }
    LONG ReturnValue() const { return m_rlError; }

    LONG &m_rlError;

protected:

private:
    CFnTracerReg &operator=(const CFnTracerReg &r); // intentionally not implemented
    CFnTracerReg(const CFnTracerReg &r); // intentionally not implemented
};

#define FN_TRACE_EX(_stc, _fsmarttlsusage) CFnTracer __t(_stc, (_fsmarttlsusage)); __t.Enter()
#define FN_TRACE_WIN32_EX(_stc, _fsucceeded) CFnTracerWin32 __t(_stc, _fsucceeded); __t.Enter()
#define FN_TRACE_REG_EX(_stc, _lastError) CFnTracerReg __t(_stc, _lastError); __t.Enter()
#define FN_TRACE_HR_EX(_stc, _hr) CFnTracerHR __t(_stc, _hr); __t.Enter()
#define FN_TRACE_CONSTRUCTOR_EX(_stc, _thistype, _this) CFnTracerConstructor<_thistype> __t(_stc, #_thistype, _this); __t.Enter()
#define FN_TRACE_DESTRUCTOR_EX(_stc, _thistype, _this) CFnTracerDestructor<_thistype> __t(_stc, #_thistype, _this); __t.Enter()
#define FN_TRACE_ADDREF_EX(_stc, _thistype, _this, _var) CFnTracerAddRef<_thistype> __t(_stc, #_thistype, (_this), (_var)); __t.Enter()
#define FN_TRACE_RELEASE_EX(_stc, _thistype, _this, _var) CFnTracerRelease<_thistype> __t(_stc, (_this), (_var)); __t.Enter()

#if !defined(FUSION_DEFAULT_FUNCTION_ENTRY_TRACE_LEVEL)
#define FUSION_DEFAULT_FUNCTION_ENTRY_TRACE_LEVEL (FUSION_DBG_LEVEL_ENTEREXIT)
#endif

#if !defined(FUSION_DEFAULT_FUNCTION_SUCCESSFUL_EXIT_TRACE_LEVEL)
#define FUSION_DEFAULT_FUNCTION_SUCCESSFUL_EXIT_TRACE_LEVEL (FUSION_DBG_LEVEL_ENTEREXIT)
#endif

#if !defined(FUSION_DEFAULT_FUNCTION_UNSUCCESSFUL_EXIT_TRACE_LEVEL)
#define FUSION_DEFAULT_FUNCTION_UNSUCCESSFUL_EXIT_TRACE_LEVEL (FUSION_DBG_LEVEL_ENTEREXIT | FUSION_DBG_LEVEL_ERROREXITPATH)
#endif

#if !defined(FUSION_DEFAULT_CONSTRUCTOR_ENTRY_TRACE_LEVEL)
#define FUSION_DEFAULT_CONSTRUCTOR_ENTRY_TRACE_LEVEL (FUSION_DBG_LEVEL_CONSTRUCTORS)
#endif

#if !defined(FUSION_DEFAULT_CONSTRUCTOR_EXIT_TRACE_LEVEL)
#define FUSION_DEFAULT_CONSTRUCTOR_EXIT_TRACE_LEVEL (FUSION_DBG_LEVEL_CONSTRUCTORS)
#endif

#if !defined(FUSION_DEFAULT_DESTRUCTOR_ENTRY_TRACE_LEVEL)
#define FUSION_DEFAULT_DESTRUCTOR_ENTRY_TRACE_LEVEL (FUSION_DBG_LEVEL_DESTRUCTORS)
#endif

#if !defined(FUSION_DEFAULT_DESTRUCTOR_EXIT_TRACE_LEVEL)
#define FUSION_DEFAULT_DESTRUCTOR_EXIT_TRACE_LEVEL (FUSION_DBG_LEVEL_DESTRUCTORS)
#endif

#if !defined(FUSION_DEFAULT_ADDREF_ENTRY_TRACE_LEVEL)
#define FUSION_DEFAULT_ADDREF_ENTRY_TRACE_LEVEL (FUSION_DBG_LEVEL_REFCOUNTING)
#endif

#if !defined(FUSION_DEFAULT_ADDREF_EXIT_TRACE_LEVEL)
#define FUSION_DEFAULT_ADDREF_EXIT_TRACE_LEVEL (FUSION_DBG_LEVEL_REFCOUNTING)
#endif

#if !defined(FUSION_DEFAULT_RELEASE_ENTRY_TRACE_LEVEL)
#define FUSION_DEFAULT_RELEASE_ENTRY_TRACE_LEVEL (FUSION_DBG_LEVEL_REFCOUNTING)
#endif

#if !defined(FUSION_DEFAULT_RELEASE_EXIT_NONZERO_TRACE_LEVEL)
#define FUSION_DEFAULT_RELEASE_NONZERO_EXIT_TRACE_LEVEL (FUSION_DBG_LEVEL_REFCOUNTING)
#endif

#if !defined(FUSION_DEFAULT_RELEASE_EXIT_ZERO_TRACE_LEVEL)
#define FUSION_DEFAULT_RELEASE_ZERO_EXIT_TRACE_LEVEL (FUSION_DBG_LEVEL_REFCOUNTING)
#endif

//
//  #undef and #define FUSION_FACILITY_MASK to any specific additional debug output
//  filtering bits you want to set.
//

#if !defined(FUSION_FACILITY_MASK)
#define FUSION_FACILITY_MASK (0)
#endif // !defined(FUSION_FACILITY_MASK)

#define DEFINE_STATIC_TRACE_CONTEXT() static const SXS_STATIC_TRACE_CONTEXT __stc = { { { TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED, __FUNCTION__ }, __FILE__ }, __LINE__ }

#define DEFINE_STATIC_FN_TRACE_CONTEXT() static const SXS_STATIC_TRACE_CONTEXT __stc = { { { TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED, __FUNCTION__ }, __FILE__ }, __LINE__ }

#define DEFINE_STATIC_CONSTRUCTOR_TRACE_CONTEXT() static const SXS_STATIC_TRACE_CONTEXT __stc = { { { TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED, __FUNCTION__ }, __FILE__ }, __LINE__ }

#define DEFINE_STATIC_DESTRUCTOR_TRACE_CONTEXT() static const SXS_STATIC_TRACE_CONTEXT __stc = { { { TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED, __FUNCTION__ }, __FILE__ }, __LINE__ }

#define DEFINE_STATIC_ADDREF_TRACE_CONTEXT() static const SXS_STATIC_TRACE_CONTEXT __stc = { { { TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED, __FUNCTION__ }, __FILE__ }, __LINE__ }

#define DEFINE_STATIC_RELEASE_TRACE_CONTEXT(_thistype) static const SXS_STATIC_RELEASE_TRACE_CONTEXT __stc = { { { { TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED, __FUNCTION__ }, __FILE__ }, __LINE__ }, #_thistype }

#define DEFINE_STATIC_FN_TRACE_CONTEXT2() static const SXS_STATIC_TRACE_CONTEXT __stc = { { { TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED, __FUNCTION__ }, __FILE__ }, __LINE__ }

#define FN_TRACE() DEFINE_STATIC_FN_TRACE_CONTEXT(); FN_TRACE_EX(__stc, , FALSE)
#define FN_TRACE_SMART_TLS() DEFINE_STATIC_FN_TRACE_CONTEXT(); FN_TRACE_EX(__stc, TRUE)
#define FN_TRACE_WIN32(_fsucceeded) DEFINE_STATIC_FN_TRACE_CONTEXT2(); FN_TRACE_WIN32_EX(__stc, _fsucceeded)
#define FN_TRACE_REG(_lastError) DEFINE_STATIC_FN_TRACE_CONTEXT2(); FN_TRACE_REG_EX(__stc, _lastError)
#define FN_TRACE_HR(_hr) DEFINE_STATIC_FN_TRACE_CONTEXT2(); FN_TRACE_HR_EX(__stc, _hr)
#define FN_TRACE_CONSTRUCTOR(_thistype) DEFINE_STATIC_CONSTRUCTOR_TRACE_CONTEXT(); FN_TRACE_CONSTRUCTOR_EX(__stc, _thistype, this)
#define FN_TRACE_DESTRUCTOR(_thistype) DEFINE_STATIC_DESTRUCTOR_TRACE_CONTEXT(); FN_TRACE_DESTRUCTOR_EX(__stc, _thistype, this)
#define FN_TRACE_ADDREF(_thistype, _var) DEFINE_STATIC_ADDREF_TRACE_CONTEXT(); FN_TRACE_ADDREF_EX(__stc, _thistype, this, _var)
#define FN_TRACE_RELEASE(_thistype, _var) DEFINE_STATIC_RELEASE_TRACE_CONTEXT(_thistype); FN_TRACE_RELEASE_EX(__stc, _thistype, this, _var)

#define FN_PROLOG_VOID FN_TRACE();
#define FN_PROLOG_VOID_TLS FN_TRACE_SMART_TLS();
#define FN_PROLOG_WIN32 BOOL __fSuccess = FALSE; FN_TRACE_WIN32(__fSuccess);
#define FN_PROLOG_HR HRESULT __hr = ~static_cast<HRESULT>(0); FN_TRACE_HR(__hr);

// "if (false) { goto Exit; }" here is probably to quash the compiler's warning about
// Exit not being otherwise used.
#define FN_EPILOG if (false) { goto Exit; } __t.MarkSuccess(); Exit: return __t.ReturnValue();

#define TRACED_RELEASE(_var) __t.Release(_var)

#define FN_TRACE_UPDATE_LINE() do { __t.SetLine(__LINE__); } while (0)

#define FUSION_CLEAR_LAST_ERROR() do { __t.ClearLastError(); } while (0)
#define FUSION_SET_LAST_ERROR(_le) do { __t.SetLastError((_le)); } while (0)

#define FUSION_VERIFY_LAST_ERROR_SET() do { ASSERT(::FusionpGetLastWin32Error() != ERROR_SUCCESS); } while (0)

#define LIST_1(x) { x }
#define LIST_2(x, y) { x , y }
#define LIST_3(x, y, z) { x , y , z }
#define LIST_4(a, b, c, d) { a , b , c , d }
#define LIST_5(a, b, c, d, e) { a , b , c , d, e }

/*
for example:
    ORIGINATE_WIN32_FAILURE_AND_EXIT_EX(dwLastError, ("%s(%ls)", "GetFileAttributesW", lpFileName));
or
    ORIGINATE_WIN32_FAILURE_AND_EXIT_EX(dwLastError, (GetFileAttributesW(%ls)", lpFileName));
*/
#define ORIGINATE_WIN32_FAILURE_AND_EXIT_EX(le_, dbgprint_va_) \
    do { __t.MarkWin32Failure(le_); TRACE_WIN32_FAILURE_ORIGINATION_EX(dbgprint_va_); goto Exit; } while (0)

#define TRACE_WIN32_FAILURE_EX(dbgprint_va_) do { \
    DEFINE_CALL_SITE_INFO_EX(callsite_); callsite_.TraceWin32LastErrorFailureEx dbgprint_va_; } while (0)

#define TRACE_WIN32_FAILURE_ORIGINATION_EX(dbgprint_va_) do { \
    DEFINE_CALL_SITE_INFO_EX(callsite_); callsite_.TraceWin32LastErrorFailureOriginationEx dbgprint_va_; } while (0)

#define ORIGINATE_WIN32_FAILURE_AND_EXIT(_x, _le) do { __t.MarkWin32Failure((_le)); TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } while (0)
#define IFFALSE_ORIGINATE_WIN32_FAILURE_AND_EXIT(_x, _le) do { if (!(_x)) { __t.MarkWin32Failure((_le)); TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } } while (0)

#define IFINVALIDHANDLE_EXIT_WIN32_TRACE(_x) do { FUSION_CLEAR_LAST_ERROR(); if ((_x) == INVALID_HANDLE_VALUE) { FUSION_VERIFY_LAST_ERROR_SET(); TRACE_WIN32_FAILURE(_x); goto Exit; } } while (0)

/*
for example:
    IFW32FALSE_EXIT_EX(f.Win32CreateFile(psz), ("%ls", psz));
*/
#define IFW32FALSE_EXIT_EX(_x, dbgprint_va_) \
    do { FUSION_CLEAR_LAST_ERROR(); \
         if (!(_x)) { FUSION_VERIFY_LAST_ERROR_SET(); \
                      __t.MarkWin32LastErrorFailure(); \
                      DEFINE_CALL_SITE_INFO(__callsite, _x); \
                      __callsite.TraceWin32LastErrorFailureEx dbgprint_va_; \
                      goto Exit; } } while (0)
#define IFW32FALSE_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); if (!(_x)) { FUSION_VERIFY_LAST_ERROR_SET(); __t.MarkWin32LastErrorFailure(); TRACE_WIN32_FAILURE(_x); goto Exit; } } while (0)
#define IFW32FALSE_ORIGINATE_AND_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); if (!(_x)) { FUSION_VERIFY_LAST_ERROR_SET(); __t.MarkWin32LastErrorFailure(); TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } } while (0)

#define IFW32FALSE_EXIT_UNLESS(_x, _unless, _unlessHitFlag) do { FUSION_CLEAR_LAST_ERROR(); (_unlessHitFlag) = false; if (!(_x)) { FUSION_VERIFY_LAST_ERROR_SET(); if (_unless) (_unlessHitFlag) = true; else { TRACE_WIN32_FAILURE(_x); goto Exit; } } } while (0)
#define IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS(_x, _unless, _unlessHitFlag) do { FUSION_CLEAR_LAST_ERROR(); (_unlessHitFlag) = false; if (!(_x)) { FUSION_VERIFY_LAST_ERROR_SET(); if (_unless) (_unlessHitFlag) = true; else { TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } } } while (0)

#define IFW32FALSE_EXIT_UNLESS2(_x, _unless, _unlessHitFlag) do { static const DWORD _s_rgdwAcceptableLastErrorValues[] = _unless; FUSION_CLEAR_LAST_ERROR(); (_unlessHitFlag) = false; if (!(_x)) { ULONG _i; const DWORD _dwLastError = ::FusionpGetLastWin32Error(); FUSION_VERIFY_LAST_ERROR_SET(); for (_i=0; _i<NUMBER_OF(_s_rgdwAcceptableLastErrorValues); _i++) { if (_dwLastError == _s_rgdwAcceptableLastErrorValues[_i]) { (_unlessHitFlag) = true; break; } } if (_i == NUMBER_OF(_s_rgdwAcceptableLastErrorValues)) { TRACE_WIN32_FAILURE(_x); goto Exit; } } } while (0)
#define IFW32FALSE_EXIT_UNLESS3(_x, _unless, _dwLastError) do { static const DWORD _s_rgdwAcceptableLastErrorValues[] = _unless; FUSION_CLEAR_LAST_ERROR(); (_dwLastError) = NO_ERROR; if (!(_x)) { ULONG _i; _dwLastError = ::FusionpGetLastWin32Error(); FUSION_VERIFY_LAST_ERROR_SET(); for (_i=0; _i<NUMBER_OF(_s_rgdwAcceptableLastErrorValues); _i++) { if (_dwLastError == _s_rgdwAcceptableLastErrorValues[_i]) { break; } } if (_i == NUMBER_OF(_s_rgdwAcceptableLastErrorValues)) { TRACE_WIN32_FAILURE(_x); goto Exit; } } } while (0)
#define IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS2(_x, _unless, _unlessHitFlag) do { static const DWORD _s_rgdwAcceptableLastErrorValues[] = _unless; FUSION_CLEAR_LAST_ERROR(); (_unlessHitFlag) = false; if (!(_x)) { ULONG _i; const DWORD _dwLastError = ::FusionpGetLastWin32Error(); FUSION_VERIFY_LAST_ERROR_SET(); for (_i=0; _i<NUMBER_OF(_s_rgdwAcceptableLastErrorValues); _i++) { if (_dwLastError == _s_rgdwAcceptableLastErrorValues[_i]) { (_unlessHitFlag) = true; break; } } if (_i == NUMBER_OF(_s_rgdwAcceptableLastErrorValues)) { TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } } } while (0)
#define IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS3(_x, _unless, _dwLastError) do { static const DWORD _s_rgdwAcceptableLastErrorValues[] = _unless; FUSION_CLEAR_LAST_ERROR(); (_dwLastError) = NO_ERROR; if (!(_x)) { ULONG _i; _dwLastError = ::FusionpGetLastWin32Error(); FUSION_VERIFY_LAST_ERROR_SET(); for (_i=0; _i<NUMBER_OF(_s_rgdwAcceptableLastErrorValues); _i++) { if (_dwLastError == _s_rgdwAcceptableLastErrorValues[_i]) { break; } } if (_i == NUMBER_OF(_s_rgdwAcceptableLastErrorValues)) { TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } } } while (0)

#define IFW32INVALIDHANDLE_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); if ((_x) == INVALID_HANDLE_VALUE) { FUSION_VERIFY_LAST_ERROR_SET(); TRACE_WIN32_FAILURE(_x); goto Exit; } } while (0)
#define IFW32INVALIDHANDLE_ORIGINATE_AND_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); if ((_x) == INVALID_HANDLE_VALUE) { FUSION_VERIFY_LAST_ERROR_SET(); TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } } while (0)

#define IFREGFAILED_EXIT(_x) do { LONG __l; __l = (_x); if (__l != ERROR_SUCCESS) { __t.MarkWin32Failure(__l); FusionpSetLastWin32Error(__l); TRACE_WIN32_FAILURE(_x); goto Exit; } } while (0)
#define IFREGFAILED_ORIGINATE_AND_EXIT(_x) do { LONG __l; __l = (_x); if (__l != ERROR_SUCCESS) { __t.MarkWin32Failure(__l); FusionpSetLastWin32Error(__l); TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } } while (0)

#define IFREGFAILED_EXIT_UNLESS2(_x, _unlessStatuses, _unlessHitFlag) do { LONG _validStatuses[] = _unlessStatuses; LONG __l; (_unlessHitFlag) = false; __l = (_x); if ( __l != ERROR_SUCCESS ) { ULONG i; for ( i = 0; i < NUMBER_OF(_validStatuses); i++ ) if ( _validStatuses[i] == __l ) { (_unlessHitFlag) = true; break; } if (i == NUMBER_OF(_validStatuses)) { FusionpSetLastWin32Error(__l); TRACE_WIN32_FAILURE(_x); goto Exit;}}} while (0)
#define IFREGFAILED_ORIGINATE_AND_EXIT_UNLESS2(_x, _unlessStatuses, _unlessHitFlag) do { LONG _validStatuses[] = _unlessStatuses; LONG __l; (_unlessHitFlag) = false; __l = (_x); if ( __l != ERROR_SUCCESS ) { ULONG i; for ( i = 0; i < NUMBER_OF(_validStatuses); i++ ) if ( _validStatuses[i] == __l ) { (_unlessHitFlag) = true; break; } if (i == NUMBER_OF(_validStatuses)) { FusionpSetLastWin32Error(__l); TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit;}}} while (0)


#define IFCOMFAILED_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); HRESULT __hr = (_x); if (FAILED(__hr)) { TRACE_COM_FAILURE(__hr, _x); __t.MarkCOMFailure(__hr); goto Exit; } } while (0)
#define IFCOMFAILED_ORIGINATE_AND_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); HRESULT __hr = (_x); if (FAILED(__hr)) { TRACE_COM_FAILURE_ORIGINATION(__hr, _x); __t.MarkCOMFailure(__hr); goto Exit; } } while (0)

#define IFFAILED_CONVERTHR_HRTOWIN32_EXIT_TRACE(_x) do { HRESULT __hr = (_x); if (FAILED(__hr)) { FusionpConvertCOMFailure(__hr); TRACE_COM_FAILURE(__hr, _x); FusionpSetLastErrorFromHRESULT(__hr); goto Exit; } } while (0)

#define IFINVALID_FLAGS_EXIT_WIN32_HARD_ASSERT(_f, _fValid) do { HARD_ASSERT(((_f) & ~(_fValid)) == 0); if ((_f) & ~(_fValid)) { TRACE_INVALID_FLAGS(_f, _fValid); ::FusionpSetLastWin32Error(ERROR_INVALID_PARAMETER); goto Exit; } } while (0)
#define IFINVALID_FLAGS_EXIT_WIN32_SOFT_ASSERT(_f, _fValid) do { SOFT_ASSERT(((_f) & ~(_fValid)) == 0); if ((_f) & ~(_fValid)) { TRACE_INVALID_FLAGS(_f, _fValid); ::FusionpSetLastWin32Error(ERROR_INVALID_PARAMETER); goto Exit; } } while (0)
#define IFINVALID_FLAGS_EXIT_COM_HARD_ASSERT(_hr, _f, _fValid) do { HARD_ASSERT(((_f) & ~(_fValid)) == 0); if ((_f) & ~(_fValid)) { TRACE_INVALID_FLAGS(_f, _fValid); _hr = E_INVALIDARG; goto Exit; } } while (0)
#define IFINVALID_FLAGS_EXIT_COM_SOFT_ASSERT(_hr, _f, _fValid) do { SOFT_ASSERT(((_f) & ~(_fValid)) == 0); if ((_f) & ~(_fValid)) { TRACE_INVALID_FLAGS(_f, _fValid); _hr = E_INVALIDARG; goto Exit; } } while (0)

#define IFALLOCFAILED_EXIT(_x) do { if ((_x) == NULL) { TRACE_ALLOCFAILED(_x); __t.MarkAllocationFailed(); goto Exit; } } while (0)

#define IFW32NULL_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); if ((_x) == NULL) { TRACE_WIN32_FAILURE_ORIGINATION(_x); FUSION_VERIFY_LAST_ERROR_SET(); goto Exit; } } while (0)
#define IFW32NULL_ORIGINATE_AND_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); if ((_x) == NULL) { TRACE_WIN32_FAILURE_ORIGINATION(_x); FUSION_VERIFY_LAST_ERROR_SET(); goto Exit; } } while (0)
#define IFW32NULL_ORIGINATE_AND_EXIT_UNLESS2(_x, _unlessStatuses, _unlessHitFlag) do { DWORD __validStatuses[] = _unlessStatuses; _unlessHitFlag = false; FUSION_CLEAR_LAST_ERROR(); if ((_x) == NULL) { const DWORD __dwLastError = ::FusionpGetLastWin32Error(); ULONG __i; for (__i = 0; __i < NUMBER_OF(__validStatuses); __i++ ) if (__validStatuses[__i] == __dwLastError) { (_unlessHitFlag) = true; break; } if (i == NUMBER_OF(__validStatuses)) { TRACE_WIN32_FAILURE_ORIGINATION(_x); FUSION_VERIFY_LAST_ERROR_SET(); goto Exit; } } } while (0)

#define IFW32ZERO_ORIGINATE_AND_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); if ((_x) == 0) { TRACE_WIN32_FAILURE_ORIGINATION(_x); FUSION_VERIFY_LAST_ERROR_SET(); goto Exit; } } while (0)
#define IFW32ZERO_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); if ((_x) == 0) { TRACE_NULL(_x); FUSION_VERIFY_LAST_ERROR_SET(); goto Exit; } } while (0)

#define PARAMETER_CHECK(_e) do { if (!(_e)) { __t.SetLine(__LINE__); TRACE_PARAMETER_CHECK(_e); __t.MarkInvalidParameter(); goto Exit; } } while (0)

#define IFINVALID_FLAGS_EXIT_WIN32(_f, _fValid) IFINVALID_FLAGS_EXIT_WIN32_HARD_ASSERT(_f, _fValid)
#define IFINVALID_FLAGS_EXIT_COM(_hr, _f, _fValid) IFINVALID_FLAGS_EXIT_COM_HARD_ASSERT(_hr, _f, _fValid)

#define FN_SUCCESSFUL_EXIT() do { FUSION_CLEAR_LAST_ERROR(); __t.MarkSuccess(); goto Exit; } while (0)

/*
This is not exposed without doing more work wrt "FusionpDbgWouldPrintAtFilterLevel".
ULONG
FusionpvDbgPrintEx(
    ULONG Level,
    PCSTR Format,
    va_list ap
    );
*/

ULONG
FusionpDbgPrintEx(
    ULONG Level,
    PCSTR Format,
    ...
    );

VOID
FusionpDbgPrintBlob(
    ULONG Level,
    PVOID Data,
    SIZE_T Length,
    PCWSTR PerLinePrefix
    );

void
FusionpGetProcessImageFileName(
    PUNICODE_STRING ProcessImageFileName
    );

#endif // !defined(_FUSION_INC_DEBMACRO_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\disk.h ===
#ifndef _DISK_H_

#define _DISK_H_

BOOL GetDiskInfoA(PSTR pszPath, PDWORD pdwClusterSize, PDWORDLONG pdlAvailable, PDWORDLONG pdlTotal);
#define GetDiskInfo GetDiskInfoA

typedef VOID (WINAPI *PFN)();

BOOL EstablishFunction(PTSTR pszModule, PTSTR pszFunction, PFN* pfn);
HRESULT GetFileSizeRoundedToCluster(HANDLE hFile, PDWORD pdwSizeLow, PDWORD pdwSizeHigh);

HRESULT GetAvailableSpaceOnDisk(PDWORD pdwFree, PDWORD pdwTotal);

#endif // _DISK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\domhelper.h ===
#if !defined(_FUSION_INC_DOMHELPER_H_INCLUDED_)
#define _FUSION_INC_DOMHELPER_H_INCLUDED_

#pragma once

#include "smartref.h"
#include "oleaut_d.h"
#include "fusionparser.h"

//
//  Be sure that you have a symbol named _Module in scope when you #include this header file
//  that has member functions for the OLEAUT32 functions:
//
//      SysAllocString
//      SysFreeString
//      VariantClear
//      VariantInit
//      VariantCopy
//



class CDOMHelper
{
public:
    static HRESULT FindChild(IXMLDOMNode **ppIXMLDOMNode_Out, IXMLDOMNode *pIXMLDOMNode_Root, DOMNodeType ntToMatch, LPCWSTR sz, bool fRecurse = false)
    {
        HRESULT hr = NOERROR;
        CSmartRef<IXMLDOMNode> srpIXMLDOMNode;

        if (ppIXMLDOMNode_Out != NULL)
            *ppIXMLDOMNode_Out = NULL;

        if ((ppIXMLDOMNode_Out == NULL) ||
            (pIXMLDOMNode_Root == NULL))
        {
            hr = E_POINTER;
            goto Exit;
        }

        hr = pIXMLDOMNode_Root->get_firstChild(&srpIXMLDOMNode);
        if (FAILED(hr))
            goto Exit;

        hr = CDOMHelper::FindSibling(ppIXMLDOMNode_Out, srpIXMLDOMNode, ntToMatch, sz, false, fRecurse);
        if (FAILED(hr))
            goto Exit;

        hr = ((*ppIXMLDOMNode_Out) != NULL) ? NOERROR : S_FALSE;

    Exit:
        return hr;
    }

    static HRESULT FindSibling(IXMLDOMNode **ppIXMLDOMNode_Out, IXMLDOMNode *pIXMLDOMNode_Root, DOMNodeType ntToMatch, LPCWSTR sz, bool fSkipCurrent, bool fRecurse = false)
    {
        BSTR bstrName = NULL;
        DOMNodeType nt;
        HRESULT hr = NOERROR;
        CSmartRef<IXMLDOMNode> srpIXMLDOMNode, srpIXMLDOMNode_Next;

        if (ppIXMLDOMNode_Out != NULL)
            *ppIXMLDOMNode_Out = NULL;

        if ((ppIXMLDOMNode_Out == NULL) ||
            (pIXMLDOMNode_Root == NULL))
        {
            hr = E_POINTER;
            goto Exit;
        }

        if (fSkipCurrent)
        {
            hr = pIXMLDOMNode_Root->get_nextSibling(&srpIXMLDOMNode);
            if (FAILED(hr))
                goto Exit;
        }
        else
            srpIXMLDOMNode = pIXMLDOMNode_Root;

        while (srpIXMLDOMNode != NULL)
        {
            hr = srpIXMLDOMNode->get_nodeType(&nt);
            if (FAILED(hr))
                goto Exit;

            if (nt == ntToMatch)
            {
                hr = srpIXMLDOMNode->get_nodeName(&bstrName);
                if (FAILED(hr))
                    goto Exit;

                if (StrCmpIW(bstrName, sz) == 0)
                {
                    *ppIXMLDOMNode_Out = srpIXMLDOMNode.Disown();
                    break;
                }

                _Module.SysFreeString(bstrName);
                bstrName = NULL;

                if (fRecurse)
                {
                    hr = CDOMHelper::FindChild(ppIXMLDOMNode_Out, srpIXMLDOMNode, ntToMatch, sz, fRecurse);
                    if (FAILED(hr))
                        goto Exit;

                    if ((*ppIXMLDOMNode_Out) != NULL)
                        break;
                }
            }

            hr = srpIXMLDOMNode->get_nextSibling(&srpIXMLDOMNode_Next);
            if (FAILED(hr))
                goto Exit;

            if (hr == S_FALSE)
                break;

            srpIXMLDOMNode.Take(srpIXMLDOMNode_Next);
        }

        hr = ((*ppIXMLDOMNode_Out) != NULL) ? NOERROR : S_FALSE;

    Exit:
        if (bstrName != NULL)
            _Module.SysFreeString(bstrName);

        return hr;
    }

    static HRESULT CopyTextNodeValue(IXMLDOMNode *pIXMLDOMNode, LPWSTR sz, ULONG *pcch)
    {
        HRESULT hr = NOERROR;
        VARIANT varTemp;
        ULONG cch;

        varTemp.vt = VT_EMPTY;

        if (pcch == NULL)
        {
            hr = E_POINTER;
            goto Exit;
        }

        hr = pIXMLDOMNode->get_nodeValue(&varTemp);
        if (FAILED(hr))
            goto Exit;

        if (varTemp.vt != VT_BSTR)
        {
            hr = E_FAIL;
            goto Exit;
        }

        cch = ::wcslen(varTemp.bstrVal) + 1;

        if ((*pcch) < cch)
        {
            *pcch = cch;
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        memcpy(sz, varTemp.bstrVal, cch * sizeof(WCHAR));

        hr = NOERROR;

    Exit:
        _Module.VariantClear(&varTemp);
        return hr;
    }

    enum Relationship
    {
        eSibling,
        eChild,
    };

    static HRESULT FollowPath(IXMLDOMNode **ppIXMLDOMNode_Out, IXMLDOMNode *pIXMLDOMNode_Root, ULONG nPathLength, Relationship r, DOMNodeType nt, LPCWSTR sz, ...)
    {
        HRESULT hr = NOERROR;
        va_list ap;
        bool fApInitialized = false;

        if (ppIXMLDOMNode_Out != NULL)
            *ppIXMLDOMNode_Out = NULL;

        if ((ppIXMLDOMNode_Out == NULL) ||
            (pIXMLDOMNode_Root == NULL))
        {
            hr = E_POINTER;
            goto Exit;
        }

        va_start(ap, sz);
        fApInitialized = true;

        hr = CDOMHelper::FollowPathVa(ppIXMLDOMNode_Out, pIXMLDOMNode_Root, nPathLength, r, nt, sz, ap);
        if (FAILED(hr))
            goto Exit;

        hr = NOERROR;

    Exit:
        if (fApInitialized)
            va_end(ap);

        return hr;
    }


    static HRESULT FollowPathVa(IXMLDOMNode **ppIXMLDOMNode_Out, IXMLDOMNode *pIXMLDOMNode_Root, ULONG nPathLength, Relationship r, DOMNodeType nt, LPCWSTR sz, va_list ap)
    {
        HRESULT hr = NOERROR;
        CSmartRef<IXMLDOMNode> srpIXMLDOMNode, srpIXMLDOMNode_Next;
        ULONG i;

        if (ppIXMLDOMNode_Out != NULL)
            *ppIXMLDOMNode_Out = NULL;

        if ((ppIXMLDOMNode_Out == NULL) ||
            (pIXMLDOMNode_Root == NULL))
        {
            hr = E_POINTER;
            goto Exit;
        }

        srpIXMLDOMNode = pIXMLDOMNode_Root;

        for (i=0; i<nPathLength; i++)
        {
            if (r == eChild)
                hr = CDOMHelper::FindChild(&srpIXMLDOMNode_Next, srpIXMLDOMNode, nt, sz);
            else if (r == eSibling)
                hr = CDOMHelper::FindSibling(&srpIXMLDOMNode_Next, srpIXMLDOMNode, nt, sz, false);
            else
            {
                hr = E_INVALIDARG;
                goto Exit;
            }

            if (FAILED(hr))
                goto Exit;

            srpIXMLDOMNode.Take(srpIXMLDOMNode_Next);

            if (hr == S_FALSE)
                break;

            r = va_arg(ap, Relationship);
            nt = va_arg(ap, DOMNodeType);
            sz = va_arg(ap, LPCWSTR);
        }

        *ppIXMLDOMNode_Out = srpIXMLDOMNode.Disown();

        hr = ((*ppIXMLDOMNode_Out) == NULL) ? S_FALSE : NOERROR;

    Exit:
        return hr;
    }

    static HRESULT GetAttributeValue(CBaseStringBuffer &rbuffOut, IXMLDOMNode *pIXMLDOMNode, LPCWSTR szAttributeName)
    {
        HRESULT hr = NOERROR;
        CSmartRef<IXMLDOMElement> srpIXMLDOMElement;
        BSTR bstrName = NULL;
        VARIANT varValue;

        varValue.vt = VT_EMPTY;

        if (pIXMLDOMNode == NULL)
        {
            hr = E_POINTER;
            goto Exit;
        }

        hr = srpIXMLDOMElement.QueryInterfaceFrom(pIXMLDOMNode);
        if (FAILED(hr))
            goto Exit;

        bstrName = _Module.SysAllocString(szAttributeName);
        if (bstrName == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        hr = srpIXMLDOMElement->getAttribute(bstrName, &varValue);
        if (FAILED(hr))
            goto Exit;

        // If the attribute did not exist, return S_FALSE and ensure that the output
        // buffer is a blank string.
        if (hr == S_FALSE)
        {
            rbuffOut.GetBufferPtr()[0] = L'\0';
            goto Exit;
        }

        if (varValue.vt != VT_BSTR)
        {
            hr = E_FAIL;
            goto Exit;
        }

        hr = rbuffOut.Assign(varValue.bstrVal);
        if (FAILED(hr))
            goto Exit;

        hr = NOERROR;
    Exit:
        if (bstrName != NULL)
            _Module.SysFreeString(bstrName);

        _Module.VariantClear(&varValue);

        return hr;
    }

    static HRESULT GetAttributeValue(LPWSTR szOut, ULONG *pcch, IXMLDOMNode *pIXMLDOMNode, LPCWSTR szAttributeName)
    {
        HRESULT hr = NOERROR;
        CSmartRef<IXMLDOMElement> srpIXMLDOMElement;
        BSTR bstrName = NULL;
        VARIANT varValue;
        ULONG cch;

        varValue.vt = VT_EMPTY;

        if (pIXMLDOMNode == NULL)
        {
            hr = E_POINTER;
            goto Exit;
        }

        hr = srpIXMLDOMElement.QueryInterfaceFrom(pIXMLDOMNode);
        if (FAILED(hr))
            goto Exit;

        bstrName = _Module.SysAllocString(szAttributeName);
        if (bstrName == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        hr = srpIXMLDOMElement->getAttribute(bstrName, &varValue);
        if (FAILED(hr))
            goto Exit;

        if (varValue.vt != VT_BSTR)
        {
            hr = E_FAIL;
            goto Exit;
        }

        cch = ::wcslen(varValue.bstrVal) + 1;
        if ((*pcch) < cch)
        {
            *pcch = cch;
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        memcpy(szOut, varValue.bstrVal, cch * sizeof(WCHAR));

        hr = NOERROR;
    Exit:
        if (bstrName != NULL)
            _Module.SysFreeString(bstrName);

        _Module.VariantClear(&varValue);

        return hr;
    }

    static HRESULT GetBooleanAttributeValue(BOOLEAN *pfValue, IXMLDOMNode *pIXMLDOMNode, LPCWSTR szAttributeName, BOOLEAN fDefaultValue)
    {
        HRESULT hr = NOERROR;
        CSmartRef<IXMLDOMElement> srpIXMLDOMElement;
        BSTR bstrName = NULL;
        VARIANT varValue;

        varValue.vt = VT_EMPTY;

        if ((pIXMLDOMNode == NULL) || (pfValue == NULL))
        {
            hr = E_POINTER;
            goto Exit;
        }

        hr = srpIXMLDOMElement.QueryInterfaceFrom(pIXMLDOMNode);
        if (FAILED(hr))
            goto Exit;

        bstrName = _Module.SysAllocString(szAttributeName);
        if (bstrName == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        hr = srpIXMLDOMElement->getAttribute(bstrName, &varValue);
        if (FAILED(hr))
            goto Exit;

        if (hr == S_FALSE)
        {
            *pfValue = fDefaultValue;
            goto Exit;
        }

        if (varValue.vt != VT_BSTR)
        {
            hr = E_FAIL;
            goto Exit;
        }

        hr = CFusionParser::ParseBoolean(*pfValue, varValue.bstrVal, ::wcslen(varValue.bstrVal));
        if (FAILED(hr))
            goto Exit;

        hr = NOERROR;
    Exit:
        if (bstrName != NULL)
            _Module.SysFreeString(bstrName);

        _Module.VariantClear(&varValue);

        return hr;
    }

    static HRESULT GetAttributeValue(CBaseStringBuffer &rbuffOut, IXMLDOMNode *pIXMLDOMNode_Root, LPCWSTR szAttributeName, ULONG nPathLength, Relationship r, DOMNodeType nt, LPCWSTR sz, ...)
    {
        HRESULT hr = NOERROR;
        va_list ap;
        bool fApInitialized = false;
        CSmartRef<IXMLDOMNode> srpIXMLDOMNode;

        if (pIXMLDOMNode_Root == NULL)
        {
            hr = E_POINTER;
            goto Exit;
        }

        va_start(ap, sz);
        fApInitialized = true;

        hr = CDOMHelper::FollowPathVa(&srpIXMLDOMNode, pIXMLDOMNode_Root, nPathLength, r, nt, sz, ap);
        if (FAILED(hr))
            goto Exit;

        hr = CDOMHelper::GetAttributeValue(rbuffOut, srpIXMLDOMNode, szAttributeName);
        if (FAILED(hr))
            goto Exit;

        hr = NOERROR;

    Exit:
        if (fApInitialized)
            va_end(ap);

        return hr;
    }


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\enumbitoperations.h ===
#pragma once

/*-----------------------------------------------------------------------------
This macro generates various bit operations (and, or, etc.) for an enum type.
Copied from \\jayk1\g\vs\src\vsee\lib\TransactionalFileSystem
-----------------------------------------------------------------------------*/
#define ENUM_BIT_OPERATIONS(e) \
    inline e operator|(e x, e y) { return static_cast<e>(static_cast<INT>(x) | static_cast<INT>(y)); } \
    inline e operator&(e x, e y) { return static_cast<e>(static_cast<INT>(x) & static_cast<INT>(y)); } \
    inline void operator&=(e& x, INT y) { x = static_cast<e>(static_cast<INT>(x) & y); } \
    inline void operator&=(e& x, e y) { x &= static_cast<INT>(y); } \
    inline void operator|=(e& x, INT y) { x = static_cast<e>(static_cast<INT>(x) | y); } \
    inline void operator|=(e& x, e y) { x |= static_cast<INT>(y); } \
    /* maybe more in the future */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\crtfree.h ===
//UNUSED

////
//// Code to help free modules from the bondage and tyranny of CRT libraries
////
//// Include this header in a single component and #define DECL_CRTFREE.
//// (CPP_FUNCTIONS is the old name.)
////


//#if defined(__cplusplus) && (defined(CPP_FUNCTIONS) || defined(DECL_CRTFREE))

//#ifndef UNIX
//void *  __cdecl operator new(unsigned int nSize)
//    {
//    // Zero init just to save some headaches
//    return((LPVOID)LocalAlloc(LPTR, nSize));
//    }


//void  __cdecl operator delete(void *pv)
//    {
//    LocalFree((HLOCAL)pv);
//    }
//#endif

//extern "C" int __cdecl _purecall(void)
//    {
//#ifdef ASSERT_MSG
//    ASSERT_MSG(0, "purecall() hit");
//#endif
//    return 0;
//    }

//#endif  // DECL_CRTFREE


//#ifdef __cplusplus
//extern "C" {
//#endif

//#if defined(DEFINE_FLOAT_STUFF)
//// If you aren't using any floating-point CRT functions and you know
//// you aren't performing any float conversions or arithmetic, yet the
//// linker wants these symbols declared, then define DEFINE_FLOAT_STUFF.
////
//// Warning: declaring these symbols in a component that needs floating
//// point support from the CRT will produce undefined results.  (You will
//// need fp support from the CRT if you simply perform fp arithmetic.)

//int _fltused = 0;
//void __cdecl _fpmath(void) { }
//#endif

//#ifdef __cplusplus
//};
//#endif

////
//// This file should be included in a global component header
//// to use the following
////

//#ifndef __CRTFREE_H_
//#define __CRTFREE_H_

//#ifdef __cplusplus

//#ifndef _M_PPC
//#pragma intrinsic(memcpy)
//#pragma intrinsic(memcmp)
//#pragma intrinsic(memset)
//#endif

//#endif

//#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fdi_d.h ===
#ifndef __FDI_D_H_INCLUDED__
#define __FDI_D_H_INCLUDED__

#include "fdi.h"

// FDI.DLL delay-load class

class CFdiDll
{
    public:
#define DELAY_FDI_HFDI(_fn, _args, _nargs) \
    HFDI _fn _args { \
        HRESULT hres = Init(); \
        HFDI hfdi; \
        if (SUCCEEDED(hres)) { \
            hfdi = _pfn##_fn _nargs; \
        } \
        return hfdi;    } \
    HFDI (FAR DIAMONDAPI* _pfn##_fn) _args;

#define DELAY_FDI_BOOL(_fn, _args, _nargs) \
    BOOL _fn _args { \
        HRESULT hres = Init(); \
        BOOL bRet; \
        if (SUCCEEDED(hres)) { \
            bRet = _pfn##_fn _nargs; \
        } \
        return bRet;    } \
    BOOL (FAR DIAMONDAPI* _pfn##_fn) _args;

    HRESULT     Init(void);
    CFdiDll(BOOL fFreeLibrary = TRUE);
    ~CFdiDll();

    BOOL    m_fInited;
    BOOL    m_fFreeLibrary;
    HMODULE m_hMod;

    DELAY_FDI_HFDI(FDICreate,
        (PFNALLOC pfnalloc,
        PFNFREE pfnfree,
        PFNOPEN pfnopen,
        PFNREAD pfnread,
        PFNWRITE pfnwrite,
        PFNCLOSE pfnclose,
        PFNSEEK pfnseek,
        int cpuType,
        PERF perf),
        (pfnalloc, pfnfree, pfnopen, pfnread, pfnwrite, pfnclose, pfnseek, cpuType, perf));

    DELAY_FDI_BOOL(FDICopy,
        (HFDI hfdi,
        char *pszCabinet,
        char *pszCabPath,
        int flags,
        PFNFDINOTIFY pfnfdin,
        PFNFDIDECRYPT pfnfdid,
        void *pvUser),
        (hfdi, pszCabinet, pszCabPath, flags, pfnfdin, pfnfdid, pvUser));

    DELAY_FDI_BOOL(FDIIsCabinet,
        (HFDI hfdi,
        int hf,
        PFDICABINETINFO pfdici),
        (hfdi, hf, pfdici));

    DELAY_FDI_BOOL(FDIDestroy,
        (HFDI hfdi),
        (hfdi));

};

inline CFdiDll::CFdiDll(BOOL fFreeLibrary)
{
    m_fInited = FALSE;
    m_fFreeLibrary = fFreeLibrary;
}

inline CFdiDll::~CFdiDll()
{
    if (m_fInited && m_fFreeLibrary) {
        FreeLibrary(m_hMod);
    }
}

inline HRESULT CFdiDll::Init(void)
{
    if (m_fInited) {
        return S_OK;
    }

    m_hMod = LoadLibrary(TEXT("CABINET.DLL"));

    if (!m_hMod) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

#define CHECKAPI(_fn) \
    *(FARPROC*)&(_pfn##_fn) = GetProcAddress(m_hMod, #_fn); \
    if (!(_pfn##_fn)) return E_UNEXPECTED;

    CHECKAPI(FDICreate);
    CHECKAPI(FDICopy);
    CHECKAPI(FDIIsCabinet);
    CHECKAPI(FDIDestroy);

    m_fInited = TRUE;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionalgorithm.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FusionAlgorithm.h

Abstract:

    Stuff inspired by and copied from <algorithm>.
    See also NVseeLibAlgorithm.
        StdFind
        ReverseFind
        StdSwap

Author:

    Jay M. Krell (a-JayK) May 2000

Revision History:

--*/
#pragma once

/*-----------------------------------------------------------------------------
code based on <algorithm>
-----------------------------------------------------------------------------*/

template<typename InputIterator, typename T>
inline InputIterator
StdFind(
    InputIterator begin,
    InputIterator end,
    const T&      valueToFind
    )
{
    for (; begin != end ; ++begin)
    {
	    if (*begin == valueToFind)
        {
            break;
        }
    }
    return begin;
}

/*-----------------------------------------------------------------------------
This is not in the STL in this form; it is there like so:

    std::vector<T> v;
    T valueToFind;
    i = std::find(v.rbegin(), v.rend(), valueToFind);
    if (i != v.rend())
        ..
where rbegin and rend are implemented via the
supplied "iterator adaptor" std::reverse_iterator<>:

	typedef std::reverse_iterator<const_iterator, value_type,
		const_reference, const_reference *, difference_type>
			const_reverse_iterator;

  	const_reverse_iterator rbegin() const
		{return const_reverse_iterator(end()); }
	const_reverse_iterator rend() const
		{return const_reverse_iterator(begin()); }

It is actually very elegant I believe, but I haven't used it, and we don't
have an equivalent to std::reverse_iterator.
-----------------------------------------------------------------------------*/
/* InputIterator isn't quite the right name here, since we use -- instead of ++. */
template<typename InputIterator, typename T>
inline InputIterator
ReverseFind(
    InputIterator begin,
    InputIterator end,
    const T&      valueToFind
    )
{
    for ( InputIterator scan = end ; scan != begin ; )
    {
	    if (*--scan == valueToFind)
        {
            return scan;
        }
    }
    return end;
}

/*-----------------------------------------------------------------------------
you should specialize this to memberwise swap, doing so
usually makes it impossible for Swap to fail; two CFusionStringBuffers
with the same heap can be swapped with no chance of failure
-----------------------------------------------------------------------------*/
template<typename T>
inline VOID
StdSwap(
    T& x,
    T& y
    )
{
    T temp = x;
    x = y;
    y = temp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionblob.h ===
#if 0
#if !defined(_FUSION_INC_FUSIONBLOB_H_INCLUDED_)
#define _FUSION_INC_FUSIONBLOB_H_INCLUDED_

#pragma once

template <SIZE_T nInlineBytes> class CFusionGenericBLOB : public BLOB
{
public:
    CFusionGenericBLOB() : m_cbBuffer(nInlineBytes)
    {
        pBlobData = m_rgbInlineBuffer;
        cbSize = 0;
    }

    ~CFusionGenericBLOB()
    {
        if (pBlobData != m_rgbInlineBuffer)
        {
            CSxsPreserveLastError ple;
            delete []pBlobData;
            ple.Restore();
        }
    }

    HRESULT Assign(const BLOB &rblob) { return this->Assign(rblob.pBlobData, rblob.cbSize); }
    HRESULT Assign(const BYTE *prgbIn, SIZE_T cbIn)
    {
        if (cbIn > m_cbBuffer)
        {
            BYTE *prgbNew = NEW(BYTE[cbIn]);
            if (prgbNew == NULL) return E_OUTOFMEMORY;
            if (pBlobData != m_rgbInlineBuffer)
                delete []pBlobData;
            pBlobData = prgbNew;
            m_cbBuffer = cbIn;
        }
        memcpy(pBlobData, prgbIn, cbIn);
        cbSize = cbIn;
        return NOERROR;
    }

    HRESULT Append(const BLOB &rblob) { return this->Assign(rblob.pBlobData, rblob.cbSize); }
    HRESULT Append(const BYTE *prgbIn, SIZE_T cbIn)
    {
        SIZE_T cbTotal = cbSize + cbIn;

        if (cbTotal > m_cbBuffer)
        {
            BYTE *prgbNew = NEW(BYTE[cbTotal]);
            if (prgbNew == NULL) return E_OUTOFMEMORY;
            if (pBlobData != m_rgbInlineBuffer)
                delete []pBlobData;
            pBlobData = prgbNew;
            m_cbBuffer = cbTotal;
        }
        memcpy(pBlobData, prgbIn, cbIn);
        cbSize = cbIn;
        return NOERROR;
    }

    HRESULT Clear()
    {
        if (pBlobData != m_rgbInlineBuffer)
        {
            delete []pBlobData;
            pBlobData = m_rgbInlineBuffer;
            m_cbBuffer = nInlineBytes;
        }
        cbSize = 0;

        return NOERROR;
    }

protected:
    BYTE m_rgbInlineBuffer[nInlineBytes];
    ULONG m_cbBuffer;
};

typedef CFusionGenericBLOB<256> CFusionBLOB;

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionarray.h ===
//depot/Lab01_N/base/win32/fusion/inc/fusionarray.h#10 - edit change 14845 (text)
#if !defined(FUSION_FUSIONARRAY_H_INCLUDED_)
#define FUSION_FUSIONARRAY_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//
//  fusionarray.h
//
//  Fusion C++ array class.  Functionally similar to ever other array
//  class out there, but since we do not throw exceptions, instead this
//  implementation does not define all the funky operators and
//  instead defines member functions to access elements of the array
//  which may return HRESULTs.
//

#if !defined(FUSION_UNUSED)
#define FUSION_UNUSED(x) (x)
#endif

#include <arrayhelp.h>
#include "CFusionArrayTypedefs.h"

template <typename TStored, typename TPassed = TStored, bool fExponentialGrowth = false, int nDefaultSize = 0, int nGrowthParam = 1>
class CFusionArray : public CFusionArrayTypedefs<TStored>
{
public:
    ConstIterator Begin() const
    {
        return m_prgtElements;
    }

    ConstIterator End() const
    {
        return m_prgtElements + GetSize();
    }

    Iterator Begin()
    {
        return m_prgtElements;
    }

    Iterator End()
    {
        return m_prgtElements + GetSize();
    }

    template <typename Integer>
    Reference operator[](Integer index)
    {
        return *(Begin() + index);
    }

    template <typename Integer>
    ConstReference operator[](Integer index) const
    {
        return *(Begin() + index);
    }

    CFusionArray() : m_prgtElements(NULL), m_cElements(0), m_iHighWaterMark(0) { }

    ~CFusionArray()
    {
        ::FusionFreeArray(m_cElements, m_prgtElements);
        m_prgtElements = NULL;
        m_cElements = 0;
        m_iHighWaterMark = 0;
    }

    BOOL Win32Initialize(SIZE_T nSize = nDefaultSize)
    {
        FN_PROLOG_WIN32

        INTERNAL_ERROR_CHECK(m_cElements == 0);

        if (nSize != 0)
        {
            IFW32FALSE_EXIT(::FusionWin32ResizeArray( m_prgtElements, m_cElements, nSize));
            m_cElements = nSize;
        }

        FN_EPILOG
    }

    BOOL Win32Access(SIZE_T iElement, TStored *&rptOut, bool fExtendIfNecessary = false)
    {
        FN_PROLOG_WIN32
        rptOut = NULL;

        if ( iElement >= m_cElements )
        {
            PARAMETER_CHECK(fExtendIfNecessary);
        }

        if ( iElement >= m_cElements )
        {
            IFW32FALSE_EXIT(this->Win32InternalExpand(iElement));
        }

        rptOut = &m_prgtElements[iElement];

        if ( iElement >= m_iHighWaterMark )
            m_iHighWaterMark = iElement + 1;
        
        FN_EPILOG
    }

//    HRESULT GetSize(SIZE_T &rcElementsOut) const { rcElementsOut = m_cElements; return NOERROR; }
    SIZE_T GetSize() const { return m_cElements; }

    DWORD GetSizeAsDWORD() const { if (m_cElements > MAXDWORD) return MAXDWORD; return static_cast<DWORD>(m_cElements); }
    ULONG GetSizeAsULONG() const { if (m_cElements > ULONG_MAX) return ULONG_MAX; return static_cast<ULONG>(m_cElements); }

    //
    //  Enumeration used to control the behavior of CFusionArray::SetSize().
    //  if eSetSizeModeExact is passed, the internal array is set to exactly
    //  the cElements passed in; if eSetSizeModeApplyRounding is passed (the
    //  default), we apply the normal expansion/shrinking algorithm for the
    //  array.
    //
    enum SetSizeMode
    {
        eSetSizeModeExact = 0,
        eSetSizeModeApplyRounding = 1,
    };

    //
    //  Member function to manually set the size of the internal array stored
    //  by the CFusionArray.  Default behavior is to find an appropriate rounded
    //  size (based on the exponential vs. linear growth characteristic of the
    //  array) and resize to that.  Alternately, the caller may supply an
    //  exact size and the internal size is set to that.  Note that explicitly
    //  setting the array size may have interesting side-effects on future
    //  growth of the array; for example if an array is set to grow exponentially
    //  at a factor of 2^1 (nGrowthFactor == 1; doubling on each growth pass),
    //  its size will normally be a power of two. However, explicitly setting the
    //  size to, for example, 10 and then trying to access element 11 will cause
    //  the exponential growth factor to grow the array to 20 elements, rather than
    //  a power of two.
    //
    BOOL Win32SetSize(SIZE_T cElements, SetSizeMode ssm = eSetSizeModeApplyRounding)
    {
        FN_PROLOG_WIN32

        if (ssm == eSetSizeModeExact)
        {
            IFW32FALSE_EXIT(::FusionWin32ResizeArray(m_prgtElements, m_cElements, cElements));

            if (cElements < m_iHighWaterMark)
                m_iHighWaterMark = cElements;

            m_cElements = cElements;
        }
        else
        {
            if (cElements > m_cElements)
            {
                IFW32FALSE_EXIT(this->Win32InternalExpand(cElements - 1));
            }
            else
            {
                // For now, since it's inexact, we'll punt non-exact shrinking.
            }
        }

        FN_EPILOG
    }

    const TStored *GetArrayPtr() const { return m_prgtElements; }
    TStored *GetArrayPtr() { return m_prgtElements; }

    //
    //  Member function to reset the array to its size and storage associated with
    //  its initial construction.
    //

    enum ResetMode {
        eResetModeZeroSize = 0,
        eResetModeDefaultSize = 1,
    };

    BOOL Win32Reset( ResetMode rm = eResetModeDefaultSize )
    {
        FN_PROLOG_WIN32

        if ( rm == eResetModeDefaultSize )
        {
            if ( m_cElements != nDefaultSize )
            {
                IFW32FALSE_EXIT(::FusionWin32ResizeArray( m_prgtElements, m_cElements, nDefaultSize ));
                m_cElements = nDefaultSize;
            }
            
            if ( m_iHighWaterMark > nDefaultSize )
                m_iHighWaterMark = nDefaultSize;
        }
        else if ( rm == eResetModeZeroSize )
        {
            ::FusionFreeArray(m_cElements, m_prgtElements);
            m_prgtElements = NULL;
            m_cElements = m_iHighWaterMark = 0;
        }
        
        FN_EPILOG
    }

    enum AppendMode {
        eAppendModeExtendArray = 0,
        eAppendModeNoExtendArray = 1,
    };

    BOOL Win32Append(const TPassed& tNew, AppendMode am = eAppendModeExtendArray)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        ASSERT(m_iHighWaterMark <= m_cElements);

        if (m_iHighWaterMark >= m_cElements)
        {
            PARAMETER_CHECK(am != eAppendModeNoExtendArray);
            SIZE_T cElementsOld = m_cElements;
            IFW32FALSE_EXIT(this->Win32InternalExpand(m_cElements));
            m_iHighWaterMark = cElementsOld;
        }

        // Clients of this class should provide explicit overrides for FusionCopyContents()
        // for their types as appropriate.
        IFW32FALSE_EXIT(::FusionWin32CopyContents(m_prgtElements[m_iHighWaterMark++], tNew));

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Win32Remove(SIZE_T i)
    {
        FN_PROLOG_WIN32

        SIZE_T j;

        PARAMETER_CHECK(i < m_cElements);

        for (j = (i + 1); j < m_cElements; j++)
            IFW32FALSE_EXIT(::FusionWin32CopyContents(m_prgtElements[j-1], m_prgtElements[j]));

        m_cElements--;

        FN_EPILOG
    }

    // 03/14/2001 - Added constness
    BOOL Win32Assign(SIZE_T celt, const TPassed *prgtelt)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        SIZE_T i;

        // So that we can fail gracefully, we need to copy our state off, attempt
        // the population of the array and then revert if necessary.
        TStored *prgtElementsSaved = m_prgtElements;
        SIZE_T cElementsSaved = m_cElements;
        SIZE_T iHighWaterMarkSaved = m_iHighWaterMark;

        m_prgtElements = NULL;
        m_cElements = 0;
        m_iHighWaterMark = 0;

        IFW32FALSE_EXIT(this->Win32Initialize(celt));

        for (i=0; i<celt; i++)
        {
            IFW32FALSE_EXIT(::FusionWin32CopyContents(m_prgtElements[i], prgtelt[i]));
        }

        m_iHighWaterMark = celt;

        // We can drop the old contents...
        ::FusionFreeArray(cElementsSaved, prgtElementsSaved);
        cElementsSaved = 0;
        prgtElementsSaved = NULL;

        fSuccess = TRUE;

    Exit:
        if (!fSuccess)
        {
            // Revert to previous state...
            ::FusionFreeArray(m_cElements, m_prgtElements);
            m_prgtElements = prgtElementsSaved;
            m_cElements = cElementsSaved;
            m_iHighWaterMark = iHighWaterMarkSaved;
        }

        return fSuccess;
    }

    // Xiaoyu 01/24/00 : copy this to prgDest
    //
    // jonwis 20-Sept-2000 : Update to be a little cleaner and 'const'
    //
    BOOL Win32Clone(CFusionArray<TStored, TPassed> &prgDest) const
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        SIZE_T i;

        //
        // Cloning an empty array shouldn't break things.
        //
        if ( m_prgtElements == NULL )
        {
            IFW32FALSE_EXIT(prgDest.Win32Reset(eResetModeZeroSize));
        }
        else
        {

            //
            // Resize the destiny array to what it should be
            //
            if ( prgDest.m_cElements != m_cElements )
                IFW32FALSE_EXIT(::FusionWin32ResizeArray(prgDest.m_prgtElements, prgDest.m_cElements, m_cElements));

            //
            // Copy the elements from point A to point B
            //
            for ( i = 0; i < m_cElements; i++ )
            {
                IFW32FALSE_EXIT(::FusionWin32CopyContents(prgDest.m_prgtElements[i], m_prgtElements[i]));
            }

            prgDest.m_cElements = m_cElements;
            prgDest.m_iHighWaterMark = m_iHighWaterMark;
        }
        
        fSuccess = TRUE;

    Exit:
        if ( !fSuccess )
        {
            prgDest.Win32Reset(eResetModeZeroSize);
        }

        return fSuccess;
    }

protected:

    BOOL Win32InternalExpand(SIZE_T iElement)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        SIZE_T nNewElements = 0;

        if (fExponentialGrowth)
        {
            if (m_cElements == 0)
            {
                if (nDefaultSize == 0)
                    nNewElements = (1 << nGrowthParam);
                else
                    nNewElements = nDefaultSize;
            }
            else
            {
                nNewElements = m_cElements * (1 << nGrowthParam);
            }

            while ((nNewElements != 0) && (nNewElements <= iElement))
                nNewElements = nNewElements << nGrowthParam;

            // Ok, it's possible that nGrowthParam was something crazy like 10
            // (meaning to grow the array by a factor of 2^10 each time), so we
            // never really found a size that was appropriate.  We'll be slightly
            // less crazy and find the power-of-two that's big enough.  We still
            // have a possibility here that the user is asking for an index between
            // 2^31 and ((2^32)-1), which of course will fail because we can't
            // allocate that much storage.

            if (nNewElements == 0)
            {
                nNewElements = 1;

                while ((nNewElements != 0) && (nNewElements <= iElement))
                    nNewElements = nNewElements << 1;
            }
        }
        else
        {
            // In the linear growth case, we can use simple division to do all the
            // work done above for exponential growth.

            nNewElements = iElement + nGrowthParam - 1;

            if (nGrowthParam > 1)
                nNewElements = nNewElements - (nNewElements % nGrowthParam);

            // We'll handle overflow in the generic checking below...
        }

        // fallback; we'll try to make it just big enough.  It's true we lose the
        // growth pattern etc. that the caller requested, but it's pretty clear that
        // the caller messed up by either specifying a wacky nGrowthParam or there's
        // an outlandishly large iElement coming in.
        if (nNewElements <= iElement)
            nNewElements = iElement + 1;

        IFW32FALSE_EXIT(::FusionWin32ResizeArray(m_prgtElements, m_cElements, nNewElements));

        m_cElements = nNewElements;

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    TStored *m_prgtElements;
    SIZE_T m_cElements;
    SIZE_T m_iHighWaterMark;
};


#endif // !defined(FUSION_FUSIONARRAY_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusioncom.h ===
#if !defined(_FUSION_INC_FUSIONCOM_H_INCLUDED_)
#define _FUSION_INC_FUSIONCOM_H_INCLUDED_

#pragma once

#include <stddef.h>
#include <guiddef.h>
#include <basetsd.h>
#include "smartref.h"

//
//  The basic design for this COM support is lifted from ATL.
//
//  ATL's implementation is much more complicated because it tries to
//  support all the sorts of COM objects there may be.  Perhaps over
//  time this COM base stuff will extend as much and we may wish we
//  just used ATL, but for now people feel that ATL is overkill, so
//  rather than implement IUnknown::AddRef() and IUnknown::Release()
//  a thousand times, we'll at least have enough to have a single
//  common implementation.
//


// Turn off the warning about using a typedef name as if it were a class name.
// We tend to do that a lot with CFusionCOMObjectBase (which is really just
// a typedef for a much hairier name...)

#pragma warning(disable: 4097) // use of typedef as class name
#pragma warning(disable: 4505) // dead code warning

// UNUSED macro with local unique name:
#define FUSION_FUSIONCOM_UNUSED(x) (x)

#define FUSION_COM_PACKING 8

#pragma pack(push, FUSION_COM_PACKING)

#define offsetofclass(base, derived) (reinterpret_cast<ULONG_PTR>(static_cast<base*>(reinterpret_cast<derived*>(FUSION_COM_PACKING)))-FUSION_COM_PACKING)

struct CFusionCOMInterfaceMapEntry
{
    const IID *piid;
    DWORD_PTR dwOffset;
    enum
    {
        eSimpleMapEntry,
        eDelegate,
        eEndOfMap,
    } eType;
};

class CFusionCOMCriticalSectionSynchronization
{
public:
    CFusionCOMCriticalSectionSynchronization() : m_fInitialized(false) { }
    ~CFusionCOMCriticalSectionSynchronization() { m_fInitialized = false; }

    static ULONG Increment(ULONG &rul) { return ::InterlockedIncrement((LONG *) &rul); }
    static ULONG Decrement(ULONG &rul) { return ::InterlockedDecrement((LONG *) &rul); }

    HRESULT Initialize(DWORD dwSpinCount = (0x80000000 | 4000))
    {
        HRESULT hr = NOERROR;

        ASSERT(!m_fInitialized);
        if (m_fInitialized)
        {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        if (!::InitializeCriticalSectionAndSpinCount(&m_cs, dwSpinCount))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            goto Exit;
        }

        m_fInitialized = true;

        hr = NOERROR;
    Exit:
        return hr;
    }

    HRESULT Lock()
    {
        HRESULT hr = NOERROR;

        ASSERT(m_fInitialized);
        if (!m_fInitialized)
        {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        ::EnterCriticalSection(&m_cs);

        hr = NOERROR;
    Exit:
        return hr;
    }

    HRESULT Unlock()
    {
        HRESULT hr = NOERROR;

        ASSERT(m_fInitialized);
        if (!m_fInitialized)
        {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        ::LeaveCriticalSection(&m_cs);

        hr = NOERROR;
    Exit:
        return hr;
    }

    HRESULT TryLock(bool &rfLocked)
    {
        HRESULT hr = NOERROR;

        ASSERT(m_fInitialized);
        if (!m_fInitialized)
        {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        rfLocked = (::TryEnterCriticalSection(&m_cs) != 0);
        hr = NOERROR;
    Exit:
        return hr;
    }

private:
    CRITICAL_SECTION m_cs;
    bool m_fInitialized;
};

class CFusionCOMNullSynchronization
{
public:
    CFusionCOMNullSynchronization() : m_fInitialized(false) { }
    ~CFusionCOMNullSynchronization() { m_fInitialized = false; }

    static ULONG Increment(ULONG &rul) { return ++rul; }
    static ULONG Decrement(ULONG &rul) { return --rul; }

    HRESULT Initialize()
    {
        HRESULT hr = NOERROR;

        ASSERT(!m_fInitialized);
        if (m_fInitialized)
        {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        m_fInitialized = true;

        hr = NOERROR;
    Exit:
        return hr;
    }

    HRESULT Lock()
    {
        HRESULT hr = NOERROR;

        ASSERT(m_fInitialized);
        if (!m_fInitialized)
        {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        hr = NOERROR;
    Exit:
        return hr;
    }

    HRESULT Unlock()
    {
        HRESULT hr = NOERROR;

        ASSERT(m_fInitialized);
        if (!m_fInitialized)
        {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        hr = NOERROR;
    Exit:
        return hr;
    }

    HRESULT TryLock(bool &rfLocked)
    {
        HRESULT hr = NOERROR;

        ASSERT(m_fInitialized);
        if (!m_fInitialized)
        {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        rfLocked = true;

        hr = NOERROR;
    Exit:
        return hr;
    }

private:
    bool m_fInitialized;
};

template <typename TSynch = CFusionCOMCriticalSectionSynchronization> class __declspec(novtable) CFusionCOMObjectBaseEx : public IUnknown
{
protected:
    CFusionCOMObjectBaseEx() : m_cRef(0), m_fInFinalRelease(false), m_fFusionCOMObjectBaseExInitialized(false) { }
    virtual ~CFusionCOMObjectBaseEx() { ASSERT(m_cRef == 0); }

    ULONG _InternalAddRef()
    {
        // You really shouldn't be causing new references on this object after its ref
        // count has dropped to zero...
        ASSERT(!m_fInFinalRelease);
        // You shouldn't be adding refs to this object prior to calling the base class's
        // Initialize() function.
        ASSERT(m_fFusionCOMObjectBaseExInitialized);
        return TSynch::Increment(m_cRef);
    }

    ULONG _InternalRelease()
    {
        // You really shouldn't be causing new references on this object after its ref
        // count has dropped to zero...
        ASSERT(!m_fInFinalRelease);
        // You shouldn't be adding (or removing) refs to this object prior to calling the base class's
        // Initialize() function.
        ASSERT(m_fFusionCOMObjectBaseExInitialized);
        return TSynch::Decrement(m_cRef);
    }

    VOID OnFinalRelease() { m_srpIUnknown_FTM.Release(); }

    // Derived classes must call this in order for the critical section/mutex/whatever
    // to be initialized.
    HRESULT Initialize(bool fCreateFTM = true)
    {
        HRESULT hr = NOERROR;

        ASSERT(!m_fFusionCOMObjectBaseExInitialized);
        if (m_fFusionCOMObjectBaseExInitialized)
        {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        hr = m_SynchronizationObject.Initialize();
        if (FAILED(hr))
            goto Exit;

        if (fCreateFTM)
        {
            hr = ::CoCreateFreeThreadedMarshaler(this, &m_srpIUnknown_FTM);
            if (FAILED(hr))
                goto Exit;
        }

        m_fFusionCOMObjectBaseExInitialized = true;

        hr = NOERROR;
    Exit:
        return hr;
    }

    static HRESULT WINAPI InternalQueryInterface(
        void *pThis,
        const CFusionCOMInterfaceMapEntry* pEntries,
        REFIID riid,
        void **ppvObject)
    {
        HRESULT hr = NOERROR;
        IUnknown *pIUnknown = NULL;

        ASSERT(pThis != NULL);

        if (ppvObject != NULL)
            *ppvObject = NULL;

        if (ppvObject == NULL)
        {
            hr = E_POINTER;
            goto Exit;
        }

        while (pEntries->eType != CFusionCOMInterfaceMapEntry::eEndOfMap)
        {
            if ((pEntries->piid == NULL) || ((*(pEntries->piid)) == riid))
            {
                switch (pEntries->eType)
                {
                default:
                    ASSERT(FALSE);
                    hr = E_UNEXPECTED;
                    goto Exit;

                case CFusionCOMInterfaceMapEntry::eDelegate:
                    pIUnknown = *((IUnknown **) (((DWORD_PTR) pThis) + pEntries->dwOffset));
                    if (pIUnknown != NULL)
                    {
                        hr = pIUnknown->QueryInterface(riid, ppvObject);
                        if (FAILED(hr))
                            goto Exit;
                    }

                    break;

                case CFusionCOMInterfaceMapEntry::eSimpleMapEntry:
                    ASSERT(pEntries->eType == CFusionCOMInterfaceMapEntry::eSimpleMapEntry);

                    pIUnknown = (IUnknown *) (((DWORD_PTR) pThis) + pEntries->dwOffset);
                    pIUnknown->AddRef();
                    *ppvObject = pIUnknown;
                    break;

                }

                // If we did find a match, get out of here.  (This may have been
                // a delegation entry that matched, but there was no delegatee in
                // the storage at pEntries->dwOffset, so we skipped it.  This allows
                // a derived class to not create, for example, a free threaded marshaler
                // and have normal marshaling semantics.
                if (pIUnknown != NULL)
                    break;
            }

            pEntries++;
        }

        if (pEntries->eType == CFusionCOMInterfaceMapEntry::eEndOfMap)
        {
            hr = E_NOINTERFACE;
            goto Exit;
        }

        hr = NOERROR;

    Exit:
        return hr;
    }

    ULONG m_cRef;
    TSynch m_SynchronizationObject;
    CSmartRef<IUnknown> m_srpIUnknown_FTM;
    bool m_fInFinalRelease;
    bool m_fFusionCOMObjectBaseExInitialized;
};

typedef CFusionCOMObjectBaseEx<CFusionCOMCriticalSectionSynchronization> CFusionCOMObjectBase;

// Putting the entry macros before the begin/end map macros so that
// we can use the entry macros in the begin/end map macros to
// automatically add entries for IUnknown and IMarshal.
#define FUSION_COM_INTERFACE_ENTRY(x) { &__uuidof(x), offsetofclass(x, _ComMapClass), CFusionCOMInterfaceMapEntry::eSimpleMapEntry },

#define FUSION_COM_INTERFACE_ENTRY2(x, x2) { &__uuidof(x), (DWORD_PTR)((x*)(x2*)((_ComMapClass*)8))-8, CFusionCOMInterfaceMapEntry::eSimpleMapEntry },

#define FUSION_COM_INTERFACE_ENTRY_IID(iid, x) { &(iid), offsetofclass(x, _ComMapClass), CFusionCOMInterfaceMapEntry::eSimpleMapEntry },

#define FUSION_COM_INTERFACE_ENTRY_AGGREGATE(x, punk) \
    {&__uuidof(x),\
    offsetof(_ComMapClass, punk),\
    CFusionCOMInterfaceMapEntry::eDelegate },

#define FUSION_BEGIN_COM_MAP_EX(x, basetype) \
public: \
    virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0; \
    virtual ULONG STDMETHODCALLTYPE Release(void) = 0; \
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID *) = 0; \
    typedef x _ComMapClass; \
    HRESULT _InternalQueryInterface(REFIID riid, void** ppvObject) \
    { \
        return InternalQueryInterface(this, _GetEntries(), riid, ppvObject); \
    } \
    const static CFusionCOMInterfaceMapEntry * WINAPI _GetEntries() \
    { \
        static const CFusionCOMInterfaceMapEntry _entries[] = { \
            FUSION_COM_INTERFACE_ENTRY2(IUnknown, basetype)

#define FUSION_BEGIN_COM_MAP(x) FUSION_BEGIN_COM_MAP_EX(x, CFusionCOMObjectBase)

#define FUSION_END_COM_MAP() \
            FUSION_COM_INTERFACE_ENTRY_AGGREGATE(IMarshal, m_srpIUnknown_FTM.m_pt) \
            { NULL, 0, CFusionCOMInterfaceMapEntry::eEndOfMap} \
        }; \
        return _entries; \
    }

template <typename TBase> class CFusionCOMObject : public TBase
{
public:
    CFusionCOMObject() { }
    virtual ~CFusionCOMObject() { }

    STDMETHODIMP_(ULONG) AddRef() { return this->_InternalAddRef(); }
    STDMETHODIMP_(ULONG) Release()
    {
        ULONG cRef = this->_InternalRelease();
        // If the ref count hits zero, but we were already in final release,
        // we know that the outer Release() will actually do the delete, so
        // we don't have to.
        if ((cRef == 0) && !m_fInFinalRelease)
        {
            m_fInFinalRelease = true;
            this->OnFinalRelease();
            // Make sure that the OnFinalRelease() didn't do something wacky
            // like increment the ref count...
            ASSERT(m_fInFinalRelease);
            ASSERT(m_cRef == 0);
            m_fInFinalRelease = false;
            delete this;
        }
        return cRef;
    }

    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) { return this->_InternalQueryInterface(riid, ppv); }
};

//
//  Use CFusionAutoCOMObject<> to instantiate a CFusionCOMObject-derived instance
//  in automatic (e.g. stack) storage.
//

template <typename TBase> class CFusionAutoCOMObject : public TBase
{
public:
    CFusionAutoCOMObject() { }
    STDMETHODIMP_(ULONG) AddRef() { return this->_InternalAddRef(); }
    STDMETHODIMP_(ULONG) Release() { return this->_InternalRelease(); }
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) { return this->_InternalQueryInterface(riid, ppv); }

    typedef BOOL (CALLBACK * PUMPMESSAGESPROC)(LPVOID pvContext);

    BOOL WaitForZeroRefCount(DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags, PUMPMESSAGESPROC lpMsgPump, LPVOID pvContext)
    {
        FUSION_FUSIONCOM_UNUSED(dwMilliseconds);

        // Anything other than dwMilliseconds == INFINITE is not implemented today...
        ASSERT(dwMilliseconds == INFINITE);
        ASSERT(dwFlags & MWMO_ALERTABLE);

        dwFlags |= MWMO_ALERTABLE;

        while (m_cRef != 0)
        {
            DWORD dwTemp = ::MsgWaitForMultipleObjectsEx(0, NULL, INFINITE, dwWakeMask, dwFlags);
            if (dwTemp == -1)
                return FALSE;

            if (m_cRef == 0)
                break;

            if (dwTemp == WAIT_OBJECT_0)
            {
                BOOL fSucceeded = (*lpMsgPump)(pvContext);
                if (!fSucceeded)
                    return FALSE;
            }
        }

        return TRUE;
    }

    // Use WaitForZeroRefCount() prior to this
    virtual ~CFusionAutoCOMObject()
    {
        ASSERT(!m_fInFinalRelease);
        if (!m_fInFinalRelease)
        {
            m_fInFinalRelease = true;
            this->OnFinalRelease();
            m_fInFinalRelease = false;
        }
        ASSERT(m_cRef == 0);
    }

};


template <typename TEnumInterface, typename TItemInterface> class CFusionCOMIter
{
public:
    CFusionCOMIter() { }
    ~CFusionCOMIter() { }
    CFusionCOMIter(TEnumInterface *pTEnumInterface) { m_srpTEnumInterface = pTEnumInterface; }
    void operator =(TEnumInterface *pTEnumInterface) { m_srpTEnumInterface = pTEnumInterface; m_srpTItemInterface.Release(); }

    TEnumInterface **operator &() { return &m_srpTEnumInterface; }
    TItemInterface *operator ->() const { return m_srpTItemInterface; }
    operator TItemInterface *() const { return m_srpTItemInterface; }

    void Release() { m_srpTEnumInterface.Release(); m_srpTItemInterface.Release(); }

    bool EnumIsNull() const { return m_srpTEnumInterface == NULL; }

    HRESULT Reset()
    {
        HRESULT hr = NOERROR;

        if (m_srpTEnumInterface == NULL)
        {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        hr = m_srpTEnumInterface->Reset();
        if (FAILED(hr))
            goto Exit;

        hr = m_srpTEnumInterface->Next(1, &m_srpTItemInterface, NULL);
        if (FAILED(hr))
            goto Exit;

        hr = NOERROR;
    Exit:
        return hr;
    }

    bool More() const { return (m_srpTItemInterface != NULL); }

    HRESULT Next()
    {
        HRESULT hr = NOERROR;

        if (m_srpTEnumInterface == NULL)
        {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        hr = m_srpTEnumInterface->Next(1, &m_srpTItemInterface, NULL);
        if (FAILED(hr))
            goto Exit;

        hr = NOERROR;
    Exit:
        return hr;
    }

protected:
    CSmartRef<TEnumInterface> m_srpTEnumInterface;
    CSmartRef<TItemInterface> m_srpTItemInterface;
};

template <class TInstance, class TInterface> class CFusionCOMObjectCreator : public CSmartRef<TInterface>
{
public:
    CFusionCOMObjectCreator() : m_ptinstance(NULL), m_fDeleteInstance(false) { }
    ~CFusionCOMObjectCreator() { if (m_fDeleteInstance) { CSxsPreserveLastError ple; delete m_ptinstance; ple.Restore(); } }

    HRESULT CreateInstance()
    {
        if (m_ptinstance != NULL) return E_UNEXPECTED;
        m_ptinstance = NEW(CFusionCOMObject<TInstance>);
        if (m_ptinstance == NULL) return E_OUTOFMEMORY;
        m_fDeleteInstance = true;
        HRESULT hr = m_ptinstance->Initialize();
        if (FAILED(hr)) return hr;
        hr = m_ptinstance->QueryInterface(__uuidof(TInterface), (LPVOID *) &m_pt);
        if (FAILED(hr)) return hr;
        m_fDeleteInstance = false;
        return NOERROR;
    }

    template <typename TArg1> HRESULT CreateInstanceWithArg(TArg1 arg1)
    {
        if (m_ptinstance != NULL) return E_UNEXPECTED;
        m_ptinstance = NEW(CFusionCOMObject<TInstance>);
        if (m_ptinstance == NULL) return E_OUTOFMEMORY;
        m_fDeleteInstance = true;
        HRESULT hr = m_ptinstance->Initialize(arg1);
        if (FAILED(hr)) return hr;
        hr = m_ptinstance->QueryInterface(__uuidof(TInterface), (LPVOID *) &m_pt);
        if (FAILED(hr)) return hr;
        m_fDeleteInstance = false;
        return NOERROR;
    }

    template <typename TArg1, typename TArg2> HRESULT CreateInstanceWith2Args(TArg1 arg1, TArg2 arg2)
    {
        if (m_ptinstance != NULL) return E_UNEXPECTED;
        m_ptinstance = NEW(CFusionCOMObject<TInstance>);
        if (m_ptinstance == NULL) return E_OUTOFMEMORY;
        m_fDeleteInstance = true;
        HRESULT hr = m_ptinstance->Initialize(arg1, arg2);
        if (FAILED(hr)) return hr;
        hr = m_ptinstance->QueryInterface(__uuidof(TInterface), (LPVOID *) &m_pt);
        if (FAILED(hr)) return hr;
        m_fDeleteInstance = false;
        return NOERROR;
    }

    template <typename TArg1, typename TArg2, typename TArg3> HRESULT CreateInstanceWith3Args(TArg1 arg1, TArg2 arg2, TArg3 arg3)
    {
        if (m_ptinstance != NULL) return E_UNEXPECTED;
        m_ptinstance = NEW(CFusionCOMObject<TInstance>);
        if (m_ptinstance == NULL) return E_OUTOFMEMORY;
        m_fDeleteInstance = true;
        HRESULT hr = m_ptinstance->Initialize(arg1, arg2, arg3);
        if (FAILED(hr)) return hr;
        hr = m_ptinstance->QueryInterface(__uuidof(TInterface), (LPVOID *) &m_pt);
        if (FAILED(hr)) return hr;
        m_fDeleteInstance = false;
        return NOERROR;
    }

    template <typename TArg1, typename TArg2, typename TArg3, typename TArg4> HRESULT CreateInstanceWith4Args(TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4)
    {
        if (m_ptinstance != NULL) return E_UNEXPECTED;
        m_ptinstance = NEW(CFusionCOMObject<TInstance>);
        if (m_ptinstance == NULL) return E_OUTOFMEMORY;
        m_fDeleteInstance = true;
        HRESULT hr = m_ptinstance->Initialize(arg1, arg2, arg3, arg4);
        if (FAILED(hr)) return hr;
        hr = m_ptinstance->QueryInterface(__uuidof(TInterface), (LPVOID *) &m_pt);
        if (FAILED(hr)) return hr;
        m_fDeleteInstance = false;
        return NOERROR;
    }

    template <typename TArg1, typename TArg2, typename TArg3, typename TArg4, typename TArg5> HRESULT CreateInstanceWith5Args(TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5)
    {
        if (m_ptinstance != NULL) return E_UNEXPECTED;
        m_ptinstance = NEW(CFusionCOMObject<TInstance>);
        if (m_ptinstance == NULL) return E_OUTOFMEMORY;
        m_fDeleteInstance = true;
        HRESULT hr = m_ptinstance->Initialize(arg1, arg2, arg3, arg4, arg5);
        if (FAILED(hr)) return hr;
        hr = m_ptinstance->QueryInterface(__uuidof(TInterface), (LPVOID *) &m_pt);
        if (FAILED(hr)) return hr;
        m_fDeleteInstance = false;
        return NOERROR;
    }

    // Call this if you need to clear out objects explicitly e.g. before uninitializing COM.
    inline void Release()
    {
        CSxsPreserveLastError ple;

        if (m_fDeleteInstance)
            delete m_ptinstance;
        CSmartRef<TInterface>::Release();
        m_fDeleteInstance = false;
        m_ptinstance = NULL;
        ple.Restore();
    }

    inline TInstance *ObjectPtr() const { return m_ptinstance; }

private:
    CFusionCOMObject<TInstance> *m_ptinstance;
    bool m_fDeleteInstance;
};


#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionbytebuffer.h ===
#if !defined(_FUSION_INC_FUSIONBYTEBUFFER_H_INCLUDED_)
#define _FUSION_INC_FUSIONBYTEBUFFER_H_INCLUDED_

#pragma once

typedef const BYTE *LPCBYTE;
typedef const BYTE *PCBYTE;

class CGenericByteBufferDefaultAllocator
{
public:
    static inline BYTE *Allocate(SIZE_T cb) { return reinterpret_cast<LPBYTE>(::LocalAlloc(LMEM_FIXED, cb)); }
    static inline VOID Deallocate(LPBYTE prgb) { ::LocalFree(prgb); }
};

enum ByteComparisonResult
{
    BCR_LESS_THAN,
    BCR_EQUAL_TO,
    BCR_GREATER_THAN
};

template<SIZE_T nInlineBytes = MAX_PATH, class TAllocator = CGenericByteBufferDefaultAllocator> class CGenericByteBuffer
{
public:
    CGenericByteBuffer() : m_prgbBuffer(m_rgbInlineBuffer), m_cbBuffer(nInlineBytes), m_cb(0) { }

    //
    //  Note that somewhat counter-intuitively, there is neither an assignment operator,
    //  copy constructor or constructor taking a TConstantString.  This is necessary
    //  because such a constructor would need to perform a dynamic allocation
    //  if the path passed in were longer than nInlineBytes which could fail and
    //  since we do not throw exceptions, constructors may not fail.  Instead the caller
    //  must just perform the default construction and then use the Assign() member
    //  function, remembering of course to check its return status.
    //

    ~CGenericByteBuffer()
    {
        if (m_prgbBuffer != m_rgbInlineBuffer)
        {
            TAllocator::Deallocate(m_prgbBuffer);
            m_prgbBuffer = NULL;
        }
    }

    HRESULT Assign(LPCBYTE prgb, SIZE_T cb)
    {
        HRESULT hr = NOERROR;

        // Only force the buffer to be dynamically grown if the new contents do not
        // fit in the old buffer.
        if (cb > m_cbBuffer)
        {
            // Resize the buffer, preserving the old contents in case the copy fails.
            hr = this->ResizeBuffer(cb, true);
            if (FAILED(hr))
                goto Exit;
        }

        // if we have a dynamically allocated buffer and the string fits in the
        // inline buffer, get rid of the dynamically allocated buffer.
        if ((m_prgbBuffer != m_rgbInlineBuffer) && (cb <= nInlineBytes))
        {
            memcpy(m_rgbInlineBuffer, prgb, cb);
            TAllocator::Deallocate(m_prgbBuffer);

            m_prgbBuffer = m_rgbInlineBuffer;
            m_cbBuffer = nInlineBytes;
        }
        else
        {
            memcpy(m_prgbBuffer, prgb, cb);
        }

        hr = NOERROR;

    Exit:
        return hr;
    }

#if defined(_FUSION_INC_FUSIONBLOB_H_INCLUDED_)
    HRESULT Assign(const BLOB &rblob) { return this->Assign(rblob.m_pBlobData, rblob.m_cbData); }
#endif

    HRESULT Append(LPCBYTE prgb, SIZE_T cb)
    {
        HRESULT hr = NOERROR;

        if ((cb + m_cb) > m_cbBuffer)
        {
            hr = this->ResizeBuffer(cb + m_cb, true);
            if (FAILED(hr))
                goto Exit;
        }

        memcpy(&m_prgbBuffer[m_cb], prgb, cb);
        m_cb += cb;

        hr = NOERROR;

    Exit:
        return hr;
    }

#if defined(_FUSION_INC_FUSIONBLOB_H_INCLUDED_)
    HRESULT Append(const BLOB &rblob) { return this->Append(rblob.m_pBlobData, rblob.m_cbData); }
#endif

    HRESULT LeftShift(ULONG cb)
    {
        HRESULT hr = NOERROR;

        if (m_cb < cb)
        {
            hr = E_INVALIDARG;
            goto Exit;
        }

        // Just do the simple memcpy.  Perhaps we should see if can lose the
        // allocated buffer, but we might just need it again soon anyways.
        memcpy(&m_prgbBuffer[0], &m_prgbBuffer[cb], m_cb - cb);
        m_cb -= cb;

        hr = NOERROR;
    Exit:
        return hr;
    }

    HRESULT TakeValue(CGenericByteBuffer<nInlineBytes, TAllocator> &r)
    {
        if (r.m_prgbBuffer == r.m_rgbInlineBuffer)
        {
            // The source has an inline buffer; since we know we're the same type,
            // just copy the bits, free our dynamic buffer if appropriate and
            // go.
            memcpy(m_rgbInlineBuffer, r.m_rgbInlineBuffer, r.m_cb);
            m_cbBuffer = r.m_cbBuffer;
            m_cb = r.m_cb;

            if (m_prgbBuffer != m_rgbInlineBuffer)
            {
                TAllocator::Deallocate(m_prgbBuffer);
                m_prgbBuffer = m_rgbInlineBuffer;
            }
        }
        else
        {
            // If we have a dynamically allocated buffer, free it...
            if (m_prgbBuffer != m_rgbInlineBuffer)
            {
                TAllocator::Deallocate(m_prgbBuffer);
                m_prgbBuffer = NULL;
            }

            // avast ye mateys, we're taking control of yer buffers!
            m_prgbBuffer = r.m_prgbBuffer;
            m_cbBuffer = r.m_cbBuffer;
            m_cb = r.m_cb;

            // Point the other buffer back to its built-in storage...
            r.m_prgbBuffer = r.m_rgbInlineBuffer;
            r.m_cbBuffer = nInlineBytes;
        }

        return NOERROR;
    }

    operator LPCBYTE() const { return m_prgbBuffer; }

    VOID Clear(bool fFreeStorage = false)
    {
        if (fFreeStorage)
        {
            if (m_prgbBuffer != NULL)
            {
                if (m_prgbBuffer != m_rgbInlineBuffer)
                {
                    TAllocator::Deallocate(m_prgbBuffer);
                    m_prgbBuffer = m_rgbInlineBuffer;
                    m_cbBuffer = nInlineBytes;
                }
            }
        }

        m_cb = 0;
    }

    HRESULT Compare(LPCBYTE prgbCandidate, SIZE_T cbCandidate, ByteComparisonResult &rbcrOut)
    {
        SIZE_T cbToCompare = (m_cb < cbCandidate) ? m_cb : cbCandidate;
        int iResult = memcmp(m_prgbBuffer, prgbCandidate, cbToCompare);

        if (iResult < 0)
            rbcrOut = BCS_LESS_THAN;
        else if (iResult > 0)
            rbcrOut = BCS_GREATER_THAN;
        else if (m_cb < cbCandidate)
            rbcrOut = BCS_LESS_THAN;
        else if (m_cb > cbCandidate)
            rbcrOut = BCS_GREATER_THAN;
        else
            rbcrOut = BCS_EQUAL_TO;

        return NOERROR;
    }

    SIZE_T GetBufferCb() const { return m_cbBuffer; }
    SIZE_T GetCurrentCb() const { return m_cb; }

    LPBYTE GetBufferPtr() { return m_prgbBuffer; }

    HRESULT ResizeBuffer(SIZE_T cb, bool fPreserveContents = false)
    {
        HRESULT hr = NOERROR;

        if (cb > m_cbBuffer)
        {
            LPBYTE prgbBufferNew = TAllocator::Allocate(cb);
            if (prgbBufferNew == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            if (fPreserveContents)
                memcpy(prgbBufferNew, m_prgbBuffer, m_cb);
            else
                m_cb = 0;

            if (m_prgbBuffer != m_rgbInlineBuffer)
                TAllocator::Deallocate(m_prgbBuffer);

            m_prgbBuffer = prgbBufferNew;
            m_cbBuffer = cb;
        }
        else if ((m_prgbBuffer != m_rgbInlineBuffer) && (cb <= nInlineBytes))
        {
            // The buffer is small enough to fit into the inline buffer, so get rid of
            // the dynamically allocated one.

            if (fPreserveContents)
            {
                memcpy(m_rgbInlineBuffer, m_prgbBuffer, nInlineBytes);
                m_cb = nInlineBytes;
            }
            else
                m_cb = 0;

            TAllocator::Deallocate(m_prgbBuffer);
            m_prgbBuffer = m_rgbInlineBuffer;
            m_cbBuffer = nInlineBytes;
        }

        hr = NOERROR;

    Exit:
        return hr;
    }

private:
    BYTE m_rgbInlineBuffer[nInlineBytes];
    LPBYTE m_prgbBuffer;
    SIZE_T m_cbBuffer;
    SIZE_T m_cb;
};

// 128 is just an arbitrary size.  The current use of this is to buffer attributes
// streaming in from the service, so 64 seems like as good a guess as any.

typedef CGenericByteBuffer<128> CByteBuffer;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionbuffer.h ===
#if !defined(FUSION_INC_FUSIONBUFFER_H_INCLUDED_)
#define FUSION_INC_FUSIONBUFFER_H_INCLUDED_

#pragma once

#include <stdio.h>
#include <limits.h>
#include "arrayhelp.h"
#include "smartref.h"
#include "ReturnStrategy.h"
#include "FusionString.h"
#include "fusiontrace.h"
#include "fusionchartraits.h"

// avoid circular reference to Util.h
BOOL FusionpIsPathSeparator(WCHAR ch);
BOOL FusionpIsDriveLetter(WCHAR ch);

//
//  This header file defines the Fusion character string buffer class.
//  The purpose of this class is to encapsulate common activities that
//  callers want to do with character string buffers and handle it in
//  a generic fashion.  A principle tenet of this class is that it is
//  not a string class, although one could consider building a string
//  class upon it.
//
//  The buffer maintains a certain amount of storage within the buffer
//  object itself, and if more storage is required, a buffer is
//  dynamically allocated from a heap.
//


//
//  Like the STL string class, we use a helper class called a "character
//  traits" class to provide the actual code to manipulate character string
//  buffers with a specific encoding.
//
//  All the members are inline static and with normal optimization turned
//  on, the C++ compiler generates code that fully meets expectations.
//

//
//  We provide two implementations: one for Unicode strings, and another
//  template class for MBCS strings.  The code page of the string is a
//  template parameter for the MBCS string, so without any extra storage
//  wasted per-instance, code can separately handle MBCS strings which
//  are expected to be in the thread-default windows code page (CP_THREAD_ACP),
//  process-default windows code page (CP_ACP) or even a particular code
//  page (e.g. CP_UTF8).
//


//
//  This template class uses a number of non-type template parameters to
//  control things like growth algorithms etc.  As a result there are
//  many comparisons of template parameters against well-known constant
//  values, for which the compiler generates warning C4127.  We'll turn that
//  warning off.
//

#pragma warning(disable:4127)
#pragma warning(disable:4284)

#if !defined(FUSION_DEFAULT_STRINGBUFFER_CHARS)
#define FUSION_DEFAULT_STRINGBUFFER_CHARS (MAX_PATH)
#endif

#if !defined(FUSION_DEFAULT_TINY_STRINGBUFFER_CHARS)
#define FUSION_DEFAULT_TINY_STRINGBUFFER_CHARS (8)
#endif

#if !defined(FUSION_DEFAULT_SMALL_STRINGBUFFER_CHARS)
#define FUSION_DEFAULT_SMALL_STRINGBUFFER_CHARS (64)
#endif

#if !defined(FUSION_DEFAULT_MEDIUM_STRINGBUFFER_CHARS)
#define FUSION_DEFAULT_MEDIUM_STRINGBUFFER_CHARS (128)
#endif

enum EIfNoExtension
{
    eAddIfNoExtension,
    eDoNothingIfNoExtension,
    eErrorIfNoExtension
};

enum ECaseConversionDirection
{
    eConvertToUpperCase,
    eConvertToLowerCase
};

enum EPreserveContents
{
    ePreserveBufferContents,
    eDoNotPreserveBufferContents
};

template <typename TCharTraits> class CGenericStringBufferAccessor;

template <typename TCharTraits> class CGenericBaseStringBuffer
{
    friend TCharTraits;
    friend CGenericStringBufferAccessor<TCharTraits>;

    //
    // These two are to induce build breaks on people doing sb1 = sb2
    //
    CGenericBaseStringBuffer& operator=(PCWSTR OtherString);
    CGenericBaseStringBuffer& operator=(CGenericBaseStringBuffer &rOtherString);

public:
    typedef TCharTraits::TChar TChar;
    typedef TCharTraits::TMutableString TMutableString;
    typedef TCharTraits::TConstantString TConstantString;
    typedef CGenericStringBufferAccessor<TCharTraits> TAccessor;

    inline static TChar NullCharacter() { return TCharTraits::NullCharacter(); }
    inline static bool IsNullCharacter(TChar ch) { return TCharTraits::IsNullCharacter(ch); }
    inline static TChar PreferredPathSeparator() { return TCharTraits::PreferredPathSeparator(); }
    inline static TConstantString PreferredPathSeparatorString() { return TCharTraits::PreferredPathSeparatorString(); }
    inline static TConstantString PathSeparators() { return TCharTraits::PathSeparators(); }
    inline static bool IsPathSeparator(TChar ch) { return TCharTraits::IsPathSeparator(ch); }
    inline static TConstantString DotString() { return TCharTraits::DotString(); }
    inline static SIZE_T DotStringCch() { return TCharTraits::DotStringCch(); }
    inline static TChar DotChar() { return TCharTraits::DotChar(); }

protected:
    // You may not instantiate an instance of this class directly; you need to provide a derived
    // class which adds allocation/deallocation particulars.

    CGenericBaseStringBuffer() : m_prgchBuffer(NULL), m_cchBuffer(0), m_cAttachedAccessors(0), m_cch(0)
    {
    }

    //
    //  Note that somewhat counter-intuitively, there is neither an assignment operator,
    //  copy constructor or constructor taking a TConstantString.  This is necessary
    //  because such a constructor would need to perform a dynamic allocation
    //  if the path passed in were longer than nInlineChars which could fail and
    //  since we do not throw exceptions, constructors may not fail.  Instead the caller
    //  must just perform the default construction and then use the Assign() member
    //  function, remembering of course to check its return status.
    //

    ~CGenericBaseStringBuffer()
    {
        ASSERT_NTC(m_cAttachedAccessors == 0);
    }

    inline void IntegrityCheck() const
    {
#if DBG
        ASSERT_NTC(m_cch < m_cchBuffer);
#endif // DBG
    }

    // Derived constructors should call this to get the initial buffer pointers set up.
    inline void InitializeInlineBuffer()
    {
        ASSERT_NTC(m_prgchBuffer == NULL);
        ASSERT_NTC(m_cchBuffer == 0);

        m_prgchBuffer = this->GetInlineBuffer();
        m_cchBuffer = this->GetInlineBufferCch();
    }

    VOID AttachAccessor(TAccessor *)
    {
        ::InterlockedIncrement(&m_cAttachedAccessors);
    }

    VOID DetachAccessor(TAccessor *)
    {
        ::InterlockedDecrement(&m_cAttachedAccessors);
    }

    virtual BOOL Win32AllocateBuffer(SIZE_T cch, TMutableString &rpsz) const = 0;
    virtual VOID DeallocateBuffer(TMutableString sz) const = 0;
    virtual TMutableString GetInlineBuffer() const = 0;
    virtual SIZE_T GetInlineBufferCch() const = 0;

public:

    BOOL Win32Assign(PCWSTR psz, SIZE_T cchIn)
    {
        FN_PROLOG_WIN32

        ASSERT(static_cast<SSIZE_T>(cchIn) >= 0);

        this->IntegrityCheck();

        SIZE_T cchIncludingTrailingNull;

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        IFW32FALSE_EXIT(TCharTraits::Win32DetermineRequiredCharacters(psz, cchIn, cchIncludingTrailingNull));

        // Only force the buffer to be dynamically grown if the new contents do not
        // fit in the old buffer.
        if (cchIncludingTrailingNull > m_cchBuffer)
            IFW32FALSE_EXIT(this->Win32ResizeBuffer(cchIncludingTrailingNull, ePreserveBufferContents));

        IFW32FALSE_EXIT(TCharTraits::Win32CopyIntoBuffer(m_prgchBuffer, m_cchBuffer, psz, cchIn));

        ASSERT(cchIncludingTrailingNull <= m_cchBuffer);
        ASSERT((cchIncludingTrailingNull == 0) || this->IsNullCharacter(m_prgchBuffer[cchIncludingTrailingNull - 1]));

        // cch was the buffer size we needed (including the trailing null); we don't need the trailing
        // null any more...
        m_cch = cchIncludingTrailingNull - 1;

        FN_EPILOG
    }

    BOOL Win32Assign(PCSTR psz, SIZE_T cchIn)
    {
        FN_PROLOG_WIN32

        ASSERT(static_cast<SSIZE_T>(cchIn) >= 0);

        this->IntegrityCheck();

        SIZE_T cchIncludingTrailingNull;

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        IFW32FALSE_EXIT(TCharTraits::Win32DetermineRequiredCharacters(psz, cchIn, cchIncludingTrailingNull));

        // Only force the buffer to be dynamically grown if the new contents do not
        // fit in the old buffer.
        if (cchIncludingTrailingNull > m_cchBuffer)
            IFW32FALSE_EXIT(this->Win32ResizeBuffer(cchIncludingTrailingNull, ePreserveBufferContents));

        IFW32FALSE_EXIT(TCharTraits::Win32CopyIntoBuffer(m_prgchBuffer, m_cchBuffer, psz, cchIn));

        ASSERT(cchIncludingTrailingNull <= m_cchBuffer);
        ASSERT((cchIncludingTrailingNull == 0) || this->IsNullCharacter(m_prgchBuffer[cchIncludingTrailingNull - 1]));

        // cch was the buffer size we needed (including the trailing null); we don't need the trailing
        // null any more...
        m_cch = cchIncludingTrailingNull - 1;

        FN_EPILOG
    }

    BOOL Win32Assign(const UNICODE_STRING* NtString)
    {
        return Win32Assign(NtString->Buffer, RTL_STRING_GET_LENGTH_CHARS(NtString));
    }

    BOOL Win32Assign(const ANSI_STRING* NtString)
    {
        return Win32Assign(NtString->Buffer, RTL_STRING_GET_LENGTH_CHARS(NtString));
    }

    BOOL Win32Assign(const CGenericBaseStringBuffer &r) { return this->Win32Assign(r, r.Cch()); }

    BOOL Win32AssignWVa(SIZE_T cStrings, va_list ap)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        TMutableString pszCursor;
        SIZE_T cchIncludingTrailingNull = 1; // leave space for trailing null...
        SIZE_T cchTemp;
        SIZE_T i;
        va_list ap2 = ap;

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        for (i=0; i<cStrings; i++)
        {
            PCWSTR psz = va_arg(ap, PCWSTR);
            INT cchArg = va_arg(ap, INT);
            SIZE_T cchThis = (cchArg < 0) ? ((psz != NULL) ? ::wcslen(psz) : 0) : static_cast<SIZE_T>(cchArg);
            SIZE_T cchRequired;

            IFW32FALSE_EXIT(TCharTraits::Win32DetermineRequiredCharacters(psz, cchThis, cchRequired));

            ASSERT((cchRequired != 0) || (cchThis == 0));

            cchIncludingTrailingNull += (cchRequired - 1);
        }

        IFW32FALSE_EXIT(this->Win32ResizeBuffer(cchIncludingTrailingNull, eDoNotPreserveBufferContents));

        pszCursor = m_prgchBuffer;
        cchTemp = cchIncludingTrailingNull;

        for (i=0; i<cStrings; i++)
        {
            PCWSTR psz = va_arg(ap2, PCWSTR);
            INT cchArg = va_arg(ap2, INT);
            SIZE_T cchThis = (cchArg < 0) ? ((psz != NULL) ? ::wcslen(psz) : 0) : static_cast<SIZE_T>(cchArg);

            IFW32FALSE_EXIT(TCharTraits::Win32CopyIntoBufferAndAdvanceCursor(pszCursor, cchTemp, psz, cchThis));
        }

        *pszCursor++ = this->NullCharacter();

        ASSERT(cchTemp == 1);
        ASSERT(static_cast<SIZE_T>(pszCursor - m_prgchBuffer) == cchIncludingTrailingNull);

        m_cch = (cchIncludingTrailingNull - 1);

        FN_EPILOG
    }

    BOOL Win32AssignW(ULONG cStrings, ...)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        va_list ap;

        va_start(ap, cStrings);

        IFW32FALSE_EXIT(this->Win32AssignWVa(cStrings, ap));

        fSuccess = TRUE;
    Exit:
        va_end(ap);

        return fSuccess;
    }

    BOOL Win32AssignFill(TChar ch, SIZE_T cch)
    {
        FN_PROLOG_WIN32

        TMutableString Cursor;

        ASSERT(static_cast<SSIZE_T>(cch) >= 0);

        IFW32FALSE_EXIT(this->Win32ResizeBuffer(cch + 1, eDoNotPreserveBufferContents));
        Cursor = m_prgchBuffer;

        while (cch > 0)
        {
            *Cursor++ = ch;
            cch--;
        }

        *Cursor = NullCharacter();

        m_cch = (Cursor - m_prgchBuffer);

        FN_EPILOG
    }

    BOOL Win32Append(const UNICODE_STRING *pus) { return this->Win32Append(pus->Buffer, RTL_STRING_GET_LENGTH_CHARS(pus)); }

    BOOL Win32Append(PCWSTR sz, SIZE_T cchIn)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        ASSERT(static_cast<SSIZE_T>(cchIn) >= 0);

        SIZE_T cchIncludingTrailingNull;             // note that cch will include space for a tailing null character

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        IFW32FALSE_EXIT(TCharTraits::Win32DetermineRequiredCharacters(sz, cchIn, cchIncludingTrailingNull));

        // Bypass all this junk if the string to append is empty.
        if (cchIncludingTrailingNull > 1)
        {
            IFW32FALSE_EXIT(this->Win32ResizeBuffer(m_cch + cchIncludingTrailingNull, ePreserveBufferContents));
            IFW32FALSE_EXIT(TCharTraits::Win32CopyIntoBuffer(&m_prgchBuffer[m_cch], m_cchBuffer - m_cch, sz, cchIn));
            m_cch += (cchIncludingTrailingNull - 1);
        }

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Win32Append(PCSTR sz, SIZE_T cchIn)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        ASSERT(static_cast<SSIZE_T>(cchIn) >= 0);

        SIZE_T cchIncludingTrailingNull;

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        IFW32FALSE_EXIT(TCharTraits::Win32DetermineRequiredCharacters(sz, cchIn, cchIncludingTrailingNull));

        // Bypass all this junk if the string to append is empty.
        if (cchIncludingTrailingNull > 1)
        {
            IFW32FALSE_EXIT(this->Win32ResizeBuffer(m_cch + cchIncludingTrailingNull, ePreserveBufferContents));
            IFW32FALSE_EXIT(TCharTraits::Win32CopyIntoBuffer(&m_prgchBuffer[m_cch], m_cchBuffer - m_cch, sz, cchIn));
            m_cch += (cchIncludingTrailingNull - 1);

            this->IntegrityCheck();
        }

        FN_EPILOG
    }

    BOOL Win32Append(const CGenericBaseStringBuffer &r) { return this->Win32Append(r, r.Cch()); }
    BOOL Win32Append(WCHAR wch) { WCHAR rgwch[1] = { wch }; return this->Win32Append(rgwch, 1); }

    BOOL Win32AppendFill(TChar ch, SIZE_T cch)
    {
        FN_PROLOG_WIN32

        ASSERT(static_cast<SSIZE_T>(cch) >= 0);

        TMutableString Cursor;

        IFW32FALSE_EXIT(this->Win32ResizeBuffer(m_cch + cch + 1, ePreserveBufferContents));
        Cursor = m_prgchBuffer + m_cch;

        while (cch > 0)
        {
            *Cursor++ = ch;
            cch--;
        }

        *Cursor = NullCharacter();

        m_cch = Cursor - m_prgchBuffer;

        FN_EPILOG
    }

    BOOL Win32Prepend(const CGenericBaseStringBuffer& other ) { return this->Win32Prepend(other, other.Cch()); }

    BOOL Win32Prepend(TConstantString sz, SIZE_T cchIn)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        ASSERT(static_cast<SSIZE_T>(cchIn) >= 0);

        SIZE_T cchIncludingTrailingNull;             // note that cch will include space for a tailing null character

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        if ( m_cch == 0 )
        {
            IFW32FALSE_EXIT(this->Win32Assign(sz, cchIn));
        }
        else
        {
            //
            // Enlarge the buffer, move the current data to past where the new data will need
            // to go, copy in the new data, and place the trailing null.
            //
            TChar SavedChar = m_prgchBuffer[0];

            IFW32FALSE_EXIT(TCharTraits::Win32DetermineRequiredCharacters(sz, cchIn, cchIncludingTrailingNull));
            IFW32FALSE_EXIT(this->Win32ResizeBuffer(m_cch + cchIncludingTrailingNull, ePreserveBufferContents));
            
            // Move current buffer "up"
            memmove(m_prgchBuffer + ( cchIncludingTrailingNull - 1), m_prgchBuffer, (m_cch + 1) * sizeof(TChar));

            // Copy from the source string into the buffer.
            IFW32FALSE_EXIT(TCharTraits::Win32CopyIntoBuffer(
                this->m_prgchBuffer, 
                this->m_cchBuffer,
                sz,
                cchIn));

            m_prgchBuffer[cchIncludingTrailingNull - 1] = SavedChar;
            m_cch += cchIncludingTrailingNull - 1;
        }
#if 0
        IFW32FALSE_EXIT(TCharTraits::Win32DetermineRequiredCharacters(sz, cchIn, cchIncludingTrailingNull));



        // Bypass all this junk if the string to prepend is empty.
        if (cchIncludingTrailingNull > 1)
        {
            if (m_cch == 0)
            {
                // Empty string, simple operation
                IFW32FALSE_EXIT(this->Win32Assign(sz, cchIn));
            }
            else
            {
                // Otherwise, resize the buffer and 
                // 
                TChar chTemp = m_prgchBuffer[0];
                IFW32FALSE_EXIT(this->Win32ResizeBuffer(m_cch + cchIncludingTrailingNull, ePreserveBufferContents));
                memmove(&m_prgchBuffer[cchIncludingTrailingNull - 1], &m_prgchBuffer[0], (m_cch + 1) * sizeof(TChar));
                IFW32FALSE_EXIT(TCharTraits::Win32CopyIntoBuffer(&m_prgchBuffer[0], m_cchBuffer, sz, cchIn));
                // Restore old first character of the string overwritten by the null
                m_prgchBuffer[cchIncludingTrailingNull - 1] = chTemp;
                m_cch += (cchIncludingTrailingNull - 1);
            }
        }

#endif        
        FN_EPILOG
    }

    BOOL Win32Prepend(TChar ch)
    {
        FN_PROLOG_WIN32

        IFW32FALSE_EXIT(this->Win32ResizeBuffer(m_cch + 1 + 1, ePreserveBufferContents));

        // move buffer ahead, including null
        memmove(m_prgchBuffer + 1, m_prgchBuffer, (m_cch + 1) * sizeof(TChar));
        m_prgchBuffer[0] = ch;
        m_cch++;

        FN_EPILOG
    }

    operator TConstantString() const { this->IntegrityCheck(); return m_prgchBuffer; }

    inline VOID Clear(bool fFreeStorage = false)
    {
        FN_TRACE();

        this->IntegrityCheck();

        // You can't free the storage if there's an attached accessor
        ASSERT(!fFreeStorage || m_cAttachedAccessors == 0);

        if (fFreeStorage && (m_cAttachedAccessors == 0))
        {
            if (m_prgchBuffer != NULL)
            {
                const TMutableString pszInlineBuffer = this->GetInlineBuffer();

                if (m_prgchBuffer != pszInlineBuffer)
                {
                    this->DeallocateBuffer(m_prgchBuffer);
                    m_prgchBuffer = pszInlineBuffer;
                    m_cchBuffer = this->GetInlineBufferCch();
                }
            }
        }

        if (m_prgchBuffer != NULL)
            m_prgchBuffer[0] = this->NullCharacter();

        m_cch = 0;
    }


    BOOL Win32ConvertCase( ECaseConversionDirection direction )
    {
#if !FUSION_WIN
        return FALSE;
#else        
        FN_PROLOG_WIN32

        this->IntegrityCheck();
        
        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        TMutableString Cursor = m_prgchBuffer;

        for ( ULONG ul = 0; ul < this->Cch(); ul++ )
        {
            if ( direction == eConvertToUpperCase )
                *Cursor = RtlUpcaseUnicodeChar(*Cursor);
            else
                *Cursor = RtlDowncaseUnicodeChar(*Cursor);
                
            Cursor++;
        }
        
        FN_EPILOG
#endif
    }

    BOOL Win32Compare(TConstantString szCandidate, SIZE_T cchCandidate, StringComparisonResult &rscrOut, bool fCaseInsensitive) const
    {
        this->IntegrityCheck();
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        IFW32FALSE_EXIT(TCharTraits::Win32CompareStrings(rscrOut, m_prgchBuffer, m_cch, szCandidate, cchCandidate, fCaseInsensitive));
        FN_EPILOG
    }

    BOOL Win32Equals(TConstantString szCandidate, SIZE_T cchCandidate, bool &rfMatches, bool fCaseInsensitive) const
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        IFW32FALSE_EXIT(
            TCharTraits::Win32EqualStrings(
                rfMatches,
                m_prgchBuffer,
                m_cch,
                szCandidate,
                cchCandidate,
                fCaseInsensitive));
        FN_EPILOG
    }

    BOOL Win32Equals(const CGenericBaseStringBuffer &r, bool &rfMatches, bool fCaseInsensitive) const
    {
        return this->Win32Equals(r, r.Cch(), rfMatches, fCaseInsensitive);
    }

    SIZE_T GetBufferCch() const { this->IntegrityCheck(); return m_cchBuffer; }
    INT GetBufferCchAsINT() const { this->IntegrityCheck(); if (m_cchBuffer > INT_MAX) return INT_MAX; return static_cast<INT>(m_cchBuffer); }
    DWORD GetBufferCchAsDWORD() const { this->IntegrityCheck(); if (m_cchBuffer > DWORD_MAX) return DWORD_MAX; return static_cast<DWORD>(m_cchBuffer); }

    SIZE_T GetBufferCb() const { this->IntegrityCheck(); return m_cchBuffer * sizeof(TChar); }
    INT GetBufferCbAsINT() const { this->IntegrityCheck(); if ((m_cchBuffer * sizeof(TChar)) > INT_MAX) return INT_MAX; return static_cast<INT>(m_cchBuffer * sizeof(TChar)); }
    DWORD GetBufferCbAsDWORD() const { this->IntegrityCheck(); if ((m_cchBuffer * sizeof(TChar)) > DWORD_MAX) return DWORD_MAX; return static_cast<DWORD>(m_cchBuffer * sizeof(TChar)); }

    bool ContainsCharacter(WCHAR wch) const
    {
        this->IntegrityCheck();
        return TCharTraits::ContainsCharacter(m_prgchBuffer, m_cch, wch);
    }

    BOOL Win32ResizeBuffer(
        SIZE_T cch,
        EPreserveContents epc
        )
    {
        FN_PROLOG_WIN32

        this->IntegrityCheck();

        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);
        PARAMETER_CHECK((epc == ePreserveBufferContents) || (epc == eDoNotPreserveBufferContents));

        if (cch > m_cchBuffer)
        {
            TMutableString prgchBufferNew = NULL;

            IFW32FALSE_EXIT(this->Win32AllocateBuffer(cch, prgchBufferNew));

            if (epc == ePreserveBufferContents)
            {
                // We assume that the buffer is/was null-terminated.
                IFW32FALSE_EXIT(TCharTraits::Win32CopyIntoBuffer(prgchBufferNew, cch, m_prgchBuffer, m_cch));
            }
            else
            {
                m_prgchBuffer[0] = this->NullCharacter();
                m_cch = 0;
            }

            if ((m_prgchBuffer != NULL) && (m_prgchBuffer != this->GetInlineBuffer()))
                this->DeallocateBuffer(m_prgchBuffer);

            m_prgchBuffer = prgchBufferNew;
            m_cchBuffer = cch;
        }

        FN_EPILOG
    }

    BOOL Win32Format(TConstantString pszFormat, ...)
    {
        this->IntegrityCheck();

        va_list args;
        va_start(args, pszFormat);
        BOOL f = this->Win32FormatV(pszFormat, args);
        va_end(args);
        return f;
    }

    BOOL Win32FormatAppend(TConstantString pszFormat, ...)
    {
        this->IntegrityCheck();

        va_list args;
        va_start(args, pszFormat);
        BOOL f = Win32FormatAppendV(pszFormat, args);
        va_end(args);
        return f;
    }

    BOOL Win32FormatV(TConstantString pszFormat, va_list args)
    {
        BOOL fSuccess = FALSE;
        this->Clear();
        fSuccess = Win32FormatAppendV(pszFormat, args);
        return fSuccess;
    }

    BOOL Win32FormatAppendV(TConstantString pszFormat, va_list args)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        SIZE_T cchRequiredBufferSize = 0;
        INT i = 0;

        this->IntegrityCheck();

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

#if 0 // ntdll.dll dependency
        IFW32FALSE_EXIT(TCharTraits::Win32GetRequiredBufferSizeInCharsForFormatV(pszFormat, args, cchRequiredBufferSize));
        IFW32FALSE_EXIT(this->Win32ResizeBuffer(m_cch + cchRequiredBufferSize + 1, ePreserveBufferContents));
#endif

        m_prgchBuffer[m_cchBuffer - 1] = this->NullCharacter();
        i = TCharTraits::FormatV(m_prgchBuffer + m_cch, m_cchBuffer - 1 - m_cch, pszFormat, args);
        ASSERT(m_prgchBuffer[m_cchBuffer - 1] == NullCharacter());
        fSuccess = (i >= 0);
        if ( fSuccess )
            m_cch += i;
        else
        {
            //
            // Sprintf doesn't touch last error. The fn tracer
            // will fail an assertion if we return false but FusionpGetLastWin32Error()==NOERROR
            //
            ORIGINATE_WIN32_FAILURE_AND_EXIT(snwprintf_MaybeBufferTooSmall, ERROR_INVALID_PARAMETER);
        }
    Exit:
        return fSuccess;
    }

    DWORD GetCchAsDWORD() const
    {
        this->IntegrityCheck();
        if (m_cch > MAXDWORD)
            return MAXDWORD;
        else
            return (DWORD)m_cch;
    }

    SIZE_T Cch() const
    {
        this->IntegrityCheck();
        return m_cch;
    }

    BOOL IsEmpty() const
    {
        this->IntegrityCheck();
        return m_prgchBuffer[0] == 0;
    }

    BOOL Win32EnsureTrailingChar(WCHAR ch)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        if ((m_cch == 0) || (m_prgchBuffer[m_cch - 1] != ch))
        {
            IFW32FALSE_EXIT(this->Win32ResizeBuffer(m_cch + 1 + 1, ePreserveBufferContents));
            m_prgchBuffer[m_cch++] = ch;
            m_prgchBuffer[m_cch] = this->NullCharacter();
        }

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Win32EnsureTrailingPathSeparator()
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        if ((m_cch == 0) || !TCharTraits::IsPathSeparator(m_prgchBuffer[m_cch - 1]))
        {
            IFW32FALSE_EXIT(this->Win32ResizeBuffer(m_cch + 1 + 1, ePreserveBufferContents));
            m_prgchBuffer[m_cch++] = this->PreferredPathSeparator();
            m_prgchBuffer[m_cch] = this->NullCharacter();
        }

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Win32AppendPathElement(PCWSTR pathElement, SIZE_T cchPathElement)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        IFW32FALSE_EXIT(this->Win32EnsureTrailingPathSeparator());
        IFW32FALSE_EXIT(this->Win32Append(pathElement, cchPathElement));

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Win32AppendPathElement(const UNICODE_STRING *pus) { return this->Win32AppendPathElement(pus->Buffer, RTL_STRING_GET_LENGTH_CHARS(pus)); }
    BOOL Win32AppendPathElement(const CGenericBaseStringBuffer &r) { return this->Win32AppendPathElement(r, r.Cch()); }

    BOOL Win32AppendPathElement(PCSTR pathElement, SIZE_T cchPathElement)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        IFW32FALSE_EXIT(this->Win32EnsureTrailingPathSeparator());
        IFW32FALSE_EXIT(this->Win32Append(pathElement, cchPathElement));

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    VOID Left(SIZE_T newLength)
    {
        FN_TRACE();

        this->IntegrityCheck();

        ASSERT(newLength <= m_cch);

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        // Note also that while the current implementation does not change the buffer
        // pointer, this is just a shortcut in the implementation; if a call to Left()
        // were to make the string short enough to fit in the inline buffer, we should
        // copy it to the inline buffer and deallocate the dynamic one.
        ASSERT(m_cAttachedAccessors == 0);

        if (m_cchBuffer > newLength)
        {
            m_prgchBuffer[newLength] = this->NullCharacter();
        }

        m_cch = newLength;
    }

    TConstantString Begin() const
    {
        this->IntegrityCheck();
        return m_prgchBuffer;
    }

    TConstantString End() const
    {
        this->IntegrityCheck();
        return &m_prgchBuffer[m_cch];
    }

    // should factor this for reuse in CchWithoutLastPathElement
    SIZE_T CchWithoutTrailingPathSeparators() const
    {
        this->IntegrityCheck();
        // Until GetLength is constant time, optimize its use..
        SIZE_T length = m_cch;
        if (length > 0)
        {
            length -= ::StringReverseSpan(&*m_prgchBuffer, &*m_prgchBuffer + length, TCharTraits::PathSeparators());
        }
        return length;
    }

    BOOL RestoreNextPathElement()
    {
        SIZE_T index;

        index = m_cch;
        m_prgchBuffer[index++] = L'\\';    // replace trailing NULL with '\'

        while ((index < m_cchBuffer) && (!this->IsNullCharacter(m_prgchBuffer[index])))
        {
            if (::FusionpIsPathSeparator(m_prgchBuffer[index]))
            {
                this->Left(index);
                return TRUE;
            }

            index++;
        }

        return FALSE;
    }

    bool HasTrailingPathSeparator() const
    {
        FN_TRACE();

        this->IntegrityCheck();

        if ((m_cch != 0) && TCharTraits::IsPathSeparator(m_prgchBuffer[m_cch - 1]))
            return true;

        return false;
    }

    VOID RemoveTrailingPathSeparators()
    {
        FN_TRACE();

        this->IntegrityCheck();

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        // Note also that while the current implementation does not change the buffer
        // pointer, this is just a shortcut in the implementation; if a call to Left()
        // were to make the string short enough to fit in the inline buffer, we should
        // copy it to the inline buffer and deallocate the dynamic one.
        ASSERT(m_cAttachedAccessors == 0);

        while ((m_cch != 0) && TCharTraits::IsPathSeparator(m_prgchBuffer[m_cch - 1]))
            m_cch--;

        m_prgchBuffer[m_cch] = this->NullCharacter();
    }

    VOID Right( SIZE_T cchRightCount )
    {
        FN_TRACE();

        this->IntegrityCheck();

        ASSERT(m_cAttachedAccessors == 0);
        ASSERT(cchRightCount <= m_cch);

        if (cchRightCount < m_cch)
        {
            ::memmove(
                m_prgchBuffer,
                &m_prgchBuffer[m_cch - cchRightCount],
                (cchRightCount + 1)*sizeof(TCharTraits::TChar));
            m_cch = cchRightCount;
        }
    }

    VOID RemoveLeadingPathSeparators()
    {
        this->Right(m_cch - wcsspn(m_prgchBuffer, TCharTraits::PathSeparators()));
    }

    BOOL Win32StripToLastPathElement()
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);
        this->Right(m_cch - this->CchWithoutLastPathElement());
        this->RemoveLeadingPathSeparators();
        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Win32GetFirstPathElement( CGenericBaseStringBuffer &sbDestination, BOOL bRemoveAsWell = FALSE )
    {
        FN_PROLOG_WIN32

        this->IntegrityCheck();

        IFW32FALSE_EXIT( sbDestination.Win32Assign( m_prgchBuffer, this->CchOfFirstPathElement() ) );
        sbDestination.RemoveLeadingPathSeparators();

        if ( bRemoveAsWell )
            IFW32FALSE_EXIT(this->Win32RemoveFirstPathElement());

        FN_EPILOG
    }

    BOOL Win32GetFirstPathElement( CGenericBaseStringBuffer &sbDestination ) const
    {
        BOOL bSuccess = FALSE;

        this->IntegrityCheck();

        if ( sbDestination.Win32Assign( m_prgchBuffer, CchOfFirstPathElement() ) )
        {
            sbDestination.RemoveLeadingPathSeparators();
            bSuccess = TRUE;
        }

        return bSuccess;
    }

    BOOL Win32StripToFirstPathElement()
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);
        this->IntegrityCheck();

        this->Left(this->CchOfFirstPathElement());
        this->RemoveLeadingPathSeparators();

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Win32RemoveFirstPathElement()
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        IntegrityCheck();
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        this->Right(this->CchWithoutFirstPathElement());
        this->RemoveLeadingPathSeparators();
        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    SIZE_T CchOfFirstPathElement() const
    {
        return Cch() - CchWithoutFirstPathElement();
    }

    SIZE_T CchWithoutFirstPathElement() const
    {
        this->IntegrityCheck();

        SIZE_T cch = m_cch;

        //
        // We just look for the first path element, which can also be the drive
        // letter!
        //
        if ( cch != 0 )
        {
            cch -= wcscspn( m_prgchBuffer, PathSeparators() );
        }

        return cch;
    }

    BOOL Win32GetLastPathElement(CGenericBaseStringBuffer &sbDestination) const
    {
        BOOL bSuccess = FALSE;
        FN_TRACE_WIN32(bSuccess);
        this->IntegrityCheck();
        IFW32FALSE_EXIT(sbDestination.Win32Assign(m_prgchBuffer, m_cch));
        IFW32FALSE_EXIT(sbDestination.Win32StripToLastPathElement());
        bSuccess = TRUE;
    Exit:
        return bSuccess;
    }

    SIZE_T CchWithoutLastPathElement() const
    {
        this->IntegrityCheck();

        // Paths are assumed to be
        // "\\machine\share"
        // or
        // "x:\"
        // Worry about alternate NTFS streams at a later date.
        // Worry about NT paths at a later date.
        // Worry about URLs at a later date.
        const SIZE_T length = m_cch;
        SIZE_T newLength = length;
        if (length > 0)
        {
            if ((length == 3) &&
                (m_prgchBuffer[1] == ':') &&
                ::FusionpIsPathSeparator(m_prgchBuffer[2]) &&
                ::FusionpIsDriveLetter(m_prgchBuffer[0]))
            {
                // c:\ => empty string
                newLength = 0;
            }
            else
            {
                // Remove trailing path seperators here, in the future when it is not risky.
                //newLength -= ::StringReverseSpan(&*m_prgchBuffer, &*m_prgchBuffer + newLength, PathSeparators());
                newLength -= ::StringReverseComplementSpan(&*m_prgchBuffer, &*m_prgchBuffer + newLength, PathSeparators());
                newLength -= ::StringReverseSpan(&*m_prgchBuffer, &*m_prgchBuffer + newLength, PathSeparators());
                if ((newLength == 2) && // "c:"
                    (length >= 4) && // "c:\d"
                    (m_prgchBuffer[1] == ':') &&
                    ::FusionpIsPathSeparator(m_prgchBuffer[2]) &&
                    ::FusionpIsDriveLetter(m_prgchBuffer[0]))
                {
                    ++newLength; // put back the slash in "c:\"
                }
            }
        }
        return newLength;
    }

    VOID RemoveLastPathElement()
    {
        FN_TRACE();

        this->IntegrityCheck();

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        // Note also that while the current implementation does not change the buffer
        // pointer, this is just a shortcut in the implementation; if a call to Left()
        // were to make the string short enough to fit in the inline buffer, we should
        // copy it to the inline buffer and deallocate the dynamic one.
        ASSERT(m_cAttachedAccessors == 0);

        this->Left(this->CchWithoutLastPathElement());
    }

    BOOL Win32ClearPathExtension()
    {
        //
        // Replace the final '.' with a \0 to clear the path extension
        //
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32( fSuccess );

        IntegrityCheck();

        TMutableString dot;

        const TMutableString end = End();

        IFW32FALSE_EXIT(TCharTraits::Win32ReverseFind(dot, m_prgchBuffer, m_cch, this->DotChar(), false));

        if((dot != end) && (dot != NULL))
        {
            *dot = this->NullCharacter();
            m_cch = (dot - m_prgchBuffer);
        }

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Win32GetPathExtension(CGenericBaseStringBuffer<TCharTraits> &destination) const
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        SIZE_T cchExtension;

        const TConstantString start = Begin();
        const TConstantString end = End();

        cchExtension = StringReverseComplementSpan( &(*start), &(*end), L"." );
        IFW32FALSE_EXIT(destination.Win32Assign( static_cast<PCWSTR>(*this) + ( m_cch - cchExtension ), cchExtension));

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    // newExtension can start with a dot or not
    BOOL Win32ChangePathExtension(PCWSTR newExtension, SIZE_T cchExtension, EIfNoExtension e)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        TMutableString end;
        TMutableString dot;

        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        PARAMETER_CHECK((e == eAddIfNoExtension) ||
                              (e == eDoNothingIfNoExtension) ||
                              (e == eErrorIfNoExtension));

        if ((cchExtension != 0) && (newExtension[0] == L'.'))
        {
            cchExtension--;
            newExtension++;
        }

        // the use of append when we know where the end of the string is inefficient
        end = this->End();

        IFW32FALSE_EXIT(TCharTraits::Win32ReverseFind(dot, m_prgchBuffer, m_cch, this->DotChar(), false));

        // Found the end of the string, or Win32ReverseFind didn't find the dot anywhere...
        if ((dot == end) || (dot == NULL))
        {
            switch (e)
            {
                case eAddIfNoExtension:
                    IFW32FALSE_EXIT(this->Win32Append(this->DotString(), 1));
                    IFW32FALSE_EXIT(this->Win32Append(newExtension, cchExtension));
                    break;

                case eDoNothingIfNoExtension:
                    break;

                case eErrorIfNoExtension:
					ORIGINATE_WIN32_FAILURE_AND_EXIT(MissingExtension, ERROR_BAD_PATHNAME);
            }
        }
        else
        {
            ++dot;
            this->Left(dot - this->Begin());
            IFW32FALSE_EXIT(this->Win32Append(newExtension, cchExtension));
        }

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Win32CopyStringOut(LPWSTR sz, ULONG *pcch)
    {
        FN_PROLOG_WIN32

        this->IntegrityCheck();

        SIZE_T cwchRequired;

        PARAMETER_CHECK(pcch != NULL);

        IFW32FALSE_EXIT(TCharTraits::Win32DetermineRequiredCharacters(m_prgchBuffer, m_cch, cwchRequired));

        if ((*pcch) < cwchRequired)
        {
            *pcch = static_cast<DWORD>(cwchRequired);
            ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);
        }

        IFW32FALSE_EXIT(TCharTraits::Win32CopyIntoBuffer(sz, *pcch, m_prgchBuffer, m_cch));

        FN_EPILOG
    }

    //
    //  This function is rather special purpose in that several design choices are not
    //  implemented as parameters.  In particular, the pcbBytesWritten is assumed to
    //  accumulate a number (thus it's updated by adding the number of bytes written to
    //  it rather than just setting it to the count of bytes written).
    //
    //  It also writes 0 bytes into the buffer is the string is zero length; if the string
    //  is not zero length, it writes the string including a trailing null.
    //

    inline BOOL Win32CopyIntoBuffer(
        PWSTR *ppszCursor,
        SIZE_T *pcbBuffer,
        SIZE_T *pcbBytesWritten,
        PVOID pvBase,
        ULONG *pulOffset,
        ULONG *pulLength
        ) const
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        PWSTR pszCursor;
        SSIZE_T dptr;
        SIZE_T cbRequired;
        SIZE_T cch;

        if (pulOffset != NULL)
            *pulOffset = 0;

        if (pulLength != NULL)
            *pulLength = 0;

        PARAMETER_CHECK(pcbBuffer != NULL);
        PARAMETER_CHECK(ppszCursor != NULL);

        pszCursor = *ppszCursor;
        dptr = ((SSIZE_T) pszCursor) - ((SSIZE_T) pvBase);

        // If they're asking for an offset or length and the cursor is too far from the base,
        // fail.
        PARAMETER_CHECK((pulOffset == NULL) || (dptr <= ULONG_MAX));

        cch = m_cch;

        cbRequired = (cch != 0) ? ((cch + 1) * sizeof(WCHAR)) : 0;

        if ((*pcbBuffer) < cbRequired)
        {
            ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        if (cbRequired > ULONG_MAX)
        {
            ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        memcpy(pszCursor, static_cast<PCWSTR>(*this), cbRequired);

        if (pulOffset != NULL)
        {
            if (cbRequired != 0)
                *pulOffset = (ULONG) dptr;
        }

        if (pulLength != NULL)
        {
            if (cbRequired == 0)
                *pulLength = 0;
            else
            {
                *pulLength = (ULONG) (cbRequired - sizeof(WCHAR));
            }
        }

        *pcbBytesWritten += cbRequired;
        *pcbBuffer -= cbRequired;

        *ppszCursor = (PWSTR) (((ULONG_PTR) pszCursor) + cbRequired);

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

protected:
    TMutableString Begin()
    {
        this->IntegrityCheck();
        /* CopyBeforeWrite() */
        return m_prgchBuffer;
    }

    TMutableString End()
    {
        this->IntegrityCheck();
        return &m_prgchBuffer[m_cch];
    }

    LONG m_cAttachedAccessors;
    TChar *m_prgchBuffer;
    SIZE_T m_cchBuffer;
    SIZE_T m_cch; // current length of string
};

template <typename TCharTraits> class CGenericStringBufferAccessor
{
public:
    typedef CGenericBaseStringBuffer<TCharTraits> TBuffer;
    typedef CGenericBaseStringBuffer<TCharTraits>::TChar TChar;

    CGenericStringBufferAccessor(TBuffer* pBuffer = NULL)
    : m_pBuffer(NULL),
      m_pszBuffer(NULL),
      m_cchBuffer(NULL)
    {
        if (pBuffer != NULL)
        {
            Attach(pBuffer);
        }
    }

    ~CGenericStringBufferAccessor()
    {
        if (m_pBuffer != NULL)
        {
            m_pBuffer->m_cch = TCharTraits::NullTerminatedStringLength(m_pszBuffer);
            m_pBuffer->DetachAccessor(this);
            m_pBuffer = NULL;
            m_pszBuffer = NULL;
            m_cchBuffer = 0;
        }
    }

    bool IsAttached() const
    {
        return (m_pBuffer != NULL);
    }

    static TChar NullCharacter() { return TCharTraits::NullCharacter(); }

    void Attach(TBuffer *pBuffer)
    {
        FN_TRACE();

        ASSERT(!IsAttached());

        if (!IsAttached())
        {
            pBuffer->AttachAccessor(this);

            m_pBuffer = pBuffer;
            m_pszBuffer = m_pBuffer->m_prgchBuffer;
            m_cchBuffer = m_pBuffer->m_cchBuffer;
        }
    }

    void Detach()
    {
        FN_TRACE();

        ASSERT (IsAttached());

        if (IsAttached())
        {
            ASSERT(m_pszBuffer == m_pBuffer->m_prgchBuffer);

            m_pBuffer->m_cch = TCharTraits::NullTerminatedStringLength(m_pszBuffer);
            m_pBuffer->DetachAccessor(this);

            m_pBuffer = NULL;
            m_pszBuffer = NULL;
            m_cchBuffer = 0;
        }
        else
        {
            ASSERT(m_pszBuffer == NULL);
            ASSERT(m_cchBuffer == 0);
        }
    }

    operator TCharTraits::TMutableString() const { ASSERT_NTC(this->IsAttached()); return m_pszBuffer; }

    SIZE_T Cch() const { ASSERT_NTC(this->IsAttached()); return (m_pszBuffer != NULL) ? ::wcslen(m_pszBuffer) : 0; }

    TCharTraits::TMutableString GetBufferPtr() const { ASSERT_NTC(IsAttached()); return m_pszBuffer; }

    SIZE_T GetBufferCch() const { ASSERT_NTC(this->IsAttached()); return m_cchBuffer; }
    INT GetBufferCchAsINT() const { ASSERT_NTC(this->IsAttached()); if (m_cchBuffer > INT_MAX) return INT_MAX; return static_cast<INT>(m_cchBuffer); }
    UINT GetBufferCchAsUINT() const { ASSERT_NTC(this->IsAttached()); if (m_cchBuffer > UINT_MAX) return UINT_MAX; return static_cast<UINT>(m_cchBuffer); }
    DWORD GetBufferCchAsDWORD() const { ASSERT_NTC(this->IsAttached()); if (m_cchBuffer > MAXDWORD) return MAXDWORD; return static_cast<DWORD>(m_cchBuffer); }

    SIZE_T GetBufferCb() const { ASSERT_NTC(this->IsAttached()); return m_cchBuffer * sizeof(*m_pszBuffer); }
    INT GetBufferCbAsINT() const { ASSERT_NTC(this->IsAttached()); if ((m_cchBuffer * sizeof(TChar)) > INT_MAX) return INT_MAX; return static_cast<INT>(m_cchBuffer * sizeof(TChar)); }
    DWORD GetBufferCbAsDWORD() const { ASSERT_NTC(this->IsAttached()); if ((m_cchBuffer * sizeof(TChar)) > MAXDWORD) return MAXDWORD; return static_cast<DWORD>(m_cchBuffer * sizeof(TChar)); }

protected:
    TBuffer *m_pBuffer;
    TCharTraits::TMutableString m_pszBuffer;
    SIZE_T m_cchBuffer;
};

template <SIZE_T nInlineChars, typename TCharTraits> class CGenericStringBuffer : public CGenericBaseStringBuffer<TCharTraits>
{
    typedef CGenericBaseStringBuffer<TCharTraits> Base;

protected:
    BOOL Win32AllocateBuffer(SIZE_T cch, TMutableString &rpsz) const
    {
        // You shouldn't be doing this if the required buffer size is small enough to be inline...
        ASSERT_NTC(cch > nInlineChars);

        rpsz = NULL;

        TCharTraits::TMutableString String = NULL;
        String = reinterpret_cast<TCharTraits::TMutableString>(::FusionpHeapAllocEx(
                                                                        FUSION_DEFAULT_PROCESS_HEAP(),
                                                                        0,
                                                                        cch * sizeof(TCharTraits::TChar),
                                                                        "<string buffer>",
                                                                        __FILE__,
                                                                        __LINE__,
                                                                        0));            // fusion heap allocation flags
        if (String == NULL)
        {
            ::FusionpSetLastWin32Error(FUSION_WIN32_ALLOCFAILED_ERROR);
            return FALSE;
        }

        rpsz = String;
        return TRUE;
    }

    VOID DeallocateBuffer(TMutableString sz) const
    {
        VERIFY_NTC(::FusionpHeapFree(FUSION_DEFAULT_PROCESS_HEAP(), 0, sz));
    }

    TMutableString GetInlineBuffer() const { return const_cast<TMutableString>(m_rgchInlineBuffer); }
    SIZE_T GetInlineBufferCch() const { return nInlineChars; }

public:
    CGenericStringBuffer() { m_rgchInlineBuffer[0] = this->NullCharacter(); Base::InitializeInlineBuffer(); }
    ~CGenericStringBuffer() { if (m_prgchBuffer != m_rgchInlineBuffer) { this->DeallocateBuffer(m_prgchBuffer); } m_prgchBuffer = NULL; m_cchBuffer = 0; }

protected:
    TChar m_rgchInlineBuffer[nInlineChars];

private:
    CGenericStringBuffer(const CGenericStringBuffer &); // intentionally not implemented
    void operator =(const CGenericStringBuffer &); // intentionally not implemented
};

template <SIZE_T nInlineChars, typename TCharTraits> class CGenericHeapStringBuffer : public CGenericBaseStringBuffer<TCharTraits>
{
//    friend CGenericBaseStringBuffer<TCharTraits>;
    typedef CGenericBaseStringBuffer<TCharTraits> Base;

protected:
    BOOL Win32AllocateBuffer(SIZE_T cch, TMutableString &rpsz) const
    {
        // You shouldn't be doing this if the required buffer size is small enough to be inline...
        ASSERT_NTC(cch > nInlineChars);

        rpsz = NULL;

        TCharTraits::TMutableString String = NULL;
        String = reinterpret_cast<TCharTraits::TMutableString>(::FusionpHeapAllocEx(
                                                                        m_hHeap,
                                                                        dwDefaultWin32HeapAllocFlags,
                                                                        cch * sizeof(TCharTraits::TChar),
                                                                        "<string buffer>",
                                                                        __FILE__,
                                                                        __LINE__,
                                                                        0))             // fusion heap allocation flags
        if (String == NULL)
        {
            ::FusionpSetLastWin32Error(FUSION_WIN32_ALLOCFAILED_ERROR);
            return FALSE;
        }

        rpsz = String;
        return TRUE;
    }

    VOID DeallocateBuffer(TMutableString sz) const
    {
        VERIFY_NTC(::FusionpHeapFree(m_hHeap, dwDefaultWin32HeapFreeFlags, sz));
    }

    TMutableString GetInlineBuffer() const { return m_rgchInlineBuffer; }
    SIZE_T GetInlineBufferCch() const { return nInlineChars; }

public:
    CGenericHeapStringBuffer(HANDLE hHeap) : m_hHeap(hHeap) { m_rgchInlineBuffer[0] = this->NullCharacter(); Base::InitializeInlineBuffer(); }

    ~CGenericHeapStringBuffer() { ASSERT(m_cchBuffer == 0); ASSERT(m_prgchBuffer == NULL); }

protected:
    HANDLE m_hHeap;
    TChar m_rgchInlineBuffer[nInlineChars];
};

typedef CGenericStringBufferAccessor<CUnicodeCharTraits> CUnicodeStringBufferAccessor;

typedef CGenericBaseStringBuffer<CUnicodeCharTraits> CUnicodeBaseStringBuffer;

typedef CGenericStringBuffer<FUSION_DEFAULT_STRINGBUFFER_CHARS, CUnicodeCharTraits> CUnicodeStringBuffer;
typedef CGenericHeapStringBuffer<FUSION_DEFAULT_STRINGBUFFER_CHARS, CUnicodeCharTraits> CUnicodeHeapStringBuffer;

typedef CGenericStringBuffer<FUSION_DEFAULT_TINY_STRINGBUFFER_CHARS, CUnicodeCharTraits> CTinyUnicodeStringBuffer;
typedef CGenericHeapStringBuffer<FUSION_DEFAULT_TINY_STRINGBUFFER_CHARS, CUnicodeCharTraits> CTinyUnicodeHeapStringBuffer;

typedef CGenericStringBuffer<FUSION_DEFAULT_SMALL_STRINGBUFFER_CHARS, CUnicodeCharTraits> CSmallUnicodeStringBuffer;
typedef CGenericHeapStringBuffer<FUSION_DEFAULT_SMALL_STRINGBUFFER_CHARS, CUnicodeCharTraits> CSmallUnicodeHeapStringBuffer;

typedef CGenericStringBuffer<FUSION_DEFAULT_MEDIUM_STRINGBUFFER_CHARS, CUnicodeCharTraits> CMediumUnicodeStringBuffer;
typedef CGenericHeapStringBuffer<FUSION_DEFAULT_MEDIUM_STRINGBUFFER_CHARS, CUnicodeCharTraits> CMediumUnicodeHeapStringBuffer;

typedef CGenericStringBufferAccessor<CANSICharTraits> CANSIStringBufferAccessor;

typedef CGenericBaseStringBuffer<CANSICharTraits> CANSIBaseStringBuffer;

typedef CGenericStringBuffer<FUSION_DEFAULT_STRINGBUFFER_CHARS, CANSICharTraits> CANSIStringBuffer;
typedef CGenericHeapStringBuffer<FUSION_DEFAULT_STRINGBUFFER_CHARS, CANSICharTraits> CANSIHeapStringBuffer;

typedef CGenericStringBuffer<FUSION_DEFAULT_TINY_STRINGBUFFER_CHARS, CANSICharTraits> CTinyANSIStringBuffer;
typedef CGenericHeapStringBuffer<FUSION_DEFAULT_TINY_STRINGBUFFER_CHARS, CANSICharTraits> CTinyANSIHeapStringBuffer;

typedef CGenericStringBuffer<FUSION_DEFAULT_SMALL_STRINGBUFFER_CHARS, CANSICharTraits> CSmallANSIStringBuffer;
typedef CGenericHeapStringBuffer<FUSION_DEFAULT_SMALL_STRINGBUFFER_CHARS, CANSICharTraits> CSmallANSIHeapStringBuffer;

typedef CGenericStringBuffer<FUSION_DEFAULT_MEDIUM_STRINGBUFFER_CHARS, CANSICharTraits> CMediumANSIStringBuffer;
typedef CGenericHeapStringBuffer<FUSION_DEFAULT_MEDIUM_STRINGBUFFER_CHARS, CANSICharTraits> CMediumANSIHeapStringBuffer;

typedef CUnicodeBaseStringBuffer CBaseStringBuffer;
typedef CUnicodeStringBuffer CStringBuffer;
typedef CUnicodeHeapStringBuffer CHeapStringBuffer;

typedef CUnicodeStringBufferAccessor CStringBufferAccessor;

typedef CTinyUnicodeStringBuffer CTinyStringBuffer;
typedef CTinyUnicodeHeapStringBuffer CTinyHeapStringBuffer;

typedef CSmallUnicodeStringBuffer CSmallStringBuffer;
typedef CSmallUnicodeHeapStringBuffer CSmallHeapStringBuffer;

typedef CMediumUnicodeStringBuffer CMediumStringBuffer;
typedef CMediumUnicodeHeapStringBuffer CMediumHeapStringBuffer;

template <typename T1, typename T2> inline HRESULT HashTableCompareKey(T1 t1, T2 *pt2, bool &rfMatch);

template <> inline HRESULT HashTableCompareKey(PCWSTR sz, CUnicodeStringBuffer *pbuff, bool &rfMatch)
{
    HRESULT hr = NOERROR;
    SIZE_T cchKey = (sz != NULL) ? ::wcslen(sz) : 0;

    rfMatch = false;

    if (!pbuff->Win32Equals(sz, cchKey, rfMatch, false))
    {
        hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        goto Exit;
    }

    hr = NOERROR;
Exit:
    return hr;
}

template <> inline HRESULT HashTableCompareKey(PCSTR sz, CANSIStringBuffer *pbuff, bool &rfMatch)
{
    HRESULT hr = NOERROR;
    SIZE_T cchKey = ::strlen(sz);

    rfMatch = false;

    if (!pbuff->Win32Equals(sz, cchKey, rfMatch, false))
    {
        hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        goto Exit;
    }

    hr = NOERROR;
Exit:
    return hr;
}

//
// Support for CFusionArrays of strings
//
inline HRESULT 
FusionCopyContents<CBaseStringBuffer>(
    CBaseStringBuffer &Dest,
    const CBaseStringBuffer &Source
    )
{
    HRESULT hr = NOERROR;

    if (!Dest.Win32Assign(Source, Source.Cch()))
        hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());

    return hr;
}

template<>
inline BOOL
FusionWin32CopyContents<CStringBuffer>(
    CStringBuffer &rDestination, 
    const CStringBuffer &rSource
    )
{
    return rDestination.Win32Assign(rSource);
}

template<>
inline HRESULT
FusionCopyContents<CStringBuffer>( 
    CStringBuffer &rDest,
    const CStringBuffer &rSource
    )
{
    FN_PROLOG_HR
    IFW32FALSE_EXIT(::FusionWin32CopyContents<CStringBuffer>(rDest, rSource));
    FN_EPILOG
}

template<>
inline void
FusionMoveContents<CStringBuffer>(
    CStringBuffer &rDest,
    CStringBuffer &rSource
    )
{
    FN_TRACE();
    HARD_ASSERT2_ACTION(FusionMoveContents, "FusionMoveContents for CAssemblyRecoveryInfo isn't allowed.");
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusiondeque.h ===
#pragma once

#include "fusiontrace.h"
#include "fusiondequelinkage.h"

class CDequeBase
{
protected:
    inline CDequeBase() : m_EntryCount(0) { m_Head.InitializeHead(this); }

    inline ~CDequeBase()
    {
        // Derived class should have cleaned up
        ASSERT_NTC(m_EntryCount == 0);
    }

    inline VOID VerifyLinkageFromThisDeque(const CDequeLinkage &r)
    {
        ASSERT_NTC(r.GetDequeBase() == this);
    }

#if DBG
    inline bool Valid() const { return (m_Head.GetFlink() != NULL) && (m_Head.GetBlink() != NULL); }
#endif // DBG

    void ResetHead() { FN_TRACE(); m_Head.InitializeHead(this); }

    inline VOID InsertAfter(CDequeLinkage *pExistingLinkage, CDequeLinkage *pNewLinkage, bool fUpdateEntryCount = true)
    {
        ASSERT_NTC(this->Valid());
        this->VerifyLinkageFromThisDeque(m_Head);

        pNewLinkage->SetFlink(pExistingLinkage->GetFlink());
        pNewLinkage->SetBlink(pExistingLinkage);
        pExistingLinkage->GetFlink()->SetBlink(pNewLinkage);
        pExistingLinkage->SetFlink(pNewLinkage);
        pNewLinkage->SetDeque(this);
        if (fUpdateEntryCount)
            m_EntryCount++;
    }

    VOID InsertBefore(CDequeLinkage *pExistingLinkage, CDequeLinkage *pNewLinkage, bool fUpdateEntryCount = true)
    {
        ASSERT_NTC(this->Valid());
        this->VerifyLinkageFromThisDeque(m_Head);

        pNewLinkage->SetBlink(pExistingLinkage->GetBlink());
        pNewLinkage->SetFlink(pExistingLinkage);
        pExistingLinkage->GetBlink()->SetFlink(pNewLinkage);
        pExistingLinkage->SetBlink(pNewLinkage);
        pNewLinkage->SetDeque(this);
        if (fUpdateEntryCount)
            m_EntryCount++;
    }

    VOID Remove(CDequeLinkage *pLinkage, bool fUpdateEntryCount = true)
    {
        ASSERT_NTC(this->Valid());
        this->VerifyLinkageFromThisDeque(m_Head);

        // You can't remove the head...
        ASSERT_NTC(pLinkage->GetDequeBase() == this);
        ASSERT_NTC(pLinkage != &m_Head);
        ASSERT_NTC(pLinkage->m_ulLockCount == 0);

        if ((pLinkage != NULL) &&
            (pLinkage->GetDequeBase() == this) &&
            (pLinkage != &m_Head))
        {
            pLinkage->GetBlink()->SetFlink(pLinkage->GetFlink());
            pLinkage->GetFlink()->SetBlink(pLinkage->GetBlink());
            if (fUpdateEntryCount)
                m_EntryCount--;
        }
    }

    VOID SetDeque(CDequeLinkage *pLinkage) { pLinkage->SetDeque(this); }

    static CDequeLinkage *GetFlink(const CDequeLinkage *pLinkage) { return pLinkage->GetFlink(); }
    static CDequeLinkage *GetFlink(const CDequeLinkage &rLinkage) { return rLinkage.GetFlink(); }
    static CDequeLinkage *GetBlink(const CDequeLinkage *pLinkage) { return pLinkage->GetBlink(); }
    static CDequeLinkage *GetBlink(const CDequeLinkage &rLinkage) { return rLinkage.GetBlink(); }
    static VOID SetFlink(CDequeLinkage *pLinkage, CDequeLinkage *pFlink) { pLinkage->SetFlink(pFlink); }
    static VOID SetFlink(CDequeLinkage &rLinkage, CDequeLinkage *pFlink) { rLinkage.SetFlink(pFlink); }
    static VOID SetBlink(CDequeLinkage *pLinkage, CDequeLinkage *pBlink) { pLinkage->SetBlink(pBlink); }
    static VOID SetBlink(CDequeLinkage &rLinkage, CDequeLinkage *pBlink) { rLinkage.SetBlink(pBlink); }

    CDequeLinkage m_Head;
    SIZE_T m_EntryCount;

private:
    CDequeBase(const CDequeBase &r); // intentionally not implemented
    void operator =(const CDequeBase &r); // intentionally not implemented
};

template <typename TEntry, size_t LinkageMemberOffset> class CConstDequeIterator;

template <typename TEntry, size_t LinkageMemberOffset> class CDeque : protected CDequeBase
{
    friend CConstDequeIterator<TEntry, LinkageMemberOffset>;

public:
    CDeque() { }

    ~CDeque()
    {
        CSxsPreserveLastError ple;

        ASSERT_NTC(this->Valid());
        this->VerifyLinkageFromThisDeque(m_Head);

        // You should have cleaned up this deque beforehand...
        ASSERT_NTC(m_EntryCount == 0);

        m_EntryCount = 0;

        ple.Restore();
    }

    VOID TakeValue(CDeque &rThat)
    {
        FN_TRACE();

        ASSERT(this->Valid());

        // Since we don't manage the storage of the entries, "this" deque
        // must be empty.
        ASSERT(m_EntryCount == 0);

        // with regards to linkages, we only need to change the pseudo-head flink
        // and blink, the actual head blink and the actual tail flink.  However,
        // for debugging purposes, we keep the identity of the deque that contains
        // the linkage in the linkage, so we also have to fix those.

        ASSERT(rThat.Valid());

        CDequeLinkage *pLinkage = rThat.GetFlink(rThat.m_Head);

        if (pLinkage != NULL)
        {
            while (pLinkage != &rThat.m_Head)
            {
                ASSERT(pLinkage->IsNotLocked());
                this->SetDeque(pLinkage);
                pLinkage = rThat.GetFlink(pLinkage);
            }
        }

        // Now munge the pointers...
        this->SetFlink(m_Head, rThat.GetFlink(rThat.m_Head));
        this->SetBlink(m_Head, rThat.GetBlink(rThat.m_Head));
        this->SetBlink(rThat.GetFlink(rThat.m_Head), &m_Head);
        this->SetFlink(rThat.GetBlink(rThat.m_Head), &m_Head);
        rThat.SetFlink(rThat.m_Head, &rThat.m_Head);
        rThat.SetBlink(rThat.m_Head, &rThat.m_Head);

        m_EntryCount = rThat.m_EntryCount;
        rThat.m_EntryCount = 0;
    }

    VOID AddToHead(TEntry *pEntry)
    {
        FN_TRACE();
        ASSERT(this->Valid());
        this->InsertAfter(&m_Head, this->MapEntryToLinkage(pEntry), true);
    }

    VOID AddToTail(TEntry *pEntry)
    {
        FN_TRACE();
        ASSERT(this->Valid());
        this->InsertBefore(&m_Head, this->MapEntryToLinkage(pEntry), true);
    }

    VOID Add(TEntry *pEntry)
    {
        FN_TRACE();
        ASSERT(this->Valid());
        AddToTail(pEntry);
    }

    TEntry *RemoveHead()
    {
        FN_TRACE();

        ASSERT(this->Valid());

        TEntry *pEntry = NULL;

        if (this->GetFlink(m_Head) != &m_Head)
        {
            CDequeLinkage *pLinkage = this->GetFlink(m_Head);
            this->Remove(pLinkage, true);
            pEntry = this->MapLinkageToEntry(pLinkage);
        }

        return pEntry;
    }

    TEntry *RemoveTail()
    {
        FN_TRACE();

        ASSERT(this->Valid());

        TEntry *pEntry = NULL;

        if (this->GetBlink(m_Head) != &m_Head)
        {
            pEntry = this->GetBlink(m_Head);
            this->Remove(pEntry, true);
        }

        return pEntry;
    }

    bool IsHead(CDequeLinkage *pLinkage) const { return pLinkage == &m_Head; }

    VOID Remove(TEntry *pEntry)
    {
        FN_TRACE();

        ASSERT(this->Valid());

        this->Remove(this->MapEntryToLinkage(pEntry), true);
    }

    template <typename T> VOID ForEach(T *pt, VOID (T::*pmfn)(TEntry *p))
    {
        FN_TRACE();

        ASSERT(this->Valid());

        CDequeLinkage *pLinkage = this->GetFlink(m_Head);

        if (pLinkage != NULL)
        {
            while (pLinkage != &m_Head)
            {
                // You can't remove the element that you're on during a ForEach() call.
                pLinkage->Lock();
                (pt->*pmfn)(this->MapLinkageToEntry(pLinkage));
                pLinkage->Unlock();
                pLinkage = this->GetFlink(pLinkage);
            }
        }
    }

    template <typename T> VOID ForEach(const T *pt, VOID (T::*pmfn)(TEntry *p) const)
    {
        FN_TRACE();

        ASSERT(this->Valid());
        CDequeLinkage *pLinkage = this->GetFlink(m_Head);

        while ( pLinkage && (pLinkage != &m_Head) )
        {
            pLinkage->Lock();
            (pt->*pmfn)(this->MapLinkageToEntry(pLinkage));
            pLinkage->Unlock();
            pLinkage = this->GetFlink(pLinkage);
        }
    }

    template <typename T> VOID Clear(T *pt, VOID (T::*pmfn)(TEntry *p))
    {
        FN_TRACE();

        ASSERT(this->Valid());
        CDequeLinkage *pLinkage = this->GetFlink(m_Head);

        if (pLinkage != NULL)
        {
            while (pLinkage != &m_Head)
            {
                CDequeLinkage *pLinkage_Next = this->GetFlink(pLinkage);
                ASSERT(pLinkage->IsNotLocked());
                (pt->*pmfn)(this->MapLinkageToEntry(pLinkage));
                pLinkage = pLinkage_Next;
            }
        }

        this->ResetHead();
        m_EntryCount = 0;
    }

    template <typename T> VOID Clear(const T *pt, VOID (T::*pmfn)(TEntry *p) const)
    {
        FN_TRACE();

        ASSERT(this->Valid());
        CDequeLinkage *pLinkage = this->GetFlink(m_Head);

        if (pLinkage != NULL)
        {
            while (pLinkage != &m_Head)
            {
                CDequeLinkage *pLinkage_Next = this->GetFlink(pLinkage);
                ASSERT(pLinkage->IsNotLocked());
                (pt->*pmfn)(this->MapLinkageToEntry(pLinkage));
                pLinkage = pLinkage_Next;
            }
        }

        this->ResetHead();
        m_EntryCount = 0;
    }

    VOID Clear(VOID (TEntry::*pmfn)())
    {
        FN_TRACE();

        ASSERT(this->Valid());
        CDequeLinkage *pLinkage = this->GetFlink(m_Head);

        if (pLinkage != NULL)
        {
            while (pLinkage != &m_Head)
            {
                CDequeLinkage *pLinkage_Next = this->GetFlink(pLinkage);
                ASSERT(pLinkage->IsNotLocked());
                TEntry* pEntry = this->MapLinkageToEntry(pLinkage);
                (pEntry->*pmfn)();
                pLinkage = pLinkage_Next;
            }
        }

        this->ResetHead();
        m_EntryCount = 0;
    }

    VOID ClearAndDeleteAll()
    {
        FN_TRACE();
        ASSERT(this->Valid());
        CDequeLinkage *pLinkage = this->GetFlink(m_Head);

        if (pLinkage != NULL)
        {
            while (pLinkage != &m_Head)
            {
                CDequeLinkage *pLinkage_Next = this->GetFlink(pLinkage);
                ASSERT(pLinkage->IsNotLocked());
                TEntry* pEntry = this->MapLinkageToEntry(pLinkage);
                FUSION_DELETE_SINGLETON(pEntry);
                pLinkage = pLinkage_Next;
            }
        }

        this->ResetHead();
        m_EntryCount = 0;
    }

    void ClearNoCallback()
    {
        FN_TRACE();

        ASSERT(this->Valid());

        this->ResetHead();
        m_EntryCount = 0;
    }


    SIZE_T GetEntryCount() const { return m_EntryCount; }
    bool IsEmpty() const { return m_EntryCount == 0; }

protected:
    using CDequeBase::Remove;

    TEntry *MapLinkageToEntry(CDequeLinkage *pLinkage) const
    {
        ASSERT_NTC(pLinkage != &m_Head);

        if (pLinkage == &m_Head)
            return NULL;

        return (TEntry *) (((LONG_PTR) pLinkage) - LinkageMemberOffset);
    }

    CDequeLinkage *MapEntryToLinkage(TEntry *pEntry) const
    {
        ASSERT_NTC(pEntry != NULL);

        return (CDequeLinkage *) (((LONG_PTR) pEntry) + LinkageMemberOffset);
    }

private:
    CDeque(const CDeque &r); // intentionally not implemented
    void operator =(const CDeque &r); // intentionally not implemented
};

enum DequeIteratorMovementDirection
{
    eDequeIteratorMoveForward,
    eDequeIteratorMoveBackward
};

template <typename TEntry, size_t LinkageMemberOffset> class CConstDequeIterator
{
public:
    CConstDequeIterator(const CDeque<TEntry, LinkageMemberOffset> *Deque = NULL) : m_Deque(Deque), m_pCurrent(NULL) { }

    ~CConstDequeIterator()
    {
        if (m_pCurrent != NULL)
        {
            m_pCurrent->Unlock();
            m_pCurrent = NULL;
        }
    }

    VOID Rebind(const CDeque<TEntry, LinkageMemberOffset> *NewDeque)
    {
        FN_TRACE();

        if (m_pCurrent != NULL)
        {
            m_pCurrent->Unlock();
            m_pCurrent = NULL;
        }

        m_Deque = NewDeque;
        if (NewDeque != NULL)
        {
            m_pCurrent = this->GetFirstLinkage();
            m_pCurrent->Lock();
        }
    }

    bool IsBound() const { return (m_Deque != NULL); }

    VOID Unbind()
    {
        FN_TRACE();

        if (m_Deque != NULL)
        {
            if (m_pCurrent != NULL)
            {
                m_pCurrent->Unlock();
                m_pCurrent = NULL;
            }

            m_Deque = NULL;
        }
    }

    // You can't remove an element that the iterator is sitting on; usually you just
    // save the current element and move to the next one, but if you found the exact
    // element you wanted and don't want to use the iterator any more, you can Close()
    // it to release the lock.
    VOID Close()
    {
        FN_TRACE();

        if (m_pCurrent != NULL)
        {
            m_pCurrent->Unlock();
            m_pCurrent = NULL;
        }
    }

    inline VOID Reset()
    {
        if (m_pCurrent != NULL)
        {
            m_pCurrent->Unlock();
            m_pCurrent = NULL;
        }

        m_pCurrent = this->GetFirstLinkage();
        m_pCurrent->Lock();
    }

    inline VOID Move(DequeIteratorMovementDirection eDirection)
    {
        ASSERT_NTC(m_pCurrent != NULL);
        ASSERT_NTC((eDirection == eDequeIteratorMoveForward) ||
               (eDirection == eDequeIteratorMoveBackward));

        m_pCurrent->Unlock();
        if (eDirection == eDequeIteratorMoveForward)
            m_pCurrent = m_Deque->GetFlink(m_pCurrent);
        else if (eDirection == eDequeIteratorMoveBackward)
            m_pCurrent = m_Deque->GetBlink(m_pCurrent);
        m_pCurrent->Lock();
    }

    VOID Next() { this->Move(eDequeIteratorMoveForward); }
    VOID Previous() { this->Move(eDequeIteratorMoveBackward); }

    bool More() const { return (m_pCurrent != NULL) && (m_pCurrent != &m_Deque->m_Head); }

    TEntry *operator ->() const { ASSERT_NTC(m_pCurrent != NULL); return this->MapLinkageToEntry(m_pCurrent); }
    operator TEntry *() const { ASSERT_NTC(m_pCurrent != NULL); return this->MapLinkageToEntry(m_pCurrent); }
    TEntry *Current() const { ASSERT_NTC(m_pCurrent != NULL); return this->MapLinkageToEntry(m_pCurrent); }

protected:
    CDequeLinkage *GetFirstLinkage() const { return m_Deque->GetFlink(m_Deque->m_Head); }
    CDequeLinkage *GetLastLinkage() const { return m_Deque->GetBlink(m_Deque->m_Head); }

    TEntry *MapLinkageToEntry(CDequeLinkage *pLinkage) const { return m_Deque->MapLinkageToEntry(pLinkage); }

    const CDeque<TEntry, LinkageMemberOffset> *m_Deque;
    CDequeLinkage *m_pCurrent;
};

template <typename TEntry, size_t LinkageMemberOffset> class CDequeIterator : public CConstDequeIterator<TEntry, LinkageMemberOffset>
{
    typedef CConstDequeIterator<TEntry, LinkageMemberOffset> Base;

public:
    CDequeIterator(CDeque<TEntry, LinkageMemberOffset> *Deque = NULL) : Base(Deque) { }

    ~CDequeIterator() { }

    VOID Rebind(CDeque<TEntry, LinkageMemberOffset> *NewDeque)
    {
        FN_TRACE();

        if (m_pCurrent != NULL)
        {
            m_pCurrent->Unlock();
            m_pCurrent = NULL;
        }

        m_Deque = NewDeque;

        if (NewDeque != NULL)
        {
            m_pCurrent = this->GetFirstLinkage();
            m_pCurrent->Lock();
        }
    }

    TEntry *RemoveCurrent(DequeIteratorMovementDirection eDirection)
    {
        FN_TRACE();
        TEntry *Result = NULL;

        ASSERT(m_pCurrent != NULL);
        ASSERT(!m_Deque->IsHead(m_pCurrent));

        if ((m_pCurrent != NULL) && (!m_Deque->IsHead(m_pCurrent)))
        {
            Result = this->MapLinkageToEntry(m_pCurrent);
            this->Move(eDirection);
            const_cast<CDeque<TEntry, LinkageMemberOffset> *>(m_Deque)->Remove(Result);
        }
        return Result;
    }

    void DeleteCurrent(DequeIteratorMovementDirection eDirection)
    {
        FN_TRACE();
        TEntry *Result = this->RemoveCurrent(eDirection);

        if (Result != NULL)
            FUSION_DELETE_SINGLETON(Result);
    }

protected:
    // All member data is in the parent...
};

#ifdef FN_TRACE_SHOULD_POP
#pragma pop_macro("FN_TRACE")
#undef FN_TRACE_SHOULD_POP
#elif defined(FN_TRACE_SHOULD_DESTROY)
#undef FN_TRACE
#endif

#ifdef FN_TRACE_CONSTRUCTOR_SHOULD_POP
#pragma pop_macro("FN_TRACE_CONSTRUCTOR")
#undef FN_TRACE_CONSTRUCTOR_SHOULD_POP
#elif defined(FN_TRACE_CONSTRUCTOR_SHOULD_DESTROY)
#undef FN_TRACE_CONSTRUCTOR
#endif

#ifdef FN_TRACE_DESTRUCTOR_SHOULD_POP
#pragma pop_macro("FN_TRACE_DESTRUCTOR")
#undef FN_TRACE_DESTRUCTOR_SHOULD_POP
#elif defined(FN_TRACE_DESTRUCTOR_SHOULD_DESTROY)
#undef FN_TRACE_DESTRUCTOR
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionchartraits.h ===
#if !defined(_FUSION_INC_FUSIONCHARTRAITS_H_INCLUDED_)
#define _FUSION_INC_FUSIONCHARTRAITS_H_INCLUDED_

#pragma once

#include <stdio.h>
#include <limits.h>
#include "returnstrategy.h"
#include "fusionhashstring.h"
#include "fusionstring.h"

enum StringComparisonResult {
    eLessThan,
    eEquals,
    eGreaterThan
};

//
// This is not the base of all possible CharTraits, but it is the base of the ones
// we have so far. There are pieces of this you can imagine changing.
//   StringLength could be strlen/wcslen (msvcrt/Rtl/ntoskrnl)
//   CompareStrings could be stricmp/wcsicmp or like unilib and do all the work itself
//   WideCharToMultiByte / MultiByteToWideChar could use Rtl.
//   more
//
template <typename Char, typename OtherChar>
class CCharTraitsBase
{
    typedef CCharTraitsBase<Char, OtherChar> TThis;

public:
    typedef Char TChar;
    typedef Char* TMutableString;
    typedef const Char* TConstantString;

    // MFC 7.0 templatized CString makes some good use of this idea; we do not yet.
    typedef OtherChar TOtherChar;
    typedef OtherChar* TOtherString;
    typedef const OtherChar* TOtherConstantString;

    inline static TChar NullCharacter() { return 0; }
    inline static bool IsNullCharacter(TChar ch)
        { return ch == NullCharacter(); }

    inline static TConstantString PreferredPathSeparatorString()
    {
        const static TChar Result[] = { '\\', 0 };
        return Result;
    }

    inline static TChar PreferredPathSeparator()
        { return '\\'; }
    inline static bool IsPathSeparator(TChar ch)
        { return ((ch == '\\') || (ch == '/')); }
    inline static TConstantString PathSeparators()
    {
        const static TChar Result[] = { '\\', '/', 0 };
        return Result;
    }

    inline static TChar DotChar()
        { return '.'; }

    // copy into buffer from TChar to TChar
    template <typename ReturnStrategy>
    inline static ReturnStrategy::ReturnType
    CopyIntoBuffer(
        ReturnStrategy &returnStrategy,
        TChar rgchBuffer[],
        SIZE_T cchBuffer,
        TConstantString szString,
        SIZE_T cchIn
        )
    {
        if (cchBuffer != 0)
        {
            if (szString != NULL)
            {
                SIZE_T cchToCopy = cchIn;

                if (cchToCopy >= cchBuffer)
                    cchToCopy = cchBuffer - 1;

                memcpy(rgchBuffer, szString, cchToCopy * sizeof(TChar));
                rgchBuffer[cchToCopy] = NullCharacter();
            }
            else
                rgchBuffer[0] = NullCharacter();
        }
        returnStrategy.SetWin32Bool(TRUE);
        return returnStrategy.Return();
    }

    // copy into buffer from TChar to TChar
    inline static HRESULT CopyIntoBuffer(TChar rgchBuffer[], SIZE_T cchBuffer, TConstantString szString, SIZE_T cchIn)
    {
        CReturnStrategyHresult hr;
        return TThis::CopyIntoBuffer(hr, rgchBuffer, cchBuffer, szString, cchIn);
    }

    // copy into buffer from TChar to TChar
    inline static BOOL Win32CopyIntoBuffer(TChar rgchBuffer[], SIZE_T cchBuffer, TConstantString szString, SIZE_T cchIn)
    {
        CReturnStrategyBoolLastError f;
        return TThis::CopyIntoBuffer(f, rgchBuffer, cchBuffer, szString, cchIn);
    }


    // copy into buffer from TChar to TChar
    template <typename ReturnStrategy>
    inline static ReturnStrategy::ReturnType
    CopyIntoBufferAndAdvanceCursor(
        ReturnStrategy &returnStrategy,
        TMutableString &rBuffer,
        SIZE_T &cchBuffer,
        TConstantString szString,
        SIZE_T cchIn
        )
    {
        FN_TRACE();

        ASSERT((cchBuffer != 0) || (cchIn == 0));
        ASSERT((szString != NULL) || (cchIn == 0));

        if (cchBuffer != 0)
        {
            if (szString != NULL)
            {
                SIZE_T cchToCopy = static_cast<SIZE_T>(cchIn);

                // Someone should have stopped this before we got this far.
                ASSERT(cchToCopy <= cchBuffer);
                // You should not include the null character in the count in
                ASSERT((cchToCopy == NULL) || (szString[cchToCopy-1] != NullCharacter()));

                if (cchToCopy > cchBuffer)
                    cchToCopy = cchBuffer;

                memcpy(rBuffer, szString, cchToCopy * sizeof(TChar));

                rBuffer += cchToCopy;
                cchBuffer -= cchToCopy;
            }
        }
        returnStrategy.SetWin32Bool(TRUE);
        return returnStrategy.Return();
    }

    inline static BOOL Win32HashString(TConstantString szString, SIZE_T cchIn, ULONG &rulPseudoKey, bool fCaseInsensitive)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        IFW32FALSE_EXIT(::FusionpHashUnicodeString(szString, cchIn, &rulPseudoKey, fCaseInsensitive));
        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    // copy into buffer from TChar to TChar
    inline static BOOL Win32CopyIntoBufferAndAdvanceCursor(TMutableString &rBuffer, SIZE_T &cchBuffer, TConstantString szString, SIZE_T cchIn)
    {
        CReturnStrategyBoolLastError f;
        return CopyIntoBufferAndAdvanceCursor(f, rBuffer, cchBuffer, szString, cchIn);
    }

    // copy into buffer from TChar to TChar
    inline static HRESULT ComCopyIntoBufferAndAdvanceCursor(TMutableString &rBuffer, SIZE_T &cchBuffer, TConstantString szString, SIZE_T cchIn)
    {
        CReturnStrategyHresult hr;
        return CopyIntoBufferAndAdvanceCursor(hr, rBuffer, cchBuffer, szString, cchIn);
    }

    // determine characters required for matching type (TChar)
    // like strlen but checks for null and optionally can be told the length
    template <typename ReturnStrategy>
    inline static ReturnStrategy::ReturnType
    DetermineRequiredCharacters(
        ReturnStrategy &returnStrategy,
        TConstantString /* sz */,
        SIZE_T         cchIn,
        SIZE_T          &rcch
        )
    {
        rcch = cchIn + 1;
        returnStrategy.SetWin32Bool(TRUE);
        return returnStrategy.Return();
    }

    // determine characters required for matching type (TChar)
    inline static HRESULT DetermineRequiredCharacters(TConstantString sz, SIZE_T cchIn, SIZE_T &rcch)
    {
        CReturnStrategyHresult returnStrategy;
        return DetermineRequiredCharacters(returnStrategy, sz, cchIn, rcch);
    }

    // determine characters required for matching type (TChar)
    inline static BOOL Win32DetermineRequiredCharacters(TConstantString sz, SIZE_T cchIn, SIZE_T &rcch)
    {
        CReturnStrategyBoolLastError returnStrategy;
        return DetermineRequiredCharacters(returnStrategy, sz, cchIn, rcch);
    }

    inline static BOOL Win32EqualStrings(bool &rfMatches, PCWSTR psz1, SIZE_T cch1, PCWSTR psz2, SIZE_T cch2, bool fCaseInsensitive)
    {
        rfMatches = (::FusionpCompareStrings(psz1, cch1, psz2, cch2, fCaseInsensitive) == 0);
        return TRUE;
    }

    inline static BOOL Win32EqualStrings(bool &rfMatches, PCSTR psz1, SIZE_T cch1, PCSTR psz2, SIZE_T cch2, bool fCaseInsensitive)
    {
        rfMatches = (::FusionpCompareStrings(psz1, cch1, psz2, cch2, fCaseInsensitive) == 0);
        return TRUE;
    }

    inline static BOOL Win32CompareStrings(StringComparisonResult &rscr, PCWSTR psz1, SIZE_T cch1, PCWSTR psz2, SIZE_T cch2, bool fCaseInsensitive)
    {
        int i = ::FusionpCompareStrings(psz1, cch1, psz2, cch2, fCaseInsensitive);

        if (i == 0)
            rscr = eEquals;
        else if (i < 0)
            rscr = eLessThan;
        else
            rscr = eGreaterThan;

        return TRUE;
    }

    inline static BOOL Win32CompareStrings(StringComparisonResult &rscr, PCSTR psz1, SIZE_T cch1, PCSTR psz2, SIZE_T cch2, bool fCaseInsensitive)
    {
        int i = ::FusionpCompareStrings(psz1, cch1, psz2, cch2, fCaseInsensitive);

        if (i == 0)
            rscr = eEquals;
        else if (i < 0)
            rscr = eLessThan;
        else
            rscr = eGreaterThan;

        return TRUE;
    }

    inline static int CompareStrings(LCID lcid, DWORD dwCmpFlags, PCWSTR psz1, int cch1, PCWSTR psz2, int cch2)
    {
        return ::CompareStringW(lcid, dwCmpFlags, psz1, cch1, psz2, cch2);
    }

    inline static int CompareStrings(LCID lcid, DWORD dwCmpFlags, PCSTR psz1, int cch1, PCSTR psz2, int cch2)
    {
        return ::CompareStringA(lcid, dwCmpFlags, psz1, cch1, psz2, cch2);
    }

    inline static int FormatV(PSTR pszBuffer, SIZE_T nBufferSize, PCSTR pszFormat, va_list args)
    {
        return _vsnprintf(pszBuffer, nBufferSize, pszFormat, args);
    }

    inline static int FormatV(PWSTR pszBuffer, SIZE_T nBufferSize, PCWSTR pszFormat, va_list args)
    {
        return _vsnwprintf(pszBuffer, nBufferSize, pszFormat, args);
    }
#if 0
    inline static BOOL Win32GetRequiredBufferSizeInCharsForFormatV(PCWSTR pszFormat, va_list args, SIZE_T& rcch)
    {
        FN_PROLOG_WIN32
        INT i = 0;
        rcch = 0;
        if ((i = _vscwprintf(pszFormat, args)) < 0)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(_vscwprintf, ERROR_INVALID_PARAMETER);
        rcch = static_cast<SIZE_T>(i);
        FN_EPILOG
    }

    inline static BOOL Win32GetRequiredBufferSizeInCharsForFormatV(PCSTR pszFormat, va_list args, SIZE_T& rcch)
    {
        FN_PROLOG_WIN32
        INT i = 0;
        rcch = 0;
        if ((i = _vscprintf(pszFormat, args)) < 0)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(_vscprintf, ERROR_INVALID_PARAMETER);
        rcch = static_cast<SIZE_T>(i);
        FN_EPILOG
    }
#endif    
};

class CUnicodeCharTraits : public CCharTraitsBase<WCHAR, CHAR>
{
    typedef CUnicodeCharTraits TThis;
    typedef CCharTraitsBase<WCHAR, CHAR> Base;

public:
    // without using, we end up hiding these by providing equally named functions
    using Base::DetermineRequiredCharacters;
    using Base::Win32DetermineRequiredCharacters;
    using Base::CopyIntoBuffer;
    using Base::Win32CopyIntoBuffer;

    inline static PCWSTR DotString() { return L"."; }
    inline static SIZE_T DotStringCch() { return 1; }

    // determine characters required for mismatched type (CHAR -> WCHAR)
    template <typename ReturnStrategy>
    inline static ReturnStrategy::ReturnType
    DetermineRequiredCharacters(
        ReturnStrategy &returnStrategy,
        PCSTR  sz,
        SIZE_T cchIn,
        SIZE_T  &rcch,
        UINT    cp = CP_THREAD_ACP,
        DWORD dwFlags = MB_ERR_INVALID_CHARS
        )
    {
        FN_TRACE();

        if (sz != NULL)
        {
            // For 64-bit, clamp the maximum size passed in to the largest that the INT
            // parameter to MultiByteToWideChar() can take.
            ASSERT2(cchIn <= INT_MAX, "large parameter clamped");
            if (cchIn > INT_MAX)
                cchIn = INT_MAX;

            INT cch = ::MultiByteToWideChar(cp, dwFlags, sz, static_cast<INT>(cchIn), NULL, 0);
            if ((cch == 0) && (cchIn > 0))
            {
                returnStrategy.SetWin32Bool(FALSE);
                goto Exit;
            }
            rcch = static_cast<SIZE_T>(cch) + 1;
        }
        else
            rcch = 1;

        returnStrategy.SetWin32Bool(TRUE);
    Exit:
         return returnStrategy.Return();
    }

    inline static BOOL FindCharacter(PCWSTR sz, SIZE_T cch, WCHAR ch, BOOL *pfFound, SIZE_T *pich)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        // There doesn't seem to be a builtin to do this...
        SIZE_T i;

        if (pfFound != NULL)
            *pfFound = FALSE;

        if (pich != NULL)
            *pich = 0;

        PARAMETER_CHECK((pfFound != NULL) && (pich != NULL));

        for (i=0; i<cch; i++)
        {
            if (sz[i] == ch)
            {
                *pich = i;
                *pfFound = TRUE;
                break;
            }
        }

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    inline static bool ContainsCharacter(PCWSTR sz, SIZE_T cch, WCHAR ch)
    {
        SIZE_T i;

        for (i=0; i<cch; i++)
        {
            if (sz[i] == ch)
                return true;
        }

        return false;
    }

    inline static BOOL Win32ToLower(WCHAR wchToConvert, WCHAR &rwchConverted)
    {
        rwchConverted = ::FusionpRtlDowncaseUnicodeChar(wchToConvert);
        return TRUE;
    }

    inline static BOOL Win32ToUpper(WCHAR wchToConvert, WCHAR &rwchConverted)
    {
        rwchConverted = ::FusionpRtlUpcaseUnicodeChar(wchToConvert);
        return TRUE;
    }

    inline static BOOL Win32ReverseFind(PCWSTR &rpchFound, PCWSTR psz, SIZE_T cch, WCHAR wchToFind, bool fCaseInsensitive)
    {
        BOOL fSuccess = FALSE;
        SIZE_T i = 0;

        rpchFound = NULL;

        if (fCaseInsensitive)
        {
            // Map the character to its lower case equivalent...
            if (!TThis::Win32ToLower(wchToFind, wchToFind))
                goto Exit;

            for (i=cch; i>0; i--)
            {
                bool fMatch;

                if (!TThis::Win32CompareLowerCaseCharacterToCharCaseInsensitively(fMatch, wchToFind, psz[i - 1]))
                    goto Exit;

                if (fMatch)
                    break;
            }

        }
        else
        {
            for (i=cch; i>0; i--)
            {
                if (psz[i - 1] == wchToFind)
                    break;
            }
        }

        if (i != 0)
            rpchFound = &psz[i - 1];

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    inline static BOOL Win32CompareLowerCaseCharacterToCharCaseInsensitively(bool &rfMatch, WCHAR wchLowerCase, WCHAR wchCandidate)
    {
        BOOL fSuccess = FALSE;

        rfMatch = false;

        if (!TThis::Win32ToLower(wchCandidate, wchCandidate))
            goto Exit;

        if (wchCandidate == wchLowerCase)
            rfMatch = true;

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    // determine characters required for mismatched type (CHAR -> WCHAR)
    inline static HRESULT DetermineRequiredCharacters(PCSTR sz, SIZE_T cchIn, SIZE_T &rcch, UINT cp = CP_THREAD_ACP, DWORD dwFlags = MB_ERR_INVALID_CHARS)
    {
        CReturnStrategyHresult hr;
        return DetermineRequiredCharacters(hr, sz, cchIn, rcch, cp, dwFlags);
    }

    // determine characters required for mismatched type (CHAR -> WCHAR)
    inline static BOOL Win32DetermineRequiredCharacters(PCSTR sz, SIZE_T cchIn, SIZE_T &rcch, UINT cp = CP_THREAD_ACP, DWORD dwFlags = MB_ERR_INVALID_CHARS)
    {
        CReturnStrategyBoolLastError f;
        return DetermineRequiredCharacters(f, sz, cchIn, rcch, cp, dwFlags);
    }

    inline static SIZE_T NullTerminatedStringLength(PCWSTR sz) { return (sz != NULL) ? ::wcslen(sz) : 0; }

    // copy into buffer from CHAR to WCHAR
    template <typename ReturnStrategy>
    inline static ReturnStrategy::ReturnType
    CopyIntoBuffer(
        ReturnStrategy &returnStrategy,
        WCHAR rgchBuffer[],
        SIZE_T cchBuffer,
        PCSTR szString,
        SIZE_T cchIn,
        UINT cp = CP_THREAD_ACP,
        DWORD dwFlags = MB_ERR_INVALID_CHARS
        )
    {
        FN_TRACE();

        // The caller must be on drugs if they (think that they) have a buffer larger than 2gb, but
        // let's at least clamp it so that we don't get a negative int value passed in
        // to ::MultiByteToWideChar().
        ASSERT2(cchBuffer <= INT_MAX, "large parameter clamped");
        if (cchBuffer > INT_MAX)
            cchBuffer = INT_MAX;

        if (cchBuffer != 0)
        {
            if (szString != NULL)
            {
                // It would seem that you could just pass the -1 into MultiByteToWideChar(), but
                // you get some errors on the boundary conditions, because -1 implies that you
                // want to consider the null termination on the input string, and the output
                // string will be null terminated also.  Consider the degenerate case of a 2
                // character output buffer and an input string that's a single non-null
                // character followed by a null character.  We're going to trim the size of
                // cchBuffer by 1 so that we manually null-terminate in case the input string
                // was not null-terminated, so MultiByteToWideChar() just writes a single
                // null character to the output buffer since it thinks it must write a null-
                // terminated string.
                //
                // Instead, we'll just always pass in an exact length, not including the null character
                // in the input, and we'll always put the null in place after the conversion succeeds.
                //
                // (this comment is mostly outdated - 11/24/2000 - but the discussion of how the
                // MultiByteToWideChar() API works is worth keeping -mgrier)

                // Since MultiByteToWideChar() takes an "int" length, clamp the maximum
                // value we pass in to 2gb.
                ASSERT2(cchIn <= INT_MAX, "large parameter clamped");
                if (cchIn > INT_MAX)
                    cchIn = INT_MAX;

                INT cch = ::MultiByteToWideChar(cp, dwFlags, szString, static_cast<INT>(cchIn), rgchBuffer, static_cast<INT>(cchBuffer) - 1);
                if ((cch == 0) && (cchBuffer > 1))
                {
                    returnStrategy.SetWin32Bool(FALSE);
                    goto Exit;
                }
                rgchBuffer[cch] = NullCharacter();
            }
            else
                rgchBuffer[0] = NullCharacter();
        }

        returnStrategy.SetWin32Bool(TRUE);
    Exit:
        return returnStrategy.Return();
    }

    // copy into buffer from CHAR to WCHAR
    inline static BOOL Win32CopyIntoBuffer(WCHAR rgchBuffer[], SIZE_T cchBuffer, PCSTR szString, SIZE_T cchIn, UINT cp = CP_THREAD_ACP, DWORD dwFlags = MB_ERR_INVALID_CHARS)
    {
        CReturnStrategyBoolLastError f;
        return CopyIntoBuffer(f, rgchBuffer, cchBuffer, szString, cchIn, cp, dwFlags);
    }

    // copy into buffer from CHAR to WCHAR
    inline static HRESULT CopyIntoBuffer(WCHAR rgchBuffer[], SIZE_T cchBuffer, PCSTR szString, SIZE_T cchIn, UINT cp = CP_THREAD_ACP, DWORD dwFlags = MB_ERR_INVALID_CHARS)
    {
        CReturnStrategyHresult hr;
        return CopyIntoBuffer(hr, rgchBuffer, cchBuffer, szString, cchIn, cp, dwFlags);
    }

    inline static SIZE_T Cch(PCWSTR psz) { return (psz != NULL) ? ::wcslen(psz) : 0; }

};

template <UINT cp = CP_THREAD_ACP> class CMBCSCharTraits : public CCharTraitsBase<CHAR, WCHAR>
{
private:
    typedef CCharTraitsBase<CHAR, WCHAR> Base;
public:
    typedef CHAR TChar;
    typedef LPSTR TMutableString;
    typedef PCSTR TConstantString;

    typedef CUnicodeCharTraits TOtherTraits;
    typedef TOtherTraits::TOtherChar TOtherChar;
    typedef TOtherTraits::TOtherString TOtherString;
    typedef TOtherTraits::TConstantString TOtherConstantString;

    inline static PCSTR DotString() { return "."; }
    inline static SIZE_T DotStringCch() { return 1; }

    // without using, we end up hiding these by providing equally named functions
    using Base::DetermineRequiredCharacters;
    using Base::Win32DetermineRequiredCharacters;
    using Base::CopyIntoBuffer;
    using Base::Win32CopyIntoBuffer;

    // determine characters required for mismatched type (WCHAR -> CHAR)
    template <typename ReturnStrategy>
    inline static ReturnStrategy::ReturnType
    DetermineRequiredCharacters(
            ReturnStrategy &returnStrategy,
            PCWSTR sz,
            SIZE_T cchIn,
            SIZE_T &rcch,
            DWORD dwFlags = 0,
            PCSTR pszDefaultChar = NULL,
            LPBOOL lpUsedDefaultChar = NULL
            )
    {
        if (sz != NULL)
        {
            ASSERT2(cchIn <= INT_MAX, "large parameter clamped");
            ASSERT(cchIn <= INT_MAX);
            if (cchIn > INT_MAX)
                cchIn = INT_MAX;

            INT cch = ::WideCharToMultiByte(cp, dwFlags, sz, static_cast<INT>(cchIn), NULL, 0, pszDefaultChar, lpUsedDefaultChar);
            if ((cch == 0) && (cchIn > 0))
            {
                returnStrategy.SetWin32Bool(FALSE);
                goto Exit;
            }

            rcch = static_cast<SIZE_T>(cch) + 1;
        } else
            rcch = 1;

        returnStrategy.SetWin32Bool(TRUE);
    Exit:
        return returnStrategy.Return();
    }

    inline static SIZE_T NullTerminatedStringLength(PCSTR sz) { return ::strlen(sz); }

    // determine characters required for mismatched type (WCHAR -> CHAR)
    inline static BOOL Win32DetermineRequiredCharacters(PCWSTR sz, SIZE_T cchIn, SIZE_T &rcch, DWORD dwFlags = 0, PCSTR pszDefaultChar = NULL, LPBOOL lpUsedDefaultChar = NULL)
    {
        CReturnStrategyBoolLastError f;
        return DetermineRequiredCharacters(f, sz, cchIn, rcch, dwFlags, pszDefaultChar, lpUsedDefaultChar);
    }

    // determine characters required for mismatched type (WCHAR -> CHAR)
    inline static HRESULT DetermineRequiredCharacters(PCWSTR sz, SIZE_T cchIn, SIZE_T &rcch, DWORD dwFlags = 0, PCSTR pszDefaultChar = NULL, LPBOOL lpUsedDefaultChar = NULL)
    {
        CReturnStrategyHresult hr;
        return DetermineRequiredCharacters(hr, sz, cchIn, rcch, dwFlags, pszDefaultChar, lpUsedDefaultChar);
    }

    // copy into buffer from WCHAR to CHAR
    template <typename ReturnStrategy>
    inline static ReturnStrategy::ReturnType
    CopyIntoBuffer(
        ReturnStrategy &returnStrategy,
        CHAR rgchBuffer[],
        SIZE_T cchBuffer,
        PCWSTR szString,
        SIZE_T cchIn,
        DWORD dwFlags = 0,
        PCSTR pszDefaultChar = NULL,
        LPBOOL lpUsedDefaultChar = NULL
        )
    {
        if (cchBuffer != 0)
        {
            // Clamp the maximum buffer size to maxint, since the buffer size passed in to
            // WideCharToMultiByte() is an INT rather than a SIZE_T or INT_PTR etc.
            // After all, who's really going to have a buffer size > 2gb?  The caller
            // probably just messed up.
            ASSERT2(cchBuffer <= INT_MAX, "large parameter clamped");
            if (cchBuffer > INT_MAX)
                cchBuffer = INT_MAX;

            if (szString != NULL)
            {
                // It would seem that you could just pass the -1 into MultiByteToWideChar(), but
                // you get some errors on the boundary conditions, because -1 implies that you
                // want to consider the null termination on the input string, and the output
                // string will be null terminated also.  Consider the degenerate case of a 2
                // character output buffer and an input string that's a single non-null
                // character followed by a null character.  We're going to trim the size of
                // cchBuffer by 1 so that we manually null-terminate in case the input string
                // was not null-terminated, so MultiByteToWideChar() just writes a single
                // null character to the output buffer since it thinks it must write a null-
                // terminated string.
                //
                // Instead, we'll just always pass in an exact length, not including the null character
                // in the input, and we'll always put the null in place after the conversion succeeds.
                //

                ASSERT2(cchIn <= INT_MAX, "large parameter clamped");
                if (cchIn > INT_MAX)
                    cchIn = INT_MAX;

                INT cch = ::WideCharToMultiByte(cp, dwFlags, szString, static_cast<INT>(cchIn), rgchBuffer, static_cast<INT>(cchBuffer - 1), pszDefaultChar, lpUsedDefaultChar);
                if ((cch == 0) && (cchBuffer > 1))
                {
                    returnStrategy.SetWin32Bool(FALSE);
                    goto Exit;
                }

                rgchBuffer[cch] = NullCharacter();
            }
            else
                rgchBuffer[0] = NullCharacter();
        }
        returnStrategy.SetWin32Bool(TRUE);
    Exit:
        return returnStrategy.Return();
    }

    // copy into buffer from WCHAR to CHAR
    inline static HRESULT CopyIntoBuffer(CHAR rgchBuffer[], SIZE_T cchBuffer, PCWSTR szString, SIZE_T cchIn, DWORD dwFlags = 0, PCSTR pszDefaultChar = NULL, LPBOOL lpUsedDefaultChar = NULL)
    {
        CReturnStrategyHresult hr;
        return CopyIntoBuffer(hr, rgchBuffer, cchBuffer, szString, cchIn, dwFlags, pszDefaultChar, lpUsedDefaultChar);
    }

    // copy into buffer from WCHAR to CHAR
    inline static BOOL Win32CopyIntoBuffer(CHAR rgchBuffer[], SIZE_T cchBuffer, PCWSTR szString, SIZE_T cchIn, DWORD dwFlags = 0, PCSTR pszDefaultChar = NULL, LPBOOL lpUsedDefaultChar = NULL)
    {
        CReturnStrategyBoolLastError f;
        return CopyIntoBuffer(f, rgchBuffer, cchBuffer, szString, cchIn, dwFlags, pszDefaultChar, lpUsedDefaultChar);
    }

    inline static SIZE_T Cch(PCSTR psz) { return ::strlen(psz); }

};

typedef CMBCSCharTraits<CP_THREAD_ACP> CANSICharTraits;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusioneventlog.h ===
#pragma once

#if !defined(NT_INCLUDED) && defined(_WINDOWS_)
#error You must not include windows.h before this.
#endif
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include <limits.h>
#include "debmacro.h"
#include "FusionString.h"
#include "messages.h"
#include "numberof.h"
#include <ole2.h>
#include <xmlparser.h>
#include "fusionbuffer.h"
#include <sxstypes.h>
#include "util.h"

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

typedef struct _SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE;

BOOL
FusionpEventLogMain(
    HINSTANCE,
    DWORD dwReason,
    PVOID pvReserved
    );

HRESULT
FusionpLogError(
    DWORD dwEventId,
    const UNICODE_STRING& s1,
    const UNICODE_STRING& s2 = g_strEmptyUnicodeString,
    const UNICODE_STRING& s3 = g_strEmptyUnicodeString,
    const UNICODE_STRING& s4 = g_strEmptyUnicodeString
    );

HRESULT
FusionpLogError(
    DWORD dwEventId,
    ULONG nStrings = 0,
    UNICODE_STRING const* const* rgps = NULL
    );

HRESULT
FusionpLogErrorToEventLog(
    DWORD dwEventId,
    const UNICODE_STRING& s1,
    const UNICODE_STRING& s2 = g_strEmptyUnicodeString,
    const UNICODE_STRING& s3 = g_strEmptyUnicodeString,
    const UNICODE_STRING& s4 = g_strEmptyUnicodeString
    );

HRESULT
FusionpLogErrorToEventLog(
    DWORD dwEventId,
    ULONG nStrings = 0,
    UNICODE_STRING const* const* rgps = NULL
    );

HRESULT
FusionpLogErrorToDebugger(
    DWORD dwEventId,
    const UNICODE_STRING& s1,
    const UNICODE_STRING& s2 = g_strEmptyUnicodeString,
    const UNICODE_STRING& s3 = g_strEmptyUnicodeString,
    const UNICODE_STRING& s4 = g_strEmptyUnicodeString
    );

HRESULT
FusionpLogErrorToDebugger(
    DWORD dwEventId,
    ULONG nStrings = 0,
    UNICODE_STRING const* const* rgps = NULL
    );

HRESULT
FusionpLogParseError(
    PCWSTR FilePath,
    SIZE_T FilePathCch,
    ULONG LineNumber,
    DWORD dwLastParseError,
    const UNICODE_STRING *p1 = NULL,
    const UNICODE_STRING *p2 = NULL,
    const UNICODE_STRING *p3 = NULL,
    const UNICODE_STRING *p4 = NULL,
    const UNICODE_STRING *p5 = NULL,
    const UNICODE_STRING *p6 = NULL,
    const UNICODE_STRING *p7 = NULL,
    const UNICODE_STRING *p8 = NULL,
    const UNICODE_STRING *p9 = NULL,
    const UNICODE_STRING *p10 = NULL,
    const UNICODE_STRING *p11 = NULL,
    const UNICODE_STRING *p12 = NULL,
    const UNICODE_STRING *p13 = NULL,
    const UNICODE_STRING *p14 = NULL,
    const UNICODE_STRING *p15 = NULL,
    const UNICODE_STRING *p16 = NULL,
    const UNICODE_STRING *p17 = NULL,
    const UNICODE_STRING *p18 = NULL,
    const UNICODE_STRING *p19 = NULL,
    const UNICODE_STRING *p20 = NULL
    );

DWORD
FusionpEventIdToError(
    DWORD dwEventId
    );

VOID
FusionpLogRequiredAttributeMissingParseError(
    PCWSTR SourceFilePath,
    SIZE_T SourceFileCch,
    ULONG LineNumber,
    PCWSTR ElementName,
    SIZE_T ElementNameCch,
    PCWSTR AttributeName,
    SIZE_T AttributeNameCch
    );

VOID
FusionpLogInvalidAttributeValueParseError(
    PCWSTR SourceFilePath,
    SIZE_T SourceFileCch,
    ULONG LineNumber,
    PCWSTR ElementName,
    SIZE_T ElementNameCch,
    PCWSTR AttributeName,
    SIZE_T AttributeNameCch
    );

VOID
FusionpLogInvalidAttributeValueParseError(
    PCWSTR SourceFilePath,
    SIZE_T SourceFileCch,
    ULONG LineNumber,
    PCWSTR ElementName,
    SIZE_T ElementNameCch,
    const SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE &rAttribute
    );

VOID
FusionpLogAttributeNotAllowedParseError(
    PCWSTR SourceFilePath,
    SIZE_T SourceFileCch,
    ULONG LineNumber,
    PCWSTR ElementName,
    SIZE_T ElementNameCch,
    PCWSTR AttributeName,
    SIZE_T AttributeNameCch
    );

VOID
FusionpLogWin32ErrorToEventLog(
    );

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

typedef CUnicodeString CEventLogString;

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

// sizeof(__int64)*CHAR_BIT is big enough to format an __int64,
// it's enough of an overestimate for negative decimals, 0x prefixed
// hex, and the terminal nul; I don't know about octal.
//
// Using this to log GetLastError may truncate some characters,
// but we'll always have a terminal nul.
typedef CUnicodeStringN<sizeof(ULONGLONG)*CHAR_BIT> CEventLogBuffer;

// but this size is not enough for LastError LogBuffer
typedef CUnicodeStringN<160> CEventLogBufferLastError;

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/
class CEventLogInteger : public CEventLogBuffer
{
public:
    explicit CEventLogInteger(LONGLONG i);
    ~CEventLogInteger() { }

private: // deliberately not implemented
    CEventLogInteger();
    CEventLogInteger(const CEventLogInteger&);
    void operator=(const CEventLogInteger&);
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

class CEventLogHex : public CEventLogBuffer
{
public:
    explicit CEventLogHex(LONGLONG i);
    ~CEventLogHex() { }

    LONGLONG m_i;

private: // deliberately not implemented
    CEventLogHex();
    CEventLogHex(const CEventLogHex&);
    void operator=(const CEventLogHex&);
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

class CEventLogHResult : public CEventLogBuffer
{
public:
    explicit CEventLogHResult(HRESULT hr);
    ~CEventLogHResult() { }

    HRESULT m_hresult;

private: // deliberately not implemented
    CEventLogHResult();
    CEventLogHResult(const CEventLogHResult&);
    void operator=(const CEventLogHResult&);
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

class CEventLogLastError : public CEventLogBufferLastError
{
public:
    CEventLogLastError();
    CEventLogLastError(DWORD dwLastError);
    ~CEventLogLastError() { }

private: // deliberately not implemented
    CEventLogLastError(const CEventLogLastError&);
    void operator=(const CEventLogLastError&);
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

inline CEventLogInteger::CEventLogInteger(LONGLONG i)
{
    _i64tow(i, m_rgchBuffer, 10);
    Sync();
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

inline CEventLogHex::CEventLogHex(LONGLONG i)
{
    m_rgchBuffer[0] = '0';
    m_rgchBuffer[1] = 'x';
    _i64tow(i, &m_rgchBuffer[2], 16);
    // CONSIDER _wcsupr(m_psz+2);
    Sync();
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

inline CEventLogHResult::CEventLogHResult(HRESULT hr)
{
    Format(L"hr = %#08lx", static_cast<ULONG>(hr));
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

class CEventLogProcessorArchitecture :
public CUnicodeStringN<MAX_PATH + sizeof(int)*CHAR_BIT + 3>
{
public:
    ~CEventLogProcessorArchitecture() { }

    explicit CEventLogProcessorArchitecture(USHORT usProcessorArchitecture)
    {
        CSmallStringBuffer buffer;
        ::FusionpFormatProcessorArchitecture(usProcessorArchitecture, buffer);
        this->Format(L"%d(%ls)", usProcessorArchitecture, static_cast<PCWSTR>(buffer));
    }

private:
    // deliberately not implemented
    CEventLogProcessorArchitecture();
    CEventLogProcessorArchitecture(const CEventLogProcessorArchitecture&);
    void operator=(const CEventLogProcessorArchitecture&);
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

class CEventLogAssemblyVersion : public CUnicodeStringN<4*sizeof(unsigned)*CHAR_BIT+4>
{
public:
    ~CEventLogAssemblyVersion() { }

    explicit CEventLogAssemblyVersion(const ASSEMBLY_VERSION& av)
    {
        unsigned major = av.Major;
        unsigned minor = av.Minor;
        unsigned revision = av.Revision;
        unsigned build = av.Build;
        Format(L"%u.%u.%u.%u", major, minor, revision, build);
    }

private:  // deliberately not implemented
    CEventLogAssemblyVersion();
    CEventLogAssemblyVersion(const CEventLogAssemblyVersion&);
    void operator=(const CEventLogAssemblyVersion&);
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

class CEventLogLanguageName : public CUnicodeString
{
private:
    typedef CUnicodeString base;
public:
    ~CEventLogLanguageName() { }

    explicit CEventLogLanguageName(LANGID languageId)
    {
        ::FusionpFormatEnglishLanguageName(languageId, m_buffer);
        (*this) = static_cast<PCWSTR>(m_buffer);
    }

    void operator=(PCWSTR sz)
    {
        base::operator=(sz);
    }

private:
    CSmallStringBuffer m_buffer;

    // deliberately not implemented
    CEventLogLanguageName();
    CEventLogLanguageName(const CEventLogLanguageName&);
    void operator=(const CEventLogLanguageName&);
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

class CEventLogFileCopyCallbackDisposition
{
public:
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusiondequelinkage.h ===
#if !defined(_FUSION_INC_FUSIONDEQUELINKAGE_H_INCLUDED_)
#define _FUSION_INC_FUSIONDEQUELINKAGE_H_INCLUDED_

#pragma once

#include "fusiontrace.h"

class CDequeBase;

class CDequeLinkage : protected LIST_ENTRY
{
    friend CDequeBase;

public:
    inline CDequeLinkage() : m_pDeque(NULL), m_ulLockCount(0) { this->Flink = NULL; this->Blink = NULL; }
    inline ~CDequeLinkage() { ASSERT_NTC(m_ulLockCount == 0); m_pDeque = NULL; }

    inline bool IsNotLocked() const { return (m_ulLockCount == 0); }
    inline VOID Lock() { m_ulLockCount++; }
    inline VOID Unlock() { m_ulLockCount--; }

    inline VOID Remove() { this->Flink->Blink = this->Flink; this->Blink->Flink = this->Flink; }

protected:
    inline VOID InitializeHead(CDequeBase *pDequeBase) { ASSERT_NTC(pDequeBase != NULL); this->Flink = this; this->Blink = this; this->m_pDeque = pDequeBase; }
    inline CDequeLinkage *GetFlink() const { return static_cast<CDequeLinkage *>(this->Flink); }
    inline CDequeLinkage *GetBlink() const { return static_cast<CDequeLinkage *>(this->Blink); }

    inline CDequeBase *GetDequeBase() const { return m_pDeque; }
    inline VOID SetDeque(CDequeBase *pDeque) { m_pDeque = pDeque; }

    inline VOID SetFlink(CDequeLinkage *pFlink) { this->Flink = pFlink; }
    inline VOID SetBlink(CDequeLinkage *pBlink) { this->Blink = pBlink; }

    CDequeBase *m_pDeque;

    // m_ulLockCount is incremented when an iterator is positioned on an entry, to stop
    // it from being deleted.  Note that no interlocked synchronization is attempted;
    // this is merely to stop blatent programming errors.  If you want multithreaded
    // access to the deque, you need to provide your own synchronization.
    ULONG m_ulLockCount;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionfacilities.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fusionfacilities.h

Abstract:

    Include file that is included MULTIPLE TIMES to get varying effects
    of defining global variables vs. references to those global variables
    vs. symbols that you can use when writing output to scope it to
    a facility.

Author:

    Michael J. Grier (MGrier) 7/28/2000

Revision History:

--*/

//
//  NO INCLUSION PROTECTION!!! BY DESIGN!!!
//
//  NO PRAGMA ONCE PLEASE!!
//

#if !defined(FUSION_FACILITY_MASK_NAME)
#define FUSION_FACILITY_MASK_NAME(_x) g_FUSION_ ## _x ## _MASK
#endif

#if defined(FUSION_DEFINE_FACILITY_MASK_VARIABLE_DEFS)

#if !defined(FUSION_FACILITY_VARIABLE_DEFS_DEFINED)
#define FUSION_FACILITY_BEFORE_FACILITIES() /* nothing */
#define FUSION_FACILITY(_facname) DWORD FUSION_FACILITY_MASK_NAME(_facname);
#define FUSION_FACILITY_AFTER_FACILITIES() /* nothing */
#define FUSION_FACILITY_VARIABLE_DEFS_DEFINED 1
#else
#define FUSION_FACILITY_BEFORE_FACILITIES() /* nothing */
#define FUSION_FACILITY(_facname) /* nothing */
#define FUSION_FACILITY_AFTER_FACILITIES() /* nothing */
#endif

#elif defined(FUSION_DEFINE_FACILITY_MASK_VARIABLE_ARRAY)

#if !defined(FUSION_FACILITY_MASK_VARIABLE_ARRAY_DEFINED)
#define FUSION_FACILITY_BEFORE_FACILITIES() static const DWORD *s_rgFusionFacilityMasks[] = {
#define FUSION_FACILITY(_facname) &FUSION_FACILITY_MASK_NAME(_facname),
#define FUSION_FACILITY_AFTER_FACILITIES() };
#define FUSION_FACILITY_MASK_VARIABLE_ARRAY_DEFINED 1
#else
#define FUSION_FACILITY_BEFORE_FACILITIES() /* nothing */
#define FUSION_FACILITY(_facname) /* nothing */
#define FUSION_FACILITY_AFTER_FACILITIES() /* nothing */
#endif

#elif defined(FUSION_DEFINE_FACILITY_STRUCTURE)

#if !defined(FUSION_FACILITY_STRUCTURE_DEFINED)
#define FUSION_FACILITY_BEFORE_FACILITIES() class CFusionFacilityList { public:
#define FUSION_FACILITY(_facname) char _facname;
#define FUSION_FACILITY_AFTER_FACILITIES() };
#define FUSION_FACILITY_STRUCTURE_DEFINED 1
#else
#define FUSION_FACILITY_BEFORE_FACILITIES() /* nothing */
#define FUSION_FACILITY(_facname) /* nothing */
#define FUSION_FACILITY_AFTER_FACILITIES() /* nothing */
#endif

#elif defined(FUSION_DEFINE_FACILITY_MASK_VARIABLE_REFS)

#if !defined(FUSION_FACILITY_VARIABLE_REFS_DEFINED)
#define FUSION_FACILITY_BEFORE_FACILITIES() /* nothing */
#define FUSION_FACILITY(_facname) EXTERN_C DWORD FUSION_FACILITY_MASK_NAME(_facname);
#define FUSION_FACILITY_AFTER_FACILITIES() /* nothing */
#define FUSION_FACILITY_VARIABLE_REFS_DEFINED 1
#else
#define FUSION_FACILITY_BEFORE_FACILITIES() /* nothing */
#define FUSION_FACILITY(_facname) /* nothing */
#define FUSION_FACILITY_AFTER_FACILITIES() /* nothing */
#endif

#elif defined(FUSION_DEFINE_FACILITY_CONSTANTS)

#if !defined(FUSION_FACILITY_CONSTANTS_DEFINED)
#define FUSION_DEFINE_FACILITY_STRUCTURE
#include "fusionfacilities.h"
#undef FUSION_DEFINE_FACILITY_STRUCTURE
#undef FUSION_FACILITY_BEFORE_FACILITIES
#undef FUSION_FACILITY
#undef FUSION_FACILITY_AFTER_FACILITIES

#define FUSION_DEFINE_FACILITY_MASK_VARIABLE_REFS
#include "fusionfacilities.h"
#undef FUSION_DEFINE_FACILITY_MASK_VARIABLE_REFS
#undef FUSION_FACILITY_BEFORE_FACILITIES
#undef FUSION_FACILITY
#undef FUSION_FACILITY_AFTER_FACILITIES

#define FUSION_FACILITY_BEFORE_FACILITIES() /* nothing */
#define FUSION_FACILITY(_facname) const ULONG FUSION_ ## _facname ## _ID = ((ULONG) FIELD_OFFSET(CFusionFacilityList, _facname));
#define FUSION_FACILITY_AFTER_FACILITIES() /* nothing */

#define FUSION_FACILITY_CONSTANTS_DEFINED 1
#else
#define FUSION_FACILITY_BEFORE_FACILITIES() /* nothing */
#define FUSION_FACILITY(_facname) /* nothing */
#define FUSION_FACILITY_AFTER_FACILITIES() /* nothing */
#endif

#elif defined(FUSION_DEFINE_FACILITY_DLLMAIN_DEFS)

#if !defined(FUSION_FACILITY_DLLMAIN_DEFS_DEFINED)

#define FUSION_DEFINE_FACILITY_CONSTANTS
#include "fusionfacilities.h"
#undef FUSION_DEFINE_FACILITY_CONSTANTS
#undef FUSION_FACILITY_BEFORE_FACILITIES
#undef FUSION_FACILITY
#undef FUSION_FACILITY_AFTER_FACILITIES

#define FUSION_DEFINE_FACILITY_MASK_VARIABLE_DEFS
#include "fusionfacilities.h"
#undef FUSION_DEFINE_FACILITY_MASK_VARIABLE_DEFS
#undef FUSION_FACILITY_BEFORE_FACILITIES
#undef FUSION_FACILITY
#undef FUSION_FACILITY_AFTER_FACILITIES

#define FUSION_DEFINE_FACILITY_MASK_VARIABLE_ARRAY
#include "fusionfacilities.h"
#undef FUSION_DEFINE_FACILITY_MASK_VARIABLE_ARRAY
#undef FUSION_FACILITY_BEFORE_FACILITIES
#undef FUSION_FACILITY
#undef FUSION_FACILITY_AFTER_FACILITIES

#define FUSION_FACILITY_DLLMAIN_DEFS_DEFINED 1
#endif

#define FUSION_FACILITY_BEFORE_FACILITIES() /* nothing */
#define FUSION_FACILITY(_facname) /* nothing */
#define FUSION_FACILITY_AFTER_FACILITIES() /* nothing */

#else

#define FUSION_DEFINE_FACILITY_CONSTANTS
#include "fusionfacilities.h"
#undef FUSION_DEFINE_FACILITY_CONSTANTS

#undef FUSION_FACILITY_BEFORE_FACILITIES
#undef FUSION_FACILITY
#undef FUSION_FACILITY_AFTER_FACILITIES

#define FUSION_FACILITY_BEFORE_FACILITIES() /* nothing */
#define FUSION_FACILITY(_facname) /* nothing */
#define FUSION_FACILITY_AFTER_FACILITIES() /* nothing */

#endif

//
//  Add fusion facility definitions here:
//

FUSION_FACILITY_BEFORE_FACILITIES()

FUSION_FACILITY(HASH_TABLE)
FUSION_FACILITY(DEQUE)
FUSION_FACILITY(STRING_BUFFER)
FUSION_FACILITY(BINDING)
FUSION_FACILITY(POLICY)

FUSION_FACILITY_AFTER_FACILITIES()

#undef FUSION_FACILITY_BEFORE_FACILITIES
#undef FUSION_FACILITY
#undef FUSION_FACILITY_AFTER_FACILITIES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionguiddatatoxxx.h ===
/*-----------------------------------------------------------------------------
Microsoft FUSION

Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

@doc external
@module fusionguiddatatoxxx.h

Macros to convert "guid data", of the
form (3f32766f, 2d94, 444d, bf,32,2f,32,9c,71,d4,08), to all of the various
needed forms:
  3f32766f-2d94-444d-bf32-2f329c71d408                               FUSIONP_GUID_DATA_TO_DASHED
 '3f32766f-2d94-444d-bf32-2f329c71d408'                              FUSIONP_GUID_DATA_TO_DASHED_CHAR
 "3f32766f-2d94-444d-bf32-2f329c71d408"                              FUSIONP_GUID_DATA_TO_DASHED_STRING
 {3f32766f-2d94-444d-bf32-2f329c71d408}                              FUSIONP_GUID_DATA_TO_BRACED_DASHED
'{3f32766f-2d94-444d-bf32-2f329c71d408}'                             FUSIONP_GUID_DATA_TO_BRACED_DASHED_CHAR
"{3f32766f-2d94-444d-bf32-2f329c71d408}"                             FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING
{0x3f32766f,0x2d94,0x444d,{0xbf,0x32,0x2f,0x32,0x9c,0x71,0xd4,0x08}} FUSIONP_GUID_DATA_TO_STRUCT_INITIALIZER

@owner JayKrell
-----------------------------------------------------------------------------*/
#if !defined(FUSIONP_GUID_DATA_TO_XXX_H_INCLUDED_)
#define FUSIONP_GUID_DATA_TO_XXX_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#include "fusionpreprocessorpaste.h"
#include "fusionpreprocessorstringize.h"
#include "fusionpreprocessorcharize.h"

/*-----------------------------------------------------------------------------
I need to investigate more, but present usage is:

FUSIONP_GUID_DATA_TO_DASHED_STRING : __declpec(uuid())
FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING : also works with__declpec(uuid())
FUSIONP_GUID_DATA_TO_BRACED_DASHED : in .rgs files (unquoted)
FUSIONP_GUID_DATA_TO_STRUCT_INITIALIZER : would be used in .ctc files
FUSIONP_GUID_DATA_TO_BRACED_DASHED_CHAR : used in .rgs files (quoted)

-----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
Name: FUSIONP_GUID_DATA_TO_STRUCT_INITIALIZER
@macro
This macro does like:
FUSIONP_GUID_DATA_TO_STRUCT_INITIALIZER(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> { 0x80f3e6ba, 0xd9b2, 0x4c41, { 0xae, 0x90, 0x63, 0x93, 0xda, 0xce, 0xac, 0x2a } }

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
FUSIONP_GUID_DATA_TO_STRUCT_INITIALIZER\
( \
	dwData1,  \
	 wData2,  \
	 wData3,  \
	bData4_0, \
	bData4_1, \
	bData4_2, \
	bData4_3, \
	bData4_4, \
	bData4_5, \
	bData4_6, \
	bData4_7  \
) \
{ \
	FusionpPreprocessorPaste2(0x, dwData1), \
	FusionpPreprocessorPaste2(0x,  wData2), \
	FusionpPreprocessorPaste2(0x,  wData3), \
	{ \
		FusionpPreprocessorPaste2(0x, bData4_0), \
		FusionpPreprocessorPaste2(0x, bData4_1), \
		FusionpPreprocessorPaste2(0x, bData4_2), \
		FusionpPreprocessorPaste2(0x, bData4_3), \
		FusionpPreprocessorPaste2(0x, bData4_4), \
		FusionpPreprocessorPaste2(0x, bData4_5), \
		FusionpPreprocessorPaste2(0x, bData4_6), \
		FusionpPreprocessorPaste2(0x, bData4_7)  \
	} \
}

/*-----------------------------------------------------------------------------
Name: FUSIONP_GUID_DATA_TO_DASHED
@macro
This macro does like:
FUSIONP_GUID_DATA_TO_DASHED(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> 80f3e6ba-d9b2-4c41-ae90-6393daceac2a

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
FUSIONP_GUID_DATA_TO_DASHED\
( \
	dwData1,  \
	 wData2,  \
	 wData3,  \
	bData4_0, \
	bData4_1, \
	bData4_2, \
	bData4_3, \
	bData4_4, \
	bData4_5, \
	bData4_6, \
	bData4_7  \
) \
FusionpPreprocessorPaste15(dwData1,-,wData2,-,wData3,-,bData4_0,bData4_1,-,bData4_2,bData4_3,bData4_4,bData4_5,bData4_6,bData4_7)

// without braces

/*-----------------------------------------------------------------------------
Name: FUSIONP_GUID_DATA_TO_DASHED_STRING
@macro
FUSIONP_GUID_DATA_TO_DASHED_STRING(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> "80f3e6ba-d9b2-4c41-ae90-6393daceac2a"

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
FUSIONP_GUID_DATA_TO_DASHED_STRING\
( \
	dw1,  \
	 w2,  \
	 w3,  \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	FusionpPreprocessorStringize(FUSIONP_GUID_DATA_TO_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7))

/*-----------------------------------------------------------------------------
Name: FUSIONP_GUID_DATA_TO_DASHED_CHAR
@macro
FUSIONP_GUID_DATA_TO_DASHED_CHAR(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> '80f3e6ba-d9b2-4c41-ae90-6393daceac2a'

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
FUSIONP_GUID_DATA_TO_DASHED_CHAR\
( \
	dw1,  \
	 w2,  \
	 w3,  \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	FusionpPreprocessorCharize(FUSIONP_GUID_DATA_TO_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7))

// with braces

/*-----------------------------------------------------------------------------
Name: FUSIONP_GUID_DATA_TO_BRACED_DASHED
@macro
FUSIONP_GUID_DATA_TO_BRACED_DASHED(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> {80f3e6ba-d9b2-4c41-ae90-6393daceac2a}

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
FUSIONP_GUID_DATA_TO_BRACED_DASHED\
( \
	dw1, \
	 w2, \
	 w3, \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	FusionpPreprocessorPaste3({,FUSIONP_GUID_DATA_TO_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7),})

/*-----------------------------------------------------------------------------
Name: FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING
@macro
FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> "{80f3e6ba-d9b2-4c41-ae90-6393daceac2a}"

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING\
( \
	dw1, \
	 w2, \
	 w3, \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	FusionpPreprocessorStringize(FUSIONP_GUID_DATA_TO_BRACED_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7))

/*-----------------------------------------------------------------------------
Name: FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING_W
@macro
FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING_W(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> L"{80f3e6ba-d9b2-4c41-ae90-6393daceac2a}"

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING_W(dw1, w2, w3, b0, b1, b2, b3, b4, b5, b6, b7) \
	FusionpPreprocessorPaste(L, FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING(dw1, w2, w3, b0, b1, b2, b3, b4, b5, b6, b7))

/*-----------------------------------------------------------------------------
Name: FUSIONP_GUID_DATA_TO_BRACED_DASHED_CHAR
@macro
FUSIONP_GUID_DATA_TO_BRACED_DASHED_CHAR(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> '{80f3e6ba-d9b2-4c41-ae90-6393daceac2a}'

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
FUSIONP_GUID_DATA_TO_BRACED_DASHED_CHAR\
( \
	dw1, \
	 w2, \
	 w3, \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	FusionpPreprocessorCharize(FUSIONP_GUID_DATA_TO_BRACED_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7))

#endif /* FUSIONP_GUID_DATA_TO_XXX_H_INCLUDED_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionguids.h ===
// Copyright (c) Microsoft Corporation
/*
All guids appear in this file, and only once.
No guids appear anywhere else.
All forms of guids can be generated from this file, using the
  macros in fusionguiddatatoxxx.h.
This helps greatly in the ability to reguid.
*/

#if !defined(FUSION_GUIDS_H_INCLUDED_)
#define FUSION_GUIDS_H_INCLUDED_
/* no #pragma once here, deliberately, to not mess up preprocessed files that aren't C/C++ */

#include "fusionguiddatatoxxx.h"
#if defined(__midl)
cpp_quote("#if !defined(FUSION_GUIDS_H_INCLUDED_)")
cpp_quote("#include \"fusionguids.h\"")
cpp_quote("#endif")
#endif

#define IID_IUnknown_data                       (00000000, 0000, 0000, C0, 00, 00, 00, 00, 00, 00, 46)

#define IID_ISxsTest_FreeThreaded_data          (f0554958, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define IID_ISxsTest_SingleThreaded_data        (f0554959, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define IID_ISxsTest_ApartmentThreaded_data     (f055495a, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxsTest_FreeThreaded_data        (f055495b, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxsTest_SingleThreaded_data      (f055495c, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxsTest_ApartmentThreaded_data   (f055495e, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define LIBID_SxsTest_Lib_data                  (f055495f, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define IID_ISxsTest_BothThreaded_data          (f0554960, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxsTest_BothThreaded_data        (f0554961, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define IID_ISxsTest_SingleThreadedDual_data    (f0554962, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxsTest_SingleThreadedDual_data  (f0554963, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)

#define OLEAUT_IDISPATCH_PROXY_STUB_CLSID_data  (00020420, 0000, 0000, C0, 00, 00, 00, 00, 00, 00, 46)
#define OLEAUT_PROXY_STUB_CLSID_data            (00020424, 0000, 0000, C0, 00, 00, 00, 00, 00, 00, 46)

/*----------------------------------------------------------------------------------------------------*/

#define IID_ISxsTest_FreeThreaded_midl                  FUSIONP_GUID_DATA_TO_DASHED IID_ISxsTest_FreeThreaded_data
#define IID_ISxsTest_SingleThreaded_midl                FUSIONP_GUID_DATA_TO_DASHED IID_ISxsTest_SingleThreaded_data
#define IID_ISxsTest_ApartmentThreaded_midl             FUSIONP_GUID_DATA_TO_DASHED IID_ISxsTest_ApartmentThreaded_data
#define CLSID_CSxsTest_FreeThreaded_midl                FUSIONP_GUID_DATA_TO_DASHED CLSID_CSxsTest_FreeThreaded_data
#define CLSID_CSxsTest_SingleThreaded_midl              FUSIONP_GUID_DATA_TO_DASHED CLSID_CSxsTest_SingleThreaded_data
#define CLSID_CSxsTest_ApartmentThreaded_midl           FUSIONP_GUID_DATA_TO_DASHED CLSID_CSxsTest_ApartmentThreaded_data
#define LIBID_SxsTest_Lib_midl                          FUSIONP_GUID_DATA_TO_DASHED LIBID_SxsTest_Lib_data
#define IID_ISxsTest_BothThreaded_midl                  FUSIONP_GUID_DATA_TO_DASHED IID_ISxsTest_BothThreaded_data
#define CLSID_CSxsTest_BothThreaded_midl                FUSIONP_GUID_DATA_TO_DASHED CLSID_CSxsTest_BothThreaded_data

#define IID_ISxsTest_FreeThreaded_rgs                   FUSIONP_GUID_DATA_TO_BRACED_DASHED IID_ISxsTest_FreeThreaded_data
#define IID_ISxsTest_SingleThreaded_rgs                 FUSIONP_GUID_DATA_TO_BRACED_DASHED IID_ISxsTest_SingleThreaded_data
#define IID_ISxsTest_ApartmentThreaded_rgs              FUSIONP_GUID_DATA_TO_BRACED_DASHED IID_ISxsTest_ApartmentThreaded_data
#define CLSID_CSxsTest_FreeThreaded_rgs                 FUSIONP_GUID_DATA_TO_BRACED_DASHED CLSID_CSxsTest_FreeThreaded_data
#define CLSID_CSxsTest_SingleThreaded_rgs               FUSIONP_GUID_DATA_TO_BRACED_DASHED CLSID_CSxsTest_SingleThreaded_data
#define CLSID_CSxsTest_ApartmentThreaded_rgs            FUSIONP_GUID_DATA_TO_BRACED_DASHED CLSID_CSxsTest_ApartmentThreaded_data
#define LIBID_SxsTest_Lib_rgs                           FUSIONP_GUID_DATA_TO_BRACED_DASHED LIBID_SxsTest_Lib_data
#define IID_ISxsTest_BothThreaded_rgs                   FUSIONP_GUID_DATA_TO_BRACED_DASHED IID_ISxsTest_BothThreaded_data
#define CLSID_CSxsTest_BothThreaded_rgs                 FUSIONP_GUID_DATA_TO_BRACED_DASHED CLSID_CSxsTest_BothThreaded_data

#define IID_ISxsTest_SingleThreaded_manifest            FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING IID_ISxsTest_SingleThreaded_data
#define LIBID_SxsTest_Lib_manifest                      FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING LIBID_SxsTest_Lib_data
#define IID_IUnknown_manifest                           FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING IID_IUnknown_data
#define CLSID_CSxsTest_SingleThreaded_manifest          FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING CLSID_CSxsTest_SingleThreaded_data

#define IID_ISxsTest_SingleThreadedDual_midl            FUSIONP_GUID_DATA_TO_DASHED IID_ISxsTest_SingleThreadedDual_data
#define CLSID_CSxsTest_SingleThreadedDual_midl          FUSIONP_GUID_DATA_TO_DASHED CLSID_CSxsTest_SingleThreadedDual_data
#define IID_ISxsTest_SingleThreadedDual_rgs             FUSIONP_GUID_DATA_TO_BRACED_DASHED IID_ISxsTest_SingleThreadedDual_data
#define CLSID_CSxsTest_SingleThreadedDual_rgs           FUSIONP_GUID_DATA_TO_BRACED_DASHED CLSID_CSxsTest_SingleThreadedDual_data
#define IID_ISxsTest_SingleThreadedDual_manifest        FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING IID_ISxsTest_SingleThreadedDual_data
#define CLSID_CSxsTest_SingleThreadedDual_manifest      FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING CLSID_CSxsTest_SingleThreadedDual_data

#define OLEAUT_PROXY_STUB_CLSID_manifest                FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING OLEAUT_PROXY_STUB_CLSID_data
#define OLEAUT_PROXY_STUB_CLSID_structInit              FUSIONP_GUID_DATA_TO_STRUCT_INITIALIZER   OLEAUT_PROXY_STUB_CLSID_data
#define OLEAUT_IDISPATCH_PROXY_STUB_CLSID_manifest      FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING OLEAUT_IDISPATCH_PROXY_STUB_CLSID_data
#define OLEAUT_IDISPATCH_PROXY_STUB_CLSID_structInit    FUSIONP_GUID_DATA_TO_STRUCT_INITIALIZER   OLEAUT_IDISPATCH_PROXY_STUB_CLSID_data

#define CLSID_CSxsTest_BothThreaded_manifest           FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING CLSID_CSxsTest_BothThreaded_data

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionhash.h ===
#if !defined(_FUSION_INC_FUSIONHASH_H_INCLUDED_)
#define _FUSION_INC_FUSIONHASH_H_INCLUDED_

#pragma once

#include "fusionheap.h"
#include "fusionbuffer.h"
#include "fusionchartraits.h"
#include "fusiondeque.h"

#define T2P(x, y) < x , y >

#pragma warning(disable:4327)  // indirection alignment of LHS (16) is greater than RHS (8)
#pragma warning(disable:4328)  // indirection alignment of formal parameter 2 (16) is greater than the actual argument alignment (8)

enum InsertOrUpdateIfDisposition
{
    eUpdateValue,
    eLeaveValueAlone,
};

template <typename TPassed, class TStored> inline BOOL HashTableCompareKey(TPassed tpassed, const TStored &rtstored, bool &rfMatch)
{
    return rtstored.Compare(tpassed, rfMatch);
}

template<> inline BOOL HashTableCompareKey<REFGUID, GUID>(REFGUID rguid, const GUID &rguidstored, bool &rfMatch)
{
    rfMatch = ((rguid == rguidstored) != 0);
    return TRUE;
}

template <typename TPassed> inline BOOL HashTableHashKey(TPassed tpassed, ULONG &rulPseudoKey);

// common override for GUID-indexed tables
template<> inline BOOL HashTableHashKey<REFGUID>(REFGUID rguid, ULONG &rulPseudoKey)
{
    rulPseudoKey = rguid.Data1;
    return TRUE;
}

template <typename TPassed, class TStored> inline BOOL HashTableInitializeKey(TPassed tpassed, TStored &rtstored)
{
    return rtstored.Initialize(tpassed);
}

// common override for GUID-indexed tables
template<> inline BOOL HashTableInitializeKey<REFGUID, GUID>(REFGUID rguidIn, GUID &rguidOut)
{
    rguidOut = rguidIn;
    return TRUE;
}

template <typename TPassed, class TStored> inline BOOL HashTableInitializeValue(TPassed tpassed, TStored &rtstored)
{
    return rtstored.Initialize(tpassed);
}

template <typename TPassed, class TStored> inline BOOL HashTableUpdateValue(TPassed tpassed, TStored &rtstored)
{
    return rtstored.Assign(tpassed);
}

template <typename TStored> inline VOID HashTablePreInitializeKey(TStored &rtstored) { }

template <typename TStored> inline VOID HashTablePreInitializeValue(TStored &rtstored) { }

template <typename TStored> inline VOID HashTableFinalizeKey(TStored &rtstored) { }

template <typename TStored> inline VOID HashTableFinalizeValue(TStored &rtstored) { }

template <typename TCharTraits>
class CCountedStringHolder
{
public:
    CCountedStringHolder() : m_psz(NULL), m_cch(0) { }
    CCountedStringHolder(TCharTraits::TConstantString sz) : m_psz(sz), m_cch(TCharTraits::Cch(sz)) { }
    CCountedStringHolder(const CGenericBaseStringBuffer<TCharTraits> &rBuffer) : m_psz(rBuffer), m_cch(TCharTraits::Cch(rBuffer)) { }
    ~CCountedStringHolder() { }

    TCharTraits::TConstantString m_psz;
    SIZE_T m_cch;
};

//
//  You want to create a class derived from CHashTableHelper, and
//  use it as THashHelper for CHashTable.
//

template <typename TKPassed, class TKStored, typename TVPassed, typename TVStored> class CHashTableHelper
{
public:
    static BOOL HashKey(TKPassed keyin, ULONG &rulPseudoKey) { return ::HashTableHashKey<TKPassed>(keyin, rulPseudoKey); }
    static BOOL CompareKey(TKPassed keyin, const TKStored &rtkeystored, bool &rfMatch) { return ::HashTableCompareKey<TKPassed, TKStored>(keyin, rtkeystored, rfMatch); }
    static VOID PreInitializeKey(TKStored &rtkeystored) { return ::HashTablePreInitializeKey<TKStored>(rtkeystored); }
    static VOID PreInitializeValue(TVStored &rtvaluestored) { return ::HashTablePreInitializeValue<TVStored>(rtvaluestored); }
    static BOOL InitializeKey(TKPassed keyin, TKStored &rtkeystored) { return ::HashTableInitializeKey<TKPassed>(keyin, rtkeystored); }
    static BOOL InitializeValue(TVPassed vin, TVStored &rvstored) { return ::HashTableInitializeValue<TVPassed, TVStored>(vin, rvstored); }
    static BOOL UpdateValue(TVPassed vin, TVStored &rvstored) { return ::HashTableUpdateValue<TVPassed, TVStored>(vin, rvstored); }
    static VOID FinalizeKey(TKStored &rtkeystored) { return ::HashTableFinalizeKey<TKStored>(rtkeystored); }
    static VOID FinalizeValue(TVStored &rtvstored) { return ::HashTableFinalizeValue<TVStored>(rtvstored); }
};

template <typename TKPassed, typename TKStored, typename TVPassed, typename TVStored, class THashHelper = CHashTableHelper<TKPassed, TKStored, TVPassed, TVStored>, ULONG nInlineBucketChains = 7, bool fAllowDups = false> class CHashTableIter;

template <typename TKPassed, typename TKStored, typename TVPassed, typename TVStored, class THashHelper = CHashTableHelper<TKPassed, TKStored, TVPassed, TVStored>, ULONG nInlineBucketChains = 7, bool fAllowDups = false> class CHashTable
{
    friend CHashTableIter<TKPassed, TKStored, TVPassed, TVStored, THashHelper, nInlineBucketChains, fAllowDups>;

    typedef CHashTable<TKPassed, TKStored, TVPassed, TVStored, THashHelper, nInlineBucketChains, fAllowDups> TThisHashTable;
public:
    CHashTable() :
        m_cBucketChains(nInlineBucketChains),
        m_prgBucketChains(m_rgInlineBucketChains),
        m_ulLockCount(0),
        m_cEntries(0)
    {
    }

    ~CHashTable()
    {
        // This denotes a programming error.
        ASSERT_NTC(m_ulLockCount == 0);
        ULONG i;
        SIZE_T cFound = 0;

        for (i=0; i<m_cBucketChains; i++)
        {
            SIZE_T cThisBucket = 0;
            m_prgBucketChains[i].ClearNoCallback(this, cThisBucket);
            FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "Destroying hash table %p; found %Id buckets at index %d\n", this, cThisBucket, i);
            cFound += cThisBucket;
        }

        FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "After loop, destroying hash table %p; found total of %Id buckets; m_cEntries == %Id\n", this, cFound, m_cEntries);

        ASSERT_NTC(cFound == m_cEntries);

        if ((m_prgBucketChains != m_rgInlineBucketChains) &&
            (m_prgBucketChains != NULL))
        {
            ASSERT_NTC(m_cBucketChains != 0);

            FUSION_DELETE_ARRAY(m_prgBucketChains);
            m_cBucketChains = 0;
            m_prgBucketChains = NULL;
        }
        else
        {
            // Better safe than sorry
            ASSERT_NTC((m_prgBucketChains == m_rgInlineBucketChains) || (m_cBucketChains == 0));
            m_cBucketChains = 0;
        }

        m_prgBucketChains = NULL;
    }

    BOOL Initialize(ULONG cBucketChains = nInlineBucketChains)
    {
        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        PARAMETER_CHECK(cBucketChains != 0);

        // If you hit this assertion, it either means that you're calling Initialize
        // twice on the same hash table, the hash table has been corrupted since it was
        // constructed, or someone messed up the constructor.
        INTERNAL_ERROR_CHECK(m_prgBucketChains == m_rgInlineBucketChains);

        // Since we already have nInlineBucketChains allocated, there's no point
        // in going lower.  However, do perform the dynamic allocation if necessary.
        if (cBucketChains > nInlineBucketChains)
        {
            IFALLOCFAILED_EXIT(m_prgBucketChains = FUSION_NEW_ARRAY(CBucketChain, cBucketChains));
            m_cBucketChains = cBucketChains;
        }

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    void Lock(bool fAllowInsertions)
    {
        FN_TRACE();

        if (m_ulLockCount++ == 0)
        {
            m_fInsertionsPermitted = fAllowInsertions;
            m_fRemovalsPermitted = false;
        }
    }

    void Unlock()
    {
        FN_TRACE();

        m_ulLockCount--;
    }

    BOOL Insert(TKPassed keyin, TVPassed valuein, DWORD DuplicateKeyErrorCode)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;

        PARAMETER_CHECK(DuplicateKeyErrorCode != ERROR_SUCCESS);

        INTERNAL_ERROR_CHECK((m_ulLockCount == 0) || (m_fInsertionsPermitted));
        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].Insert(this, keyin, valuein, ulPseudoKey, DuplicateKeyErrorCode));

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    BOOL Insert(TKPassed keyin, TVPassed valuein)
    {
        return this->Insert(keyin, valuein, ERROR_ALREADY_EXISTS);
    }

    BOOL FindOrInsertIfNotPresent(TKPassed keyin, TVPassed valuein, TVStored **ppvaluestored = NULL, BOOL *pfFound = NULL)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;

        if (ppvaluestored != NULL)
            *ppvaluestored = NULL;

        if (pfFound != NULL)
            *pfFound = FALSE;

        INTERNAL_ERROR_CHECK((m_ulLockCount == 0) || (m_fInsertionsPermitted));
        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].FindOrInsertIfNotPresent(this, keyin, valuein, ulPseudoKey, ppvaluestored, pfFound));

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    // U is always as indicated, but the compiler would rather
    // deduce that seperately than deduce types dependent on each other
    template <typename T>
    BOOL InsertOrUpdateIf(
        TKPassed keyin,
        TVPassed valuein,
        T *pt,
        BOOL (T::*pmfn)(
            TVPassed,
            const TVStored &,
            InsertOrUpdateIfDisposition &)
        )
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;

        INTERNAL_ERROR_CHECK((m_ulLockCount == 0) || (m_fInsertionsPermitted));

        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].InsertOrUpdateIf T2P(TThisHashTable, T)(this, keyin, valuein, ulPseudoKey, pt, pmfn));

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    inline VOID ClearNoCallback()
    {
        FN_TRACE();

        ULONG i;
        SIZE_T cFound = 0;

        for (i=0; i<m_cBucketChains; i++)
        {
            SIZE_T cThisBucket = 0;
            m_prgBucketChains[i].ClearNoCallback(this, cThisBucket);
            cFound += cThisBucket;
        }

        if (m_prgBucketChains != m_rgInlineBucketChains)
        {
            FUSION_DELETE_ARRAY(m_prgBucketChains);
            m_prgBucketChains = m_rgInlineBucketChains;
            m_cBucketChains = nInlineBucketChains;
        }

        m_cEntries = 0;
        FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Cleared hash table %p entries to 0\n", __FILE__, __LINE__, this);
    }

    template <typename T> inline VOID Clear(T *pt = NULL, VOID (T::*pmfn)(TKStored &, TVStored &) = NULL)
    {
        FN_TRACE();
        ULONG i;

        // Either both have to be NULL or neither.
        ASSERT((pt == NULL) == (pmfn == NULL));

        if ((pt != NULL) && (pmfn != NULL))
        {
            for (i=0; i<m_cBucketChains; i++)
                m_prgBucketChains[i].Clear(this, pt, pmfn);
        }

        if (m_prgBucketChains != m_rgInlineBucketChains)
        {
            FUSION_DELETE_ARRAY(m_prgBucketChains);
            m_prgBucketChains = m_rgInlineBucketChains;
            m_cBucketChains = nInlineBucketChains;
        }

        m_cEntries = 0;
        FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Cleared hash table %p entries to 0\n", __FILE__, __LINE__, this);
    }

    BOOL Remove(TKPassed keyin, bool fRemoveFirstFoundOnly = false)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;

        INTERNAL_ERROR_CHECK((m_ulLockCount == 0) || (m_fRemovalsPermitted));

        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].Remove(this, keyin, ulPseudoKey, fRemoveFirstFoundOnly));

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    BOOL Find(TKPassed keyin, TVStored const *&rpvaluestored) const
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;

        rpvaluestored = NULL;
        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));
        iBucket = ulPseudoKey % m_cBucketChains;
        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].Find(keyin, ulPseudoKey, rpvaluestored));

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Find(TKPassed keyin, TVStored *&rpvaluestored)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;

        rpvaluestored = NULL;

        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].Find(keyin, ulPseudoKey, rpvaluestored));

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    BOOL Assign(CHashTable &TableToCopy) { return FALSE; }

    VOID TakeValue(CHashTable &That)
    {
        FN_TRACE();

        ULONG i;

        // Nothing can fail in this function, so we're theoretically safe to preemptively clean up our own storage.
        if (m_prgBucketChains != m_rgInlineBucketChains)
        {
            FUSION_DELETE_ARRAY(m_prgBucketChains);
            m_prgBucketChains = m_rgInlineBucketChains;
            m_cBucketChains = nInlineBucketChains;
        }

        // Just steal any storage from the other table.
        if (That.m_prgBucketChains != That.m_rgInlineBucketChains)
        {
            // It's a dynamically allocated array in the source; just move the pointer over
            // and clean up its state to be somewhat consistent.
            m_prgBucketChains = That.m_prgBucketChains;
            m_cBucketChains = That.m_cBucketChains;

            That.m_prgBucketChains = That.m_rgInlineBucketChains;
            That.m_cBucketChains = nInlineBucketChains;
        }
        else
        {
            // The inline chain of the other table is being used; we have to copy the
            // chains over one by one.
            for (i=0; i<nInlineBucketChains; i++)
                m_rgInlineBucketChains[i].TakeValue(this, That.m_rgInlineBucketChains[i]);
        }

        m_cEntries = That.m_cEntries;
        That.m_cEntries = 0;
        FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Hash table %p took over hash table %p's %Id entries\n", __FILE__, __LINE__, this, &That, m_cEntries);
    }

    SIZE_T GetEntryCount() const { return m_cEntries; }

//protected:

    class CBucketChain;

    class CBucket
    {
    public:
        CBucket(ULONG ulPseudoKey) : m_ulPseudoKey(ulPseudoKey) { THashHelper::PreInitializeKey(m_tkey); THashHelper::PreInitializeValue(m_tvalue); }

        ~CBucket() { THashHelper::FinalizeKey(m_tkey); THashHelper::FinalizeValue(m_tvalue); }

        BOOL Initialize(CHashTable const * pTable, TKPassed keyin, TVPassed valuein)
        {
            BOOL fSuccess = FALSE;

            FN_TRACE_WIN32(fSuccess);

            IFW32FALSE_EXIT(THashHelper::InitializeKey(keyin, m_tkey));
            IFW32FALSE_EXIT(THashHelper::InitializeValue(valuein, m_tvalue));

            fSuccess = TRUE;

        Exit:
            return fSuccess;
        }

        BOOL Matches(TKPassed keyin, ULONG ulPseudoKey, bool &rfMatches) const
        {
            BOOL fSuccess = FALSE;
            FN_TRACE_WIN32(fSuccess);
            bool fMatches = false;

            if (m_ulPseudoKey == ulPseudoKey)
                IFW32FALSE_EXIT(THashHelper::CompareKey(keyin, m_tkey, fMatches));

            rfMatches = fMatches;

            fSuccess = TRUE;
        Exit:
            return fSuccess;
        }

        template <typename T> VOID Clear(TThisHashTable const * pTable, T *pt, VOID (T::*pmfn)(TKStored &keystored, TVStored &rvaluestored))
        {
            FN_TRACE();
            (pt->*pmfn)(m_tkey, m_tvalue);
        }

        template <typename T> VOID Clear(TThisHashTable const * pTable, T *pt, VOID (T::*pmfn)(TKStored &keystored, TVStored &rvaluestored) const)
        {
            FN_TRACE();
            (pt->*pmfn)(m_tkey, m_tvalue);
        }

        VOID Remove()
        {
            FN_TRACE();
            m_Linkage.Remove();
        }

        BOOL Update(TVPassed valuein)
        {
            BOOL fSuccess = FALSE;
            FN_TRACE_WIN32(fSuccess);
            IFW32FALSE_EXIT(THashHelper::UpdateValue(m_tvalue, valuein));
            fSuccess = TRUE;
        Exit:
            return fSuccess;
        }

        TKStored m_tkey;
        TVStored m_tvalue;
        ULONG m_ulPseudoKey;
        CDequeLinkage m_Linkage;

    private:
        CBucket(const CBucket &);
        void operator =(const CBucket &);
    };

    typedef CDequeIterator<CBucket, FIELD_OFFSET(CBucket, m_Linkage)> CBucketIterator;
    typedef CConstDequeIterator<CBucket, FIELD_OFFSET(CBucket, m_Linkage)> CConstBucketIterator;

    class CBucketChain
    {
    public:
        CBucketChain() { }
        ~CBucketChain() { }

        inline void DeallocateBuckets(CHashTable const *pTable, SIZE_T &rcFound)
        {
            rcFound = m_Buckets.GetEntryCount();
            m_Buckets.Clear(pTable, &CHashTable::DeallocateBucket);
        }

        BOOL Insert(
            CHashTable *pTable,
            TKPassed keyin,
            TVPassed valuein,
            ULONG ulPseudoKey,
            DWORD DuplicateKeyErrorCode)
        {
            BOOL fSuccess = FALSE;
            FN_TRACE_WIN32(fSuccess);

            bool fMatches = false;
            CBucket *pCBucket = NULL;

            if (!fAllowDups)
            {
                CBucketIterator Iter(&m_Buckets);

                for (Iter.Reset(); Iter.More(); Iter.Next())
                {
                    IFW32FALSE_EXIT(Iter->Matches(keyin, ulPseudoKey, fMatches));

                    if (fMatches)
                        ORIGINATE_WIN32_FAILURE_AND_EXIT(DuplicateKey, DuplicateKeyErrorCode);
                }
            }

            IFW32FALSE_EXIT(pTable->AllocateAndInitializeBucket(ulPseudoKey, keyin, valuein, pCBucket));

            m_Buckets.AddToTail(pCBucket);
            pTable->m_cEntries++;
            FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Incremented hash table %p entries to %Id\n", __FILE__, __LINE__, pTable, pTable->m_cEntries);

            fSuccess = TRUE;
        Exit:
            return fSuccess;
        }

        BOOL FindOrInsertIfNotPresent(
            CHashTable *pTable,
            TKPassed keyin,
            TVPassed valuein,
            ULONG ulPseudoKey,
            TVStored **ppvaluestored,
            BOOL *pfFound
            )
        {
            BOOL fSuccess = FALSE;
            FN_TRACE_WIN32(fSuccess);
            bool fMatches = false;
            CBucketIterator Iter(&m_Buckets);

            for (Iter.Reset(); Iter.More(); Iter.Next())
            {
                IFW32FALSE_EXIT(Iter->Matches(keyin, ulPseudoKey, fMatches));

                if (fMatches)
                {
                    *ppvaluestored = &Iter->m_tvalue;
                    break;
                }
            }

            if (!fMatches)
            {
                CBucket *pCBucket = NULL;

                IFW32FALSE_EXIT(pTable->AllocateAndInitializeBucket(ulPseudoKey, keyin, valuein, pCBucket));

                m_Buckets.AddToTail(pCBucket);

                pTable->m_cEntries++;
                FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Incremented hash table %p entries to %Id\n", __FILE__, __LINE__, pTable, pTable->m_cEntries);

                if (ppvaluestored != NULL)
                    *ppvaluestored = &pCBucket->m_tvalue;
            }

            if (pfFound != NULL)
                *pfFound = fMatches;

            fSuccess = TRUE;
        Exit:
            return fSuccess;
        }

        template <typename THashTable, typename T>
        BOOL InsertOrUpdateIf(
            THashTable *pTable,
            TKPassed keyin,
            TVPassed valuein,
            ULONG ulPseudoKey,
            T *pt,
            BOOL (T::*pmfn)(
                TVPassed,
                const TVStored &,
                InsertOrUpdateIfDisposition &)
            )
        {
            BOOL fSuccess = FALSE;
            FN_TRACE_WIN32(fSuccess);
            bool fMatches = false;
            CBucketIterator Iter(&m_Buckets);

            for (Iter.Reset(); Iter.More(); Iter.Next())
            {
                IFW32FALSE_EXIT(Iter->Matches(keyin, ulPseudoKey, fMatches));

                if (fMatches)
                {
                    InsertOrUpdateIfDisposition Disposition;

                    IFW32FALSE_EXIT((pt->*pmfn)(valuein, Iter->m_tvalue, Disposition));

                    if (Disposition == eUpdateValue)
                    {
                        FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Updating value in hash table %p\n", __FILE__, __LINE__, pTable);
                        IFW32FALSE_EXIT(THashHelper::UpdateValue(valuein, Iter->m_tvalue));
                    }

                    break;
                }
            }

            // If we didn't find one, we want to insert.
            if (!fMatches)
            {
                CBucket *pCBucket = NULL;

                IFW32FALSE_EXIT(pTable->AllocateAndInitializeBucket(ulPseudoKey, keyin, valuein, pCBucket));

                m_Buckets.AddToTail(pCBucket);
                pTable->m_cEntries++;
                FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Incremented hash table %p entries to %Id\n", __FILE__, __LINE__, pTable, pTable->m_cEntries);
            }

            fSuccess = TRUE;
        Exit:
            return fSuccess;
        }

        inline VOID ClearNoCallback(TThisHashTable const *pTable, SIZE_T &rcFound)
        {
            FN_TRACE();
            this->DeallocateBuckets(pTable, rcFound);
        }

        template <typename T> class CLEAR_CALLBACK_BLOCK
        {
        public:
            VOID DoClear(CBucket *pCBucket) { pCBucket->Clear(pTable, pt, pmfn); pTable->DeallocateBucket(pCBucket); }

            TThisHashTable const *pTable;
            T *pt;
            VOID (T::*pmfn)(TKStored &, TVStored &);
        };

        template <typename T> VOID Clear(TThisHashTable const *pTable, T *pt, VOID (T::*pmfn)(TKStored &keystored, TVStored &valuestored))
        {
            FN_TRACE();
            SIZE_T cFound = 0;
            ASSERT((pt != NULL) && (pmfn != NULL));

            CLEAR_CALLBACK_BLOCK<T> CallbackBlock;

            CallbackBlock.pTable = pTable;
            CallbackBlock.pt = pt;
            CallbackBlock.pmfn = pmfn;

            m_Buckets.Clear<CLEAR_CALLBACK_BLOCK<T> >(&CallbackBlock, &CLEAR_CALLBACK_BLOCK<T>::DoClear);

            this->DeallocateBuckets(pTable, cFound);
        }

//        BOOL Remove(CHashTable const *pTable, TKPassed keyin, ULONG ulPseudoKey, bool fFirstOnly = false)
        BOOL Remove(CHashTable *pTable, TKPassed keyin, ULONG ulPseudoKey, bool fFirstOnly = false)
        {
            BOOL fSuccess = FALSE;
            FN_TRACE_WIN32(fSuccess);
            bool fFoundOne = false;
            bool fMatches = false;

            CBucketIterator Iter(&m_Buckets);

            Iter.Reset();

            while (Iter.More())
            {
                IFW32FALSE_EXIT(Iter->Matches(keyin, ulPseudoKey, fMatches));

                if (fMatches)
                {
                    CBucket *pCBucket = Iter.RemoveCurrent(eDequeIteratorMoveForward);
                    pTable->DeallocateBucket(pCBucket);
                    fFoundOne = true;

                    pTable->m_cEntries--;
                    FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Decremented hash table %p entries to %Id\n", __FILE__, __LINE__, pTable, pTable->m_cEntries);

                    // If we don't allow duplicates, our job is done and there's no point
                    // in searching the remainder of the list.  Also, if we're only interested
                    // in removing the first match we find (and not necessarily all of them),
                    // then also bail out.
                    if ((!fAllowDups) || (fFirstOnly))
                        break;
                }
                else
                    Iter.Next();
            }

            // If we didn't at least find one, then tell the caller.
            if (!fFoundOne)
                ORIGINATE_WIN32_FAILURE_AND_EXIT(HashTableEntryNotFound, ERROR_FILE_NOT_FOUND);

            fSuccess = TRUE;
        Exit:
            return fSuccess;
        }

        BOOL Find(TKPassed keyin, ULONG ulPseudoKey, TVStored const *&rpvaluestored) const
        {
            BOOL fSuccess = FALSE;
            FN_TRACE_WIN32(fSuccess);
            bool fMatches = false;
            CConstBucketIterator Iter(&m_Buckets);

            rpvaluestored = NULL;

            for (Iter.Reset(); Iter.More(); Iter.Next())
            {
                IFW32FALSE_EXIT(Iter->Matches(keyin, ulPseudoKey, fMatches));

                if (fMatches)
                {
                    rpvaluestored = &Iter->m_tvalue;
                    break;
                }
            }

            fSuccess = TRUE;

        Exit:
            return fSuccess;
        }

        BOOL Find(TKPassed keyin, ULONG ulPseudoKey, TVStored *&rpvaluestored)
        {
            BOOL fSuccess = FALSE;
            FN_TRACE_WIN32(fSuccess);
            bool fMatches = false;
            CBucketIterator Iter(&m_Buckets);

            rpvaluestored = NULL;

            for (Iter.Reset(); Iter.More(); Iter.Next())
            {
                IFW32FALSE_EXIT(Iter->Matches(keyin, ulPseudoKey, fMatches));

                if (fMatches)
                {
                    rpvaluestored = &Iter->m_tvalue;
                    break;
                }
            }

            fSuccess = TRUE;

        Exit:
            return fSuccess;
        }

        VOID TakeValue(CHashTable *pTable, CBucketChain &That)
        {
            SIZE_T cFound = 0;
            this->DeallocateBuckets(pTable, cFound);
            m_Buckets.TakeValue(That.m_Buckets);
        }

        CDeque<CBucket, FIELD_OFFSET(CBucket, m_Linkage)> m_Buckets;
    private:
        CBucketChain(const CBucketChain &);
        void operator =(const CBucketChain &);
    };

    inline BOOL AllocateAndInitializeBucket(
        ULONG ulPseudoKey,
        TKPassed keyin,
        TVPassed valuein,
        CBucket *&rpBucket
        ) const
    {
        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        rpBucket = NULL;
        CBucket *pBucket = NULL;

        IFALLOCFAILED_EXIT(pBucket = new CBucket(ulPseudoKey));
        IFW32FALSE_EXIT(pBucket->Initialize(this, keyin, valuein));

        rpBucket = pBucket;
        pBucket = NULL;
        fSuccess = TRUE;

    Exit:
        if (pBucket != NULL)
            this->DeallocateBucket(pBucket);

        return fSuccess;
    }

    inline void DeallocateBucket(CBucket *pCBucket) const { FUSION_DELETE_SINGLETON(pCBucket); }

    friend CBucket;
    friend CBucketChain;

    ULONG m_cBucketChains;
    CBucketChain *m_prgBucketChains;
    CBucketChain m_rgInlineBucketChains[nInlineBucketChains];
    SIZE_T m_ulLockCount;
    SIZE_T m_cEntries;
    bool m_fInsertionsPermitted;
    bool m_fRemovalsPermitted;
private:
    CHashTable(const CHashTable &r); // intentionally not implmented
    void operator =(const CHashTable &r); // intentionally not implemented

};

template <typename TKPassed, typename TKStored, typename TVPassed, typename TVStored, class THashHelper = CHashTableHelper<TKPassed, TKStored, TVPassed, TVStored>, ULONG nInlineBucketChains = 7, bool fAllowDups = false> class CHashTableIter
{
    typedef CHashTable<TKPassed, TKStored, TVPassed, TVStored, THashHelper, nInlineBucketChains, fAllowDups> THashTable;

public:
    inline CHashTableIter(CHashTable<TKPassed, TKStored, TVPassed, TVStored, THashHelper, nInlineBucketChains, fAllowDups> &r) : m_rTable(r), m_iBucketChain(0),
        m_fAlreadyAdvanced(false) { }

    inline ~CHashTableIter() { }

    inline void Reset()
    {
        FN_TRACE();

        m_iBucketChain = 0;
        m_fAlreadyAdvanced = false;

        // Move the bucket iterator across the bucket chains looking for one with some
        // buckets
        for (m_iBucketChain = 0; m_iBucketChain < m_rTable.m_cBucketChains; m_iBucketChain++)
        {
            m_Iter.Rebind(&m_rTable.m_prgBucketChains[m_iBucketChain].m_Buckets);
            m_Iter.Reset();
            if (m_Iter.More())
                break;
        }

        if (m_iBucketChain == m_rTable.m_cBucketChains)
        {
            // There wasn't anything.  Unbind the iterator to signal that we're
            // totally done.
            m_Iter.Unbind();
        }
    }

    inline void Delete()
    {
        FN_TRACE();

        CSxsPreserveLastError ple;

        ASSERT(m_Iter.IsBound());
        if (m_Iter.IsBound())
        {
            THashTable::CBucket *pCBucket = m_Iter.RemoveCurrent(eDequeIteratorMoveForward);
            FUSION_DELETE_SINGLETON(pCBucket);
            m_fAlreadyAdvanced = true;
            m_rTable.m_cEntries--;
            ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Decremented hash table %p entries to %Id\n", __FILE__, __LINE__, &m_rTable, m_rTable.m_cEntries);
        }

        ple.Restore();
    }

    inline BOOL Update(TVPassed valuein) const
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        INTERNAL_ERROR_CHECK(m_Iter.IsBound());
        INTERNAL_ERROR_CHECK(!m_fAlreadyAdvanced);

        IFW32FALSE_EXIT(m_Iter->Update(valuein));

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    inline bool More() const { return m_Iter.IsBound(); }

    inline void Next()
    {
        FN_TRACE();

        if (m_Iter.IsBound())
        {
            // If someone deleted the current element, the iterator has already been
            // advanced. Otherwise, move on.
            if (!m_fAlreadyAdvanced)
                m_Iter.Next();

            // We've taken it into account, now forget about it.
            m_fAlreadyAdvanced = false;

            // If there aren't any more elements in this deque, try the next bucket chain
            if (!m_Iter.More())
            {
                m_iBucketChain++;

                while (m_iBucketChain < m_rTable.m_cBucketChains)
                {
                    m_Iter.Rebind(&m_rTable.m_prgBucketChains[m_iBucketChain].m_Buckets);
                    m_Iter.Reset();
                    if (m_Iter.More())
                        break;
                    m_iBucketChain++;
                }

                if (m_iBucketChain == m_rTable.m_cBucketChains)
                    m_Iter.Unbind();
            }
        }
    }

    inline const TKStored &GetKey() const
    {
        FN_TRACE();

        // Should not call this if More() returns false
        ASSERT(m_Iter.IsBound());

        if (m_Iter.IsBound() && m_Iter.More())
        {
            return m_Iter->m_tkey;
        }

        return NULL;
    }

    inline TVStored &GetValue() const
    {
        FN_TRACE();

        // Should not call this function if More() returns false
        ASSERT(m_Iter.IsBound());
        return m_Iter->m_tvalue;
    }

    inline TVStored &operator ->() const
    {
        FN_TRACE();

        // Should not call this function if More() returns false
        ASSERT(m_Iter.IsBound());
        return m_Iter->m_tvalue;
    }

protected:
    THashTable &m_rTable;
    THashTable::CBucketIterator m_Iter;
    ULONG m_iBucketChain;
    bool m_fAlreadyAdvanced;

private:
    CHashTableIter(const CHashTableIter &);
    void operator =(const CHashTableIter &);
};

//
//  Helper class for hash tables of filenames:
//

template <typename TVPassed, typename TVStored> class CFusionFilenameHashTableHelper : public CHashTableHelper<LPCWSTR, CUnicodeStringBuffer, TVPassed, TVStored>
{
public:
    inline static BOOL HashKey(LPCWSTR sz, ULONG &rulPseudoKey)
    {
        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        ULONG ulPK = 0;
        LPCWSTR pszTemp;
        WCHAR wch;

        if (sz != NULL)
        {
            SIZE_T cch = ::wcslen(sz);
            IFW32FALSE_EXIT(::FusionpHashUnicodeString(sz, cch, &ulPK, true));
        }

        rulPseudoKey = ulPK;
        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    static BOOL CompareKey(LPCWSTR szKey, CUnicodeBaseStringBuffer *pbuff, bool &rfMatch)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        int iResult;

        rfMatch = false;

        PARAMETER_CHECK(pbuff != NULL);

        iResult = ::FusionpCompareStrings(
                        szKey, (szKey == NULL) ? 0 : ::wcslen(szKey),
                        static_cast<LPCWSTR>(*pbuff), pbuff->Cch(),
                        true);

        rfMatch = (iResult == 2); // In SDK DOCS, 2 == CSTR_EQUAL; there is no constant defined.  -mgrier 12/6/1999
        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }
};

//
//  CSimpleKeyedTable
//
//  A simplification of the CHashTable class template which assumes that
//  keys are passed as const references.
//

template <typename TKey, typename TVPassed, typename TVStored, typename THashHelper> class CSimpleKeyedTable : public CHashTable<const TKey &, TKey, TVPassed, TVStored, THashHelper>
{
public:
    CSimpleKeyedTable() : CHashTable<const TKey &, TKey, TVPassed, TVStored, THashHelper>() { }
};

template <typename TKey, typename TVPassed, typename TVStored, typename THashHelper> class CSimpleKeyedTableIter : public CHashTableIter<const TKey &, TKey, TVPassed, TVStored, THashHelper>
{
    typedef CHashTableIter<const TKey &, TKey, TVPassed, TVStored, THashHelper> Base;
public:
    CSimpleKeyedTableIter(CSimpleKeyedTable<TKey, TVPassed, TVStored, THashHelper> &Table) : Base(Table) { }
};

template <typename TKPassed, typename TKStored, typename TValue> class CPtrTableHelper : public CHashTableHelper<TKPassed, TKStored, TValue *, TValue *>
{
    typedef TValue *TValuePtr;

public:
    static VOID PreInitializeValue(TValue *&rvstored) { rvstored = NULL; }
    static BOOL InitializeValue(const TValuePtr &vin, TValue *&rvstored) { rvstored = vin; return TRUE; }
    static BOOL UpdateValue(const TValuePtr &vin, TValue *&rvstored) { rvstored = vin; return TRUE; }
    static VOID FinalizeValue(TValuePtr &rvstored) { if (rvstored != NULL) { FUSION_DELETE_SINGLETON(rvstored); rvstored = NULL; } }
};

template <typename TKPassed, typename TKStored, typename TValue, typename THashHelper = CPtrTableHelper<TKPassed, TKStored, TValue> > class CPtrTable : public CHashTable<TKPassed, TKStored, TValue *, TValue *, THashHelper>
{
public:
    CPtrTable() : CHashTable<TKPassed, TKStored, TValue *, TValue *, THashHelper>() { }

    BOOL Find(TKPassed keyin, TValue *&rpvaluestored)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;
        TValue **ppValue = NULL;

        rpvaluestored = NULL;

        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].Find(keyin, ulPseudoKey, ppValue));

        if (ppValue != NULL)
            rpvaluestored = *ppValue;

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

private:
    CPtrTable(const CPtrTable &);
    void operator =(const CPtrTable &);
};

template <typename TKPassed, typename TKStored, typename TValue, typename THashHelper = CPtrTableHelper<TKPassed, TKStored, TValue> > class CPtrTableIter : public CHashTableIter<TKPassed, TKStored, TValue *, TValue *, THashHelper>
{
public:
    CPtrTableIter(CPtrTable<TKPassed, TKStored, TValue, THashHelper> &Table) : CHashTableIter<TKPassed, TKStored, TValue *, TValue *, THashHelper>(Table) { }

private:
    CPtrTableIter(const CPtrTableIter &);
    void operator =(const CPtrTableIter &);
};

template <typename TKey, typename TValue> class CSimplePtrTableHelper : public CPtrTableHelper<const TKey &, TKey, TValue>
{
public:
};

//
//  CSimplePtrTable
//
//  A simplification of CHashTable class template which assumes
//  that keys are passed as const references and values are pointers.
//
//  Note that the table does NOT own allocating or deallocating the storage
//  to which the pointers refer.  If the table is destroyed, the
//  storage is not released.
//

template <typename TKey, typename TValue, typename THashHelper = CSimplePtrTableHelper<TKey, TValue> > class CSimplePtrTable : public CSimpleKeyedTable<TKey, TValue *, TValue *, THashHelper>
{
public:
    CSimplePtrTable() : CSimpleKeyedTable<TKey, TValue *, TValue *, THashHelper>(hHeap) { }

    BOOL Find(const TKey &keyin, TValue *&rpvaluestored)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;
        TValue **ppValue = NULL;

        rpvaluestored = NULL;

        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].Find(keyin, ulPseudoKey, ppValue));

        if (ppValue != NULL)
            rpvaluestored = *ppValue;

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

private:
    CSimplePtrTable(const CSimplePtrTable &);
    void operator =(const CSimplePtrTable &);
};

template <typename TKey, typename TValue, typename THashHelper = CSimplePtrTableHelper<TKey, TValue> > class CSimplePtrTableIter : public CSimpleKeyedTableIter<TKey, TValue *, TValue *, THashHelper>
{
    typedef CSimpleKeyedTableIter<TKey, TValue *, TValue *, THashHelper> Base;
public:
    CSimplePtrTableIter(CSimplePtrTable<TKey, TValue, THashHelper> &Table)
       : Base(Table) { }
private:
    CSimplePtrTableIter(const CSimplePtrTableIter &);
    void operator =(const CSimplePtrTableIter &);
};

template <typename TVPassed, typename TVStored> class CGuidTableHelper : public CHashTableHelper<GUID, GUID, TVPassed, TVStored>
{
    typedef CHashTableHelper<REFGUID, GUID, TVPassed, TVStored> Base;
public:
    static BOOL InitializeKey(REFGUID keyin, GUID &rtkeystored) { rtkeystored = keyin; return TRUE; }
};

template <typename TVPassed, typename TVStored, typename THashHelper = CGuidTableHelper<TVPassed, TVStored> > class CGuidTable : public CHashTable<REFGUID, GUID, TVPassed, TVStored, THashHelper >
{
public:
    CGuidTable() : CHashTable<REFGUID, GUID, TVPassed, TVStored, THashHelper >() { }
private:
    CGuidTable(const CGuidTable &);
    void operator =(const CGuidTable &);
};

template <typename TVPassed, typename TVStored, typename THashHelper = CGuidTableHelper<TVPassed, TVStored> > class CGuidTableIter : public CHashTableIter<REFGUID, GUID, TVPassed, TVStored, THashHelper >
{
    typedef CHashTableIter<REFGUID, GUID, TVPassed, TVStored, THashHelper > Base;
public:
    CGuidTableIter(CGuidTable<TVPassed, TVStored, THashHelper> &Table) : Base(Table) { }
private:
    CGuidTableIter(const CGuidTableIter &);
    void operator =(const CGuidTableIter &);
};

template <typename TValue> class CGuidPtrTableHelper : public CHashTableHelper<REFGUID, GUID, TValue *, TValue *>
{
public:
    static BOOL InitializeKey(REFGUID keyin, GUID &rtkeystored) { rtkeystored = keyin; return TRUE; }
    static BOOL InitializeValue(TValue *vin, TValue *&rvstored) { rvstored = vin; return TRUE; }
    static BOOL UpdateValue(TValue *vin, TValue *&rvstored) { rvstored = vin; return TRUE; }
};

template <typename TValue, typename THashHelper = CGuidPtrTableHelper<TValue> > class CGuidPtrTable : public CGuidTable<TValue *, TValue *, THashHelper>
{
public:
    CGuidPtrTable() : CGuidTable<TValue *, TValue *, THashHelper>() { }
private:
    CGuidPtrTable(const CGuidPtrTable &);
    void operator =(const CGuidPtrTable &);
};

template <typename TValue, typename THashHelper = CGuidPtrTableHelper<TValue> > class CGuidPtrTableIter : public CGuidTableIter<TValue *, TValue *, THashHelper>
{
    typedef CGuidTableIter<TValue *, TValue *, THashHelper> Base;
public:
    CGuidPtrTableIter(CGuidPtrTable<TValue, THashHelper> &Table) : Base(Table) { }
private:
    CGuidPtrTableIter(const CGuidPtrTableIter &);
    void operator =(const CGuidPtrTableIter &);
};

template <typename TVPassed, typename TVStored, typename TCharTraits, bool fCaseInsensitive = false> class CStringTableHelper : public CHashTableHelper<const CCountedStringHolder<TCharTraits> &, CStringBuffer, TVPassed, TVStored>
{
public:
    typedef CCountedStringHolder<TCharTraits> TCountedStringHolder;

    static BOOL HashKey(const TCountedStringHolder &keyin, ULONG &rulPseudoKey) { BOOL fSuccess = FALSE; FN_TRACE_WIN32(fSuccess); IFW32FALSE_EXIT(TCharTraits::Win32HashString(keyin.m_psz, keyin.m_cch, rulPseudoKey, fCaseInsensitive)); fSuccess = TRUE; Exit: return fSuccess; }
    static BOOL InitializeKey(const TCountedStringHolder &keyin, CBaseStringBuffer &rtkeystored) { BOOL fSuccess = FALSE; FN_TRACE_WIN32(fSuccess); IFW32FALSE_EXIT(rtkeystored.Win32Assign(keyin.m_psz, keyin.m_cch)); fSuccess = TRUE; Exit: return fSuccess; }
    static BOOL CompareKey(const TCountedStringHolder &keyin, const CBaseStringBuffer &rtkeystored, bool &rfMatch) { BOOL fSuccess = FALSE; FN_TRACE_WIN32(fSuccess); IFW32FALSE_EXIT(rtkeystored.Win32Equals(keyin.m_psz, keyin.m_cch, rfMatch, fCaseInsensitive)); fSuccess = TRUE; Exit: return fSuccess; }
};

class STRING_TABLE_CLEAR_CALLBACK_BLOCK_BASE
{
public:
    virtual VOID DoClear(PVOID) = 0;
};

template <typename TVPassed, typename TVStored, typename TCharTraits, DWORD dwCmpFlags = 0, typename THashHelper = CStringTableHelper<TVPassed, TVStored, TCharTraits, dwCmpFlags> > class CStringTable : public CHashTable<const CCountedStringHolder<TCharTraits> &, CStringBuffer, TVPassed, TVStored, THashHelper>
{
    typedef CHashTable<const CCountedStringHolder<TCharTraits> &, CStringBuffer, TVPassed, TVStored, THashHelper> Base;

public:
    typedef CCountedStringHolder<TCharTraits> TCountedStringHolder;

protected:
    VOID ClearCallbackWrapper(CStringBuffer &key, TVStored &valuestored)
    {
        FN_TRACE();

        key.Clear();
        m_pActiveClearCallbackBlock->DoClear(valuestored);
    }

    STRING_TABLE_CLEAR_CALLBACK_BLOCK_BASE *m_pActiveClearCallbackBlock;

    template <typename T> class STRING_TABLE_CLEAR_CALLBACK_BLOCK : public STRING_TABLE_CLEAR_CALLBACK_BLOCK_BASE
    {
    public:
        T *pt;
        VOID (T::*pmfn)(TVStored &valuestored);

        VOID DoClear(PVOID pv) { TVStored *pvstored = (TVStored *) pv; (pt->*pmfn)(*pvstored); }
    };

    // Introduce name that derived classes will not override to work around compiler bugs
    inline VOID ClearStringTable(STRING_TABLE_CLEAR_CALLBACK_BLOCK_BASE *pCallbackBlock)
    {
        FN_TRACE();

        ASSERT(m_pActiveClearCallbackBlock == NULL);

        m_pActiveClearCallbackBlock = pCallbackBlock;

        ULONG i;

        for (i=0; i<m_cBucketChains; i++)
            m_prgBucketChains[i].Clear<CStringTable>(this, this, &CStringTable::ClearCallbackWrapper);

        this->ClearNoCallback();

        m_pActiveClearCallbackBlock = NULL;
    }

public:
    typedef CCountedStringHolder<TCharTraits> TCountedStringHolder;

    CStringTable() : CHashTable<const TCountedStringHolder &, CStringBuffer, TVPassed, TVStored, THashHelper>(), m_pActiveClearCallbackBlock(NULL) { }

    template <typename T> inline VOID Clear(T *pt, VOID (T::*pmfn)(TVStored &valuestored))
    {
        FN_TRACE();

        STRING_TABLE_CLEAR_CALLBACK_BLOCK<T> CallbackBlock;
        CallbackBlock.pt = pt;
        CallbackBlock.pmfn = pmfn;
        this->ClearStringTable(&CallbackBlock);
    }

private:
    CStringTable(const CStringTable &);
    void operator =(const CStringTable &);
};

template <typename TVPassed, typename TVStored, typename TCharTraits, DWORD dwCmpFlags = 0, typename THashHelper = CStringTableHelper<TVPassed, TVStored, TCharTraits, dwCmpFlags> > class CStringTableIter : public CHashTableIter<const CCountedStringHolder<TCharTraits> &, CStringBuffer, TVPassed, TVStored, THashHelper>
{
public:
    typedef CCountedStringHolder<TCharTraits> TCountedStringHolder;

protected:
    typedef CHashTableIter<const TCountedStringHolder &, CStringBuffer, TVPassed, TVStored, THashHelper> Base;

public:
    CStringTableIter(CStringTable<TVPassed, TVStored, TCharTraits, dwCmpFlags, THashHelper> &rTable) : Base(rTable) { }

    inline TCharTraits::TConstantString GetKey() const
    {
        FN_TRACE();

        // Should not call this if More() returns false
        ASSERT(m_Iter != NULL);

        //
        // m_ulLockCount doesn't exist. I'm wondering if perhaps this entire function
        // could be axed in favor of using the default one, which does something
        // very similar. (jonwis 8/24/00)
        //
        // ASSERT(m_ulLockCount != 0);

        if (m_Iter != NULL)
            return m_Iter->m_tkey;

        return NULL;
    }
private:
    CStringTableIter(const CStringTableIter &);
    void operator =(const CStringTableIter &);
};

template <typename TValue, typename TCharTraits, bool fCaseInsensitive = false> class CStringPtrTableHelper : public CStringTableHelper<TValue *, TValue *, TCharTraits, fCaseInsensitive>
{
public:
    static VOID PreInitializeValue(TValue *&rvstored) { rvstored = NULL; }
    static BOOL InitializeValue(TValue *vin, TValue *&rvstored) { rvstored = vin; return TRUE; }
    static BOOL UpdateValue(TValue *vin, TValue *&rvstored) { rvstored = vin; return TRUE; }
    static VOID FinalizeValue(TValue *&rvstored) { if (rvstored != NULL) { FUSION_DELETE_SINGLETON(rvstored); rvstored = NULL; } }
};

template <typename TValue, typename TCharTraits, DWORD dwCmpFlags = 0, typename THashHelper = CStringPtrTableHelper<TValue, TCharTraits, dwCmpFlags> > class CStringPtrTable : public CStringTable<TValue *, TValue *, TCharTraits, dwCmpFlags, THashHelper>
{
    typedef CStringTable<TValue *, TValue *, TCharTraits, dwCmpFlags, THashHelper> Base;

protected:
    template <typename T> class STRING_PTR_TABLE_CLEAR_CALLBACK_BLOCK : public STRING_TABLE_CLEAR_CALLBACK_BLOCK_BASE
    {
    public:
        T *pt;
        VOID (T::*pmfn)(TValue *pvaluestored);

        VOID DoClear(PVOID pv) { /* TValue **ppvstored = (TValue **) pv; */ (pt->*pmfn)((TValue *) pv); }
    };

public:
    CStringPtrTable() : CStringTable<TValue *, TValue *, TCharTraits, dwCmpFlags, THashHelper>() { }

    template <typename T> VOID Clear(T *pt, VOID (T::*pmfn)(TValue *valuestored))
    {
        FN_TRACE();

        STRING_PTR_TABLE_CLEAR_CALLBACK_BLOCK<T> CallbackBlock;
        CallbackBlock.pt = pt;
        CallbackBlock.pmfn = pmfn;
        this->ClearStringTable(&CallbackBlock);
    }

    BOOL Find(const TCountedStringHolder &keyin, TValue const *&rpvaluestored) const
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;

        rpvaluestored = NULL;

        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].Find(keyin, ulPseudoKey, rpvaluestored));

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    BOOL Find(const TCountedStringHolder &keyin, TValue *&rpvaluestored)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;
        TValue **ppvaluestored = NULL;

        rpvaluestored = NULL;

        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].Find(keyin, ulPseudoKey, ppvaluestored));

        if (ppvaluestored != NULL)
            rpvaluestored = *ppvaluestored;

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

private:
    CStringPtrTable(const CStringPtrTable &);
    void operator =(const CStringPtrTable &);
};

template <typename TValue, typename TCharTraits, DWORD dwCmpFlags = 0, typename THashHelper = CStringPtrTableHelper<TValue, TCharTraits, dwCmpFlags> > class CStringPtrTableIter : public CStringTableIter<TValue *, TValue *, TCharTraits, dwCmpFlags, THashHelper>
{
    typedef CStringTableIter<TValue *, TValue *, TCharTraits, dwCmpFlags, THashHelper> Base;
public:
    CStringPtrTableIter(CStringPtrTable<TValue, TCharTraits, dwCmpFlags, THashHelper> &rTable) : Base(rTable) { }

    operator TValue *() const { return this->GetValue(); }
    TValue *operator ->() const { return this->GetValue(); }

private:
    CStringPtrTableIter(const CStringPtrTableIter &);
    void operator =(const CStringPtrTableIter &);
};

template <typename TValue, typename TCharTraits, DWORD dwCmpFlags = 0> class CSimpleStringTableHelper : public CStringTableHelper<const TValue &, TValue, TCharTraits, dwCmpFlags>
{
public:
    static BOOL InitializeValue(const TValue &vin, TValue &rvstored) { rvstored = vin; return TRUE; }
    static BOOL UpdateValue(const TValue &vin, TValue &rvstored) { rvstored = vin; return TRUE; }
};

template <typename TValue, typename TCharTraits, DWORD dwCmpFlags = 0, typename THashHelper = CSimpleStringTableHelper<TValue, TCharTraits, dwCmpFlags> > class CSimpleStringTable : public CStringTable<const TValue &, TValue, TCharTraits, dwCmpFlags, THashHelper>
{
public:
    CSimpleStringTable() : CStringTable<const TValue &, TValue, TCharTraits, dwCmpFlags, THashHelper>() { }
private:
    CSimpleStringTable(const CSimpleStringTable &);
    void operator =(const CSimpleStringTable &);
};

template <typename TValue, typename TCharTraits, DWORD dwCmpFlags = 0, typename THashHelper = CSimpleStringTableHelper<TValue, TCharTraits, dwCmpFlags> > class CSimpleStringTableIter : public CStringTableIter<const TValue &, TValue, TCharTraits, dwCmpFlags, THashHelper>
{
    typedef CStringTableIter<const TValue &, TValue, TCharTraits, dwCmpFlags, THashHelper> Base;
public:
    CSimpleStringTableIter(CSimpleStringTable<TValue, TCharTraits, dwCmpFlags, THashHelper> &rTable) : Base(rTable) { }

private:
    CSimpleStringTableIter(const CSimpleStringTableIter &);
    void operator =(const CSimpleStringTableIter &);
};

// CSimpleUnicodeStringTable et al:

template <typename TValue, DWORD dwCmpFlags = 0> class CSimpleUnicodeStringTableHelper : public CSimpleStringTableHelper<TValue, CUnicodeCharTraits, dwCmpFlags>
{
};

template <typename TValue, DWORD dwCmpFlags = 0, typename THashHelper = CSimpleUnicodeStringTableHelper<TValue, dwCmpFlags> > class CSimpleUnicodeStringTable : public CSimpleStringTable<TValue, CUnicodeCharTraits, dwCmpFlags, THashHelper>
{
    typedef CSimpleStringTable<TValue, CUnicodeCharTraits, dwCmpFlags, THashHelper> Base;
public:
    CSimpleUnicodeStringTable() : Base() { }
private:
    CSimpleUnicodeStringTable(const CSimpleUnicodeStringTable &);
    void operator =(const CSimpleUnicodeStringTable &);
};

template <typename TValue, DWORD dwCmpFlags = 0, typename THashHelper = CSimpleUnicodeStringTableHelper<TValue, dwCmpFlags> > class CSimpleUnicodeStringTableIter : public CSimpleStringTableIter<TValue, CUnicodeCharTraits, dwCmpFlags, THashHelper>
{
    typedef CSimpleStringTableIter<TValue, CUnicodeCharTraits, dwCmpFlags, THashHelper> Base;
    typedef CSimpleUnicodeStringTable<TValue, dwCmpFlags, THashHelper> TTable;

public:
    CSimpleUnicodeStringTableIter(TTable &rTable) : Base(rTable) { }
private:
    CSimpleUnicodeStringTableIter(const CSimpleUnicodeStringTableIter &);
    void operator =(const CSimpleUnicodeStringTableIter &);
};

// CCaseInsensitiveSimpleStringTable et al:

template <typename TValue, typename TCharTraits> class CCaseInsensitiveSimpleStringTableHelper : public CSimpleStringTableHelper<TValue, TCharTraits, true>
{
};

template <typename TValue, typename TCharTraits, typename THashHelper = CCaseInsensitiveSimpleStringTableHelper<TValue, TCharTraits> > class CCaseInsensitiveSimpleStringTable : public CSimpleStringTable<TValue, TCharTraits, true, THashHelper>
{
    typedef CSimpleStringTable<TValue, TCharTraits, true, THashHelper> Base;
public:
    CCaseInsensitiveSimpleStringTable() : Base() { }
};

template <typename TValue, typename TCharTraits, typename THashHelper = CCaseInsensitiveSimpleStringTableHelper<TValue, TCharTraits> > class CCaseInsensitiveSimpleStringTableIter : public CSimpleStringTableIter<TValue, TCharTraits, true, THashHelper>
{
    typedef CSimpleStringTableIter<TValue, TCharTraits, true, THashHelper> Base;
public:
    CCaseInsensitiveSimpleStringTableIter(CCaseInsensitiveSimpleStringTable<TValue, TCharTraits, THashHelper> &rTable) : Base(rTable) { }
};

// CCaseInsensitiveSimpleUnicodeStringTable et al:

template <typename TValue> class CCaseInsensitiveSimpleUnicodeStringTableHelper : public CSimpleUnicodeStringTableHelper<TValue, true>
{
};

template <typename TValue, typename THashHelper = CCaseInsensitiveSimpleUnicodeStringTableHelper<TValue> > class CCaseInsensitiveSimpleUnicodeStringTable : public CSimpleUnicodeStringTable<TValue, true, THashHelper>
{
    typedef CSimpleUnicodeStringTable<TValue, true, THashHelper> Base;
public:
    CCaseInsensitiveSimpleUnicodeStringTable() : Base() { }

private:
    CCaseInsensitiveSimpleUnicodeStringTable(const CCaseInsensitiveSimpleUnicodeStringTable &);
    void operator =(const CCaseInsensitiveSimpleUnicodeStringTable &);
};

template <typename TValue, typename THashHelper = CCaseInsensitiveSimpleUnicodeStringTableHelper<TValue> > class CCaseInsensitiveSimpleUnicodeStringTableIter : public CSimpleUnicodeStringTableIter<TValue, true, THashHelper>
{
    typedef CSimpleUnicodeStringTableIter<TValue, true, THashHelper> Base;
public:
    CCaseInsensitiveSimpleUnicodeStringTableIter(CCaseInsensitiveSimpleUnicodeStringTable<TValue, THashHelper> &rTable) : Base(rTable) { }

private:
    CCaseInsensitiveSimpleUnicodeStringTableIter(const CCaseInsensitiveSimpleUnicodeStringTableIter &);
    void operator =(const CCaseInsensitiveSimpleUnicodeStringTableIter &);
};

// CCaseInsensitiveStringPtrTable et al:

template <typename TValue, typename TCharTraits> class CCaseInsensitiveStringPtrTableHelper : public CStringPtrTableHelper<TValue, TCharTraits, true>
{
};

template <typename TValue, typename TCharTraits, typename THashHelper = CCaseInsensitiveStringPtrTableHelper<TValue, TCharTraits> > class CCaseInsensitiveStringPtrTable : public CStringPtrTable<TValue, TCharTraits, true, THashHelper>
{
    typedef CStringPtrTable<TValue, TCharTraits, true, THashHelper> Base;
public:
    CCaseInsensitiveStringPtrTable() : Base() { }
};

template <typename TValue, typename TCharTraits, typename THashHelper = CCaseInsensitiveStringPtrTableHelper<TValue, TCharTraits> > class CCaseInsensitiveStringPtrTableIter : public CStringPtrTableIter<TValue, TCharTraits, true, THashHelper>
{
    typedef CStringPtrTableIter<TValue, TCharTraits, true, THashHelper> Base;

public:
    CCaseInsensitiveStringPtrTableIter(CCaseInsensitiveStringPtrTable<TValue, TCharTraits, THashHelper> &rTable) : Base(rTable) { }
};

// CCaseInsensitiveUnicodeStringPtrTable et al:

template <typename TValue> class CCaseInsensitiveUnicodeStringPtrTableHelper : public CStringPtrTableHelper<TValue, CUnicodeCharTraits, true>
{
};

template <typename TValue, typename THashHelper = CCaseInsensitiveUnicodeStringPtrTableHelper<TValue> > class CCaseInsensitiveUnicodeStringPtrTable : public CStringPtrTable<TValue, CUnicodeCharTraits, true, THashHelper>
{
    typedef CStringPtrTable<TValue, CUnicodeCharTraits, true, THashHelper> Base;
public:
    CCaseInsensitiveUnicodeStringPtrTable() { }

private:
    CCaseInsensitiveUnicodeStringPtrTable(const CCaseInsensitiveUnicodeStringPtrTable &r);
    void operator =(const CCaseInsensitiveUnicodeStringPtrTable &r);
};

template <typename TValue, typename THashHelper = CCaseInsensitiveUnicodeStringPtrTableHelper<TValue> > class CCaseInsensitiveUnicodeStringPtrTableIter : public CStringPtrTableIter<TValue, CUnicodeCharTraits, true, THashHelper>
{
    typedef CStringPtrTableIter<TValue, CUnicodeCharTraits, true, THashHelper> Base;

public:
    CCaseInsensitiveUnicodeStringPtrTableIter(CCaseInsensitiveUnicodeStringPtrTable<TValue, THashHelper> &rTable) : Base(rTable) { }

private:
    CCaseInsensitiveUnicodeStringPtrTableIter(const CCaseInsensitiveUnicodeStringPtrTableIter &);
    void operator =(const CCaseInsensitiveUnicodeStringPtrTableIter &);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionlastwin32error.h ===
#if !defined(FUSION_INC_FUSIONLASTWIN32ERROR_H_INCLUDED_)
#define FUSION_INC_FUSIONLASTWIN32ERROR_H_INCLUDED_
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#if defined(_M_IX86)

inline DWORD FusionpGetLastWin32Error(void)
/* This works fine. */
{
    __asm
    { 
        mov eax, fs:[0] _TEB.LastErrorValue
    }
}

inline void FusionpGetLastWin32Error(
    DWORD *pdwLastError
    )
{
    *pdwLastError = ::FusionpGetLastWin32Error();
}

/* This works pretty ok. */

__forceinline VOID FusionpSetLastWin32Error(DWORD dw)
{
    NtCurrentTeb()->LastErrorValue = dw;
}

inline void FusionpClearLastWin32Error(void)
{
    __asm
    {
        mov fs:[0] _TEB.LastErrorValue, 0
    }
}

#else

inline DWORD FusionpGetLastWin32Error(void)
{
    return ::GetLastError();
}

inline void FusionpGetLastWin32Error(
    DWORD *pdwLastError
    )
{
    *pdwLastError = ::GetLastError();
}

inline VOID FusionpSetLastWin32Error(DWORD dw)
{
    ::SetLastError(dw);
}

inline void FusionpClearLastWin32Error(void)
{
    ::SetLastError(ERROR_SUCCESS);
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionhandle.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    FusionHandle.h

Abstract:

    Simple exception safe wrappers of Win32 "handle" types, defining "handle" loosely.
        CFusionFile
        CDynamicLinkLibrary
        CFindFile (should be named CFindFileHandle, see NVseeLibIo::CFindFile vs. NVseeLibIo::CFindFileHandle
            CFindFile includes a WIN32_FIND_DATA, CFindFileHandle does not.)
        CFileMapping
        CMappedViewOfFile
        CRegKey
    See also:
        NVseeLibReg::CRegKey
        NVseeLibIo::CFusionFile
        NVseeLibIo::CFileMapping
        NVseeLibIo::CMappedViewOfFile
        NVseeLibIo::CFindFullPath
        NVseeLibModule::CDynamicLinkLibrary
        etc.
 
Author:

    Jay Krell (a-JayK, JayKrell) May 2000

Revision History:

--*/
#pragma once

#include "fusiontrace.h"
#include "fusionbuffer.h"
#include "wtypes.h"
#include "wincrypt.h"

template <void* const* invalidValue, typename Closer>
class CHandleTemplate
{
public:
    // void* instead of HANDLE to fudge views
    // HANDLE is void*
    CHandleTemplate(const void* handle = *invalidValue);
    ~CHandleTemplate();
    BOOL Win32Close();
    void* Detach();
    void operator=(const void*);

    operator void*() const;
    operator const void*() const;

    // private
    class CSmartPointerPointerOrDumbPointerPointer
    {
    public:
        CSmartPointerPointerOrDumbPointerPointer(CHandleTemplate* p) : m(p) { }
        operator CHandleTemplate*() { return m; }
        operator void**() { /*assert((**m).m_handle == *invalidValue);*/ return &(*m).m_handle; }
        operator HKEY*() { /*assert((**m).m_handle == *invalidValue);*/
            //compiler bug? m->operator HKEY(); // only allow this to compile for CFusionRegKey
            //static_cast<HKEY>(*m);
            static_cast<CRegKey*>(m);
            return reinterpret_cast<HKEY*>(operator void**()); }
        operator HCRYPTHASH*() {
            static_cast<CCryptHash*>(m);
            return reinterpret_cast<HCRYPTHASH*>(operator void**()); }

        CHandleTemplate* m;
    };

    CSmartPointerPointerOrDumbPointerPointer operator&() { return CSmartPointerPointerOrDumbPointerPointer(this); }

    void* m_handle;

    static void* GetInvalidValue() { return *invalidValue; }
    bool IsValid() const { return m_handle != *invalidValue; }

private:
    CHandleTemplate(const CHandleTemplate&); // deliberately not implemented
    void operator=(const CHandleTemplate&); // deliberately not implemented
};

__declspec(selectany) extern void* const hInvalidValue    = INVALID_HANDLE_VALUE;
__declspec(selectany) extern void* const hNull            = NULL;

/* This closes a Win32 event log handle for writing. */
class COperatorDeregisterEventSource
{
public:    BOOL operator()(void* handle) const;
};

/* This closes a Win32 event log handle for reading. */
class COperatorCloseEventLog
{
public:    BOOL operator()(void* handle) const;
};

/* This closes file, event, mutex, semaphore, etc. kernel objects */
class COperatorCloseHandle
{
public:    BOOL operator()(void* handle) const;
};

//
// Closes HCRYPTHASH objects
//
class COperatorCloseCryptHash
{
public:    BOOL operator()(void* handle) const;
};

/* this closes FindFirstFile/FindNextFile */
class COperatorFindClose
{
public:    BOOL operator()(void* handle) const;
};

/* this closes MapViewOfFile */
class COperatorUnmapViewOfFile
{
public: BOOL operator()(void* handle) const;
};

/* this closes FreeLibrary */
class COperatorFreeLibrary
{
public: BOOL operator()(void* handle) const;
};

/* this closes CreateActCtx/AddRefActCtx */
class COperatorReleaseActCtx
{
public: BOOL operator()(void* handle) const;
};

#include "fusionreg.h"

class CEvent : public CHandleTemplate<&hNull, COperatorCloseHandle>
{
private:
    typedef CHandleTemplate<&hNull, COperatorCloseHandle> Base;
public:
    CEvent(void* handle = NULL) : Base(handle) { }

    BOOL Win32CreateEvent(BOOL ManualReset, BOOL InitialState, PCWSTR Name = NULL);

    void operator=(void* v) { Base::operator=(v); }

private:
    CEvent(const CEvent &); // intentionally not implemented
    void operator =(const CEvent &); // intentionally not implemented
};

class CThread : public CHandleTemplate<&hNull, COperatorCloseHandle>
{
private:
    typedef CHandleTemplate<&hNull, COperatorCloseHandle> Base;
public:
    CThread(void* handle = NULL) : Base(handle) { }

    BOOL Win32CreateThread(LPTHREAD_START_ROUTINE StartAddress, LPVOID Parameter, DWORD Flags = 0, LPDWORD ThreadId = NULL);

    void operator=(void* v) { Base::operator=(v); }

private:
    CThread(const CThread &); // intentionally not implemented
    void operator =(const CThread &); // intentionally not implemented
};

class CFindFile : public CHandleTemplate<&hInvalidValue, COperatorFindClose>
{
private:
    typedef CHandleTemplate<&hInvalidValue, COperatorFindClose> Base;
public:
    CFindFile(void* handle = INVALID_HANDLE_VALUE) : Base(handle) { }
    HRESULT HrFindFirstFile(PCSTR nameOrWildcard, WIN32_FIND_DATAA*);
    HRESULT HrFindFirstFile(PCWSTR nameOrWildcard, WIN32_FIND_DATAW*);
    BOOL Win32FindFirstFile( PCSTR nameOrWildcard, WIN32_FIND_DATAA*);
    BOOL Win32FindFirstFile(PCWSTR nameOrWildcard, WIN32_FIND_DATAW*);
    void operator=(void* v) { Base::operator=(v); }

private:
    CFindFile(const CFindFile &); // intentionally not implemented
    void operator =(const CFindFile &); // intentionally not implemented
};

class CFusionFile : public CHandleTemplate<&hInvalidValue, COperatorCloseHandle>
{
private:
    typedef CHandleTemplate<&hInvalidValue, COperatorCloseHandle> Base;

public:
    CFusionFile(void* handle = INVALID_HANDLE_VALUE) : Base(handle) { }
    HRESULT HrCreateFile( PCSTR name, DWORD access, DWORD share, DWORD openOrCreate);
    HRESULT HrCreateFile(PCWSTR name, DWORD access, DWORD share, DWORD openOrCreate);
    BOOL Win32CreateFile( PCSTR name, DWORD access, DWORD share, DWORD openOrCreate);
    BOOL Win32CreateFile(PCWSTR name, DWORD access, DWORD share, DWORD openOrCreate);
    BOOL Win32GetSize(ULONGLONG &rulSize) const;
    void operator=(void* v) { Base::operator=(v); }

private:
    CFusionFile(const CFusionFile &); // intentionally not implemented
    void operator =(const CFusionFile &); // intentionally not implemented
};

class CFileMapping : public CHandleTemplate<&hNull, COperatorCloseHandle>
{
private:
    typedef CHandleTemplate<&hNull, COperatorCloseHandle> Base;
public:
    CFileMapping(void* handle = NULL) : Base(handle) { }
    HRESULT HrCreateFileMapping(void* file, DWORD flProtect, ULONGLONG maximumSize=0, PCWSTR name=0);
    BOOL Win32CreateFileMapping(void* file, DWORD flProtect, ULONGLONG maximumSize=0, PCWSTR name=0);
    void operator=(void* v) { Base::operator=(v); }
private:
    CFileMapping(const CFileMapping &); // intentionally not implemented
    void operator =(const CFileMapping &); // intentionally not implemented
};

class CCryptHash : public CHandleTemplate<&hNull, COperatorCloseCryptHash>
{
private:
    typedef CHandleTemplate<&hNull, COperatorCloseCryptHash> Base;
public:
    CCryptHash( HCRYPTHASH hash = NULL ) : Base((void*)hash) { }
    operator HCRYPTHASH() { return (HCRYPTHASH)(Base::operator void*()); }
    void operator=(HCRYPTHASH hash) { 
        ASSERT_NTC(!IsValid());
        m_handle = (void*)hash;
    }

private:
    CCryptHash( const CCryptHash & );
    CCryptHash &operator=( const CCryptHash & );
};


class CMappedViewOfFile : public CHandleTemplate<&hNull, COperatorUnmapViewOfFile>
{
private:
    typedef CHandleTemplate<&hNull, COperatorUnmapViewOfFile> Base;
public:
    CMappedViewOfFile(void* handle = NULL) : Base(handle) { }
    HRESULT HrMapViewOfFile(void* fileMapping, DWORD access, ULONGLONG offset=0, SIZE_T size=0);
    BOOL Win32MapViewOfFile(void* fileMapping, DWORD access, ULONGLONG offset=0, SIZE_T size=0);
    void operator=(void* v) { Base::operator=(v); }
    operator void*()        { return Base::operator void*(); }
private:
    CMappedViewOfFile(const CMappedViewOfFile &); // intentionally not implemented
    void operator =(const CMappedViewOfFile &); // intentionally not implemented
    operator void*() const; // intentionally not implemented
};

class CDynamicLinkLibrary : public CHandleTemplate<&hNull, COperatorFreeLibrary>
{
private:
    typedef CHandleTemplate<&hNull, COperatorFreeLibrary> Base;
public:
    CDynamicLinkLibrary(void* handle = NULL) : Base(handle) { }

    BOOL Win32LoadLibrary(PCWSTR file, DWORD flags = 0);

    template <typename PointerToFunction>
    bool Win32GetProcAddress(PCSTR procName, PointerToFunction* ppfn)
    {
        return (*ppfn = reinterpret_cast<PointerToFunction>(::GetProcAddress(*this, procName))) != NULL;
    }

    operator HMODULE() { return reinterpret_cast<HMODULE>(operator void*()); }
    HMODULE Detach() { return reinterpret_cast<HMODULE>(Base::Detach()); }
    void operator=(void* v) { Base::operator=(v); }
private:
    CDynamicLinkLibrary(const CDynamicLinkLibrary &); // intentionally not implemented
    void operator =(const CDynamicLinkLibrary &); // intentionally not implemented
};

class CFusionActCtxHandle : public CHandleTemplate<&hInvalidValue, COperatorReleaseActCtx>
{
private:
    typedef CHandleTemplate<&hInvalidValue, COperatorReleaseActCtx> Base;
public:
    CFusionActCtxHandle(void* handle = INVALID_HANDLE_VALUE) : Base(handle) { }
    BOOL Win32Create(PCACTCTXW);
    void operator=(void* v) { Base::operator=(v); }
private:
    CFusionActCtxHandle(const CFusionActCtxHandle &); // intentionally not implemented
    void operator =(const CFusionActCtxHandle &); // intentionally not implemented
};

class CFusionActCtxScope
{
protected:
    BOOL        m_fSuccess;
    ULONG_PTR   m_ulCookie;
public:
    CFusionActCtxScope();
    ~CFusionActCtxScope();
    BOOL Win32Activate(HANDLE hActCtx);

private:
    CFusionActCtxScope(const CFusionActCtxScope &); // intentionally not implemented
    void operator =(const CFusionActCtxScope &); // intentionally not implemented
};

/*--------------------------------------------------------------------------
CFindFile
--------------------------------------------------------------------------*/

inline BOOL
CFindFile::Win32FindFirstFile(
    PCSTR nameOrWildcard,
    WIN32_FIND_DATAA *data
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    HANDLE hTemp = ::FindFirstFileA(nameOrWildcard, data);
    if (hTemp == INVALID_HANDLE_VALUE)
    {
        goto Exit;
    }

    (*this) = hTemp;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

inline BOOL
CFindFile::Win32FindFirstFile(
    PCWSTR nameOrWildcard,
    WIN32_FIND_DATAW *data
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    HANDLE hTemp = ::FindFirstFileW(nameOrWildcard, data);
    if (hTemp == INVALID_HANDLE_VALUE)
    {
        goto Exit;
    }

    (*this) = hTemp;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

inline
HRESULT
CFindFile::HrFindFirstFile(
    PCSTR nameOrWildcard,
    WIN32_FIND_DATAA *data
    )
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
    FN_TRACE_HR(hr);

    IFW32FALSE_EXIT(this->Win32FindFirstFile(nameOrWildcard, data));

    hr = NOERROR;
Exit:
    return hr;
}

inline
HRESULT
CFindFile::HrFindFirstFile(PCWSTR nameOrWildcard, WIN32_FIND_DATAW* data)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
    FN_TRACE_HR(hr);

    IFW32FALSE_EXIT(this->Win32FindFirstFile(nameOrWildcard, data));

    hr = NOERROR;
Exit:
    return hr;
}

/*--------------------------------------------------------------------------
CFusionFile
--------------------------------------------------------------------------*/

inline BOOL
CFusionFile::Win32CreateFile(
    PCSTR name,
    DWORD access,
    DWORD share,
    DWORD openOrCreate
    )
{
	FN_PROLOG_WIN32

    HANDLE hTemp;
	
	IFW32INVALIDHANDLE_ORIGINATE_AND_EXIT(
		hTemp = ::CreateFileA(name, access, share, NULL, openOrCreate, FILE_ATTRIBUTE_NORMAL, NULL));
    operator=(hTemp);

	FN_EPILOG
}

inline BOOL
CFusionFile::Win32CreateFile(
    PCWSTR name,
    DWORD access,
    DWORD share,
    DWORD openOrCreate
    )
{
	FN_PROLOG_WIN32

    HANDLE hTemp;
	
	IFW32INVALIDHANDLE_ORIGINATE_AND_EXIT(
		hTemp = ::CreateFileW(name, access, share, NULL, openOrCreate, FILE_ATTRIBUTE_NORMAL, NULL));
    operator=(hTemp);

	FN_EPILOG
}

inline HRESULT CFusionFile::HrCreateFile(PCSTR name, DWORD access, DWORD share, DWORD openOrCreate)
{
    if (!this->Win32CreateFile(name, access, share, openOrCreate))
        return HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
    return NOERROR;
}

inline HRESULT CFusionFile::HrCreateFile(PCWSTR name, DWORD access, DWORD share, DWORD openOrCreate)
{
    if (!this->Win32CreateFile(name, access, share, openOrCreate))
        return HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
    return NOERROR;
}

inline BOOL
CFusionFile::Win32GetSize(ULONGLONG &rulSize) const
{
    DWORD highPart = 0;
    DWORD lastError = NO_ERROR;
    DWORD lowPart = ::GetFileSize(m_handle, &highPart);
    if (lowPart == INVALID_FILE_SIZE && (lastError = ::FusionpGetLastWin32Error()) != NO_ERROR)
    {
		TRACE_WIN32_FAILURE_ORIGINATION(GetFileSize);
        return FALSE;
    }
    ULARGE_INTEGER liSize;
    liSize.LowPart = lowPart;
    liSize.HighPart = highPart;
    rulSize = liSize.QuadPart;
    return TRUE;
}

/*--------------------------------------------------------------------------
CFileMapping
--------------------------------------------------------------------------*/

inline HRESULT
CFileMapping::HrCreateFileMapping(void* file, DWORD flProtect, ULONGLONG maximumSize, PCWSTR name)
{
    LARGE_INTEGER liMaximumSize;
    liMaximumSize.QuadPart = maximumSize;
    HANDLE hTemp = ::CreateFileMappingW(file, NULL, flProtect, liMaximumSize.HighPart, liMaximumSize.LowPart, name);
    if (hTemp == NULL)
	{
		TRACE_WIN32_FAILURE_ORIGINATION(CreateFileMapping);
        return HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
	}
    operator=(hTemp);
    return S_OK;
}

inline BOOL
CFileMapping::Win32CreateFileMapping(
    void* file,
    DWORD flProtect,
    ULONGLONG maximumSize,
    PCWSTR name
    )
{
    return SUCCEEDED(this->HrCreateFileMapping(file, flProtect, maximumSize, name));
}

/*--------------------------------------------------------------------------
CMappedViewOfFile
--------------------------------------------------------------------------*/

inline HRESULT
CMappedViewOfFile::HrMapViewOfFile(
    void* fileMapping,
    DWORD access,
    ULONGLONG offset,
    SIZE_T size
    )
{
    ULARGE_INTEGER liOffset;
    liOffset.QuadPart = offset;

    void* pvTemp = ::MapViewOfFile(fileMapping, access, liOffset.HighPart, liOffset.LowPart, size);
    if (pvTemp == NULL)
	{
		TRACE_WIN32_FAILURE_ORIGINATION(MapViewOfFile);
        return HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
	}

    (*this) = pvTemp;

    return S_OK;
}

inline BOOL
CMappedViewOfFile::Win32MapViewOfFile(void* fileMapping, DWORD access, ULONGLONG offset, SIZE_T size)
{
    return SUCCEEDED(this->HrMapViewOfFile(fileMapping, access, offset, size));
}

/*--------------------------------------------------------------------------
CEvent
--------------------------------------------------------------------------*/

inline BOOL CEvent::Win32CreateEvent(BOOL ManualReset, BOOL InitialState, PCWSTR Name)
{
    HANDLE Temp = ::CreateEventW(NULL, ManualReset, InitialState, Name);
    if (Temp == NULL)
    {
		TRACE_WIN32_FAILURE_ORIGINATION(CreateEventW);
        return FALSE;
    }
    (*this) = Temp;
    return TRUE;
}

/*--------------------------------------------------------------------------
CThread
--------------------------------------------------------------------------*/
inline BOOL
CThread::Win32CreateThread(
    LPTHREAD_START_ROUTINE StartAddress,
    LPVOID Parameter,
    DWORD Flags,
    LPDWORD ThreadId
    )
{
    DWORD LocalThreadId;
    if (ThreadId == NULL)
        ThreadId = &LocalThreadId;
    HANDLE Temp = ::CreateThread(NULL, 0, StartAddress, Parameter, Flags, ThreadId);
    if (Temp == NULL)
    {
		TRACE_WIN32_FAILURE_ORIGINATION(CreateThread);
        return FALSE;
    }
    (*this) = Temp;
    return TRUE;
}

/*--------------------------------------------------------------------------
CDynamicLinkLibrary
--------------------------------------------------------------------------*/
inline BOOL
CDynamicLinkLibrary::Win32LoadLibrary(
    PCWSTR file,
    DWORD flags
    )
{
    void* temp = ::LoadLibraryExW(file, NULL, flags);
    if (temp == NULL)
	{
		TRACE_WIN32_FAILURE_ORIGINATION(LoadLibraryExW);
        return FALSE;
	}
    (*this) = temp;
    return TRUE;
}

/*--------------------------------------------------------------------------
CFusionActCtxHandle
--------------------------------------------------------------------------*/
inline BOOL
CFusionActCtxHandle::Win32Create(
    PCACTCTXW pActCtx
    )
{
    typedef HANDLE (WINAPI* PFN)(PCACTCTXW pActCtx);
    static PFN pfn;
    if (pfn == NULL)
    {
        HMODULE hmodKernel32 = ::GetModuleHandleW(L"Kernel32.dll");
        if (hmodKernel32 != NULL)
		{
            pfn = reinterpret_cast<PFN>(::GetProcAddress(hmodKernel32, "CreateActCtxW"));
			if (pfn == NULL)
				TRACE_WIN32_FAILURE_ORIGINATION(GetProcAddress);
		}
		else
			TRACE_WIN32_FAILURE_ORIGINATION(GetModuleHandleW);

        if (pfn == NULL)
            return FALSE;
    }
    void* temp = (*pfn)(pActCtx);
    if (temp == INVALID_HANDLE_VALUE)
	{
		TRACE_WIN32_FAILURE_ORIGINATION(CreateActCtxW);
        return FALSE;
	}
    (*this) = temp;
    return TRUE;
}

inline BOOL COperatorReleaseActCtx::operator()(HANDLE hActCtx) const
{
    typedef BOOL (WINAPI* PFN)(HANDLE);
    static PFN pfn;
    if (pfn == NULL)
    {
        HMODULE hmodKernel32 = ::GetModuleHandleW(L"Kernel32.dll");
        if (hmodKernel32 != NULL)
		{
            pfn = reinterpret_cast<PFN>(::GetProcAddress(hmodKernel32, "ReleaseActCtx"));
			if (pfn == NULL)
				TRACE_WIN32_FAILURE_ORIGINATION(GetProcAddress);
		}
		else
		{
			TRACE_WIN32_FAILURE_ORIGINATION(GetModuleHandleW);
		}
        if (pfn == NULL)
            return FALSE;
    }
    return pfn(hActCtx);
}

/*--------------------------------------------------------------------------
CFusionActCtxScope
--------------------------------------------------------------------------*/

inline CFusionActCtxScope::CFusionActCtxScope() : m_fSuccess(FALSE) { }

inline BOOL CFusionActCtxScope::Win32Activate(HANDLE hActCtx)
{
    typedef BOOL (WINAPI* PFN)(HANDLE hActCtx, ULONG_PTR* lpCookie);
    static PFN pfn;
    if (pfn == NULL)
    {
        HMODULE hmodKernel32 = ::GetModuleHandleW(L"Kernel32.dll");
        if (hmodKernel32 != NULL)
		{
            pfn = reinterpret_cast<PFN>(GetProcAddress(hmodKernel32, "ActivateActCtx"));
			if (pfn == NULL)
				TRACE_WIN32_FAILURE_ORIGINATION(GetProcAddress);
		}
		else
		{
			TRACE_WIN32_FAILURE_ORIGINATION(GetModuleHandleW);
		}

        if (pfn == NULL)
            return FALSE;
    }
    return (m_fSuccess = pfn(hActCtx, &m_ulCookie));
}

inline CFusionActCtxScope::~CFusionActCtxScope()
{
    if (m_fSuccess)
    {
        CSxsPreserveLastError ple;
        m_fSuccess = FALSE;
        typedef BOOL (WINAPI* PFN)(DWORD dwFlags, ULONG_PTR ulCookie);
        static PFN pfn;

        if (pfn == NULL)
        {
            HMODULE hmodKernel32 = GetModuleHandleW(L"Kernel32.dll");
            if (hmodKernel32 != NULL)
			{
                pfn = reinterpret_cast<PFN>(GetProcAddress(hmodKernel32, "DeactivateActCtx"));
				if (pfn == NULL)
					TRACE_WIN32_FAILURE_ORIGINATION(GetProcAddress);
			}
			else
			{
				TRACE_WIN32_FAILURE_ORIGINATION(GetModuleHandleW);
			}

            if (pfn == NULL)
            {
                ple.Restore();
                return;
            }
        }
        (*pfn)(0, m_ulCookie);
        ple.Restore();
    }
}

/*--------------------------------------------------------------------------
COperator*
--------------------------------------------------------------------------*/

inline BOOL COperatorCloseHandle::operator()(void* handle) const { return ::CloseHandle(handle); }
inline BOOL COperatorFindClose::operator()(void* handle) const { return ::FindClose(handle); }
inline BOOL COperatorUnmapViewOfFile::operator()(void* handle) const { return ::UnmapViewOfFile(handle); }
inline BOOL COperatorCloseEventLog::operator()(void* handle) const { return ::CloseEventLog(handle); }
inline BOOL COperatorDeregisterEventSource::operator()(void* handle) const { return ::DeregisterEventSource(handle); }
inline BOOL COperatorFreeLibrary::operator()(void* handle) const { return ::FreeLibrary(reinterpret_cast<HMODULE>(handle)); }
inline BOOL COperatorCloseCryptHash::operator()(void* handle) const { return ::CryptDestroyHash(reinterpret_cast<HCRYPTHASH>(handle)); };


/*--------------------------------------------------------------------------
CHandleTemplate
--------------------------------------------------------------------------*/

template <void* const* invalidValue, typename Closer>
CHandleTemplate<invalidValue, Closer>::CHandleTemplate(const void* handle)
: m_handle(const_cast<void*>(handle))
{
}

template <void* const* invalidValue, typename Closer>
void* CHandleTemplate<invalidValue, Closer>::Detach()
{
    void* handle = m_handle;
    m_handle = *invalidValue;
    return handle;
}

template <void* const* invalidValue, typename Closer>
void CHandleTemplate<invalidValue, Closer>::operator=(const void* handle)
{
    if (handle != m_handle)
    {
        void *SavedHandle = m_handle;
        m_handle = const_cast<void*>(handle);

        if (SavedHandle != *invalidValue)
        {
            Closer close;
            // a bug waiting to happen to customers
            VERIFY_NTC(close(SavedHandle));
        }
    }
}

template <void* const* invalidValue, typename Closer>
BOOL CHandleTemplate<invalidValue, Closer>::Win32Close()
{
    void* handle = Detach();
    if (handle != *invalidValue)
    {
        Closer close;
        return close(handle);
    }
    return TRUE;
}

template <void* const* invalidValue, typename Closer>
CHandleTemplate<invalidValue, Closer>::~CHandleTemplate()
{
    CSxsPreserveLastError ple;
    (void) this->Win32Close();
    ple.Restore();
}

template <void* const* invalidValue, typename Closer>
CHandleTemplate<invalidValue, Closer>::operator void*() const
{
    return m_handle;
}

template <void* const* invalidValue, typename Closer>
CHandleTemplate<invalidValue, Closer>::operator const void*() const
{
    return m_handle;
}

/*--------------------------------------------------------------------------
end of file
--------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionheap.h ===
#if !defined(FUSION_INC_FUSIONHEAP_H_INCLUDED_)
#define FUSION_INC_FUSIONHEAP_H_INCLUDED_

#pragma once

#include "debmacro.h"
#include "SxsExceptionHandling.h"
#include "fusionunused.h"
#include "fusionlastwin32error.h"

#if DBG
#if defined(FUSION_DEBUG_HEAP)
#undef FUSION_DEBUG_HEAP
#endif // defined(FUSION_DEBUG_HEAP)
#define FUSION_DEBUG_HEAP 1
#endif // DBG

//
//  We allocate FUSION_ARRAY_PREFIX_LENGTH extra bytes at
//  the beginning of array allocations to store the number of
//  elements in the array.
//

#define FUSION_ARRAY_PREFIX_LENGTH (sizeof(void*)*2)

C_ASSERT(FUSION_ARRAY_PREFIX_LENGTH >= sizeof(SIZE_T));

EXTERN_C
BOOL
FusionpInitializeHeap(
    HINSTANCE hInstance
    );

EXTERN_C
VOID
FusionpUninitializeHeap();

// Unique type so that we can overload operator new and delete and not
// have ambiguity with the fact that HANDLE == PVOID.

typedef struct _FUSION_HEAP_HANDLE_FAKE_STRUCT *FUSION_HEAP_HANDLE;

EXTERN_C FUSION_HEAP_HANDLE g_hHeap;
#define FUSION_DEFAULT_PROCESS_HEAP() (g_hHeap)

#if FUSION_DEBUG_HEAP

EXTERN_C FUSION_HEAP_HANDLE g_hDebugInfoHeap;
EXTERN_C LONG g_FusionHeapAllocationCount;
EXTERN_C LONG g_FusionHeapAllocationToBreakOn;

#define FUSION_HEAP_ALLOCATION_FREED_WHEN_DLL_UNLOADED (0x00000001)
#define FUSION_HEAP_DO_NOT_REPORT_LEAKED_ALLOCATION (0x00000002)

typedef struct _FUSION_HEAP_ALLOCATION_TRACKER *PFUSION_HEAP_ALLOCATION_TRACKER;

#if defined(_WIN64)
#define FUSION_HEAP_ALIGNMENT         16 /* 2*sizeof(void*) but __declspec(align()) doesn't like that */
#else
#define FUSION_HEAP_ALIGNMENT         8  /* 2*sizeof(void*) but __declspec(align()) doesn't like that */
#endif
#define FUSION_HEAP_ALIGNMENT_MINUS_1 (FUSION_HEAP_ALIGNMENT - 1)
#define FUSION_HEAP_ROUND_SIZE(_x)    (((_x) + FUSION_HEAP_ALIGNMENT_MINUS_1) & ~FUSION_HEAP_ALIGNMENT_MINUS_1)

typedef struct DECLSPEC_ALIGN(FUSION_HEAP_ALIGNMENT) _FUSION_HEAP_PREFIX
{
    union
    {
        PFUSION_HEAP_ALLOCATION_TRACKER Tracker;
        void* InterlockedAlignment[2];
    };
} FUSION_HEAP_PREFIX, *PFUSION_HEAP_PREFIX;

typedef struct DECLSPEC_ALIGN(FUSION_HEAP_ALIGNMENT) _FUSION_HEAP_ALLOCATION_TRACKER
{
    PFUSION_HEAP_PREFIX Prefix;
    FUSION_HEAP_HANDLE Heap;
    size_t AllocationSize;
    size_t RequestedSize;
    PCSTR FileName;
    PCSTR Expression;
    LONG SequenceNumber;
    INT Line;
    DWORD Flags;
    // We have to track this here because someone could change the global setting while the dll is running
    PUCHAR PostAllocPoisonArea;
    UCHAR PostAllocPoisonChar;
    ULONG PostAllocPoisonBytes;
#if FUSION_ENABLE_FROZEN_STACK
    PVOID pvFrozenStack;
#endif
} FUSION_HEAP_ALLOCATION_TRACKER, *PFUSION_HEAP_ALLOCATION_TRACKER;

PVOID
FusionpDbgHeapAlloc(
    FUSION_HEAP_HANDLE hHeap,
    DWORD dwHeapAllocFlags,
    SIZE_T cb,
    PCSTR pszFile,
    INT nLine,
    PCSTR pszExpression,
    DWORD dwFusionFlags
    );

PVOID
FusionpDbgHeapReAlloc(
    FUSION_HEAP_HANDLE hHeap,
    DWORD dwHeapReAllocFlags,
    PVOID lpMem,
    SIZE_T cb,
    PCSTR pszFile,
    INT nLine,
    PCSTR pszExpression,
    DWORD dwFusionFlags
    );

EXTERN_C
BOOL
FusionpDbgHeapFree(
    FUSION_HEAP_HANDLE hHeap,
    DWORD dwHeapFreeFlags,
    PVOID lpMem
    );

EXTERN_C
VOID
FusionpDeallocateTracker(
    PFUSION_HEAP_PREFIX p
    );

EXTERN_C
BOOL
FusionpEnableLeakTracking(
    BOOL Enable);

EXTERN_C
VOID *
FusionpGetFakeVTbl();


EXTERN_C
VOID
FusionpDontTrackBlk(
    VOID *pv
    );

#define FusionpHeapAllocEx(_hHeap, _dwFlags, _nBytes, _szExpr, _szFile, _nLine, _dwFusionHeapFlags) FusionpDbgHeapAlloc((_hHeap), (_dwFlags), (_nBytes), (_szFile), (_nLine), (_szExpr), (_dwFusionHeapFlags))
#define FusionpHeapReAllocEx(_hHeap, _dwFlags, _lpMem, _nBytes, _szExpr, _szFile, _nLine, _dwFusionHeapFlags) FusionpDbgHeapReAlloc((_hHeap), (_dwFlags), (_lpMem), (_nBytes), (_szFile), (_nLine), (_szExpr), (_dwFusionHeapFlags))
#define FusionpHeapFreeEx(_hHeap, _dwFlags, _lpMem) FusionpDbgHeapFree((_hHeap), (_dwFlags), (_lpMem))

#define FusionpHeapAlloc(_hHeap, _dwFlags, _nBytes) FusionpHeapAllocEx((_hHeap), (_dwFlags), (_nBytes), NULL, NULL, 0, 0)
#define FusionpHeapReAlloc(_hHeap, _dwFlags, _lpMem, _nBytes) FusionpHeapReAllocEx((_hHeap), (_dwFlags), (_lpMem), (_nBytes), NULL, NULL, 0, 0)
#define FusionpHeapFree(_hHeap, _dwFlags, _lpMem) FusionpHeapFreeEx((_hHeap), (_dwFlags), (_lpMem))

#define FUSION_HEAP_DISABLE_LEAK_TRACKING() do { ::FusionpEnableLeakTracking(FALSE); } while (0)
#define FUSION_HEAP_ENABLE_LEAK_TRACKING() do { ::FusionpEnableLeakTracking(TRUE); } while (0)

EXTERN_C
VOID
FusionpDumpHeap(
    PCWSTR PerLinePrefix
    );

#else // FUSION_DEBUG_HEAP

#define FusionpHeapAlloc HeapAlloc
#define FusionpHeapReAlloc HeapReAlloc
#define FusionpHeapFree HeapFree

#define FusionpHeapAllocEx(_hHeap, _dwFlags, _nBytes, _szExpr, _szFile, _nLine, _dwFusionHeapFlags) HeapAlloc((_hHeap), (_dwFlags), (_nBytes))
#define FusionpHeapReAllocEx(_hHeap, _dwFlags, _lpMem, _nBytes, _szExpr, _szFile, _nLine, _dwFusionHeapFlags) HeapReAlloc((_hHeap), (_dwFlags), (_lpMem), (_nBytes))
#define FusionpHeapFreeEx(_hHeap, _dwFlags, _lpMem) HeapFree((_hHeap), (_dwFlags), (_lpMem))

#define FUSION_HEAP_DISABLE_LEAK_TRACKING()
#define FUSION_HEAP_ENABLE_LEAK_TRACKING()

#endif // FUSION_DEBUG_HEAP

template <typename T> class CAllocator
{
public:
    static inline T *AllocateArray(FUSION_HEAP_HANDLE hHeap, PCSTR szFile, int nLine, PCSTR szExpression, DWORD dwWin32HeapFlags, SIZE_T cElements, DWORD dwFusionHeapFlags)
    {
        T *prgtResult = NULL;
        PVOID pv = ::FusionpHeapAllocEx(hHeap, dwWin32HeapFlags, FUSION_ARRAY_PREFIX_LENGTH + (sizeof(T) * cElements), szExpression, szFile, nLine, dwFusionHeapFlags);
        if (pv != NULL)
        {
            SIZE_T i;
            T *prgt = (T *) (((ULONG_PTR) pv) + FUSION_ARRAY_PREFIX_LENGTH);

            *((SIZE_T *) pv) = cElements;

            // Initialize each element by calling its constructing via the "normal" placement new.
            for (i=0; i<cElements; i++)
            {
                T *pt = new(&prgt[i]) T;
                ASSERT_NTC(pt == &prgt[i]);
                RETAIL_UNUSED(pt);
            }

            prgtResult = prgt;
        }

        return prgtResult;
    }

    static inline T *AllocateSingleton(FUSION_HEAP_HANDLE hHeap, PCSTR szFile, int nLine, PCSTR szExpression, DWORD dwWin32HeapFlags, DWORD dwFusionHeapFlags)
    {
        T *ptResult = NULL;
        PVOID pv = ::FusionpHeapAllocEx(hHeap, dwWin32HeapFlags, sizeof(T), szExpression, szFile, nLine, dwFusionHeapFlags);
        if (pv != NULL)
        {
            // Initialize calling its constructing via the "normal" placement new.
            T *pt = new(pv) T;
            ASSERT_NTC(pt == pv);
            ptResult = pt;
        }

        return ptResult;
    }

    static inline VOID DeallocateArray(FUSION_HEAP_HANDLE hHeap, DWORD dwWin32HeapFlags, T *prgt)
    {
        const DWORD _dwLastError = ::FusionpGetLastWin32Error();

        if (prgt != NULL)
        {
            // This thing had better be aligned...
            ASSERT_NTC(
                (((ULONG_PTR) prgt) & 0x7) == 0);

            SIZE_T *pcElements = (SIZE_T *) (((ULONG_PTR) prgt) - FUSION_ARRAY_PREFIX_LENGTH);
            SIZE_T i;
            SIZE_T cElements = *pcElements;

            for (i=0; i<cElements; i++)
                prgt[i].~T();

            ::FusionpHeapFree(hHeap, dwWin32HeapFlags, pcElements);
        }

        ::FusionpSetLastWin32Error( _dwLastError );
    }

    static inline VOID DeallocateSingleton(FUSION_HEAP_HANDLE hHeap, DWORD dwWin32HeapFlags, T *pt)
    {
        const DWORD _dwLastError = ::FusionpGetLastWin32Error();

        if (pt != NULL)
        {
            pt->~T();
            ::FusionpHeapFree(hHeap, dwWin32HeapFlags, pt);
        }

        ::FusionpSetLastWin32Error( _dwLastError );
    }
};

template <typename T> inline void FusionpAllocateSingletonFromPrivateHeap(FUSION_HEAP_HANDLE hHeap, DWORD dwWin32HeapFlags, T *ptUnused, PCSTR szFile, int nLine, PCSTR szTypeName) { (ptUnused); return CAllocator<T>::AllocateSingleton(hHeap, szFile, nLine, szTypeName, 0, 0); }
template <typename T> inline void FusionpAllocateArrayFromPrivateHeap(FUSION_HEAP_HANDLE hHeap, DWORD dwWin32HeapFlags, SIZE_T cElements, T *ptUnused, PCSTR szFile, int nLine, PCSTR szTypeName) { (ptUnused); return CAllocator<T>::AllocateArray(hHeap, szFile, nLine, szTypeName, 0, cElements, 0); }
template <typename T> inline void FusionpDeleteArrayFromPrivateHeap(FUSION_HEAP_HANDLE hHeap, DWORD dwWin32HeapFlags, T *prgt) { CAllocator<T>::DeallocateArray(hHeap, dwWin32HeapFlags, prgt); }

template <typename T> inline void FusionpDeleteSingletonFromPrivateHeap(FUSION_HEAP_HANDLE hHeap, DWORD dwWin32HeapFlags, T *pt) { CAllocator<T>::DeallocateSingleton(hHeap, dwWin32HeapFlags, pt); }

#define FUSION_NEW_SINGLETON(_type) (new(__FILE__, __LINE__, #_type) _type)
#define FUSION_NEW_ARRAY(_type, _n) (new _type[_n])

// #define FUSION_DELETE_SINGLETON_(_heap, _ptr) do { ::FusionpDeleteSingletonFromPrivateHeap((_heap), 0, (_ptr)); } while (0)
// #define FUSION_DELETE_ARRAY_(_heap, _ptr) do { ::FusionpDeleteArrayFromPrivateHeap((_heap), 0, _ptr); } while (0)

#define FUSION_DELETE_SINGLETON(_ptr) do { delete (_ptr); } while (0) /* FUSION_DELETE_SINGLETON_(FUSION_DEFAULT_PROCESS_HEAP(), _ptr) */
#define FUSION_DELETE_ARRAY(_ptr) do { delete [](_ptr); } while (0) /* FUSION_DELETE_ARRAY_(FUSION_DEFAULT_PROCESS_HEAP(), _ptr) */

#define FUSION_RAW_ALLOC_(_heap, _cb, _typeTag) (::FusionpHeapAllocEx((_heap), 0, (_cb), #_typeTag, __FILE__, __LINE__, 0))
#define FUSION_RAW_DEALLOC_(_heap, _ptr) (::FusionpHeapFree((_heap), 0, (_ptr)))

#define FUSION_RAW_ALLOC(_cb, _typeTag) FUSION_RAW_ALLOC_(FUSION_DEFAULT_PROCESS_HEAP(), _cb, _typeTag)
#define FUSION_RAW_DEALLOC(_ptr) FUSION_RAW_DEALLOC_(FUSION_DEFAULT_PROCESS_HEAP(), _ptr)

#define NEW(_type) FUSION_NEW_SINGLETON(_type)
#define NEW_SINGLETON_(_heap, _type) FUSION_NEW_SINGLETON_(_heap, _type)
#define NEW_ARRAY_(_heap, _type, _n) FUSION_NEW_ARRAY_(_heap, _type, _n)

#define DELETE_ARRAY(_ptr) FUSION_DELETE_ARRAY(_ptr)
#define DELETE_ARRAY_(_heap, _ptr) FUSION_DELETE_ARRAY_(_heap, _ptr)

#define DELETE_SINGLETON(_ptr) FUSION_DELETE_SINGLETON(_ptr)
#define DELETE_SINGLETON_(_heap, _ptr) FUSION_DELETE_SINGLETON_(_heap, _ptr)

#if defined(__cplusplus)

#if FUSION_ENABLE_UNWRAPPED_NEW

inline void * __cdecl operator new(size_t cb)
{
    return ::FusionpHeapAllocEx(FUSION_DEFAULT_PROCESS_HEAP(), 0, cb, NULL, NULL, NULL, 0);
}

inline void * __cdecl operator new(size_t cb, PCSTR pszFile, int nLine, PCSTR pszTypeName)
{
    return ::FusionpHeapAllocEx(FUSION_DEFAULT_PROCESS_HEAP(), 0, cb, pszTypeName, pszFile, nLine, 0);
}

#else // FUSION_ENABLE_UNWRAPPED_NEW

EXTERN_C PVOID SomebodyUsedUnwrappedOperatorNew(size_t cb);

#pragma warning(push)
#pragma warning(disable: 4211)

static inline void * __cdecl operator new(size_t cb)
{
    // Call a bogus function so that we'll get a link error. DO NOT IMPLEMENT THIS
    // FUNCTION EVER!  It's referenced here to generate build errors rather than runtime ones.
    return ::SomebodyUsedUnwrappedOperatorNew(cb);
}

#pragma warning(pop)

#endif // FUSION_ENABLE_UNWRAPPED_NEW

#if FUSION_ENABLE_UNWRAPPED_DELETE

inline void __cdecl operator delete(void *pv)
{
    if (pv != NULL)
        ::FusionpHeapFreeEx(FUSION_DEFAULT_PROCESS_HEAP(), 0, pv);
}

inline void __cdecl operator delete(void *pv, PCSTR pszFile, int nLine, PCSTR pszTypeName)
{
    if (pv != NULL)
        ::FusionpHeapFreeEx(FUSION_DEFAULT_PROCESS_HEAP(), 0, pv);
}

#else

EXTERN_C VOID SomebodyUsedUnwrappedOperatorDelete(void *pv);

static void __cdecl operator delete(void *pv)
{
    return ::SomebodyUsedUnwrappedOperatorDelete(pv);
}

#endif

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *P) { return (P); }
#if     _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void *) { return; }
#endif
#endif

inline void * __cdecl operator new(size_t cb, FUSION_HEAP_HANDLE hHeap, PCSTR pszFile, INT nLine, PCSTR pszExpression, DWORD dwFusionHeapFlags)
{
    ASSERT_NTC(hHeap != 0);
    return ::FusionpHeapAllocEx(hHeap, 0, cb, pszExpression, pszFile, nLine, dwFusionHeapFlags);
}

//
// error C4291: 'void *operator new(size_t,FUSION_HEAP_HANDLE,const PCSTR,INT,const PCSTR,DWORD)'
// : no matching operator delete found; memory will not be freed if initialization throws an exception
//
inline void __cdecl
operator delete(
    void* p,
    FUSION_HEAP_HANDLE hHeap,
    PCSTR /* pszFile */,
    INT /* nLine */,
    PCSTR /* pszExpression */,
    DWORD /* dwFusionHeapFlags */)
{
    ASSERT_NTC(hHeap != 0);
    FusionpDeleteSingletonFromPrivateHeap(hHeap, 0, p);
}

#endif // defined(__cplusplus)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionhashstring.h ===
#if !defined(_FUSION_INC_FUSIONHASHSTRING_H_INCLUDED_)
#define _FUSION_INC_FUSIONHASHSTRING_H_INCLUDED_

#pragma once

//
//  Do not change this algorithm ID!  We depend on persisted string hashes for
//  quick lookups.
//

#define FUSION_HASH_ALGORITHM HASH_STRING_ALGORITHM_X65599

BOOL
FusionpHashUnicodeString(
    PCWSTR szString,
    SIZE_T cchString,
    PULONG HashValue,
    bool fCaseInsensitive
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionntdll.h ===
#if !defined(FUSION_INC_FUSIONNTDLL_H_INCLUDED_)
#define FUSION_INC_FUSIONNTDLL_H_INCLUDED_

#pragma once

#if !defined(FUSION_STATIC_NTDLL)
#if FUSION_WIN
#define FUSION_STATIC_NTDLL 1
#else
#define FUSION_STATIC_NTDLL 0
#endif // FUSION_WIN
#endif // !defined(FUSION_STATIC_NTDLL)

void
FusionpInitializeNTDLLPtr(
    PVOID *ppfn,
    PCSTR szFunctionName
    );

#if FUSION_STATIC_NTDLL
#define FUSION_WRAP_NTDLL_FN(_rt, _api, _ai, _ao) inline _rt Fusionp ## _api _ai { return ::_api _ao; }
#else
#define FUSION_WRAP_NTDLL_FN(_rt, _api, _ai, _ao) \
extern _rt (NTAPI * g_Fusionp ## _api) _ai; \
inline _rt Fusionp ## _api _ai { return (*g_Fusionp ## _api) _ao; }
#endif

FUSION_WRAP_NTDLL_FN(WCHAR, RtlUpcaseUnicodeChar, (WCHAR wch), (wch))
FUSION_WRAP_NTDLL_FN(WCHAR, RtlDowncaseUnicodeChar, (WCHAR wch), (wch))
FUSION_WRAP_NTDLL_FN(ULONG, vDbgPrintExWithPrefix, (PCSTR Prefix, ULONG ComponentId, ULONG Level, PCSTR Format, va_list arglist), ((PCH) Prefix, ComponentId, Level, (PCH) Format, arglist))
FUSION_WRAP_NTDLL_FN(DWORD, RtlNtStatusToDosError, (NTSTATUS st), (st))
FUSION_WRAP_NTDLL_FN(NTSTATUS, RtlHashUnicodeString, (PCUNICODE_STRING String, BOOLEAN CaseInSensitive, ULONG HashAlgorithm, PULONG HashValue), (String, CaseInSensitive, HashAlgorithm, HashValue))
FUSION_WRAP_NTDLL_FN(NTSTATUS, RtlExpandEnvironmentStrings_U, (PVOID Environment, PUNICODE_STRING Source, PUNICODE_STRING Destination, PULONG ReturnedLength), (Environment, Source, Destination, ReturnedLength))
FUSION_WRAP_NTDLL_FN(NTSTATUS, NtQueryDebugFilterState, (ULONG ComponentId, ULONG Level), (ComponentId, Level))
FUSION_WRAP_NTDLL_FN(LONG, RtlCompareUnicodeString, (PCUNICODE_STRING String1, PCUNICODE_STRING String2, BOOLEAN CaseInSensitive), ((PUNICODE_STRING) String1, (PUNICODE_STRING) String2, CaseInSensitive));
FUSION_WRAP_NTDLL_FN(LONG, RtlUnhandledExceptionFilter, (struct _EXCEPTION_POINTERS *ExceptionInfo), (ExceptionInfo))
FUSION_WRAP_NTDLL_FN(NTSTATUS, NtAllocateLocallyUniqueId, (PLUID Luid), (Luid))

#if DBG
FUSION_WRAP_NTDLL_FN(VOID, RtlAssert, (PVOID FailedAssertion, PVOID FileName, ULONG LineNumber, PCSTR Message), (FailedAssertion, FileName, LineNumber, (PCHAR) Message))
#endif // DBG

inline ULONG FusionpDbgPrint(PCSTR Format, ...) { va_list ap; va_start(ap, Format); ULONG uRetVal = ::FusionpvDbgPrintExWithPrefix("", DPFLTR_FUSION_ID, 0, Format, ap); va_end(ap); return uRetVal; }

#endif // FUSION_INC_FUSIONNTDLL_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionmodule.h ===
#if !defined(_FUSION_INC_FUSIONMODULE_H_INCLUDED_)
#define _FUSION_INC_FUSIONMODULE_H_INCLUDED_

#pragma once

#include "oleaut_d.h"
#include "debmacro.h"
#include "FusionBuffer.h"

#define FUSION_OA_API(_fn, _args, _nargs) void _fn _args { ASSERT(m_fFusionModuleInitialized); m_OleAut._fn _nargs; }
#define FUSION_OA_API_(_rett, _fn, _args, _nargs) _rett _fn _args { ASSERT(m_fFusionModuleInitialized); return m_OleAut._fn _nargs; }

#define FUSION_MODULE_UNUSED(x) (x)

class CFusionModule
{
public:
    CFusionModule() : m_fFusionModuleInitialized(false), m_hInstDLL(NULL), m_dwEnumLocaleTLS(0)
#if DBG
        , m_dwTraceContextTLS(0)
#endif
    { }
    ~CFusionModule() { }

    // Pass all DllMain() activations through here for attach and detach time work.
    BOOL ModuleDllMain(HINSTANCE hInstDLL, DWORD dwReason, LPVOID pvReserved);
    HRESULT Initialize();
    FUSION_OA_API_(HRESULT, VariantClear, (VARIANTARG *pvarg), (pvarg))
    FUSION_OA_API_(HRESULT, VariantInit, (VARIANTARG *pvarg), (pvarg))
    FUSION_OA_API_(HRESULT, VariantCopy, (VARIANTARG *pvargDest, const VARIANTARG *pvargSrc), (pvargDest, const_cast<VARIANTARG *>(pvargSrc)))
    FUSION_OA_API_(HRESULT, VariantChangeType, (VARIANTARG *pvargDest, const VARIANTARG *pvargSrc, USHORT wFlags, VARTYPE vt),
        (pvargDest, const_cast<VARIANTARG *>(pvargSrc), wFlags, vt))
    FUSION_OA_API_(BSTR, SysAllocString, (LPCOLESTR sz), (sz))
    FUSION_OA_API(SysFreeString, (BSTR bstr), (bstr))

    typedef BOOL (CALLBACK * LOCALE_ENUMPROCEXW)(LPWSTR pszLCID, LPVOID pvContext);
    typedef BOOL (CALLBACK * LOCALE_ENUMPROCEXA)(LPSTR pszLCID, LPVOID pvContext);

    BOOL EnumSystemLocalesExA(LOCALE_ENUMPROCEXA lpLocaleEnumProc, DWORD dwFlags, LPVOID pvContext);
    BOOL EnumSystemLocalesExW(LOCALE_ENUMPROCEXW lpLocaleEnumProc, DWORD dwFlags, LPVOID pvContext);

#if DBG
    template <typename T> void GetFunctionTraceContext(T *&rpt)
    {
        rpt = reinterpret_cast<T *>(::TlsGetValue(m_dwTraceContextTLS));
    }

    template <typename T> void SetFunctionTraceContext(T *pt)
    {
        ::TlsSetValue(m_dwTraceContextTLS, pt);
    }
#endif

protected:
    bool m_fFusionModuleInitialized;
    DWORD m_dwEnumLocaleTLS; // TLS key used in wrapped calls to EnumSystemLocales
#if DBG
    DWORD m_dwTraceContextTLS; // TLS key used to manage active trace contexts
#endif
    COleAutDll m_OleAut;
    HINSTANCE m_hInstDLL;

    typedef struct tagENUMSYSTEMLOCALESEXCONTEXTA
    {
        LPVOID pvContext; // user specified context
        LOCALE_ENUMPROCEXA lpLocaleEnumProc; // user specified enumeration function
    } ENUMSYSTEMLOCALESEXCONTEXTA, *LPENUMSYSTEMLOCALESEXCONTEXTA;

    typedef struct tagENUMSYSTEMLOCALESEXCONTEXTW
    {
        LPVOID pvContext; // user specified context
        LOCALE_ENUMPROCEXW lpLocaleEnumProc; // user specified enumeration function
    } ENUMSYSTEMLOCALESEXCONTEXTW, *LPENUMSYSTEMLOCALESEXCONTEXTW;

    static BOOL CALLBACK EnumLocalesProcA(LPSTR pszLCID);
    static BOOL CALLBACK EnumLocalesProcW(LPWSTR pszLCID);
};

#undef FUSION_MODULE_UNUSED

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionpreprocessorcharize.h ===
/*-----------------------------------------------------------------------------
Microsoft Fusion

Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

@doc external
@module fusionpreprocessorcharize.h

@owner JayKrell
-----------------------------------------------------------------------------*/
#if !defined(VS_COMMON_INC_FUSION_PREPROCESSORCHARIZE_H_INCLUDED_) // {
#define VS_COMMON_INC_FUSION_PREPROCESSORCHARIZE_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#include "fusionpreprocessorpaste.h"

#define FusionpPrivatePreprocessorCharize(x) #@ x

/*-----------------------------------------------------------------------------
Name: SxApwPreprocessorCharize, SxApwPreprocessorCharizeW
@macro
These macros simply charize their parameter, after evaluating it;
it is evaluated so that
define A B
SxApwPreprocessorCharize(A) -> 'B' instead of 'A'
SxApwPreprocessorCharizeW(A) -> 'B' instead of L'A'
@owner JayKrell
-----------------------------------------------------------------------------*/
#define FusionpPreprocessorCharize(x)  FusionpPrivatePreprocessorCharize(x)
#define FusionpPreprocessorCharizeW(x) FusionpPreprocessorPaste(L, FusionpPrivatePreprocessorCharize(x))

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionpreprocessorpaste.h ===
/*-----------------------------------------------------------------------------
Microsoft FUSION

Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

@doc external
@module fusionpreprocessorpaste.h

@owner JayKrell
-----------------------------------------------------------------------------*/
#if !defined(VS_COMMON_INC_FUSION_PREPROCESSORPASTE_H_INCLUDED_) // {
#define VS_COMMON_INC_FUSION_PREPROCESSORPASTE_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#define FusionpPrivatePreprocessorPaste(x, y) x ## y

/*-----------------------------------------------------------------------------
Name: FusionpPreprocessorPaste2, FusionpPreprocessorPaste3, etc.
@macro
These macros paste together n tokens, where n is in the name of the macro.
A level of evaluation is inserted as well.

define A 1
define B 2

FusionpPreprocessorPaste2(A, B) -> 12
@owner JayKrell
-----------------------------------------------------------------------------*/

// These are synonyms.
#define FusionpPreprocessorPaste(x, y)  FusionpPrivatePreprocessorPaste(x, y)
#define FusionpPreprocessorPaste2(x, y) FusionpPrivatePreprocessorPaste(x, y)

#define FusionpPreprocessorPaste3(x, y, z) FusionpPreprocessorPaste(FusionpPreprocessorPaste(x, y), z)
#define FusionpPreprocessorPaste4(w, x, y, z) FusionpPreprocessorPaste(FusionpPreprocessorPaste3(w, x, y), z)
#define FusionpPreprocessorPaste5(v, w, x, y, z) FusionpPreprocessorPaste(FusionpPreprocessorPaste4(v, w, x, y), z)
#define FusionpPreprocessorPaste6(u, v, w, x, y, z) FusionpPreprocessorPaste(FusionpPreprocessorPaste5(u, v, w, x, y), z)

#define FusionpPreprocessorPaste15(a1,a2,a3,a4,a5,a6,a7,a8,a9,a,b,c,d,e,f) \
	FusionpPreprocessorPaste3 \
	( \
		FusionpPreprocessorPaste5(a1,a2,a3,a4,a5), \
		FusionpPreprocessorPaste5(a6,a7,a8,a9,a), \
		FusionpPreprocessorPaste5(b,c,d,e,f) \
	)

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionpreprocessorstringize.h ===
/*-----------------------------------------------------------------------------
Microsoft Fusion

Microsoft Confidential
Copyright Microsoft Corporation. All Rights Reserved.

@doc external
@module fusionpreprocessorstringize.h

@owner JayKrell
-----------------------------------------------------------------------------*/
#if !defined(VS_COMMON_INC_FUSION_PREPROCESSORSTRINGIZE_H_INCLUDED_) // {
#define VS_COMMON_INC_FUSION_PREPROCESSORSTRINGIZE_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#include "fusionpreprocessorpaste.h"

#define FusionpPrivatePreprocessorStringize(x) # x

/*-----------------------------------------------------------------------------
Name: FusionpPreprocessorStringize, FusionpPreprocessorStringizeW
@macro
These macros simply stringize their parameter, after evaluating it;
it is evaluated so that
define A B
FusionpPreprocessorStringize(A) -> "B" instead of "A"
FusionpPreprocessorStringizeW(A) -> L"B" instead of L"A"
@owner JayKrell
-----------------------------------------------------------------------------*/
#define FusionpPreprocessorStringize(x) FusionpPrivatePreprocessorStringize(x)
#define FusionpPreprocessorStringizeW(x) FusionpPreprocessorPaste(L, FusionpPrivatePreprocessorStringize(x))

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionparser.h ===
#if !defined(_FUSION_INC_PARSER_H_INCLUDED_)
#define _FUSION_INC_PARSER_H_INCLUDED_

#pragma once

#include "fusionarray.h"
#include "sxstypes.h"

class CFusionParser
{
public:
    static BOOL ParseULONG(ULONG &rul, PCWSTR sz, SIZE_T cch, ULONG Radix = 10);
    static BOOL ParseFILETIME(FILETIME &rft, PCWSTR sz, SIZE_T cch);
    static BOOL ParseIETFDate( FILETIME &rft, PCWSTR sz, SIZE_T cch );
    static BOOL ParseVersion(ASSEMBLY_VERSION &rav, PCWSTR sz, SIZE_T cch, bool &rfSyntaxValid);
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionsha1.h ===
#pragma once

#include "stdinc.h"
#include "fusionarray.h"
#include "wincrypt.h"
#include "fusionhandle.h"

#define A_SHA_DIGEST_LEN 20

#ifndef INVALID_CRYPT_HASH
#define INVALID_CRYPT_HASH (static_cast<HCRYPTHASH>(NULL))
#endif

#define PRIVATIZE_COPY_CONSTRUCTORS( obj ) obj( const obj& ); obj& operator=(const obj&);

class CSha1Context
{
    PRIVATIZE_COPY_CONSTRUCTORS(CSha1Context);
    unsigned char m_workspace[64];
    unsigned long state[5];
    SIZE_T count[2];
    unsigned char buffer[64];

    BOOL Transform( const unsigned char* buffer );

public:
    CSha1Context() { }

    BOOL Update( const unsigned char* data, SIZE_T len );
    BOOL GetDigest( unsigned char* digest, PSIZE_T len );
    BOOL Initialize();
};

/*
void A_SHATransform(CSha1Context* context, const unsigned char buffer);
void A_SHAInit(CSha1Context* context);
void A_SHAUpdate(CSha1Context* context, const unsigned char* data, const ULONG len);
BOOL A_SHAFinal(CSha1Context* context, unsigned char* digest, ULONG *len);
*/


class CFusionHash
{
private:
    PRIVATIZE_COPY_CONSTRUCTORS(CFusionHash);
    
protected:
    CSha1Context m_Sha1Context;
    CCryptHash m_hCryptHash;
    ALG_ID m_aid;
    BOOL m_fInitialized;

    BOOL GetIsValid();

public:
    CFusionHash() 
        : m_fInitialized(FALSE), m_aid(0), m_hCryptHash(INVALID_CRYPT_HASH)
    { }

    BOOL Win32Initialize( ALG_ID aid );
    BOOL Win32HashData(const BYTE *pbBuffer, SIZE_T cbSize);
    BOOL Win32GetValue(OUT CFusionArray<BYTE> &out);
};


//
// There's no "real" invalid value defined anywhere, but by inspecting the
// codebase, NULL is the accepted "invalid" value - check the logon service
// code, they do the same thing.
//
#define INVALID_CRYPT_HANDLE (static_cast<HCRYPTPROV>(NULL))

//
// Global crypto context stuff
//
BOOL SxspAcquireGlobalCryptContext( HCRYPTPROV *pContext );
BOOL SxspReleaseGlobalCryptContext();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionreg.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fusionreg.h

Abstract:
    registry pieces of FusionHandle
    other registry stuff -- Win2000 32bit-on-64bit support
 
Author:

    Jay Krell (JayKrell) April 2001

Revision History:

--*/

#pragma once

//
// KEY_WOW64_64KEY if it is supported on this system, else 0.
//
DWORD FUSIONP_KEY_WOW64_64KEY();

/* this closes RegOpenKey/RegCreateKey */
class COperatorFRegCloseKey
{
public: BOOL operator()(void* handle) const;
};

//
// there isn't an actual invalid value, and HKEY is not HANDLE.
// The right solution is to keep a seperate bool as in \\JayK1\g\vs\src\vsee\lib\Reg.
// See about porting that over.
//
// 3/20/2001 - JonWis - "NULL" really is the "invalid key" value, as I watched
//      RegOpenKeyExW fill out its out PHKEY with "NULL" when the tag could not be
//      opened.
//
class CRegKey : public CHandleTemplate<&hNull, COperatorFRegCloseKey>
{
private:
    typedef CHandleTemplate<&hNull, COperatorFRegCloseKey> Base;
public:
    CRegKey(void* handle = GetInvalidValue()) : Base(handle) { }
    operator HKEY() const { return reinterpret_cast<HKEY>(m_handle); }
    void operator=(HKEY hkValue) { return Base::operator=(hkValue); }

    BOOL OpenOrCreateSubKey(
		OUT CRegKey& Target,
		IN PCWSTR SubKeyName, 
        IN REGSAM rsDesiredAccess = KEY_ALL_ACCESS,
		IN DWORD dwOptions = 0,
		IN PDWORD pdwDisposition = NULL,
        IN PWSTR pwszClass = NULL) const;
    BOOL OpenSubKey( OUT CRegKey& Target, IN PCWSTR SubKeyName, REGSAM rsAccess = KEY_READ, DWORD ulOptions = 0) const;
    BOOL EnumKey( IN DWORD dwIndex, OUT CBaseStringBuffer& rbuffKeyName, PFILETIME pftLastWriteTime = NULL, PBOOL pbNoMoreItems = NULL ) const;
    BOOL LargestSubItemLengths( PDWORD pdwSubkeyLength = NULL, PDWORD pdwValueLength = NULL ) const;
    BOOL EnumValue( IN DWORD dwIndex, OUT CBaseStringBuffer& rbuffValueName, LPDWORD lpdwType = NULL, PBYTE pbData = NULL, PDWORD pdwcbData = NULL, PBOOL pbNoMoreItems = NULL );
    BOOL SetValue(IN PCWSTR pcwszValueName, IN DWORD dwRegType, IN const BYTE *pbData, IN SIZE_T cbDataLength) const;
    BOOL SetValue(IN PCWSTR pcwszValueName, IN const CBaseStringBuffer &rcbuffValueValue) const;
    BOOL SetValue(IN PCWSTR pcwszValueName, IN DWORD dwValue) const;
    BOOL DeleteValue(IN PCWSTR pcwszValueName, OUT DWORD &rdwWin32Error, SIZE_T cExceptionalWin32Errors, ...) const;
    BOOL DeleteValue(IN PCWSTR pcwszValueName) const;
    BOOL DeleteKey( IN PCWSTR pcwszValue );
    BOOL DestroyKeyTree();

    BOOL Save( IN PCWSTR TargetFilePath, IN DWORD dwFlags = REG_LATEST_FORMAT, IN LPSECURITY_ATTRIBUTES pSecAttrsOnTargetFile = NULL );
    BOOL Restore( IN PCWSTR SourceFilePath, DWORD dwFlags );

    static HKEY GetInvalidValue() { return reinterpret_cast<HKEY>(Base::GetInvalidValue()); }

private:
    void operator =(const HANDLE);
    CRegKey(const CRegKey &); // intentionally not implemented
    void operator =(const CRegKey &); // intentionally not implemented
};

/*--------------------------------------------------------------------------
inline implementation
--------------------------------------------------------------------------*/

inline BOOL COperatorFRegCloseKey::operator()(void* handle) const
{
    HKEY hk = reinterpret_cast<HKEY>(handle);
    if ( ( hk != NULL ) && ( hk != INVALID_HANDLE_VALUE ) )
    {
        LONG lRet = ::RegCloseKey(reinterpret_cast<HKEY>(handle));
        if (lRet == NO_ERROR)
            return true;
        ::FusionpSetLastWin32Error(lRet);
        return false;
    }
    return true;
}

#if defined(FUSION_WIN)

#define FUSIONP_KEY_WOW64_64KEY KEY_WOW64_64KEY
inline DWORD FusionpKeyWow6464key() { return KEY_WOW64_64KEY; }

#else

#include "fusionversion.h"

inline DWORD FusionpKeyWow6464key()
{
    static DWORD dwResult;
    static BOOL  fInited;
    if (!fInited)
    {
        //
        // GetVersion gets the significance wrong, returning 0x0105 in the lower word.
        // As well since these functions say WindowsNt in their names, they return 0 for Win9x.
        //
        DWORD dwVersion = (FusionpGetWindowsNtMajorVersion() << 8) | FusionpGetWindowsNtMinorVersion();
        if (dwVersion >= 0x0501)
        {
            dwResult = KEY_WOW64_64KEY;
        }
        fInited = TRUE;
    }
    return dwResult;
}

#define FUSIONP_KEY_WOW64_64KEY FusionpKeyWow6464key()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionxml.h ===
#if !defined(_FUSION_INC_FUSIONXML_H_INCLUDED_)
#define _FUSION_INC_FUSIONXML_H_INCLUDED_

#pragma once

void
SxspDumpXmlTree(
    IN DWORD Flags,
    IN PCSXS_XML_DOCUMENT Document
    );

void
SxspDumpXmlSubTree(
    IN PCWSTR PerLinePrefix,
    IN PCSXS_XML_DOCUMENT Document, // need for string table resolution
    IN PCSXS_XML_NODE Node
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionunused.h ===
#pragma once
#if !defined(UNUSED)
#define UNUSED(x) x
#endif
#if DBG
#define RETAIL_UNUSED(x) /* nothing */
#else
#define RETAIL_UNUSED(x) UNUSED(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusiontrace.h ===
#if !defined(FUSION_INC_FUSIONTRACE_H_INCLUDED_)
#define FUSION_INC_FUSIONTRACE_H_INCLUDED_

#pragma once

#include "debmacro.h"
#include "CSxsPreserveLastError.h"

#endif // FUSION_INC_FUSIONTRACE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusiontls.h ===
#pragma once

/*-----------------------------------------------------------------------------
Fusion Thread Local Storage (aka Per Thread Data)
----------------------------------------------------------------------------*/

#include "EnumBitOperations.h"
// #include "FusionDequeLinkage.h"

#define FUSION_EVENT_LOG_FLAGS_DISABLE (0x00000001)

#ifndef INITIALIZE_CRITICAL_SECTION_AND_SPIN_COUNT_ALLOCATE_NOW
#define INITIALIZE_CRITICAL_SECTION_AND_SPIN_COUNT_ALLOCATE_NOW ( 0x80000000 )
#endif

class CFusionPerThreadData;

BOOL
FusionpPerThreadDataMain(
    HINSTANCE hInst,
    DWORD dwReason
    );

enum EFusionpTls
{
    eFusionpTlsCreate                 = 1 << 0,
    eFusionpTlsCanScrambleLastError   = 1 << 1
};

ENUM_BIT_OPERATIONS(EFusionpTls)

CFusionPerThreadData *
FusionpGetPerThreadData(
    EFusionpTls = static_cast<EFusionpTls>(0)
    );

enum EFusionSetTls
{
    eFusionpTlsSetDefaultValue,
    eFusionpTlsSetReplaceExisting   = 1,
    eFusionpTlsSetIfNull            = 2
};

//
//  This function preserves last error and does not ever set it.
CFusionPerThreadData *
FusionpSetPerThreadData(
    CFusionPerThreadData *pThreadData,
    EFusionSetTls = eFusionpTlsSetDefaultValue
    );


VOID
FusionpClearPerThreadData(
    VOID
    );

class CFusionPerThreadData
{
public:
    CFusionPerThreadData()
    :
        m_dwLastParseError(0),
        m_dwEventLoggingFlags(0)
    {
    }

    DWORD m_dwLastParseError;
    DWORD m_dwEventLoggingFlags;

    // add any additional per sxs thread data here
    // so we only ever consume one tls entry
    //
    // Move (a pointer to) this to the TEB in the future.

    LIST_ENTRY m_Linkage;

    //
    // Callback from the CDeque::Clear function - Calls the function
    // to clear this thread's data, which has the side-effect of
    // deleting the object.
    //
    inline VOID DeleteSelf() { ::FusionpClearPerThreadData(); }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionstring.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FusionString.h

Abstract:

    Stuff to futz with everybody's favorite type, generally templatized
        to work on char, wchar_t, or anything else; occasionally
        templatized to work on arbitrary STL style [begin, end)
        sequences.
    Also stuff particularly for NT's UNICODE_STRING.
    To be merged with CFusionBuffer.h.

Author:

    Jay M. Krell (a-JayK) May 2000

Revision History:

--*/
#pragma once

#include <stdio.h>
#include "fusionntdll.h"
//#include "fusionalgorithm.h"

class CUnicodeCharTraits;
template <typename T> class CGenericBaseStringBuffer;

int
FusionpCompareStrings(
    PCWSTR sz1,
    SIZE_T cch1,
    PCWSTR sz2,
    SIZE_T cch2,
    bool fCaseInsensitive
    );

inline bool
FusionpEqualStrings(
    PCWSTR sz1,
    SIZE_T cch1,
    PCWSTR sz2,
    SIZE_T cch2,
    bool fCaseInsensitive
    )
{
    return ((cch1 == cch2) && (FusionpCompareStrings(sz1, cch1, sz2, cch2, fCaseInsensitive) == 0));
}

int
FusionpCompareStrings(
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff1,
    PCWSTR psz2,
    SIZE_T cch2,
    bool fCaseInsensitive
    );

int
FusionpCompareStrings(
    PCWSTR psz1,
    SIZE_T cch1,
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff2,
    bool fCaseInsensitive
    );

int
FusionpCompareStrings(
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff1,
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff2,
    bool fCaseInsensitive
    );

int
FusionpCompareStrings(
    PCSTR sz1,
    SIZE_T cch1,
    PCSTR sz2,
    SIZE_T cch2,
    bool fCaseInsensitive
    );

#if !defined(FUSION_CANONICAL_CASE_IS_UPPER)
#define FUSION_CANONICAL_CASE_IS_UPPER 1
#endif // !defined(FUSION_CANONICAL_CASE_IS_UPPER)

#if FUSION_CANONICAL_CASE_IS_UPPER

inline WCHAR FusionpCanonicalizeUnicodeChar(WCHAR wch) { return ::FusionpRtlUpcaseUnicodeChar(wch); }

#else

inline WCHAR FusionpCanonicalizeUnicodeChar(WCHAR wch) { return ::FusionpRtlDowncaseUnicodeChar(wch); }

#endif


inline int
FusionpStrCmpI(
    PCWSTR psz1,
    PCWSTR psz2
    )
{
    return ::FusionpCompareStrings(
        psz1,
        (psz1 != NULL) ? ::wcslen(psz1) : 0,
        psz2,
        (psz2 != NULL) ? ::wcslen(psz2) : 0,
        true);
}

/*-----------------------------------------------------------------------------
StringLength is a generic name for getting the length, in count of
characters, of various kinds of strings
-----------------------------------------------------------------------------*/

inline SIZE_T StringLength(LPCSTR psz)
{
    return ::strlen(psz);
}

inline SIZE_T StringLength(LPCWSTR psz)
{
    return ::wcslen(psz);
}

#if defined(NT_INCLUDED) // { {

inline SIZE_T StringLength(const UNICODE_STRING* s)
{
    return s->Length / sizeof(*s->Buffer);
}

inline SIZE_T StringLength(const ANSI_STRING* s)
{
    return s->Length / sizeof(*s->Buffer);
}

/*
perhaps half backed, like UNICODE_STRING itself, should probably call
these CContantUnicodeString or CUnicodeStringNoFree, to indicate
they do no allocation or deallocation
..
..
darn, really just need to merge this with existing FusionBuffer...
*/
#define CONSTANT_UNICODE_STRING(x) \
{ \
    /* the subtraction is to not count the terminal nul */ \
    static_cast<unsigned short>(sizeof(x) - sizeof((x)[0])), \
    static_cast<unsigned short>(sizeof(x) - sizeof((x)[0])), \
    const_cast<PWSTR>(x) \
}

extern const UNICODE_STRING g_strEmptyUnicodeString;

class CUnicodeString : public UNICODE_STRING
{
public:
    ~CUnicodeString() { }

    CUnicodeString(PCWSTR buffer, SIZE_T length)
    {
        this->Buffer = const_cast<PWSTR>(buffer); // Careful!
        this->Length = static_cast<USHORT>(length * sizeof(*Buffer));
        this->MaximumLength = this->Length;
    }

    CUnicodeString(PCWSTR buffer)
    {
        this->Buffer = const_cast<PWSTR>(buffer);
        this->Length = static_cast<USHORT>(::wcslen(buffer) * sizeof(*Buffer));
        this->MaximumLength = this->Length;
    }

    operator const UNICODE_STRING *() const { return this; }

    void operator=(PCWSTR buffer)
    {
        this->Buffer = const_cast<PWSTR>(buffer); // Careful!
        this->Length = static_cast<USHORT>(::wcslen(buffer) * sizeof(*Buffer));
        this->MaximumLength = this->Length;
    }

    void Sync()
    {
        this->Length = static_cast<USHORT>(::wcslen(Buffer) * sizeof(*Buffer));
    }

    int FormatV(PCWSTR pszFormat, va_list args)
    {
        // note that vsnprintf doesn't nul terminate if there isn't room,
        // it squeezes the nul out in favor of an additional character,
        // we work around this by telling it one char less, and by always
        // putting a nul at the end
        int cchMaximumLength = this->MaximumLength / sizeof(*Buffer);
        this->Buffer[cchMaximumLength - 1] = 0;
        int i = _vsnwprintf(this->Buffer, cchMaximumLength - 1, pszFormat, args);
        if (i >= 0)
        {
            this->Buffer[i] = 0;
            this->Length = static_cast<USHORT>(i * sizeof(*Buffer));
        }
        return i;
    }

    int Format(PCWSTR pszFormat, ...)
    {
        va_list args;
        va_start(args, pszFormat);
        int i = FormatV(pszFormat, args);
        va_end(args);
        return i;
    }

//protected:
    CUnicodeString()
    {
        this->Buffer = L"";
        this->Length = sizeof(*Buffer);
        this->MaximumLength = this->Length;
    }

private: // deliberately not implemented
    CUnicodeString(const CUnicodeString&);
    void operator=(const CUnicodeString&);
};

template <int N>
class CUnicodeStringN : public CUnicodeString
{
public:
    ~CUnicodeStringN() { }

    CUnicodeStringN()
    {
        this->Buffer = m_rgchBuffer;
        this->Length = 0;
        this->MaximumLength = sizeof(m_rgchBuffer);

        m_rgchBuffer[0] = 0;
        m_rgchBuffer[N-1] = 0;
    }

    WCHAR m_rgchBuffer[N];

private: // deliberately not implemented
    CUnicodeStringN(const CUnicodeStringN&);
    void operator=(const CUnicodeStringN&);
};

#endif // } }

/*-----------------------------------------------------------------------------
genericized name for strchr and wcschr
-----------------------------------------------------------------------------*/
//template <typename Char> const Char* StringFindChar(const Char* s, Char ch)
// Automatically provide non const, but looser type binding between s
// and ch. Still requires nul termination, so doesn't really support more than
// char*, const char*, wchar_t*, and const wchar_t*.
//
// StdFind is the obvious generalization that doesn't require a particular
// terminal value, but the ability to pass a terminal pointer or iterator.
template <typename String, typename Char>
inline String
StringFindChar(String s, Char ch)
{
    String end = s + StringLength(s);
    String found = StdFind(s, end, ch);
    if (found == end)
    {
        found = NULL;
    }
    return found;
}

/*-----------------------------------------------------------------------------
specialize StringFindChar for char to use strchr provided
in msvcrt.dll or ntdll.dll.
-----------------------------------------------------------------------------*/
// strchr is getting defined to be StrChrW, which does not work.
#if !defined(strchr) // { {
template <>
inline const char* StringFindChar<const char*>(const char* s, char ch)
{
    s = strchr(s, ch);
    return s;
}

template <>
inline char* StringFindChar<char*>(char* s, char ch)
{
    s = strchr(s, ch);
    return s;
}
#endif // } }

/*-----------------------------------------------------------------------------
specialize StringFindChar for wchar_t to use wcschr provided
in msvcrt.dll or ntdll.dll.
-----------------------------------------------------------------------------*/
template <>
inline const wchar_t* StringFindChar<const wchar_t*>(const wchar_t* s, wchar_t ch)
{
    s = wcschr(s, ch);
    return s;
}

template <>
inline wchar_t* StringFindChar<wchar_t*>(wchar_t* s, wchar_t ch)
{
    s = wcschr(s, ch);
    return s;
}

/*-----------------------------------------------------------------------------
common code for StringReverseSpan and StringReverseComplementSpan
-----------------------------------------------------------------------------*/
template <typename Char>
INT
PrivateStringReverseSpanCommon(
    const Char* begin,
    const Char* end,
    const Char* set, // nul terminated
    bool breakVal
    )
{
    const Char* t = end;
    while (t != begin)
    {
        if (breakVal == !!StringFindChar(set, *--t))
        {
            ++t; // don't count the last checked one
            break;
        }
    }
    return static_cast<INT>(end - t);
}


/*-----------------------------------------------------------------------------
Find the length of the run of characters in set from the end of [begin, end).
"wcsrspn"
variants of this can be seen at
    \vsee\lib\xfcstr\strexw.cpp
    and \\jayk1\g\temp\rspn.cpp
-----------------------------------------------------------------------------*/
template <typename Char>
inline INT
StringReverseSpan(
    const Char* begin,
    const Char* end,
    const Char* set
    )
{
    // break when not found
    return ::PrivateStringReverseSpanCommon(begin, end, set, false);
}

/*-----------------------------------------------------------------------------
Find the length of the run of characters not in set from the end of [begin, end).
"wcsrcspn"
variants of this can be seen at
    \vsee\lib\xfcstr\strexw.cpp
    and \\jayk1\g\temp\rspn.cpp
-----------------------------------------------------------------------------*/
template <typename Char>
inline INT
StringReverseComplementSpan(
    const Char* begin,
    const Char* end,
    const Char* set
    )
{
    // break when found
    return ::PrivateStringReverseSpanCommon(begin, end, set, true);
}


template <typename Char>
inline INT
PrivateStringSpanCommon(
    const Char* begin,
    const Char* end,
    const Char* set,
    bool breakVal
    )
{
    const Char* t = begin;

    while ( t != end )
    {
        if (breakVal == !!StringFindChar(set, *t++)) 
        {
            --t;
            break;
        }
    }
    return static_cast<INT>(t - begin);
}


template <typename Char>
inline INT
StringSpan(
    const Char* begin,
    const Char* end,
    const Char* set
    )
{
    return ::PrivateStringSpanCommon( begin, end, set, false );
}

template <typename Char>
inline INT
StringComplimentSpan(
    const Char* begin,
    const Char* end,
    const Char* set
    )
{
    return ::PrivateStringSpanCommon( begin, end, set, true );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionwin32.h ===
#if !defined(_FUSION_INC_FUSIONWIN32_H_INCLUDED_)
#define _FUSION_INC_FUSIONWIN32_H_INCLUDED_

#pragma once

//
//  Helper functions for dealing with exposing a Win32 API
//

ULONG FusionMapHRESULTToWin32(HRESULT hr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\fusionversion.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fusionversion.h

Abstract:
 
Author:

    Jay Krell (JayKrell) April 2001

Revision History:

--*/

#pragma once

inline DWORD FusionpGetWindowsNtBuildVersion()
{
    DWORD dwVersion = GetVersion();
    if ((dwVersion & 0x80000000) != 0)
        return 0;
    return (dwVersion & 0xffff0000) >> 16;
}

inline DWORD FusionpGetWindowsNtMinorVersion()
{
    DWORD dwVersion = GetVersion();
    if ((dwVersion & 0x80000000) != 0)
        return 0;
    return (dwVersion & 0xff00) >> 8;
}

inline DWORD FusionpGetWindowsNtMajorVersion()
{
    DWORD dwVersion = GetVersion();
    if ((dwVersion & 0x80000000) != 0)
        return 0;
    return (dwVersion & 0xff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\gitcookie.h ===
#if !defined(_FUSION_INC_GITCOOKIE_H_INCLUDED_)
#define _FUSION_INC_GITCOOKIE_H_INCLUDED_

#pragma once

#include <objidl.h>

template <class TInterface> class CGITCookie
{
public:
    CGITCookie() : m_dwCookie(0), m_fSet(false) { }
    ~CGITCookie()
    {
        HRESULT hr;
        IGlobalInterfaceTable *pGIT = NULL;

// In debug builds, always create the GIT.  This is slower, but will find code
// paths which are destroying CGITCookie instances after COM is uninitialized
// for the thread.
#if DBG
        hr = this->GetGIT(&pGIT);
        ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
        {
            if (m_fSet)
            {
                hr = pGIT->RevokeInterfaceFromGlobal(m_dwCookie);
                ASSERT(SUCCEEDED(hr));

                m_fSet = false;
            }

            pGIT->Release();
        }
#else
        if (m_fSet)
        {
            hr = this->GetGIT(&pGIT);
            if (SUCCEEDED(hr))
            {
                (VOID) pGIT->RevokeInterfaceFromGlobal(m_dwCookie);
            }
            m_fSet = false;
        }
#endif
    }

    HRESULT Set(TInterface *pt)
    {
        IGlobalInterfaceTable *pGIT = NULL;
        DWORD dwCookieTemp = 0;
        bool fTempCookieNeedsToBeFreed = false;
        HRESULT hr = this->GetGIT(&pGIT);
        if (FAILED(hr))
            goto Exit;

        if (pt != NULL)
        {
            hr = pGIT->RegisterInterfaceInGlobal(pt, __uuidof(TInterface), &dwCookieTemp);
            if (FAILED(hr))
                goto Exit;

            fTempCookieNeedsToBeFreed = true;
        }

        if (m_fSet)
        {
            hr = pGIT->RevokeInterfaceFromGlobal(m_dwCookie);
            if (FAILED(hr))
                goto Exit;
            m_fSet = false;
        }

        if (pt != NULL)
        {
            m_dwCookie = dwCookieTemp;
            m_fSet = true;
            fTempCookieNeedsToBeFreed = false;
        }

        hr = NOERROR;
    Exit:
        if (fTempCookieNeedsToBeFreed)
            pGIT->RevokeInterfaceFromGlobal(dwCookieTemp);

        return hr;
    }

    HRESULT Get(TInterface **ppt)
    {
        HRESULT hr = NOERROR;
        IGlobalInterfaceTable *pGIT = NULL;

        ASSERT(ppt != NULL);
        if (ppt == NULL)
        {
            hr = E_INVALIDARG;
            goto Exit;
        }

        // How can you get if you haven't set?
        ASSERT(m_fSet);
        if (!m_fSet)
        {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        ASSERT((*ppt) == NULL);
        hr = this->GetGIT(&pGIT);
        if (FAILED(hr))
            goto Exit;

        hr = pGIT->GetInterfaceFromGlobal(m_dwCookie, __uuidof(TInterface), (LPVOID *) ppt);
        if (FAILED(hr))
            goto Exit;

        hr = NOERROR;

    Exit:
        if (pGIT != NULL)
            pGIT->Release();

        return hr;
    }

private:
    HRESULT GetGIT(IGlobalInterfaceTable **ppGIT)
    {
        return ::CoCreateInstance(
                    CLSID_StdGlobalInterfaceTable,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IGlobalInterfaceTable,
                    (LPVOID *) ppGIT);
    }

    DWORD m_dwCookie;
    bool m_fSet;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\parse.h ===
#ifndef PARSE_H
#define PARSE_H

#define CTSTRLEN(s) (sizeof(s)/sizeof(TCHAR) - 1)
#define RFC1766_KEY_SZ L"MIME\\Database\\Rfc1766"

#define NAME_BUF_SIZE MAX_PATH
#define VALUE_BUF_SIZE MAX_PATH

// Used for generating display name.
#define FLAG_QUOTE          0x1
#define FLAG_DELIMIT        0x2

#define PARSE_FLAGS_LCID_TO_SZ 0x1
#define PARSE_FLAGS_SZ_TO_LCID 0x2

// ---------------------------------------------------------------------------
// CParseUtils
// Generic parsing utils.
// ---------------------------------------------------------------------------
class CParseUtils
{

public:

    // Inline strip leading and trailing whitespace.
    static VOID TrimWhiteSpace(LPWSTR *psz, LPDWORD pcc);

    // Inline parse of delimited token.
    static BOOL GetDelimitedToken(LPWSTR* pszBuf,   LPDWORD pccBuf,
        LPWSTR* pszTok,   LPDWORD pccTok, WCHAR cDelim);

    // Inline parse of key=value token.
    static BOOL GetKeyValuePair(LPWSTR  szB,    DWORD ccB,
        LPWSTR* pszK,   LPDWORD pccK, LPWSTR* pszV,   LPDWORD pccV);

    // Outputs token to buffer.
    static HRESULT SetKey(LPWSTR szBuffer, LPDWORD pccBuffer,
        PCWSTR szKey, DWORD ccAlloced, DWORD dwFlags);

    // Outputs key=value token to buffer.
    static HRESULT SetKeyValuePair(LPWSTR szBuffer, LPDWORD pcbBuffer, PCWSTR szKey,
        PCWSTR szValue,  DWORD cbAlloced, DWORD dwFlags);

    // Converts binary to hex encoded unicode string.
    static VOID BinToUnicodeHex(LPBYTE pSrc, UINT cSrc, LPWSTR pDst);

    // Converts hex encoded unicode string to binary.
    static VOID UnicodeHexToBin(LPCWSTR pSrc, UINT cSrc, LPBYTE pDest);


};

#endif // PARSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\numberof.h ===
////
// Macro for dimension of static arrays.
#if !defined(FUSION_INC_NUMBEROF_H_INCLUDED_)
#define FUSION_INC_NUMBEROF_H_INCLUDED_

#pragma once

#if defined(NUMBER_OF)
#undef NUMBER_OF
#endif

#if FUSION_USE_CHECKED_NUMBER_OF

//
//   Note!
//
//  Use of this "checked" number of macro causes CRT initializers to have to run
//  for static/constant arrays.
//
//  We cannot enable this for fusion right now, but turning it on and running at
//  least will lead to the compiler errors
//


// Static arrays will match this signature.
template< typename	T
		>
inline
SIZE_T
NUMBER_OF_validate
		( void const *
		, T
		)
throw()
{
	return (0);
}

// Other things (e.g. pointers) will match this signature.
template< typename	T
		>
inline
void
NUMBER_OF_validate
		( T * const
		, T * const *
		)
throw()
{
}

// Use the size of the validation function's return type to create an
//	error when this macro is misused.
#define NUMBER_OF(array)									\
		(sizeof(NUMBER_OF_validate((array), &(array))),	\
			(sizeof((array)) / sizeof((array)[0])))

#else

#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))

#endif // FUSION_USE_CHECKED_NUMBER_OF

#endif // !defined(FUSION_INC_NUMBEROF_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\helpers.h ===
#pragma once
#if 0
#ifndef __HELPERS_H_INCLUDED__
#define __HELPERS_H_INCLUDED__

#define MAX_URL_LENGTH                     2084 // same as INTERNET_MAX_URL_LENGTH

typedef HRESULT(*PFNGETCORSYSTEMDIRECTORY)(LPWSTR, DWORD, LPDWORD);

HRESULT Unicode2Ansi(const wchar_t *src, char ** dest);
HRESULT Ansi2Unicode(const char * src, wchar_t **dest);
UINT GetDriveTypeWrapper(LPCWSTR wzPath);
HRESULT AppCtxGetWrapper(IApplicationContext *pAppCtx, LPWSTR wzTag,
                         WCHAR **ppwzValue);
HRESULT NameObjGetWrapper(IAssemblyName *pName, DWORD nIdx,
                          LPBYTE *ppbBuf, LPDWORD pcbBuf);
HRESULT GetFileLastModified(LPCWSTR pwzFileName, FILETIME *pftLastModified);
HRESULT CheckLocaleMatch(BLOB blobAsmLCIDDef, BLOB blobAsmLCIDRef);
DWORD GetRealWindowsDirectory(LPWSTR wszRealWindowsDir, UINT uSize);
HRESULT SIDCmpW(LPWSTR pwzSIDL, LPWSTR pwzSIDR, int *piRet);
HRESULT SetAppCfgFilePath(IApplicationContext *pAppCtx, LPCWSTR wzFilePath);

HRESULT CfgEnterCriticalSection(IApplicationContext *pAppCtx);
HRESULT CfgLeaveCriticalSection(IApplicationContext *pAppCtx);
HRESULT MakeUniqueTempDirectory(LPCSTR szTempDir, LPSTR szUniqueTempDir,
                                DWORD dwLen);
HRESULT CreateFilePathHierarchy( LPCOLESTR pszName );
DWORD GetRandomName (LPTSTR szDirName, DWORD dwLen);
HRESULT CreateDirectoryForAssembly
   (IN DWORD dwDirSize, IN OUT LPTSTR pszPath, IN OUT LPDWORD pcwPath);
HRESULT RemoveDirectoryAndChildren(LPWSTR szDir);
#ifdef NEW_POLICY_CODE
void GetDefaultPlatform(OSINFO *pOS);
#endif
STDAPI CopyPDBs(IAssembly *pAsm);
HRESULT UpdatePolicyTimeStamp();
HRESULT VersionFromString(LPCWSTR wzVersion, WORD *pwVerMajor, WORD *pwVerMinor,
                          WORD *pwVerRev, WORD *pwVerBld);

BOOL LoadMSCorSN();
BOOL VerifySignature(LPWSTR szFilePath, LPBOOL fAllowDelaySig);

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\hashnode.h ===
#ifndef __HASHNODE_H_INCLUDED__
#define __HASHNODE_H_INCLUDED__

class CHashNode {
    public:
        CHashNode();
        virtual ~CHashNode();

        static HRESULT Create(LPCWSTR pwzSource, CHashNode **ppHashNode);

        BOOL IsDuplicate(LPCWSTR pwzStr) const;

    private:
        HRESULT Init(LPCWSTR pwzSource);

    private:
        LPWSTR                     _pwzSource;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\perfclocking.h ===
#ifndef __FUSION_PERFCLOCKING
#define __FUSION_PERFCLOCKING

typedef struct _tagFUSION_PERF_INFO
{
    LARGE_INTEGER   AccumulatedCycles;
    LARGE_INTEGER   LineHits;
    BOOL            bInitialized;
    int             iSourceLine;
    CHAR            *pSourceFile;
    CHAR            *pStatement;

#ifdef __cplusplus
    _tagFUSION_PERF_INFO() { AccumulatedCycles.QuadPart = LineHits.QuadPart = 0; bInitialized = FALSE; }
#endif
} FUSION_PERF_INFO, *PFUSION_PERF_INFO;

#if defined(DBG) && defined(FUSION_PROFILING)

#define PERFINFOTIME( pPerfInfo, statement ) \
{ \
    if ( !(pPerfInfo)->bInitialized ) { \
        (pPerfInfo)->iSourceLine = __LINE__; \
        (pPerfInfo)->pSourceFile = __FILE__; \
        (pPerfInfo)->pStatement = (#statement); \
        (pPerfInfo)->bInitialized = TRUE; \
    } \
    TIMEANDACCUMULATE( (pPerfInfo)->AccumulatedCycles, statement ); \
    (pPerfInfo)->LineHits.QuadPart++; \
}

#define CLOCKINTO( destiny ) \
    __asm { __asm cpuid __asm rdtsc }; \
    __asm { mov destiny.HighPart, edx }; \
    __asm { mov destiny.LowPart, eax };



#define STARTCLOCK( destination, lag ) \
{ \
    LARGE_INTEGER __start, __stop; \
    LARGE_INTEGER *__pdest = &(destination), *__plag = &(lag); \
    CLOCKINTO( __start );

#define STOPCLOCK() \
    CLOCKINTO( __stop ); \
    __pdest->QuadPart = __stop.QuadPart - ( __start.QuadPart + __plag->QuadPart ); \
}

#define STARTCLOCKACCUMULATE( accum, lag ) \
{ \
    LARGE_INTEGER __start, __stop; \
    LARGE_INTEGER *__acc = &(accum), *__plag = &(lag); \
    CLOCKINTO( __start ); \

#define STOPCLOCKACCUMULATE() \
    CLOCKINTO( __stop ); \
    __acc->QuadPart += ( __stop.QuadPart - ( __start.QuadPart + __plag->QuadPart ) ); \
}

#define TIMEANDACCUMULATE( accumulator, statement ) \
    TIMEANDACCUMULATEWITHLAG( accumulator, statement, CpuIdLag )

#define TIMEANDACCUMULATEWITHLAG( accumulator, statement, lag ) \
    STARTCLOCKACCUMULATE( accumulator, lag ); \
    statement; \
    STOPCLOCKACCUMULATE();

#define FUSIONPERF_DUMP_TARGET_MASK     ( 0x0000000F )
#define FUSIONPERF_DUMP_TO_DEBUGGER     ( 0x00000001 )
#define FUSIONPERF_DUMP_TO_STDOUT       ( 0x00000002 )
#define FUSIONPERF_DUMP_TO_STDERR       ( 0x00000003 )

#define FUSIONPERF_DUMP_ALL_MASK		( 0x00000F00 )
#define FUSIONPERF_DUMP_ALL_STATISTICS	( 0x00000100 )
#define FUSIONPERF_DUMP_ALL_SOURCEINFO	( 0x00000200 )
#define FUSIONPERF_DUMP_ALL_CONCISE     ( 0x00000400 )
#define FUSIONPERF_DUMP_TALLYS          ( 0x00001000 )

inline static VOID
FusionpDumpPerfInfo( DWORD dwFlags, PFUSION_PERF_INFO pInfo )
{
    CStringBuffer sbTemp;

	if ( dwFlags & FUSIONPERF_DUMP_ALL_SOURCEINFO )
	{
		sbTemp.Win32Format(
			L"Perf: %S(%d) - Hit %I64d times\n\t%I64d cycles total, %I64d average\n\t%S\n",
			pInfo->pSourceFile,
			pInfo->iSourceLine,
			pInfo->LineHits.QuadPart,
			pInfo->AccumulatedCycles.QuadPart,
			pInfo->AccumulatedCycles.QuadPart / pInfo->LineHits.QuadPart,
			pInfo->pStatement
		);
	}
	else if ( dwFlags & FUSIONPERF_DUMP_ALL_CONCISE )
	{
		sbTemp.Win32Format(
			L"%S(%d) - Hit %I64d times %I64d cycles total %I64d average\n",
			pInfo->pSourceFile,
			pInfo->iSourceLine,
			pInfo->LineHits.QuadPart,
			pInfo->AccumulatedCycles.QuadPart,
			pInfo->AccumulatedCycles.QuadPart / pInfo->LineHits.QuadPart
		);
	}
	else
	{
		sbTemp.Win32Format(
			L"Perf: %S(%d) - Hit %I64d times, \n\t%I64d cycles total, %I64d average\n",
			pInfo->pSourceFile,
			pInfo->iSourceLine,
			pInfo->LineHits.QuadPart,
			pInfo->AccumulatedCycles.QuadPart,
			pInfo->AccumulatedCycles.QuadPart / pInfo->LineHits.QuadPart
		);
	}

    switch ( dwFlags & FUSIONPERF_DUMP_TARGET_MASK )
    {
    case FUSIONPERF_DUMP_TO_DEBUGGER:
        OutputDebugString( sbTemp );
        break;
    case FUSIONPERF_DUMP_TO_STDOUT:
        wprintf( sbTemp );
        break;
    case FUSIONPERF_DUMP_TO_STDERR:
        fwprintf( stderr, sbTemp );
        break;
    }
}

inline static VOID
FusionpReportPerfInfo( DWORD dwFlags, FUSION_PERF_INFO Info[], SIZE_T cInfo )
{
	LARGE_INTEGER liAveragedTotalHits, liRawTotalCycles;
	liAveragedTotalHits.QuadPart = 0;
	liRawTotalCycles.QuadPart = 0;

	for ( SIZE_T i = 0; i < cInfo; i++ )
	{
		if ( dwFlags & FUSIONPERF_DUMP_ALL_STATISTICS )
		{
			FusionpDumpPerfInfo( dwFlags, Info + i );
		}

		liAveragedTotalHits.QuadPart +=
			( Info[i].AccumulatedCycles.QuadPart / Info[i].LineHits.QuadPart );
	    liRawTotalCycles.QuadPart += Info[i].AccumulatedCycles.QuadPart;
	}

	wprintf( L"Perf: Profiled %d statements, cyclecount average per set %I64d\n"
	         L"      %I64d total cycles in this set",
		cInfo,
		liAveragedTotalHits.QuadPart,
		liRawTotalCycles.QuadPart
	);
}


#define PERFINFOSINGLESTATEMENT( statement ) \
{ \
	FUSION_PERF_INFO __dumpinfo; \
	TIMEANDACCUMULATE( &__dumpinfo, statement ); \
	FusionpDumpPerfInfo( FUSIONPERF_DUMP_TO_STDOUT, &__dumpinfo ); \
}
	


#else

#define PERFINFOTIME( pDump, statement ) statement;
#define TIMEANDACCUMULATE( a, s ) s;
#define TIMEANDACCUMULATEWITHLAG( a, s, l ) s;
#define FusionpReportPerfInfo( a, b, c )
#define FusionpDumpPerfInfo( a, b )
#define PERFINFOSINGLESTATEMENT( statement ) statement;

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\processorarchitecture.h ===
#pragma once

/*-----------------------------------------------------------------------------
common "code" factored out of FusionWin and FusionUrt
-----------------------------------------------------------------------------*/

#if defined(_X86_)
#define DEFAULT_ARCHITECTURE PROCESSOR_ARCHITECTURE_INTEL
#elif defined(_AMD64_)
#define DEFAULT_ARCHITECTURE PROCESSOR_ARCHITECTURE_AMD64
#elif defined(_IA64_)
#define DEFAULT_ARCHITECTURE PROCESSOR_ARCHITECTURE_IA64
#else
#error Unknown Processor type
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\pspipehelper.h ===
#if !defined(_FUSION_INC_PSPIPEHELPER_H_INCLUDED_)
#define _FUSION_INC_PSPIPEHELPER_H_INCLUDED_

#pragma once

#pragma warning(disable: 4127)

#include "fusioncom.h"
#include "smartref.h"
#include "fusewin.h"
#include "fusionbytebuffer.h"
#include "pstream.h"

#define IFFAIL_RETURN(x) \
do { \
    const HRESULT __hr = (x); \
    if (FAILED(__hr)) \
        return __hr; \
} while (0)

#define IFFAIL_SET_PIPE_BAD_AND_RETURN(x) \
do { \
    const HRESULT __hr = (x);\
    if (FAILED(__hr)) \
    { \
        m_fPipeBad = true; \
        return __hr; \
    } \
} while (0)

#define IFFAIL_SET_PIPE_BAD_IF_AND_RETURN(x, cond) \
do { \
    const HRESULT __hr = (x);\
    if (FAILED(__hr)) \
    { \
        if ((cond)) m_fPipeBad = true; \
        return __hr; \
    } \
} while (0)

// SET_PIPE_BAD_IF_AND_EXIT evaluates the first parameter.  If it is
// failure and "cond" is true, the pipe is set to be broken.  Regardless
// of success vs. failure, the value of the first parameter is returned.
#define SET_PIPE_BAD_IF_AND_EXIT(x, cond) \
do { \
    const HRESULT __hr = (x); \
    if (FAILED(__hr)) \
    { \
        if ((cond)) m_fPipeBad = true; \
        hr = __hr; \
        goto Exit; \
    } \
} while (0)

#define UNUSED(x) (x)

extern HRESULT FusionWriteProperty(IPipeByte *pIPipeByte, ULONG propid, const PROPVARIANT &rvarValue, bool &rfAnyDataWritten);
extern HRESULT FusionWriteBlobVectorProperty(IPipeByte *pIPipeByte, ULONG propid, ULONG cElements, va_list ap, bool &rfAnyDataWritten);
extern HRESULT FusionWriteUI2VectorProperty(IPipeByte *pIPipeByte, ULONG propid, ULONG cElements, va_list ap, bool &rfAnyDataWritten);

class CPropertyStreamPipeWriter
{
public:
    CPropertyStreamPipeWriter() : m_fInitialized(false), m_dwNextSectionCookie(0), m_fPipeBad(false) { }
    ~CPropertyStreamPipeWriter() { }

    HRESULT Initialize(IPipeByte *pIPipeByte)
    {
        if (m_fInitialized) return E_UNEXPECTED;
        if (pIPipeByte == NULL) return E_POINTER;
        m_srpIPipeByte = pIPipeByte;
        m_fInitialized = true;
        m_fPipeBad = false;
        return NOERROR;
    }

    // The pipe data stream is considered bad if we started writing some part of a data
    // item and failed before completing.  Once a pipe is bad, there is nothing
    // you can do with it except close it.
    bool IsPipeBad() const { return m_fPipeBad; }

    HRESULT WriteHeader(REFCLSID rclsidOriginator)
    {
        if (!m_fInitialized) return E_UNEXPECTED;
        if (m_dwNextSectionCookie != 0) return E_UNEXPECTED;
        if (m_fPipeBad) return HRESULT_FROM_WIN32(ERROR_BAD_PIPE);
        FUSION_PSTREAM_VERSION_1_HEADER hdr;
        hdr.vih.wByteOrder = 0xFFFE;
        hdr.vih.wFormat = 1;
        hdr.vih.dwOSVer = (DWORD) MAKELONG(LOWORD(::GetVersion()), 2); // taken from MSDN mk:@MSITStore:\\infosrv2\msdn_oct99\MSDN\COM.chm::/devdoc/com/stgasstg_44mr.htm
        hdr.vih.clsid = rclsidOriginator;
        hdr.vih.reserved = 0;
        IFFAIL_RETURN(m_srpIPipeByte->Push((LPBYTE) &hdr, sizeof(hdr)));
        m_dwNextSectionCookie = 1;
        return NOERROR;
    }

    HRESULT BeginSection(REFGUID rguidSectionSet, ULONG ulSectionID, DWORD &rdwSectionCookie)
    {
        if (!m_fInitialized) return E_UNEXPECTED;
        ASSERT(m_dwNextSectionCookie != 0); // forgot to send header
        if (m_dwNextSectionCookie == 0) return E_UNEXPECTED;
        if (m_fPipeBad) return HRESULT_FROM_WIN32(ERROR_BAD_PIPE);
        FUSION_PSTREAM_ELEMENT elt;
        elt.bIndicator = FUSION_PSTREAM_INDICATOR_SECTION_BEGIN;
        elt.BeginSectionVal.guidSectionSet = rguidSectionSet;
        elt.BeginSectionVal.ulSectionID = ulSectionID;
        IFFAIL_RETURN(m_srpIPipeByte->Push((LPBYTE) &elt, FUSION_PSTREAM_SIZEOF_SECTION_BEGIN));
        rdwSectionCookie = m_dwNextSectionCookie++;
        return NOERROR;
    }

    HRESULT EndSection(DWORD dwSectionCookie)
    {
        UNUSED(dwSectionCookie); // Eventually check this so that we can make sure caller doesn't mis-match begins/ends
        if (!m_fInitialized) return E_UNEXPECTED;
        if (m_fPipeBad) return HRESULT_FROM_WIN32(ERROR_BAD_PIPE);
        FUSION_PSTREAM_ELEMENT elt;
        elt.bIndicator = FUSION_PSTREAM_INDICATOR_SECTION_END;
        IFFAIL_RETURN(m_srpIPipeByte->Push((LPBYTE) &elt, FUSION_PSTREAM_SIZEOF_SECTION_END));
        return NOERROR;
    }

    HRESULT WriteProperty(DWORD dwSectionCookie, ULONG ulPropertyID, PROPVARIANT varValue)
    {
        UNUSED(dwSectionCookie);
        if (!m_fInitialized) return E_UNEXPECTED;
        if (m_fPipeBad) return HRESULT_FROM_WIN32(ERROR_BAD_PIPE);
        // Too much work to even try to do inline..
        bool fAnyDataWritten = false;
        IFFAIL_SET_PIPE_BAD_IF_AND_RETURN(::FusionWriteProperty(m_srpIPipeByte, ulPropertyID, varValue, fAnyDataWritten), fAnyDataWritten);
        return NOERROR;
    }

    // cch should not include space for the null...
    HRESULT WriteProperty(DWORD dwSectionCookie, ULONG ulPropertyID, LPCWSTR szValue, INT cch = -1)
    {
        UNUSED(dwSectionCookie);
        if (!m_fInitialized) return E_UNEXPECTED;
        if (m_fPipeBad) return HRESULT_FROM_WIN32(ERROR_BAD_PIPE);
        if (cch < 0)
        {
            cch = ::wcslen(szValue);
            // Handle overflow - crazy case, but might as well not crash.
            if (cch < 0)
                cch = 0x7fffffff;
        }
        else {
            // Trim off trailing null characters when user passed in cch > 0
            while ((cch > 0) && (szValue[cch - 1] == L'\0')) cch--;
        }
        FUSION_PSTREAM_ELEMENT elt;
        elt.bIndicator = FUSION_PSTREAM_INDICATOR_PROPERTY;
        elt.PropertyVal.propid = ulPropertyID;
        elt.PropertyVal.wType = VT_LPWSTR;
        bool fAnyDataWritten = false;
        IFFAIL_RETURN(m_srpIPipeByte->Push((LPBYTE) &elt, FUSION_PSTREAM_SIZEOF_PROPERTY));
        IFFAIL_SET_PIPE_BAD_AND_RETURN(m_srpIPipeByte->Push((LPBYTE) &cch, sizeof(cch)));
        IFFAIL_SET_PIPE_BAD_AND_RETURN(m_srpIPipeByte->Push((LPBYTE) szValue, cch * sizeof(WCHAR)));
        return NOERROR;
    }

    // WriteVector() currently only understands: VT_UI2, VT_BLOB
    HRESULT WriteVectorVa(DWORD dwSectionCookie, ULONG ulPropertyID, VARTYPE vt, ULONG cElements, va_list ap)
    {
        HRESULT hr = NOERROR;
        bool fAnyDataWritten = false;
        UNUSED(dwSectionCookie);
        if (!m_fInitialized) { hr = E_UNEXPECTED; goto Exit; }
        if (m_fPipeBad) { hr = HRESULT_FROM_WIN32(ERROR_BAD_PIPE); goto Exit; }
        switch (vt)
        {
        case VT_BLOB:
            SET_PIPE_BAD_IF_AND_EXIT(
                ::FusionWriteBlobVectorProperty(m_srpIPipeByte, ulPropertyID, cElements, ap, fAnyDataWritten),
                fAnyDataWritten);
            break;

        case VT_UI2:
            SET_PIPE_BAD_IF_AND_EXIT(
                ::FusionWriteUI2VectorProperty(m_srpIPipeByte, ulPropertyID, cElements, ap, fAnyDataWritten),
                fAnyDataWritten);
            break;

        default:
            ASSERT(FALSE);
            hr = E_INVALIDARG;
            goto Exit;

            break;
        }

        hr = NOERROR;
    Exit:
        return hr;
    }

    HRESULT WriteVector(DWORD dwSectionCookie, ULONG ulPropertyID, VARTYPE vt, ULONG cElements, ...)
    {
        va_list ap;
        if (!m_fInitialized) return E_UNEXPECTED;
        if (m_fPipeBad) return HRESULT_FROM_WIN32(ERROR_BAD_PIPE);
        va_start(ap, cElements);
        HRESULT hr = this->WriteVectorVa(dwSectionCookie, ulPropertyID, vt, cElements, ap);
        va_end(ap);
        if (!FAILED(hr)) hr = NOERROR;
        return hr;
    }

    HRESULT Close()
    {
        if (!m_fInitialized) return E_UNEXPECTED;
        HRESULT hr = m_srpIPipeByte->Push(0, 0);
        if (FAILED(hr)) return hr;
        m_srpIPipeByte.Release();
        m_fInitialized = false;
        return NOERROR;
    }

protected:
    CSmartRef<IPipeByte> m_srpIPipeByte;
    bool m_fInitialized;
    DWORD m_dwNextSectionCookie;
    bool m_fPipeBad;
};

//
//  CPropertyStreamPipeReader is an aggregatable/tear-off-able COM object that
//  you can instantiate on your class in order to get callbacks when a piped
//  property stream has data available on it.
//
//  We expect to invoke the following member functions on the T pointer passed in:
//
//  HRESULT OnPropertyStreamHeader(PFUSION_PSTREAM_VERSION_INDEPENDENT_HEADER phdr);
//      Called when the header has been recognized from the stream in.
//      If this function returns a non-successful HRESULT, the remainder of
//      the property stream is discarded, and when OnPropertyStreamEnd() is
//      called, the caller should call StopParsingPropertyStream().
//
//  HRESULT OnPropertyStreamElement(PFUSION_PSTREAM_ELEMENT pelt);
//      Called when a property stream element header has been recognized.
//      This may be either a section begin (in which case the section guid
//      and ID are available in the pelt), a section end (no additional data),
//      or a property (in which case the property id and property type are
//      available in the pelt).  Once a property header has been found, the
//      property data is buffered until entirely available.
//      If this function returns a non-successful HRESULT, the remainder of
//      the property stream is discarded, and when OnPropertyStreamEnd() is
//      called, the caller should call StopParsingPropertyStream().
//
//  HRESULT OnPropertyStreamPropertyValue(LPCBYTE *prgbValue, ULONG cbValue);
//      Called when an entire property value is available.  Note that
//      the buffer passed in is the raw format of the property value; strings
//      are not null terminated and there may or may not be valid data past
//      prgbValue[cbValue-1].
//      If this function returns a non-successful HRESULT, the remainder of
//      the property stream is discarded, and when OnPropertyStreamEnd() is
//      called, the caller should call StopParsingPropertyStream().
//
//  VOID OnPropertyStreamEnd(CPropertyStreamPipeReaderBase::PropertyStreamEndReason er);
//      Called when the pipe is closed/ended.
//

class __declspec(novtable) CPropertyStreamPipeReaderBase : public CFusionCOMObjectBase, public IPipeByte
{
public:
    FUSION_BEGIN_COM_MAP(CPropertyStreamPipeReaderBase)
        FUSION_COM_INTERFACE_ENTRY(IPipeByte)
    FUSION_END_COM_MAP()

    HRESULT StartParsingPropertyStream();
    HRESULT StopParsingPropertyStream();

    // IPipeByte methods:
    STDMETHODIMP Pull(BYTE *prgbBuffer, ULONG cRequest, ULONG *pcReturned);
    STDMETHODIMP Push(BYTE *prgbBuffer, ULONG cbBuffer);

    enum PropertyStreamEndReason
    {
        eNormalEnd,
        eStreamFormatError,
        ePropertyTypeError,
        eStreamEndEarly,
        eInternalError,         // indicates a code bug
        eOutOfMemory,
        eOtherError,            // indicates some HRESULT other than E_OUTOFMEMORY was encountered
    };

protected:
    CPropertyStreamPipeReaderBase() : m_fInitialized(false), m_iByteCurrent(0) { }
    ~CPropertyStreamPipeReaderBase() { }

    virtual HRESULT FireOnPropertyStreamHeader(PCFUSION_PSTREAM_VERSION_INDEPENDENT_HEADER phdr) = 0;
    virtual HRESULT FireOnPropertyStreamElement(PCFUSION_PSTREAM_ELEMENT pelt) = 0;
    virtual HRESULT FireOnPropertyStreamPropertyValue(PCBYTE prgbValue, ULONG cbValue) = 0;
    virtual VOID FireOnPropertyStreamEnd(PropertyStreamEndReason pser) = 0;

    bool m_fInitialized;
    CByteBuffer m_buffer;
    ULONG m_iByteCurrent;

    enum State
    {
        eIdle,                      // Not yet started parsing
        eWaitingForHeader,          // waiting for header bytes
        eWaitingForIndicator,       // waiting for indicator byte
        eWaitingForSection,         // waiting for remainder of section header
        eWaitingForProperty,        // waiting for property
        eWaitingForPropertySize,    // Waiting for some size/count on the property
        eWaitingForPropertyElementSize,
        eWaitingForPropertyElementData,
        eWaitingForPropertyValue,   // waiting for property value
        eWaitingForPipeEnd,         // Hit end indicator; next push should be length 0 and there should
                                    // be no data in the buffer.
        ePipeDone,                  // end of pipe hit; will transition to idle when parsing is stopped
        eDiscarded,                 // we don't care about the rest of the data pushed to us.
    } m_state;

    ULONG m_cbRequiredForNextStateTransition;
    ULONG m_cVectorElementsLeft;    // Used when parsing VT_VECTOR properties; we store the
                                    // total number of elements we still expect to find in the
                                    // data stream here so we can tell when we can fire
                                    // OnPropertyStreamPropertyValue().
    ULONG m_iNextVectorSize;        // Offset from m_iByteCurrent to the next vector element size.
    WORD m_wType;                   // current property type we're parsing; makes a lot of code
                                    // simpler to just copy it here.

    HRESULT OnStateMet();
    HRESULT OnWaitingForHeaderStateMet();
    HRESULT OnWaitingForIndicatorStateMet();
    HRESULT OnWaitingForSectionStateMet();
    HRESULT OnWaitingForPropertyStateMet();
    HRESULT OnWaitingForPropertySizeStateMet();
    HRESULT OnWaitingForPropertyValueStateMet();
    HRESULT OnWaitingForPropertyElementSizeStateMet();
    HRESULT OnWaitingForPropertyElementDataStateMet();
};

template <class T> class __declspec(novtable) CPropertyStreamPipeReader : public CPropertyStreamPipeReaderBase
{
public:
    CPropertyStreamPipeReader() : m_pt(NULL) { }
    ~CPropertyStreamPipeReader() { m_pt = NULL; }

    HRESULT Initialize(T *pt)
    {
        if (m_fInitialized) return E_UNEXPECTED;
        if (pt == NULL) return E_POINTER;
        IFFAIL_RETURN(CFusionCOMObjectBase::Initialize());
        m_pt = pt;
        m_state = eIdle;
        return NOERROR;
    }

protected:
    T *m_pt;

    virtual HRESULT FireOnPropertyStreamHeader(PCFUSION_PSTREAM_VERSION_INDEPENDENT_HEADER phdr)
    {
        ASSERT(m_fInitialized);
        if (!m_fInitialized) return E_UNEXPECTED;
        return m_pt->OnPropertyStreamHeader(phdr);
    }

    virtual HRESULT FireOnPropertyStreamElement(PCFUSION_PSTREAM_ELEMENT pelt)
    {
        ASSERT(m_fInitialized);
        if (!m_fInitialized) return E_UNEXPECTED;
        return m_pt->OnPropertyStreamElement(pelt);
    }

    virtual HRESULT FireOnPropertyStreamPropertyValue(PCBYTE prgbValue, ULONG cbValue)
    {
        ASSERT(m_fInitialized);
        if (!m_fInitialized) return E_UNEXPECTED;
        return m_pt->OnPropertyStreamPropertyValue(prgbValue, cbValue);
    }

    virtual VOID FireOnPropertyStreamEnd(PropertyStreamEndReason er)
    {
        ASSERT(m_fInitialized);
        if (m_fInitialized) m_pt->OnPropertyStreamEnd(er);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\pstream.h ===
#if !defined(_FUSION_INC_PSTREAM_H_INCLUDED_)
#define _FUSION_INC_PSTREAM_H_INCLUDED_

#pragma once

typedef struct tagFUSION_PSTREAM_VERSION_INDEPENDENT_HEADER
{
    WORD    wByteOrder;     // Always 0xFFFE for little-endian
    WORD    wFormat;        // Starting with 1
    DWORD   dwOSVer;        // System version
    CLSID   clsid;          // Originator identifier
    DWORD   reserved;       // reserved as in PROPERTYSETHEADER
} FUSION_PSTREAM_VERSION_INDEPENDENT_HEADER, *PFUSION_PSTREAM_VERSION_INDEPENDENT_HEADER;

typedef const FUSION_PSTREAM_VERSION_INDEPENDENT_HEADER *PCFUSION_PSTREAM_VERSION_INDEPENDENT_HEADER;

typedef struct tagFUSION_PSTREAM_VERSION_1_HEADER
{
    FUSION_PSTREAM_VERSION_INDEPENDENT_HEADER vih;
} FUSION_PSTREAM_VERSION_1_HEADER, *PFUSION_PSTREAM_VERSION_1_HEADER;

typedef struct tagFUSION_PSTREAM_ELEMENT
{
    BYTE bIndicator;
    union
    {
        struct
        {
            GUID guidSectionSet;
            ULONG ulSectionID;
        } BeginSectionVal;
        struct
        {
            DWORD propid;
            WORD wType;
        } PropertyVal;
    };
} FUSION_PSTREAM_ELEMENT, *PFUSION_PSTREAM_ELEMENT;

typedef const FUSION_PSTREAM_ELEMENT *PCFUSION_PSTREAM_ELEMENT;

#define FUSION_PSTREAM_INDICATOR_SECTION_BEGIN  (1)
#define FUSION_PSTREAM_SIZEOF_SECTION_BEGIN     (21) // BYTE + GUID + ULONG
#define FUSION_PSTREAM_INDICATOR_SECTION_END    (2)
#define FUSION_PSTREAM_SIZEOF_SECTION_END       (1) // BYTE
#define FUSION_PSTREAM_INDICATOR_PROPERTY       (3)
#define FUSION_PSTREAM_SIZEOF_PROPERTY          (7) // BYTE + DWORD + WORD
#define FUSION_PSTREAM_INDICATOR_END            (4)
#define FUSION_PSTREAM_SIZEOF_END               (1) // BYTE

//
//  While the design for the fusion property stream is similar to the
//  OLE property set persistance format, it's specifically optimized to
//  be able to be pushed over the wire with as little pre-calculation
//  and buffering as possible.  Thus rather than having each property
//  carry its total byte count (which may not be computable), each
//  type is generally prefixed by either an element count or a length.
//
//  Specifics, per type:
//
//  VT_I1, VT_UI1:
//                      03          // FUSION_PSTREAM_INDICATOR_PROPERTY
//                      xx xx xx xx // property id
//                      10 00       // VT_I1
//                      yy          // single byte integer value
//
//  VT_I2, VT_UI2:
//                      03          // FUSION_PSTREAM_INDICATOR_PROPERTY
//                      xx xx xx xx // property id
//                      02 00       // VT_I2
//                      yy yy       // word integer value
//
//  VT_I4, VT_UI4:
//                      03          // FUSION_PSTREAM_INDICATOR_PROPERTY
//                      xx xx xx xx // property id
//                      03 00       // VT_I4
//                      yy yy yy yy // dword integer value
//
//  VT_LPSTR:
//                      03          // FUSION_PSTREAM_INDICATOR_PROPERTY
//                      xx xx xx xx // property id
//                      1E 00       // VT_LPSTR
//                      yy yy yy yy // byte/character count
//                      ...         // "y" bytes of data; no null terminator and no padding
//
//  VT_LPWSTR:
//                      03          // FUSION_PSTREAM_INDICATOR_PROPERTY
//                      xx xx xx xx // property id
//                      1F 00       // VT_LPWSTR
//                      yy yy yy yy // character count
//                      ...         // "y" characters (2*y bytes) of data; no null terminator and no padding
//
//  VT_BLOB:
//                      03          // FUSION_PSTREAM_INDICATOR_PROPERTY
//                      xx xx xx xx // property id
//                      41 00       // VT_BLOB
//                      yy yy yy yy // byte count
//                      ...         // "y" bytes of data; no padding
//
//  VT_VECTOR | VT_LPWSTR:
//                      03          // FUSION_PSTREAM_INDICATOR_PROPERTY
//                      xx xx xx xx // property id
//                      1F 10       // VT_VECTOR | VT_LPWSTR
//                      yy yy yy yy // element count
//                      zz zz zz zz // character count for first element
//                      ...         // "z" characters (2*z bytes) of data; no null terminator and no padding
//                      zz zz zz zz // character count for 2nd element
//                      ...         // "z" characters (2*z bytes) of data; no null terminator and no padding
//                          .
//                          .
//                          .
//                      repeats "y" times; y may be 0 in which case the property ends immediately
//                      after the "y" bytes.
//
//


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\serialst.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    serialst.h

Abstract:

    Header file for serialst.c

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Revision History:

    16-Feb-1995 rfirth
        Created

    05-Jul-1999 adriaanc
        nabbed for fusion

--*/

#if defined(__cplusplus)
extern "C" {
#endif


// defines copied from wininet\common
#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))


#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))


#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}


#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }


#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }


#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }


#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

//
// types
//

#if DBG
typedef struct _RESOURCE_INFO
{
    DWORD Tid;
} RESOURCE_INFO, *LPRESOURCE_INFO;
#endif // DBG

typedef struct {

#if DBG

    //
    // Signature - must have this to ensure its really a serialized list. Also
    // makes finding start of this structure relatively easy when debugging
    //

    DWORD Signature;

    //
    // ResourceInfo - basically who owns this 'object', combined with yet more
    // debugging information
    //

    RESOURCE_INFO ResourceInfo;

    //
    // LockCount - number of re-entrant locks held
    //

    LONG LockCount;

#endif // DBG

    LIST_ENTRY List;

    //
    // ElementCount - number of items on list. Useful for consistency checking
    //

    LONG ElementCount;

    //
    // Lock - we must acquire this to update the list. Put this structure at
    // the end to make life easier when debugging
    //

    CRITICAL_SECTION Lock;

} SERIALIZED_LIST, *LPSERIALIZED_LIST;

//
// SERIALIZED_LIST_ENTRY - we can use this in place of LIST_ENTRY so that in
// the debug version we can check for cycles, etc.
//

typedef struct {

    LIST_ENTRY List;

#if DBG

    DWORD Signature;
    DWORD Flags;

#endif

} SERIALIZED_LIST_ENTRY, *LPSERIALIZED_LIST_ENTRY;

//
// prototypes
//

#if DBG

VOID
InitializeSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
TerminateSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
LockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
UnlockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
InsertAtHeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

VOID
InsertAtTailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

VOID
RemoveFromSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

BOOL
IsSerializedListEmpty(
    IN LPSERIALIZED_LIST SerializedList
    );

PLIST_ENTRY
HeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

PLIST_ENTRY
TailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
CheckEntryOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    );

#define IsLockHeld(list) \
    (((list)->ResourceInfo.Tid == GetCurrentThreadId()) \
        ? ((list)->LockCount != 0) \
        : FALSE)

#else // DBG

#define InitializeSerializedList(list) \
    { \
        InitializeListHead(&(list)->List); \
        InitializeCriticalSection(&(list)->Lock); \
        (list)->ElementCount = 0; \
    }

#define TerminateSerializedList(list) \
    DeleteCriticalSection(&(list)->Lock)

#define LockSerializedList(list) \
    EnterCriticalSection(&(list)->Lock)

#define UnlockSerializedList(list) \
    LeaveCriticalSection(&(list)->Lock)

#define InsertAtHeadOfSerializedList(list, entry) \
    { \
        LockSerializedList(list); \
        InsertHeadList(&(list)->List, entry); \
        ++(list)->ElementCount; \
        UnlockSerializedList(list); \
    }

#define InsertAtTailOfSerializedList(list, entry) \
    { \
        LockSerializedList(list); \
        InsertTailList(&(list)->List, entry); \
        ++(list)->ElementCount; \
        UnlockSerializedList(list); \
    }

#define RemoveFromSerializedList(list, entry) \
    { \
        LockSerializedList(list); \
        RemoveEntryList(entry); \
        --(list)->ElementCount; \
        UnlockSerializedList(list); \
    }

#define IsSerializedListEmpty(list) \
    IsListEmpty(&(list)->List)

#define HeadOfSerializedList(list) \
    (list)->List.Flink

#define TailOfSerializedList(list) \
    (list)->List.Blink

#define IsLockHeld(list) \
    /* NOTHING */



#endif // DBG

//
// functions that are always functions
//

LPVOID
SlDequeueHead(
    IN LPSERIALIZED_LIST SerializedList
    );

LPVOID
SlDequeueTail(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
IsOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

//
// functions that are always macros
//

#define NextInSerializedList(list, entry)\
        (( ((entry)->List).Flink == &((list)->List))? NULL : ((entry)->List).Flink)

#define ElementsOnSerializedList(list) \
    (list)->ElementCount

#define SlSelf(SerializedList) \
    &(SerializedList)->List.Flink

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\smartref.h ===
#if !defined(_FUSION_MI_CIPTR_H_INCLUDED_)
#define _FUSION_MI_CIPTR_H_INCLUDED_

#pragma once

#include <unknwn.h>
#include "CSxsPreserveLastError.h"

template <typename T> class CSmartRef
{
public:
    inline CSmartRef() : m_pt(NULL) { }
    inline CSmartRef(const CSmartRef& r) : m_pt(r.m_pt) { if (m_pt) m_pt->AddRef(); }
    inline CSmartRef(T *pt) : m_pt(pt) { if (pt != NULL) pt->AddRef(); }
    inline ~CSmartRef() { if (m_pt != NULL) { CSxsPreserveLastError ple; m_pt->Release(); m_pt = NULL; ple.Restore(); } }

    inline T *operator ->() const { ASSERT_NTC(m_pt != NULL); return m_pt; }
    inline T **operator &() { ASSERT_NTC(m_pt == NULL); return &m_pt; }

    CSmartRef<T> &operator =(T *pt) { if (pt != NULL) pt->AddRef(); if (m_pt != NULL) m_pt->Release(); m_pt = pt; return *this; }
    CSmartRef<T> &operator =(const CSmartRef& r) { return operator=(r.m_pt); }

    inline operator T *() const { return m_pt; }
    inline T *Ptr() const { return m_pt; }

    inline void Release() { if (m_pt != NULL) { m_pt->Release(); m_pt = NULL; } }
    T *Disown() { T *pt = m_pt; m_pt = NULL; return pt; }

    inline void Take(CSmartRef<T> &r) { if (r.m_pt != NULL) { r.m_pt->AddRef(); } if (m_pt != NULL) { m_pt->Release(); } m_pt = r.m_pt; r.m_pt = NULL; }

    HRESULT Initialize(T *pt) { (*this) = pt; return NOERROR; }

    HRESULT CreateInstance(REFCLSID rclsid, IUnknown *pUnkOuter = NULL, CLSCTX clsctx = static_cast<CLSCTX>(CLSCTX_ALL))
    {
        T *pt = NULL;
        HRESULT hr = ::CoCreateInstance(rclsid, pUnkOuter, clsctx, __uuidof(T), (LPVOID *) &pt);
        if (FAILED(hr)) return hr;
        if (m_pt != NULL)
            m_pt->Release();
        m_pt = pt;
        pt = NULL;
        return NOERROR;
    }

    HRESULT QueryInterfaceFrom(IUnknown *pIUnknown)
    {
        HRESULT hr = NOERROR;
        T *pt = NULL;

        if (pIUnknown == NULL)
            this->Release();
        else
        {
            hr = pIUnknown->QueryInterface(__uuidof(T), (void **) &pt);
            if (FAILED(hr))
                goto Exit;

            if (m_pt != NULL)
                m_pt->Release();

            m_pt = pt;
        }

        hr = NOERROR;

    Exit:

        return hr;
    }

    // Not protected, because we need access to it for the table-based aggregation
    // in fusioncom.h to work, but don't touch it unless you understand the consequences!!
    T *m_pt;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\returnstrategy.h ===
#pragma once

//
// This an incomplete return strategy bridge.
// Return strategies include BOOL/LastError, no tls LastError, HRESULT, HRESULT/IErrorInfo, exception.
// Where exception is multiple types, including HRESULT and _com_error.
// This only bridges BOOL/LastError and HRESULT.
//
// What problem we are solving.
//
// We had a few functions duplicated. One copy would return HRESULTs "all the way down",
// one would propagate BOOL and the thread local LastError "all the way down". By
// "all the way down" I mean any function calls were changed to call a function of the
// corresponding "return strategy", cloning that function as well do to the same thing,
// "transitive closure". Such source code duplication is not good; there were
// inconsistencies in the clones and the source was a little confusing for all the duplication
// (it's still confusing, and it isn't clear we helped the situation).
// There are at least two ways to fix this source code duplication.
//
// a) write most code using one return strategy, and occasionally transition to the
// other as needed; this results in no code duplication, but you must be sure
// that maximal error information is available/preserved, and that transitions are
// not too difficult to write or too slow to run; this is well demonstrated in the Vsee
// code base that throws _com_errors internally and transitions to HRESULT/IErrorInfo*
// at COM boundaries.
//
// b) templatize the code as we have
//
// How you use it.
//
//  See FusionBuffer.h
//
// Future stuff.
//
// A more complete design probably requires a nested typedef "BeginTryBlockType".
//
// try
// {
//      returnStrategy.BeginTryBlock(&beginTryBlockValue);
//      if (FAILED())
//          return returnStrategy.ReturnHr(hr);
//      returnStrategy.EndTryBlock(&beginTryBlockValue);
//  }
//  catch (TReturnStrategy::ExceptionType exceptionValue) // to bad we can't catch void
//  {
//      .. something like returnStrategy.Catch(exceptionValue)
//      or if returnStrategy.Rethrow(exceptionValue)
//      or returnStrategy.ReturnException(); !
// }
//
// and then wrap it up in macros like VSEE_TRY \\jayk1\g\vs\src\vsee\lib\Try.h
//
// More generally, you might just have work to do upon any return strategy transition.
//
// TBD.
//
// Furthermore, the act of "saving last error" (Win32 GetLastError/::FusionpSetLastWin32Error
// or COM GetErrorInfo/SetErrorInfo) around cleanup should probably be encapsulated here.
// It would be nothing for "full" exception types, only IErrorInfo* for some, only LastError for others,
// etc.
//
// TBD.
//

#define UNCHECKED_DOWNCAST static_cast

template <typename T, typename RetType>
/*
T should have
    nested enums (or member data set in the constructor or static member data)
        SuccessValue, FailureValue of type ReturnType
    functions SetHresult, SetWin32Bool, GetBool,
    if you actually use enough of it for the compiler to enforce these
*/
class CReturnStrategyBase
{
public:
    typedef RetType ReturnType;
    ReturnType m_returnValue;

    // like ATL; the compiler does not typecheck this, it depends
    // on "careful inheritance"
    T*          t()       { return UNCHECKED_DOWNCAST<T*>(this); }
    const T*    t() const { return UNCHECKED_DOWNCAST<const T*>(this); }

    // this is like a constructor, where you'd start a function with
    // BOOL fSucceeded = FALSE;
    // or
    // HRESULT hr = E_FAIL;
    //
    // But note that following the pattern of BOOL fSucceeded = FALSE doesn't work.
    // You know that the pattern HRESULT hr = E_FAIL is usually actually
    // hr = NOERROR, because if you fail, it will be by propogating someone else's
    // returned HRESULT. Well, we might be returning a BOOL or an HRESULT.
    // We propagate an HRESULT, if that is the case, by explicitly calling
    // SetWin32Bool(FALSE) after a failed Win32 calls, which if we are returning
    // HRESULTs, will call GetLastError.
    ReturnType AssumeFailure()
    {
        return (m_returnValue = t()->FailureValue);
    }

    // this is like a constructor, where you'd start a function with
    // BOOL fSucceeded = TRUE;
    // or
    // HRESULT hr = NOERROR;
    //
    // There is really no advantage to this over
    //   returnStrategy->SetWin32Bool(TRUE) or SetHresult(NOERROR);
    //   return returnStrategy->Return();
    //
    // We must assume some level of translatability between return strategies.
    // Win32Bool(TRUE) and SetHresult(NOERROR) convert losslessly.
    //
    // We might have "informational" and "warning" to contend with at some point.
    ReturnType AssumeSuccess()
    {
        return (m_returnValue = t()->SuccessValue);
    }

    ReturnType Return() const
    {
        return m_returnValue;
    }

    // CallThatUsesReturnStrategy(...);
    // if (returnStrategy->Failed())
    //     goto Exit;
    BOOL Failed() const
    {
        return !t()->GetBool();
    }

    BOOL Succeeded() const
    {
        return t()->GetBool();
    }

    ReturnType ReturnHr(HRESULT hr)
    {
        t()->SetHresult(hr);
        return Return();
    }

    ReturnType ReturnWin32Bool(BOOL f)
    {
        t()->SetWin32Bool(f);
        return Return();
    }
};

class CReturnStrategyBoolLastError : public CReturnStrategyBase<CReturnStrategyBoolLastError, BOOL>
{
public:
    enum
    {
        SuccessValue = TRUE,
        FailureValue = FALSE
    };

    BOOL GetBool() const
    {
        return m_returnValue;
    }

    VOID SetInternalCodingError()
    {
        m_returnValue = FALSE;
        ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
    }

    VOID SetWin32Error(DWORD lastError)
    {
        if (lastError == NO_ERROR)
        {
            m_returnValue = TRUE;
        }
        else
        {
            m_returnValue = FALSE;
            ::FusionpSetLastWin32Error(lastError);
        }
    }

    VOID SetWin32Bool(BOOL f)
    {
        m_returnValue = f;
    }

    VOID SetHresult(HRESULT hr)
    {
        ASSERT_NTC(
               HRESULT_FACILITY(hr) == FACILITY_NULL
            || HRESULT_FACILITY(hr) == FACILITY_WINDOWS
            || HRESULT_FACILITY(hr) == FACILITY_WIN32);

        if (!(m_returnValue = SUCCEEDED(hr)))
        {
            // It's confusing if this is FACILITY_WIN32 or FACILITY_WINDOWS
            // or what, we avoid knowing it.
            const DWORD facilityWin32 = HRESULT_FACILITY(HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED));
            if (HRESULT_FACILITY(hr) == facilityWin32)
            {
                DWORD dwWin32Error = HRESULT_CODE(hr);
                ::FusionpSetLastWin32Error(dwWin32Error);
            }
            else
            {
                // This is dubious, but FormatMessage can cope with
                // many of them, and that's the most common thing I
                // imagine people do with this other than propagate.
                // They also check for particular values, and if we
                // pretend this is FACILITY_WIN32, we'll bogusly
                // impersonate values.
                ::FusionpSetLastWin32Error(hr);
            }
        }
    }

    HRESULT GetHresult() const
    {
        if (m_returnValue)
        {
            return NOERROR;
        }
        else
        {
            DWORD lastError = ::FusionpGetLastWin32Error();
            if (lastError == NO_ERROR)
            {
                return E_FAIL;
            }
            return HRESULT_FROM_WIN32(lastError);
        }
    }
};

class CReturnStrategyHresult : public CReturnStrategyBase<CReturnStrategyHresult, HRESULT>
{
public:
    enum
    {
        SuccessValue = NOERROR,
        FailureValue = E_FAIL // not the only one
    };

    BOOL GetBool() const
    {
        return SUCCEEDED(m_returnValue);
    }

    VOID SetInternalCodingError()
    {
        m_returnValue = E_UNEXPECTED;
    }

    VOID SetWin32Error(DWORD lastError)
    {
        m_returnValue = HRESULT_FROM_WIN32(lastError);
    }

    VOID SetWin32Bool(BOOL f)
    {
        if (f)
        {
            m_returnValue = NOERROR;
        }
        else
        {
            DWORD lastError = ::FusionpGetLastWin32Error();
            if (lastError != NO_ERROR)
            {
                m_returnValue = HRESULT_FROM_WIN32(lastError);
            }
            else
            {
                m_returnValue = E_FAIL;
            }
        }
    }

    VOID SetHresult(HRESULT hr)
    {
        m_returnValue = hr;
    }

    HRESULT GetHresult() const
    {
        return m_returnValue;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\smartptr.h ===
#if !defined(_FUSION_INC_SMARTPTR_H_INCLUDED_)
#define _FUSION_INC_SMARTPTR_H_INCLUDED_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    SxsExceptionHandling.h

Abstract:

Author:

    Jay Krell (a-JayK) October 2000

Revision History:

--*/
#pragma once

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "fusiontrace.h"
#include "csxspreservelasterror.h" // Most destructors should use this.
#include "fusionheap.h"

//template <typename T> void SxsDelete(T* /*&*/ p) { T* q = p; p = NULL; delete q; }

//
// Need to flesh this out.
// See \\cpvsbuild\Drops\v7.0\raw\current\vs\src\VSEE\lib\Memory\*Pointer*.
//

//
// Split off into ATL style Base/Derived to avoid compiler ICE;
// Otherwise was void (*Delete)(T*) = SxsDelete<T>
//

template <typename T, typename Derived>
class CSxsPointerBase
{
    CSxsPointerBase(const CSxsPointerBase&); // deliberately not implemented
    void operator=(const CSxsPointerBase&); // deliberately not implemented

protected:
    T* m_p;
    void operator=(T* p);

    HRESULT HrAllocateBase(PCSTR pszFileName, int nLine, PCSTR pszTypeName) { HRESULT hr = E_FAIL; FN_TRACE_HR(hr); INTERNAL_ERROR_CHECK(m_p == NULL); IFALLOCFAILED_EXIT(m_p = new(pszFileName, nLine, pszTypeName) T); hr = NOERROR; Exit: return hr; }
    BOOL Win32AllocateBase(PCSTR pszFileName, int nLine, PCSTR pszTypeName) { BOOL fSuccess = FALSE; FN_TRACE_WIN32(fSuccess); INTERNAL_ERROR_CHECK(m_p == NULL); IFALLOCFAILED_EXIT(m_p = new(pszFileName, nLine, pszTypeName) T); fSuccess = TRUE; Exit: return fSuccess; }

public:
    CSxsPointerBase(T* p = NULL);
    ~CSxsPointerBase();

    operator T*() { return m_p; }
    operator T const *() const { return m_p; }
    T** operator&() { ASSERT_NTC( m_p == NULL ); return &m_p; }
    T* operator->() { return m_p; }
    T const * operator->() const { return m_p; }

    // this stores null in m_p and returns its previous value
    T* Detach() { T *p = m_p; m_p = NULL; return p; }

    // these are synonyms of each other
    void Delete();
};

template <typename T, PCSTR pszTypeName>
class CSxsPointer : public CSxsPointerBase<T, CSxsPointer>
{
    typedef CSxsPointerBase<T, CSxsPointer> Base;
    CSxsPointer(const CSxsPointer&); // deliberately not implemented
    operator=(const CSxsPointer&); // deliberately not implemented
public:
    CSxsPointer(T* p = NULL) : Base(p) { }
    CSxsPointer& operator=(T* p) { Base::operator=(p); return *this; }
    bool operator ==(const CSxsPointer &r) const { return m_p == r.m_p; }
    ~CSxsPointer() { }
    static void Delete(T* p) { if (p != NULL) { CSxsPreserveLastError ple; FUSION_DELETE_SINGLETON(p); ple.Restore(); } }

    HRESULT HrAllocate(PCSTR pszFileName, int nLine) { return Base::HrAllocateBase(pszFileName, nLine, pszTypeName); }
    BOOL Win32Allocate(PCSTR pszFileName, int nLine) { return Base::Win32AllocateBase(pszFileName, nLine, pszTypeName); }
};

#define SMARTPTR(_T) CSxsPointer<_T, _T::ms_szTypeName>
#define SMARTTYPEDEF(_T) static PCSTR ms_szTypeName
#define SMARTTYPE(_T) __declspec(selectany) PCSTR _T::ms_szTypeName = #_T

template <typename T>
class CSxsArrayPointer : public CSxsPointerBase<T, CSxsArrayPointer>
{
    typedef CSxsPointerBase<T, CSxsArrayPointer> Base;
public:
    CSxsArrayPointer(T* p = NULL) : Base(p) { }
    CSxsArrayPointer& operator=(T* p) { Base::operator=(p); return *this; }
    bool operator ==(const CSxsArrayPointer &r) const { return m_p == r.m_p; }
    bool operator ==(T *prgt) const { return m_p == prgt; }
    ~CSxsArrayPointer() { }
    static void Delete(T* p) { if (p != NULL) { CSxsPreserveLastError ple; FUSION_DELETE_ARRAY(p); ple.Restore(); } }

private:
    CSxsArrayPointer(const CSxsArrayPointer &);
    void operator =(const CSxsArrayPointer &);
};

template <typename T, void (*Destructor)(T*)>
class CSxsPointerWithNamedDestructor : public CSxsPointerBase<T, CSxsPointerWithNamedDestructor>
{
    typedef CSxsPointerBase<T, CSxsPointerWithNamedDestructor> Base;
    CSxsPointerWithNamedDestructor(const CSxsPointerWithNamedDestructor&); // deliberately not implemented
    void operator=(const CSxsPointerWithNamedDestructor&); // deliberately not implemented
public:
    CSxsPointerWithNamedDestructor(T* p = NULL) : Base(p) { }

    CSxsPointerWithNamedDestructor& operator=(T* p) { Base::operator=(p); return *this; }
    bool operator ==(const CSxsPointerWithNamedDestructor &r) const { return m_p == r.m_p; }
    bool operator ==(T *pt) const { return m_p == pt; }

    ~CSxsPointerWithNamedDestructor() { CSxsPreserveLastError ple; Base::Delete(); ple.Restore(); }
    static void Delete(T* p) { if (p != NULL) { CSxsPreserveLastError ple; Destructor(p); ple.Restore(); } }
};

template <typename T, typename Derived>
inline CSxsPointerBase<T, Derived>::CSxsPointerBase(T* p)
    : m_p(p) { }

// if verify is an expression then
//define IF_VERIFY(x) if (VERIFY(x))
//define IF_NOT_VERIFY(x) if (!VERIFY(x))
#define IF_VERIFY(x) VERIFY(x); if (x)
#define IF_NOT_VERIFY(x) VERIFY(x); if (!(x))
// in the second case, x must not have side effects

template <typename T, typename Derived>
inline void CSxsPointerBase<T, Derived>::operator=(T* p)
    { FN_TRACE(); IF_VERIFY(m_p == NULL) { m_p = p; } }

template <typename T, typename Derived>
inline void CSxsPointerBase<T, Derived>::Delete()
    { CSxsPreserveLastError ple; static_cast<Derived*>(this)->Delete(Detach()); ple.Restore(); }

template <typename T, typename Derived>
inline CSxsPointerBase<T, Derived>::~CSxsPointerBase()
    { CSxsPreserveLastError ple; Delete(); ple.Restore(); }


#endif // !defined(_FUSION_INC_SMARTPTR_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\urlparse.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\stringclass.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    stringclass.h

Abstract:

    Fusion string class, layered on the Fusion string buffer class.

Author:

    mgrier (Michael Grier) 6/27/2000

Revision History:

--*/

#if !defined(_FUSION_INC_STRINGCLASS_H_INCLUDED_)
#define _FUSION_INC_STRINGCLASS_H_INCLUDED_

#pragma once

#include "fusionbuffer.h"

#if defined(_UNICODE) || defined(UNICODE)
typedef CUnicodeHeapStringBuffer CStringValueBase;
#else
typedef CANSIHeapStringBuffer CStringValueBase;
#endif // defined(_UNICODE) || defined(UNICODE)

class CReadOnlyStringAccessor;
class CString;

class CStringValue : protected CStringValueBase
{
    friend CReadOnlyStringAccessor;
    friend CString;

protected:
    typedef CStringValueBase Base;

    typedef Base::THeap THeap;
    typedef Base::TChar TChar;
    typedef Base::TConstantString TConstantString;

    CStringValue(THeap hHeap) : Base(hHeap), m_cch(0), m_cRef(1) { }

    void AddRef() { ::InterlockedIncrement(&m_cRef); }
    void Release() { if (::InterlockedDecrement(&m_cRef) == 0) { CSxsPreserveLastError ple; delete this; ple.Restore(); } }

    BOOL Win32Initialize(TConstantString psz, SIZE_T cch) { if (this->Win32Assign(psz, cch)) { m_cch = Base::Cch(); return TRUE; } return FALSE; }
    HRESULT ComInitialize(TConstantString psz, SIZE_T cch);

private:
    ULONG m_cch;
    LONG m_cRef;
};

class CString
{
public:
    typedef CStringValue::THeap THeap;
    typedef CStringValue::TChar TChar;
    typedef CStringValue::TConstantString TConstantString;

    BOOL Win32Assign(const CString &r) { if (Base::Win32Assign(r, r.m_cch)) { m_cch = r.m_cch; return TRUE; } return FALSE; }
    HRESULT ComAssign(const CString &r) { HRESULT hr = Base::Assign(r, r.m_cch); if (SUCCEEDED(hr)) { m_cch = r.m_cch; hr = NOERROR; } return hr; }

    BOOL Win32Assign(PCWSTR s, SIZE_T cchIn = -1) { SIZE_T cch; if (Base::Win32Assign(s, cchIn, &cch)) { m_cch = cch; return TRUE; } return FALSE; }
    HRESULT ComAssign(PCWSTR s, SIZE_T cchIn = -1) { SIZE_T cch; HRESULT hr; if (SUCCEEDED(hr = Base::Assign(s, cchIn, &cch))) { m_cch = cch; hr = NOERROR; } return hr; }

    BOOL Win32Assign(PCSTR s, SIZE_T cchIn = -1) { SIZE_T cch; if (Base::Win32Assign(s, cchIn, &cch)) { m_cch = cch; return TRUE; } return FALSE; }
    HRESULT ComAssign(PCSTR s, SIZE_T cchIn = -1) { SIZE_T cch; HRESULT hr; if (SUCCEEDED(hr = Base::Assign(s, cchIn, &cch))) { m_cch = cch; hr = NOERROR; } return hr; }

    BOOL Win32AssignW(SIZE_T cStrings, ...) { va_list ap; va_start(ap, cStrings); BOOL fSuccess = this->Win32AssignWVa(cStrings, ap); va_end(ap); return fSuccess; }
    HRESULT ComAssignW(SIZE_T cStrings, ...) { va_list ap; va_start(ap, cStrings); HRESULT hr = this->ComAssignWVa(cStrings, ap); va_end(ap); return hr; }

    BOOL Win32AssignWVa(SIZE_T cStrings, va_list ap) { SIZE_T cch; if (Base::Win32AssignWVa(cStrings, &cch, ap)) { m_cch = cch; return TRUE; } return FALSE; }
    HRESULT ComAssignWVa(SIZE_T cStrings, va_list ap) { SIZE_T cch; HRESULT hr; if (SUCCEEDED(hr = Base::AssignWVa(cStrings, &cch, ap))) { m_cch = cch; hr = NOERROR; } return hr; }

    BOOL Win32Append(const CString &r) { return this->Win32Append(r, r.m_cch); }
    HRESULT ComAppend(const CString &r) { return this->ComAppend(r, r.m_cch); }

    BOOL Win32Append(PCWSTR s, SIZE_T cchIn = -1) { SIZE_T cch; if (Base::Win32Append(s, cchIn, &cch)) { m_cch = cch; return TRUE; } return FALSE; }
    HRESULT ComAppend(PCWSTR s, SIZE_T cchIn = -1) { SIZE_T cch; HRESULT hr; if (SUCCEEDED(hr = Base::Append(s, cchIn, &cch))) { m_cch = cch; hr = NOERROR; } return hr; }

    BOOL Win32Append(PCSTR s, SIZE_T cchIn = -1) { SIZE_T cch; if (Base::Win32Append(s, cchIn, &cch)) { m_cch = cch; return TRUE; } return FALSE; }
    HRESULT ComAppend(PCSTR s, SIZE_T cchIn = -1) { SIZE_T cch; HRESULT hr; if (SUCCEEDED(hr = Base::Append(s, cchIn, &cch))) { m_cch = cch; hr = NOERROR; } return hr; }

    inline BOOL Win32FormatFileTime(const FILETIME &rft);
    inline HRESULT ComFormatFileTime(const FILETIME &rft);

    inline BOOL Win32FormatFileTime(const LARGE_INTEGER &rli) { return this->Win32FormatFileTime(reinterpret_cast<const FILETIME &>(rli)); }

    SIZE_T Cch() const { return m_cch; }
    SIZE_T Cb() const { return m_cch * sizeof(TChar); }

    //
    //  This function is rather special purpose in that several design choices are not
    //  implemented as parameters.  In particular, the pcbBytesWritten is assumed to
    //  accumulate a number (thus it's updated by adding the number of bytes written to
    //  it rather than just setting it to the count of bytes written).
    //
    //  It also writes 0 bytes into the buffer is the string is zero length; if the string
    //  is not zero length, it writes the string including a trailing null.
    //

    inline BOOL Win32CopyIntoBuffer(
        PWSTR *ppszCursor,
        SIZE_T cbBuffer,
        SIZE_T *pcbBytesWritten,
        PVOID pvBase,
        ULONG *pulOffset,
        ULONG *pulLength
        );

    //
    //  String-as-path-name helpers
    //

    SIZE_T CchWithoutLastPathElement() const { return Base::CchWithoutLastPathElement(); }

    VOID RemoveLastPathElement() { Base::RemoveLastPathElement(); }
    VOID RemoveTrailingPathSeparators() { Base::RemoveTrailingPathSeparators(); }

    BOOL Win32AppendPathElement(const CString &r) { return this->Win32AppendPathElement(r, r.m_cch); }
    HRESULT ComAppendPathElement(const CString &r) { return this->ComAppendPathElement(r, r.m_cch); }

    BOOL Win32AppendPathElement(PCWSTR s, SIZE_T cchIn = -1) { SIZE_T cch; if (Base::Win32AppendPathElement(s, cchIn, &cch)) { m_cch = cch; return TRUE; } return FALSE; }
    HRESULT ComAppendPathElement(PCWSTR s, SIZE_T cchIn = -1) { SIZE_T cch; HRESULT hr; if (SUCCEEDED(hr = Base::ComAppendPathElement(s, cchIn, &cch))) { m_cch = cch; hr = NOERROR; } return hr; }

    BOOL Win32AppendPathElement(PCSTR s, SIZE_T cchIn = -1) { SIZE_T cch; if (Base::Win32AppendPathElement(s, cchIn, &cch)) { m_cch = cch; return TRUE; } return FALSE; }
    HRESULT ComAppendPathElement(PCSTR s, SIZE_T cchIn = -1) { SIZE_T cch; HRESULT hr; if (SUCCEEDED(hr = Base::ComAppendPathElement(s, cchIn, &cch))) { m_cch = cch; hr = NOERROR; } return hr; }

    BOOL Win32ChangePathExtension(PCWSTR s, SIZE_T cchIn, EIfNoExtension e) { SIZE_T cch; if (Base::Win32ChangePathExtension(s, cchIn, &cch, e)) { m_cch = cch; return TRUE; } return FALSE; }
    // uncomment this after Base::ComChangePathExtension is merged with Base::Win32ChangePathExtension
    //HRESULT ComChangePathExtension(PCWSTR s, SIZE_T cchIn, EIfNoExtension e) { SIZE_T cch; HRESULT hr; if (SUCCEEDED(hr = Base::ComChangePathExtension(s, cchIn, &cch, e))) { m_cch = cch; hr = NOERROR; } return hr; }

    //
    //  Win32 helpers
    //

    inline HINSTANCE Win32LoadLibrary() const { return ::LoadLibrary(*this); }
    inline HINSTANCE Win32LoadLibraryEx(HANDLE hFile, DWORD dwFlags) const { ASSERT(hFile == NULL); return ::LoadLibraryEx(*this, hFile, dwFlags); }

    inline BOOL Win32GetFileSize(ULARGE_INTEGER &ruli) const;

    inline BOOL Win32CopyFileTo(const CString &r, BOOL fFailIfDestinationExists) const { return ::CopyFile(*this, r, fFailIfDestinationExists); }
    inline BOOL Win32CopyFileFrom(const CString &r, BOOL fFailIfDestinationExists) const { return ::CopyFile(r, *this, fFailIfDestinationExists); }

    inline BOOL Win32CopyFileTo(PCWSTR s, BOOL fFailIfDestinationExists) const;
    inline BOOL Win32CopyFileFrom(PCWSTR s, BOOL fFailIfDestinationExists) const;

    inline BOOL Win32CopyFileTo(PCSTR s, BOOL fFailIfDestinationExists) const;
    inline BOOL Win32CopyFileFrom(PCSTR s, BOOL fFailIfDestinationExists) const;

    inline BOOL Win32MoveFileExTo(const CString &r, DWORD dwFlags) const { return ::MoveFileEx(*this, r, dwFlags); }
    inline BOOL Win32MoveFileExFrom(const CString &r, DWORD dwFlags) const { return ::MoveFileEx(r, *this, dwFlags); }

    inline BOOL Win32MoveFileExTo(PCWSTR s, DWORD dwFlags) const;
    inline BOOL Win32MoveFileExFrom(PCWSTR s, DWORD dwFlags) const;

    inline BOOL Win32MoveFileExTo(PCSTR s, DWORD dwFlags) const;
    inline BOOL Win32MoveFileExFrom(PCSTR s, DWORD dwFlags) const;

    inline BOOL Win32CreateDirectory(LPSECURITY_ATTRIBUTES lpSecurityAttributes) const { return ::CreateDirectory(*this, lpSecurityAttributes); }

protected:
    SIZE_T m_cch; // this is the real live number of characters in the buffer prior to the trailing NULL.

    operator TConstantString() const { return Base::operator TConstantString(); }

private:
    // Intentionally not implemented:
    CString(const CString &r);
    void operator =(const CString &r);
};

class CReadOnlyStringAccessor
{
public:
    typedef CString::TChar TChar;
    typedef CString::TConstantString TConstantString;

    CReadOnlyStringAccessor(const CString &rstr) : m_rstr(rstr) { }

    operator TConstantString() const { return static_cast<TConstantString>(m_rstr); }
    void GetParts(TConstantString &rpsz, SIZE_T &rcch) const { rpsz = static_cast<TConstantString>(m_rstr); rcch = m_rstr.m_cch; }
    SIZE_T Cch() const { return m_rstr.Cch(); }

protected:
    const CString &m_rstr;
};

#include "stringclass.inl"

#endif // defined(_FUSION_INC_STRINGCLASS_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\stringclass.inl ===
#if !defined(_FUSION_INC_STRINGCLASS_INL_INCLUDED_)
#define _FUSION_INC_STRINGCLASS_INL_INCLUDED_

#pragma once

inline
BOOL
CString::Win32FormatFileTime(
    const FILETIME &rft
    )
{
    BOOL fSuccess = FALSE;

    if ((rft.dwLowDateTime == 0) && (rft.dwHighDateTime == 0))
        IFW32FALSE_EXIT(this->Win32Assign(L"n/a"));
    else
    {
        SYSTEMTIME st;
        int iResult;
        int cchDate = 0;
        int cchTime = 0;

        IFW32FALSE_EXIT(::FileTimeToSystemTime(&rft, &st));

        iResult = ::GetDateFormatW(
                            LOCALE_USER_DEFAULT,
                            LOCALE_USE_CP_ACP,
                            &st,
                            NULL,
                            NULL,
                            0);
        if (iResult == 0)
            goto Exit;

        cchDate = iResult - 1;

        iResult = ::GetTimeFormatW(
                            LOCALE_USER_DEFAULT,
                            LOCALE_USE_CP_ACP,
                            &st,
                            NULL,
                            NULL,
                            0);
        if (iResult == 0)
            goto Exit;

        cchTime = iResult - 1;

        IFW32FALSE_EXIT(this->Win32ResizeBuffer(cchDate + 1 + cchTime + 1, eDoNotPreserveBufferContents));

        iResult = ::GetDateFormatW(
                            LOCALE_USER_DEFAULT,
                            LOCALE_USE_CP_ACP,
                            &st,
                            NULL,
                            this->GetBufferPtr(),
                            cchDate + 1);
        if (iResult == 0)
            goto Exit;

        ASSERT(iResult == (cchDate + 1));

        this->GetBufferPtr()[cchDate] = L' ';

        iResult = ::GetTimeFormatW(
                        LOCALE_USER_DEFAULT,
                        LOCALE_USE_CP_ACP,
                        &st,
                        NULL,
                        this->GetBufferPtr() + cchDate + 1,
                        cchTime + 1);
        if (iResult == 0)
            goto Exit;

        ASSERT(iResult == (cchTime + 1));

        m_cch = (cchDate + 1 + cchTime);
    }

Exit:
    return fSuccess;
}

inline
BOOL
CString::Win32GetFileSize(
    ULARGE_INTEGER &ruli
    ) const
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    WIN32_FILE_ATTRIBUTE_DATA wfad;

    IFW32FALSE_EXIT(::GetFileAttributesExW(*this, GetFileExInfoStandard, &wfad));

    ruli.LowPart = wfad.nFileSizeLow;
    ruli.HighPart = wfad.nFileSizeHigh;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

inline
BOOL
CString::Win32CopyIntoBuffer(
    PWSTR *ppszCursor,
    SIZE_T cbBuffer,
    SIZE_T *cbBytesWritten,
    PVOID pvBase,
    ULONG *pulOffset,
    ULONG *pulLength
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PWSTR pszCursor;
    SSIZE_T dptr;
    SIZE_T cbRequired;

    if (pulOffset != NULL)
        *pulOffset = 0;

    if (pulLength != NULL)
        *pulLength = 0;

    PARAMETER_CHECK(ppszCursor != NULL);

    pszCursor = *ppszCursor;
    dptr = ((SSIZE_T) pszCursor) - ((SSIZE_T) pvBase);

    // If they're asking for an offset or length and the cursor is too far from the base,
    // fail.
    PARAMETER_CHECK((pulOffset == NULL) || (dptr <= ULONG_MAX));

    cbRequired = (m_cch != 0) ? ((m_cch + 1) * sizeof(WCHAR)) : 0;

    if (cbBuffer < cbRequired)
    {
        ::SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    if (cbRequired > ULONG_MAX)
    {
        ::SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    memcpy(pszCursor, static_cast<PCWSTR>(*this), cbRequired);

    if (pulOffset != NULL)
    {
        if (cbRequired != 0)
            *pulOffset = (ULONG) dptr;
    }

    if (pulLength != NULL)
        *pulLength = (ULONG) cbRequired;

    *cbBytesWritten += cbRequired;
    *ppszCursor = (PWSTR) (((ULONG_PTR) pszCursor) + cbRequired);

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\stringpool.h ===
#if !defined(_FUSION_INC_STRINGPOOL_H_INCLUDED_)
#define _FUSION_INC_STRINGPOOL_H_INCLUDED_

#pragma once

#include <windows.h>
#include "debmacro.h"
#include "fusiondeque.h"
#include "fusionbuffer.h"
#include "util.h"
#include "sxsapi.h"

//
//  Design notes:
//
//  This string pool class is intended to manage an un-reference-counted
//  pool of strings.  Adding something to the pool leaves it there until
//  the pool is destroyed; this makes it useful for things like syntax
//  trees where many of the elements will have duplicate strings, but
//  you would never want to actually keep one of these around for the
//  lifetime of the process or DLL.
//

class CStringPool;
class CStringPoolEntry;
class CStringPoolEntryClump;
class CStringPoolHeap;
class CStringPoolHeapSegment;

class CStringPoolHeapSegment
{
public:
    CStringPoolHeapSegment() : m_cchUsed(0) { }
    ~CStringPoolHeapSegment() { }

    BOOL Initialize();
    BOOL Initialize(const WCHAR *StringIn, ULONG  Cch, const WCHAR *&rpStringOut);
    BOOL TryAllocString(const WCHAR *StringIn, ULONG Cch, const WCHAR *&rpStringOut);

    inline static ULONG CchMax() { return 4096; }

    CDequeLinkage m_leLinks;
    WCHAR m_rgchBuffer[4096];
    ULONG m_cchUsed;
};

class CStringPoolSingletonString
{
public:
    CStringPoolSingletonString() : m_prgwch(NULL) { }
    ~CStringPoolSingletonString() { if (m_prgwch != NULL) { FUSION_DELETE_ARRAY(m_prgwch); m_prgwch = NULL; } }

    BOOL Initialize(const WCHAR *StringIn, ULONG Cch, const WCHAR *&rpStringOut);

    WCHAR *m_prgwch;
    CDequeLinkage m_leLinks;
};

class CStringPoolHeap
{
public:
    CStringPoolHeap() { }
    ~CStringPoolHeap()
    {
        CSxsPreserveLastError ple;
        m_dequeSegments.Clear<CStringPoolHeap>(this, CStringPoolHeap::ClearSegment);
        m_dequeSingletons.Clear<CStringPoolHeap>(this, CStringPoolHeap::ClearSingleton);
        ple.Restore();
    }

    BOOL Initialize();
    BOOL DupString(const WCHAR *StringIn, ULONG Cch, const WCHAR *&rpStringOut);

    VOID ClearSegment(CStringPoolHeapSegment *p) const { FUSION_DELETE_SINGLETON(p); }
    VOID ClearSingleton(CStringPoolSingletonString *p) const { FUSION_DELETE_SINGLETON(p); }

    CDeque<CStringPoolHeapSegment, FIELD_OFFSET(CStringPoolHeapSegment, m_leLinks)> m_dequeSegments;
    CDeque<CStringPoolSingletonString, FIELD_OFFSET(CStringPoolSingletonString, m_leLinks)> m_dequeSingletons;

private:
    CStringPoolHeap(const CStringPoolHeap &r); // intentionally not implemented
    void operator =(const CStringPoolHeap &r); // intentionally not implemented
};

class CStringPoolEntry : public _SXS_XML_STRING
{
    friend CStringPoolEntryClump;

public:
    CStringPoolEntry()
    {
        // Initialize members in base type...
        this->Flags = 0;
        this->PseudoKey = 0;
        this->Length = 0;
        this->Buffer = NULL;
    }
    ~CStringPoolEntry() { }

    BOOL Initialize(const WCHAR *StringIn, ULONG CchIn, ULONG ulPsuedoKey, CStringPoolHeap &rStringPoolHeap);
};

class CStringPoolEntryClump
{
    friend CStringPool;

public:
    CStringPoolEntryClump() : m_prgEntries(NULL), m_cEntriesAllocated(0), m_cEntriesUsed(0) { }
    ~CStringPoolEntryClump();

    BOOL Initialize(ULONG cEntriesToAllocate = 32);

    enum FindOrAddDisposition
    {
        eInvalid,
        eFound,
        eAdded,
        eNoRoom
    };

    BOOL FindOrAddEntry(
        const WCHAR *StringIn,
        ULONG CchIn,
        ULONG ulPseudoKey,
        CStringPoolHeap &rStringHeap,
        ULONG &rulPosition,
        FindOrAddDisposition &rdisposition,
        const CStringPoolEntry *&rpEntry
        );

    ULONG EntriesAllocate() const { return m_cEntriesAllocated; }
    ULONG EntriesUsed() const { return m_cEntriesUsed; }

    BOOL FillInStringArray(ULONG nArraySize, SXS_XML_STRING *prgStrings, ULONG iCurrent, ULONG &rcWritten);

//protected:
    CStringPoolEntry *m_prgEntries;
    ULONG m_cEntriesAllocated;
    ULONG m_cEntriesUsed;
    CDequeLinkage m_leEntryChain;
};

class CStringPool
{
public:
    CStringPool() : m_fInitialized(false), m_cEntries(0) { }
    ~CStringPool();

    BOOL Initialize();

    BOOL Canonicalize(
        const WCHAR *StringIn,
        ULONG CchIn,
        ULONG ulPseudoKey,
        ULONG &rulPosition,
        const WCHAR *&rStringOut
        );

    BOOL GetEntryCount() const { return m_cEntries; }
    BOOL FillInStringArray(ULONG nArraySize, SXS_XML_STRING *prgStrings, ULONG &rcWritten);

protected:
    bool m_fInitialized;
    ULONG m_cEntries;

    VOID ClearDequeEntry(CStringPoolEntryClump *p) const { FUSION_DELETE_SINGLETON(p); }

    CStringPoolHeap m_StringHeap;
    CDeque<CStringPoolEntryClump, FIELD_OFFSET(CStringPoolEntryClump, m_leEntryChain)> m_dequeEntryClumps;

private:
    CStringPool(const CStringPool &); // intentionally not implemented
    void operator =(const CStringPool &r); // intentionally not implemented
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\sxspath.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    SxsPath.h

Abstract:

Author:

    Jay Krell (a-JayK) October 2000

Revision History:

--*/

#pragma once

/*-----------------------------------------------------------------------------
 \\machine\share -> \\?\unc\machine\share
 c:\foo -> \\?\c:\foo
 \\? -> \\?
 a\b\c -> \\?\c:\windows\a\b\c current-working-directory is c:\windows (can never be unc)
-----------------------------------------------------------------------------*/
BOOL
FusionpConvertToBigPath(PCWSTR Path, SIZE_T BufferSize, PWSTR Buffer);

#define MAXIMUM_BIG_PATH_GROWTH_CCH (NUMBER_OF(L"\\\\?\\unc\\"))

/*-----------------------------------------------------------------------------
 \\?\unc\machine\share\bob
 \\?\c:\foo\bar        ^
--------^---------------------------------------------------------------------*/
BOOL
FusionpSkipBigPathRoot(PCWSTR s, OUT SIZE_T*);

/*-----------------------------------------------------------------------------
'\\' or '/'
-----------------------------------------------------------------------------*/
BOOL
FusionpIsSlash(
    WCHAR ch
    );

/*-----------------------------------------------------------------------------
just the 52 chars a-zA-Z, need to check with fs
-----------------------------------------------------------------------------*/
BOOL
FusionpIsDriveLetter(
    WCHAR ch
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

BOOL
SxspIsUncPath(
    PCWSTR Path,
    BOOL*
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

//
// This is not reliable.
//
// Nt Paths can look like absolute DOS/Win32 paths without the leading drive letter:
//   \foo\bar -> c:\foo\bar
//
// But we are not likely to get Nt paths that don't start with a double question mark:
//   \??\c:\foo\bar.
//
// (For example, on NT 3.x create a directory named \DosDevices, which is what \?? used to be
// named..)
//
BOOL
SxspIsNtPath(
    PCWSTR Path,
    BOOL*
    );

/*-----------------------------------------------------------------------------
//
//
// The acceptable forms are
//
// Win32 \\machine\share
// Win32 c:\foo
// NT \??\c:\foo
// NT \??\unc\machine\share
// Win32 \\?\c:\foo
// Win32 \\?\unc\machine\share
//
// Anything with a colon is ambiguous. The colon could mean an NTFS alternate stream.
// We never take that interpretation.
//
// The non fullpath \foo\bar is ambiguous. It could be an NT path.
//
// We are only checking for NT paths currently to assert that we don't get them.
// We used to get them.
//
//
-----------------------------------------------------------------------------*/

BOOL
SxspIsFullWin32OrNtPath(
    PCWSTR Path,
    BOOL*  Result
    );

//
//
//#define PATH_IS_REMOTE     (0x00001)
//#define PATH_IS_LOCAL      (0x00002)
//#define PATH_IS_WIN32      (0x00004)
//#define PATH_IS_WIN32_LONG (0x00008) /* starts \\?\ */
//#define PATH_IS_NT         (0x00010)
//#define PATH_IS_FULL       (0x00020)
//#define PATH_HAS_AMBIGUOUS_DRIVE_COLON_OR_NTFS_COLON (0x00040)
//#define PATH_IS_AMBIGUOUS_WIN32_OR_NT (0x00080) /* does not start with one of c:\ or \?? or \\ */
//
//BOOL
//SxspAnalyzePath(
//    PCWSTR  Path,
//    PCWSTR* LastElement,
//    ULONG*  PathCharacteristics
//    );
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\sxsexceptionhandling.h ===
#if !defined(_FUSION_INC_SXSEXCEPTIONHANDLING_H_INCLUDED_)
#define _FUSION_INC_SXSEXCEPTIONHANDLING_H_INCLUDED_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    SxsExceptionHandling.h

Abstract:

Author:

    Jay Krell (a-JayK) October 2000

Revision History:

--*/
#pragma once

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "fusionlastwin32error.h"
#include "fusionntdll.h"
#include "fusiontrace.h"
#include "csxspreservelasterror.h" // Most destructors should use this.
#include "fusionheap.h"

/*-----------------------------------------------------------------------------
Instead of:
    __except(EXECEPTION_EXECUTE_HANDLER)
say:
    __except(SXSP_EXCEPTION_FILTER())

This way all exceptions will be logged with DbgPrint,
and probably hit a breakpoint if under a debugger, and any other behavior we
want.

If your exception filter is other than (EXECEPTION_EXECUTE_HANDLER), then
you are on your own.
-----------------------------------------------------------------------------*/

INT
SxspExceptionFilter(
    PEXCEPTION_POINTERS ExceptionPointers,
    PCSTR Function
    );

#define SXSP_EXCEPTION_FILTER() (::SxspExceptionFilter(GetExceptionInformation(), __FUNCTION__))

#define SXS_REPORT_SEH_EXCEPTION(string) \
    __try \
    { \
        if (::FusionpReportConditionAndBreak(NULL, "SXS.DLL: " __FUNCTION__ " - Unhandled exception caught: 0x%08lx", GetExceptionCode())) \
            FUSION_DEBUG_BREAK(); \
    } \
    __except(EXCEPTION_EXECUTE_HANDLER) { }

class CCriticalSectionNoConstructor : public CRITICAL_SECTION
{
    void operator=(const CCriticalSectionNoConstructor&); // deliberately not implemented
    //CCriticalSectionNoConstructor(const CCriticalSectionNoConstructor&); // deliberately not implemented
public:
	BOOL Construct();
	BOOL ConstructWithSEH(PCSTR Function = "");
	BOOL Destruct();
};

inline BOOL
CCriticalSectionNoConstructor::Construct()
{
    ::InitializeCriticalSection(this);
	return TRUE;
}

inline BOOL
CCriticalSectionNoConstructor::Destruct()
{
    ::DeleteCriticalSection(this);
	return TRUE;
}

inline BOOL
CCriticalSectionNoConstructor::ConstructWithSEH(
    PCSTR /* Function */)
{
    BOOL Result = FALSE;
    DWORD dwWin32Error;

    __try
    {
        if (!this->Construct())
            goto Exit;
    }
    __except(SXSP_EXCEPTION_FILTER())
    {
        SXS_REPORT_SEH_EXCEPTION("");
#if FUSION_STATIC_NTDLL
        dwWin32Error = ::RtlNtStatusToDosErrorNoTeb(GetExceptionCode());
#else
        dwWin32Error = ERROR_OUTOFMEMORY;
#endif
        ::FusionpSetLastWin32Error(dwWin32Error);
        goto Exit;
    }

    Result = TRUE;
Exit:
    return Result;
}

class CSxsLockCriticalSection
{
public:
    CSxsLockCriticalSection(CRITICAL_SECTION &rcs) : m_rcs(rcs), m_fIsLocked(false) { }
    BOOL Lock();
    BOOL TryLock();
    BOOL LockWithSEH();
    ~CSxsLockCriticalSection() { if (m_fIsLocked) { CSxsPreserveLastError ple; ::LeaveCriticalSection(&m_rcs); ple.Restore(); } }
    BOOL Unlock();

protected:
    CRITICAL_SECTION &m_rcs;
    bool m_fIsLocked;

private:
    void operator=(const CSxsLockCriticalSection&);
    CSxsLockCriticalSection(const CSxsLockCriticalSection&);
};

inline
BOOL
CSxsLockCriticalSection::Lock()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    INTERNAL_ERROR_CHECK(!m_fIsLocked);
    ::EnterCriticalSection(&m_rcs);
    m_fIsLocked = true;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

inline
BOOL
CSxsLockCriticalSection::LockWithSEH()
{
    BOOL fSuccess = FALSE;
    DWORD dwWin32Error;

    // We can't use the spiffy macros in the same frame as a __try block.
    ASSERT_NTC(!m_fIsLocked);
    if (m_fIsLocked)
    {
        ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
        goto Exit;
    }

    __try
    {
        if (!this->Lock())
            goto Exit;
        m_fIsLocked = true;
    }
    __except(SXSP_EXCEPTION_FILTER())
    {
        SXS_REPORT_SEH_EXCEPTION("");
#if FUSION_STATIC_NTDLL
        dwWin32Error = ::RtlNtStatusToDosErrorNoTeb(GetExceptionCode());
#else
        dwWin32Error = ERROR_OUTOFMEMORY;
#endif
        ::FusionpSetLastWin32Error(dwWin32Error);
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

inline
BOOL
CSxsLockCriticalSection::TryLock()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    IFW32FALSE_ORIGINATE_AND_EXIT(::TryEnterCriticalSection(&m_rcs));
    m_fIsLocked = true;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

inline
BOOL
CSxsLockCriticalSection::Unlock()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    INTERNAL_ERROR_CHECK(m_fIsLocked);
    ::LeaveCriticalSection(&m_rcs);
    m_fIsLocked = false;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

#endif // !defined(_FUSION_INC_SXSEXCEPTIONHANDLING_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\sxsid.h ===
#if !defined(_FUSION_INC_SXSID_H_INCLUDED_)
#define _FUSION_INC_SXSID_H_INCLUDED_

#pragma once

#include <windows.h>
#include <setupapi.h>
#include <sxsapi.h>
#include <stdlib.h>
#include <search.h>

typedef struct _SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE
{
    const WCHAR *Namespace;
    SIZE_T NamespaceCch;
    const WCHAR *Name;
    SIZE_T NameCch;
} SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE, *PSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE;

typedef const SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE *PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE;

#define SXS_DEFINE_ATTRIBUTE_REFERENCE_EX(_id, _ns, _n) EXTERN_C __declspec(selectany) const SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE _id = { _ns, (sizeof(_ns) / sizeof(_ns[0])) - 1, _n, (sizeof(_n) / sizeof(_n[0])) - 1 };
#define SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(_id, _n) EXTERN_C __declspec(selectany) const SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE _id = { NULL, 0, _n, (sizeof(_n) / sizeof(_n[0])) - 1 };

SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_name, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_type, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_version, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_processorArchitecture, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_publicKey, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_publicKeyToken, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_language, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE)

#define ASSEMBLY_TYPE_POLICY                                    (L"policy")
#define ASSEMBLY_TYPE_POLICY_CCH                                (NUMBER_OF(ASSEMBLY_TYPE_POLICY) - 1)
#define ASSEMBLY_TYPE_POLICY_SUFFIX                             (L"-policy")
#define ASSEMBLY_TYPE_POLICY_SUFFIX_CCH                         (NUMBER_OF(ASSEMBLY_TYPE_POLICY_SUFFIX) - 1)

//
//  This header defines the "semi-public" assembly identity functions.
//
//  The public ones are in sxsapi.h; these are not private to the identity
//  implementation directly but are private to sxs.dll.
//

BOOL
SxsIsAssemblyIdentityAttributePresent(
    DWORD Flags,
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    BOOL *pfFound
    );

#define SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING (0x00000001)

BOOL
SxspSetAssemblyIdentityAttributeValue(
    DWORD Flags,
    struct _ASSEMBLY_IDENTITY* pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    PCWSTR pszValue,
    SIZE_T cchValue
    );

BOOL
SxspSetAssemblyIdentityAttributeValue(
    DWORD Flags,
    struct _ASSEMBLY_IDENTITY* pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    const CBaseStringBuffer &Value
    );

#define SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS (0x00000001)

BOOL
SxspRemoveAssemblyIdentityAttribute(
    DWORD Flags,
    struct _ASSEMBLY_IDENTITY* pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference
    );

#define SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL (0x00000001)

BOOL
SxspGetAssemblyIdentityAttributeValue(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    OUT PCWSTR *ValuePointer,
    OUT SIZE_T *ValueCch
    );

BOOL
SxspGetAssemblyIdentityAttributeValue(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    OUT CBaseStringBuffer &Value
    );

VOID
SxspDbgPrintAssemblyIdentity(
    DWORD dwflags,
    PCASSEMBLY_IDENTITY pAssemblyIdentity
    );

#define SXSP_MAP_ASSEMBLY_IDENTITY_TO_POLICY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION (0x00000001)

BOOL
SxspMapAssemblyIdentityToPolicyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT PASSEMBLY_IDENTITY &PolicyIdentity
    );

#define SXSP_GENERATE_TEXTUALLY_ENCODED_POLICY_IDENTITY_FROM_ASSEMBLY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION (0x00000001)

BOOL
SxspGenerateTextuallyEncodedPolicyIdentityFromAssemblyIdentity(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    CBaseStringBuffer &rbuffEncodedIdentity,
    PASSEMBLY_IDENTITY *PolicyIdentity OPTIONAL
    );

BOOL
SxspHashAssemblyIdentityForPolicy(
    IN DWORD dwFlags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT ULONG & IdentityHash);


BOOL
SxspDoesStringIndicatePolicy(
    SIZE_T cchString,
    PCWSTR pcwsz,
    BOOL &fIsPolicy
    );

BOOL
SxspDetermineAssemblyType(
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    BOOL &fIsPolicyAssembly
    );



#endif // !defined(_FUSION_INC_SXSID_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\tablesizer.h ===
#if !defined(_FUSION_INC_TABLESIZER_H_INCLUDED_)
#define _FUSION_INC_TABLESIZER_H_INCLUDED_

#pragma once

//
//  This class is used to sample a set of pseudokeys and make
//  a recommendation about the size of an optimal hash table
//  for the data set.
//

class CHashTableSizer
{
public:
    CHashTableSizer();
    ~CHashTableSizer();

    BOOL Initialize(SIZE_T cElements);
    VOID AddSample(ULONG ulPseudokey);
    BOOL ComputeOptimalTableSize(DWORD dwFlags, SIZE_T &rnTableSize);

protected:
    SIZE_T m_cPseudokeys;
    SIZE_T m_nHistogramTableSize;
    SIZE_T m_iCurrentPseudokey;

    ULONG *m_prgPseudokeys;
    SIZE_T *m_prgHistogramTable;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\xmlns.h ===
#if !defined(_FUSION_INC_XMLNS_H_INCLUDED_)
#define _FUSION_INC_XMLNS_H_INCLUDED_

#pragma once

#include <ole2.h>
#include <xmlparser.h>
#include "fusionhash.h"
#include "fusionheap.h"
#include "fusionchartraits.h"
#include "smartptr.h"

class CXMLNamespaceManager
{
public:
    CXMLNamespaceManager();
    ~CXMLNamespaceManager();

    BOOL Initialize();

    // To get things to track, call these functions in your IXMLNodeFactory before your own processing.
    HRESULT OnCreateNode(IXMLNodeSource *pSource, PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO **apNodeInfo);
    HRESULT OnBeginChildren(IXMLNodeSource *pSource, XML_NODE_INFO *pNodeInfo);
    HRESULT OnEndChildren(IXMLNodeSource *pSource, BOOL fEmpty, XML_NODE_INFO *pNodeInfo);

    enum MapFlags
    {
        eMapFlag_DoNotApplyDefaultNamespace = 0x00000001,
    };

    HRESULT Map(
        DWORD dwMapFlags,
        const XML_NODE_INFO *pNodeInfo,
        CBaseStringBuffer *pbuffNamespace,
        SIZE_T *pcchNamespacePrefix
        );

    class CNamespacePrefix
    {
    public:
        CNamespacePrefix();
        ~CNamespacePrefix();

        CNamespacePrefix *m_Previous;
        CSmallStringBuffer m_NamespaceURI;
        ULONG m_Depth;

        SMARTTYPEDEF(CNamespacePrefix);

    private:
        CNamespacePrefix(const CNamespacePrefix &);
        void operator =(const CNamespacePrefix &);
    };

protected:
    BOOL InsertOrUpdateIfCallback(
        CNamespacePrefix *pPrefixNew,
        CNamespacePrefix * const &rpPrefixCurrent,
        InsertOrUpdateIfDisposition &Disposition
        );

    CStringPtrTable<CNamespacePrefix, CUnicodeCharTraits> m_NamespacePrefixes;
    ULONG m_CurrentDepth;
    CNamespacePrefix *m_DefaultNamespacePrefix;

private:
    CXMLNamespaceManager(const CXMLNamespaceManager &r);
    void operator =(const CXMLNamespaceManager &r);

};

SMARTTYPE(CXMLNamespaceManager::CNamespacePrefix);

#endif // !defined(_FUSION_INC_XMLNS_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\installer.inc ===
#
# Set private include paths
#


#INSTALLER_PATH        = e:\nt\base\win32\fusion\installer
#INSTALLER_INCLUDE_PATH = e:\nt\base\win32\fusion\installer\includes
#IDL_GENERATED_HEADERS = e:\nt\base\win32\fusion\installer\idl\obj\i386

INSTALLER_PATH         = $(PROJECT_ROOT)\win32\fusion\installer
IDL_GENERATED_HEADERS  = $(INSTALLER_PATH)\idl\obj\i386

INSTALLER_INCLUDE_PATH = $(INSTALLER_PATH)\includes;\
			 $(IDL_GENERATED_HEADERS)

INSTALLER_LIB_DEST     = $(INSTALLER_PATH)\libs\$(_OBJ_DIR)
INSTALLER_LIB_PATH     = $(INSTALLER_LIB_DEST)\*

INCLUDES        = \
    $(WINDOWS_INC_PATH);\
    $(BASE_INC_PATH);\
    $(SDK_INC_PATH);\
    $(NET_INC_PATH);\
    $(INSTALLER_INCLUDE_PATH);\
    $(IDL_GENERATED_HEADERS);\
    $(INCLUDES)



USE_RTTI=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\cache\assemblycache.cpp ===
#include <fusenetincludes.h>
#include <assemblycache.h>
#include "..\id\sxsid.h"

#define WZ_CACHE_LOCALROOTDIR    L"Application Store\\"
#define WZ_MANIFEST_STAGING_DIR   L"ManifestStagingDir\\"
#define WZ_WILDCARDSTRING L"*"

extern BOOL IsEqualAssemblyFileInfo(LPASSEMBLY_FILE_INFO pAsmFileInfo1, LPASSEMBLY_FILE_INFO pAsmFileInfo2);

// ---------------------------------------------------------------------------
// CreateAssemblyCacheImport
// ---------------------------------------------------------------------------
STDAPI
CreateAssemblyCacheImport(
    LPASSEMBLY_CACHE_IMPORT *ppAssemblyCacheImport,
    LPASSEMBLY_IDENTITY       pAssemblyIdentity,
    DWORD                    dwFlags)
{
    HRESULT hr = S_OK;
    LPWSTR pwzSearchDisplayName = NULL;
    BOOL bNewAsmId = FALSE;
        
    CAssemblyCache *pAssemblyCache = NULL;

    pAssemblyCache = new(CAssemblyCache);
    if (!pAssemblyCache)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (FAILED(hr = pAssemblyCache->Init(NULL)))
        goto exit;

    if (dwFlags == CACHEIMP_CREATE_RETRIEVE_MAX_COMPLETED
        || dwFlags == CACHEIMP_CREATE_RETRIEVE_EXIST
        || dwFlags == CACHEIMP_CREATE_RESOLVE_REF
        || dwFlags == CACHEIMP_CREATE_RESOLVE_REF_EX
        || dwFlags == CACHEIMP_CREATE_RETRIEVE_EXIST_COMPLETED)
    {
        LPWSTR pwzBuf = NULL;
        DWORD dwCC = 0;
        CString sManifestFilename;
        CString sDisplayName;

        if (pAssemblyIdentity == NULL)
        {
            hr = E_INVALIDARG;
            goto exit;
        }

        // get the identity name
        if ((hr = pAssemblyIdentity->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME,
            &pwzBuf, &dwCC)) != S_OK)
        {
            // BUGBUG?: should this work regardless the existence of asm name?
            hr = E_INVALIDARG;
            goto exit;
        }

        // filename of the manifest must be the same as the assembly name
        // BUGBUG??: this implies manifest filename (and asm name) be remained unchange because
        // the assembly name from the new AsmId is used for looking up in the older cached version...
        sManifestFilename.TakeOwnership(pwzBuf, dwCC);
        if (FAILED(hr = sManifestFilename.Append(L".manifest")))
            goto exit;

        if (dwFlags == CACHEIMP_CREATE_RETRIEVE_MAX_COMPLETED)
        {
            LPASSEMBLY_IDENTITY pNewAsmId = NULL;
            
            if (FAILED(hr = CloneAssemblyIdentity(pAssemblyIdentity, &pNewAsmId)))
                goto exit;

            pAssemblyIdentity = pNewAsmId;
            bNewAsmId = TRUE;
            
            // force Version to be a wildcard
            if (FAILED(hr = pAssemblyIdentity->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION,
                        WZ_WILDCARDSTRING, lstrlen(WZ_WILDCARDSTRING)+1)))
                goto exit;
        }

        if (dwFlags == CACHEIMP_CREATE_RETRIEVE_MAX_COMPLETED
            || dwFlags == CACHEIMP_CREATE_RESOLVE_REF
            || dwFlags == CACHEIMP_CREATE_RESOLVE_REF_EX)
        {
            // issues: what if other then Version is already wildcarded? does version comparison make sense here?
            if (FAILED(hr = pAssemblyIdentity->GetDisplayName(ASMID_DISPLAYNAME_WILDCARDED,
                    &pwzSearchDisplayName, &dwCC)))
                goto exit;

            if (SearchForHighestVersionInCache(&pwzBuf, pwzSearchDisplayName, CAssemblyCache::COMPLETED, pAssemblyCache) == S_OK)
            {
                sDisplayName.TakeOwnership(pwzBuf);
                // BUGBUG - make GetDisplayName call getassemblyid/getdisplayname instead
                if (FAILED(hr = (pAssemblyCache->_sDisplayName).Assign(sDisplayName)))
                    goto exit;
            }    
            else
            {
                // can't resolve
                hr = S_FALSE;

                if (dwFlags != CACHEIMP_CREATE_RESOLVE_REF_EX)
                    goto exit;
            }
        }

        if (dwFlags == CACHEIMP_CREATE_RETRIEVE_EXIST
            || dwFlags ==  CACHEIMP_CREATE_RETRIEVE_EXIST_COMPLETED
            || (hr == S_FALSE && dwFlags == CACHEIMP_CREATE_RESOLVE_REF_EX))
        {
            // make the name anyway if resolving a ref that does not have any completed cache counterpart
            // BUGBUG: this may no longer be necessary if shortcut code/UI changes - it's expecting a path
            //          plus this is inefficient as it searchs the disk at above, even if ref is fully qualified
            
            if (FAILED(hr = pAssemblyIdentity->GetDisplayName(ASMID_DISPLAYNAME_NOMANGLING, &pwzBuf, &dwCC)))
                goto exit;
            
            hr = sDisplayName.TakeOwnership(pwzBuf, dwCC);

            // BUGBUG - make GetDisplayName call getassemblyid/getdisplayname instead
            if (FAILED(hr = (pAssemblyCache->_sDisplayName).Assign(sDisplayName)))
                goto exit;
            
        }
            
        // Note: this will prepare for delay initializing _pManifestImport
        
        if (FAILED(hr = (pAssemblyCache->_sManifestFileDir).Assign(pAssemblyCache->_sRootDir)))
            goto exit;

        // build paths
        if (FAILED(hr = (pAssemblyCache->_sManifestFileDir).Append(sDisplayName)))
            goto exit;

        if (dwFlags == CACHEIMP_CREATE_RETRIEVE_EXIST ||dwFlags ==  CACHEIMP_CREATE_RETRIEVE_EXIST_COMPLETED)
        {
            // simple check if dir is in cache or not
            if (GetFileAttributes((pAssemblyCache->_sManifestFileDir)._pwz) == (DWORD)-1)
            {
                // cache dir not exists
                hr = S_FALSE;
                goto exit;
            }
        }

        if (dwFlags ==  CACHEIMP_CREATE_RETRIEVE_EXIST_COMPLETED)
        {
            if (!(pAssemblyCache ->IsStatus (sDisplayName._pwz, CAssemblyCache::COMPLETED)))
            {
                // cache dir not completed
                hr = S_FALSE;
                goto exit;
            }
        }

        if (FAILED(hr = (pAssemblyCache->_sManifestFileDir).Append(L"\\")))
            goto exit;

        if (FAILED(hr = (pAssemblyCache->_sManifestFilePath).Assign(pAssemblyCache->_sManifestFileDir)))
            goto exit;

        if (FAILED(hr = (pAssemblyCache->_sManifestFilePath).Append(sManifestFilename)))
            goto exit;
    }
    
exit:
    SAFEDELETE(pwzSearchDisplayName);

    if (bNewAsmId)
        SAFERELEASE(pAssemblyIdentity);
        
    if (FAILED(hr) || hr == S_FALSE)
    {
        // hr == S_FALSE for not found
        SAFERELEASE(pAssemblyCache);
    }

    *ppAssemblyCacheImport = static_cast<IAssemblyCacheImport*> (pAssemblyCache);

    return hr;
}


// ---------------------------------------------------------------------------
// CreateAssemblyCacheEmit
// ---------------------------------------------------------------------------
STDAPI
CreateAssemblyCacheEmit(
    LPASSEMBLY_CACHE_EMIT *ppAssemblyCacheEmit,
    LPASSEMBLY_CACHE_EMIT  pAssemblyCacheEmit,
    DWORD                  dwFlags)
{
    HRESULT hr = S_OK;

    CAssemblyCache *pAssemblyCache = NULL;

    pAssemblyCache = new(CAssemblyCache);
    if (!pAssemblyCache)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = pAssemblyCache->Init(static_cast<CAssemblyCache*> (pAssemblyCacheEmit));
    if (FAILED(hr))
    {
        SAFERELEASE(pAssemblyCache);
        goto exit;
    }
    
exit:

    *ppAssemblyCacheEmit = static_cast<IAssemblyCacheEmit*> (pAssemblyCache);

    return hr;
}


// ---------------------------------------------------------------------------
// FindVersionInDisplayName
// ---------------------------------------------------------------------------
LPCWSTR
FindVersionInDisplayName(LPCWSTR pwzDisplayName)
{
    int cNumUnderscoreFromEndToVersionString = 2;
    int count = 0;
    int ccLen = lstrlen(pwzDisplayName);
    LPWSTR pwz = (LPWSTR) (pwzDisplayName+ccLen-1);
    LPWSTR pwzRetVal = NULL;

    // return a pointer to the start of Version string inside a displayName
    while (*pwz != NULL && pwz > pwzDisplayName)
    {
        if (*pwz == L'_')
            count++;

        if (count == cNumUnderscoreFromEndToVersionString)
            break;

        pwz--;
    }

    if (count == cNumUnderscoreFromEndToVersionString)
        pwzRetVal = ++pwz;

    return pwzRetVal;
}


// ---------------------------------------------------------------------------
// CompareVersion
// ---------------------------------------------------------------------------
int
CompareVersion(LPCWSTR pwzVersion1, LPCWSTR pwzVersion2)
{
    // BUGBUG: this should compare version by its major minor build revision!
    //  possible break if V1=10.0.0.0 and V2=2.0.0.0?
    //  plus pwzVersion1 is something like "1.0.0.0_en"
    return wcscmp(pwzVersion1, pwzVersion2);
}


// ---------------------------------------------------------------------------
// SearchForHighestVersionInCache
// Look for a copy in cache that has the highest version and the specified status
// pwzSearchDisplayName should really be created from a partial ref
//
// return:  S_OK    - found a version from the ref
//         S_FALSE - not found any version from the ref, or
//                   ref not partial and that version is not there/not in that status
//         E_*
// ---------------------------------------------------------------------------
HRESULT
SearchForHighestVersionInCache(LPWSTR *ppwzResultDisplayName, LPWSTR pwzSearchDisplayName, CAssemblyCache::CacheStatus eCacheStatus, CAssemblyCache* pCache)
{
    HRESULT hr = S_OK;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fdAppDir;
    DWORD dwLastError = 0;
    BOOL fFound = FALSE;

    CString sDisplayName;
    CString sSearchPath;

    *ppwzResultDisplayName = NULL;

    sDisplayName.Assign(pwzSearchDisplayName);
    if (FAILED(hr=sSearchPath.Assign(pCache->_sRootDir)))
        goto exit;

    if (FAILED(hr=sSearchPath.Append(sDisplayName)))
        goto exit;

    hFind = FindFirstFileEx(sSearchPath._pwz, FindExInfoStandard, &fdAppDir, FindExSearchLimitToDirectories, NULL, 0);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = S_FALSE;
        goto exit;
    }

    while (dwLastError != ERROR_NO_MORE_FILES)
    {
        // ???? check file attribute to see if it's a directory? needed only if the file system does not support the filter...
        // ???? check version string format?
        if (pCache->IsStatus(fdAppDir.cFileName, eCacheStatus))
        {
            int iRetVal = CompareVersion(FindVersionInDisplayName(fdAppDir.cFileName), FindVersionInDisplayName(sDisplayName._pwz));
            if (iRetVal > 0)
            {
                sDisplayName.Assign(fdAppDir.cFileName);
                fFound = TRUE;
            } else if (iRetVal == 0)
                fFound = TRUE;
            // else keep the newest
        }

        if (!FindNextFile(hFind, &fdAppDir))
        {
            dwLastError = GetLastError();
            continue;
        }
    }

    if (fFound)
    {
        *ppwzResultDisplayName = sDisplayName._pwz;
        sDisplayName.ReleaseOwnership();
        hr = S_OK;
    }
    else
        hr = S_FALSE;

exit:
    if (hFind != INVALID_HANDLE_VALUE)
    {
        if (!FindClose(hFind))
        {
            // can return 0, even when there's an error.
            DWORD dw = GetLastError();
            hr = dw ? HRESULT_FROM_WIN32(dw) : E_FAIL;
        }
    }

    return hr;
}


// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CAssemblyCache::CAssemblyCache()
    : _dwSig('hcac'), _cRef(1), _hr(S_OK), _pManifestImport(NULL)
{}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CAssemblyCache::~CAssemblyCache()
{    
    SAFERELEASE(_pManifestImport);
}


// ---------------------------------------------------------------------------
// Init
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::Init(CAssemblyCache *pAssemblyCache)
{
    if (!pAssemblyCache)
        GetCacheRootDir(_sRootDir, Base);
    else
        _sRootDir.Assign(pAssemblyCache->_sManifestFileDir);

    return S_OK;
}


// ---------------------------------------------------------------------------
// GetManifestFilePath
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::GetManifestFilePath(LPOLESTR *ppwzManifestFilePath, 
    LPDWORD pccManifestFilePath)
{
    CString sPathOut;
    sPathOut.Assign(_sManifestFilePath);    
    *ppwzManifestFilePath = sPathOut._pwz;
    *pccManifestFilePath = sPathOut._cc;
    sPathOut.ReleaseOwnership();
    return S_OK;
}

// ---------------------------------------------------------------------------
// GetManifestFileDir
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::GetManifestFileDir(LPOLESTR *ppwzManifestFileDir, 
    LPDWORD pccManifestFileDir)
{
    CString sDirOut;
    sDirOut.Assign(_sManifestFileDir);    
    *ppwzManifestFileDir = sDirOut._pwz;
    *pccManifestFileDir = sDirOut._cc;
    sDirOut.ReleaseOwnership();
    return S_OK;
}


// ---------------------------------------------------------------------------
// GetManifestImport
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::GetManifestImport(LPASSEMBLY_MANIFEST_IMPORT *ppManifestImport)
{
    *ppManifestImport = _pManifestImport;
    (*ppManifestImport)->AddRef();
    return S_OK;
}

// ---------------------------------------------------------------------------
// GetDisplayName
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::GetDisplayName(LPOLESTR *ppwzDisplayName, LPDWORD pccDiaplyName)
{
    CString sDisplayNameOut;
    sDisplayNameOut.Assign(_sDisplayName);    
    *ppwzDisplayName = sDisplayNameOut._pwz;
    *pccDiaplyName= sDisplayNameOut._cc;
    sDisplayNameOut.ReleaseOwnership();
    return S_OK;
}


// ---------------------------------------------------------------------------
// FindExistMatching
// return:
//    S_OK
//    S_FALSE -not exist or not match
//    E_*
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::FindExistMatching(LPASSEMBLY_FILE_INFO  pAssemblyFileInfo, LPOLESTR *ppwzPath)
{
    LPWSTR pwzBuf = NULL;
    DWORD ccBuf = 0;
    CString sFileName;
    CString sTargetPath;
    LPASSEMBLY_FILE_INFO pFoundFileInfo = NULL;

    if (pAssemblyFileInfo == NULL || ppwzPath == NULL)
    {
        _hr = E_INVALIDARG;
        goto exit;
    }
    
    *ppwzPath = NULL;

    if (_pManifestImport == NULL)
    {
        if (_sManifestFilePath._cc == 0)
        {
            // no manifest path
            _hr = CO_E_NOTINITIALIZED;
            goto exit;
        }

        // lazy init
        if (FAILED(_hr = CreateAssemblyManifestImport(&_pManifestImport, _sManifestFilePath._pwz)))
            goto exit;
    }

    // file name parsed from manifest.
    if (FAILED(_hr = pAssemblyFileInfo->Get(ASM_FILE_NAME, &pwzBuf, &ccBuf)))
        goto exit;
    sFileName.TakeOwnership(pwzBuf, ccBuf);

    if (FAILED(_hr = sTargetPath.Assign(_sManifestFileDir)))
        goto exit;
    
    if (FAILED(_hr = sTargetPath.Append(sFileName._pwz)))
        goto exit;

    // optimization: check if the target exists
    if (GetFileAttributes(sTargetPath._pwz) == (DWORD)-1)
    {
        // file doesn't exist - no point looking into the manifest file 
        _hr = S_FALSE;
        goto exit;
    }

    // find the specified file entry in the manifest
    // BUGBUG: check for missing attribute case
    if (FAILED(_hr = _pManifestImport->QueryFile(sFileName._pwz, &pFoundFileInfo))
        || _hr == S_FALSE)
        goto exit;

    // check if the entries match
    if (IsEqualAssemblyFileInfo(pAssemblyFileInfo, pFoundFileInfo))
    {
        // BUGBUG:? should now check if the actual file has the matching hash etc.
        *ppwzPath = sTargetPath._pwz;
        sTargetPath.ReleaseOwnership();
    }
    else
        _hr = S_FALSE;

exit:
    SAFERELEASE(pFoundFileInfo);
        
    return _hr;
}


// ---------------------------------------------------------------------------
// CopyFile
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::CopyFile(LPOLESTR pwzSourcePath, LPOLESTR pwzFileName, DWORD dwFlags)
{
    LPWSTR pwzBuf = NULL;
    DWORD ccBuf = 0;

    CString sDisplayName;

    LPASSEMBLY_MANIFEST_IMPORT pManifestImport = NULL;
    LPASSEMBLY_IDENTITY pIdentity = NULL;
    LPASSEMBLY_FILE_INFO pAssemblyFile= NULL;
    
    if (dwFlags == MANIFEST)
    {
        DWORD n = 0;
        CreateAssemblyManifestImport(&pManifestImport, pwzSourcePath);
        pManifestImport->GetAssemblyIdentity(&pIdentity);
        pIdentity->GetDisplayName(ASMID_DISPLAYNAME_NOMANGLING, &pwzBuf, &ccBuf);
        sDisplayName.TakeOwnership(pwzBuf, ccBuf);

        _sDisplayName.Assign(sDisplayName);
        
        // Construct target path
        _sManifestFileDir.Assign(_sRootDir);
        _sManifestFileDir.Append(sDisplayName);
        _sManifestFileDir.Append(L"\\");

        _sManifestFilePath.Assign(_sManifestFileDir);
        _sManifestFilePath.Append(pwzFileName);
        
        CreateDirectoryHierarchy(NULL, _sManifestFilePath._pwz);

        // Copy the manifest from staging area into cache.
        ::CopyFile(pwzSourcePath, _sManifestFilePath._pwz, FALSE);

        SAFERELEASE(pManifestImport);
        ::DeleteFile(pwzSourcePath);
        
        // Create the manifest import interface
        CreateAssemblyManifestImport(&_pManifestImport, _sManifestFilePath._pwz);

        // Enumerate files from manifest and pre-generate nested
        // directories required for background file copy.
        while (_pManifestImport->GetNextFile(n++, &pAssemblyFile) == S_OK)
        {
            CString sPath;
            pAssemblyFile->Get(ASM_FILE_NAME, &pwzBuf, &ccBuf);
            sPath.TakeOwnership(pwzBuf, ccBuf);
            sPath.PathNormalize();
            CreateDirectoryHierarchy(_sManifestFileDir._pwz, sPath._pwz);

            // RELEASE pAssebmlyFile everytime through the while loop
            SAFERELEASE(pAssemblyFile);
        }
    }
    else
    {
        CString sTargetPath;

        // Construct target path
        sTargetPath.Assign(_sManifestFileDir);
        sTargetPath.Append(pwzFileName);

        CreateDirectoryHierarchy(NULL, sTargetPath._pwz);

        // Copy non-manifest files into cache. Presumably from previous cached location to the new 
        ::CopyFile(pwzSourcePath, sTargetPath._pwz, FALSE);
    }

    if (pIdentity)
        pIdentity->Release();

    return _hr;

}


// ---------------------------------------------------------------------------
// Commit
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::Commit(DWORD dwFlags)
{
    if (!(_sDisplayName._pwz))
    {
        _hr = E_FAIL;
        goto exit;
    }
    
    // mark cache completed
    _hr = SetStatus(_sDisplayName._pwz, COMPLETED);

exit:

    return _hr;
}


#define REG_KEY_FUSION_SETTINGS     TEXT("Software\\Microsoft\\Fusion\\Installer\\1.0.0.0\\Cache\\")
#define WZ_STATUS_CONFIRMED L"Confirmed"
#define WZ_STATUS_COMPLETED L"Complete"
#define WZ_STATUS_CRITICAL   L"Critical"
#define SET_VALUE   1
// ---------------------------------------------------------------------------
// IsStatus
// return FALSE if absent
// ---------------------------------------------------------------------------
BOOL CAssemblyCache::IsStatus(LPWSTR pwzDisplayName, CacheStatus eStatus)
{
    CString sStatus;
    HUSKEY hRegKey;
    DWORD dwType = 0;
    DWORD dwValue = -1;
    DWORD dwSize = sizeof(dwValue);
    DWORD dwDefault = -1;
    LPCWSTR pwzQueryString = NULL;
    BOOL bRelVal = FALSE;

    if (eStatus == COMPLETED)
        pwzQueryString = WZ_STATUS_COMPLETED;
    else if (eStatus == CONFIRMED)
        pwzQueryString = WZ_STATUS_CONFIRMED;
    else if (eStatus == CRITICAL)
        pwzQueryString = WZ_STATUS_CRITICAL;
    else
    {
        _hr = E_INVALIDARG;
        goto exit;
    }

    if (FAILED(_hr=sStatus.Assign(REG_KEY_FUSION_SETTINGS)))
        goto exit;

    if (FAILED(_hr=sStatus.Append(pwzDisplayName)))
        goto exit;
    
    // Open registry entry
    if (SHRegOpenUSKey(sStatus._pwz, KEY_ALL_ACCESS, NULL, 
        &hRegKey, FALSE) != ERROR_SUCCESS)
    {
        _hr = E_FAIL;
        goto exit;
    }

    // Query
    if(SHRegQueryUSValue(hRegKey, pwzQueryString, &dwType, (LPVOID) &dwValue,
        &dwSize, FALSE, (LPVOID) &dwDefault, sizeof(dwDefault)) != ERROR_SUCCESS)
        _hr = E_FAIL;
 
    if (dwValue == SET_VALUE)
        bRelVal = TRUE;

    if(SHRegCloseUSKey(hRegKey) != ERROR_SUCCESS)
        _hr = E_FAIL;
 
exit:
    return bRelVal;
}


// ---------------------------------------------------------------------------
// SetStatus
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::SetStatus(LPWSTR pwzDisplayName, CacheStatus eStatus)
{
    CString sStatus;
    HUSKEY hRegKey;
    DWORD dwValue = SET_VALUE;
    LPCWSTR pwzValueNameString = NULL;
    
    // BUGBUG: should this be in-sync with what server does to register update?

    if (eStatus == COMPLETED)
        pwzValueNameString = WZ_STATUS_COMPLETED;
    else if (eStatus == CONFIRMED)
        pwzValueNameString = WZ_STATUS_CONFIRMED;
    else if (eStatus == CRITICAL)
        pwzValueNameString = WZ_STATUS_CRITICAL;
    else
    {
        _hr = E_INVALIDARG;
        goto exit;
    }

    if (FAILED(_hr=sStatus.Assign(REG_KEY_FUSION_SETTINGS)))
        goto exit;

    if (FAILED(_hr=sStatus.Append(pwzDisplayName)))
        goto exit;
    
    // Create registry entry
    if (SHRegCreateUSKey(sStatus._pwz, KEY_ALL_ACCESS, NULL, 
        &hRegKey, SHREGSET_FORCE_HKCU) != ERROR_SUCCESS)   //SHREGSET_DEFAULT for strongly named apps?
    {
        _hr = E_FAIL;
        goto exit;
    }

    // Write
    if (SHRegWriteUSValue(hRegKey, pwzValueNameString, REG_DWORD, (LPVOID) &dwValue,
        sizeof(dwValue), SHREGSET_FORCE_HKCU) != ERROR_SUCCESS)
        _hr = E_FAIL;

    if (SHRegCloseUSKey(hRegKey) != ERROR_SUCCESS)
        _hr = E_FAIL;

exit:
    return _hr;
}


// ---------------------------------------------------------------------------
// CreateDirectoryHierarchy
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::CreateDirectoryHierarchy(LPWSTR pwzRootDir, LPWSTR pwzFilePath)
{
    LPWSTR pwzPath, pwzEnd;
    CString sCombinedPath;

    if (pwzRootDir)    
        sCombinedPath.Assign(pwzRootDir);
    sCombinedPath.Append(pwzFilePath);
    
    pwzPath = sCombinedPath._pwz;
    pwzEnd = pwzPath + sizeof("C:\\");    
    while (pwzEnd = StrChr(pwzEnd, L'\\'))
    {
        *pwzEnd = L'\0';
        if (GetFileAttributes(pwzPath) == -1) 
            CreateDirectory(pwzPath, NULL);
        *(pwzEnd++) = L'\\';
    }
    
    return S_OK;

}


// ---------------------------------------------------------------------------
// GetCacheRootDir
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::GetCacheRootDir(CString &sCacheDir, CacheFlags eFlags)
{
    HRESULT hr = S_OK;
    WCHAR wzPath[MAX_PATH];

    // BUGBUG?: MAX_PATH restriction. Seems reasonable in this case?
    if(GetEnvironmentVariable(L"ProgramFiles", wzPath, MAX_PATH/*-lstrlen(WZ_CACHE_LOCALROOTDIR)*/-1) == 0)
    {
        hr = CO_E_PATHTOOLONG;
        goto exit;
    }

    if (FAILED(hr = sCacheDir.Assign(wzPath)))
        goto exit;
    
    if (FAILED(hr = sCacheDir.PathCombine(WZ_CACHE_LOCALROOTDIR)))
        goto exit;

    if (eFlags == Staging)
        hr = sCacheDir.PathCombine(WZ_MANIFEST_STAGING_DIR);
exit:
    return hr;
}


// IUnknown methods

// ---------------------------------------------------------------------------
// CAssemblyCache::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyCache::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyCacheImport)
       )
    {
        *ppvObj = static_cast<IAssemblyCacheImport*> (this);
        AddRef();
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IAssemblyCacheEmit))
    {
        *ppvObj = static_cast<IAssemblyCacheEmit*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyCache::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyCache::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyCache::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyCache::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\inc\util.h ===
#ifndef UTIL_H
#define UTIL_H
#pragma once

#include "fusionheap.h"
#include "shlwapi.h"
#include "wincrypt.h"
#include "fusionhandle.h"

#include "numberof.h"

#pragma warning(push)
#pragma warning(disable: 4201)


#define SXSP_DIR_WALK_FLAGS_FIND_AT_LEAST_ONE_FILEUNDER_CURRENTDIR          (1)
#define SXSP_DIR_WALK_FLAGS_INSTALL_ASSEMBLY_UNDER_CURRECTDIR_SUCCEED       (2)

inline
VOID GetTodaysTime( LPFILETIME  lpFt)
{
    SYSTEMTIME sSysT;

    ::GetSystemTime(&sSysT);
    sSysT.wHour = sSysT.wMinute = sSysT.wSecond = sSysT.wMilliseconds = 0;
    ::SystemTimeToFileTime(&sSysT, lpFt);
}

inline
USHORT FusionGetMajorFromVersionHighHalf(DWORD dwVerHigh)
{
    return HIWORD(dwVerHigh);
}

inline
USHORT FusionGetMinorFromVersionHighHalf(DWORD dwVerHigh)
{
    return LOWORD(dwVerHigh);
}

inline
USHORT FusionGetRevisionFromVersionLowHalf(DWORD dwVerLow)
{
    return HIWORD(dwVerLow);
}

inline
USHORT FusionGetBuildFromVersionLowHalf(DWORD dwVerLow)
{
    return LOWORD(dwVerLow);
}


#if defined(FUSION_WIN) || defined(FUSION_WIN2000)

#include "debmacro.h"
#include "FusionArray.h"
#include "fusionbuffer.h"
#include "EnumBitOperations.h"

//
//  FusionCopyString() has a non-obvious interface due to the overloading of
//  pcchBuffer to both describe the size of the buffer on entry and the number of
//  characters required on exit.
//
//  prgchBuffer is the buffer to write to.  If *pcchBuffer is zero when FusionCopyString()
//      is called, it may be NULL.
//
//  pcchBuffer is a required parameter, which on entry must contain the number of unicode
//      characters in the buffer pointed to by prgchBuffer.  On exit, if the buffer was
//      not large enough to hold the character string, including a trailing null,
//      it is set to the number of WCHARs required to hold the string, including the
//      trailing null, and HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) is returned.
//
//      If the buffer is large enough, *pcchBuffer is set to the number of characters
//      written into the buffer, including the trailing null character.
//
//      This is contrary to most functions which return the number of characters written
//      not including the trailing null, but since both on input and in the error case,
//      it deals with the size of the buffer required rather than the number of non-
//      null characters written, it seems inconsistent to only in the success case
//      omit the null from the count.
//
//  szIn is a pointer to sequence of unicode characters to be copied.
//
//  cchIn is the number of Unicode characters in the character string to copy.  If a
//      value less than zero is passed in, szIn must point to a null-terminated string,
//      and the current length of the string is used.  If a value zero or greater is
//      passed, exactly that many characters are assumed to be in the character string.
//

HRESULT FusionCopyString(
    WCHAR *prgchBuffer,
    SIZE_T *pcchBuffer,
    LPCWSTR szIn,
    SIZE_T cchIn
    );

HRESULT FusionCopyBlob(BLOB *pblobOut, const BLOB &rblobIn);
VOID FusionFreeBlob(BLOB *pblob);

BOOL
FusionDupString(
    PWSTR *ppszOut,
    PCWSTR szIn,
    SIZE_T cchIn
    );

BOOL
SxspMapLANGIDToCultures(
	LANGID langid,
	CBaseStringBuffer &rbuffGeneric,
	CBaseStringBuffer &rbuffSpecific
	);

BOOL
SxspMapCultureToLANGID(
    PCWSTR pcwszCultureString,
    LANGID &lid,
    PBOOL pfFound
    );

typedef struct _SXSP_LANGUAGE_BUFFER_PAIR
{
    CBaseStringBuffer * m_Generic;
    CBaseStringBuffer * m_Specific;
} SXSP_LANGUAGE_BUFFER_PAIR, *PSXSP_LANGUAGE_BUFFER_PAIR;
typedef const SXSP_LANGUAGE_BUFFER_PAIR * PCSXSP_LANGUAGE_BUFFER_PAIR;

BOOL
SxspCultureStringToCultureStrings(
    PCWSTR              pcwszCultureString,
    bool &              rfFoundOut,
    SXSP_LANGUAGE_BUFFER_PAIR & LanguagePair
    );

BOOL
FusionpParseProcessorArchitecture(
    IN PCWSTR String,
    IN SIZE_T Cch,
    OUT USHORT *ProcessorArchitecture OPTIONAL,
    bool &rfValid
    );

BOOL
FusionpFormatProcessorArchitecture(
    IN USHORT ProcessorArchitecture,
    CBaseStringBuffer &rBuffer
    );

BOOL
FusionpFormatEnglishLanguageName(
    IN LANGID LangID,
    CBaseStringBuffer &rBuffer
    );

/*-----------------------------------------------------------------------------
like ::CreateDirectoryW, but will create the parent directories as needed
-----------------------------------------------------------------------------*/
BOOL
FusionpCreateDirectories(
    PCWSTR pszDirectory,
    SIZE_T cchDirectory
    );

/*-----------------------------------------------------------------------------
'\\' or '/'
-----------------------------------------------------------------------------*/
BOOL
FusionpIsPathSeparator(
    WCHAR ch
    );

/*-----------------------------------------------------------------------------
just the 52 chars a-zA-Z, need to check with fs
-----------------------------------------------------------------------------*/
BOOL
FusionpIsDriveLetter(
    WCHAR ch
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

VOID
FusionpSetLastErrorFromHRESULT(
    HRESULT hr
    );

DWORD
FusionpHRESULTToWin32(
    HRESULT hr
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

class CFusionDirectoryDifference;

BOOL
FusionpCompareDirectoriesSizewiseRecursively(
    CFusionDirectoryDifference*  pResult,
    const CBaseStringBuffer &rdir1,
    const CBaseStringBuffer &rdir2
    );

class CFusionDirectoryDifference
{
private: // deliberately unimplemented
    CFusionDirectoryDifference(const CFusionDirectoryDifference&);
    VOID operator=(const CFusionDirectoryDifference&);
public:
    CFusionDirectoryDifference()
    :
        m_e(eEqual),
        m_pstr1(&m_str1),
        m_pstr2(&m_str2)
    {
    }

    VOID
    DbgPrint(
        PCWSTR dir1,
        PCWSTR dir2
        );

public:
    enum E
    {
        eEqual,
        eExtraOrMissingFile,
        eMismatchedFileSize,
        eMismatchedFileCount,
        eFileDirectoryMismatch
    };

    E               m_e;

    union
    {
        struct
        {
            CBaseStringBuffer *   m_pstr1;
            CBaseStringBuffer *   m_pstr2;
        };
        struct // eExtraOrMissingFile
        {
            CBaseStringBuffer *   m_pstrExtraOrMissingFile;
        };
        struct // eMismatchFileSize
        {
            CBaseStringBuffer *   m_pstrMismatchedSizeFile1;
            CBaseStringBuffer *   m_pstrMismatchedSizeFile2;
            ULONGLONG        m_nMismatchedFileSize1;
            ULONGLONG        m_nMismatchedFileSize2;
        };
        struct // eMismatchFileCount
        {
            CBaseStringBuffer *   m_pstrMismatchedCountDir1;
            CBaseStringBuffer *   m_pstrMismatchedCountDir2;
            ULONGLONG        m_nMismatchedFileCount1;
            ULONGLONG        m_nMismatchedFileCount2;
        };
        struct // eFileDirectoryMismatch
        {
            CBaseStringBuffer *   m_pstrFile;
            CBaseStringBuffer *   m_pstrDirectory;
        };
    };

// private:
    CStringBuffer   m_str1;
    CStringBuffer   m_str2;
};

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

class CFusionFilePathAndSize
{
public:
    CFusionFilePathAndSize() : m_size(0) { }

    // bsearch and qsort accept optionally subtley different functions
    // bsearch looks for a key in an array, the key and the array elements
    // can be of different types, qsort compares only elements in the array
    static int __cdecl QsortComparePath(const void*, const void*);

    // for qsort/bsearch an array of pointers to CFusionFilePathAndSize
    static int __cdecl QsortIndirectComparePath(const void*, const void*);

    CStringBuffer   m_path;
    __int64         m_size;

    // Do we actually have valid hashing data?
    bool            m_bHasHashInfo;
    CStringBuffer   m_HashString;
    ALG_ID          m_HashAlgorithm;

private:
    CFusionFilePathAndSize(const CFusionFilePathAndSize &); // intentionally not implemented
    void operator =(const CFusionFilePathAndSize &); // intentionally not implemented
};

template <> inline HRESULT
FusionCopyContents<CFusionFilePathAndSize>(
    CFusionFilePathAndSize& rtDestination,
    const CFusionFilePathAndSize& rtSource
    );

/*-----------------------------------------------------------------------------
two DWORDs to an __int64
-----------------------------------------------------------------------------*/
ULONGLONG
FusionpFileSizeFromFindData(
    const WIN32_FIND_DATAW& wfd
    );

/*-----------------------------------------------------------------------------
HRESULT_FROM_WIN32(GetLastError()) or E_FAIL if GetLastError() == NO_ERROR
-----------------------------------------------------------------------------*/
HRESULT
FusionpHresultFromLastError();

/*-----------------------------------------------------------------------------
FindFirstFile results you always ignore "." and ".."
-----------------------------------------------------------------------------*/
BOOL FusionpIsDotOrDotDot(PCWSTR str);

/*-----------------------------------------------------------------------------
simple code for walking directories, with a per file callback
could be fleshed out more, but good enough for present purposes
-----------------------------------------------------------------------------*/

class CDirWalk
{
public:
    enum ECallbackReason
    {
        eBeginDirectory = 1,
        eFile,
        eEndDirectory
    };

    CDirWalk();

    //
    // the callback cannot reenable what is has disabled
    // perhaps move these to be member data bools
    //
    enum ECallbackResult
    {
        eKeepWalking            = 0x00000000,
        eError                  = 0x00000001,
        eSuccess                = 0x00000002,
        eStopWalkingFiles       = 0x00000004,
        eStopWalkingDirectories = 0x00000008,
        eStopWalkingDeep        = 0x00000010
    };

    //
    // Just filter on like *.dll, in the future you can imagine
    // filtering on attributes like read onlyness, or running
    // SQL queries over the "File System Oledb Provider"...
    //
    // Also, note that we currently do a FindFirstFile/FindNextFile
    // loop for each filter, plus sometimes one more with *
    // to pick up directories. It is probably more efficient to
    // use * and then filter individually but I don't feel like
    // porting over \Vsee\Lib\Io\Wildcard.cpp right now (which
    // was itself ported from FsRtl, and should be in Win32!)
    //
    const PCWSTR*    m_fileFiltersBegin;
    const PCWSTR*    m_fileFiltersEnd;
    CStringBuffer    m_strParent; // set this to the initial directory to walk
    SIZE_T           m_cchOriginalPath;
    WIN32_FIND_DATAW m_fileData; // not valid for directory callbacks, but could be with a little work
    PVOID            m_context;

    CStringBuffer   m_strLastObjectFound;

    ECallbackResult
    (*m_callback)(
        ECallbackReason  reason,
        CDirWalk*        dirWalk,
        DWORD            dwWalkDirFlags
        );

    BOOL
    Walk();

protected:
    ECallbackResult
    WalkHelper();

private:
    CDirWalk(const CDirWalk &); // intentionally not implemented
    void operator =(const CDirWalk &); // intentionally not implemented
};

ENUM_BIT_OPERATIONS(CDirWalk::ECallbackResult)

/*-----------------------------------------------------------------------------*/

typedef struct _FUSION_FLAG_FORMAT_MAP_ENTRY
{
    DWORD m_dwFlagMask;
    PCWSTR m_pszString;
    SIZE_T m_cchString;
    PCWSTR m_pszShortString;
    SIZE_T m_cchShortString;
    DWORD m_dwFlagsToTurnOff; // enables more generic flags first in map hiding more specific combinations later
} FUSION_FLAG_FORMAT_MAP_ENTRY, *PFUSION_FLAG_FORMAT_MAP_ENTRY;

#define DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(_x, _ss) { _x, L ## #_x, NUMBER_OF(L ## #_x) - 1, L ## _ss, NUMBER_OF(_ss) - 1, _x },

typedef const FUSION_FLAG_FORMAT_MAP_ENTRY *PCFUSION_FLAG_FORMAT_MAP_ENTRY;

BOOL
FusionpFormatFlags(
    IN DWORD dwFlagsToFormat,
    IN bool fUseLongNames,
    IN SIZE_T cMapEntries,
    IN PCFUSION_FLAG_FORMAT_MAP_ENTRY prgMapEntries,
    IN OUT CBaseStringBuffer &rbuff
    );

/*-----------------------------------------------------------------------------
inline implementations
-----------------------------------------------------------------------------*/
inline BOOL
FusionpIsPathSeparator(
    WCHAR ch
    )
{
    return ((ch == L'\\') || (ch == L'/'));
}

inline BOOL
FusionpIsDotOrDotDot(
    PCWSTR str
    )
{
    return ((str[0] == L'.') && ((str[1] == L'\0') || ((str[1] == L'.') && (str[2] == L'\0'))));
}

inline BOOL
FusionpIsDriveLetter(
    WCHAR ch
    )
{
    if (ch >= L'a' && ch <= L'z')
        return TRUE;
    if (ch >= L'A' && ch <= L'Z')
        return TRUE;
    return FALSE;
}

inline ULONGLONG
FusionpFileSizeFromFindData(
    const WIN32_FIND_DATAW& wfd
    )
{
    ULARGE_INTEGER uli;

    uli.LowPart = wfd.nFileSizeLow;
    uli.HighPart = wfd.nFileSizeHigh;

    return uli.QuadPart;
}

inline HRESULT
FusionpHresultFromLastError()
{
    HRESULT hr = E_FAIL;
    DWORD dwLastError = ::FusionpGetLastWin32Error();
    if (dwLastError != NO_ERROR)
    {
        hr = HRESULT_FROM_WIN32(dwLastError);
    }
    return hr;
}

template <> inline BOOL
FusionWin32CopyContents<CFusionFilePathAndSize>(
    CFusionFilePathAndSize& rtDestination,
    const CFusionFilePathAndSize& rtSource
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    IFW32FALSE_EXIT(rtDestination.m_path.Win32Assign(rtSource.m_path, rtSource.m_path.Cch()));
    IFW32FALSE_EXIT(rtDestination.m_HashString.Win32Assign(rtSource.m_HashString, rtSource.m_HashString.Cch()));
    rtDestination.m_size = rtSource.m_size;
    rtDestination.m_HashAlgorithm = rtSource.m_HashAlgorithm;
    rtDestination.m_bHasHashInfo = rtSource.m_bHasHashInfo;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

template <> inline VOID
FusionMoveContents<CFusionFilePathAndSize>(
    CFusionFilePathAndSize& /* rtDestination */,
    CFusionFilePathAndSize& /* rtSource */
    )
{
    FN_TRACE();
    HARD_ASSERT2_ACTION(FusionMoveContents, "FusionMoveContents for CFusionFilePathAndSize isn't allowed.");
}


template <> inline HRESULT
FusionCopyContents<CFusionFilePathAndSize>(
    CFusionFilePathAndSize& rtDestination,
    const CFusionFilePathAndSize& rtSource
    )
{
    HRESULT hr;
    FN_TRACE_HR(hr);
    IFW32FALSE_EXIT(rtDestination.m_path.Win32Assign(rtSource.m_path, rtSource.m_path.Cch()));
    IFW32FALSE_EXIT(rtDestination.m_HashString.Win32Assign(rtSource.m_HashString, rtSource.m_HashString.Cch()));
    rtDestination.m_size = rtSource.m_size;
    rtDestination.m_HashAlgorithm = rtSource.m_HashAlgorithm;
    rtDestination.m_bHasHashInfo = rtSource.m_bHasHashInfo;
    hr = NOERROR;
Exit:
    return hr;
}

#define FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING (0x00000001)
#define FUSIONP_REG_QUERY_DWORD_MISSING_VALUE_IS_FAILURE        (0x00000001)
#define FUSIONP_REG_QUERY_BINARY_NO_FAIL_IF_NON_BINARY          (0x00000001)

BOOL
FusionpRegQuerySzValueEx(
    DWORD dwFlags,
    HKEY hKey,
    PCWSTR lpValueName,
    CBaseStringBuffer &Buffer,
    DWORD &rdwWin32Error,
    SIZE_T cExceptionalLastErrorValues,
    ...
    );

BOOL
FusionpRegQuerySzValueEx(
    DWORD dwFlags,
    HKEY hKey,
    PCWSTR lpValueName,
    CBaseStringBuffer &Buffer
    );

BOOL
FusionpRegQueryDwordValueEx(
    DWORD   dwFlags,
    HKEY    hKey,
    PCWSTR  wszValueName,
    PDWORD  pdwValue,
    DWORD   dwDefaultValue = 0
    );

BOOL
FusionpRegQueryBinaryValueEx(
    DWORD dwFlags,
    HKEY hKey,
    PCWSTR lpValueName,
    CFusionArray<BYTE> &rbBuffer
    );

BOOL
FusionpRegQueryBinaryValueEx(
    DWORD dwFlags,
    HKEY hKey,
    PCWSTR lpValueName,
    CFusionArray<BYTE> &rbBuffer,
    DWORD &rdwLastError,
    SIZE_T cExceptionalLastErrors,
    ...
    );

BOOL
FusionpRegQueryBinaryValueEx(
    DWORD dwFlags,
    HKEY hKey,
    PCWSTR lpValueName,
    CFusionArray<BYTE> &rbBuffer,
    DWORD &rdwLastError,
    SIZE_T cExceptionalLastErrors,
    va_list ap
    );

BOOL
FusionpAreWeInOSSetupMode(
    BOOL*
    );

BOOL
FusionpMapLangIdToString(
    DWORD dwFlags,
    LANGID LangID,
    PCWSTR *StringOut
    );


BOOL
SxspDequoteString(
    IN DWORD dwFlags,
    IN PCWSTR pcwszStringIn,
    IN SIZE_T cchStringIn,
    OUT PWSTR pwszStringOut,
    OUT SIZE_T *pcchStringOut
    );

BOOL
FusionpGetActivationContextFromFindResult(
    IN PCACTCTX_SECTION_KEYED_DATA askd,
    OUT HANDLE *
    );

#define FUSIONP_SEARCH_PATH_ACTCTX (0x00000001)
BOOL
FusionpSearchPath(
    ULONG               ulFusionFlags,
    LPCWSTR             lpPath,
    LPCWSTR             lpFileName,         // file name
    LPCWSTR             lpExtension,        // file extension
    CBaseStringBuffer & StringBuffer,
    SIZE_T *            lpFilePartOffset,   // file component
    HANDLE              hActCtx
    );

BOOL
FusionpGetModuleFileName(
    ULONG               ulFusionFlags,
    HMODULE             hmodDll,
    CBaseStringBuffer & StringBuffer
    );

#endif // defined(FUSION_WIN) || defined(FUSION_WIN2000)

#pragma warning(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\dll\dllmain.cpp ===
#include <fusenetincludes.h>
#include <msxml2.h>
#include <manifestimport.h>
//#include <idp.h>
#include <sxsapi.h>
//#include <sxsid.h>


HINSTANCE g_hInst = NULL;

extern HANDLE g_hNamedEvent;

//----------------------------------------------------------------------------
BOOL WINAPI DllMain( HINSTANCE hInst, DWORD dwReason, LPVOID pvReserved )
{        
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_hInst = hInst;
            DisableThreadLibraryCalls(hInst);
            CAssemblyManifestImport::InitGlobalCritSect();
            break;
            
        case DLL_PROCESS_DETACH:                         
             break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            break;
    }
    return TRUE;
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\dll\guids.c ===
#define INITGUID
#include <guiddef.h>


DEFINE_GUID( IID_IAssemblyFileInfo,
0x66f171ea,0xbd29,0x4936,0xb3,0x91,0x42,0x25,0xc6,0xd7,0x36,0x1a);

DEFINE_GUID( IID_IAssemblyIdentity,
0xaaa1257d,0xa56c,0x4383,0x9b,0x4a,0xc8,0x68,0xed,0xa7,0xca,0x42);


DEFINE_GUID( IID_IAssemblyManifestImport,
0x696fb37f,0xda64,0x4175,0x94,0xe7,0xfd,0xc8,0x23,0x45,0x39,0xc4);

DEFINE_GUID( IID_IAssemblyCacheImport,
0xc920b164,0x33e0,0x4c61,0xb5,0x95,0xec,0xa4,0xcd,0xb0,0x4f,0x12);

DEFINE_GUID( IID_IAssemblyCacheEmit,
0x83d6b9ac,0xeff9,0x45a3,0x83,0x61,0x7c,0x41,0xdf,0x1f,0x9f,0x85);

DEFINE_GUID( IID_IAssemblyDownload,
0x8a249b36,0x6132,0x4238,0x88,0x71,0xa2,0x67,0x02,0x93,0x82,0xa8);

DEFINE_GUID( IID_IManifestApplicationInfo,
0x1367877f,0xbe85,0x40ab,0xb1,0x6c,0x44,0xb9,0xc2,0x3b,0x18,0x19);

DEFINE_GUID( IID_IDependentAssemblyInfo,
0xc9629878,0x461a,0x451b,0xa0,0x32,0xea,0xca,0x1c,0xb5,0x38,0x3a);
			


DEFINE_GUID( IID_IBackgroundCopyFile,0x01b7bd23,0xfb88,0x4a77,0x84,0x90,0x58,0x91,0xd3,0xe4,0x65,0x3a);


DEFINE_GUID( IID_IEnumBackgroundCopyFiles,0xca51e165,0xc365,0x424c,0x8d,0x41,0x24,0xaa,0xa4,0xff,0x3c,0x40);


DEFINE_GUID( IID_IBackgroundCopyError,0x19c613a0,0xfcb8,0x4f28,0x81,0xae,0x89,0x7c,0x3d,0x07,0x8f,0x81);


DEFINE_GUID( IID_IBackgroundCopyJob,0x37668d37,0x507e,0x4160,0x93,0x16,0x26,0x30,0x6d,0x15,0x0b,0x12);


DEFINE_GUID( IID_IEnumBackgroundCopyJobs,0x1af4f612,0x3b71,0x466f,0x8f,0x58,0x7b,0x6f,0x73,0xac,0x57,0xad);


DEFINE_GUID( IID_IBackgroundCopyCallback,0x97ea99c7,0x0186,0x4ad4,0x8d,0xf9,0xc5,0xb4,0xe0,0xed,0x6b,0x22);


DEFINE_GUID( IID_AsyncIBackgroundCopyCallback,0xca29d251,0xb4bb,0x4679,0xa3,0xd9,0xae,0x80,0x06,0x11,0x9d,0x54);


DEFINE_GUID( IID_IBackgroundCopyManager,0x5ce34c0d,0x0dc9,0x4c1f,0x89,0x7c,0xda,0xa1,0xb7,0x8c,0xee,0x7c);


DEFINE_GUID( LIBID_BackgroundCopyManager,0x1deeb74f,0x7915,0x4560,0xb5,0x58,0x91,0x8c,0x83,0xf1,0x76,0xa6);


DEFINE_GUID(CLSID_BackgroundCopyManager,0x4991d34b,0x80a1,0x4291,0x83,0xb6,0x33,0x28,0x36,0x6b,0x90,0x97);


// For update services, referenced in assemblydownload.cpp
DEFINE_GUID(IID_IAssemblyUpdate,0x301b3415,0xf52d,0x4d40,0xbd,0xf7,0x31,0xd8,0x27,0x12,0xc2,0xdc);

DEFINE_GUID(CLSID_CAssemblyUpdate,0x37b088b8,0x70ef,0x4ecf,0xb1,0x1e,0x1f,0x3f,0x4d,0x10,0x5f,0xdd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\download\assemblydownload.cpp ===
#include <fusenetincludes.h>

#include <bits.h>
#include <assemblycache.h>
#include "dialog.h"
#include <assemblydownload.h>

#include "..\id\sxsid.h"
#include ".\patchapi.h"

// Update services
#include "server.h"

#define DOWNLOAD_FLAGS_INTERNAL_TRAVERSE_LINK (DOWNLOAD_FLAGS_NOTIFY_COMPLETION + 1)
#define PATCH_DIRECTORY L"__patch__\\"


IBackgroundCopyManager* CAssemblyDownload::g_pManager = NULL;

// ---------------------------------------------------------------------------
// CreateAssemblyDownload
// ---------------------------------------------------------------------------
STDAPI CreateAssemblyDownload(IAssemblyDownload** ppDownload)
{
    HRESULT hr = S_OK;

    CAssemblyDownload *pDownload = new(CAssemblyDownload);
    if (!pDownload)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

exit:

    *ppDownload = (IAssemblyDownload*) pDownload;

    return hr;
}



// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CAssemblyDownload::CAssemblyDownload()
    :   _dwSig('DLND'), _cRef(1), _hr(S_OK), _pRootEmit(NULL), _hNamedEvent(NULL),
    _pDlg(NULL)
{}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CAssemblyDownload::~CAssemblyDownload()
{
    SAFERELEASE(_pRootEmit);
    SAFEDELETE(_pDlg);

    // BUGBUG: Do proper ref counting and release here
    //SAFERELEASE(g_pManager);
}


// IAssemblyDownload methods


void MakeSequentialFileName(CString& sPath)
{
    int iSeqNum = 1;
    int iIndex = sPath._cc;

    // BUGBUG: hack up name generation code

    sPath.Append(L"[1]");
    while (GetFileAttributes(sPath._pwz) != (DWORD)-1)
    {
        // keep incrementing till unique...
        iSeqNum++;

        // BUGBUG: note string len limitation
        WCHAR buffer[20];

        _itow(iSeqNum, buffer, 10);

        sPath[iIndex] = L'/';
        sPath.RemoveLastElement();
        sPath.Append(buffer);
        sPath.Append(L"]");

        // BUGBUG: MAX_PATH restriction?
    }
}


// ---------------------------------------------------------------------------
// DownloadManifestAndDependencies
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::DownloadManifestAndDependencies(
    LPWSTR pwzApplicationManifestUrl, HANDLE hNamedEvent, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    LPWSTR pwz = NULL;
    IBackgroundCopyJob *pJob = NULL;
    GUID guid = {0};

    CString sTempManifestPath;
    CString sAppUrl;
    CString sManifestFileName;

    // Create temporary manifest path from url.
    sAppUrl.Assign(pwzApplicationManifestUrl);
    sAppUrl.LastElement(sManifestFileName);
    CAssemblyCache::GetCacheRootDir(sTempManifestPath, CAssemblyCache::Staging);
    sTempManifestPath.Append(sManifestFileName._pwz);
    MakeSequentialFileName(sTempManifestPath);

    // BUGBUG - do real check
    if (!g_pManager)
    {
        CoCreateInstance(CLSID_BackgroundCopyManager, NULL, CLSCTX_LOCAL_SERVER, 
                IID_IBackgroundCopyManager, (void**) &g_pManager);
    }
    
    // just give it a location name
    hr = g_pManager->CreateJob(pwzApplicationManifestUrl, 
        BG_JOB_TYPE_DOWNLOAD, &guid, &pJob);

    // Init dialog object with job.
    if (dwFlags == DOWNLOAD_FLAGS_PROGRESS_UI)
    {
        hr = CreateDialogObject(&_pDlg, pJob);

    //felixybc no need        _pDlg->_pDownload = this; // bugbug - if addref, circular refcount
    }
    else if ((dwFlags == DOWNLOAD_FLAGS_INTERNAL_TRAVERSE_LINK) && _pDlg)
        _pDlg->SetJobObject(pJob);
    else if (dwFlags == DOWNLOAD_FLAGS_NOTIFY_COMPLETION)
        _hNamedEvent = hNamedEvent;
        
    // Set job config info.
    hr = pJob->SetNotifyInterface(static_cast<IBackgroundCopyCallback*> (this));    
    hr = pJob->SetNotifyFlags(BG_NOTIFY_JOB_MODIFICATION | BG_NOTIFY_JOB_TRANSFERRED | BG_NOTIFY_JOB_ERROR);
    hr = pJob->SetPriority(BG_JOB_PRIORITY_FOREGROUND);

    // Ensure local dir path exists.
    CAssemblyCache::CreateDirectoryHierarchy(NULL, sTempManifestPath._pwz);

    // Do the download;
    pJob->AddFile(pwzApplicationManifestUrl, sTempManifestPath._pwz);
    pJob->Resume();

    // We're releasing the job but BITS addrefs it.
    SAFERELEASE(pJob);

    // Pump messages if progress ui specified.
    if (dwFlags == DOWNLOAD_FLAGS_PROGRESS_UI)
    {
        MSG msg;
        BOOL bRet;
        DWORD dwError;
        while((bRet = GetMessage( &msg, _pDlg->_hwndDlg, 0, 0 )))
        {
            DWORD dwLow = LOWORD(msg.message);
            if (dwLow == WM_FINISH_DOWNLOAD || dwLow == WM_CANCEL_DOWNLOAD)
            {
                DestroyWindow(_pDlg->_hwndDlg);

                // BUGBUG: delete all committed files and app dir if canceling!
                if (dwLow == WM_CANCEL_DOWNLOAD)
                    hr = E_ABORT;
                
                break;
            }

            if (bRet == -1)
            {
                dwError = GetLastError();
                DebugBreak();
            }
            if (!IsDialogMessage(_pDlg->_hwndDlg, &msg))
            {
                TranslateMessage( &msg );
                DispatchMessage( &msg );
            }
        }

    }
    return hr;
}

// ---------------------------------------------------------------------------
// DoCacheUpdate
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::DoCacheUpdate(IBackgroundCopyJob *pJob)
{
    LPWSTR pwz             = NULL;
    DWORD nCount          = 0, cc = 0;
    SERIALIZED_LIST          ManifestList = {0};
    IEnumBackgroundCopyFiles *pEnumFiles = NULL;
    IBackgroundCopyFile       *pFile = NULL;
    IAssemblyCacheEmit       *pEmit = NULL;
    IAssemblyCacheImport     *pCacheImport = NULL;
    IBackgroundCopyJob       *pChildJob = NULL;
    CString sDisplayName;
    CString sManifestStagingDir;
    CString sManifestFilePath, sManifestPatchFilePath;
    LPASSEMBLY_IDENTITY pPatchAssemblyId = NULL;
    BOOL fAdditionalDependencies = FALSE;

    CAssemblyCache::GetCacheRootDir(sManifestStagingDir, CAssemblyCache::Staging);

    // Commit files to disk
    pJob->Complete();    

    // Get the file enumerator.
    pJob->EnumFiles(&pEnumFiles);
    pEnumFiles->GetCount(&nCount);

    for (DWORD i = 0; i < nCount; i++)            
    {
        CString sLocalName(CString::COM_Allocator);
        
        pEnumFiles->Next(1, &pFile, NULL);        
        pFile->GetLocalName(&pwz);
        sLocalName.TakeOwnership(pwz);

        // This is somewhat hacky - we rely on the local target path
        // returned from BITS to figure out if a manifest file.
        if (sLocalName.PathPrefixMatch(sManifestStagingDir._pwz) == S_OK)
        {
            // First thing we need to do is figure out if this
            // is a subscription manifest which we have to indirect 
            // through            
            LPASSEMBLY_MANIFEST_IMPORT pManifestImport = NULL;
            LPDEPENDENT_ASSEMBLY_INFO pDependAsmInfo = NULL;
            CString sManifestFileName;
            CString sDependantASMCodebase;
            DWORD dwManifestType = MANIFEST_TYPE_UNKNOWN;

            CreateAssemblyManifestImport(&pManifestImport, sLocalName._pwz);

            pManifestImport->ReportManifestType(&dwManifestType);
            if (dwManifestType == MANIFEST_TYPE_SUBSCRIPTION)
            {
                // BUGBUG: the hardcoded index '0'
                pManifestImport->GetNextAssembly(0, &pDependAsmInfo);
            }

            if (pDependAsmInfo)
            {
                // We know its a subscription
                // just transit to the referenced codebase.
                // BUGBUG - need to clean up the old manifest in staging dir.

                _hr = pDependAsmInfo->Get(DEPENDENT_ASM_CODEBASE, &pwz, &cc);
                sDependantASMCodebase.TakeOwnership(pwz, cc);

                if (sDependantASMCodebase._pwz)
                {
                    LPASSEMBLY_IDENTITY pAsmId = NULL;

                    // subscription's dependent asm's id == app's asm id (fully qualified)                    
                    if ((_hr = pDependAsmInfo->GetAssemblyIdentity(&pAsmId)) == S_OK)
                    {
                        CString sName;
                        
                        _hr = pAsmId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwz, &cc);
                        sName.TakeOwnership(pwz, cc);

                        // _hr from above GetAttribute
                        if (_hr == S_OK)
                        {
                            IAssemblyUpdate *pAssemblyUpdate = NULL;

                            // register for updates
                            if (SUCCEEDED(_hr = CoCreateInstance(CLSID_CAssemblyUpdate, NULL, CLSCTX_LOCAL_SERVER, 
                                                IID_IAssemblyUpdate, (void**)&pAssemblyUpdate)))
                            {
                                CString sRemoteName(CString::COM_Allocator);
                                LPWSTR pwzSubscriptionManifestCodebase = NULL;
                                DWORD pollingInterval;

                                pFile->GetRemoteName(&pwzSubscriptionManifestCodebase);
                                sRemoteName.TakeOwnership(pwzSubscriptionManifestCodebase);

                                // Get subscription polling interval from manifest
                                _hr = pManifestImport->GetPollingInterval (&pollingInterval);

                                _hr = pAssemblyUpdate->RegisterAssemblySubscription(sName._pwz, 
                                            sRemoteName._pwz, pollingInterval);

                                SAFERELEASE(pAssemblyUpdate);
                            }
                            // else
                                // Error in update services. Cannot register subscription for updates - fail gracefully
                                // BUGBUG: need a way to recover from this and register later
                                
                        }
                        // else
                            // Error in retrieving assembly name. Cannot register subscription for updates - fail gracefully
                            // BUGBUG: This should not be allowed!
    
                        // check if this download is necessary
                        // download only if not in cache
                        if ((_hr=CreateAssemblyCacheImport(&pCacheImport, pAsmId, CACHEIMP_CREATE_RETRIEVE_EXIST)) == S_FALSE)
                        {
                            if (_pDlg)
                            {
                                _pDlg->InitDialog(_pDlg->_hwndDlg);
                                _pDlg->SetDlgState(DOWNLOADDLG_STATE_GETTING_APP_MANIFEST);
                            }

                            _hr = DownloadManifestAndDependencies(sDependantASMCodebase._pwz, NULL, DOWNLOAD_FLAGS_INTERNAL_TRAVERSE_LINK);
                        }
                             
                        // else
                            // assume it's being handled or it's done

                        SAFERELEASE(pCacheImport);
                    }
                        
                    // BUGBUG: should check file integrity

                    SAFERELEASE(pAsmId);
                }                                          

                else
                    // redirected to a manifest which has no dependentassembly/codebase
                   _hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);


                SAFERELEASE(pDependAsmInfo);

                // We're done with the subscription manifest now
                // and can release the interface and delete it from the manifest staging dir.
                SAFERELEASE(pManifestImport);
                ::DeleteFile(sLocalName._pwz);
                
                goto exit;
            }
            SAFERELEASE(pManifestImport);
            
            // Not a subscription manifest - pull down dependencies.
            fAdditionalDependencies = TRUE;

            // Generate the cache entry (assemblydir/manifest/<dirs>)
            // First callbac, _pRootEmit = NULL;
            CreateAssemblyCacheEmit(&pEmit, _pRootEmit, 0);

            // Generate manifest file codebase directory
            // used for enqueuing parsed dependencies.
            CString sCodebase(CString::COM_Allocator);
            pFile->GetRemoteName(&pwz);
            sCodebase.TakeOwnership(pwz);
            sCodebase.LastElement(sManifestFileName);
            sCodebase.RemoveLastElement();
            sCodebase.Append(L"/");

            // Create the cache entry.
            // (x86_foo_1.0.0.0_en-us/foo.manifest/<+extra dirs>)
            pEmit->CopyFile(sLocalName._pwz, sManifestFileName._pwz, MANIFEST);

            // If this is first cache entry created, save as root.
            if (!_pRootEmit)
            {
                _pRootEmit = pEmit;
                _pRootEmit->AddRef();
            }        

            // QI for the import interface.
            pEmit->QueryInterface(IID_IAssemblyCacheImport, (LPVOID*) &pCacheImport);

            // First time through loop get the display name
            if (!i)
            {
                pCacheImport->GetDisplayName(&pwz, &cc);
                sDisplayName.TakeOwnership(pwz, cc);                
            }

            // Line up it's dependencies for download and fire them off.
            // We pass the cache import interface which provides the
            // manifest enumeration. We could just as easily passed a manifest
            // interface but already have one in the pCacheImport
            EnqueueDependencies(pCacheImport, sCodebase, sDisplayName, &pChildJob);

            SAFERELEASE(pEmit);
            SAFERELEASE(pCacheImport);
        }


        // if file was a patch file, find the source and target, apply patch to source and move result to target
        // or if file was compressed, uncompress file
        else
        {
            // Grab mainfest file directory and append on PATCH_DIRECTORY
            // "C:\Program Files\Application Store\x86_foo_X.X.X.X\PATCH_DIRECTORY\"
            _pRootEmit->GetManifestFileDir(&pwz, &cc);
            sManifestFilePath.TakeOwnership(pwz, cc);
            sManifestPatchFilePath.Assign(sManifestFilePath);
            sManifestPatchFilePath.Append(PATCH_DIRECTORY);

            // if local file begins with the manifests patch direcotry, file is a patch file
            if (sLocalName.PathPrefixMatch(sManifestPatchFilePath._pwz) == S_OK)
            {
                CString sPatchDisplayName;
                
                // init pPatchAssemblyId only once                    
                if (!pPatchAssemblyId)
                {
                    _hr = GetPatchDisplayNameFromFilePath (sLocalName, sPatchDisplayName);
                    CreateAssemblyIdentityEx(&pPatchAssemblyId, 0, sPatchDisplayName._pwz);
                }

                // Check to see if file is a cab file (have to revamp IsCABbed to handle this by passing in the AssemblyId)
                // If it is CABbed, then have to call the FDI functions and pass in base directory (should have relative paths in 
                // the cab .ddf file (done by tool).


                // using the patch file path, step through the manifest to to find
                // the source and target files associated with the patch file and
                // apply the patch file to the the source file to create the target file.                
                _hr = ApplyPatchFile (pPatchAssemblyId, sLocalName._pwz);
            }
        }

        SAFERELEASE(pFile);
    }

    // if patched, delete patch directory
    if (pPatchAssemblyId)
        _hr = RemoveDirectoryAndChildren(sManifestPatchFilePath._pwz);

    SAFERELEASE(pEnumFiles);

    // Submit the job.
    if (pChildJob)
    {
        if (_pDlg)
        {
            _pDlg->InitDialog(_pDlg->_hwndDlg);
            _pDlg->SetDlgState(DOWNLOADDLG_STATE_GETTING_OTHER_FILES);
            _pDlg->SetJob(pChildJob);
        }
        pChildJob->Resume();            
        SAFERELEASE(pChildJob);
    }

    // If no additional jobs 
    if (!fAdditionalDependencies)
    {
        // If we have a dialog then DoFinish will commit bits.
        // BUGBUG - formalize done semantics

        _pRootEmit->Commit(0);

        if (_hNamedEvent)
            SetEvent(_hNamedEvent);

        _pDlg->SetDlgState(DOWNLOADDLG_STATE_ALL_DONE);
    }
    
exit:
    SAFERELEASE(pPatchAssemblyId);

    return S_OK;
}


// ---------------------------------------------------------------------------
//GetPatchDisplayNameFromFilePath
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::GetPatchDisplayNameFromFilePath ( CString &sPatchFilePath, CString &sDisplayName)
{
    CString pwzFilePath;
    LPWSTR pwzStart, pwzEnd;

    pwzFilePath.Assign(sPatchFilePath);

    // Search file path for the PATCH_DIRECTORY
    pwzStart = StrStr(pwzFilePath._pwz, PATCH_DIRECTORY);

    // Set start pointer the one directory below the PATCH_DIRECTORY
    // This is the Beginning of the Patch DisplayNameb
    pwzStart = StrChr(pwzStart, L'\\');
    pwzStart++;
    
    // Set end pointer to the end of the Patch DisplayName and null out the character
    pwzEnd = StrChr(pwzStart, L'\\');
    (*pwzEnd) = L'\0';

    sDisplayName.Assign(pwzStart);

    return S_OK;
}


// ---------------------------------------------------------------------------
//ApplyPatchFile
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::ApplyPatchFile ( LPASSEMBLY_IDENTITY pPatchAssemblyId, LPWSTR pwzPatchFilePath)
{
    int i = 0;
    LPWSTR pwzSource = NULL, pwzTarget = NULL;
    LPWSTR pwzBuf;
    DWORD ccBuf;
    CString sPatchLocalName;
    CString sPatchDisplayName;
    CString sManifestDir, sPatchManifestDir;
    CString sSourcePath, sTargetPath, sPatchPath;
    IAssemblyManifestImport *pManifestImport = NULL;
    LPASSEMBLY_IDENTITY pTempPatchAssemblyId = NULL;
    LPASSEMBLY_CACHE_IMPORT pPatchImport = NULL;


    // Get DisplayName of the "Patch From" Assembly
    _hr = pPatchAssemblyId->GetDisplayName(ASMID_DISPLAYNAME_NOMANGLING, &pwzBuf, &ccBuf);
    sPatchDisplayName.TakeOwnership(pwzBuf, ccBuf);
    
    //Parse out the local file path from the full file path of the patch file
    pwzBuf= StrStr (pwzPatchFilePath, sPatchDisplayName._pwz);
    pwzBuf = StrChr(pwzBuf, L'\\');

    //Following commented out code needed for NULL patching
    /*
    // Take care of patching from "itself"
     if (StrStr (pwzPatchFilePath, sPatchDisplayName._pwz) != NULL)
     {
          pwzBuf= StrStr (pwzBuf, sPatchDisplayName._pwz);
          pwzBuf = StrChr(pwzBuf, L'\\');
     }
    */
    pwzBuf++;
    sPatchLocalName.Assign(pwzBuf);
   
    _pRootEmit->GetManifestImport(&pManifestImport);
    _pRootEmit->GetManifestFileDir(&pwzBuf, &ccBuf);
    sManifestDir.TakeOwnership (pwzBuf, ccBuf);

    // set up the patchAssemblyNode in the manifestimport
     while ((_hr = pManifestImport->GetNextPatchAssemblyId (i,  &pTempPatchAssemblyId)) == S_OK)
    {
        if(FAILED(_hr =pPatchAssemblyId->IsEqual(pTempPatchAssemblyId)))
            goto exit;
        else if (_hr == S_OK)
        {
            _hr = pManifestImport->SetPatchAssemblyNode(i);

            // get the cacheImport for the "patch from" assembly
             if ((_hr = CreateAssemblyCacheImport(&pPatchImport, pPatchAssemblyId, CACHEIMP_CREATE_RETRIEVE_EXIST_COMPLETED))!= S_OK)
                goto exit;
                            
            break;        
        }

        i++;
        SAFERELEASE(pTempPatchAssemblyId);
    }

    // there has to be a matching patchassembly node.
    if (_hr != S_OK)
        goto exit;
    
    pPatchImport->GetManifestFileDir(&pwzBuf, &ccBuf);
    sPatchManifestDir.TakeOwnership (pwzBuf, ccBuf);

    if((_hr = pManifestImport->GetPatchFilePatchMapping(sPatchLocalName._pwz, &pwzSource, &pwzTarget)) != S_OK)
        goto exit;

    // Set up paths of source, target and patch files
    // set up Source path
    // If NULL patching, must add code to call sSourcePath.FreeBuffer is pwzSource is NULL
/*        
    sSourcePath.Assign(sManifestDir);
    sSourcePath.Append(PATCH_DIRECTORY);
    sSourcePath.Append(sPatchDisplayName);
    sSourcePath.Append(L"\\");
*/

    sSourcePath.Append(sPatchManifestDir);
    sSourcePath.Append(pwzSource);
    
    // set up Target path
    sTargetPath.Assign(sManifestDir);
    sTargetPath.Append(pwzTarget);
           
    // set up Patch path
    sPatchPath.Assign(pwzPatchFilePath);

    //Apply patchfile to sSource (grab from patch directory) and copy to path specified by sTarget
    if (!(ApplyPatchToFile((LPCWSTR)sPatchPath._pwz, (LPCWSTR)sSourcePath._pwz, (LPCWSTR)sTargetPath._pwz, 0)))
        _hr = E_FAIL;

    goto exit;       
          
   
exit:
    SAFEDELETEARRAY(pwzSource);
    SAFEDELETEARRAY(pwzTarget);
    SAFERELEASE(pTempPatchAssemblyId);    
    SAFERELEASE(pManifestImport);
    SAFERELEASE(pPatchImport);
    
    return _hr;
}


// ---------------------------------------------------------------------------
// EnqueueDependencies
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::EnqueueDependencies(LPASSEMBLY_CACHE_IMPORT 
    pCacheImport, CString &sCodebase, CString &sDisplayName, IBackgroundCopyJob **ppJob)
{

    LPWSTR pwzBuf = NULL;
    LPWSTR pwzPatchFile, pwzSource;
    
    DWORD ccBuf   = 0;
    DWORD n = 0, i=0;

    BOOL patchAvailable = FALSE;
    BOOL CABbed = FALSE;

    CString sLocalPatchDirectoryPath, sPatchAssemblyDisplayName, sPatchManifestDirectory;
    CString sManifestDirectory;
    
    GUID guid = {0};
    IBackgroundCopyJob *pJob = NULL;
    IAssemblyManifestImport *pManifestImport = NULL;
    IAssemblyIdentity *pIdentity = NULL;
    IAssemblyFileInfo *pAssemblyFile = NULL;
    LPDEPENDENT_ASSEMBLY_INFO pDependAsm = NULL;
    LPASSEMBLY_CACHE_EMIT pCacheEmit = NULL;
    LPASSEMBLY_CACHE_IMPORT pMaxCachedImport = NULL;
    LPASSEMBLY_CACHE_IMPORT pMaxPatchImport = NULL;
    LPASSEMBLY_IDENTITY pPatchAssemblyId = NULL;


    // Create a new job
    if (*ppJob)
        pJob = *ppJob;
    else
    {
        g_pManager->CreateJob(sDisplayName._pwz,  BG_JOB_TYPE_DOWNLOAD, &guid, &pJob);
        pJob->SetNotifyInterface(static_cast<IBackgroundCopyCallback*> (this));    
        _hr = pJob->SetNotifyFlags(BG_NOTIFY_JOB_MODIFICATION | BG_NOTIFY_JOB_TRANSFERRED | BG_NOTIFY_JOB_ERROR);
        _hr = pJob->SetPriority(BG_JOB_PRIORITY_FOREGROUND);
   }
    
    // Get the cache import's manifest interface
    pCacheImport->GetManifestImport(&pManifestImport);

    // Get the asm Id
    _hr = pManifestImport->GetAssemblyIdentity(&pIdentity);

    // Find max completed version, if any
    // Init newly created cache import with the highest completed version
    // else S_FALSE or E_* and pMaxCachedImport == NULL - no completed version
    _hr = CreateAssemblyCacheImport(&pMaxCachedImport, pIdentity, CACHEIMP_CREATE_RETRIEVE_MAX_COMPLETED);
    
    // Check to see if there is a suitable upgradable version to patch from already in cache
    while (pManifestImport->GetNextPatchAssemblyId (i,  &pPatchAssemblyId) == S_OK)
    { 

        if (FAILED(_hr = CreateAssemblyCacheImport(&pMaxPatchImport, pPatchAssemblyId, CACHEIMP_CREATE_RETRIEVE_EXIST_COMPLETED)))
            goto exit;

        if (_hr == S_FALSE)
        {
                if(FAILED(_hr =pPatchAssemblyId->IsEqual(pIdentity)))
                    goto exit;
                else if (_hr == S_OK)
                {
                    pMaxPatchImport = pCacheImport;
                    pMaxPatchImport->AddRef();
                }
        }
                
        if (_hr == S_OK)          
        {
            // Set the patch assembly node
            pManifestImport->SetPatchAssemblyNode(i);
            
            // grab the manifest directory
            pCacheImport->GetManifestFileDir(&pwzBuf, &ccBuf);
            sManifestDirectory.TakeOwnership(pwzBuf, ccBuf);

            // get the manifest directory of the "patch from" directory
            pMaxPatchImport->GetManifestFileDir(&pwzBuf, &ccBuf);
            sPatchManifestDirectory.TakeOwnership(pwzBuf, ccBuf);
            
            //get display name of patch assembly identity
            _hr = (pPatchAssemblyId->GetDisplayName(ASMID_DISPLAYNAME_NOMANGLING, &pwzBuf, &ccBuf));
            sPatchAssemblyDisplayName.TakeOwnership (pwzBuf, ccBuf);

            //get the local path of the "patch to" directory
            sLocalPatchDirectoryPath.Assign(PATCH_DIRECTORY);
            sLocalPatchDirectoryPath.PathCombine(sPatchAssemblyDisplayName);
            sLocalPatchDirectoryPath.Append(L"\\");
            sLocalPatchDirectoryPath.PathNormalize();

            //create the patch directory
            CAssemblyCache::CreateDirectoryHierarchy(sManifestDirectory._pwz, sLocalPatchDirectoryPath._pwz);

            patchAvailable = TRUE;
            break;
        }

        i++;
        
        // Release pPatchAssemblyId every time through the loop
        // If the break is executed, the last pPatchAssemblyId is Released at end of the function
        SAFERELEASE (pPatchAssemblyId);
    }

    SAFERELEASE(pIdentity);

    // Lazy init. QI for the emit interface.
    if (!pCacheEmit)
        _hr = pCacheImport->QueryInterface(IID_IAssemblyCacheEmit, (LPVOID*) &pCacheEmit);

    if (!pCacheEmit)
    {
        _hr = E_FAIL;
        goto exit;                    
    }

    //Check to see if files are contained in a CAB. If so, entire pjob is the on cab file.
    if (patchAvailable)
    {
        LPWSTR pwzCabName;
        if ((_hr =pManifestImport->IsCABbed(&pwzCabName)) == S_OK)
        {
            n=0;
            CString sFileName;
            CString sLocalFilePath;
            CString sRemoteUrl;

            sFileName.TakeOwnership(pwzCabName);

             // Form local file path
            pCacheImport->GetManifestFileDir(&pwzBuf, &ccBuf);
            sLocalFilePath.TakeOwnership(pwzBuf, ccBuf);

            // Combine and ensure backslashes.
            sLocalFilePath.PathCombine(sFileName);
            sLocalFilePath.PathNormalize();
                 
            // Form remote name
            sRemoteUrl.Assign(sCodebase);
            sRemoteUrl.UrlCombine(sFileName);
             
            // add the file to the job.
            pJob->AddFile(sRemoteUrl._pwz, sLocalFilePath._pwz);

            CABbed = TRUE;
        }
    }

    
    // Submit files directly into their target dirs.
    while ((!CABbed) && (pManifestImport->GetNextFile(n++, &pAssemblyFile) == S_OK))
    {     
        CString sFileName;
        CString sLocalFilePath;
        CString sRemoteUrl;
        BOOL bSkipFile = FALSE;

        // File name parsed from manifest.
        pAssemblyFile->Get(ASM_FILE_NAME, &pwzBuf, &ccBuf);
        sFileName.TakeOwnership(pwzBuf, ccBuf);

        // Check against the max committed version
        if (pMaxCachedImport)
        {
            LPWSTR pwzPath = NULL;

            if ((_hr = pMaxCachedImport->FindExistMatching(pAssemblyFile, &pwzPath)) == S_OK)
            {               
                // Copy from existing cached copy to the new location
                // (Non-manifest files)
                if (SUCCEEDED(_hr = pCacheEmit->CopyFile(pwzPath, sFileName._pwz, OTHERFILES)))
                    bSkipFile = TRUE;

                SAFEDELETEARRAY(pwzPath);                
            }
        }

        if (!bSkipFile)
        {
            // Form local file path...
            // Manifest cache directory
            pCacheImport->GetManifestFileDir(&pwzBuf, &ccBuf);
            sLocalFilePath.TakeOwnership(pwzBuf, ccBuf);            

            if (patchAvailable)
            {
                if(FAILED(_hr = pManifestImport->GetTargetPatchMapping(sFileName._pwz, &pwzSource, &pwzPatchFile)))
                    goto exit;
                else if (_hr == S_OK)
                {
                    CString sLocalPatchDirFileName, sOrigFileName;
    
                    // Set up path of source file to be copied
                    sOrigFileName.Assign(sPatchManifestDirectory);
                    sOrigFileName.PathCombine(pwzSource);

                    // Set up local path of where the source file will be copied to.
                    sLocalPatchDirFileName.Assign(sLocalPatchDirectoryPath);
                    sLocalPatchDirFileName.PathCombine(pwzSource);

                    // Copy Source File into path directory
                    // _hr = pCacheEmit->CopyFile(sOrigFileName._pwz, sLocalPatchDirFileName._pwz, OTHERFILES);
                    sFileName.Assign (pwzPatchFile);

                    // Append the patch directory to local file path
                    sLocalFilePath.Append(sLocalPatchDirectoryPath);
                    CAssemblyCache::CreateDirectoryHierarchy(sLocalFilePath._pwz, sFileName._pwz);

                    SAFEDELETEARRAY(pwzSource);
                    SAFEDELETEARRAY(pwzPatchFile);

                }
            }

            // Form local file path continued from above if statement
            // Combine and ensure backslashes.
            sLocalFilePath.PathCombine(sFileName);
            sLocalFilePath.PathNormalize();
             
            // Form remote name
            sRemoteUrl.Assign(sCodebase);
            sRemoteUrl.UrlCombine(sFileName);
                
            // add the file to the job.
            pJob->AddFile(sRemoteUrl._pwz, sLocalFilePath._pwz);
        }

        SAFERELEASE(pAssemblyFile);        
    }
    
    // Submit assembly manifests into staging area
    // Note - we should also get assembly codebase and
    // use this instead or adjunctly to display name.
    // As is, there is a problem if the ref is partial.

    n = 0;
    while (pManifestImport->GetNextAssembly(n, &pDependAsm) == S_OK)
    {
        CString sAssemblyName;
        CString sLocalFilePath;
        CString sRemoteUrl;
        
        // Form local name (in staging area)....
        pDependAsm->GetAssemblyIdentity(&pIdentity);
        
        // Get the identity name
        pIdentity->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME,
            &pwzBuf, &ccBuf);
        sAssemblyName.TakeOwnership(pwzBuf, ccBuf);
        
        // Form local cache path from identity name.
        // BUG?
        CAssemblyCache::GetCacheRootDir(sLocalFilePath, CAssemblyCache::Staging);
        sLocalFilePath.Append(sAssemblyName);
        sLocalFilePath.Append(L".manifest");
        MakeSequentialFileName(sLocalFilePath);

        // Get remote name, if any specified
        pDependAsm->Get(DEPENDENT_ASM_CODEBASE, &pwzBuf, &ccBuf);
        if (pwzBuf != NULL)
            sRemoteUrl.TakeOwnership(pwzBuf, ccBuf);
        else
        {
            // Form remote name - probing, in effect.
            sRemoteUrl.Assign(sCodebase);
            sRemoteUrl.UrlCombine(sAssemblyName);
            sRemoteUrl.Append(L"/");
            sRemoteUrl.Append(sAssemblyName);
            sRemoteUrl.Append(L".manifest");
        }
        
        pJob->AddFile(sRemoteUrl._pwz, sLocalFilePath._pwz);
        SAFERELEASE(pIdentity);
        SAFERELEASE(pDependAsm);
        n++;        
    }        

    *ppJob = pJob;    
        
    _hr = S_OK;

exit:

    SAFERELEASE(pManifestImport);
    SAFERELEASE(pCacheEmit);
    SAFERELEASE(pMaxCachedImport);
    SAFERELEASE(pPatchAssemblyId);
    SAFERELEASE(pMaxPatchImport );

    return _hr;

}


// IBackgroundCopyCallback methods

// ---------------------------------------------------------------------------
// JobTransferred
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::JobTransferred(IBackgroundCopyJob *pJob)
{
    if (_pDlg)
        _pDlg->HandleCOMCallback(pJob, TRUE);

    _hr = DoCacheUpdate(pJob);
    return _hr;
}


// ---------------------------------------------------------------------------
// JobError
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::JobError(IBackgroundCopyJob *pJob, IBackgroundCopyError *pError)
{
    LPWSTR pwstr = NULL;
    pError->GetErrorDescription(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), &pwstr);
    // BUGBUG - need to do CoTaskMemFree on pwstr (or use a cstring)
//    _pDlg->HandleCOMCallback(pJob, TRUE);
    return S_OK;
}

// ---------------------------------------------------------------------------
// JobModification
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::JobModification(IBackgroundCopyJob *pJob, DWORD dwReserved)
{
    if (_pDlg)
        _pDlg->HandleCOMCallback(pJob, TRUE);
    return S_OK;
}

// Privates

// IUnknown methods

// ---------------------------------------------------------------------------
// CAssemblyDownload::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyDownload::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyDownload)
       )
    {
        *ppvObj = static_cast<IAssemblyDownload*> (this);
        AddRef();
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IBackgroundCopyCallback))
    {
        *ppvObj = static_cast<IBackgroundCopyCallback*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyDownload::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyDownload::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyDownload::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyDownload::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\file\assemblyfile.cpp ===
#include <fusenetincludes.h>
#include <assemblyfile.h>


// ---------------------------------------------------------------------------
// CreateAssemblyFile
// ---------------------------------------------------------------------------
STDAPI
CreateAssemblyFileInfo(
    LPASSEMBLY_FILE_INFO *ppAssemblyFile)
{
    HRESULT hr = S_OK;

    CAssemblyFileInfo *pAssemblyFile = NULL;

    pAssemblyFile = new(CAssemblyFileInfo);
    if (!pAssemblyFile)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    
exit:

    *ppAssemblyFile = static_cast<IAssemblyFileInfo*> (pAssemblyFile);

    return hr;
}

// ---------------------------------------------------------------------------
// IsEqualAssemblyFileInfo
// ---------------------------------------------------------------------------
BOOL
IsEqualAssemblyFileInfo(LPASSEMBLY_FILE_INFO pAsmFileInfo1, LPASSEMBLY_FILE_INFO pAsmFileInfo2)
{
    return (*(static_cast<CAssemblyFileInfo*> (pAsmFileInfo1))
        == *(static_cast<CAssemblyFileInfo*> (pAsmFileInfo2)));
}

// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CAssemblyFileInfo::CAssemblyFileInfo()
    : _dwSig('ELIF'), _cRef(1), _hr(S_OK)
{
    memset(_fi, 0, sizeof(_fi));
}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CAssemblyFileInfo::~CAssemblyFileInfo()
{
    for (DWORD i = ASM_FILE_NAME; i < ASM_FILE_MAX; i++)
        SAFEDELETEARRAY(_fi[i].pwzProperty);
}

// ---------------------------------------------------------------------------
// operator==
// ---------------------------------------------------------------------------
BOOL
CAssemblyFileInfo::operator==( CAssemblyFileInfo& asmFIRHS )
{
    BOOL bEqual = TRUE;

    for (DWORD i = ASM_FILE_NAME; i < ASM_FILE_MAX; i++)
    {
        // BUGBUG?: case sensitivity and issues?
        // BUGBUG?: locale?
        if (((_fi[i].pwzProperty) && !((asmFIRHS._fi[i]).pwzProperty)) ||
            (!(_fi[i].pwzProperty) && ((asmFIRHS._fi[i]).pwzProperty)) ||
            ((_fi[i].pwzProperty)
                && wcscmp(_fi[i].pwzProperty, (asmFIRHS._fi[i]).pwzProperty) != 0))
        {
            bEqual = FALSE;
            break;
        }
    }

    return bEqual;
}
   
// ---------------------------------------------------------------------------
// Set
// ---------------------------------------------------------------------------
HRESULT CAssemblyFileInfo::Set(DWORD dwId, LPCOLESTR pwzProperty)
{
    DWORD ccProperty = lstrlen(pwzProperty) + 1;
    LPWSTR pwzTmp = new WCHAR[ccProperty];
    if (!pwzTmp)
    {
        _hr = E_OUTOFMEMORY;
        goto exit;
    }
    memcpy(pwzTmp, pwzProperty, ccProperty * sizeof(WCHAR));
    SAFEDELETEARRAY(_fi[dwId].pwzProperty);
    _fi[dwId].pwzProperty = pwzTmp;
    _fi[dwId].ccProperty = ccProperty;
    
exit:
    return _hr;
}

// ---------------------------------------------------------------------------
// Get
// ---------------------------------------------------------------------------
HRESULT CAssemblyFileInfo::Get(DWORD dwId, LPOLESTR *ppwzProperty, LPDWORD pccProperty)
{
    *ppwzProperty = NULL;
    *pccProperty = 0;
    DWORD ccProperty = _fi[dwId].ccProperty ? _fi[dwId].ccProperty : 1;
    LPWSTR pwzProperty = new WCHAR[ccProperty];
    if (!pwzProperty)
    {
        _hr = E_OUTOFMEMORY;
        goto exit;
    }
    memcpy(pwzProperty, _fi[dwId].pwzProperty, ccProperty * sizeof(WCHAR));
    *ppwzProperty = pwzProperty;
    *pccProperty = ccProperty;

exit:
    return _hr;
}


// IUnknown Boilerplate

// ---------------------------------------------------------------------------
// CAssemblyFileInfo::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyFileInfo::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyFileInfo)
       )
    {
        *ppvObj = static_cast<IAssemblyFileInfo*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyFileInfo::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyFileInfo::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyFileInfo::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyFileInfo::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\download\dialog.cpp ===
#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#ifdef SIMPLEUI
#undef _WIN32_IE
#define _WIN32_IE 0x0500
#endif

#pragma warning( disable : 4786 )

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <math.h>
#include <float.h>
#include <commctrl.h>
#include <commdlg.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <wininet.h>
#include <shlobj.h>
#include <bits.h>
#include <comdef.h>
#include <fusenetincludes.h>
#include "resource.h"
#include "dialog.h"

#include <assemblydownload.h>

extern HINSTANCE g_hInst;

// Maxstring size, bump up on problems
#define MAX_STRING 0x800 // 2K

// BUGBUG - these two also have to be made per-instance
// adriaanc
GUID g_JobId;
#ifndef SIMPLEUI
WCHAR g_szFileName[MAX_PATH];
#else
WCHAR g_szFileName[] = { L"ClickOnce Application" };
#endif

// Received on update request while timer is active
LONG g_RefreshOnTimer = 0; 

#ifdef SIMPLEUI
bool g_IsMinimized = FALSE;

#define TRAY_UID 0

// note: ensure no conflict with other messages
#define MYWM_NOTIFYICON WM_USER+9
#endif

IBackgroundCopyManager *g_pManager = NULL;

HRESULT CreateDialogObject(CDownloadDlg **ppDlg, IBackgroundCopyJob *pJob)
{
    CDownloadDlg *pDlg = new CDownloadDlg;
    pDlg->SetJobObject(pJob);
    *ppDlg = pDlg;
    return (pDlg)->CreateUI(SW_SHOW);
}

VOID CDownloadDlg::SetJobObject(IBackgroundCopyJob *pJob)
{
    SAFERELEASE(_pJob);
    _pJob = pJob;
    _pJob->AddRef();
}

CDownloadDlg::CDownloadDlg()
{
    _pJob = NULL;
    _hwndDlg = NULL;
    _eState = DOWNLOADDLG_STATE_INIT;
}

CDownloadDlg::~CDownloadDlg()
{
    SAFERELEASE(_pJob);
}

const WCHAR * CDownloadDlg::GetString( UINT id )
{

    //
    // Retrieves the localized string for the resource id
    // caching the string when loaded.
    static const WCHAR* pStringArray[ IDS_MAX ];
    static WCHAR TempStringBuffer[ MAX_STRING ];
    const WCHAR * & pStringPointer = pStringArray[ id - 1 ];

    // Cache resource strings
    if ( pStringPointer )
        return pStringPointer;

    // Load string from resource

    int CharsLoaded =
        LoadStringW(
            (HINSTANCE)GetModuleHandle(L"fusenet.dll"),
            id,
            TempStringBuffer,
            MAX_STRING );

    if ( !CharsLoaded )
        return L"";

    WCHAR *pNewString = new WCHAR[ CharsLoaded + 1];
    if ( !pNewString )
        return L"";

    wcscpy( pNewString, TempStringBuffer );
    return ( pStringPointer = pNewString );

}

void CDownloadDlg::SetWindowTime(
    HWND hwnd,
    FILETIME filetime
    )
{
     // Set the window text to be the text representation
     // of the file time.
     // If an error occurs, set the window text to be error

     FILETIME localtime;
     FileTimeToLocalFileTime( &filetime, &localtime );

     SYSTEMTIME systemtime;
     FileTimeToSystemTime( &localtime, &systemtime );

     int RequiredDateSize =
         GetDateFormatW(
             LOCALE_USER_DEFAULT,
             0,
             &systemtime,
             NULL,
             NULL,
             0 );

     if ( !RequiredDateSize )
         {
         SetWindowText( hwnd, GetString( IDS_ERROR ) );
         return;
         }

     WCHAR *pszDateBuffer = (WCHAR*)alloca( sizeof(WCHAR) * (RequiredDateSize + 1) );

     int DateSize =
         GetDateFormatW(
             LOCALE_USER_DEFAULT,
             0,
             &systemtime,
             NULL,
             pszDateBuffer,
             RequiredDateSize );

     if (!DateSize)
         {
         SetWindowText( hwnd, GetString( IDS_ERROR ) );
         return;
         }

     int RequiredTimeSize =
         GetTimeFormatW(
             LOCALE_USER_DEFAULT,
             0,
             &systemtime,
             NULL,
             NULL,
             0 );

     if (!RequiredTimeSize)
         {
         SetWindowText( hwnd, GetString( IDS_ERROR ) );
         return;
         }

     WCHAR *pszTimeBuffer = (WCHAR*)alloca( sizeof( WCHAR ) * ( RequiredTimeSize + 1 ) );

     int TimeSize =
        GetTimeFormatW(
            LOCALE_USER_DEFAULT,
            0,
            &systemtime,
            NULL,
            pszTimeBuffer,
            RequiredTimeSize );

     if (!TimeSize)
         {
         SetWindowText( hwnd, GetString( IDS_ERROR ) );
         return;
         }

     // Add 2 for extra measure
     WCHAR *FullTime =
         (WCHAR*)alloca( sizeof( WCHAR ) *
                          ( RequiredTimeSize + RequiredDateSize + 2 ) );
     wsprintf( FullTime, L"%s %s", pszDateBuffer, pszTimeBuffer );

     SetWindowText( hwnd, FullTime );
}

UINT64 CDownloadDlg::GetSystemTimeAsUINT64()
{

    //
    // Returns the system time as an UINT instead of a FILETIME.
    //

    FILETIME filetime;
    GetSystemTimeAsFileTime( &filetime );

    ULARGE_INTEGER large;
    memcpy( &large, &filetime, sizeof(FILETIME) );

    return large.QuadPart;
}

void CDownloadDlg::SignalAlert(
    HWND hwndDlg,
    UINT Type
    )
{

    //
    // Alert the user that an important event has occurred
    //

    FLASHWINFO FlashInfo;
    FlashInfo.cbSize    = sizeof(FlashInfo);
    FlashInfo.hwnd      = hwndDlg;
    FlashInfo.dwFlags   = FLASHW_ALL | FLASHW_TIMERNOFG;
    FlashInfo.uCount    = 0;
    FlashInfo.dwTimeout = 0;

    FlashWindowEx( &FlashInfo );
    MessageBeep( Type );

}

const WCHAR *
CDownloadDlg::MapStateToString(
    BG_JOB_STATE state
    )
{

   //
   // Maps a BITS job state to a human readable string
   //

   switch( state )
       {

       case BG_JOB_STATE_QUEUED:
           return GetString( IDS_QUEUED );

       case BG_JOB_STATE_CONNECTING:
           return GetString( IDS_CONNECTING );

       case BG_JOB_STATE_TRANSFERRING:
           return GetString( IDS_TRANSFERRING );

       case BG_JOB_STATE_SUSPENDED:
           return GetString( IDS_SUSPENDED );

       case BG_JOB_STATE_ERROR:
           return GetString( IDS_FATALERROR );

       case BG_JOB_STATE_TRANSIENT_ERROR:
           return GetString( IDS_TRANSIENTERROR );

       case BG_JOB_STATE_TRANSFERRED:
           return GetString( IDS_TRANSFERRED );

       case BG_JOB_STATE_ACKNOWLEDGED:
           return GetString( IDS_ACKNOWLEDGED );

       case BG_JOB_STATE_CANCELLED:
           return GetString( IDS_CANCELLED );

       default:

           // NOTE: Always provide a default case
           // since new states may be added in future versions.
           return GetString( IDS_UNKNOWN );

       }
}

UINT64
CDownloadDlg::ScaleDownloadRate(
    double Rate, // rate in seconds
    const WCHAR **pFormat )
{

    //
    // Scales a download rate and selects the correct
    // format to pass to wprintf for printing.
    //

    double RateBounds[] =
    {
       1073741824.0, // Gigabyte
       1048576.0,    // Megabyte
       1024.0,       // Kilobyte
       0             // Byte
    };

    UINT RateFormat[] =
    {
        IDS_GIGAFORMAT,
        IDS_MEGAFORMAT,
        IDS_KILOFORMAT,
        IDS_BYTEFORMAT
    };

    for( unsigned int c = 0;; c++ )
        {
        if ( Rate >= RateBounds[c] )
            {
            *pFormat = GetString( RateFormat[c] );
            double scale = (RateBounds[c] >= 1.0) ? RateBounds[c] : 1.0;
            return (UINT64)floor( ( Rate / scale ) + 0.5);
            }
        }
}

UINT64
CDownloadDlg::ScaleDownloadEstimate(
    double Time, // time in seconds
    const WCHAR **pFormat )
{

    //
    // Scales a download time estimate and selects the correct
    // format to pass to wprintf for printing.
    //


    double TimeBounds[] =
    {
       60.0 * 60.0 * 24.0,        // Days
       60.0 * 60.0,               // Hours
       60.0,                      // Minutes
       0.0                        // Seconds
    };

    UINT TimeFormat[] =
    {
        IDS_DAYSFORMAT,
        IDS_HOURSFORMAT,
        IDS_MINUTESFORMAT,
        IDS_SECONDSFORMAT
    };

    for( unsigned int c = 0;; c++ )
        {
        if ( Time >= TimeBounds[c] )
            {
            *pFormat = GetString( TimeFormat[c] );
            double scale = (TimeBounds[c] >= 1.0) ? TimeBounds[c] : 1.0;
            return (UINT64)floor( ( Time / scale ) + 0.5);
            }
        }

}

void
CDownloadDlg::UpdateDialog(
    HWND hwndDlg
    )
{

   //
   // Main update routine for the dialog box.
   // Retries the job state/properties from
   // BITS and updates the dialog box.
   //

   {
   // update the display name
#ifndef SIMPLEUI
   HWND hwndDisplayName = GetDlgItem( hwndDlg, IDC_DISPLAYNAME );
   WCHAR * pszDisplayName = NULL;

   if (FAILED( _pJob->GetDisplayName( &pszDisplayName ) ) ) 
       return; // stop updating on an error
   SetWindowText( hwndDisplayName, pszDisplayName );
   ShowWindow( hwndDisplayName, SW_SHOW );

   CoTaskMemFree( pszDisplayName );
#endif
   }

   static BG_JOB_STATE prevstate = BG_JOB_STATE_SUSPENDED;
   BG_JOB_STATE state;

   if (FAILED(_pJob->GetState( &state )))
       return; // stop updating on an error

   if ( BG_JOB_STATE_ACKNOWLEDGED == state ||
        BG_JOB_STATE_CANCELLED == state )
       {
       // someone else cancelled or completed the job on us,
       // just exist the exit.
       // May happen if job is canceled with bitsadmin

//       DeleteStartupLink( g_JobId );
//       ExitProcess( 0 );

       // BUGBUG: Should post a CANCEL message to assemblydownload
       }

   BG_JOB_PROGRESS progress;
   if (FAILED(_pJob->GetProgress( &progress )))
       return; // stop updating on an error

   {
      // update the title, progress bar, and progress description
      WCHAR szProgress[MAX_STRING];
      WCHAR szTitle[MAX_STRING];
      WPARAM newpos = 0;

      if ( progress.BytesTotal &&
           ( progress.BytesTotal != BG_SIZE_UNKNOWN ) )
          {
          swprintf( szProgress, GetString( IDS_LONGPROGRESS ), progress.BytesTransferred,
                    progress.BytesTotal );

          double Percent = (double)(__int64)progress.BytesTransferred /
                           (double)(__int64)progress.BytesTotal;
          Percent *= 100.0;
          swprintf( szTitle, L"%u%% of %s Downloaded", (unsigned int)Percent, g_szFileName );
          newpos = (WPARAM)Percent;

          }
      else
          {
          swprintf( szProgress, GetString( IDS_SHORTPROGRESS ), progress.BytesTransferred );
          wcscpy( szTitle, g_szFileName );
          newpos = 0;
          }

      SendDlgItemMessage( hwndDlg, IDC_PROGRESSBAR, PBM_SETPOS, newpos, 0 );
      SetWindowText( GetDlgItem( hwndDlg, IDC_PROGRESSINFO ), szProgress );
      ShowWindow( GetDlgItem( hwndDlg, IDC_PROGRESSINFO ), SW_SHOW );
      EnableWindow( GetDlgItem( hwndDlg, IDC_PROGRESSINFOTXT ), TRUE );
      SetWindowText( hwndDlg, szTitle );

   }

   {
#ifndef SIMPLEUI
   // update the status
   HWND hwndStatus = GetDlgItem( hwndDlg, IDC_STATUS );

   SetWindowText( hwndStatus, MapStateToString( state ) );
   ShowWindow( hwndStatus, SW_SHOW );
#endif

   // Only enable the finish button if the job is finished.
// ADRIAANC   EnableWindow( GetDlgItem( hwndDlg, IDC_FINISH ), ( state == BG_JOB_STATE_TRANSFERRED ) );
   EnableWindow( GetDlgItem( hwndDlg, IDC_FINISH ), ( state == BG_JOB_STATE_ACKNOWLEDGED ) );

    // felixybc   BUGBUG: CANCEL is not allowed when the job is done
    //    - should hold off ACK-ing that job until user clicks FINISH so that it can still be canceled at 100%?
   EnableWindow( GetDlgItem( hwndDlg, IDC_CANCEL ), ( state != BG_JOB_STATE_ACKNOWLEDGED && state != BG_JOB_STATE_CANCELLED ) );
   
   // Only enable the suspend button if the job is not finished or transferred
   BOOL EnableSuspend =
       ( state != BG_JOB_STATE_SUSPENDED ) && ( state != BG_JOB_STATE_TRANSFERRED ) && (state != BG_JOB_STATE_ACKNOWLEDGED);
   EnableWindow( GetDlgItem( hwndDlg, IDC_SUSPEND ), EnableSuspend );

   // Only enable the resume button if the job is suspended
   BOOL EnableResume = ( BG_JOB_STATE_SUSPENDED == state );
   EnableWindow( GetDlgItem( hwndDlg, IDC_RESUME ), EnableResume );

   // Alert the user when something important happens
   // such as the job completes or a unrecoverable error occurs
#ifndef SIMPLEUI
   if ( BG_JOB_STATE_TRANSFERRED == state &&
        BG_JOB_STATE_TRANSFERRED != prevstate )
    {
          SignalAlert( hwndDlg, MB_OK );
//        DestroyWindow(hwndStatus);
    }
   else 
#endif
    if ( BG_JOB_STATE_ERROR == state &&
        BG_JOB_STATE_ERROR != prevstate )
       SignalAlert( hwndDlg, MB_ICONEXCLAMATION );

   }

#ifndef SIMPLEUI
   {
   // update times
   BG_JOB_TIMES times;
   if (FAILED(_pJob->GetTimes( &times )))
       return;

   HWND hwndCreationTime = GetDlgItem( hwndDlg, IDC_STARTTIME );
   SetWindowTime( hwndCreationTime, times.CreationTime );
   ShowWindow( hwndCreationTime, SW_SHOW );

   HWND hwndModificationTime = GetDlgItem( hwndDlg, IDC_MODIFICATIONTIME );
   SetWindowTime( hwndModificationTime, times.ModificationTime );
   ShowWindow( hwndModificationTime, SW_SHOW );

   HWND hwndCompletionTime = GetDlgItem( hwndDlg, IDC_COMPLETIONTIME );
   if ( !times.TransferCompletionTime.dwLowDateTime && !times.TransferCompletionTime.dwHighDateTime )
       {

       // BITS sets the CompletionTime to all zeros
       // if the job is incomplete

       ShowWindow( hwndCompletionTime, SW_HIDE );
       EnableWindow( GetDlgItem( hwndDlg, IDC_COMPLETIONTIMETXT ), FALSE );
       }
   else
       {
       SetWindowTime( hwndCompletionTime, times.TransferCompletionTime );
       ShowWindow( hwndCompletionTime, SW_SHOW );
       EnableWindow( GetDlgItem( hwndDlg, IDC_COMPLETIONTIMETXT ), TRUE );
       }
   }
#endif

   {
   // update the error message
   IBackgroundCopyError *pError;
   HRESULT Hr = _pJob->GetError( &pError );

   if ( FAILED(Hr) )
       {
       ShowWindow( GetDlgItem( hwndDlg, IDC_ERRORMSG ), SW_HIDE );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ERRORMSGTXT ), FALSE );
       }
   else
       {

       WCHAR* pszDescription = NULL;
       WCHAR* pszContext = NULL;
       SIZE_T SizeRequired = 0;

       // If these APIs fail, we should get back
       // a NULL string. So everything should be harmless.

       pError->GetErrorDescription(
           LANGIDFROMLCID( GetThreadLocale() ),
           &pszDescription );
       pError->GetErrorContextDescription(
           LANGIDFROMLCID( GetThreadLocale() ),
           &pszContext );

       if ( pszDescription )
           SizeRequired += wcslen( pszDescription );
       if ( pszContext )
           SizeRequired += wcslen( pszContext );

       WCHAR* pszFullText = (WCHAR*)_alloca((SizeRequired + 1) * sizeof(WCHAR));
       *pszFullText = L'\0';

       if ( pszDescription )
           wcscpy( pszFullText, pszDescription );
       if ( pszContext )
           wcscat( pszFullText, pszContext );
       CoTaskMemFree( pszDescription );
       CoTaskMemFree( pszContext );

       HWND hwndErrorText = GetDlgItem( hwndDlg, IDC_ERRORMSG );
       SetWindowText( hwndErrorText, pszFullText );
       ShowWindow( hwndErrorText, SW_SHOW );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ERRORMSGTXT ), TRUE );

       }

   }

#ifndef SIMPLEUI
   if (!SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_GETDROPPEDSTATE, 0, 0) )
       {
       // set the priority, but only do it if user isn't trying to
       // set the priority.
       BG_JOB_PRIORITY priority;
       _pJob->GetPriority( &priority );
       SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_SETCURSEL, (WPARAM)priority, 0 );
       }
#endif

   {

   //
   // This large block of text computes the average transfer rate
   // and estimated completion time.  This code has much
   // room for improvement.
   //

   static BOOL HasRates = FALSE;
   static UINT64 LastMeasurementTime;
   static UINT64 LastMeasurementBytes;
   static double LastMeasurementRate;

   WCHAR szRateText[MAX_STRING];
   BOOL EnableRate = FALSE;

   if ( !( BG_JOB_STATE_QUEUED == state ) &&
        !( BG_JOB_STATE_CONNECTING == state ) &&
        !( BG_JOB_STATE_TRANSFERRING == state ) )
       {
       // If the job isn't running, then rate values won't
       // make any sense. Don't display them.
       HasRates = FALSE;
       }
   else
       {

       if ( !HasRates )
           {
           LastMeasurementTime = GetSystemTimeAsUINT64();
           LastMeasurementBytes = progress.BytesTransferred;
           LastMeasurementRate = 0;
           HasRates = TRUE;
           }
       else
           {

           UINT64 CurrentTime = GetSystemTimeAsUINT64();
           UINT64 NewTotalBytes = progress.BytesTransferred;

           UINT64 NewTimeDiff = CurrentTime - LastMeasurementTime;
           UINT64 NewBytesDiff = NewTotalBytes - LastMeasurementBytes;
           double NewInstantRate = (double)(__int64)NewBytesDiff /
                                   (double)(__int64)NewTimeDiff;
           double NewAvgRate = (0.3 * LastMeasurementRate) +
                               (0.7 * NewInstantRate );

           if ( !_finite(NewInstantRate) || !_finite(NewAvgRate) )
               {
               NewInstantRate = 0;
               NewAvgRate = LastMeasurementRate;
               }

           LastMeasurementTime = CurrentTime;
           LastMeasurementBytes = NewTotalBytes;
           LastMeasurementRate = NewAvgRate;

           // convert from FILETIME units to seconds
           double NewDisplayRate = NewAvgRate * 10000000;

           const WCHAR *pRateFormat = NULL;
           UINT64 Rate = ScaleDownloadRate( NewDisplayRate, &pRateFormat );
           wsprintf( szRateText, pRateFormat, Rate );
           
           EnableRate = TRUE;
           }

       }

   if (!EnableRate)
       {
       ShowWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATE ), SW_HIDE );
       EnableWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATETXT ), FALSE );
       }
   else
       {
       SetWindowText( GetDlgItem( hwndDlg, IDC_TRANSFERRATE ), szRateText );
       ShowWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATE ), SW_SHOW );
       EnableWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATETXT ), TRUE );
       }

   BOOL EnableEstimate = FALSE;
   WCHAR szEstimateText[MAX_STRING];

   if ( EnableRate )
       {

       if ( progress.BytesTotal != 0 &&
            progress.BytesTotal != BG_SIZE_UNKNOWN )
           {

           double TimeRemaining =
               ( (__int64)progress.BytesTotal - (__int64)LastMeasurementBytes ) / LastMeasurementRate;

           // convert from FILETIME units to seconds
           TimeRemaining = TimeRemaining / 10000000.0;

           static const double SecsPer30Days = 60.0 * 60.0 * 24.0 * 30.0;

           // Don't estimate if estimate is larger then 30 days.
           if ( TimeRemaining < SecsPer30Days )
               {

               const WCHAR *pFormat = NULL;
               UINT64 Time = ScaleDownloadEstimate( TimeRemaining, &pFormat );
               wsprintf( szEstimateText, pFormat, Time );
               EnableEstimate = TRUE;
               }
           }
       }

   if (!EnableEstimate)
       {
       ShowWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIME ), SW_HIDE );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIMETXT ), FALSE );
       }
   else
       {
       SetWindowText( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIME ), szEstimateText );
       ShowWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIME ), SW_SHOW );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIMETXT ), TRUE );
       }

   }

   prevstate = state;
}

void
CDownloadDlg::InitDialog(
    HWND hwndDlg
    )
{

   //
   // Populate the priority list with priority descriptions
   //

   _hwndDlg = hwndDlg;

#ifndef SIMPLEUI   
   const WCHAR *Foreground    = GetString( IDS_FOREGROUND );
   const WCHAR *High          = GetString( IDS_HIGH );
   const WCHAR *Normal        = GetString( IDS_NORMAL );
   const WCHAR *Low           = GetString( IDS_LOW );
#endif

   SendDlgItemMessage( hwndDlg, IDC_PROGRESSBAR, PBM_SETRANGE, 0, MAKELPARAM(0, 100) );
#ifndef SIMPLEUI
   SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_ADDSTRING, 0, (LPARAM)Foreground );
   SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_ADDSTRING, 0, (LPARAM)High );
   SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_ADDSTRING, 0, (LPARAM)Normal );
   SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_ADDSTRING, 0, (LPARAM)Low );
#endif

}

void CDownloadDlg::CheckHR( HWND hwnd, HRESULT Hr, bool bThrow )
{
    //
    // Provides automatic error code checking and dialog
    // for generic system errors
    //

    if (SUCCEEDED(Hr))
        return;

    WCHAR * pszError = NULL;

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        (DWORD)Hr,
        LANGIDFROMLCID( GetThreadLocale() ),
        (WCHAR*)&pszError,
        0,
        NULL );

    MessageBox( hwnd, pszError, GetString( IDS_ERRORBOXTITLE ),
                MB_OK | MB_ICONSTOP | MB_APPLMODAL );
    LocalFree( pszError );

    if ( bThrow )
        throw _com_error( Hr );

}

void CDownloadDlg::BITSCheckHR( HWND hwnd, HRESULT Hr, bool bThrow )
{

   //
   // Provides automatic error code checking and dialog
   // for BITS specific errors
   //


   if (SUCCEEDED(Hr))
       return;

   WCHAR * pszError = NULL;
   g_pManager->GetErrorDescription(
       Hr,
       LANGIDFROMLCID( GetThreadLocale() ),
       &pszError );

   MessageBox( hwnd, pszError, GetString( IDS_ERRORBOXTITLE ),
               MB_OK | MB_ICONSTOP | MB_APPLMODAL );
   CoTaskMemFree( pszError );

   if ( bThrow )
       throw _com_error( Hr );
}

void
CDownloadDlg::DoCancel(
    HWND hwndDlg,
    bool PromptUser
    )
{

   //
   // Handle all the operations required to cancel the job.
   // This includes asking the user for confirmation.
   //

   if ( PromptUser )
       {

       int Result =
           MessageBox(
               hwndDlg,
               GetString( IDS_CANCELTEXT ),
               GetString( IDS_CANCELCAPTION ),
               MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL |
               MB_SETFOREGROUND | MB_TOPMOST );


       if ( IDYES != Result )
           return;

       }

//   try
   {
       BITSCheckHR( hwndDlg, _pJob->Cancel(), false );//felixybc true );
   }
//   catch( _com_error Error )
   {
       // If we can't cancel for some unknown reason,
       // don't exit
//       return;
   }

//   DeleteStartupLink( g_JobId );
//felixybc   ExitProcess( 0 );
KillTimer(hwndDlg, 0);
PostMessage(hwndDlg, WM_CANCEL_DOWNLOAD, 0, 0);
}

void
CDownloadDlg::DoFinish(
    HWND hwndDlg
    )
{

   //
   // Handles all the necessary work to complete
   // the download.
   //

//   try
   {
// ADRIAANC
//       BITSCheckHR( hwndDlg, _pJob->Complete(), true );
   }
//   catch( _com_error Error )
   {
       // If we can't finish/complete for some unknown reason,
       // don't exit
 //      return;
   }

//   DeleteStartupLink( g_JobId );
// ExitProcess( 0 );

// Commit the bits and notify done.
//_pDownload->_pRootEmit->Commit(0);
KillTimer(hwndDlg, 0);
PostMessage(hwndDlg, WM_FINISH_DOWNLOAD, 0, 0);

return;

}

void
CDownloadDlg::DoClose(
    HWND hwndDlg
    )
{
    //
    // Handles an attempt by the user to close the sample.
    //

    // Check to see if the download has finished,
    // if so don't let the user exit.

    BG_JOB_STATE state;
    HRESULT hResult = _pJob->GetState( &state );

    if (FAILED( hResult ))
        {
        BITSCheckHR( hwndDlg, hResult, false );
        return;
        }

    // BUGBUG: should also check for BG_JOB_STATE_ACKNOWLEDGED and don't call DoCancel then
    
    if ( BG_JOB_STATE_ERROR == state ||
         BG_JOB_STATE_TRANSFERRED == state )
        {

        MessageBox(
            hwndDlg,
            GetString( IDS_ALREADYFINISHED ),
            GetString( IDS_ALREADYFINISHEDCAPTION ),
            MB_OK | MB_ICONERROR | MB_DEFBUTTON1 | MB_APPLMODAL |
            MB_SETFOREGROUND | MB_TOPMOST );


        return;
        }


    //
    // Inform the user that he selected close and ask
    // confirm the intention to exit.  Explain that the job 
    // will be canceled.

    int Result =
        MessageBox(
            hwndDlg,
            GetString( IDS_CLOSETEXT ),
            GetString( IDS_CLOSECAPTION ),
            MB_OKCANCEL | MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL |
            MB_SETFOREGROUND | MB_TOPMOST );

    if ( IDOK == Result )
        {
        
        // User confirmed the cancel, just do it.

        DoCancel( hwndDlg, false );
        return;
        }

    // The user didn't really want to exit, so ignore him
    else
        return;

}

void
CDownloadDlg::HandleTimerTick( HWND hwndDlg )
{
    // The timer fired. Update dialog.
    UpdateDialog( hwndDlg );

#ifdef SIMPLEUI
    if (_eState == DOWNLOADDLG_STATE_ALL_DONE)
    {
        static bool bHasTip = FALSE;
        if (!g_IsMinimized)
        {
            // not minimized, continue to run app
            DoFinish(hwndDlg);
        }
        else
        {
            if (!bHasTip)
            {
                // minimized, pop up buttom tip
                NOTIFYICONDATA tnid = {0};

                // ignore all error

                tnid.cbSize = sizeof(NOTIFYICONDATA);
                tnid.hWnd = hwndDlg;
                tnid.uID = TRAY_UID;
                tnid.uFlags = NIF_INFO;

                tnid.uTimeout = 20000; // in milliseconds
                tnid.dwInfoFlags = NIIF_INFO;
                lstrcpyn(tnid.szInfoTitle, L"ClickOnce application ready!", (sizeof(tnid.szInfoTitle)/sizeof(tnid.szInfoTitle[0])));
                lstrcpyn(tnid.szInfo, L"Click this notification icon to start. You can also find this new application on your Start Menu, Programs listing.", (sizeof(tnid.szInfo)/sizeof(tnid.szInfo[0])));

                Shell_NotifyIcon(NIM_MODIFY, &tnid);
                bHasTip = TRUE;
            }
        }
    }
#endif
}

HRESULT
CDownloadDlg::HandleUpdate()
{

    // Handle a update request, batching the update if needed
    DWORD dwRefresh = 0;
    dwRefresh = InterlockedIncrement(&g_RefreshOnTimer);
    if (dwRefresh == 1)
    {
        // First time in; fire off timer and update the dialog.
        UpdateDialog(_hwndDlg);
        SetTimer( _hwndDlg, 0, 500, NULL );
    }
    else
    {
        // We've already received the first callback.
        // Let the timer do any further work.
        InterlockedDecrement(&g_RefreshOnTimer);    
    }
    return S_OK;

}


 INT_PTR CALLBACK DialogProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
  )
{
  //
  // Dialog proc for main dialog window
  //
  static CDownloadDlg *pDlg = NULL;

  switch( uMsg )
      {

      case WM_DESTROY:
      {
#ifdef SIMPLEUI
            Animate_Stop(GetDlgItem(hwndDlg, IDC_ANIMATE_DOWNLOAD));
            Animate_Close(GetDlgItem(hwndDlg, IDC_ANIMATE_DOWNLOAD));
#endif
          return FALSE;
      }
      case WM_INITDIALOG:
          pDlg = (CDownloadDlg*) lParam;
          pDlg->InitDialog(hwndDlg);
#ifdef SIMPLEUI
            ShowWindow(GetDlgItem(hwndDlg, IDC_ANIMATE_DOWNLOAD), SW_SHOW);
            Animate_Open(GetDlgItem(hwndDlg, IDC_ANIMATE_DOWNLOAD), MAKEINTRESOURCE(IDA_DOWNLOADING));
            Animate_Play(GetDlgItem(hwndDlg, IDC_ANIMATE_DOWNLOAD), 0, -1, -1);
#endif
          return TRUE;

      case WM_TIMER:
          pDlg->HandleTimerTick( hwndDlg );
          return TRUE;


      case WM_CLOSE:
          pDlg->DoClose( hwndDlg );
          return TRUE;

      case WM_COMMAND:

          switch( LOWORD( wParam ) )
              {

              case IDC_RESUME:
                  pDlg->BITSCheckHR( hwndDlg, pDlg->_pJob->Resume(), false );
                  return TRUE;

              case IDC_SUSPEND:
                  pDlg->BITSCheckHR( hwndDlg, pDlg->_pJob->Suspend(), false );
                  return TRUE;

              case IDC_CANCEL:
                  pDlg->DoCancel( hwndDlg, true );
                  return TRUE;

              case IDC_FINISH:
                  pDlg->DoFinish( hwndDlg );
                  return TRUE;

#ifndef SIMPLEUI
              case IDC_PRIORITY:
                  switch( HIWORD( wParam ) )
                      {

                      case CBN_SELENDOK:

                          // User clicked on priority,
                          // update it.

                          pDlg->BITSCheckHR( hwndDlg,
                          pDlg->_pJob->SetPriority( (BG_JOB_PRIORITY)

                                  SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_GETCURSEL, 0, 0 ) ), false );
                          return TRUE;

                      case CBN_SELENDCANCEL:
                          return TRUE;

                      default:
                          return FALSE;
                      }
#endif
              default:
                  return FALSE;
              }

#ifdef SIMPLEUI
      case WM_SIZE:

        if (wParam == SIZE_MINIMIZED)
        {
            HICON hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_ICON));

           if (hIcon != NULL)
           {
                NOTIFYICONDATA tnid = {0};
                
                // ignore all error (user will not be able to restore dialog in some cases)

                tnid.cbSize = sizeof(NOTIFYICONDATA);
                tnid.hWnd = hwndDlg;
                tnid.uID = TRAY_UID;
                tnid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;
                tnid.uCallbackMessage = MYWM_NOTIFYICON;
                tnid.hIcon = hIcon;
                lstrcpyn(tnid.szTip, L"Downloading ClickOnce application.", (sizeof(tnid.szTip)/sizeof(tnid.szTip[0]))); // set tip to file name
                Shell_NotifyIcon(NIM_ADD, &tnid);

                DestroyIcon(hIcon);

                // set shell32 v5 behavior
                tnid.uVersion = NOTIFYICON_VERSION;
                tnid.uFlags = 0;
                Shell_NotifyIcon(NIM_SETVERSION, &tnid);

                // hide window
                ShowWindow( hwndDlg, SW_HIDE );
                g_IsMinimized = TRUE;
                return TRUE;
           }
           // else error loading icon - ignore
        }

        return FALSE;

      case MYWM_NOTIFYICON:
        if (g_IsMinimized && (lParam == WM_CONTEXTMENU || lParam == NIN_KEYSELECT || lParam == NIN_SELECT ))
        {
            // if the notification icon is clicked on

            NOTIFYICONDATA tnid = {0};

            // show window
            ShowWindow( hwndDlg, SW_RESTORE );
            g_IsMinimized = FALSE;

            // remove icon from tray
            tnid.cbSize = sizeof(NOTIFYICONDATA);
            tnid.hWnd = hwndDlg;
            tnid.uID = TRAY_UID;
            tnid.uFlags = 0;
            Shell_NotifyIcon(NIM_DELETE, &tnid);

            return TRUE;
        }

        return FALSE;
#endif
      default:
          return FALSE;
      }
}


HRESULT
CDownloadDlg::HandleCOMCallback(
    IBackgroundCopyJob* pJob,
    bool CriticalEvent
    )
{

    // In addition to the work of HandleUpdate,
    // this function checks to see if we've
    // already initialized the manager.  If not,
    // do it now.

    g_pManager = CAssemblyDownload::g_pManager;
    
/*
    if ( !g_pManager )
        {

//        try
        {
            CheckHR( NULL,
                     CoCreateInstance( CLSID_BackgroundCopyManager,
                         NULL,
                         CLSCTX_LOCAL_SERVER,
                         IID_IBackgroundCopyManager,
                         (void**)&g_pManager ), true );

            //pJob->AddRef();
            //_pJob = pJob;

            BITSCheckHR( NULL, _pJob->SetNotifyFlags( BG_NOTIFY_JOB_MODIFICATION ), true );

            // As an optimization, set the notification interface to be the callback
            // It shouldn't matter if this fails
            // BUGBUG - what the heck does that mean? adriaanc
//                _pJob->SetNotifyInterface( (IBackgroundCopyCallback*)&g_Callback );

            HRESULT Hr = HandleUpdate();

            ShowWindow(_hwndDlg, CriticalEvent ? SW_NORMAL : SW_MINIMIZE);

        }

            HRESULT Hr = HandleUpdate();
            ShowWindow(_hwndDlg, CriticalEvent ? SW_NORMAL : SW_MINIMIZE);


        catch(_com_error error )
        {
            if ( g_pManager )
                g_pManager->Release();
            g_pManager = NULL;

            if ( _pJob )
                _pJob->Release();
            _pJob = NULL;

            return error.Error();
        }
        }
*/

    return HandleUpdate();
}

HRESULT
CDownloadDlg::CreateUI( int nShowCmd )
{
    HINSTANCE hinstance = GetModuleHandle(L"fusenet.dll");
    DWORD dwError = 0;
    //
    // Creates the dialog box for the sample.
    //    
  InitCommonControls();

    _hwndDlg =
      CreateDialogParam(
        g_hInst,
        MAKEINTRESOURCE(IDD_DIALOG),
        NULL,
         DialogProc,
         (LPARAM) (this));

    if (!_hwndDlg)
    {
        dwError = GetLastError();
        return HRESULT_FROM_WIN32(dwError);
    }

    ShowWindow(_hwndDlg, nShowCmd);

    return S_OK;
}

void CDownloadDlg::ResumeJob(
    WCHAR* szJobGUID,
    WCHAR* szJobFileName
    )
{

    //
    // Resume the display on an existing job
    //

//    try
    {
#ifndef SIMPLEUI
        wcscpy( g_szFileName, szJobFileName );
#endif
        CheckHR( NULL, IIDFromString( szJobGUID, &g_JobId ), true );

        CheckHR( NULL,
                 CoCreateInstance( CLSID_BackgroundCopyManager,
                     NULL,
                     CLSCTX_LOCAL_SERVER,
                     IID_IBackgroundCopyManager,
                     (void**)&g_pManager ), true );

        BITSCheckHR( NULL, g_pManager->GetJob( g_JobId, &_pJob ), true );

// BUGBUG - bits dialog class doesn't know about callbacks - adriaanc

//        BITSCheckHR( NULL,
//                     _pJob->SetNotifyInterface( (IBackgroundCopyCallback*)&g_Callback ),
//                     true );

        BITSCheckHR( NULL, _pJob->SetNotifyFlags( BG_NOTIFY_JOB_MODIFICATION ), true );

        ShowWindow(_hwndDlg, SW_MINIMIZE );
        HandleUpdate();
    }
/*
    catch(_com_error error )
    {
        ExitProcess( error.Error() );
    }
*/
}

void CDownloadDlg::SetJob(IBackgroundCopyJob *pJob)
{
    SAFERELEASE(_pJob);
    _pJob = pJob;
    _pJob->AddRef();
}

void CDownloadDlg::SetDlgState(DOWNLOADDLG_STATE eState)
{
    _eState = eState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\id\assemblyidentity.cpp ===
#include <fusenetincludes.h>
#include <msxml2.h>
#include <sxsid.h>
#include <assemblyidentity.h>
#include <shlwapi.h>

// ---------------------------------------------------------------------------
// CreateAssemblyIdentity
// ---------------------------------------------------------------------------
STDAPI
CreateAssemblyIdentity(
    LPASSEMBLY_IDENTITY *ppAssemblyId,
    DWORD                dwFlags)
{
    HRESULT hr = S_OK;

    CAssemblyIdentity *pAssemblyId = NULL;

    pAssemblyId = new(CAssemblyIdentity);
    if (!pAssemblyId)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = pAssemblyId->Init();
    if (FAILED(hr))
    {
        SAFERELEASE(pAssemblyId);
        goto exit;
    }

exit:

    *ppAssemblyId = pAssemblyId;

    return hr;
}


STDAPI
CreateAssemblyIdentityEx(
    LPASSEMBLY_IDENTITY *ppAssemblyId,
    DWORD                dwFlags,
    LPWSTR wzDisplayName)
{
    HRESULT hr = S_OK;

    CAssemblyIdentity *pAssemblyId = NULL;

    pAssemblyId = new(CAssemblyIdentity);
    if (!pAssemblyId)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = pAssemblyId->Init();
    if (FAILED(hr))
    {
        SAFERELEASE(pAssemblyId);
        goto exit;
    }

    if (wzDisplayName)
    {
        LPWSTR pwzStart, pwzEnd;
        CString Temp[4];
        CString sDirName;
        int i=0;

        sDirName.Assign(wzDisplayName);
        pwzStart = sDirName._pwz;
        pwzEnd = sDirName._pwz;
                
        while (pwzEnd = StrChr(pwzEnd, L'_'))
        {
            *pwzEnd = L'\0';
            Temp[i++].Assign(pwzStart);
            pwzStart = ++pwzEnd;
        }
        pAssemblyId->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE, 
            (LPCOLESTR)pwzStart, lstrlen(pwzStart) + 1);
        pAssemblyId->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION, 
            (LPCOLESTR)Temp[3]._pwz, lstrlen(Temp[3]._pwz) + 1);
        pAssemblyId->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN, 
            (LPCOLESTR)Temp[2]._pwz, lstrlen(Temp[2]._pwz) + 1);
        pAssemblyId->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, 
            (LPCOLESTR)Temp[1]._pwz, lstrlen(Temp[1]._pwz) + 1);
        pAssemblyId->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE,
            (LPCOLESTR)Temp[0]._pwz, lstrlen(Temp[0]._pwz) + 1);
    }

exit:

    *ppAssemblyId = pAssemblyId;

    return hr;
}


// ---------------------------------------------------------------------------
// CloneAssemblyIdentity
// ---------------------------------------------------------------------------
STDAPI
CloneAssemblyIdentity(
    LPASSEMBLY_IDENTITY pSrcAssemblyId,
    LPASSEMBLY_IDENTITY *ppDestAssemblyId)
{
    HRESULT hr = S_OK;
    CAssemblyIdentity *pAssemblyId = NULL;

    if (pSrcAssemblyId == NULL || ppDestAssemblyId == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *ppDestAssemblyId = NULL;

    if (FAILED(hr = CreateAssemblyIdentity((LPASSEMBLY_IDENTITY*) &pAssemblyId, 0)))
        goto exit;

    if (!SxsDuplicateAssemblyIdentity(0, (static_cast<CAssemblyIdentity*> (pSrcAssemblyId))->_pId,
        &(pAssemblyId->_pId)))
    {
        DWORD dw = ::GetLastError();
        hr = HRESULT_FROM_WIN32(dw);
        goto exit;
    }

    *ppDestAssemblyId = pAssemblyId;
exit:
    return hr;
}


// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CAssemblyIdentity::CAssemblyIdentity()
   : _dwSig('TNDI'), _cRef(1), _hr(S_OK), _pId(NULL)
{
}    


// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CAssemblyIdentity::~CAssemblyIdentity()
{
    SxsDestroyAssemblyIdentity(_pId);
}

// ---------------------------------------------------------------------------
// Init
// ---------------------------------------------------------------------------
HRESULT CAssemblyIdentity::Init()
{
    if (!SxsCreateAssemblyIdentity(0, ASSEMBLY_IDENTITY_TYPE_DEFINITION, &_pId, 0, NULL))
    {
        DWORD dw = ::GetLastError();
        _hr = HRESULT_FROM_WIN32(dw);
    }
    else
        _hr = S_OK;

    return _hr;
}

// ---------------------------------------------------------------------------
// SetAttribute
// ---------------------------------------------------------------------------
HRESULT CAssemblyIdentity::SetAttribute(LPCOLESTR pwzName, 
    LPCOLESTR pwzValue, DWORD ccValue)
{
    DWORD ccName = lstrlen(pwzName);

    SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttrRef;

    AttrRef.Namespace = SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE;
    AttrRef.NamespaceCch = SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE_CCH;
    AttrRef.Name = pwzName;
    AttrRef.NameCch = ccName;

    // BUGBUG: should allow overwrite or not?
    if (!SxspSetAssemblyIdentityAttributeValue(
            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
            _pId, &AttrRef, pwzValue, ccValue))
    {
        DWORD dw = ::GetLastError();
        _hr = HRESULT_FROM_WIN32(dw);
    }
    else
        _hr = S_OK;

    return _hr;

}


// ---------------------------------------------------------------------------
// GetAttribute
// ---------------------------------------------------------------------------
HRESULT CAssemblyIdentity::GetAttribute(LPCOLESTR pwzName, 
    LPOLESTR *ppwzValue, LPDWORD pccValue)
{
    LPWSTR pwzValue = NULL;
    PCWSTR pwzStringOut = NULL;
    DWORD ccStringOut = 0;
    DWORD ccName = lstrlen(pwzName);
    
    SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttrRef;

    AttrRef.Namespace = SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE;
    AttrRef.NamespaceCch = SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE_CCH;
    AttrRef.Name = pwzName;
    AttrRef.NameCch = ccName;
    
    if (!SxspGetAssemblyIdentityAttributeValue(0, _pId, &AttrRef, &pwzStringOut, &ccStringOut))
    {
        DWORD dw = ::GetLastError();
        _hr = HRESULT_FROM_WIN32(dw);
        goto exit;
    }

    pwzValue = WSTRDupDynamic(pwzStringOut);
    if (!pwzValue)
    {
        _hr = E_OUTOFMEMORY;
        goto exit;
    }
    _hr = S_OK;
        
    *ppwzValue = pwzValue;
    *pccValue = ccStringOut;
    
exit:    

    return _hr;

}

// ---------------------------------------------------------------------------
// IsEqual
// ---------------------------------------------------------------------------
HRESULT CAssemblyIdentity::IsEqual (IAssemblyIdentity *pAssemblyId)
{
    LPWSTR pwzBuf;
    DWORD ccBuf;
    CString sLang1, sVersion1, sToken1, sName1, sArch1;
    CString sLang2, sVersion2, sToken2, sName2, sArch2;

    // Compare architectures
    if (FAILED(_hr = (pAssemblyId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE, &pwzBuf, &ccBuf))))
            goto exit;
    sArch1.TakeOwnership(pwzBuf, ccBuf);

    if (FAILED(_hr = (GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE, &pwzBuf, &ccBuf))))
            goto exit;
    sArch2.TakeOwnership(pwzBuf, ccBuf);

    if (StrCmp (sArch1._pwz, sArch2._pwz))
    { 
        _hr = S_FALSE;
        goto exit;
    }

    // Compare names
    if (FAILED(_hr = (pAssemblyId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwzBuf, &ccBuf))))
            goto exit;
    sName1.TakeOwnership(pwzBuf, ccBuf);
       
    if (FAILED(_hr = (GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwzBuf, &ccBuf))))
            goto exit;
    sName2.TakeOwnership(pwzBuf, ccBuf);

    if (StrCmp (sName1._pwz, sName2._pwz))
    { 
        _hr = S_FALSE;
        goto exit;
    }

    // Compare Public Key Tokens
    if (FAILED(_hr = (pAssemblyId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN, &pwzBuf, &ccBuf))))
            goto exit;
    sToken1.TakeOwnership(pwzBuf, ccBuf);

    if (FAILED(_hr = (GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN, &pwzBuf, &ccBuf))))
            goto exit;
    sToken2.TakeOwnership(pwzBuf, ccBuf);

    if (StrCmp (sToken1._pwz, sToken2._pwz))
    { 
        _hr = S_FALSE;
        goto exit;
    }

    // Compare Versions
    if (FAILED(_hr = (pAssemblyId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION, &pwzBuf, &ccBuf))))
            goto exit;
    sVersion1.TakeOwnership(pwzBuf, ccBuf);

    if (FAILED(_hr = (GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION, &pwzBuf, &ccBuf))))
            goto exit;
    sVersion2.TakeOwnership(pwzBuf, ccBuf);

    if (StrCmp (sVersion1._pwz, sVersion2._pwz))
    { 
        _hr = S_FALSE;
        goto exit;
    }

    // Compare Languages
    if (FAILED(_hr = (pAssemblyId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE, &pwzBuf, &ccBuf))))
            goto exit;
    sLang1.TakeOwnership(pwzBuf, ccBuf);

    if (FAILED(_hr = (GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE, &pwzBuf, &ccBuf))))
            goto exit;
    sLang2.TakeOwnership(pwzBuf, ccBuf);

    if (StrCmp (sLang1._pwz, sLang2._pwz))
    { 
        _hr = S_FALSE;
        goto exit;
    }

    _hr = S_OK;
exit:

    return _hr;

}



#define WZ_WILDCARDSTRING L"*"
// ---------------------------------------------------------------------------
// GetDisplayName
// ---------------------------------------------------------------------------
HRESULT CAssemblyIdentity::GetDisplayName(DWORD dwFlags, LPOLESTR *ppwzDisplayName, LPDWORD pccDisplayName)
{
    LPWSTR rpwzAttrNames[5] = 
    {
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE,
    };

    LPWSTR pwzBuf = NULL;
    DWORD  ccBuf = 0;

    CString sDisplayName;
    
    for (int i = 0; i < 5; i++)
    {
        CString sBuffer;
        if (FAILED(_hr = GetAttribute(rpwzAttrNames[i], &pwzBuf, &ccBuf))
            && _hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
            goto exit;

        // append anyway to keep the number of underscore constant
        if (i)
            sDisplayName.Append(L"_");

        if (dwFlags == ASMID_DISPLAYNAME_WILDCARDED
            && _hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
        {
            sDisplayName.Append(WZ_WILDCARDSTRING);

            _hr = S_OK;
        }
        else if (_hr == S_OK)
        {
            sBuffer.TakeOwnership(pwzBuf, ccBuf);

            sDisplayName.Append(sBuffer);
        }
    }

    *ppwzDisplayName = sDisplayName._pwz;
    *pccDisplayName  = sDisplayName._cc;

    sDisplayName.ReleaseOwnership();

exit:
    return _hr;
}


// IUnknown Boilerplate

// ---------------------------------------------------------------------------
// CAssemblyIdentity::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyIdentity::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyIdentity)
       )
    {
        *ppvObj = static_cast<IAssemblyIdentity*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyIdentity::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyIdentity::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyIdentity::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyIdentity::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\id\idaux.cpp ===
#include <windows.h>
#include <shlwapi.h>
#include <idp.h>
#include <idaux.h>


ULONG
FusionpDbgPrintEx(
    ULONG Level,
    PCSTR Format,
    ...
    )
{
    return 0;
}


int
FusionpCompareStrings(
    PCWSTR psz1,
    SIZE_T cch1,
    PCWSTR psz2,
    SIZE_T cch2,
    bool fCaseInsensitive
    )
{
    if (fCaseInsensitive)
        return StrCmpI(psz1, psz2);
    else
        return StrCmp(psz1, psz2);    
}




BOOL
FusionpHashUnicodeString(
    PCWSTR String,
    SIZE_T cch,
    PULONG HashValue,
    DWORD dwCmpFlags
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG TmpHashValue = 0;

    if (HashValue != NULL)
        *HashValue = 0;

    //PARAMETER_CHECK((dwCmpFlags == 0) || (dwCmpFlags == (NORM_IGNORECASE|SORT_STRINGSORT))); // ?safe
    PARAMETER_CHECK((dwCmpFlags == 0) || (dwCmpFlags & NORM_IGNORECASE)); // ?safe
    PARAMETER_CHECK(HashValue != NULL);

    if (dwCmpFlags & NORM_IGNORECASE)
        dwCmpFlags  |= SORT_STRINGSORT;     

    //
    //  Note that if you change this implementation, you have to have the implementation inside
    //  ntdll change to match it.  Since that's hard and will affect everyone else in the world,
    //  DON'T CHANGE THIS ALGORITHM NO MATTER HOW GOOD OF AN IDEA IT SEEMS TO BE!  This isn't the
    //  most perfect hashing algorithm, but its stability is critical to being able to match
    //  previously persisted hash values.
    //

    if (dwCmpFlags & NORM_IGNORECASE)
    {
        while (cch-- != 0)
        {
            WCHAR Char = *String++;
            TmpHashValue = (TmpHashValue * 65599) + (WCHAR) ::CharUpperW((PWSTR) Char);
        }
    }
    else
    {
        while (cch-- != 0)
            TmpHashValue = (TmpHashValue * 65599) + *String++;
    }

    *HashValue = TmpHashValue;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\clrhost\asmexec.cs ===
/*=============================================================================
**
** Class: AsmExecute
**
** Purpose: Used to setup the correct hosting environment before executing an assembly
**
** Date: 10/20/2000
**        5/10/2001  Rev for CLR Beta2
**
** Copyright (c) Microsoft, 1999-2001
**
=============================================================================*/

using System.Reflection;
using System.Configuration.Assemblies;

[assembly:AssemblyCultureAttribute("")]
[assembly:AssemblyVersionAttribute("1.0.128.0")]
[assembly:AssemblyKeyFileAttribute(/*"..\..\*/"asmexecKey.snk")]

[assembly:AssemblyTitleAttribute("Microsoft Fusion .Net Assembly Execute Host")]
[assembly:AssemblyDescriptionAttribute("Microsoft Fusion Network Services CLR Host for executing .Net assemblies")]
[assembly:AssemblyProductAttribute("Microsoft Fusion Network Services")]
[assembly:AssemblyInformationalVersionAttribute("1.0.0.0")]
[assembly:AssemblyTrademarkAttribute("Microsoft is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation")]
[assembly:AssemblyCompanyAttribute("Microsoft Corporation")]
[assembly:AssemblyCopyrightAttribute("Copyright  Microsoft Corp. 1999-2001. All rights reserved.")]


//BUGBUG??
[assembly:System.CLSCompliant(true)]


//namespace Microsoft {
namespace FusionCLRHost {

    using System;
    using System.Text;
    using System.Runtime.Remoting;
    using System.Globalization;
    using System.Security;
    using System.Security.Policy;
    using System.Security.Permissions;
    using System.Collections;
    using System.Runtime.InteropServices;

//    [GuidAttribute("E612D54D-B42A-32B5-B1D7-8490CE09705C")]
    public interface IAsmExecute
    {
        int Execute(string codebase, Int32 flags, Int32 evidenceZone, string evidenceSrcUrl, string stringArg);
    }

    [GuidAttribute("7EB9A84D-646E-3764-BBCA-3789CDB3447B")]
    public class AsmExecute : MarshalByRefObject, IAsmExecute
    {
        // this must be the same as defined in the caller...
        private static readonly int SECURITY_NONE = 0x00;
        private static readonly int SECURITY_ZONE = 0x01;
        private static readonly int SECURITY_SITE = 0x02;

        // Arguments: Codebase, flags, zone, srcurl
        // If the flags indicate zone then a zone must be provided. 
        // If the flags indicate a site then a srcurl must be provided, codebase must be a filepath
        public int Execute(string codebase, Int32 flags, Int32 evidenceZone, string evidenceSrcUrl, string stringArg)
        {
            string file = codebase;
            if((file.Length == 0) || (file[0] == '\0'))
                throw new ArgumentException("Invalid codebase");

            Console.WriteLine("Codebase- {0}", file);

            // Find the appbase of the executable. For now we assume the 
            // form to be http://blah/... with forward slashes. This
            // need to be update.
            // Note: aso works with '\' as in file paths
            string appbase = null;
            string ConfigurationFile = null;
            int k = file.LastIndexOf('/');
            if(k <= 0)
            {
                k = file.LastIndexOf('\\');
                if(k == 0) 
                {
                    appbase = file;
                    ConfigurationFile = file;
                }
            }

            if(k != 0)
            {
                // if k is still < 0 at this point, appbase should be an empty string
                appbase = file.Substring(0,k+1);
                if(k+1 < file.Length) 
                    ConfigurationFile = file.Substring(k+1);
            }

            // Check 1: disallow non-fully qualified path/codebase
            if ((appbase.Length == 0) || (appbase[0] == '.'))
                throw new ArgumentException("Codebase must be fully qualified");
            
            // BUGBUG: should appbase be the source of the code, not local?
            Console.WriteLine("AppBase- {0}", appbase);

            // Build up the configuration File name
            if(ConfigurationFile != null)
            {
                StringBuilder bld = new StringBuilder();
                bld.Append(ConfigurationFile);
                bld.Append(".config");
                ConfigurationFile = bld.ToString();
            }

            Console.WriteLine("Config- {0}", ConfigurationFile);

            // Get the flags 
            // 0x1 we have Zone
            // 0x2 we have a unique id.
            int dwFlag = flags;

            Evidence documentSecurity = null;

            // Check 2: disallow called with no evidence
            if (dwFlag == SECURITY_NONE)
            {
                // BUGBUG?: disallow executing with no evidence
                throw new ArgumentException("Flag set at no evidence");
            }

            if((dwFlag & SECURITY_SITE) != 0 ||
               (dwFlag & SECURITY_ZONE) != 0) 
                documentSecurity = new Evidence();

            // BUGBUG: check other invalid cases for dwFlag
            
            if((dwFlag & SECURITY_ZONE) != 0)
            {
                int zone = evidenceZone;
                documentSecurity.AddHost( new Zone((System.Security.SecurityZone)zone) );

                Console.WriteLine("Evidence Zone- {0}", zone);
            }
            if((dwFlag & SECURITY_SITE) != 0)
            {
                if (file.Length<7||String.Compare(file.Substring(0,7),"file://",true)!=0)
                {
                    documentSecurity.AddHost( System.Security.Policy.Site.CreateFromUrl(evidenceSrcUrl) );

                    Console.WriteLine("Evidence SiteFromUrl- {0}", evidenceSrcUrl);
                
                    // if srcUrl is given, assume file/appbase is a local file path
                    StringBuilder bld = new StringBuilder();
                    bld.Append("file://");
                    bld.Append(appbase);
                    documentSecurity.AddHost( new ApplicationDirectory(bld.ToString()) );

                    Console.WriteLine("Evidence AppDir- {0}", bld);
                }

                // URLs may be matched exactly or by a wildcard in the final position,
                // for example: http://www.fourthcoffee.com/process/*
                StringBuilder bld2 = new StringBuilder();
                if (evidenceSrcUrl[evidenceSrcUrl.Length-1] == '/')
                    bld2.Append(evidenceSrcUrl);
                else
                {
                    int j = evidenceSrcUrl.LastIndexOf('/');
                    if(j > 0)
                    {
                        if (j > 7)  // evidenceSrcUrl == "http://a/file.exe"
                            bld2.Append(evidenceSrcUrl.Substring(0,j+1));
                        else
                        {
                            // evidenceSrcUrl == "http://foo.com" -> but why?
                            bld2.Append(evidenceSrcUrl);
                            bld2.Append('/');
                        }
                    }
                    else
                        throw new ArgumentException("Invalid Url format");
                }
                bld2.Append('*');

                documentSecurity.AddHost( new Url(bld2.ToString()) );

                Console.WriteLine("Evidence Url- {0}", bld2);
            }

            // other evidence: Hash, Publisher, StrongName
            
            // Set domain name to site name if possible
            string friendlyName = null;
            if((dwFlag & SECURITY_SITE) != 0)
                friendlyName = GetSiteName(evidenceSrcUrl);
            else
                friendlyName = GetSiteName(file);
            Console.WriteLine("AppDomain friendlyName- {0}", friendlyName);

            // set up arguments
            // only allow 1 for now
            string[] args;
            if (stringArg != null)
            {
                args = new string[1];
                args[0] = stringArg;
            }
            else
                args = new string[0];

            AppDomainSetup properties = new AppDomainSetup();
            properties.ApplicationBase = appbase;
            properties.PrivateBinPath = "bin";
            if(ConfigurationFile != null)
                properties.ConfigurationFile = ConfigurationFile;

            AppDomain proxy = AppDomain.CreateDomain(friendlyName, documentSecurity, properties);
            if(proxy != null) 
            {
                AssemblyName asmname = Assembly.GetExecutingAssembly().GetName();
                Console.WriteLine("AsmExecute name- {0}", asmname);

                try
                {
                    // Use remoting. Otherwise asm will be loaded both in current and the new AppDomain
                    // ... as explained by URT dev
                    // asmexec.dll must be found on path (CorPath?) or in the GAC for this to work.
                    ObjectHandle handle = proxy.CreateInstance(asmname.FullName, "FusionCLRHost.AsmExecute");
                    if (handle != null)
                    {
                        AsmExecute execproxy = (AsmExecute)handle.Unwrap();
                        int retVal = -1;

                        Console.WriteLine("\n========");
                        
                        if (execproxy != null)
                            retVal = execproxy.ExecuteAsAssembly(file, documentSecurity, args);

                        Console.WriteLine("\n========");

                        return retVal;
                    }

                }
                catch(Exception e)
                {
                    Console.WriteLine("AsmExecute CreateInstance(AsmExecute) failed: {0}", e.Message);
                    throw e;
                }
            } 
            else
                Console.WriteLine("AsmExecute CreateDomain failed");

            // BUGBUG: throw Exception?
            return -1;           
        }

        // This method must be internal, since it asserts the ControlEvidence permission.
        // private --> require ReflectionPermission not known how
        // solution: public but LinkDemand StrongNameIdentity of ours
        [ComVisible(false)]
        [StrongNameIdentityPermissionAttribute(SecurityAction.LinkDemand, PublicKey = "0x002400000480000094000000060200000024000052534131000400000100010013F3CD6C291DF1566D3C6E7269800C35D9212A622FA934492AD0833DAEA2574D12A9AA2A9392FF30A892ECD3F7F9B57211A541CC4712A184450992E143C1BDBC864E31826598B0D90BB2F04C5C50F004771370F9C76444696E8DC18999A3D8448D26EBF3A9E68796CA3A7D2ACC47B491455E462F4E6DDD9DF338171D911D88B2" )]
        public int ExecuteAsAssembly(string file, Evidence evidence, string[] args)
        {
            new PermissionSet(PermissionState.Unrestricted).Assert();
            return AppDomain.CurrentDomain.ExecuteAssembly(file, evidence, args);
        }

        private static string GetSiteName(string pURL) 
        {
            // BUGBUG: this does not work w/ UNC or file:// (?)
            string siteName = null;
            if(pURL != null) {
                int j = pURL.IndexOf(':');  
                
                // If there is a protocal remove it. In a URL of the form
                // yyyy://xxxx/zzzz   where yyyy is the protocal, xxxx is
                // the site and zzzz is extra we want to get xxxx.
                if(j != -1 && 
                   j+3 < pURL.Length &&
                   pURL[j+1] == '/' &&
                   pURL[j+2] == '/') 
                    {
                        j+=3;
                        
                        // Remove characters after the
                        // next /.  
                        int i = pURL.IndexOf('/',j);
                        if(i > -1) 
                            siteName = pURL.Substring(j,i-j);
                        else 
                            siteName = pURL.Substring(j);
                    }
            
                if(siteName == null)
                    siteName = pURL;
            }
            return siteName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\id\id.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    id.cpp

Abstract:

    Implementation of the assembly identity data type.

Author:

    Michael Grier (MGrier) 7/20/2000

Revision History:

--*/

//adriaanc
//#include "stdinc.h"
//#include <setupapi.h>

#include <sxsapi.h>
// adriaanc
//#include <stdlib.h>
//#include <search.h>

// adriaanc
#include "idaux.h"

#include "idp.h"

//
//  Power of two to which to round the number of allocated attribute
//  pointers.
//

#define ROUNDING_FACTOR_BITS (3)

#define WILDCARD_CHAR '*'

#define ENTRY(x) { x, NUMBER_OF(x) - 1 },

const static struct
{
    const WCHAR *String;
    SIZE_T Cch;
} s_rgLegalNamesNotInANamespace[] =
{ 
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE)
};

#undef ENTRY


BOOL
SxspValidateAssemblyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK((Flags & ~(SXSP_VALIDATE_ASSEMBLY_IDENTITY_FLAGS_MAY_BE_NULL)) == 0);

    if (AssemblyIdentity == NULL)
    {
        PARAMETER_CHECK(Flags & SXSP_VALIDATE_ASSEMBLY_IDENTITY_FLAGS_MAY_BE_NULL);
    }
    else
    {
        const ULONG IdentityType = AssemblyIdentity->Type;

        PARAMETER_CHECK(
            (IdentityType == ASSEMBLY_IDENTITY_TYPE_DEFINITION) ||
            (IdentityType == ASSEMBLY_IDENTITY_TYPE_REFERENCE) ||
            (IdentityType == ASSEMBLY_IDENTITY_TYPE_WILDCARD));
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

//
//  Note!
//
//  We currently are very very restrictive on the legal characters in namespaces.
//
//  This is because the various rules for equivalences of namespaces are extremely
//  complex w.r.t. when "a" == "A" and "%Ab" == "%aB" etc.
//
//  We're side-stepping this issue by requireing everything to be lower case and
//  not permitting the "%" character.
//

const WCHAR s_rgLegalNamespaceChars[] = L"abcdefghijklmnopqrstuvwxyz0123456789.-_/\\:";
BOOL
SxspValidateAssemblyIdentityAttributeNamespace(
    IN DWORD Flags,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG i;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK((Namespace != NULL) || (NamespaceCch == 0));

    //
    //  We really should ensure that the namespace is a well-formed URI
    //

    for (i=0; i<NamespaceCch; i++)
    {
        if (wcschr(s_rgLegalNamespaceChars, Namespace[i]) == NULL)
        {
            ::SetLastError(ERROR_SXS_INVALID_XML_NAMESPACE_URI);
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspValidateAssemblyIdentityAttributeName(
    IN DWORD Flags,
    IN const WCHAR *Name,
    IN SIZE_T NameCch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK((Name != NULL) || (NameCch == 0));

    //
    //  We should ensure that Name is a well-formed XML identifier
    //

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspValidateAssemblyIdentityAttributeValue(
    IN DWORD Flags,
    IN const WCHAR * /* Value */,
    SIZE_T /* ValueCch */
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK((Flags & ~(SXSP_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_WILDCARDS_PERMITTED)) == 0);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxsValidateAssemblyIdentityAttribute(
    DWORD Flags,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK((Flags & ~(
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_WILDCARDS_PERMITTED)) == 0);
    PARAMETER_CHECK(Attribute != NULL);

    //
    //  apply useful defaults.  Note that by default, wildcards are not permitted.
    //

    if (Flags == 0)
    {
        Flags = 
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE;
    }

    // No attribute flags defined or permitted at this time.
    PARAMETER_CHECK(Attribute->Flags == 0);

    if (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE)
        IFFALSE_EXIT(::SxspValidateAssemblyIdentityAttributeNamespace(0, Attribute->Namespace, Attribute->NamespaceCch));

    if (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME)
        IFFALSE_EXIT(::SxspValidateAssemblyIdentityAttributeName(0, Attribute->Name, Attribute->NameCch));

    if (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE)
        IFFALSE_EXIT(::SxspValidateAssemblyIdentityAttributeValue(
                        (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_WILDCARDS_PERMITTED) ?
                            SXSP_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_WILDCARDS_PERMITTED : 0,
                         Attribute->Value,
                         Attribute->ValueCch));

    if ((Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE) &&
        (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME) &&
        (Attribute->NamespaceCch == 0))
    {
        ULONG i;
        // There is only a small set of legal attribute names when the namespace is omitted.
        
        for (i=0; i<NUMBER_OF(s_rgLegalNamesNotInANamespace); i++)
        {
            if (Attribute->NameCch == s_rgLegalNamesNotInANamespace[i].Cch)
            {
                if (memcmp(Attribute->Name, s_rgLegalNamesNotInANamespace[i].String, Attribute->NameCch * sizeof(WCHAR)) == 0)
                    break;
            }
        }

        if (i == NUMBER_OF(s_rgLegalNamesNotInANamespace))
        {
            // Someone had an attribute on the <assemblyIdentity> element which was not in a namespace and
            // was not listed as a builtin attribute.  Boom.
            ::SetLastError(ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE);
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxsHashAssemblyIdentityAttribute(
    DWORD Flags,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    ULONG *HashOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG Hash = 0;
    ULONG TempHash = 0;

    if (HashOut != NULL)
        *HashOut = 0;

    if (Flags == 0)
        Flags = SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE |
                SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME |
                SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE;
    
    PARAMETER_CHECK((Flags & ~(SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE | 
                  SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME |
                  SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE)) == 0);

    // if hash value, must hash name, if hash name, must hash namespace
    if (((Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE) && (
        (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME) == 0)) ||
        ((Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME) && (
        (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE) == 0))) {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK(HashOut != NULL);

    if (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE) {
        IFFALSE_EXIT(::FusionpHashUnicodeString(Attribute->Namespace, Attribute->NamespaceCch, &TempHash, NORM_IGNORECASE|SORT_STRINGSORT));
        Hash = TempHash;
    }
    if (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME) {
        IFFALSE_EXIT(::FusionpHashUnicodeString(Attribute->Name, Attribute->NameCch, &TempHash, NORM_IGNORECASE|SORT_STRINGSORT));    
        Hash = (Hash * 65599) + TempHash;
    }
    
    if (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE) {
        IFFALSE_EXIT(::FusionpHashUnicodeString(Attribute->Value, Attribute->ValueCch, &TempHash, NORM_IGNORECASE|SORT_STRINGSORT));    
        Hash = (Hash * 65599) + TempHash;
    }

    *HashOut = Hash;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspComputeInternalAssemblyIdentityAttributeBytesRequired(
    IN DWORD Flags,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT SIZE_T *BytesRequiredOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T BytesNeeded = 0;

    if (BytesRequiredOut != NULL)
        *BytesRequiredOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(BytesRequiredOut != NULL);
    PARAMETER_CHECK((NameCch == 0) || (Name != NULL));
    PARAMETER_CHECK((ValueCch == 0) || (Value != NULL));

    BytesNeeded = sizeof(INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE);

    // Note that we do not account for the namespace length because namespaces are pooled
    // for the identity object and come from a separate allocation.

    if ((Name != NULL) && (NameCch != 0))
        BytesNeeded += ((NameCch + 1) * sizeof(WCHAR));

    if ((Value != NULL) && (ValueCch != 0))
        BytesNeeded += ((ValueCch + 1) * sizeof(WCHAR));

    *BytesRequiredOut = BytesNeeded;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspComputeAssemblyIdentityAttributeBytesRequired(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Source,
    OUT SIZE_T *BytesRequiredOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T BytesNeeded = 0;

    if (BytesRequiredOut != NULL)
        *BytesRequiredOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Source != NULL);
    PARAMETER_CHECK(BytesRequiredOut != NULL);

    BytesNeeded = sizeof(ASSEMBLY_IDENTITY_ATTRIBUTE);

    // We do account for the namespace length here because we're presumably about
    // to copy into an ASSEMBLY_IDENTITY_ATTRIBUTE where the namespace isn't pooled.
    
    if (Source->NamespaceCch != 0)
        BytesNeeded += ((Source->NamespaceCch + 1) * sizeof(WCHAR));

    if (Source->NameCch != 0)
        BytesNeeded += ((Source->NameCch + 1) * sizeof(WCHAR));

    if (Source->ValueCch != 0)
        BytesNeeded += ((Source->ValueCch + 1) * sizeof(WCHAR));

    *BytesRequiredOut = BytesNeeded;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspFindAssemblyIdentityNamespaceInArray(
    IN DWORD Flags,
    IN OUT PCASSEMBLY_IDENTITY_NAMESPACE **NamespacePointerArrayPtr,
    IN OUT ULONG *NamespaceArraySizePtr,
    IN OUT ULONG *NamespaceCountPtr,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG i, j;
    ULONG NamespaceHash = 0;
    ULONG NamespaceCount;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray;
    ULONG NewNamespaceArraySize = 0;
    PCASSEMBLY_IDENTITY_NAMESPACE *NewNamespacePointerArray = NULL;
    PCASSEMBLY_IDENTITY_NAMESPACE NamespacePointer = NULL;
    PCASSEMBLY_IDENTITY_NAMESPACE NewNamespacePointer = NULL;
    ULONG NamespaceArraySize = 0;
    LONG Comparison;

    if (NamespaceOut != NULL)
        *NamespaceOut = NULL;

    PARAMETER_CHECK((Flags & ~(SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND)) == 0);
    PARAMETER_CHECK(NamespacePointerArrayPtr != NULL);
    PARAMETER_CHECK(NamespaceCountPtr != NULL);
    PARAMETER_CHECK(NamespaceArraySizePtr != NULL);
    PARAMETER_CHECK((NamespaceCch == 0) || (Namespace != NULL));

    NamespacePointerArray = *NamespacePointerArrayPtr;
    NamespaceCount = *NamespaceCountPtr;
    NamespaceArraySize = *NamespaceArraySizePtr;

    IFFALSE_EXIT(::FusionpHashUnicodeString(Namespace, NamespaceCch, &NamespaceHash, 0));

    for (i=0; i<NamespaceCount; i++)
    {
        if (NamespaceHash <= NamespacePointerArray[i]->Hash)
            break;
    }

    // Loop through the duplicate hash values seeing if we have a match.
    while ((i < NamespaceCount) && (NamespacePointerArray[i]->Hash == NamespaceHash) && (NamespacePointerArray[i]->NamespaceCch == NamespaceCch))
    {
        NamespacePointer = NamespacePointerArray[i];

        Comparison = memcmp(Namespace, NamespacePointerArray[i]->Namespace, NamespaceCch * sizeof(WCHAR));
        if (Comparison == 0)
            break;

        NamespacePointer = NULL;
        i++;
    }

    if ((NamespacePointer == NULL) && (Flags & SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND))
    {
        // We didn't find a match.  Allocate a new one and push it into the array at the 
        // appropriate location.  If the namespace isn't null.
        if (NamespaceCch != 0)
        {
            IFFALSE_EXIT(::SxspAllocateAssemblyIdentityNamespace(0, Namespace, NamespaceCch, NamespaceHash, &NewNamespacePointer));

            // the "i" variable is where we want to insert this one.
            if (i >= NamespaceArraySize)
            {
                NewNamespaceArraySize = NamespaceArraySize + 8;
                IFALLOCFAILED_EXIT(NewNamespacePointerArray = FUSION_NEW_ARRAY(PCASSEMBLY_IDENTITY_NAMESPACE, NewNamespaceArraySize));

                for (j=0; j<NamespaceCount; j++)
                    NewNamespacePointerArray[j] = NamespacePointerArray[j];

                while (j < NewNamespaceArraySize)
                    NewNamespacePointerArray[j++] = NULL;

                FUSION_DELETE_ARRAY(NamespacePointerArray);

                *NamespacePointerArrayPtr = NewNamespacePointerArray;
                *NamespaceArraySizePtr = NewNamespaceArraySize;

                NamespacePointerArray = NewNamespacePointerArray;
                NamespaceArraySize = NewNamespaceArraySize;

                NewNamespacePointerArray = NULL;
                NewNamespaceArraySize = 0;
            }

            ASSERT(i < NamespaceArraySize);

            for (j = NamespaceCount; j > i; j--)
                NamespacePointerArray[j] = NamespacePointerArray[j-1];

            ASSERT(j == i);

            NamespacePointerArray[i] = NewNamespacePointer;
            NamespacePointer = NewNamespacePointer;
            NewNamespacePointer = NULL;

            *NamespaceCountPtr = NamespaceCount + 1;
        }
    }

    if (NamespaceOut != NULL)
        *NamespaceOut = NamespacePointer;

    fSuccess = TRUE;

Exit:
    if (NewNamespacePointer != NULL)
        SxspDeallocateAssemblyIdentityNamespace(NewNamespacePointer);

    if (NewNamespacePointerArray != NULL)
        FUSION_DELETE_ARRAY(NewNamespacePointerArray);

    return fSuccess;
}

BOOL
SxspFindAssemblyIdentityNamespace(
    IN DWORD Flags,
    IN PASSEMBLY_IDENTITY AssemblyIdentity,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCASSEMBLY_IDENTITY_NAMESPACE NamespacePointer = NULL;

    if (NamespaceOut != NULL)
        *NamespaceOut = NULL;

    PARAMETER_CHECK((Flags & ~(SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_FLAG_ADD_IF_NOT_FOUND)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(NamespaceOut != NULL);
    PARAMETER_CHECK((Namespace != NULL) || (NamespaceCch == 0));
    IFFALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    IFFALSE_EXIT(
        ::SxspFindAssemblyIdentityNamespaceInArray(
            (Flags & SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_FLAG_ADD_IF_NOT_FOUND) ?
                SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND : 0,
            &AssemblyIdentity->NamespacePointerArray,
            &AssemblyIdentity->NamespaceArraySize,
            &AssemblyIdentity->NamespaceCount,
            Namespace,
            NamespaceCch,
            &NamespacePointer));

    *NamespaceOut = NamespacePointer;

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspAllocateAssemblyIdentityNamespace(
    IN DWORD Flags,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    IN ULONG NamespaceHash,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY_NAMESPACE NewNamespace = NULL;
    SIZE_T BytesRequired = 0;

    if (NamespaceOut != NULL)
        *NamespaceOut = NULL;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(NamespaceOut != NULL);
    PARAMETER_CHECK((Namespace != NULL) || (NamespaceHash == 0));
    PARAMETER_CHECK((Namespace != NULL) || (NamespaceCch == 0));

    BytesRequired = sizeof(ASSEMBLY_IDENTITY_NAMESPACE);

    if (NamespaceCch != 0)
        BytesRequired += (NamespaceCch + 1) * sizeof(WCHAR);

    IFALLOCFAILED_EXIT(NewNamespace = reinterpret_cast<PASSEMBLY_IDENTITY_NAMESPACE>(FUSION_RAW_ALLOC(BytesRequired, ASSEMBLY_IDENTITY_NAMESPACE)));

    NewNamespace->Flags = 0;

    if (NamespaceCch != 0)
    {
        NewNamespace->Namespace = (PWSTR) (NewNamespace + 1);
        NewNamespace->NamespaceCch = NamespaceCch;

        memcpy(
            (PVOID) NewNamespace->Namespace,
            Namespace,
            NamespaceCch * sizeof(WCHAR));

        ((PWSTR) NewNamespace->Namespace) [NamespaceCch] = L'\0';
        NewNamespace->NamespaceCch = NamespaceCch;
    }
    else
    {
        NewNamespace->Namespace = NULL;
        NewNamespace->NamespaceCch = 0;
    }

    NewNamespace->Hash = NamespaceHash;

    *NamespaceOut = NewNamespace;
    NewNamespace = NULL;

    fSuccess = TRUE;
Exit:
    if (NewNamespace != NULL)
        FUSION_RAW_DEALLOC(NewNamespace);

    return fSuccess;
}

VOID
SxspDeallocateAssemblyIdentityNamespace(
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace
    )
{
    FN_TRACE();
    // The whole thing is allocated as a single chunk...
    ASSERT(Namespace != NULL);

    if (Namespace != NULL)
        FUSION_RAW_DEALLOC((PVOID) Namespace);
}

BOOL
SxspPopulateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Destination
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PVOID Cursor = NULL;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Destination != NULL);

    Destination->Attribute.Flags = 0;
    Destination->Namespace = Namespace;

    Cursor = (PVOID) (Destination + 1);

    if (Namespace != NULL)
    {
        Destination->Attribute.Namespace = Namespace->Namespace;
        Destination->Attribute.NamespaceCch = Namespace->NamespaceCch;
    }
    else
    {
        Destination->Attribute.Namespace = NULL;
        Destination->Attribute.NamespaceCch = 0;
    }

    if ((Name != NULL) && (NameCch != 0))
    {
        Destination->Attribute.Name = (PWSTR) Cursor;
        memcpy(
            Cursor,
            Name,
            NameCch * sizeof(WCHAR));
        ((PWSTR) Destination->Attribute.Name) [NameCch] = L'\0';
        Destination->Attribute.NameCch = NameCch;
        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((NameCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        Destination->Attribute.Name = NULL;
        Destination->Attribute.NameCch = 0;
    }

    if ((Value != NULL) && (ValueCch != 0))
    {
        Destination->Attribute.Value = (PWSTR) Cursor;
        memcpy(
            Cursor,
            Value,
            ValueCch * sizeof(WCHAR));
        ((PWSTR) Destination->Attribute.Value)[ValueCch] = L'\0';
        Destination->Attribute.ValueCch = ValueCch;
        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((ValueCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        Destination->Attribute.Value = NULL;
        Destination->Attribute.ValueCch = 0;
    }

    IFFALSE_EXIT(::SxsHashAssemblyIdentityAttribute(0, &Destination->Attribute, &Destination->WholeAttributeHash));
    IFFALSE_EXIT(::SxsHashAssemblyIdentityAttribute(SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE | SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME,
                                &Destination->Attribute, &Destination->NamespaceAndNameHash));
    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspAllocateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Destination
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T BytesNeeded = 0;
    PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE NewAttribute = NULL;

    if (Destination != NULL)
        *Destination = NULL;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Destination != NULL);
    PARAMETER_CHECK((NameCch == 0) || (Name != NULL));
    PARAMETER_CHECK((ValueCch == 0) || (Value != NULL));

    IFFALSE_EXIT(::SxspComputeInternalAssemblyIdentityAttributeBytesRequired(0, Name, NameCch, Value, ValueCch, &BytesNeeded));
    IFALLOCFAILED_EXIT(NewAttribute = (PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE) FUSION_RAW_ALLOC(BytesNeeded, INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE));
    IFFALSE_EXIT(::SxspPopulateInternalAssemblyIdentityAttribute(0, Namespace, Name, NameCch, Value, ValueCch, NewAttribute));

    *Destination = NewAttribute;
    NewAttribute = NULL;

    fSuccess = TRUE;

Exit:
    if (NewAttribute != NULL)
        FUSION_RAW_DEALLOC(NewAttribute);

    return fSuccess;
}

VOID
SxspDeallocateInternalAssemblyIdentityAttribute(
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    )
{
    FN_TRACE();
    if (Attribute != NULL)
        FUSION_RAW_DEALLOC((PVOID) Attribute);
}

BOOL
SxsCompareAssemblyIdentityAttributes(
    DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute1,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute2,
    OUT ULONG *ComparisonResult
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    LONG Comparison = 0, Comparison1, Comparison2, Comparison3;

    if (Flags == 0)
        Flags = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE |
                SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME |
                SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE;

    PARAMETER_CHECK((Flags & ~(SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE |
                    SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME |
                    SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE)) == 0);
    PARAMETER_CHECK(Attribute1 != NULL);
    PARAMETER_CHECK(Attribute2 != NULL);
    PARAMETER_CHECK(ComparisonResult != NULL);

    if ( Flags & SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE) {
        Comparison1 = FusionpCompareStrings(Attribute1->Namespace, Attribute1->NamespaceCch, Attribute2->Namespace, Attribute2->NamespaceCch, false);
        if (Comparison1 != 0) { // we have get the result
            Comparison = Comparison1 ;
            goto done;
        }
    }

    if ( Flags & SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME) {
        Comparison2 = FusionpCompareStrings(Attribute1->Name, Attribute1->NameCch, Attribute2->Name, Attribute2->NameCch, false);
        if (Comparison2 != 0) { // we have get the result
            Comparison = Comparison2;
            goto done;
        }
    }

    if ( Flags & SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE){    
        Comparison3 = FusionpCompareStrings(Attribute1->Value, Attribute1->ValueCch, Attribute2->Value, Attribute2->ValueCch, true);
        if (Comparison3 != 0) { // we have get the result
            Comparison = Comparison3;
            goto done;
        }
    }
    Comparison = 0;
done:
    if (Comparison < 0)
        *ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN;
    else if (Comparison == 0)
        *ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL;
    else
        *ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

int
__cdecl
SxspCompareInternalAttributesForQsort(
    const void *elem1,
    const void *elem2
    )
{
    FN_TRACE();
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE * p1 = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *)elem1; 
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE patt1 = *p1;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE * p2 = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *)elem2; 
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE patt2 = *p2;
    LONG Comparison;

    Comparison = FusionpCompareStrings(patt1->Attribute.Namespace, patt1->Attribute.NamespaceCch, patt2->Attribute.Namespace, patt2->Attribute.NamespaceCch, false);
    if (Comparison == 0)
		Comparison = FusionpCompareStrings(patt1->Attribute.Name, patt1->Attribute.NameCch, patt2->Attribute.Name, patt2->Attribute.NameCch, false);
    if (Comparison == 0)
        Comparison = FusionpCompareStrings(patt1->Attribute.Value, patt1->Attribute.ValueCch, patt2->Attribute.Value, patt2->Attribute.ValueCch, true);
    return Comparison;
}

int
__cdecl
SxspCompareULONGsForQsort(
    const void *elem1,
    const void *elem2
    )
{
    FN_TRACE();
    ULONG *pul1 = (ULONG *) elem1;
    ULONG *pul2 = (ULONG *) elem2;

    return ((LONG) *pul1) - ((LONG) *pul2);
}

BOOL
SxspCompareAssemblyIdentityAttributeLists(
    DWORD Flags,
    ULONG AttributeCount,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *List1,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *List2,
    ULONG *ComparisonResultOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL;
    ULONG i;

    if ((Flags != 0) ||
        ((AttributeCount != 0) &&
         ((List1 == NULL) ||
          (List2 == NULL))) ||
        (ComparisonResultOut == NULL))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }
    
    for (i=0; i<AttributeCount; i++)
    {
        IFFALSE_EXIT(::SxsCompareAssemblyIdentityAttributes(0, &List1[i]->Attribute, &List2[i]->Attribute, &ComparisonResult));

        if (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL){            
            break;
        }
    }

    *ComparisonResultOut = ComparisonResult;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspHashInternalAssemblyIdentityAttributes(
    DWORD Flags,
    ULONG Count,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Attributes,
    ULONG *HashOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG Hash = 0;
    ULONG i;

    if (HashOut != NULL)
        *HashOut = 0;

    if ((Flags != 0) ||
        ((Count != 0) && (Attributes == NULL)) ||
        (HashOut == NULL))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    for (i=0; i<Count; i++)
        Hash = (Hash * 65599) + Attributes[i]->WholeAttributeHash;

    *HashOut = Hash;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

VOID SxspDbgPrintInternalAssemblyIdentityAttribute(DWORD dwflags, PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute)
{
    ::FusionpDbgPrintEx(dwflags, "Attribute: \n"
        "\tNamespace = %S, \tNamespaceCch = %d\n"
        "\tAttributeName = %S, \tAttributeNameCch = %d\n"
        "\tAttributeValue = %S, \tAttributeValueCch = %d\n\n",    
        Attribute->Attribute.Namespace == NULL ? L"" : Attribute->Attribute.Namespace, Attribute->Attribute.NamespaceCch, 
        Attribute->Attribute.Name == NULL ? L"" : Attribute->Attribute.Name, Attribute->Attribute.NameCch,
        Attribute->Attribute.Value == NULL ? L"" : Attribute->Attribute.Value, Attribute->Attribute.ValueCch); 
    
    return; 
}
VOID 
SxspDbgPrintInternalAssemblyIdentityAttributes(DWORD dwflags, ULONG AttributeCount, PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes)
{
    for ( DWORD i=0;i<AttributeCount;i++){
        SxspDbgPrintInternalAssemblyIdentityAttribute(dwflags, Attributes[i]);
    }
    return;
}
VOID SxspDbgPrintAssemblyIdentity(DWORD dwflags, PCASSEMBLY_IDENTITY pAssemblyIdentity){
    if ( pAssemblyIdentity) {
        SxspDbgPrintInternalAssemblyIdentityAttributes(dwflags, pAssemblyIdentity->AttributeCount, 
            pAssemblyIdentity->AttributePointerArray);
    }
    return;
}

VOID SxspDbgPrintAssemblyIdentityAttribute(DWORD dwflags, PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute)
{
    ::FusionpDbgPrintEx(dwflags, "Attribute: \n"
        "\tNamespace = %S, \tNamespaceCch = %d\n"
        "\tAttributeName = %S, \tAttributeNameCch = %d\n"
        "\tAttributeValue = %S, \tAttributeValueCch = %d\n\n",    
        Attribute->Namespace == NULL ? L"" : Attribute->Namespace, Attribute->NamespaceCch, 
        Attribute->Name == NULL ? L"" : Attribute->Name, Attribute->NameCch,
        Attribute->Value == NULL ? L"" : Attribute->Value, Attribute->ValueCch); 
    
    return; 
}
VOID 
SxspDbgPrintAssemblyIdentityAttributes(DWORD dwflags, ULONG AttributeCount, PCASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes)
{
    for ( DWORD i=0;i<AttributeCount;i++){
        SxspDbgPrintAssemblyIdentityAttribute(dwflags, Attributes[i]);
    }
}

BOOL
SxsCreateAssemblyIdentity(
    DWORD Flags,
    ULONG Type,
    PASSEMBLY_IDENTITY *AssemblyIdentityOut,
    ULONG AttributeCount,
    PCASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    ULONG AttributeArraySize = 0;
    SIZE_T BytesNeeded = 0;
    ULONG i;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = NULL;
    ULONG NamespaceArraySize = 0;
    ULONG NamespaceCount = 0;

#if DBG
    ::SxspDbgPrintAssemblyIdentityAttributes(FUSION_DBG_LEVEL_VERBOSE, AttributeCount, Attributes); 
#endif
    if (AssemblyIdentityOut != NULL)
        *AssemblyIdentityOut = NULL;

    if (((Flags & ~(SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)) != 0) ||
        ((Type != ASSEMBLY_IDENTITY_TYPE_DEFINITION) &&
         (Type != ASSEMBLY_IDENTITY_TYPE_REFERENCE) &&
         (Type != ASSEMBLY_IDENTITY_TYPE_WILDCARD)) ||
         ((AttributeCount != 0) && (Attributes == NULL)))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    //
    //  Validate all our inputs before we get started...
    for (i=0; i<AttributeCount; i++)
    {
        IFFALSE_EXIT(SxsValidateAssemblyIdentityAttribute(0, Attributes[i]));
    }

    //
    //  If we were told that this is a frozen assembly identity, we could be super-smart and
    //  have a single allocation for the whole thing.  Instead we'll leave that optimization
    //  for a future maintainer.  We'll at least be smart enough to allocate both the
    //  assembly identity and the array of attribute pointers in a single whack tho'.
    //

    if (Flags & SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
    {
        AttributeArraySize = AttributeCount;
    }
    else
    {
        // For non-frozen identities, we'll add a rounding factor and round up for the number of
        // array elements.
        AttributeArraySize = (AttributeCount + (1 << ROUNDING_FACTOR_BITS)) & ~((1 << ROUNDING_FACTOR_BITS) - 1);
    }

    // allocate everything except namespace array
    BytesNeeded = sizeof(ASSEMBLY_IDENTITY) + (AttributeArraySize * sizeof(PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE));
    IFALLOCFAILED_EXIT(AssemblyIdentity = (PASSEMBLY_IDENTITY) FUSION_RAW_ALLOC(BytesNeeded, ASSEMBLY_IDENTITY));

    if (AttributeArraySize != 0)
    {
        AttributePointerArray = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *) (AssemblyIdentity + 1);

        // Initialize the pointers so we can clean up non-NULL ones in the error path
        for (i=0; i<AttributeArraySize; i++)
            AttributePointerArray[i] = NULL;
    }

    for (i=0; i<AttributeCount; i++)
    {
        PCASSEMBLY_IDENTITY_NAMESPACE NamespacePointer = NULL;

        IFFALSE_EXIT(
            ::SxspFindAssemblyIdentityNamespaceInArray(
                    SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND,
                    &NamespacePointerArray,
                    &NamespaceArraySize,
                    &NamespaceCount,
                    Attributes[i]->Namespace,
                    Attributes[i]->NamespaceCch,
                    &NamespacePointer));
        IFFALSE_EXIT(
            ::SxspAllocateInternalAssemblyIdentityAttribute(
                0,
                NamespacePointer,
                Attributes[i]->Name,
                Attributes[i]->NameCch,
                Attributes[i]->Value,
                Attributes[i]->ValueCch,
                &AttributePointerArray[i]));
    }

    // sort 'em.
    qsort((PVOID) AttributePointerArray, AttributeCount, sizeof(PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE), SxspCompareInternalAttributesForQsort);

    AssemblyIdentity->AttributeArraySize = AttributeArraySize;
    AssemblyIdentity->AttributeCount = AttributeCount;
    AssemblyIdentity->AttributePointerArray = AttributePointerArray;
    AssemblyIdentity->NamespaceArraySize = NamespaceArraySize;
    AssemblyIdentity->NamespaceCount = NamespaceCount;
    AssemblyIdentity->NamespacePointerArray = NamespacePointerArray;
    AssemblyIdentity->Flags = 0;
    AssemblyIdentity->InternalFlags = ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION; // namespace is allocated sperately
    AssemblyIdentity->Type = Type;
    AssemblyIdentity->HashDirty = TRUE;

    AttributePointerArray = NULL;
    NamespacePointerArray = NULL;

    IFFALSE_EXIT(::SxspEnsureAssemblyIdentityHashIsUpToDate(0, AssemblyIdentity));

    if (Flags & SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
        AssemblyIdentity->Flags |= ASSEMBLY_IDENTITY_FLAG_FROZEN;

    *AssemblyIdentityOut = AssemblyIdentity;
    AssemblyIdentity = NULL;

    fSuccess = TRUE;

Exit:
    if ((AttributePointerArray != NULL) && (AttributeCount != 0))
    {
        for (i=0; i<AttributeCount; i++)
            SxspDeallocateInternalAssemblyIdentityAttribute(AttributePointerArray[i]);

        FUSION_RAW_DEALLOC((PVOID) AttributePointerArray);
    }

    if ((NamespacePointerArray != NULL) && (NamespaceCount != 0))
    {
        for (i=0; i<NamespaceCount; i++)
            SxspDeallocateAssemblyIdentityNamespace(NamespacePointerArray[i]);

        FUSION_RAW_DEALLOC((PVOID) NamespacePointerArray);
    }

    if (AssemblyIdentity != NULL)
    {
        FUSION_RAW_DEALLOC(AssemblyIdentity);
    }

    return fSuccess;
}

BOOL
SxsFreezeAssemblyIdentity(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if ((Flags != 0) ||
        (AssemblyIdentity == NULL))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    // We could possibly do something really interesting like realloc the whole thing but
    // instead we'll just set the flag that stops future modifications.

    AssemblyIdentity->Flags |= ASSEMBLY_IDENTITY_FLAG_FROZEN;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

VOID
SxsDestroyAssemblyIdentity(
    PASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    // adriaanc
    // CSxsPreserveLastError ple;
    FN_TRACE();

    if (AssemblyIdentity == NULL)
        return;

    ULONG i;

    //
    // An identity that's created frozen (whether created new or copied from an existing identity)
    // uses a single allocation for everything.  Only free the suballocations if we're not
    // in this state.
    //

    if (!(AssemblyIdentity->InternalFlags & ASSEMBLY_IDENTITY_INTERNAL_FLAG_SINGLE_ALLOCATION_FOR_EVERYTHING))
    {
        const ULONG AttributeCount = AssemblyIdentity->AttributeCount;
        PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = AssemblyIdentity->AttributePointerArray;
        const ULONG NamespaceCount = AssemblyIdentity->NamespaceCount;
        PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = AssemblyIdentity->NamespacePointerArray;

        for (i=0; i<AttributeCount; i++)
        {
            SxspDeallocateInternalAssemblyIdentityAttribute((PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE) AttributePointerArray[i]);
            AttributePointerArray[i] = NULL;
        }

        for (i=0; i<NamespaceCount; i++)
        {
            SxspDeallocateAssemblyIdentityNamespace(NamespacePointerArray[i]);
            NamespacePointerArray[i] = NULL;
        }

        if (AssemblyIdentity->InternalFlags & ASSEMBLY_IDENTITY_INTERNAL_FLAG_ATTRIBUTE_POINTERS_IN_SEPARATE_ALLOCATION)
        {
            FUSION_DELETE_ARRAY(AttributePointerArray);
            AssemblyIdentity->AttributePointerArray = NULL;
        }

        if (AssemblyIdentity->InternalFlags & ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION)
        {
            FUSION_DELETE_ARRAY(NamespacePointerArray);
            AssemblyIdentity->NamespacePointerArray = NULL;
        }
    }

    FUSION_RAW_DEALLOC(AssemblyIdentity);
}

BOOL
SxspCopyInternalAssemblyIdentityAttributeOut(
    DWORD Flags,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    SIZE_T BufferSize,
    PASSEMBLY_IDENTITY_ATTRIBUTE DestinationBuffer,
    SIZE_T *BytesCopiedOrRequired
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T BytesRequired = 0;
    PVOID Cursor;

    if (BytesCopiedOrRequired != NULL)
        *BytesCopiedOrRequired = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK((BufferSize == 0) || (DestinationBuffer != NULL));
    PARAMETER_CHECK((BufferSize != 0) || (BytesCopiedOrRequired != NULL));

    IFFALSE_EXIT(::SxspComputeAssemblyIdentityAttributeBytesRequired(0, &Attribute->Attribute, &BytesRequired));

    if (BufferSize < BytesRequired)
    {
        if (BytesCopiedOrRequired != NULL)
            *BytesCopiedOrRequired = BytesRequired;

        ::SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    // We must be in the clear...
    DestinationBuffer->Flags = 0;

    Cursor = (PVOID) (DestinationBuffer + 1);

    if (Attribute->Attribute.NamespaceCch != 0)
    {
        DestinationBuffer->Namespace = (PWSTR) Cursor;
        DestinationBuffer->NamespaceCch = Attribute->Attribute.NamespaceCch;

        // We always internally store the strings with a null terminating character, so just copy
        // it with the body of the string.
        memcpy(
            Cursor,
            Attribute->Attribute.Namespace,
            (Attribute->Attribute.NamespaceCch + 1) * sizeof(WCHAR));

        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((Attribute->Attribute.NamespaceCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        DestinationBuffer->Namespace = NULL;
        DestinationBuffer->NamespaceCch = 0;
    }

    if (Attribute->Attribute.NameCch != 0)
    {
        DestinationBuffer->Name = (PWSTR) Cursor;
        DestinationBuffer->NameCch = Attribute->Attribute.NameCch;

        // We always internally store the strings with a null terminating character, so just copy
        // it with the body of the string.
        memcpy(
            Cursor,
            Attribute->Attribute.Name,
            (Attribute->Attribute.NameCch + 1) * sizeof(WCHAR));

        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((Attribute->Attribute.NameCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        DestinationBuffer->Name = NULL;
        DestinationBuffer->NameCch = 0;
    }

    if (Attribute->Attribute.ValueCch != 0)
    {
        DestinationBuffer->Value = (PWSTR) Cursor;
        DestinationBuffer->ValueCch = Attribute->Attribute.ValueCch;

        // We always internally store the strings with a null terminating character, so just copy
        // it with the body of the string.
        memcpy(
            Cursor,
            Attribute->Attribute.Value,
            (Attribute->Attribute.ValueCch + 1) * sizeof(WCHAR));

        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((Attribute->Attribute.ValueCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        DestinationBuffer->Value = NULL;
        DestinationBuffer->ValueCch = 0;
    }

    if (BytesCopiedOrRequired != NULL)
    {
        *BytesCopiedOrRequired = (((ULONG_PTR) Cursor) - ((ULONG_PTR) DestinationBuffer));
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspLocateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *InternalAttributeOut,
    OUT ULONG *LastIndexSearched OPTIONAL
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    ULONG i = 0;
    ULONG AttributeCount = 0;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    ULONG ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = NULL;
    ULONG LowIndex = 0;
    ULONG HighIndexPlusOne = 0;
    ULONG CompareAttributesFlags = 0;

    if (InternalAttributeOut != NULL)
        *InternalAttributeOut = NULL;

    if (LastIndexSearched != NULL)
        *LastIndexSearched = 0;

    if (((Flags & ~(SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE | 
                    SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME | 
                    SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE |
                    SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL)) != 0) ||
        (AssemblyIdentity == NULL) ||
        (Attribute == NULL) ||
        (InternalAttributeOut == NULL))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if ((Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME) &&
        !(Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if ((Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE) &&
        !(Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if (Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE)
    {
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE;
    }

    if (Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME)
    {
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME;
    }

    if (Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE)
    {
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE;
    }

    AttributeCount = AssemblyIdentity->AttributeCount;
    AttributePointerArray = AssemblyIdentity->AttributePointerArray;

    LowIndex = 0;
    HighIndexPlusOne = AttributeCount;
    i = 0;

    while (LowIndex < HighIndexPlusOne)
    {
        i = (LowIndex + HighIndexPlusOne) / 2;

        if (i == HighIndexPlusOne)
        {
            i = LowIndex;
        }

        IFFALSE_EXIT(
            ::SxsCompareAssemblyIdentityAttributes(
                CompareAttributesFlags,
                Attribute,
                &AttributePointerArray[i]->Attribute,
                &ComparisonResult));

        if (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
        {
            InternalAttribute = AttributePointerArray[i];
            break;
        }
        else if (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN)
        {
            if ( HighIndexPlusOne == i){
                i--;
                break;
            }
            else 
                HighIndexPlusOne = i;
        }
        else if (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN)
        {
            if ( LowIndex == i){
                i++;
                break;
            }
            else
                LowIndex = i;
        }
        else
        {
            ::SetLastError(ERROR_INTERNAL_ERROR);
            goto Exit;
        }
    }

    // If it's equal, there's no guarantee it's the first.  Back up to find the first non-equal match
    if (InternalAttribute != NULL)
    {
        while (i > 0)
        {
            IFFALSE_EXIT(::SxsCompareAssemblyIdentityAttributes(
                            CompareAttributesFlags,
                            Attribute,
                            &AttributePointerArray[i - 1]->Attribute,
                            &ComparisonResult));

            if (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
                break;

            i--;
            InternalAttribute = AttributePointerArray[i];
        }
    }

    if (InternalAttribute != NULL)
        *InternalAttributeOut = InternalAttribute;

    if (LastIndexSearched != NULL)
        *LastIndexSearched = i;

    // If we didn't find it, return ERROR_NOT_FOUND.
    if (((Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL) == 0) &&
        (InternalAttribute == NULL))
        ORIGINATE_WIN32_FAILURE_AND_EXIT(LocatingAssemblyIdentityAttribute, ERROR_NOT_FOUND);

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxsInsertAssemblyIdentityAttribute(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    PCASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttribute
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCASSEMBLY_IDENTITY_NAMESPACE Namespace = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE NewInternalAttribute = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *NewAttributePointerArray = NULL;
    ULONG NewAttributeArraySize = 0;
    ULONG i;
    ULONG LastIndexSearched;

    PARAMETER_CHECK((Flags & ~(SXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_OVERWRITE_EXISTING)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(AssemblyIdentityAttribute != NULL);

    IFFALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));
    IFFALSE_EXIT(::SxsValidateAssemblyIdentityAttribute(0, AssemblyIdentityAttribute));

    INTERNAL_ERROR_CHECK((AssemblyIdentity->Flags & ASSEMBLY_IDENTITY_FLAG_FROZEN) == 0);

    IFFALSE_EXIT(
        ::SxspFindAssemblyIdentityNamespace(
            SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_FLAG_ADD_IF_NOT_FOUND,
            AssemblyIdentity,
            AssemblyIdentityAttribute->Namespace,
            AssemblyIdentityAttribute->NamespaceCch,
            &Namespace));

    // Let's see if we can find it.
    IFFALSE_EXIT(
        ::SxspLocateInternalAssemblyIdentityAttribute(
            SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
            SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
            SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyIdentity,
            AssemblyIdentityAttribute,
            &InternalAttribute,
            &LastIndexSearched));

    if (InternalAttribute != NULL)
    {
        if (Flags & SXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_OVERWRITE_EXISTING)
        {
            // Ok, replace it!
            IFFALSE_EXIT(
                ::SxspAllocateInternalAssemblyIdentityAttribute(
                    0,
                    Namespace,
                    AssemblyIdentityAttribute->Name,
                    AssemblyIdentityAttribute->NameCch,
                    AssemblyIdentityAttribute->Value,
                    AssemblyIdentityAttribute->ValueCch,
                    &NewInternalAttribute));
            AssemblyIdentity->AttributePointerArray[LastIndexSearched] = NewInternalAttribute;
            NewInternalAttribute = NULL;

            ::SxspDeallocateInternalAssemblyIdentityAttribute(InternalAttribute);
        }
        else
        {
            // We actually wanted it to fail...
            ORIGINATE_WIN32_FAILURE_AND_EXIT(InserttingNonDuplicateAttribute, ERROR_DUP_NAME);
        }
    }
    else
    {
        IFFALSE_EXIT(
            ::SxspAllocateInternalAssemblyIdentityAttribute(
                0,
                Namespace,
                AssemblyIdentityAttribute->Name,
                AssemblyIdentityAttribute->NameCch,
                AssemblyIdentityAttribute->Value,
                AssemblyIdentityAttribute->ValueCch,
                &NewInternalAttribute));

        // Now we have it and we even know where to put it.  Grow the array if we need to.
        if (AssemblyIdentity->AttributeCount == AssemblyIdentity->AttributeArraySize)
        {
            NewAttributeArraySize = AssemblyIdentity->AttributeCount + 8;

            IFALLOCFAILED_EXIT(NewAttributePointerArray = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *) FUSION_RAW_ALLOC(sizeof(PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE) * NewAttributeArraySize, PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE));

            // Instead of copying the data and then shuffling, we'll copy the stuff before the insertion
            // point, fill in at the insertion point and then copy the rest.

            for (i=0; i<LastIndexSearched; i++)
                NewAttributePointerArray[i] = AssemblyIdentity->AttributePointerArray[i];

            for (i=LastIndexSearched; i<AssemblyIdentity->AttributeCount; i++)
                NewAttributePointerArray[i+1] = AssemblyIdentity->AttributePointerArray[i];

            if (AssemblyIdentity->AttributePointerArray != NULL)
                FUSION_RAW_DEALLOC((PVOID) AssemblyIdentity->AttributePointerArray);

            AssemblyIdentity->AttributePointerArray = NewAttributePointerArray;
            AssemblyIdentity->AttributeArraySize = NewAttributeArraySize;
        }
        else
        {
            // The array's big enough; shuffle the ending part of the array down one.
            for (i=AssemblyIdentity->AttributeCount; i>LastIndexSearched; i--)
                AssemblyIdentity->AttributePointerArray[i] = AssemblyIdentity->AttributePointerArray[i-1];
        }

        AssemblyIdentity->AttributePointerArray[LastIndexSearched] = NewInternalAttribute;
        NewInternalAttribute = NULL;

        AssemblyIdentity->AttributeCount++;
    }

    AssemblyIdentity->HashDirty = TRUE;

    fSuccess = TRUE;
Exit:
    if (NewInternalAttribute != NULL)
        ::SxspDeallocateInternalAssemblyIdentityAttribute(NewInternalAttribute);

    return fSuccess;
}

BOOL
SxsRemoveAssemblyIdentityAttributesByOrdinal(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    ULONG Ordinal,
    ULONG Count
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG AttributeCount;
    ULONG i;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    ULONG StopIndex;

    if ((Flags != 0) ||
        (AssemblyIdentity == NULL) ||
        (Count == 0))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    IFFALSE_EXIT(SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    AttributeCount = AssemblyIdentity->AttributeCount;
    AttributePointerArray = AssemblyIdentity->AttributePointerArray;

    // We can't delete outside the bounds of [0 .. AttributeCount - 1]
    if ((Ordinal >= AssemblyIdentity->AttributeCount) ||
        (Count > AssemblyIdentity->AttributeCount) ||
        ((Ordinal + Count) > AssemblyIdentity->AttributeCount))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    StopIndex = Ordinal + Count;

    // Let's get rid of them!  We're going to go through the array twice; it's somewhat
    // unnecessary but in the first run, we're going to NULL out any attribute pointers
    // that we're removing and clean up namespaces that aren't in use any more.  On the
    // second pass, we'll compress the array down.  This is somewhat wasteful, but
    // in the alternative case, we end up doing "Count" shifts down of the tail of the array.

    for (i = Ordinal; i < StopIndex; i++)
    {
        PCASSEMBLY_IDENTITY_NAMESPACE Namespace = NULL;
        PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = AttributePointerArray[i];

        // If this is the last use of this namespace, keep track of it so we can
        // clean it up.

        if ((i + 1) < AttributeCount)
        {
            // If the next attribute has a different namespace, there's some possibility
            // that this attribute was the last one that used it, so we'll delete the
            // attribute then ask to get rid of the namespace if there aren't any more
            // attributes using it.
            if (AttributePointerArray[i+1]->Namespace != InternalAttribute->Namespace)
                Namespace = InternalAttribute->Namespace;
        }

        AttributePointerArray[i] = NULL;

        SxspDeallocateInternalAssemblyIdentityAttribute(InternalAttribute);

        if (Namespace != NULL)
            SxspCleanUpAssemblyIdentityNamespaceIfNotReferenced(0, AssemblyIdentity, Namespace);
    }

    for (i = StopIndex; i < AttributeCount; i++)
    {
        AttributePointerArray[i - Count] = AttributePointerArray[i];
        AttributePointerArray[i] = NULL;
    }

    AssemblyIdentity->AttributeCount -= Count;
    AssemblyIdentity->HashDirty = TRUE;
    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxsFindAssemblyIdentityAttribute(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    ULONG *OrdinalOut,
    ULONG *CountOut OPTIONAL
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG ValidateAttributeFlags = 0;
    ULONG LocateAttributeFlags = 0;
    ULONG CompareAttributesFlags = 0;
    ULONG Ordinal;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = NULL;
    ULONG AttributeCount = 0;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    ULONG i;
    ULONG ComparisonResult;

    if (OrdinalOut != NULL)
        *OrdinalOut = 0;

    if (CountOut != NULL)
        *CountOut = 0;

    if (((Flags & ~(SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS)) != 0) ||
        (AssemblyIdentity == NULL) ||
        (Attribute == NULL))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if (Flags == 0)
        Flags = SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE;

    if ((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME) &&
        !(Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if ((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE) &&
        ((!(Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME)) ||
         (!(Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE))))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    IFFALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    ValidateAttributeFlags = 0;

    if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE)
    {
        ValidateAttributeFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE;
        LocateAttributeFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE;
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE;
    }

    if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME)
    {
        ValidateAttributeFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME;
        LocateAttributeFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME;
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME;
    }

    if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE)
    {
        ValidateAttributeFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE;
        LocateAttributeFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE;
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE;
    }

    IFFALSE_EXIT(::SxsValidateAssemblyIdentityAttribute(ValidateAttributeFlags, Attribute));

    if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS)
        LocateAttributeFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL;

    IFFALSE_EXIT(SxspLocateInternalAssemblyIdentityAttribute(LocateAttributeFlags, AssemblyIdentity, Attribute, &InternalAttribute, &Ordinal));

    INTERNAL_ERROR_CHECK((InternalAttribute != NULL) || (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS));

    if (InternalAttribute != NULL)
    {
        if (CountOut != NULL)
        {
            // We found it, now let's look for how many matches we have.  We'll separately handle the three levels
            // of specificity:

            AttributeCount = AssemblyIdentity->AttributeCount;
            AttributePointerArray = AssemblyIdentity->AttributePointerArray;

            for (i = (Ordinal + 1); i<AttributeCount; i++)
            {
                PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE AnotherInternalAttribute = AttributePointerArray[i];

                if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE)
                {
                    // If the hashes are different, we're certainly different.
                    if (AnotherInternalAttribute->WholeAttributeHash != InternalAttribute->WholeAttributeHash)
                        break;
                }
                else if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME)
                {
                    // If the hashes are different, we're certainly different.
                    if (AnotherInternalAttribute->NamespaceAndNameHash != InternalAttribute->NamespaceAndNameHash)
                        break;
                }
                else if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE)
                {
                    // If the hashes are different, we're certainly different.
                    if (AnotherInternalAttribute->Namespace->Hash != InternalAttribute->Namespace->Hash)
                        break;
                }
                else
                {
                    // Hey, how did we get here?
                    ::SetLastError(ERROR_INTERNAL_ERROR);
                    goto Exit;
                }

                IFFALSE_EXIT(
                    ::SxsCompareAssemblyIdentityAttributes(
                        CompareAttributesFlags,
                        Attribute,
                        &AnotherInternalAttribute->Attribute,
                        &ComparisonResult));

                if (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
                    break;
            }

            *CountOut = i - Ordinal;
        }

        if (OrdinalOut != NULL)
            *OrdinalOut = Ordinal;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

VOID
SxspCleanUpAssemblyIdentityNamespaceIfNotReferenced(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    PCASSEMBLY_IDENTITY_NAMESPACE Namespace
    )
{
    FN_TRACE();

    ASSERT(AssemblyIdentity != NULL);
    ASSERT(Flags == 0);

    if ((AssemblyIdentity != NULL) && (Namespace != NULL))
    {
        const ULONG AttributeCount = AssemblyIdentity->AttributeCount;
        PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = AssemblyIdentity->AttributePointerArray;
        ULONG i;

        // We could do some sort of binary search here based on the text string of the namespace since
        // the attributes are sorted first on namespace, but my guess is that a single text comparison
        // is worth a few dozen simple pointer comparisons, so the attribute array would have to be
        // pretty darned huge for the k1*O(log n) to be faster than the k2*(n) algorithm to actually
        // dominate.
        for (i=0; i<AttributeCount; i++)
        {
            const PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = AttributePointerArray[i];

            if ((InternalAttribute != NULL) &&
                (InternalAttribute->Namespace == Namespace))
                break;
        }

        if (i == AttributeCount)
        {
            // We fell through; it must be orphaned.
            const ULONG NamespaceCount = AssemblyIdentity->NamespaceCount;
            PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = AssemblyIdentity->NamespacePointerArray;

            for (i=0; i<NamespaceCount; i++)
            {
                if (NamespacePointerArray[i] == Namespace)
                    break;
            }

            // This assert should only fire if the namespace isn't actually present.
            ASSERT(i != NamespaceCount);

            if (i != NamespaceCount)
            {
                ULONG j;

                for (j=(i+1); j<NamespaceCount; j++)
                    NamespacePointerArray[j-1] = NamespacePointerArray[j];

                NamespacePointerArray[NamespaceCount - 1] = NULL;

                ::SxspDeallocateAssemblyIdentityNamespace(Namespace);

                AssemblyIdentity->NamespaceCount--;
            }
        }
    }

    AssemblyIdentity->HashDirty = TRUE;
}

BOOL
SxsGetAssemblyIdentityAttributeByOrdinal(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    ULONG Ordinal,
    SIZE_T BufferSize,
    PASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttributeBuffer,
    SIZE_T *BytesWrittenOrRequired
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (BytesWrittenOrRequired != NULL)
        *BytesWrittenOrRequired = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK((BufferSize == 0) || (AssemblyIdentityAttributeBuffer != NULL));
    PARAMETER_CHECK((BufferSize != 0) || (BytesWrittenOrRequired != NULL));
    PARAMETER_CHECK(Ordinal < AssemblyIdentity->AttributeCount);

    IFFALSE_EXIT(
        ::SxspCopyInternalAssemblyIdentityAttributeOut(
            0,
            AssemblyIdentity->AttributePointerArray[Ordinal],
            BufferSize,
            AssemblyIdentityAttributeBuffer,
            BytesWrittenOrRequired));

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxsDuplicateAssemblyIdentity(
    DWORD Flags,
    PCASSEMBLY_IDENTITY Source,
    PASSEMBLY_IDENTITY *Destination
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY NewIdentity = NULL;
    ULONG CreateAssemblyIdentityFlags = 0;

    if (Destination != NULL)
        *Destination = NULL;

    PARAMETER_CHECK((Flags & ~(SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE | SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_ALLOW_NULL)) == 0);
    PARAMETER_CHECK(((Flags & SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_ALLOW_NULL) != 0) || (Source != NULL));
    PARAMETER_CHECK(Destination != NULL);

    if (Flags & SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
        CreateAssemblyIdentityFlags |= SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE;

    //
    //  We depend on the Attribute field being first in the internal attribute
    //  structure below where we callously cast a pointer to an array of
    //  internal attribute pointers into a pointer to an array of attribute pointers.
    //

    ASSERT(FIELD_OFFSET(INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE, Attribute) == 0);

    if (Source != NULL)
    {
        IFFALSE_EXIT(
            ::SxsCreateAssemblyIdentity(
                        CreateAssemblyIdentityFlags,
                        Source->Type,
                        &NewIdentity,
                        Source->AttributeCount,
                        (PASSEMBLY_IDENTITY_ATTRIBUTE const *) Source->AttributePointerArray));
    }

    *Destination = NewIdentity;
    NewIdentity = NULL;

    fSuccess = TRUE;

Exit:
    if (NewIdentity != NULL)
        SxsDestroyAssemblyIdentity(NewIdentity);

    return fSuccess;
}

BOOL
SxsQueryAssemblyIdentityInformation(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PVOID Buffer,
    SIZE_T BufferSize,
    ASSEMBLY_IDENTITY_INFORMATION_CLASS AssemblyIdentityInformationClass
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if ((Flags != 0) ||
        (AssemblyIdentity == NULL) ||
        (AssemblyIdentityInformationClass != AssemblyIdentityBasicInformation))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    IFFALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    switch (AssemblyIdentityInformationClass)
    {
        default:
            ASSERT(FALSE);
            ::SetLastError(ERROR_INTERNAL_ERROR);
            goto Exit;

        case AssemblyIdentityBasicInformation: {
            PASSEMBLY_IDENTITY_BASIC_INFORMATION BasicBuffer = NULL;

            if (BufferSize < sizeof(ASSEMBLY_IDENTITY_BASIC_INFORMATION))
            {
                ::SetLastError(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }

            BasicBuffer = (PASSEMBLY_IDENTITY_BASIC_INFORMATION) Buffer;

            BasicBuffer->Flags = AssemblyIdentity->Flags;
            BasicBuffer->Type = AssemblyIdentity->Type;
            BasicBuffer->AttributeCount = AssemblyIdentity->AttributeCount;
            BasicBuffer->Hash = AssemblyIdentity->Hash;

            break;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxsEnumerateAssemblyIdentityAttributes(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    IN PSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_ENUMERATION_ROUTINE EnumerationRoutine,
    IN PVOID Context
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG AttributeCount;
    ULONG i;
    ULONG ValidateFlags = 0;
    ULONG CompareFlags = 0;

    if (((Flags & ~(SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAMESPACE |
                    SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAME |
                    SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_VALUE)) != 0) ||
        ((Flags & (SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAMESPACE |
                   SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAME |
                   SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_VALUE)) &&
         (Attribute == NULL)) ||
        (AssemblyIdentity == NULL) ||
        (EnumerationRoutine == NULL))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    IFFALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    if (Flags & SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAMESPACE)
    {
        ValidateFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE;
        CompareFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE;
    }

    if (Flags & SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAME)
    {
        ValidateFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME;
        CompareFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME;
    }

    if (Flags & SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_VALUE)
    {
        ValidateFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE;
        CompareFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE;
    }

    IFFALSE_EXIT(::SxsValidateAssemblyIdentityAttribute(ValidateFlags, Attribute));

    AttributeCount = AssemblyIdentity->AttributeCount;

    for (i=0; i<AttributeCount; i++)
    {
        PCASSEMBLY_IDENTITY_ATTRIBUTE CandidateAttribute = &AssemblyIdentity->AttributePointerArray[i]->Attribute;
        ULONG ComparisonResult = 0;

        if (CompareFlags != 0)
        {
            IFFALSE_EXIT(
                ::SxsCompareAssemblyIdentityAttributes(
                    CompareFlags,
                    Attribute,
                    CandidateAttribute,
                    &ComparisonResult));

            // If they're not equal, skip it!
            if (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
                continue;
        }

        (*EnumerationRoutine)(
            AssemblyIdentity,
            CandidateAttribute,
            Context);
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspIsInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    OUT BOOL *EqualsOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (EqualsOut != NULL)
        *EqualsOut = FALSE;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK(Namespace != NULL || NamespaceCch == 0);
    PARAMETER_CHECK(Name != NULL || NameCch == 0);
    PARAMETER_CHECK(EqualsOut != NULL);

    if ((NamespaceCch == Attribute->Attribute.NamespaceCch) &&
        (NameCch == Attribute->Attribute.NameCch))
    {
        if ((NamespaceCch == 0) ||
            (memcmp(Attribute->Attribute.Namespace, Namespace, NamespaceCch * sizeof(WCHAR)) == 0))
        {
            if ((NameCch == 0) ||
                (memcmp(Attribute->Attribute.Name, Name, NameCch * sizeof(WCHAR)) == 0))
            {
                *EqualsOut = TRUE;
            }
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\id\idaux.h ===
#pragma once

#define NUMBER_OF(x) ( (sizeof(x) / sizeof(*x) ) )
#define IFFAILED_EXIT(_x) do {HRESULT __hr = (_x); if (FAILED(__hr)) { goto Exit; } } while (0)
#define IFFALSE_EXIT(_x) do {if (!(_x)) {goto Exit; } } while (0)

#define FN_TRACE_WIN32(args)
#define FN_TRACE()

#define PARAMETER_CHECK(args) IFFALSE_EXIT(args)

#define IFALLOCFAILED_EXIT(_x) do {if ((_x) == NULL) {goto Exit; } } while (0)

#define FUSION_HASH_ALGORITHM HASH_STRING_ALGORITHM_X65599

#define FUSION_NEW_ARRAY(_type, _n) (new _type[_n])
#define FUSION_RAW_ALLOC_(_heap, _cb, _typeTag) (new BYTE[_cb])

#define FUSION_RAW_ALLOC(_cb, _typeTag) (new BYTE[_cb])

#define ASSERT(_x) 
#define FUSION_DELETE_ARRAY(_ptr) (delete _ptr)
#define FUSION_RAW_DEALLOC_(_heap, _ptr) (delete _ptr)
#define FUSION_RAW_DEALLOC(_ptr) (delete _ptr)

#define ORIGINATE_WIN32_FAILURE_AND_EXIT(_x, _le) do {  ::SetLastError(_le); goto Exit; } while (0)

#define FUSION_DBG_LEVEL_VERBOSE 0

#define INTERNAL_ERROR_CHECK(_e) 

#define FUSION_NEW_SINGLETON(_type) (new _type)

#define FUSION_DELETE_SINGLETON(_ptr) (delete _ptr)

#define HARD_ASSERT_ACTION(_e)



ULONG
FusionpDbgPrintEx(
    ULONG Level,
    PCSTR Format,
    ...
    );


int
FusionpCompareStrings(
    PCWSTR psz1,
    SIZE_T cch1,
    PCWSTR psz2,
    SIZE_T cch2,
    bool fCaseInsensitive
    );


BOOL
FusionpHashUnicodeString(
    PCWSTR szString,
    SIZE_T cchString,
    PULONG HashValue,
    DWORD dwCmpFlags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\id\encdec.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sxsasmidencdec.c

Abstract:

    Implementation of the encoding/decoding support for the assembly identity data type.

Author:

    Michael Grier (MGrier) 7/28/2000

Revision History:

--*/


//adriaanc
//#include "stdinc.h"
//#include <setupapi.h>

#include <sxsapi.h>

// adriaanc
//#include <stdlib.h>
//#include <search.h>

// adriaanc
#include "idaux.h"

#include "idp.h"
static const WCHAR s_rgHexChars[] = L"0123456789abcdef";

// adriaanc
#undef FN_TRACE_WIN32
#define FN_TRACE_WIN32(args)
#undef PARAMETER_CHECK
#define PARAMETER_CHECK(args)

BOOL
SxsComputeAssemblyIdentityEncodedSize(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN const GUID *EncodingGroup OPTIONAL,
    IN ULONG EncodingFormat,
    OUT SIZE_T *SizeOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T Size = 0;
    ULONG i;
    ULONG AttributeCount, NamespaceCount;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = NULL;

    if (SizeOut != NULL)
        *SizeOut = 0;

    if ((Flags != 0) ||
        (AssemblyIdentity == NULL) ||
        (SizeOut == NULL)) {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if (EncodingGroup != NULL)
    {
        ::SetLastError(ERROR_SXS_UNKNOWN_ENCODING_GROUP);
        goto Exit;
    }

    if ((EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY) &&
        (EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL))
    {
        ::SetLastError(ERROR_SXS_UNKNOWN_ENCODING);
        goto Exit;
    }

    IFFALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    AttributeCount = AssemblyIdentity->AttributeCount;
    NamespaceCount = AssemblyIdentity->NamespaceCount;
    AttributePointerArray = AssemblyIdentity->AttributePointerArray;
    NamespacePointerArray = AssemblyIdentity->NamespacePointerArray;
    
    switch (EncodingFormat)
    {
    case SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY:
        // First, we know we need a header.

        Size = sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER);

        // Then a ULONG hash per attribute:
        Size += (AssemblyIdentity->AttributeCount * sizeof(ULONG));

        // Then a USHORT per namespace...
        Size += (AssemblyIdentity->NamespaceCount * sizeof(ULONG));

        // Then we need an attribute header per attribute:

        Size += AssemblyIdentity->AttributeCount * sizeof(ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER);

        // Then come the namespace strings...

        for (i=0; i<NamespaceCount; i++)
            Size += NamespacePointerArray[i]->NamespaceCch * sizeof(WCHAR);

        // Then we need space for each of the attributes' names and value.

        AttributePointerArray = AssemblyIdentity->AttributePointerArray;

        for (i=0; i<AttributeCount; i++)
        {
            ASSERT(AttributePointerArray[i] != NULL);
            if (AttributePointerArray[i] == NULL)
            {
                ::SetLastError(ERROR_INTERNAL_ERROR);
                goto Exit;
            }

            Size += AttributePointerArray[i]->Attribute.NameCch * sizeof(WCHAR);
            Size += AttributePointerArray[i]->Attribute.ValueCch * sizeof(WCHAR);
        }

        // We should at least be byte aligned here...
        ASSERT((Size % 2) == 0);

        // And finally pad out to a multiple of four if we are not...
        Size = (Size + 3) & ~3;

        break;

    case SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL:
        for (i=0; i<AttributeCount; i++)
        {
            PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute = AttributePointerArray[i];
            BOOL IsAssemblyName = FALSE;
            SIZE_T BytesThisAttribute = 0;

            INTERNAL_ERROR_CHECK(Attribute != NULL);

            IFFALSE_EXIT(SxspIsInternalAssemblyIdentityAttribute(
                                0,
                                Attribute,
                                NULL,
                                0,
                                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME,
                                NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME) - 1,
                                &IsAssemblyName));

            // It's the attribute name.  Just account for the size of the encoded value string
            IFFALSE_EXIT(::SxspComputeInternalAssemblyIdentityAttributeEncodedTextualSize(
                            IsAssemblyName ?
                                SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_VALUE_ONLY |
                                    SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_OMIT_QUOTES
                                    : 0,
                            Attribute,
                            &BytesThisAttribute));

            // Account for the separator character
            if (i != 0)
                Size += sizeof(WCHAR);

            Size += BytesThisAttribute;
        }

        break;
    }

    *SizeOut = Size;

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspComputeQuotedStringSize(
    IN DWORD Flags,
    IN const WCHAR *StringIn,
    IN SIZE_T Cch,
    OUT SIZE_T *BytesOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T Bytes = 0;

    if (BytesOut != NULL)
        *BytesOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(StringIn != NULL || Cch == 0);
    PARAMETER_CHECK(BytesOut != NULL);

    while (Cch != 0)
    {
        const WCHAR wch = *StringIn++;

        if (((wch >= L'A') && (wch <= L'Z')) ||
            ((wch >= L'a') && (wch <= L'z')) ||
            ((wch >= L'0') && (wch <= L'9')) ||
            (wch == L'.') ||
            (wch == L'-') ||
            (wch == L'_'))
        {
            Bytes += sizeof(WCHAR);
        }
        else
        {
            switch (wch)
            {
            case L'&':
                // &amp;
                Bytes += (5 * sizeof(WCHAR));
                break;

            case L'"':
                // &quot;
                Bytes += (6 * sizeof(WCHAR));
                break;

            case L'<':
                // &lt;
                Bytes += (4 * sizeof(WCHAR));
                break;

            case L'>':
                // &gt;
                Bytes += (4 * sizeof(WCHAR));
                break;

            case L'\'':
                // &apos;
                Bytes += (6 * sizeof(WCHAR));
                break;

            default:
                // Otherwise, it's going to be &#xn;
                if (wch < 0x10)
                    Bytes += (5 * sizeof(WCHAR));
                else if (wch < 0x100)
                    Bytes += (6 * sizeof(WCHAR));
                else if (wch < 0x1000)
                    Bytes += (7 * sizeof(WCHAR));
                else
                    Bytes += (8 * sizeof(WCHAR));
                break;
            }
        }

        Cch--;
    }

    *BytesOut = Bytes;
    fSuccess = TRUE;
// adriaanc
// Exit:
    return fSuccess;
}

BOOL
SxspQuoteString(
    IN DWORD Flags,
    IN const WCHAR *StringIn,
    IN SIZE_T Cch,
    IN SIZE_T BufferSize,
    IN PVOID Buffer,
    OUT SIZE_T *BytesWrittenOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    WCHAR *Cursor;
    SIZE_T BytesWritten = 0;
    SIZE_T BytesLeft = BufferSize;

    if (BytesWrittenOut != NULL)
        *BytesWrittenOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(StringIn != NULL || Cch == 0);
    PARAMETER_CHECK(Buffer != NULL || BufferSize == 0);

    Cursor = (WCHAR *) Buffer;
    BytesWritten = 0;

    while (Cch != 0)
    {
        const WCHAR wch = *StringIn++;

        if (((wch >= L'A') && (wch <= L'Z')) ||
            ((wch >= L'a') && (wch <= L'z')) ||
            ((wch >= L'0') && (wch <= L'9')) ||
            (wch == L'.') ||
            (wch == L'-') ||
            (wch == L'_'))
        {
            if (BytesLeft < sizeof(WCHAR))
            {
                ::SetLastError(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }

            *Cursor++ = wch;
            BytesLeft -= sizeof(WCHAR);
            BytesWritten += sizeof(WCHAR);
        }
        else
        {

#define HANDLE_CASE(_wch, _wstr) \
            case _wch: \
            { \
            ULONG i; \
            if (BytesLeft < (sizeof(_wstr) - sizeof(WCHAR))) \
            { \
                ::SetLastError(ERROR_INSUFFICIENT_BUFFER); \
                goto Exit; \
            } \
            for (i=0; i<(NUMBER_OF(_wstr) - 1); i++) \
                *Cursor++ = _wstr[i]; \
            BytesLeft -= (sizeof(_wstr) - sizeof(WCHAR)); \
            BytesWritten += (sizeof(_wstr) - sizeof(WCHAR)); \
            break; \
            }

            switch (wch)
            {
            HANDLE_CASE(L'"', L"&quot;")
            HANDLE_CASE(L'&', L"&amp;")
            HANDLE_CASE(L'<', L"&lt;")
            HANDLE_CASE(L'>', L"&gt;")
            HANDLE_CASE(L'\'', L"&apos;")

            default:
                if (wch < 0x10)
                {
                    if (BytesLeft < (5 * sizeof(WCHAR)))
                    {
                        ::SetLastError(ERROR_INSUFFICIENT_BUFFER);
                        goto Exit;
                    }

                    *Cursor++ = L'&';
                    *Cursor++ = L'#';
                    *Cursor++ = L'x';
                    *Cursor++ = s_rgHexChars[wch];
                    *Cursor++ = L';';

                    BytesWritten += (5 * sizeof(WCHAR));
                    BytesLeft -= (5 * sizeof(WCHAR));
                }
                else if (wch < 0x100)
                {
                    if (BytesLeft < (6 * sizeof(WCHAR)))
                    {
                        ::SetLastError(ERROR_INSUFFICIENT_BUFFER);
                        goto Exit;
                    }
                    *Cursor++ = L'&';
                    *Cursor++ = L'#';
                    *Cursor++ = L'x';
                    *Cursor++ = s_rgHexChars[(wch >> 4) & 0xf];
                    *Cursor++ = s_rgHexChars[wch & 0xf];
                    *Cursor++ = L';';

                    BytesWritten += (6 * sizeof(WCHAR));
                    BytesLeft -= (6 * sizeof(WCHAR));
                }
                else if (wch < 0x1000)
                {
                    if (BytesLeft < (7 * sizeof(WCHAR)))
                    {
                        ::SetLastError(ERROR_INSUFFICIENT_BUFFER);
                        goto Exit;
                    }
                    *Cursor++ = L'&';
                    *Cursor++ = L'#';
                    *Cursor++ = L'x';
                    *Cursor++ = s_rgHexChars[(wch >> 8) & 0xf];
                    *Cursor++ = s_rgHexChars[(wch >> 4) & 0xf];
                    *Cursor++ = s_rgHexChars[wch & 0xf];
                    *Cursor++ = L';';

                    BytesWritten += (7 * sizeof(WCHAR));
                    BytesLeft -= (7 * sizeof(WCHAR));
                }
                else
                {
                    INTERNAL_ERROR_CHECK(wch <= 0xffff);

                    if (BytesLeft < (8 * sizeof(WCHAR)))
                    {
                        ::SetLastError(ERROR_INSUFFICIENT_BUFFER);
                        goto Exit;
                    }
                    *Cursor++ = L'&';
                    *Cursor++ = L'#';
                    *Cursor++ = L'x';
                    *Cursor++ = s_rgHexChars[(wch >> 12) & 0xf];
                    *Cursor++ = s_rgHexChars[(wch >> 8) & 0xf];
                    *Cursor++ = s_rgHexChars[(wch >> 4) & 0xf];
                    *Cursor++ = s_rgHexChars[wch & 0xf];
                    *Cursor++ = L';';

                    BytesWritten += (8 * sizeof(WCHAR));
                    BytesLeft -= (8 * sizeof(WCHAR));
                }

                break;
            }

        }

        Cch--;
    }

    if (BytesWrittenOut != NULL)
        *BytesWrittenOut = BytesWritten;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspComputeInternalAssemblyIdentityAttributeEncodedTextualSize(
    IN DWORD Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT SIZE_T *BytesOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T Bytes = 0;
    SIZE_T BytesTemp = 0;

    if (BytesOut != NULL)
        *BytesOut = 0;

    PARAMETER_CHECK((Flags & ~(
                                SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_VALUE_ONLY |
                                SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_OMIT_QUOTES)) == 0);
    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK(BytesOut != NULL);

    Bytes = 0;
    if ((Flags & SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_VALUE_ONLY) == 0)
    {
        if (Attribute->Attribute.NamespaceCch != 0)
        {
            // Figure out the ns:n= part
            IFFALSE_EXIT(::SxspComputeQuotedStringSize(0, Attribute->Attribute.Namespace, Attribute->Attribute.NamespaceCch, &BytesTemp));
            Bytes += BytesTemp;
            Bytes += sizeof(WCHAR); // the ":"
        }

        IFFALSE_EXIT(::SxspComputeQuotedStringSize(0, Attribute->Attribute.Name, Attribute->Attribute.NameCch, &BytesTemp));
        Bytes += BytesTemp;
        Bytes += sizeof(WCHAR); // the "="
    }

    IFFALSE_EXIT(::SxspComputeQuotedStringSize(0, Attribute->Attribute.Value, Attribute->Attribute.ValueCch, &BytesTemp));
    Bytes += BytesTemp;

    if ((Flags & SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_OMIT_QUOTES) == 0)
        Bytes += 2 * sizeof(WCHAR); // the beginning and ending quotes

    *BytesOut = Bytes;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspEncodeInternalAssemblyIdentityAttributeAsText(
    IN DWORD Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    SIZE_T BufferSize,
    PVOID Buffer,
    SIZE_T *BytesWrittenOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T BytesWritten = 0;
    SIZE_T BytesLeft = 0;
    SIZE_T BytesThisSegment;
    WCHAR *Cursor;

    if (BytesWrittenOut != NULL)
        *BytesWrittenOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK((Buffer != NULL) || (BufferSize == 0));

    BytesWritten = 0;
    BytesLeft = BufferSize;
    Cursor = reinterpret_cast<WCHAR *>(Buffer);

    if (Attribute->Attribute.NamespaceCch != 0)
    {
        IFFALSE_EXIT(::SxspQuoteString(0, Attribute->Namespace->Namespace, Attribute->Namespace->NamespaceCch, BytesLeft, Cursor, &BytesThisSegment));

        INTERNAL_ERROR_CHECK(BytesThisSegment <= BytesLeft);

        Cursor = (WCHAR *) (((ULONG_PTR) Cursor) + BytesThisSegment);
        BytesLeft -= BytesThisSegment;
        BytesWritten += BytesThisSegment;

        if (BytesLeft < sizeof(WCHAR))
        {
            ::SetLastError(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        *Cursor++ = L':';
        BytesLeft -= sizeof(WCHAR);
        BytesWritten += sizeof(WCHAR);
    }

    IFFALSE_EXIT(::SxspQuoteString(0, Attribute->Attribute.Name, Attribute->Attribute.NameCch, BytesLeft, Cursor, &BytesThisSegment));

    INTERNAL_ERROR_CHECK(BytesThisSegment <= BytesLeft);

    Cursor = (WCHAR *) (((ULONG_PTR) Cursor) + BytesThisSegment);
    BytesLeft -= BytesThisSegment;
    BytesWritten += BytesThisSegment;

    if (BytesLeft < (2 * sizeof(WCHAR)))
    {
        ::SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    *Cursor++ = L'=';
    *Cursor++ = L'"';
    BytesLeft -= (2 * sizeof(WCHAR));
    BytesWritten += (2 * sizeof(WCHAR));

    IFFALSE_EXIT(::SxspQuoteString(0, Attribute->Attribute.Value, Attribute->Attribute.ValueCch, BytesLeft, Cursor, &BytesThisSegment));

    INTERNAL_ERROR_CHECK(BytesThisSegment <= BytesLeft);

    Cursor = (WCHAR *) (((ULONG_PTR) Cursor) + BytesThisSegment);
    BytesLeft -= BytesThisSegment;
    BytesWritten += BytesThisSegment;

    if (BytesLeft < sizeof(WCHAR))
    {
        ::SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    *Cursor++ = L'"';
    BytesLeft -= sizeof(WCHAR);
    BytesWritten += sizeof(WCHAR);

    *BytesWrittenOut = BytesWritten;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspEncodeAssemblyIdentityTextually(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN SIZE_T BufferSize,
    IN PVOID Buffer,
    OUT SIZE_T *BytesWrittenOut)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG AttributeCount, NamespaceCount;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Attributes;
    PCASSEMBLY_IDENTITY_NAMESPACE *Namespaces;
    ULONG i;
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE NameInternalAttribute = NULL;
    SIZE_T BytesLeft;
    SIZE_T BytesWritten;
    PVOID Cursor;
    SIZE_T TempBytesWritten;

    if (BytesWrittenOut != NULL)
        *BytesWrittenOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(BufferSize != 0);
    PARAMETER_CHECK(Buffer != NULL);
    PARAMETER_CHECK(BytesWrittenOut != NULL);

    Cursor = Buffer;
    BytesLeft = BufferSize;
    BytesWritten = 0;

    // The root assembly identity is actually totally empty, so we'll short-circuit that case.
    AttributeCount = AssemblyIdentity->AttributeCount;
    if (AttributeCount != 0)
    {
        NamespaceCount = AssemblyIdentity->NamespaceCount;
        Attributes = AssemblyIdentity->AttributePointerArray;
        Namespaces = AssemblyIdentity->NamespacePointerArray;

        // First, let's look for the "name" attribute.
        Attribute.Flags = 0;
        Attribute.Namespace = NULL;
        Attribute.NamespaceCch = 0;
        Attribute.Name = SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME;
        Attribute.NameCch = NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME) - 1;

        IFFALSE_EXIT(
            ::SxspLocateInternalAssemblyIdentityAttribute(
                SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                    SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME,
                AssemblyIdentity,
                &Attribute,
                &NameInternalAttribute,
                NULL));
        INTERNAL_ERROR_CHECK(NameInternalAttribute != NULL);

        IFFALSE_EXIT(::SxspQuoteString(0, NameInternalAttribute->Attribute.Value, NameInternalAttribute->Attribute.ValueCch, BytesLeft, Cursor, &TempBytesWritten));
        INTERNAL_ERROR_CHECK(TempBytesWritten <= BytesLeft);

        Cursor = (PVOID) (((ULONG_PTR) Cursor) + TempBytesWritten);
        BytesLeft -= TempBytesWritten;
        BytesWritten += TempBytesWritten;

        for (i=0; i<AttributeCount; i++)
        {
            // Skip the standard "name" attribute
            if (Attributes[i] == NameInternalAttribute)
                continue;

            if (BytesLeft < sizeof(WCHAR))
            {
                ::SetLastError(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }

            *((WCHAR *) Cursor) = L',';
            Cursor = (PVOID) (((ULONG_PTR) Cursor) + sizeof(WCHAR));
            BytesLeft -= sizeof(WCHAR);
            BytesWritten += sizeof(WCHAR);

            IFFALSE_EXIT(::SxspEncodeInternalAssemblyIdentityAttributeAsText(0, Attributes[i], BytesLeft, Cursor, &TempBytesWritten));
            INTERNAL_ERROR_CHECK(TempBytesWritten <= BytesLeft);

            Cursor = (PVOID) (((ULONG_PTR) Cursor) + TempBytesWritten);
            BytesLeft -= TempBytesWritten;
            BytesWritten += TempBytesWritten;
        }
    }

    *BytesWrittenOut = BytesWritten;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
SxsEncodeAssemblyIdentity(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN const GUID *EncodingGroup OPTIONAL, // use NULL to use any of the SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_* encodings
    IN ULONG EncodingFormat,
    IN SIZE_T BufferSize,
    OUT PVOID Buffer,
    OUT SIZE_T *BytesWrittenOrRequired
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T TotalSize = 0;
    PVOID Cursor = NULL;
    SIZE_T i;
    PENCODED_ASSEMBLY_IDENTITY_HEADER EncodedAssemblyIdentityHeader = NULL;
    PENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER EncodedAssemblyIdentityAttributeHeader = NULL;
    ULONG *TempULONGArrayPointer;
    SIZE_T BytesWritten = 0;
    ULONG AttributeCount, NamespaceCount;

    if (BytesWrittenOrRequired != NULL)
        *BytesWrittenOrRequired = 0;

    if ((Flags != 0) ||
        (AssemblyIdentity == NULL) ||
        ((BufferSize != 0) && (Buffer == NULL)) ||
        ((BufferSize == 0) && (BytesWrittenOrRequired == NULL)))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if (EncodingGroup != NULL)
    {
        ::SetLastError(ERROR_SXS_UNKNOWN_ENCODING_GROUP);
        goto Exit;
    }

    if ((EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY) &&
        (EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL))
    {
        ::SetLastError(ERROR_SXS_UNKNOWN_ENCODING);
        goto Exit;
    }

    IFFALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));
    IFFALSE_EXIT(::SxsComputeAssemblyIdentityEncodedSize(0, AssemblyIdentity, EncodingGroup, EncodingFormat, &TotalSize));

    if (TotalSize > BufferSize)
    {
        if (BytesWrittenOrRequired != NULL)
            *BytesWrittenOrRequired = TotalSize;

        ::SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    AttributeCount = AssemblyIdentity->AttributeCount;
    NamespaceCount = AssemblyIdentity->NamespaceCount;

    //
    //  Let's start filling it in.
    //

    switch (EncodingFormat)
    {
    case SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY:
        BytesWritten = 0;
        Cursor = Buffer;

        EncodedAssemblyIdentityHeader = (PENCODED_ASSEMBLY_IDENTITY_HEADER) Cursor;
        Cursor = (PVOID) (((ULONG_PTR) Cursor) + sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER));
        BytesWritten += sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER);

        EncodedAssemblyIdentityHeader->HeaderSize = sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER);
        EncodedAssemblyIdentityHeader->Magic = ENCODED_ASSEMBLY_IDENTITY_HEADER_MAGIC;
        EncodedAssemblyIdentityHeader->TotalSize = static_cast<ULONG>(TotalSize);
        // turn off any flags not relevant to persisted state
        EncodedAssemblyIdentityHeader->Type = AssemblyIdentity->Type;
        EncodedAssemblyIdentityHeader->Flags = AssemblyIdentity->Flags & ~(ASSEMBLY_IDENTITY_FLAG_FROZEN);
        EncodedAssemblyIdentityHeader->EncodingFlags = 0;
        EncodedAssemblyIdentityHeader->AttributeCount = AttributeCount;
        EncodedAssemblyIdentityHeader->NamespaceCount = NamespaceCount;
        EncodedAssemblyIdentityHeader->ReservedMustBeZero1 = 0;
        EncodedAssemblyIdentityHeader->ReservedMustBeZero2 = 0;
        EncodedAssemblyIdentityHeader->ReservedMustBeZero3 = 0;
        EncodedAssemblyIdentityHeader->ReservedMustBeZero4 = 0;

        TempULONGArrayPointer = (ULONG *) Cursor;
        Cursor = (PVOID) (TempULONGArrayPointer + AttributeCount);
        BytesWritten += (AttributeCount * sizeof(ULONG));

        for (i=0; i<AttributeCount; i++)
            TempULONGArrayPointer[i] = AssemblyIdentity->AttributePointerArray[i]->WholeAttributeHash;

        // sort 'em...
        qsort(TempULONGArrayPointer, AttributeCount, sizeof(ULONG), &SxspCompareULONGsForQsort);

        TempULONGArrayPointer = (ULONG *) Cursor;
        Cursor = (PVOID) (TempULONGArrayPointer + NamespaceCount);
        BytesWritten += (sizeof(ULONG) * NamespaceCount);

        for (i=0; i<NamespaceCount; i++)
            TempULONGArrayPointer[i] = static_cast<ULONG>(AssemblyIdentity->NamespacePointerArray[i]->NamespaceCch);

        EncodedAssemblyIdentityAttributeHeader = (PENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER) Cursor;
        Cursor = (PVOID) (EncodedAssemblyIdentityAttributeHeader + AttributeCount);
        BytesWritten += (AttributeCount * sizeof(ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER));

        for (i=0; i<AttributeCount; i++)
        {
            PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = AssemblyIdentity->AttributePointerArray[i];
            ULONG NamespaceIndex;

            // Totally gross linear search to determine the namespace index.  Fortunately the common case
            // will be a single namespace for all attributes.
            for (NamespaceIndex = 0; NamespaceIndex < NamespaceCount; NamespaceIndex++)
            {
                if (AssemblyIdentity->NamespacePointerArray[NamespaceIndex] == InternalAttribute->Namespace)
                    break;
            }

            // If this assert fires, the attribute refers to a namespace that's not in the identity; bad!
            INTERNAL_ERROR_CHECK(
                (InternalAttribute->Namespace == NULL) ||
                (NamespaceIndex < NamespaceCount));

            EncodedAssemblyIdentityAttributeHeader[i].NamespaceIndex = NamespaceIndex + 1;
            EncodedAssemblyIdentityAttributeHeader[i].NameCch = static_cast<ULONG>(InternalAttribute->Attribute.NameCch);
            EncodedAssemblyIdentityAttributeHeader[i].ValueCch = static_cast<ULONG>(InternalAttribute->Attribute.ValueCch);
        }

        // so much for the fixed length stuff; write the namespaces.
        for (i=0; i<NamespaceCount; i++)
        {
            PWSTR psz = (PWSTR) Cursor;
            Cursor = (PVOID) (((ULONG_PTR) psz) + (AssemblyIdentity->NamespacePointerArray[i]->NamespaceCch * sizeof(WCHAR)));

            BytesWritten += (AssemblyIdentity->NamespacePointerArray[i]->NamespaceCch * sizeof(WCHAR));

            memcpy(
                psz,
                AssemblyIdentity->NamespacePointerArray[i]->Namespace,
                AssemblyIdentity->NamespacePointerArray[i]->NamespaceCch * sizeof(WCHAR));
        }

        // And the attributes...
        for (i=0; i<AttributeCount; i++)
        {
            PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = AssemblyIdentity->AttributePointerArray[i];
            PWSTR psz;

            psz = (PWSTR) Cursor;
            Cursor = (PVOID) (((ULONG_PTR) psz) + (InternalAttribute->Attribute.NameCch * sizeof(WCHAR)));
            BytesWritten += (InternalAttribute->Attribute.NameCch * sizeof(WCHAR));

            memcpy(
                psz,
                InternalAttribute->Attribute.Name,
                InternalAttribute->Attribute.NameCch * sizeof(WCHAR));

            psz = (PWSTR) Cursor;
            Cursor = (PVOID) (((ULONG_PTR) psz) + InternalAttribute->Attribute.ValueCch * sizeof(WCHAR));
            BytesWritten += InternalAttribute->Attribute.ValueCch * sizeof(WCHAR);

            memcpy(
                psz,
                InternalAttribute->Attribute.Value,
                InternalAttribute->Attribute.ValueCch * sizeof(WCHAR));
        }

        if ((BytesWritten % 4) != 0) {
            ASSERT((BytesWritten % 4) == sizeof(USHORT));

            *((USHORT *) Cursor) = 0;
            BytesWritten += sizeof(USHORT);
        }
        
        break;

    case SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL:
        IFFALSE_EXIT(::SxspEncodeAssemblyIdentityTextually(0, AssemblyIdentity, BufferSize, Buffer, &BytesWritten));
        break;
    }

    INTERNAL_ERROR_CHECK(BytesWritten == TotalSize);

    if (BytesWrittenOrRequired != NULL)
        *BytesWrittenOrRequired = BytesWritten;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxsDecodeAssemblyIdentity(
    ULONG Flags,
    IN const GUID *EncodingGroup,
    IN ULONG EncodingFormat,
    IN SIZE_T BufferSize,
    IN const VOID *Buffer,
    OUT PASSEMBLY_IDENTITY *AssemblyIdentityOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCENCODED_ASSEMBLY_IDENTITY_HEADER EncodedAssemblyIdentityHeader = NULL;
    PCENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER EncodedAssemblyIdentityAttributeHeader = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = NULL;
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;
    ULONG AttributeCount = 0;
    ULONG NamespaceCount = 0;
    ULONG AttributeArraySize = 0;
    ULONG NamespaceArraySize = 0;
    ULONG i;
    const ULONG *NamespaceLengthArray = NULL;
    const ULONG *AttributeHashArray = NULL;
    const WCHAR *UnicodeStringArray = NULL;

    if (AssemblyIdentityOut != NULL)
        *AssemblyIdentityOut = NULL;

    if (((Flags & ~(SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE)) != 0) ||
        (BufferSize < sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER)) ||
        (Buffer == NULL) ||
        (AssemblyIdentityOut == NULL)) {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if (EncodingGroup != NULL)
    {
        ::SetLastError(ERROR_SXS_UNKNOWN_ENCODING_GROUP);
        goto Exit;
    }

    if ((EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY) &&
        (EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL))
    {
        ::SetLastError(ERROR_SXS_UNKNOWN_ENCODING);
        goto Exit;
    }

    EncodedAssemblyIdentityHeader = (PCENCODED_ASSEMBLY_IDENTITY_HEADER) Buffer;

    if ((EncodedAssemblyIdentityHeader->HeaderSize != sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER)) ||
        (EncodedAssemblyIdentityHeader->Magic != ENCODED_ASSEMBLY_IDENTITY_HEADER_MAGIC) ||
        (EncodedAssemblyIdentityHeader->TotalSize > BufferSize) ||
        (EncodedAssemblyIdentityHeader->Flags != 0) ||
        ((EncodedAssemblyIdentityHeader->Type != ASSEMBLY_IDENTITY_TYPE_DEFINITION) &&
         (EncodedAssemblyIdentityHeader->Type != ASSEMBLY_IDENTITY_TYPE_REFERENCE) &&
         (EncodedAssemblyIdentityHeader->Type != ASSEMBLY_IDENTITY_TYPE_WILDCARD)) ||
        (EncodedAssemblyIdentityHeader->EncodingFlags != 0) ||
        (EncodedAssemblyIdentityHeader->ReservedMustBeZero1 != 0) ||
        (EncodedAssemblyIdentityHeader->ReservedMustBeZero2 != 0) ||
        (EncodedAssemblyIdentityHeader->ReservedMustBeZero3 != 0) ||
        (EncodedAssemblyIdentityHeader->ReservedMustBeZero4 != 0)) {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    IFALLOCFAILED_EXIT(AssemblyIdentity = new ASSEMBLY_IDENTITY);

    NamespaceCount = EncodedAssemblyIdentityHeader->NamespaceCount;

    if (Flags & SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
    {
        NamespaceArraySize = NamespaceCount;
    }
    else if (NamespaceCount == 0)
    {
        NamespaceArraySize = 8;
    }
    else
    {
        NamespaceArraySize = (NamespaceCount + 7) & ~7;
    }

    if (NamespaceArraySize != 0)
    {
        IFALLOCFAILED_EXIT(NamespacePointerArray = FUSION_NEW_ARRAY(PCASSEMBLY_IDENTITY_NAMESPACE, NamespaceArraySize));

        for (i=0; i<NamespaceArraySize; i++)
            NamespacePointerArray[i] = NULL;
    }

    AttributeCount = EncodedAssemblyIdentityHeader->AttributeCount;

    if (Flags & SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
    {
        // If we're going to freeze, just perform an exact allocation.
        AttributeArraySize = AttributeCount;
    }
    else if (AttributeCount == 0)
    {
        AttributeArraySize = 8;
    }
    else
    {
        AttributeArraySize = (AttributeCount + 7) & ~7;
    }

    if (AttributeArraySize != 0)
    {
        IFALLOCFAILED_EXIT(AttributePointerArray = FUSION_NEW_ARRAY(PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE, AttributeArraySize));

        for (i=0; i<AttributeArraySize; i++)
            AttributePointerArray[i] = NULL;
    }

    AttributeHashArray = (const ULONG *) (EncodedAssemblyIdentityHeader + 1);
    NamespaceLengthArray = (const ULONG *) (AttributeHashArray + AttributeCount);
    EncodedAssemblyIdentityAttributeHeader = (PCENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER) (NamespaceLengthArray + NamespaceCount);
    UnicodeStringArray = (const WCHAR *) (EncodedAssemblyIdentityAttributeHeader + AttributeCount);

    // Start by building up those namespaces...
    for (i=0; i<NamespaceCount; i++)
    {
        ULONG NamespaceHash = 0;
        IFFALSE_EXIT(::FusionpHashUnicodeString(UnicodeStringArray, NamespaceLengthArray[i], &NamespaceHash, 0));
        IFFALSE_EXIT(::SxspAllocateAssemblyIdentityNamespace(0, UnicodeStringArray, NamespaceLengthArray[i], NamespaceHash, &NamespacePointerArray[i]));
        UnicodeStringArray += NamespaceLengthArray[i];
    }

    if (AttributeCount != 0)
    {
        // and now those attributes...
        for (i=0; i<AttributeCount; i++)
        {
            const ULONG NamespaceIndex = EncodedAssemblyIdentityAttributeHeader[i].NamespaceIndex;
            const ULONG NameCch = EncodedAssemblyIdentityAttributeHeader[i].NameCch;
            const ULONG ValueCch = EncodedAssemblyIdentityAttributeHeader[i].ValueCch;
            const WCHAR * const Name = UnicodeStringArray;
            const WCHAR * const Value = &UnicodeStringArray[NameCch];

            UnicodeStringArray = &Value[ValueCch];

            IFFALSE_EXIT(
                ::SxspAllocateInternalAssemblyIdentityAttribute(
                    0,
                    NamespacePointerArray[NamespaceIndex],
                    Name,
                    NameCch,
                    Value,
                    ValueCch,
                    &AttributePointerArray[i]));
        }
        
        // sort 'em...
        qsort((PVOID) AttributePointerArray, AttributeCount, sizeof(PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE), &SxspCompareInternalAttributesForQsort);
    }

    IFFALSE_EXIT(::SxspHashInternalAssemblyIdentityAttributes(0, AttributeCount, AttributePointerArray, &AssemblyIdentity->Hash));

    AssemblyIdentity->Flags = 0;
    AssemblyIdentity->Type = EncodedAssemblyIdentityHeader->Type;
    AssemblyIdentity->InternalFlags = ASSEMBLY_IDENTITY_INTERNAL_FLAG_ATTRIBUTE_POINTERS_IN_SEPARATE_ALLOCATION | ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION;
    AssemblyIdentity->AttributePointerArray = AttributePointerArray;
    AssemblyIdentity->AttributeCount = AttributeCount;
    AssemblyIdentity->AttributeArraySize = AttributeArraySize;
    AssemblyIdentity->NamespacePointerArray = NamespacePointerArray;
    AssemblyIdentity->NamespaceCount = NamespaceCount;
    AssemblyIdentity->NamespaceArraySize = NamespaceArraySize;

    AttributePointerArray = NULL;
    NamespacePointerArray = NULL;

    if (Flags & SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
        AssemblyIdentity->Flags |= ASSEMBLY_IDENTITY_FLAG_FROZEN;

    *AssemblyIdentityOut = AssemblyIdentity;
    AssemblyIdentity = NULL;

    fSuccess = TRUE;

Exit:
    //
    // REVIEW: Should this be an SxsDestroyAssemblyIdentity
    //
    if (AssemblyIdentity != NULL)
        FUSION_DELETE_SINGLETON(AssemblyIdentity);

    if ((AttributeCount != 0) && (AttributePointerArray != NULL))
    {
        for (i=0; i<AttributeCount; i++)
        {
            if (AttributePointerArray[i] != NULL)
            {
                ::SxspDeallocateInternalAssemblyIdentityAttribute(AttributePointerArray[i]);
                AttributePointerArray[i] = NULL;
            }
        }

        FUSION_DELETE_ARRAY( AttributePointerArray );
    }

    if ((NamespaceCount != 0) && (NamespacePointerArray != NULL))
    {
        for (i=0; i<NamespaceCount; i++)
        {
            if (NamespacePointerArray[i] != NULL)
            {
                ::SxspDeallocateAssemblyIdentityNamespace(NamespacePointerArray[i]);
                NamespacePointerArray[i] = NULL;
            }
        }

        FUSION_DELETE_ARRAY( NamespacePointerArray );
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\id\idp.h ===
#if !defined(_FUSION_ID_IDP_H_INCLUDED_)
#define _FUSION_ID_IDP_H_INCLUDED_

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    idp.h

Abstract:

    private definitions for assembly identity

Author:

    Michael Grier (MGrier) 7/27/2000

Revision History:

--*/

#pragma once

/* adriaanc
#include "debmacro.h"
#include "fusiontrace.h"
#include "fusionhashstring.h"
#include "fusionheap.h"
#include "util.h"
*/

#include <sxstypes.h>
#include <sxsapi.h>

//
//  Power of two to which to round the number of allocated attribute
//  pointers.
//

#define ROUNDING_FACTOR_BITS (3)

#define WILDCARD_CHAR '*'

//
//  Note! Do not change this algorithm lightly.  Encoded identities stored in the
//  filesystem contain hashes using it.  Actually, just do not change it.
//

#define HASH_ALGORITHM HASH_STRING_ALGORITHM_X65599

typedef struct _ASSEMBLY_IDENTITY_NAMESPACE {
    ULONG Hash;
    DWORD Flags;
    SIZE_T NamespaceCch;
    const WCHAR *Namespace;
} ASSEMBLY_IDENTITY_NAMESPACE, *PASSEMBLY_IDENTITY_NAMESPACE;

typedef const ASSEMBLY_IDENTITY_NAMESPACE *PCASSEMBLY_IDENTITY_NAMESPACE;

//
//  Internal-use ASSEMBLY_IDENTITY_ATTRIBUTE struct that
//  also contains the hash of the attribute definition.
//

typedef struct _INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE {
    // NOTE!!! It is very important that the Attribute member appear first in this struct;
    // there are several places in the code that make this assumption.  If it is not true,
    // the code will break!
    // Note also that the Attribute's namespace string is actually allocated in common
    // for all attributes with the same namespace.
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    PCASSEMBLY_IDENTITY_NAMESPACE Namespace;
    ULONG NamespaceAndNameHash;
    ULONG WholeAttributeHash;
} INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE, *PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE;

C_ASSERT(FIELD_OFFSET(INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE, Attribute) == 0);

typedef const INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE;

#define ASSEMBLY_IDENTITY_INTERNAL_FLAG_ATTRIBUTE_POINTERS_IN_SEPARATE_ALLOCATION   (0x00000001)
#define ASSEMBLY_IDENTITY_INTERNAL_FLAG_SINGLE_ALLOCATION_FOR_EVERYTHING            (0x00000002)
#define ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION   (0x00000004)

//
//  Revelation of the ASSEMBLY_IDENTITY struct:
//

typedef struct _ASSEMBLY_IDENTITY {
    DWORD Flags;
    ULONG InternalFlags;
    ULONG Type;
    ULONG Hash;
    ULONG AttributeCount;
    ULONG AttributeArraySize; // preallocated a little larger so that we don't have to keep growing
    ULONG NamespaceCount;
    ULONG NamespaceArraySize;
    BOOL  HashDirty;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray;
} ASSEMBLY_IDENTITY;

//
//  Header for encoded/serialized assembly identities:
//

#define ENCODED_ASSEMBLY_IDENTITY_HEADER_MAGIC ((ULONG) 'dIAE')

//
//  Encoded assembly identity layout:
//
//      ENCODED_ASSEMBLY_IDENTITY_HEADER
//      <AttributeCount hashes of the attributes, sorted by the hash value>
//      <NamespaceCount ENCODED_ASSEMBLY_IDENTITY_NAMESPACE_HEADER headers, each
//          followed by the unicode namespace value>
//      <AttributeCount ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER headers, each
//          followed by the unicode attribute name and value>
//
//
//      e.g.
//
//      <begin ENCODED_ASSEMBLY_IDENTITY_HEADER>
//      00000000:   00000038            HeaderSize == sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER)
//      00000004:   'EAId'              Magic (ENCODED_ASSEMBLY_IDENTITY_HEADER_MAGIC)
//      00000008:   0000014C            TotalSize
//      0000000C:   00000000            Flags
//      00000010:   00000001            Type (1 = ASSEMBLY_IDENTITY_TYPE_DEFINITION)
//      00000014:   00000000            EncodingFlags
//      00000018:   00000001            HashAlgorithm (1 = HASH_STRING_ALGORITHM_X65599)
//      0000001C:   ????????            Logical hash value of entire identity based on hash algorithm
//                                      (algorithm described in more detail below...)
//      00000020:   00000003            AttributeCount
//      00000024:   00000002            NamespaceCount
//      00000028:   00000000            ReservedMustBeZero1
//      0000002C:   00000000            ReservedMustBeZero2
//      00000030:   00000000 00000000   ReservedMustBeZero3
//      00000038:   00000000 00000000   ReservedMustBeZero4
//      <end ENCODED_ASSEMBLY_IDENTITY_HEADER>
//      <begin sorted attribute hash list>
//      00000040:   xxxxxxxx            hash of attribute #1
//      00000044:   yyyyyyyy            hash of attribute #0 - note that yyyyyyyy >= xxxxxxxx
//      00000048:   zzzzzzzz            hash of attribute #2 - note that zzzzzzzz >= yyyyyyyy
//      <end sorted attribute hash list>
//      <begin namespace length list>
//      0000004C:   00000015            length (in Unicode chars) of namespace #1 - "http://www.amazon.com" - 21 chars = 0x00000015
//      00000050:   00000018            length (in Unicode chars) of namespace #2 - "http://www.microsoft.com" - 24 chars = 0x00000018
//      <end namespace length list>
//      <begin attribute headers>
//      <begin ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      00000054:   00000001            NamespaceIndex: 1 (http://www.amazon.com)
//      00000058:   00000004            Name length ("name" - 4 chars = 0x00000004)
//      0000005C:   00000006            Value length ("foobar" - 6 chars = 0x00000006)
//      <end ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      <begin ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      00000060:   00000002            NamespaceIndex: 2 (http://www.microsoft.com)
//      00000064:   00000004            Name length ("guid" - 4 chars = 0x00000004)
//      00000068:   00000026            Value length ("{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" - 38 chars = 0x00000026)
//      <end ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      <begin ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      0000006C:   00000002            NamespaceIndex: 2 (http://www.microsoft.com)
//      00000070:   00000004            Name length ("type" - 4 chars = 0x00000004)
//      00000074:   00000005            Value length ("win32" - 5 chars = 0x00000005)
//      <end ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      <end attribute headers>
//      <begin namespace strings>
//      00000078:   "http://www.amazon.com"
//      000000A2:   "http://www.microsoft.com"
//      <end namespace strings>
//      <begin attribute values - names and values for each attribute in series>
//      000000D2:   "name"
//      000000DA:   "foobar"
//      000000E6:   "guid"
//      000000EE:   "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"
//      0000013A:   "type"
//      00000142:   "win32"
//      <end attribute values>
//      0000014C:
//
//  Computing the whole identity hash:
//
//      The hash of the entire encoded identity is not the hash of the binary form, but
//      rather is a combination of the hashes for the various components.
//
//      For any Unicode character string, its hash is computed according to HashAlgorithm.
//      Currently this must be HASH_STRING_ALGORITHM_X65599 which is a multiply-and-
//      accumulate algorithm, implemented essentially as follows:
//
//          HashValue = 0;
//          for (i=0; i<Chars; i++)
//              HashValue = (HashValue * 65599) + OptionalToUpper(String[i]);
//
//      Note that the characters are converted to upper case.  This is somewhat in
//      conflict with the Unicode recommendation to convert to lower case for case
//      insensitive operations, but it is what the rest of the Windows NT system
//      does, so consistency matters more than doing the "right thing".
//
//      Note also that no trailing null characters are included in the hash.  This
//      is significant because of the fact that applying the loop to another character
//      even though its value is zero will significantly change the hash value.
//
//      Namespaces and attribute names are case sensitive, derived from the fact
//      that they appear in case sensitive contexts in the real world.  This is
//      unfortunate, but simpler in many ways.
//
//      Assembly identity attributes are composed of a triple of:
//          - Namespace URI (e.g. http://www.microsoft.com/schemas/side-by-side)
//          - Name (e.g. "publicKey")
//          - Value (case insensitive Unicode string)
//
//      The hash of an attribute is computed by computing the hash of the three
//      strings, and then combining them as:
//
//          AttributeHashValue = (((NamespaceHash * 65599) + NameHash) * 65599) + ValueHash
//
//      Now, sort the attributes based first on namespace, then on name then on
//      value (case sensitive, case sensitive and case insensitive respectively),
//      and combine their hashes as follows:
//
//          IdentityHash = 0;
//          for (i=0; i<AttributeCount; i++)
//              IdentityHash = (IdentityHash * 65599) + AttributeHashes[i];
//
//      IdentityHash is the value stored in the encoded header.
//
//      The attribute hash array stored in the encoded data is the attribute
//      hashes as described above.  The interesting thing is that they are stored
//      in order of ascending hash value, not in the canonical ordering for
//      attributes.
//
//      This is because a common scenario is to find an identity which has a
//      superset of a given identity.  While the actual attributes have to
//      be consulted to verify that the candidate is a true subset, non-
//      matches can be very quickly found by sorting both lists of hash
//      values and first looping over the smaller reference list, then
//      in a single pass walking the larger definition list.  Attributes present
//      in one but not in the other will be immediately noticable due to
//      the missing hashes.
//
//      As always with hashes, just because an encoded identity contains a
//      superset of the hash values in your candidate assembly reference,
//      it does not mean that the actual values appear and you must perform
//      real character string comparisons to verify containment.
//

#include <pshpack4.h>

typedef struct _ENCODED_ASSEMBLY_IDENTITY_HEADER {
    ULONG HeaderSize;           // bytes just in the header
    ULONG Magic;
    ULONG TotalSize;            // bytes for the whole encoded thing
    DWORD Flags;                // as defined for assembly identity flags
    ULONG Type;                 // type of identity - def, ref or wildcard
    ULONG EncodingFlags;        // flags describing the encoding itself
    ULONG HashAlgorithm;        // Algorithm ID for the hashes stored in the identity
    ULONG Hash;                 // Hash value of the entire identity
    ULONG AttributeCount;       // number of attributes
    ULONG NamespaceCount;       // number of distinct namespaces
    ULONG ReservedMustBeZero1;
    ULONG ReservedMustBeZero2;
    ULONGLONG ReservedMustBeZero3;
    ULONGLONG ReservedMustBeZero4;
} ENCODED_ASSEMBLY_IDENTITY_HEADER, *PENCODED_ASSEMBLY_IDENTITY_HEADER;

typedef const ENCODED_ASSEMBLY_IDENTITY_HEADER *PCENCODED_ASSEMBLY_IDENTITY_HEADER;

typedef struct _ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER {
    ULONG NamespaceIndex;       // number of the namespace for this attribute
    ULONG NameCch;              // size in Unicode characters of the name immediately following the
                                // namespace
    ULONG ValueCch;             // size in Unicode characters of the value immediately following the
                                // name.
} ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER, *PENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER;

typedef const ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER *PCENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER;

#include <poppack.h>

#define SXSP_VALIDATE_ASSEMBLY_IDENTITY_FLAGS_MAY_BE_NULL (0x00000001)

BOOL
SxspValidateAssemblyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity
    );

BOOL
SxspValidateAssemblyIdentityAttributeNamespace(
    IN DWORD Flags,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch
    );

BOOL
SxspValidateAssemblyIdentityAttributeName(
    IN DWORD Flags,
    IN const WCHAR *Name,
    IN SIZE_T NameCch
    );

#define SXSP_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_WILDCARDS_PERMITTED (0x00000001)

BOOL
SxspValidateAssemblyIdentityAttributeValue(
    IN DWORD Flags,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch
    );

BOOL
SxspComputeInternalAssemblyIdentityAttributeBytesRequired(
    IN DWORD Flags,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT SIZE_T *BytesRequiredOut
    );

BOOL
SxspComputeAssemblyIdentityAttributeBytesRequired(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Source,
    OUT SIZE_T *BytesRequiredOut
    );

#define SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND (0x00000001)

BOOL
SxspFindAssemblyIdentityNamespaceInArray(
    IN DWORD Flags,
    IN OUT PCASSEMBLY_IDENTITY_NAMESPACE **NamespacePointerArrayPtr,
    IN OUT ULONG *NamespaceArraySizePtr,
    IN OUT ULONG *NamespaceCountPtr,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    );

#define SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_FLAG_ADD_IF_NOT_FOUND (0x00000001)

BOOL
SxspFindAssemblyIdentityNamespace(
    IN DWORD Flags,
    IN struct _ASSEMBLY_IDENTITY* AssemblyIdentity,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    );

BOOL
SxspAllocateAssemblyIdentityNamespace(
    IN DWORD Flags,
    IN const WCHAR *NamespaceString,
    IN SIZE_T NamespaceCch,
    IN ULONG NamespaceHash,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    );

VOID
SxspDeallocateAssemblyIdentityNamespace(
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace
    );

BOOL
SxspPopulateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Destination
    );

BOOL
SxspAllocateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Destination
    );

VOID
SxspCleanUpAssemblyIdentityNamespaceIfNotReferenced(
    IN DWORD Flags,
    IN struct _ASSEMBLY_IDENTITY* AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace
    );

VOID
SxspDeallocateInternalAssemblyIdentityAttribute(
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    );

int
__cdecl
SxspCompareInternalAttributesForQsort(
    const void *elem1,
    const void *elem2
    );

int
__cdecl
SxspCompareULONGsForQsort(
    const void *elem1,
    const void *elem2
    );

BOOL
SxspCompareAssemblyIdentityAttributeLists(
    DWORD Flags,
    ULONG AttributeCount,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *List1,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *List2,
    ULONG *ComparisonResultOut
    );

BOOL
SxspHashInternalAssemblyIdentityAttributes(
    DWORD Flags,
    ULONG Count,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Attributes,
    ULONG *HashOut
    );

BOOL
SxspCopyInternalAssemblyIdentityAttributeOut(
    DWORD Flags,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    SIZE_T BufferSize,
    PASSEMBLY_IDENTITY_ATTRIBUTE DestinationBuffer,
    SIZE_T *BytesCopiedOrRequired
    );

BOOL
SxspIsInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    OUT BOOL *EqualsOut
    );

#define SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_VALUE_ONLY (0x00000001)
#define SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_OMIT_QUOTES (0x00000002)

BOOL
SxspComputeInternalAssemblyIdentityAttributeEncodedTextualSize(
    IN DWORD Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT SIZE_T *BytesOut
    );

#define SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE   (0x00000001)
#define SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME        (0x00000002)
#define SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE       (0x00000004)
#define SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL (0x00000008)

BOOL
SxspLocateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *InternalAttributeOut,
    OUT ULONG *LastIndexSearched OPTIONAL
    );

BOOL
SxspComputeQuotedStringSize(
    IN DWORD Flags,
    IN const WCHAR *StringIn,
    IN SIZE_T Cch,
    OUT SIZE_T *BytesOut
    );

VOID 
SxspDbgPrintInternalAssemblyIdentityAttribute(
    DWORD dwflags, 
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    );

VOID 
SxspDbgPrintInternalAssemblyIdentityAttributes(
    DWORD dwflags, 
    ULONG AttributeCount, 
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes
    );

VOID
SxspDbgPrintAssemblyIdentityAttribute(
    DWORD dwflags, 
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    );

VOID 
SxspDbgPrintAssemblyIdentityAttributes(
    DWORD dwflags, 
    ULONG AttributeCount, 
    PCASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes
    );

BOOL
SxspEnsureAssemblyIdentityHashIsUpToDate(
    DWORD dwFlags,
    PCASSEMBLY_IDENTITY AssemblyIdentity
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\id\sxsid.cpp ===
//adriaanc
//#include "stdinc.h"
//#include <setupapi.h>
#include <sxsapi.h>

//adriaanc
//#include <stdlib.h>
//#include <search.h>
#include "idp.h"
#include "sxsapi.h"
#include "sxsid.h"

// adriaanc
#include "idaux.h"


ASSEMBLY_IDENTITY_ATTRIBUTE  
SxsComposeAssemblyIdentityAttribute(
    PCWSTR pszNamespace,    SIZE_T cchNamespace, 
    PCWSTR pszName,         SIZE_T cchName, 
    PCWSTR pszValue,        SIZE_T cchValue)
{    
    ASSEMBLY_IDENTITY_ATTRIBUTE anattribute;

    anattribute.Flags         = 0; // reserved flags : must be 0; 
    anattribute.NamespaceCch  = cchNamespace;
    anattribute.NameCch       = cchName;
    anattribute.ValueCch      = cchValue;
    anattribute.Namespace     = pszNamespace; 
    anattribute.Name          = pszName; 
    anattribute.Value         = pszValue; 
    
    return anattribute; 
}

BOOL
SxsAssemblyIdentityIsAttributePresent(
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    PCWSTR pszNamespace, 
    SIZE_T cchNamespace, 
    PCWSTR pszName, 
    SIZE_T cchName,         
    BOOL & rfFound)
{
    BOOL fSuccess = FALSE; 
    FN_TRACE_WIN32(fSuccess); 
    ULONG Count = 0;  
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;            
    DWORD dwFindFlags;
        
    PARAMETER_CHECK(pszName != NULL); 
    rfFound = FALSE;
    if ( pAssemblyIdentity == NULL) 
    { 
        goto Done; 
    }
    // in the case of a NULL namespace, we must set the flag, too ? xiaoyuw@09/11/00 
    dwFindFlags = SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE | SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME;
    Attribute = SxsComposeAssemblyIdentityAttribute(pszNamespace, cchNamespace, pszName, cchName, NULL, 0);
    
    if (pAssemblyIdentity){
        IFFALSE_EXIT(SxsFindAssemblyIdentityAttribute( // find attribute by "namespace" and "name"
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE | 
                    SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                    SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS,
                pAssemblyIdentity,
                &Attribute,
                NULL,
                &Count)); 
        if ( Count >0 ) { // found
            rfFound = TRUE;
        }
    }
Done:
    fSuccess = TRUE; 
Exit: 
    return fSuccess;
}

BOOL
SxspSetAssemblyIdentityAttributeValue(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    const WCHAR *Value,
    SIZE_T ValueCch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    DWORD FlagsToRealInsert = 0;

    PARAMETER_CHECK((Flags & ~(SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(AttributeReference != NULL);
    PARAMETER_CHECK(Value != NULL || ValueCch == 0);

    Attribute.Flags = 0;
    Attribute.Namespace = AttributeReference->Namespace;
    Attribute.NamespaceCch = AttributeReference->NamespaceCch;
    Attribute.Name = AttributeReference->Name;
    Attribute.NameCch = AttributeReference->NameCch;
    Attribute.Value = Value;
    Attribute.ValueCch = ValueCch;

    if (Flags & SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING)
        FlagsToRealInsert |= SXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_OVERWRITE_EXISTING;

    IFFALSE_EXIT(::SxsInsertAssemblyIdentityAttribute(FlagsToRealInsert, AssemblyIdentity, &Attribute));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

// adriaanc
/*
BOOL
SxspSetAssemblyIdentityAttributeValue(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    const CBaseStringBuffer &Value
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    IFFALSE_EXIT(
        ::SxspSetAssemblyIdentityAttributeValue(
            Flags,
            AssemblyIdentity,
            AttributeReference,
            static_cast<PCWSTR>(Value),
            Value.Cch()));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
*/

/////////////////////////////////////////////////////////////////////////////
// Action : 
// 1. if (namespace, name) is provided, remove all attributes with such (namespace, name)
// 2. if (namespace, name, value), remove at most 1 attribute from assembly-identity 
///////////////////////////////////////////////////////////////////////////////
BOOL
SxspRemoveAssemblyIdentityAttribute(
    DWORD Flags,
    PASSEMBLY_IDENTITY pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    ULONG Ordinal; 
    ULONG Count;
    DWORD dwFindAttributeFlags = 0;

    PARAMETER_CHECK((Flags & ~(SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS)) == 0);
    PARAMETER_CHECK(pAssemblyIdentity != NULL);
    PARAMETER_CHECK(AttributeReference != NULL);

    Attribute.Flags = 0;
    Attribute.Namespace = AttributeReference->Namespace;
    Attribute.NamespaceCch = AttributeReference->NamespaceCch;
    Attribute.Name = AttributeReference->Name;
    Attribute.NameCch = AttributeReference->NameCch;

    dwFindAttributeFlags = SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE | SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME;

    // If it's OK for the attribute not to exist, set the flag in the call to find it.
    if (Flags & SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS)
        dwFindAttributeFlags |= SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS;

    IFFALSE_EXIT(
        ::SxsFindAssemblyIdentityAttribute(
            dwFindAttributeFlags,
            pAssemblyIdentity,
            &Attribute,
            &Ordinal,
            &Count));

//     INTERNAL_ERROR_CHECK(Count <= 1);
    do
    {
        if (!(Count <= 1))
        {
            for (;;)
            {
                HARD_ASSERT_ACTION(_e);
                SetLastError(ERROR_INTERNAL_ERROR);
                goto Exit;
            }
        }
    } while (0);

    if (Count > 0)
    {
        IFFALSE_EXIT(
            ::SxsRemoveAssemblyIdentityAttributesByOrdinal(
                0,                  //  DWORD Flags,
                pAssemblyIdentity,
                Ordinal,
                Count));
    }

    fSuccess = TRUE; 
Exit: 
    return fSuccess; 
}
/////////////////////////////////////////////////////////////////////////////
// if no such attribure with such (namespace and name), return FALSE with 
// ::SetLastError(ERROR_NOT_FOUND); 
///////////////////////////////////////////////////////////////////////////////
BOOL
SxspGetAssemblyIdentityAttributeValue(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    OUT PCWSTR *StringOut,
    OUT SIZE_T *CchOut OPTIONAL
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = NULL;
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    DWORD dwLocateFlags = SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE | SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME;

    if (StringOut != NULL)
        *StringOut = NULL;

    if (CchOut != NULL)
        *CchOut = 0;

    PARAMETER_CHECK((Flags & ~(SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(AttributeReference != NULL);

    Attribute.Flags = 0;
    Attribute.Namespace = AttributeReference->Namespace;
    Attribute.NamespaceCch = AttributeReference->NamespaceCch;
    Attribute.Name = AttributeReference->Name;
    Attribute.NameCch = AttributeReference->NameCch;

    if (Flags & SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL)
        dwLocateFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_RETURNS_NULL;

    IFFALSE_EXIT(
        ::SxspLocateInternalAssemblyIdentityAttribute(
            dwLocateFlags,
            AssemblyIdentity,
            &Attribute,
            &InternalAttribute,
            NULL));

    if (InternalAttribute != NULL)
    {
        if (StringOut != NULL)
            *StringOut = InternalAttribute->Attribute.Value;

        if (CchOut != NULL)
            *CchOut = InternalAttribute->Attribute.ValueCch;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

//adriaanc
/*
BOOL
SxspGetAssemblyIdentityAttributeValue(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    OUT CBaseStringBuffer &Value
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCWSTR String = NULL;
    SIZE_T Cch = 0;

    IFFALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            Flags,
            AssemblyIdentity,
            AttributeReference,
            &String,
            &Cch));

    IFFALSE_EXIT(Value.Win32Assign(String, Cch));
    
    fSuccess = TRUE;
Exit:
    return fSuccess;
}
*/
BOOL
SxspUpdateAssemblyIdentityHash(
    DWORD dwFlags,
    PASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);

    if (AssemblyIdentity->HashDirty)
    {
        IFFALSE_EXIT(::SxspHashInternalAssemblyIdentityAttributes(
                            0,
                            AssemblyIdentity->AttributeCount, 
                            AssemblyIdentity->AttributePointerArray,
                            &AssemblyIdentity->Hash));

        AssemblyIdentity->HashDirty = FALSE;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspEnsureAssemblyIdentityHashIsUpToDate(
    DWORD dwFlags,
    PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);

    if (AssemblyIdentity->HashDirty)
        IFFALSE_EXIT(SxspUpdateAssemblyIdentityHash(0, const_cast<PASSEMBLY_IDENTITY>(AssemblyIdentity)));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
SxsHashAssemblyIdentity(
    DWORD dwFlags, 
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    ULONG * pulPseudoKey
)
{
    BOOL fSuccess = FALSE; 
    FN_TRACE_WIN32(fSuccess); 
    ULONG ulPseudoKey;     

    if (pulPseudoKey) 
        *pulPseudoKey = 0;

    PARAMETER_CHECK(dwFlags == 0);

    if (pAssemblyIdentity == NULL) 
        ulPseudoKey = 0; 
    else
    {
        IFFALSE_EXIT(SxspEnsureAssemblyIdentityHashIsUpToDate(0, pAssemblyIdentity));
        ulPseudoKey = pAssemblyIdentity->Hash;
    }

    if (pulPseudoKey != NULL)
        *pulPseudoKey = ulPseudoKey; 

    fSuccess = TRUE;

Exit:
    return fSuccess; 
}

// just to find whether Equal or Not
BOOL
SxsAreAssemblyIdentitiesEqual(
    DWORD dwFlags, 
    PCASSEMBLY_IDENTITY pAssemblyIdentity1,
    PCASSEMBLY_IDENTITY pAssemblyIdentity2,
    BOOL *EqualOut
    )
{
    BOOL fSuccess = FALSE; 
    FN_TRACE_WIN32(fSuccess);
    BOOL Equal = FALSE;

    if (EqualOut != NULL)
        *EqualOut = FALSE;

    PARAMETER_CHECK((dwFlags & ~(SXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_FLAG_ALLOW_REF_TO_MATCH_DEF)) == 0);
    PARAMETER_CHECK(pAssemblyIdentity1 != NULL);
    PARAMETER_CHECK(pAssemblyIdentity2 != NULL);
    PARAMETER_CHECK(EqualOut != NULL);
    
    // get hash for each assembly identity
    IFFALSE_EXIT(SxspEnsureAssemblyIdentityHashIsUpToDate(0, pAssemblyIdentity1));
    IFFALSE_EXIT(SxspEnsureAssemblyIdentityHashIsUpToDate(0, pAssemblyIdentity2));

    // compare hash value of two identity; it's a quick way to determine they're not equal.
    if (pAssemblyIdentity2->Hash == pAssemblyIdentity1->Hash)
    {
        // Note that two identities which differ only in their internal flags are still semantically
        // equal.
        if ((pAssemblyIdentity1->Flags ==  pAssemblyIdentity2->Flags) &&
            (pAssemblyIdentity1->Hash ==  pAssemblyIdentity2->Hash) &&
            (pAssemblyIdentity1->NamespaceCount ==  pAssemblyIdentity2->NamespaceCount) &&
            (pAssemblyIdentity1->AttributeCount ==  pAssemblyIdentity2->AttributeCount))
        {
            if (dwFlags & SXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_FLAG_ALLOW_REF_TO_MATCH_DEF)
            {
                if (((pAssemblyIdentity1->Type == ASSEMBLY_IDENTITY_TYPE_DEFINITION) ||
                     (pAssemblyIdentity1->Type == ASSEMBLY_IDENTITY_TYPE_REFERENCE)) &&
                    ((pAssemblyIdentity2->Type == ASSEMBLY_IDENTITY_TYPE_DEFINITION) ||
                     (pAssemblyIdentity2->Type == ASSEMBLY_IDENTITY_TYPE_REFERENCE)))
                {
                    // They match sufficiently...
                    Equal = TRUE;
                }
            }
            else
                Equal = (pAssemblyIdentity1->Type == pAssemblyIdentity2->Type);

            if (Equal)
            {
                ULONG ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_INVALID;

                // Reset our assumption...
                Equal = FALSE;

                IFFALSE_EXIT(SxspCompareAssemblyIdentityAttributeLists(
                    0,
                    pAssemblyIdentity1->AttributeCount,
                    pAssemblyIdentity1->AttributePointerArray,
                    pAssemblyIdentity2->AttributePointerArray,
                    &ComparisonResult));

                INTERNAL_ERROR_CHECK(
                    (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN) ||
                    (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL) ||
                    (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN));

                if (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
                    Equal = TRUE;
            }
        }
    }

    *EqualOut = Equal;
    fSuccess = TRUE;

Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\id\sxsid.h ===
#if !defined(_FUSION_INC_SXSID_H_INCLUDED_)
#define _FUSION_INC_SXSID_H_INCLUDED_

#pragma once

//adriaanc
//#include <windows.h>
#include <setupapi.h>
#include <sxsapi.h>
//#include <stdlib.h>
//#include <search.h>

typedef struct _SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE
{
    const WCHAR *Namespace;
    SIZE_T NamespaceCch;
    const WCHAR *Name;
    SIZE_T NameCch;
} SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE, *PSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE;

typedef const SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE *PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE;

#define SXS_DEFINE_ATTRIBUTE_REFERENCE_EX(_id, _ns, _n) EXTERN_C __declspec(selectany) const SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE _id = { _ns, (sizeof(_ns) / sizeof(_ns[0])) - 1, _n, (sizeof(_n) / sizeof(_n[0])) - 1 };
#define SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(_id, _n) EXTERN_C __declspec(selectany) const SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE _id = { NULL, 0, _n, (sizeof(_n) / sizeof(_n[0])) - 1 };

SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_name, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_type, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_version, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_processorArchitecture, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_publicKey, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_publicKeyToken, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_language, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE)


//
//  This header defines the "semi-public" assembly identity functions.
//
//  The public ones are in sxsapi.h; these are not private to the identity
//  implementation directly but are private to sxs.dll.
//

BOOL
SxsIsAssemblyIdentityAttributePresent(
    DWORD Flags,
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    BOOL *pfFound
    );

#define SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING (0x00000001)

BOOL
SxspSetAssemblyIdentityAttributeValue(
    DWORD Flags,
    struct _ASSEMBLY_IDENTITY* pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    PCWSTR pszValue,
    SIZE_T cchValue
    );
// adriaanc
/*
BOOL
SxspSetAssemblyIdentityAttributeValue(
    DWORD Flags,
    struct _ASSEMBLY_IDENTITY* pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    const CBaseStringBuffer &Value
    );
*/
#define SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS (0x00000001)

BOOL
SxspRemoveAssemblyIdentityAttribute(
    DWORD Flags,
    struct _ASSEMBLY_IDENTITY* pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference
    );

#define SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL (0x00000001)

BOOL
SxspGetAssemblyIdentityAttributeValue(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    OUT PCWSTR *ValuePointer,
    OUT SIZE_T *ValueCch
    );

//adriaanc
/*
BOOL
SxspGetAssemblyIdentityAttributeValue(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    OUT CBaseStringBuffer &Value
    );
*/

VOID
SxspDbgPrintAssemblyIdentity(
    DWORD dwflags, 
    PCASSEMBLY_IDENTITY pAssemblyIdentity
    );

#define SXSP_MAP_ASSEMBLY_IDENTITY_TO_POLICY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION (0x00000001)

BOOL
SxspMapAssemblyIdentityToPolicyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT PASSEMBLY_IDENTITY &PolicyIdentity
    );

#define SXSP_GENERATE_TEXTUALLY_ENCODED_POLICY_IDENTITY_FROM_ASSEMBLY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION (0x00000001)

// adriaanc
/*
BOOL
SxspGenerateTextuallyEncodedPolicyIdentityFromAssemblyIdentity(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    CBaseStringBuffer &rbuffEncodedIdentity,
    PASSEMBLY_IDENTITY *PolicyIdentity OPTIONAL
    );
*/
#endif // !defined(_FUSION_INC_SXSID_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\applicationinfo.h ===
#pragma once

// note: Ids (defined in fusenet.idl) have to be in sync with eStringTableId in manifestimport.h

class CManifestApplicationInfo : public IManifestApplicationInfo
{
    public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD(Set)(
        /* in */ DWORD dwId,
        /* in */ LPCOLESTR pwzProperty);

    STDMETHOD(Get)(
        /* in */ DWORD dwId,
        /* out */ LPOLESTR *ppwzProperty,
        /* out */ LPDWORD   pccProperty);
    
    CManifestApplicationInfo();
    ~CManifestApplicationInfo();

    private:
    struct ApplicationInfo
    {
        LPWSTR pwzProperty;
        DWORD  ccProperty;
    };
        
    DWORD    _dwSig;
    DWORD    _cRef;
    HRESULT  _hr;

    ApplicationInfo _ai[MAN_APPLICATION_MAX];


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\assemblycache.h ===
#pragma once

#define OTHERFILES 0
#define MANIFEST 1

class CAssemblyCache : public IAssemblyCacheImport, public IAssemblyCacheEmit
{
public:
    enum CacheFlags
    {
        Base = 0,
        Staging
    };

    typedef enum
    {
        COMPLETED = 0,
        CONFIRMED,
        CRITICAL  
    } CacheStatus;

    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // Import/Emit methods
    STDMETHOD(GetManifestImport)( 
        /* out */ LPASSEMBLY_MANIFEST_IMPORT *ppManifestImport);

    STDMETHOD(GetManifestFilePath)(
        /* out */      LPOLESTR *ppwzManifestFilePath,
        /* in, out */  LPDWORD ccManifestFilePath);
    
    STDMETHOD(GetManifestFileDir)(
        /* out */      LPOLESTR *ppwzManifestFileDir,
        /* in, out */  LPDWORD ccManifestFileDir);

    STDMETHOD(GetDisplayName)(
        /* out */   LPOLESTR *ppwzDisplayName,
        /* out */   LPDWORD ccDisplayName);
    
    // Import only methods
    STDMETHOD(FindExistMatching)(
        /* in */       LPASSEMBLY_FILE_INFO  pAssemblyFileInfo,
        /* out */      LPOLESTR *ppwzPath);
        
    // Emit only methods
    STDMETHOD(CopyFile)(
        /* in */ LPOLESTR pwzSourcePath, 
        /* in */ LPOLESTR pwzFileName,
        /* in */ DWORD dwFlags);

    STDMETHOD(Commit)(
        /* in */  DWORD dwFlags);

    
    CAssemblyCache();
    ~CAssemblyCache();

    static HRESULT CreateDirectoryHierarchy(
        LPWSTR pwzRootPath,
        LPWSTR pwzPath);

    static HRESULT GetCacheRootDir(CString &sCacheDir, CacheFlags eFlags);

private:
    DWORD                       _dwSig;
    DWORD                       _cRef;
    DWORD                       _hr;
    CString                     _sRootDir;
    CString                     _sManifestFileDir;
    CString                     _sManifestFilePath;
    CString                     _sDisplayName;
    LPASSEMBLY_MANIFEST_IMPORT  _pManifestImport;

    HRESULT Init(CAssemblyCache* pAssemblyCache);

    // status get/set methods
    BOOL IsStatus(LPWSTR pwzDisplayName, CacheStatus eStatus);
    HRESULT SetStatus(LPWSTR pwzDisplayName, CacheStatus eStatus);

friend HRESULT CreateAssemblyCacheImport(
    LPASSEMBLY_CACHE_IMPORT *ppAssemblyCacheImport,
    LPASSEMBLY_IDENTITY       pAssemblyIdentity,
    DWORD                  dwFlags);

friend HRESULT CreateAssemblyCacheEmit(
    LPASSEMBLY_CACHE_EMIT *ppAssemblyCacheEmit, 
    LPASSEMBLY_CACHE_EMIT pAssemblyCacheEmit,
    DWORD                  dwFlags);

friend HRESULT SearchForHighestVersionInCache(
    LPWSTR *ppwzResultDisplayName,
    LPWSTR pwzSearchDisplayName,
    CAssemblyCache::CacheStatus eCacheStatus,
    CAssemblyCache* pCache);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\assemblyfile.h ===
#pragma once

class CAssemblyFileInfo : public IAssemblyFileInfo
{
    public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD(Set)(
        /* in */ DWORD dwId,
        /* in */ LPCOLESTR pwzProperty);

    STDMETHOD(Get)(
        /* in */ DWORD dwId,
        /* out */ LPOLESTR *ppwzProperty,
        /* out */ LPDWORD   pccProperty);

    BOOL operator==( CAssemblyFileInfo& asmFIRHS );

    CAssemblyFileInfo();
    ~CAssemblyFileInfo();

    private:
    struct FileInfo
    {
        LPWSTR pwzProperty;
        DWORD  ccProperty;
    };
        
    DWORD    _dwSig;
    DWORD    _cRef;
    HRESULT  _hr;

    FileInfo _fi[ASM_FILE_MAX];


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifndef _MFC_VER
#define _MFC_VER 0x0600
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// Tab Control styles
#ifndef TCS_MULTILINE // new in later versions of Win32
#define TCS_MULTILINE       0x0200
#endif

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#if _MFC_VER >= 0x0600
#define CBRS_GRIPPER        0x00400000L
#endif

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#if _MFC_VER >= 0x0600
#define CBRS_ALL            0x0040FFFFL
#else
#define CBRS_ALL            0xFFFFL
#endif

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#if _MFC_VER >= 0x0600
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar
#endif

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#if _MFC_VER >= 0x0600
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
#endif
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#if _MFC_VER >= 0x0600
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#endif
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

#if _MFC_VER >= 0x0600
// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D
#endif

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\assemblydownload.h ===
#pragma once

class CDownloadDlg;

class CAssemblyDownload : public IAssemblyDownload
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IBackgroundCopyCallback methods
    STDMETHOD(JobTransferred)(
        /* in */ IBackgroundCopyJob *pJob);

    STDMETHOD(JobError)(
        /* in */ IBackgroundCopyJob* pJob,
        /* in */ IBackgroundCopyError* pError);

    STDMETHOD(JobModification)(
        /* in */ IBackgroundCopyJob* pJob,
        /* in */ DWORD dwReserved);


    // IAssemblyDownload methods

    STDMETHOD(DownloadManifestAndDependencies)(
        /* in */ LPWSTR wzApplicationManifestUrl, HANDLE hNamedEvent, DWORD dwFlags);


    CAssemblyDownload();
    ~CAssemblyDownload();


private:
    
    HRESULT Init();

    HRESULT DoCacheUpdate(IBackgroundCopyJob *pJob);

    HRESULT EnqueueDependencies(LPASSEMBLY_CACHE_IMPORT 
        pCacheImport,  CString &sCodebase, CString &sDisplayName, IBackgroundCopyJob **ppJob);

    HRESULT GetPatchDisplayNameFromFilePath ( CString &sPatchFilePath, CString &sDisplayName);

    HRESULT ApplyPatchFile (LPASSEMBLY_IDENTITY pPatchAssemblyId, LPWSTR pwzFilePath);
        
    DWORD                          _dwSig;
    LONG                           _cRef;
    HRESULT                        _hr;
    CString                        _sDisplayName;
    IAssemblyCacheEmit            *_pRootEmit;
    HANDLE                        _hNamedEvent;
    CDownloadDlg                  *_pDlg;    
    static IBackgroundCopyManager *g_pManager;

    friend CDownloadDlg;    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\assemblyidentity.h ===
#pragma once
#ifndef __ASSEMBLY_IDENTITY_H__
#define __ASSEMBLY_IDENTITY_H__

class CAssemblyIdentity : public IAssemblyIdentity
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD(SetAttribute)(
        /* in */ LPCOLESTR pwzName, 
        /* in */ LPCOLESTR pwzValue, 
        /* in */ DWORD     ccValue);

    STDMETHOD(GetAttribute)(
        /* in */  LPCOLESTR pwzName, 
        /* out */ LPOLESTR *ppwzValue, 
        /* out */ LPDWORD   pccValue);

    STDMETHOD(GetDisplayName)(
        /* in */  DWORD    dwFlags,
        /* out */ LPOLESTR *ppwzDisplayName, 
        /* out */ LPDWORD   pccDisplayName);

    STDMETHOD(IsEqual )(
        /*in */ IAssemblyIdentity *pAssemblyId);

    CAssemblyIdentity();
    ~CAssemblyIdentity();

private:
    DWORD                    _dwSig;
    DWORD                    _cRef;
    DWORD                    _hr;
    PASSEMBLY_IDENTITY       _pId;

    HRESULT Init();
    
friend HRESULT CreateAssemblyIdentity(
    LPASSEMBLY_IDENTITY *ppAssemblyId,
    DWORD                dwFlags);

friend HRESULT CreateAssemblyIdentityEx(
    LPASSEMBLY_IDENTITY *ppAssemblyId,
    DWORD                dwFlags,
    LPWSTR          wzDisplayName);

friend HRESULT CloneAssemblyIdentity(
    LPASSEMBLY_IDENTITY  pSrcAssemblyId,
    LPASSEMBLY_IDENTITY *ppDestAssemblyId);
};   

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\bits.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for bits.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __bits_h__
#define __bits_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IBackgroundCopyFile_FWD_DEFINED__
#define __IBackgroundCopyFile_FWD_DEFINED__
typedef interface IBackgroundCopyFile IBackgroundCopyFile;
#endif 	/* __IBackgroundCopyFile_FWD_DEFINED__ */


#ifndef __IEnumBackgroundCopyFiles_FWD_DEFINED__
#define __IEnumBackgroundCopyFiles_FWD_DEFINED__
typedef interface IEnumBackgroundCopyFiles IEnumBackgroundCopyFiles;
#endif 	/* __IEnumBackgroundCopyFiles_FWD_DEFINED__ */


#ifndef __IBackgroundCopyError_FWD_DEFINED__
#define __IBackgroundCopyError_FWD_DEFINED__
typedef interface IBackgroundCopyError IBackgroundCopyError;
#endif 	/* __IBackgroundCopyError_FWD_DEFINED__ */


#ifndef __IBackgroundCopyJob_FWD_DEFINED__
#define __IBackgroundCopyJob_FWD_DEFINED__
typedef interface IBackgroundCopyJob IBackgroundCopyJob;
#endif 	/* __IBackgroundCopyJob_FWD_DEFINED__ */


#ifndef __IEnumBackgroundCopyJobs_FWD_DEFINED__
#define __IEnumBackgroundCopyJobs_FWD_DEFINED__
typedef interface IEnumBackgroundCopyJobs IEnumBackgroundCopyJobs;
#endif 	/* __IEnumBackgroundCopyJobs_FWD_DEFINED__ */


#ifndef __IBackgroundCopyCallback_FWD_DEFINED__
#define __IBackgroundCopyCallback_FWD_DEFINED__
typedef interface IBackgroundCopyCallback IBackgroundCopyCallback;
#endif 	/* __IBackgroundCopyCallback_FWD_DEFINED__ */


#ifndef __AsyncIBackgroundCopyCallback_FWD_DEFINED__
#define __AsyncIBackgroundCopyCallback_FWD_DEFINED__
typedef interface AsyncIBackgroundCopyCallback AsyncIBackgroundCopyCallback;
#endif 	/* __AsyncIBackgroundCopyCallback_FWD_DEFINED__ */


#ifndef __IBackgroundCopyManager_FWD_DEFINED__
#define __IBackgroundCopyManager_FWD_DEFINED__
typedef interface IBackgroundCopyManager IBackgroundCopyManager;
#endif 	/* __IBackgroundCopyManager_FWD_DEFINED__ */


#ifndef __BackgroundCopyManager_FWD_DEFINED__
#define __BackgroundCopyManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class BackgroundCopyManager BackgroundCopyManager;
#else
typedef struct BackgroundCopyManager BackgroundCopyManager;
#endif /* __cplusplus */

#endif 	/* __BackgroundCopyManager_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_bits_0000 */
/* [local] */ 

#include "bitsmsg.h"
#define BG_SIZE_UNKNOWN     (UINT64)(-1)


extern RPC_IF_HANDLE __MIDL_itf_bits_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bits_0000_v0_0_s_ifspec;

#ifndef __IBackgroundCopyFile_INTERFACE_DEFINED__
#define __IBackgroundCopyFile_INTERFACE_DEFINED__

/* interface IBackgroundCopyFile */
/* [object][uuid] */ 

typedef struct _BG_FILE_PROGRESS
    {
    UINT64 BytesTotal;
    UINT64 BytesTransferred;
    BOOL Transferred;
    } 	BG_FILE_PROGRESS;


EXTERN_C const IID IID_IBackgroundCopyFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01b7bd23-fb88-4a77-8490-5891d3e4653a")
    IBackgroundCopyFile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRemoteName( 
            /* [out] */ LPWSTR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalName( 
            /* [out] */ LPWSTR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgress( 
            /* [out] */ BG_FILE_PROGRESS *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBackgroundCopyFile * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBackgroundCopyFile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBackgroundCopyFile * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteName )( 
            IBackgroundCopyFile * This,
            /* [out] */ LPWSTR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalName )( 
            IBackgroundCopyFile * This,
            /* [out] */ LPWSTR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgress )( 
            IBackgroundCopyFile * This,
            /* [out] */ BG_FILE_PROGRESS *pVal);
        
        END_INTERFACE
    } IBackgroundCopyFileVtbl;

    interface IBackgroundCopyFile
    {
        CONST_VTBL struct IBackgroundCopyFileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBackgroundCopyFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBackgroundCopyFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBackgroundCopyFile_GetRemoteName(This,pVal)	\
    (This)->lpVtbl -> GetRemoteName(This,pVal)

#define IBackgroundCopyFile_GetLocalName(This,pVal)	\
    (This)->lpVtbl -> GetLocalName(This,pVal)

#define IBackgroundCopyFile_GetProgress(This,pVal)	\
    (This)->lpVtbl -> GetProgress(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBackgroundCopyFile_GetRemoteName_Proxy( 
    IBackgroundCopyFile * This,
    /* [out] */ LPWSTR *pVal);


void __RPC_STUB IBackgroundCopyFile_GetRemoteName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyFile_GetLocalName_Proxy( 
    IBackgroundCopyFile * This,
    /* [out] */ LPWSTR *pVal);


void __RPC_STUB IBackgroundCopyFile_GetLocalName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyFile_GetProgress_Proxy( 
    IBackgroundCopyFile * This,
    /* [out] */ BG_FILE_PROGRESS *pVal);


void __RPC_STUB IBackgroundCopyFile_GetProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBackgroundCopyFile_INTERFACE_DEFINED__ */


#ifndef __IEnumBackgroundCopyFiles_INTERFACE_DEFINED__
#define __IEnumBackgroundCopyFiles_INTERFACE_DEFINED__

/* interface IEnumBackgroundCopyFiles */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumBackgroundCopyFiles;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ca51e165-c365-424c-8d41-24aaa4ff3c40")
    IEnumBackgroundCopyFiles : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IBackgroundCopyFile **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumBackgroundCopyFiles **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *puCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumBackgroundCopyFilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumBackgroundCopyFiles * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumBackgroundCopyFiles * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumBackgroundCopyFiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumBackgroundCopyFiles * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IBackgroundCopyFile **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumBackgroundCopyFiles * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumBackgroundCopyFiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumBackgroundCopyFiles * This,
            /* [out] */ IEnumBackgroundCopyFiles **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumBackgroundCopyFiles * This,
            /* [out] */ ULONG *puCount);
        
        END_INTERFACE
    } IEnumBackgroundCopyFilesVtbl;

    interface IEnumBackgroundCopyFiles
    {
        CONST_VTBL struct IEnumBackgroundCopyFilesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumBackgroundCopyFiles_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumBackgroundCopyFiles_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumBackgroundCopyFiles_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumBackgroundCopyFiles_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumBackgroundCopyFiles_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumBackgroundCopyFiles_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumBackgroundCopyFiles_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#define IEnumBackgroundCopyFiles_GetCount(This,puCount)	\
    (This)->lpVtbl -> GetCount(This,puCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyFiles_Next_Proxy( 
    IEnumBackgroundCopyFiles * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IBackgroundCopyFile **rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumBackgroundCopyFiles_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyFiles_Skip_Proxy( 
    IEnumBackgroundCopyFiles * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumBackgroundCopyFiles_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyFiles_Reset_Proxy( 
    IEnumBackgroundCopyFiles * This);


void __RPC_STUB IEnumBackgroundCopyFiles_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyFiles_Clone_Proxy( 
    IEnumBackgroundCopyFiles * This,
    /* [out] */ IEnumBackgroundCopyFiles **ppenum);


void __RPC_STUB IEnumBackgroundCopyFiles_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyFiles_GetCount_Proxy( 
    IEnumBackgroundCopyFiles * This,
    /* [out] */ ULONG *puCount);


void __RPC_STUB IEnumBackgroundCopyFiles_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumBackgroundCopyFiles_INTERFACE_DEFINED__ */


#ifndef __IBackgroundCopyError_INTERFACE_DEFINED__
#define __IBackgroundCopyError_INTERFACE_DEFINED__

/* interface IBackgroundCopyError */
/* [object][helpstring][uuid] */ 

typedef /* [public][public] */ 
enum __MIDL_IBackgroundCopyError_0001
    {	BG_ERROR_CONTEXT_NONE	= 0,
	BG_ERROR_CONTEXT_UNKNOWN	= 1,
	BG_ERROR_CONTEXT_GENERAL_QUEUE_MANAGER	= 2,
	BG_ERROR_CONTEXT_QUEUE_MANAGER_NOTIFICATION	= 3,
	BG_ERROR_CONTEXT_LOCAL_FILE	= 4,
	BG_ERROR_CONTEXT_REMOTE_FILE	= 5,
	BG_ERROR_CONTEXT_GENERAL_TRANSPORT	= 6
    } 	BG_ERROR_CONTEXT;


EXTERN_C const IID IID_IBackgroundCopyError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("19c613a0-fcb8-4f28-81ae-897c3d078f81")
    IBackgroundCopyError : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetError( 
            /* [ref][out] */ BG_ERROR_CONTEXT *pContext,
            /* [ref][out] */ HRESULT *pCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFile( 
            /* [out] */ IBackgroundCopyFile **pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorDescription( 
            /* [in] */ DWORD LanguageId,
            /* [ref][out] */ LPWSTR *pErrorDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorContextDescription( 
            /* [in] */ DWORD LanguageId,
            /* [ref][out] */ LPWSTR *pContextDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProtocol( 
            /* [ref][out] */ LPWSTR *pProtocol) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBackgroundCopyError * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBackgroundCopyError * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBackgroundCopyError * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetError )( 
            IBackgroundCopyError * This,
            /* [ref][out] */ BG_ERROR_CONTEXT *pContext,
            /* [ref][out] */ HRESULT *pCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFile )( 
            IBackgroundCopyError * This,
            /* [out] */ IBackgroundCopyFile **pVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorDescription )( 
            IBackgroundCopyError * This,
            /* [in] */ DWORD LanguageId,
            /* [ref][out] */ LPWSTR *pErrorDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorContextDescription )( 
            IBackgroundCopyError * This,
            /* [in] */ DWORD LanguageId,
            /* [ref][out] */ LPWSTR *pContextDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetProtocol )( 
            IBackgroundCopyError * This,
            /* [ref][out] */ LPWSTR *pProtocol);
        
        END_INTERFACE
    } IBackgroundCopyErrorVtbl;

    interface IBackgroundCopyError
    {
        CONST_VTBL struct IBackgroundCopyErrorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBackgroundCopyError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBackgroundCopyError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBackgroundCopyError_GetError(This,pContext,pCode)	\
    (This)->lpVtbl -> GetError(This,pContext,pCode)

#define IBackgroundCopyError_GetFile(This,pVal)	\
    (This)->lpVtbl -> GetFile(This,pVal)

#define IBackgroundCopyError_GetErrorDescription(This,LanguageId,pErrorDescription)	\
    (This)->lpVtbl -> GetErrorDescription(This,LanguageId,pErrorDescription)

#define IBackgroundCopyError_GetErrorContextDescription(This,LanguageId,pContextDescription)	\
    (This)->lpVtbl -> GetErrorContextDescription(This,LanguageId,pContextDescription)

#define IBackgroundCopyError_GetProtocol(This,pProtocol)	\
    (This)->lpVtbl -> GetProtocol(This,pProtocol)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBackgroundCopyError_GetError_Proxy( 
    IBackgroundCopyError * This,
    /* [ref][out] */ BG_ERROR_CONTEXT *pContext,
    /* [ref][out] */ HRESULT *pCode);


void __RPC_STUB IBackgroundCopyError_GetError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyError_GetFile_Proxy( 
    IBackgroundCopyError * This,
    /* [out] */ IBackgroundCopyFile **pVal);


void __RPC_STUB IBackgroundCopyError_GetFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyError_GetErrorDescription_Proxy( 
    IBackgroundCopyError * This,
    /* [in] */ DWORD LanguageId,
    /* [ref][out] */ LPWSTR *pErrorDescription);


void __RPC_STUB IBackgroundCopyError_GetErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyError_GetErrorContextDescription_Proxy( 
    IBackgroundCopyError * This,
    /* [in] */ DWORD LanguageId,
    /* [ref][out] */ LPWSTR *pContextDescription);


void __RPC_STUB IBackgroundCopyError_GetErrorContextDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyError_GetProtocol_Proxy( 
    IBackgroundCopyError * This,
    /* [ref][out] */ LPWSTR *pProtocol);


void __RPC_STUB IBackgroundCopyError_GetProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBackgroundCopyError_INTERFACE_DEFINED__ */


#ifndef __IBackgroundCopyJob_INTERFACE_DEFINED__
#define __IBackgroundCopyJob_INTERFACE_DEFINED__

/* interface IBackgroundCopyJob */
/* [object][helpstring][uuid] */ 

typedef struct _BG_FILE_INFO
    {
    LPWSTR RemoteName;
    LPWSTR LocalName;
    } 	BG_FILE_INFO;

typedef struct _BG_JOB_PROGRESS
    {
    UINT64 BytesTotal;
    UINT64 BytesTransferred;
    ULONG FilesTotal;
    ULONG FilesTransferred;
    } 	BG_JOB_PROGRESS;

typedef struct _BG_JOB_TIMES
    {
    FILETIME CreationTime;
    FILETIME ModificationTime;
    FILETIME TransferCompletionTime;
    } 	BG_JOB_TIMES;

typedef /* [public][public][public] */ 
enum __MIDL_IBackgroundCopyJob_0001
    {	BG_JOB_PRIORITY_FOREGROUND	= 0,
	BG_JOB_PRIORITY_HIGH	= BG_JOB_PRIORITY_FOREGROUND + 1,
	BG_JOB_PRIORITY_NORMAL	= BG_JOB_PRIORITY_HIGH + 1,
	BG_JOB_PRIORITY_LOW	= BG_JOB_PRIORITY_NORMAL + 1
    } 	BG_JOB_PRIORITY;

typedef /* [public][public] */ 
enum __MIDL_IBackgroundCopyJob_0002
    {	BG_JOB_STATE_QUEUED	= 0,
	BG_JOB_STATE_CONNECTING	= BG_JOB_STATE_QUEUED + 1,
	BG_JOB_STATE_TRANSFERRING	= BG_JOB_STATE_CONNECTING + 1,
	BG_JOB_STATE_SUSPENDED	= BG_JOB_STATE_TRANSFERRING + 1,
	BG_JOB_STATE_ERROR	= BG_JOB_STATE_SUSPENDED + 1,
	BG_JOB_STATE_TRANSIENT_ERROR	= BG_JOB_STATE_ERROR + 1,
	BG_JOB_STATE_TRANSFERRED	= BG_JOB_STATE_TRANSIENT_ERROR + 1,
	BG_JOB_STATE_ACKNOWLEDGED	= BG_JOB_STATE_TRANSFERRED + 1,
	BG_JOB_STATE_CANCELLED	= BG_JOB_STATE_ACKNOWLEDGED + 1
    } 	BG_JOB_STATE;

typedef /* [public][public][public] */ 
enum __MIDL_IBackgroundCopyJob_0003
    {	BG_JOB_TYPE_DOWNLOAD	= 0
    } 	BG_JOB_TYPE;

typedef /* [public][public][public] */ 
enum __MIDL_IBackgroundCopyJob_0004
    {	BG_JOB_PROXY_USAGE_PRECONFIG	= 0,
	BG_JOB_PROXY_USAGE_NO_PROXY	= BG_JOB_PROXY_USAGE_PRECONFIG + 1,
	BG_JOB_PROXY_USAGE_OVERRIDE	= BG_JOB_PROXY_USAGE_NO_PROXY + 1
    } 	BG_JOB_PROXY_USAGE;


EXTERN_C const IID IID_IBackgroundCopyJob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37668d37-507e-4160-9316-26306d150b12")
    IBackgroundCopyJob : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddFileSet( 
            /* [in] */ ULONG cFileCount,
            /* [size_is][in] */ BG_FILE_INFO *pFileSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFile( 
            /* [in] */ LPCWSTR RemoteUrl,
            /* [in] */ LPCWSTR LocalName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumFiles( 
            /* [out] */ IEnumBackgroundCopyFiles **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Complete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetId( 
            /* [out] */ GUID *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ BG_JOB_TYPE *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgress( 
            /* [out] */ BG_JOB_PROGRESS *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimes( 
            /* [out] */ BG_JOB_TIMES *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ BG_JOB_STATE *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetError( 
            /* [out] */ IBackgroundCopyError **ppError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [out] */ LPWSTR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDisplayName( 
            /* [in] */ LPCWSTR Val) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [out] */ LPWSTR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [in] */ LPCWSTR Val) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ LPWSTR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPriority( 
            /* [in] */ BG_JOB_PRIORITY Val) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ BG_JOB_PRIORITY *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNotifyFlags( 
            /* [in] */ ULONG Val) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNotifyFlags( 
            /* [out] */ ULONG *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNotifyInterface( 
            /* [in] */ IUnknown *Val) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNotifyInterface( 
            /* [out] */ IUnknown **pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMinimumRetryDelay( 
            /* [in] */ ULONG Seconds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinimumRetryDelay( 
            /* [out] */ ULONG *Seconds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNoProgressTimeout( 
            /* [in] */ ULONG Seconds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNoProgressTimeout( 
            /* [out] */ ULONG *Seconds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorCount( 
            /* [out] */ ULONG *Errors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxySettings( 
            /* [in] */ BG_JOB_PROXY_USAGE ProxyUsage,
            /* [unique][string][in] */ const WCHAR *ProxyList,
            /* [unique][string][in] */ const WCHAR *ProxyBypassList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxySettings( 
            /* [out] */ BG_JOB_PROXY_USAGE *pProxyUsage,
            /* [out] */ LPWSTR *pProxyList,
            /* [out] */ LPWSTR *pProxyBypassList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TakeOwnership( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyJobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBackgroundCopyJob * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBackgroundCopyJob * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBackgroundCopyJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFileSet )( 
            IBackgroundCopyJob * This,
            /* [in] */ ULONG cFileCount,
            /* [size_is][in] */ BG_FILE_INFO *pFileSet);
        
        HRESULT ( STDMETHODCALLTYPE *AddFile )( 
            IBackgroundCopyJob * This,
            /* [in] */ LPCWSTR RemoteUrl,
            /* [in] */ LPCWSTR LocalName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFiles )( 
            IBackgroundCopyJob * This,
            /* [out] */ IEnumBackgroundCopyFiles **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IBackgroundCopyJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IBackgroundCopyJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IBackgroundCopyJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *Complete )( 
            IBackgroundCopyJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetId )( 
            IBackgroundCopyJob * This,
            /* [out] */ GUID *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IBackgroundCopyJob * This,
            /* [out] */ BG_JOB_TYPE *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgress )( 
            IBackgroundCopyJob * This,
            /* [out] */ BG_JOB_PROGRESS *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimes )( 
            IBackgroundCopyJob * This,
            /* [out] */ BG_JOB_TIMES *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IBackgroundCopyJob * This,
            /* [out] */ BG_JOB_STATE *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetError )( 
            IBackgroundCopyJob * This,
            /* [out] */ IBackgroundCopyError **ppError);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            IBackgroundCopyJob * This,
            /* [out] */ LPWSTR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetDisplayName )( 
            IBackgroundCopyJob * This,
            /* [in] */ LPCWSTR Val);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IBackgroundCopyJob * This,
            /* [out] */ LPWSTR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            IBackgroundCopyJob * This,
            /* [in] */ LPCWSTR Val);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IBackgroundCopyJob * This,
            /* [out] */ LPWSTR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetPriority )( 
            IBackgroundCopyJob * This,
            /* [in] */ BG_JOB_PRIORITY Val);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            IBackgroundCopyJob * This,
            /* [out] */ BG_JOB_PRIORITY *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotifyFlags )( 
            IBackgroundCopyJob * This,
            /* [in] */ ULONG Val);
        
        HRESULT ( STDMETHODCALLTYPE *GetNotifyFlags )( 
            IBackgroundCopyJob * This,
            /* [out] */ ULONG *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotifyInterface )( 
            IBackgroundCopyJob * This,
            /* [in] */ IUnknown *Val);
        
        HRESULT ( STDMETHODCALLTYPE *GetNotifyInterface )( 
            IBackgroundCopyJob * This,
            /* [out] */ IUnknown **pVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetMinimumRetryDelay )( 
            IBackgroundCopyJob * This,
            /* [in] */ ULONG Seconds);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinimumRetryDelay )( 
            IBackgroundCopyJob * This,
            /* [out] */ ULONG *Seconds);
        
        HRESULT ( STDMETHODCALLTYPE *SetNoProgressTimeout )( 
            IBackgroundCopyJob * This,
            /* [in] */ ULONG Seconds);
        
        HRESULT ( STDMETHODCALLTYPE *GetNoProgressTimeout )( 
            IBackgroundCopyJob * This,
            /* [out] */ ULONG *Seconds);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorCount )( 
            IBackgroundCopyJob * This,
            /* [out] */ ULONG *Errors);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxySettings )( 
            IBackgroundCopyJob * This,
            /* [in] */ BG_JOB_PROXY_USAGE ProxyUsage,
            /* [unique][string][in] */ const WCHAR *ProxyList,
            /* [unique][string][in] */ const WCHAR *ProxyBypassList);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxySettings )( 
            IBackgroundCopyJob * This,
            /* [out] */ BG_JOB_PROXY_USAGE *pProxyUsage,
            /* [out] */ LPWSTR *pProxyList,
            /* [out] */ LPWSTR *pProxyBypassList);
        
        HRESULT ( STDMETHODCALLTYPE *TakeOwnership )( 
            IBackgroundCopyJob * This);
        
        END_INTERFACE
    } IBackgroundCopyJobVtbl;

    interface IBackgroundCopyJob
    {
        CONST_VTBL struct IBackgroundCopyJobVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyJob_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBackgroundCopyJob_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBackgroundCopyJob_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBackgroundCopyJob_AddFileSet(This,cFileCount,pFileSet)	\
    (This)->lpVtbl -> AddFileSet(This,cFileCount,pFileSet)

#define IBackgroundCopyJob_AddFile(This,RemoteUrl,LocalName)	\
    (This)->lpVtbl -> AddFile(This,RemoteUrl,LocalName)

#define IBackgroundCopyJob_EnumFiles(This,pEnum)	\
    (This)->lpVtbl -> EnumFiles(This,pEnum)

#define IBackgroundCopyJob_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IBackgroundCopyJob_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IBackgroundCopyJob_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#define IBackgroundCopyJob_Complete(This)	\
    (This)->lpVtbl -> Complete(This)

#define IBackgroundCopyJob_GetId(This,pVal)	\
    (This)->lpVtbl -> GetId(This,pVal)

#define IBackgroundCopyJob_GetType(This,pVal)	\
    (This)->lpVtbl -> GetType(This,pVal)

#define IBackgroundCopyJob_GetProgress(This,pVal)	\
    (This)->lpVtbl -> GetProgress(This,pVal)

#define IBackgroundCopyJob_GetTimes(This,pVal)	\
    (This)->lpVtbl -> GetTimes(This,pVal)

#define IBackgroundCopyJob_GetState(This,pVal)	\
    (This)->lpVtbl -> GetState(This,pVal)

#define IBackgroundCopyJob_GetError(This,ppError)	\
    (This)->lpVtbl -> GetError(This,ppError)

#define IBackgroundCopyJob_GetOwner(This,pVal)	\
    (This)->lpVtbl -> GetOwner(This,pVal)

#define IBackgroundCopyJob_SetDisplayName(This,Val)	\
    (This)->lpVtbl -> SetDisplayName(This,Val)

#define IBackgroundCopyJob_GetDisplayName(This,pVal)	\
    (This)->lpVtbl -> GetDisplayName(This,pVal)

#define IBackgroundCopyJob_SetDescription(This,Val)	\
    (This)->lpVtbl -> SetDescription(This,Val)

#define IBackgroundCopyJob_GetDescription(This,pVal)	\
    (This)->lpVtbl -> GetDescription(This,pVal)

#define IBackgroundCopyJob_SetPriority(This,Val)	\
    (This)->lpVtbl -> SetPriority(This,Val)

#define IBackgroundCopyJob_GetPriority(This,pVal)	\
    (This)->lpVtbl -> GetPriority(This,pVal)

#define IBackgroundCopyJob_SetNotifyFlags(This,Val)	\
    (This)->lpVtbl -> SetNotifyFlags(This,Val)

#define IBackgroundCopyJob_GetNotifyFlags(This,pVal)	\
    (This)->lpVtbl -> GetNotifyFlags(This,pVal)

#define IBackgroundCopyJob_SetNotifyInterface(This,Val)	\
    (This)->lpVtbl -> SetNotifyInterface(This,Val)

#define IBackgroundCopyJob_GetNotifyInterface(This,pVal)	\
    (This)->lpVtbl -> GetNotifyInterface(This,pVal)

#define IBackgroundCopyJob_SetMinimumRetryDelay(This,Seconds)	\
    (This)->lpVtbl -> SetMinimumRetryDelay(This,Seconds)

#define IBackgroundCopyJob_GetMinimumRetryDelay(This,Seconds)	\
    (This)->lpVtbl -> GetMinimumRetryDelay(This,Seconds)

#define IBackgroundCopyJob_SetNoProgressTimeout(This,Seconds)	\
    (This)->lpVtbl -> SetNoProgressTimeout(This,Seconds)

#define IBackgroundCopyJob_GetNoProgressTimeout(This,Seconds)	\
    (This)->lpVtbl -> GetNoProgressTimeout(This,Seconds)

#define IBackgroundCopyJob_GetErrorCount(This,Errors)	\
    (This)->lpVtbl -> GetErrorCount(This,Errors)

#define IBackgroundCopyJob_SetProxySettings(This,ProxyUsage,ProxyList,ProxyBypassList)	\
    (This)->lpVtbl -> SetProxySettings(This,ProxyUsage,ProxyList,ProxyBypassList)

#define IBackgroundCopyJob_GetProxySettings(This,pProxyUsage,pProxyList,pProxyBypassList)	\
    (This)->lpVtbl -> GetProxySettings(This,pProxyUsage,pProxyList,pProxyBypassList)

#define IBackgroundCopyJob_TakeOwnership(This)	\
    (This)->lpVtbl -> TakeOwnership(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_AddFileSet_Proxy( 
    IBackgroundCopyJob * This,
    /* [in] */ ULONG cFileCount,
    /* [size_is][in] */ BG_FILE_INFO *pFileSet);


void __RPC_STUB IBackgroundCopyJob_AddFileSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_AddFile_Proxy( 
    IBackgroundCopyJob * This,
    /* [in] */ LPCWSTR RemoteUrl,
    /* [in] */ LPCWSTR LocalName);


void __RPC_STUB IBackgroundCopyJob_AddFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_EnumFiles_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ IEnumBackgroundCopyFiles **pEnum);


void __RPC_STUB IBackgroundCopyJob_EnumFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_Suspend_Proxy( 
    IBackgroundCopyJob * This);


void __RPC_STUB IBackgroundCopyJob_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_Resume_Proxy( 
    IBackgroundCopyJob * This);


void __RPC_STUB IBackgroundCopyJob_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_Cancel_Proxy( 
    IBackgroundCopyJob * This);


void __RPC_STUB IBackgroundCopyJob_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_Complete_Proxy( 
    IBackgroundCopyJob * This);


void __RPC_STUB IBackgroundCopyJob_Complete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_GetId_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ GUID *pVal);


void __RPC_STUB IBackgroundCopyJob_GetId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_GetType_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ BG_JOB_TYPE *pVal);


void __RPC_STUB IBackgroundCopyJob_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_GetProgress_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ BG_JOB_PROGRESS *pVal);


void __RPC_STUB IBackgroundCopyJob_GetProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_GetTimes_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ BG_JOB_TIMES *pVal);


void __RPC_STUB IBackgroundCopyJob_GetTimes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_GetState_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ BG_JOB_STATE *pVal);


void __RPC_STUB IBackgroundCopyJob_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_GetError_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ IBackgroundCopyError **ppError);


void __RPC_STUB IBackgroundCopyJob_GetError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_GetOwner_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ LPWSTR *pVal);


void __RPC_STUB IBackgroundCopyJob_GetOwner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_SetDisplayName_Proxy( 
    IBackgroundCopyJob * This,
    /* [in] */ LPCWSTR Val);


void __RPC_STUB IBackgroundCopyJob_SetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_GetDisplayName_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ LPWSTR *pVal);


void __RPC_STUB IBackgroundCopyJob_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_SetDescription_Proxy( 
    IBackgroundCopyJob * This,
    /* [in] */ LPCWSTR Val);


void __RPC_STUB IBackgroundCopyJob_SetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_GetDescription_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ LPWSTR *pVal);


void __RPC_STUB IBackgroundCopyJob_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_SetPriority_Proxy( 
    IBackgroundCopyJob * This,
    /* [in] */ BG_JOB_PRIORITY Val);


void __RPC_STUB IBackgroundCopyJob_SetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_GetPriority_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ BG_JOB_PRIORITY *pVal);


void __RPC_STUB IBackgroundCopyJob_GetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_SetNotifyFlags_Proxy( 
    IBackgroundCopyJob * This,
    /* [in] */ ULONG Val);


void __RPC_STUB IBackgroundCopyJob_SetNotifyFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_GetNotifyFlags_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ ULONG *pVal);


void __RPC_STUB IBackgroundCopyJob_GetNotifyFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_SetNotifyInterface_Proxy( 
    IBackgroundCopyJob * This,
    /* [in] */ IUnknown *Val);


void __RPC_STUB IBackgroundCopyJob_SetNotifyInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_GetNotifyInterface_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ IUnknown **pVal);


void __RPC_STUB IBackgroundCopyJob_GetNotifyInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_SetMinimumRetryDelay_Proxy( 
    IBackgroundCopyJob * This,
    /* [in] */ ULONG Seconds);


void __RPC_STUB IBackgroundCopyJob_SetMinimumRetryDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_GetMinimumRetryDelay_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ ULONG *Seconds);


void __RPC_STUB IBackgroundCopyJob_GetMinimumRetryDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_SetNoProgressTimeout_Proxy( 
    IBackgroundCopyJob * This,
    /* [in] */ ULONG Seconds);


void __RPC_STUB IBackgroundCopyJob_SetNoProgressTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_GetNoProgressTimeout_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ ULONG *Seconds);


void __RPC_STUB IBackgroundCopyJob_GetNoProgressTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_GetErrorCount_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ ULONG *Errors);


void __RPC_STUB IBackgroundCopyJob_GetErrorCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_SetProxySettings_Proxy( 
    IBackgroundCopyJob * This,
    /* [in] */ BG_JOB_PROXY_USAGE ProxyUsage,
    /* [unique][string][in] */ const WCHAR *ProxyList,
    /* [unique][string][in] */ const WCHAR *ProxyBypassList);


void __RPC_STUB IBackgroundCopyJob_SetProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_GetProxySettings_Proxy( 
    IBackgroundCopyJob * This,
    /* [out] */ BG_JOB_PROXY_USAGE *pProxyUsage,
    /* [out] */ LPWSTR *pProxyList,
    /* [out] */ LPWSTR *pProxyBypassList);


void __RPC_STUB IBackgroundCopyJob_GetProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyJob_TakeOwnership_Proxy( 
    IBackgroundCopyJob * This);


void __RPC_STUB IBackgroundCopyJob_TakeOwnership_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBackgroundCopyJob_INTERFACE_DEFINED__ */


#ifndef __IEnumBackgroundCopyJobs_INTERFACE_DEFINED__
#define __IEnumBackgroundCopyJobs_INTERFACE_DEFINED__

/* interface IEnumBackgroundCopyJobs */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumBackgroundCopyJobs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1af4f612-3b71-466f-8f58-7b6f73ac57ad")
    IEnumBackgroundCopyJobs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IBackgroundCopyJob **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumBackgroundCopyJobs **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *puCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumBackgroundCopyJobsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumBackgroundCopyJobs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumBackgroundCopyJobs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumBackgroundCopyJobs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumBackgroundCopyJobs * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IBackgroundCopyJob **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumBackgroundCopyJobs * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumBackgroundCopyJobs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumBackgroundCopyJobs * This,
            /* [out] */ IEnumBackgroundCopyJobs **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumBackgroundCopyJobs * This,
            /* [out] */ ULONG *puCount);
        
        END_INTERFACE
    } IEnumBackgroundCopyJobsVtbl;

    interface IEnumBackgroundCopyJobs
    {
        CONST_VTBL struct IEnumBackgroundCopyJobsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumBackgroundCopyJobs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumBackgroundCopyJobs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumBackgroundCopyJobs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumBackgroundCopyJobs_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumBackgroundCopyJobs_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumBackgroundCopyJobs_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumBackgroundCopyJobs_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#define IEnumBackgroundCopyJobs_GetCount(This,puCount)	\
    (This)->lpVtbl -> GetCount(This,puCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyJobs_Next_Proxy( 
    IEnumBackgroundCopyJobs * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IBackgroundCopyJob **rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumBackgroundCopyJobs_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyJobs_Skip_Proxy( 
    IEnumBackgroundCopyJobs * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumBackgroundCopyJobs_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyJobs_Reset_Proxy( 
    IEnumBackgroundCopyJobs * This);


void __RPC_STUB IEnumBackgroundCopyJobs_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyJobs_Clone_Proxy( 
    IEnumBackgroundCopyJobs * This,
    /* [out] */ IEnumBackgroundCopyJobs **ppenum);


void __RPC_STUB IEnumBackgroundCopyJobs_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBackgroundCopyJobs_GetCount_Proxy( 
    IEnumBackgroundCopyJobs * This,
    /* [out] */ ULONG *puCount);


void __RPC_STUB IEnumBackgroundCopyJobs_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumBackgroundCopyJobs_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_bits_0013 */
/* [local] */ 

#define   BG_NOTIFY_JOB_TRANSFERRED    0x0001
#define   BG_NOTIFY_JOB_ERROR          0x0002
#define   BG_NOTIFY_DISABLE            0x0004
#define   BG_NOTIFY_JOB_MODIFICATION   0x0008


extern RPC_IF_HANDLE __MIDL_itf_bits_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bits_0013_v0_0_s_ifspec;

#ifndef __IBackgroundCopyCallback_INTERFACE_DEFINED__
#define __IBackgroundCopyCallback_INTERFACE_DEFINED__

/* interface IBackgroundCopyCallback */
/* [object][helpstring][async_uuid][uuid] */ 


EXTERN_C const IID IID_IBackgroundCopyCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97ea99c7-0186-4ad4-8df9-c5b4e0ed6b22")
    IBackgroundCopyCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE JobTransferred( 
            /* [in] */ IBackgroundCopyJob *pJob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JobError( 
            /* [in] */ IBackgroundCopyJob *pJob,
            /* [in] */ IBackgroundCopyError *pError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JobModification( 
            /* [in] */ IBackgroundCopyJob *pJob,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBackgroundCopyCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBackgroundCopyCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBackgroundCopyCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *JobTransferred )( 
            IBackgroundCopyCallback * This,
            /* [in] */ IBackgroundCopyJob *pJob);
        
        HRESULT ( STDMETHODCALLTYPE *JobError )( 
            IBackgroundCopyCallback * This,
            /* [in] */ IBackgroundCopyJob *pJob,
            /* [in] */ IBackgroundCopyError *pError);
        
        HRESULT ( STDMETHODCALLTYPE *JobModification )( 
            IBackgroundCopyCallback * This,
            /* [in] */ IBackgroundCopyJob *pJob,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IBackgroundCopyCallbackVtbl;

    interface IBackgroundCopyCallback
    {
        CONST_VTBL struct IBackgroundCopyCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBackgroundCopyCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBackgroundCopyCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBackgroundCopyCallback_JobTransferred(This,pJob)	\
    (This)->lpVtbl -> JobTransferred(This,pJob)

#define IBackgroundCopyCallback_JobError(This,pJob,pError)	\
    (This)->lpVtbl -> JobError(This,pJob,pError)

#define IBackgroundCopyCallback_JobModification(This,pJob,dwReserved)	\
    (This)->lpVtbl -> JobModification(This,pJob,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBackgroundCopyCallback_JobTransferred_Proxy( 
    IBackgroundCopyCallback * This,
    /* [in] */ IBackgroundCopyJob *pJob);


void __RPC_STUB IBackgroundCopyCallback_JobTransferred_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyCallback_JobError_Proxy( 
    IBackgroundCopyCallback * This,
    /* [in] */ IBackgroundCopyJob *pJob,
    /* [in] */ IBackgroundCopyError *pError);


void __RPC_STUB IBackgroundCopyCallback_JobError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyCallback_JobModification_Proxy( 
    IBackgroundCopyCallback * This,
    /* [in] */ IBackgroundCopyJob *pJob,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IBackgroundCopyCallback_JobModification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBackgroundCopyCallback_INTERFACE_DEFINED__ */


#ifndef __AsyncIBackgroundCopyCallback_INTERFACE_DEFINED__
#define __AsyncIBackgroundCopyCallback_INTERFACE_DEFINED__

/* interface AsyncIBackgroundCopyCallback */
/* [uuid][object][helpstring] */ 


EXTERN_C const IID IID_AsyncIBackgroundCopyCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ca29d251-b4bb-4679-a3d9-ae8006119d54")
    AsyncIBackgroundCopyCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Begin_JobTransferred( 
            /* [in] */ IBackgroundCopyJob *pJob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish_JobTransferred( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Begin_JobError( 
            /* [in] */ IBackgroundCopyJob *pJob,
            /* [in] */ IBackgroundCopyError *pError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish_JobError( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Begin_JobModification( 
            /* [in] */ IBackgroundCopyJob *pJob,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish_JobModification( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct AsyncIBackgroundCopyCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            AsyncIBackgroundCopyCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            AsyncIBackgroundCopyCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            AsyncIBackgroundCopyCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_JobTransferred )( 
            AsyncIBackgroundCopyCallback * This,
            /* [in] */ IBackgroundCopyJob *pJob);
        
        HRESULT ( STDMETHODCALLTYPE *Finish_JobTransferred )( 
            AsyncIBackgroundCopyCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_JobError )( 
            AsyncIBackgroundCopyCallback * This,
            /* [in] */ IBackgroundCopyJob *pJob,
            /* [in] */ IBackgroundCopyError *pError);
        
        HRESULT ( STDMETHODCALLTYPE *Finish_JobError )( 
            AsyncIBackgroundCopyCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_JobModification )( 
            AsyncIBackgroundCopyCallback * This,
            /* [in] */ IBackgroundCopyJob *pJob,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Finish_JobModification )( 
            AsyncIBackgroundCopyCallback * This);
        
        END_INTERFACE
    } AsyncIBackgroundCopyCallbackVtbl;

    interface AsyncIBackgroundCopyCallback
    {
        CONST_VTBL struct AsyncIBackgroundCopyCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define AsyncIBackgroundCopyCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define AsyncIBackgroundCopyCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define AsyncIBackgroundCopyCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define AsyncIBackgroundCopyCallback_Begin_JobTransferred(This,pJob)	\
    (This)->lpVtbl -> Begin_JobTransferred(This,pJob)

#define AsyncIBackgroundCopyCallback_Finish_JobTransferred(This)	\
    (This)->lpVtbl -> Finish_JobTransferred(This)

#define AsyncIBackgroundCopyCallback_Begin_JobError(This,pJob,pError)	\
    (This)->lpVtbl -> Begin_JobError(This,pJob,pError)

#define AsyncIBackgroundCopyCallback_Finish_JobError(This)	\
    (This)->lpVtbl -> Finish_JobError(This)

#define AsyncIBackgroundCopyCallback_Begin_JobModification(This,pJob,dwReserved)	\
    (This)->lpVtbl -> Begin_JobModification(This,pJob,dwReserved)

#define AsyncIBackgroundCopyCallback_Finish_JobModification(This)	\
    (This)->lpVtbl -> Finish_JobModification(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE AsyncIBackgroundCopyCallback_Begin_JobTransferred_Proxy( 
    AsyncIBackgroundCopyCallback * This,
    /* [in] */ IBackgroundCopyJob *pJob);


void __RPC_STUB AsyncIBackgroundCopyCallback_Begin_JobTransferred_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE AsyncIBackgroundCopyCallback_Finish_JobTransferred_Proxy( 
    AsyncIBackgroundCopyCallback * This);


void __RPC_STUB AsyncIBackgroundCopyCallback_Finish_JobTransferred_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE AsyncIBackgroundCopyCallback_Begin_JobError_Proxy( 
    AsyncIBackgroundCopyCallback * This,
    /* [in] */ IBackgroundCopyJob *pJob,
    /* [in] */ IBackgroundCopyError *pError);


void __RPC_STUB AsyncIBackgroundCopyCallback_Begin_JobError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE AsyncIBackgroundCopyCallback_Finish_JobError_Proxy( 
    AsyncIBackgroundCopyCallback * This);


void __RPC_STUB AsyncIBackgroundCopyCallback_Finish_JobError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE AsyncIBackgroundCopyCallback_Begin_JobModification_Proxy( 
    AsyncIBackgroundCopyCallback * This,
    /* [in] */ IBackgroundCopyJob *pJob,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB AsyncIBackgroundCopyCallback_Begin_JobModification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE AsyncIBackgroundCopyCallback_Finish_JobModification_Proxy( 
    AsyncIBackgroundCopyCallback * This);


void __RPC_STUB AsyncIBackgroundCopyCallback_Finish_JobModification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __AsyncIBackgroundCopyCallback_INTERFACE_DEFINED__ */


#ifndef __IBackgroundCopyManager_INTERFACE_DEFINED__
#define __IBackgroundCopyManager_INTERFACE_DEFINED__

/* interface IBackgroundCopyManager */
/* [object][helpstring][uuid] */ 

#define    BG_JOB_ENUM_ALL_USERS  0x0001

EXTERN_C const IID IID_IBackgroundCopyManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ce34c0d-0dc9-4c1f-897c-daa1b78cee7c")
    IBackgroundCopyManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateJob( 
            /* [in] */ LPCWSTR DisplayName,
            /* [in] */ BG_JOB_TYPE Type,
            /* [out] */ GUID *pJobId,
            /* [out] */ IBackgroundCopyJob **ppJob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetJob( 
            /* [in] */ REFGUID jobID,
            /* [out] */ IBackgroundCopyJob **ppJob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumJobs( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ IEnumBackgroundCopyJobs **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorDescription( 
            /* [in] */ HRESULT hResult,
            /* [in] */ DWORD LanguageId,
            /* [out] */ LPWSTR *pErrorDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBackgroundCopyManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBackgroundCopyManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBackgroundCopyManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateJob )( 
            IBackgroundCopyManager * This,
            /* [in] */ LPCWSTR DisplayName,
            /* [in] */ BG_JOB_TYPE Type,
            /* [out] */ GUID *pJobId,
            /* [out] */ IBackgroundCopyJob **ppJob);
        
        HRESULT ( STDMETHODCALLTYPE *GetJob )( 
            IBackgroundCopyManager * This,
            /* [in] */ REFGUID jobID,
            /* [out] */ IBackgroundCopyJob **ppJob);
        
        HRESULT ( STDMETHODCALLTYPE *EnumJobs )( 
            IBackgroundCopyManager * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IEnumBackgroundCopyJobs **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorDescription )( 
            IBackgroundCopyManager * This,
            /* [in] */ HRESULT hResult,
            /* [in] */ DWORD LanguageId,
            /* [out] */ LPWSTR *pErrorDescription);
        
        END_INTERFACE
    } IBackgroundCopyManagerVtbl;

    interface IBackgroundCopyManager
    {
        CONST_VTBL struct IBackgroundCopyManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBackgroundCopyManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBackgroundCopyManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBackgroundCopyManager_CreateJob(This,DisplayName,Type,pJobId,ppJob)	\
    (This)->lpVtbl -> CreateJob(This,DisplayName,Type,pJobId,ppJob)

#define IBackgroundCopyManager_GetJob(This,jobID,ppJob)	\
    (This)->lpVtbl -> GetJob(This,jobID,ppJob)

#define IBackgroundCopyManager_EnumJobs(This,dwFlags,ppEnum)	\
    (This)->lpVtbl -> EnumJobs(This,dwFlags,ppEnum)

#define IBackgroundCopyManager_GetErrorDescription(This,hResult,LanguageId,pErrorDescription)	\
    (This)->lpVtbl -> GetErrorDescription(This,hResult,LanguageId,pErrorDescription)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBackgroundCopyManager_CreateJob_Proxy( 
    IBackgroundCopyManager * This,
    /* [in] */ LPCWSTR DisplayName,
    /* [in] */ BG_JOB_TYPE Type,
    /* [out] */ GUID *pJobId,
    /* [out] */ IBackgroundCopyJob **ppJob);


void __RPC_STUB IBackgroundCopyManager_CreateJob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyManager_GetJob_Proxy( 
    IBackgroundCopyManager * This,
    /* [in] */ REFGUID jobID,
    /* [out] */ IBackgroundCopyJob **ppJob);


void __RPC_STUB IBackgroundCopyManager_GetJob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyManager_EnumJobs_Proxy( 
    IBackgroundCopyManager * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IEnumBackgroundCopyJobs **ppEnum);


void __RPC_STUB IBackgroundCopyManager_EnumJobs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBackgroundCopyManager_GetErrorDescription_Proxy( 
    IBackgroundCopyManager * This,
    /* [in] */ HRESULT hResult,
    /* [in] */ DWORD LanguageId,
    /* [out] */ LPWSTR *pErrorDescription);


void __RPC_STUB IBackgroundCopyManager_GetErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBackgroundCopyManager_INTERFACE_DEFINED__ */



#ifndef __BackgroundCopyManager_LIBRARY_DEFINED__
#define __BackgroundCopyManager_LIBRARY_DEFINED__

/* library BackgroundCopyManager */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_BackgroundCopyManager;

EXTERN_C const CLSID CLSID_BackgroundCopyManager;

#ifdef __cplusplus

class DECLSPEC_UUID("4991d34b-80a1-4291-83b6-3328366b9097")
BackgroundCopyManager;
#endif
#endif /* __BackgroundCopyManager_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\debmacro.h ===
#if !defined(_FUSION_INC_DEBMACRO_H_INCLUDED_)
#define _FUSION_INC_DEBMACRO_H_INCLUDED_

#pragma once


#if DBG
#define ASSERT(x) if (!(x)) { DebugBreak(); }
#else
#define ASSERT(x)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\serialst.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    serialst.h

Abstract:

    Header file for serialst.c

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Revision History:

    16-Feb-1995 rfirth
        Created

    05-Jul-1999 adriaanc
        nabbed for fusion

--*/

#if defined(__cplusplus)
extern "C" {
#endif


// defines copied from wininet\common
#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))


#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))


#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}


#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }


#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }


#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }


#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

//
// types
//

#if DBG
typedef struct _RESOURCE_INFO
{
    DWORD Tid;
} RESOURCE_INFO, *LPRESOURCE_INFO;
#endif // DBG

typedef struct {

#if DBG

    //
    // Signature - must have this to ensure its really a serialized list. Also
    // makes finding start of this structure relatively easy when debugging
    //

    DWORD Signature;

    //
    // ResourceInfo - basically who owns this 'object', combined with yet more
    // debugging information
    //

    RESOURCE_INFO ResourceInfo;

    //
    // LockCount - number of re-entrant locks held
    //

    LONG LockCount;

#endif // DBG

    LIST_ENTRY List;

    //
    // ElementCount - number of items on list. Useful for consistency checking
    //

    LONG ElementCount;

    //
    // Lock - we must acquire this to update the list. Put this structure at
    // the end to make life easier when debugging
    //

    CRITICAL_SECTION Lock;

} SERIALIZED_LIST, *LPSERIALIZED_LIST;

//
// SERIALIZED_LIST_ENTRY - we can use this in place of LIST_ENTRY so that in
// the debug version we can check for cycles, etc.
//

typedef struct {

    LIST_ENTRY List;

#if DBG

    DWORD Signature;
    DWORD Flags;

#endif

} SERIALIZED_LIST_ENTRY, *LPSERIALIZED_LIST_ENTRY;

//
// prototypes
//

#if DBG

VOID
InitializeSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
TerminateSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
LockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
UnlockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
InsertAtHeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

VOID
InsertAtTailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

VOID
RemoveFromSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

BOOL
IsSerializedListEmpty(
    IN LPSERIALIZED_LIST SerializedList
    );

PLIST_ENTRY
HeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

PLIST_ENTRY
TailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
CheckEntryOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    );

#define IsLockHeld(list) \
    (((list)->ResourceInfo.Tid == GetCurrentThreadId()) \
        ? ((list)->LockCount != 0) \
        : FALSE)

#else // DBG

#define InitializeSerializedList(list) \
    { \
        InitializeListHead(&(list)->List); \
        InitializeCriticalSection(&(list)->Lock); \
        (list)->ElementCount = 0; \
    }

#define TerminateSerializedList(list) \
    DeleteCriticalSection(&(list)->Lock)

#define LockSerializedList(list) \
    EnterCriticalSection(&(list)->Lock)

#define UnlockSerializedList(list) \
    LeaveCriticalSection(&(list)->Lock)

#define InsertAtHeadOfSerializedList(list, entry) \
    { \
        LockSerializedList(list); \
        InsertHeadList(&(list)->List, entry); \
        ++(list)->ElementCount; \
        UnlockSerializedList(list); \
    }

#define InsertAtTailOfSerializedList(list, entry) \
    { \
        LockSerializedList(list); \
        InsertTailList(&(list)->List, entry); \
        ++(list)->ElementCount; \
        UnlockSerializedList(list); \
    }

#define RemoveFromSerializedList(list, entry) \
    { \
        LockSerializedList(list); \
        RemoveEntryList(entry); \
        --(list)->ElementCount; \
        UnlockSerializedList(list); \
    }

#define IsSerializedListEmpty(list) \
    IsListEmpty(&(list)->List)

#define HeadOfSerializedList(list) \
    (list)->List.Flink

#define TailOfSerializedList(list) \
    (list)->List.Blink

#define IsLockHeld(list) \
    /* NOTHING */



#endif // DBG

//
// functions that are always functions
//

LPVOID
SlDequeueHead(
    IN LPSERIALIZED_LIST SerializedList
    );

LPVOID
SlDequeueTail(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
IsOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

//
// functions that are always macros
//

#define NextInSerializedList(list, entry)\
        (( ((entry)->List).Flink == &((list)->List))? NULL : ((entry)->List).Flink)

#define ElementsOnSerializedList(list) \
    (list)->ElementCount

#define SlSelf(SerializedList) \
    &(SerializedList)->List.Flink

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\bitsmsg.h ===
/***************************************************************************
*                                                                          *
*   bitsmsg.h --  error code definitions for the background file copier    *
*                                                                          *
*   Copyright (c) 2000, Microsoft Corp. All rights reserved.               *
*                                                                          *
***************************************************************************/

#ifndef _BGCPYMSG_
#define _BGCPYMSG_

#if defined (_MSC_VER) && (_MSC_VER >= 1020) && !defined(__midl)
#pragma once
#endif

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: BG_E_NOT_FOUND
//
// MessageText:
//
//  The requested item was not found.
//
#define BG_E_NOT_FOUND                   0x80200001L

//
// MessageId: BG_E_INVALID_STATE
//
// MessageText:
//
//  The requested action is not allowed in the current state.
//
#define BG_E_INVALID_STATE               0x80200002L

//
// MessageId: BG_E_EMPTY
//
// MessageText:
//
//  The item is empty.
//
#define BG_E_EMPTY                       0x80200003L

//
// MessageId: BG_E_FILE_NOT_AVAILABLE
//
// MessageText:
//
//  The file is not available.
//
#define BG_E_FILE_NOT_AVAILABLE          0x80200004L

//
// MessageId: BG_E_PROTOCOL_NOT_AVAILABLE
//
// MessageText:
//
//  The protocol is not available.
//
#define BG_E_PROTOCOL_NOT_AVAILABLE      0x80200005L

//
// MessageId: BG_S_ERROR_CONTEXT_NONE
//
// MessageText:
//
//  An error has not occured.
//
#define BG_S_ERROR_CONTEXT_NONE          0x00200006L

//
// MessageId: BG_E_ERROR_CONTEXT_UNKNOWN
//
// MessageText:
//
//  The error occured in an unknown location.
//
#define BG_E_ERROR_CONTEXT_UNKNOWN       0x80200007L

//
// MessageId: BG_E_ERROR_CONTEXT_GENERAL_QUEUE_MANAGER
//
// MessageText:
//
//  The error occured in the queue manager.
//
#define BG_E_ERROR_CONTEXT_GENERAL_QUEUE_MANAGER 0x80200008L

//
// MessageId: BG_E_ERROR_CONTEXT_LOCAL_FILE
//
// MessageText:
//
//  The error occured while processing the local file.
//
#define BG_E_ERROR_CONTEXT_LOCAL_FILE    0x80200009L

//
// MessageId: BG_E_ERROR_CONTEXT_REMOTE_FILE
//
// MessageText:
//
//  The error occured while processing the remote file.
//
#define BG_E_ERROR_CONTEXT_REMOTE_FILE   0x8020000AL

//
// MessageId: BG_E_ERROR_CONTEXT_GENERAL_TRANSPORT
//
// MessageText:
//
//  The error occured in the transport layer.
//
#define BG_E_ERROR_CONTEXT_GENERAL_TRANSPORT 0x8020000BL

//
// MessageId: BG_E_ERROR_CONTEXT_QUEUE_MANAGER_NOTIFICATION
//
// MessageText:
//
//  The error occured while processing the notification callback.
//
#define BG_E_ERROR_CONTEXT_QUEUE_MANAGER_NOTIFICATION 0x8020000CL

//
// MessageId: BG_E_DESTINATION_LOCKED
//
// MessageText:
//
//  The destination volume is locked.
//
#define BG_E_DESTINATION_LOCKED          0x8020000DL

//
// MessageId: BG_E_VOLUME_CHANGED
//
// MessageText:
//
//  The destination volume changed.
//
#define BG_E_VOLUME_CHANGED              0x8020000EL

//
// MessageId: BG_E_ERROR_INFORMATION_UNAVAILABLE
//
// MessageText:
//
//  Error information is unavailable. 
//
#define BG_E_ERROR_INFORMATION_UNAVAILABLE 0x8020000FL

//
// MessageId: BG_E_ERROR_FATAL_ERROR_ON_COMPLETE
//
// MessageText:
//
//  A fatal error occured while completing the job.   Some of the job files may be missing or corrupt. Cancel the job and resubmit.
//
#define BG_E_ERROR_FATAL_ERROR_ON_COMPLETE 0x80200010L

//
// MessageId: BG_E_MISSING_FILE_SIZE
//
// MessageText:
//
//  The server did not return the file size. The URL may point to dynamic content.
//
#define BG_E_MISSING_FILE_SIZE           0x80200011L

//
// MessageId: BG_E_INSUFFICIENT_HTTP_SUPPORT
//
// MessageText:
//
//  The server does not support HTTP 1.1.
//
#define BG_E_INSUFFICIENT_HTTP_SUPPORT   0x80200012L

//
// MessageId: BG_E_INSUFFICIENT_RANGE_SUPPORT
//
// MessageText:
//
//  The server does not support the Range header.
//
#define BG_E_INSUFFICIENT_RANGE_SUPPORT  0x80200013L

//
// MessageId: BG_E_REMOTE_NOT_SUPPORTED
//
// MessageText:
//
//  Remote use of BITS is not supported.
//
#define BG_E_REMOTE_NOT_SUPPORTED        0x80200014L

//
// MessageId: BG_E_NEW_OWNER_DIFF_MAPPING
//
// MessageText:
//
//  The drive mapping for the job are different for the current owner then the previous owner.
//
#define BG_E_NEW_OWNER_DIFF_MAPPING      0x80200015L

//
// MessageId: BG_E_NEW_OWNER_NO_FILE_ACCESS
//
// MessageText:
//
//  The new owner has insufficient access to the temp files. 
//
#define BG_E_NEW_OWNER_NO_FILE_ACCESS    0x80200016L

//
// MessageId: BG_E_HTTP_ERROR_100
//
// MessageText:
//
//  The request can be continued. 
//
#define BG_E_HTTP_ERROR_100              0x80190064L

//
// MessageId: BG_E_HTTP_ERROR_101
//
// MessageText:
//
//  The server has switched protocols in an upgrade header. 
//
#define BG_E_HTTP_ERROR_101              0x80190065L

//
// MessageId: BG_E_HTTP_ERROR_200
//
// MessageText:
//
//  The request completed successfully. 
//
#define BG_E_HTTP_ERROR_200              0x801900C8L

//
// MessageId: BG_E_HTTP_ERROR_201
//
// MessageText:
//
//  The request has been fulfilled and resulted in the creation of a new resource. 
//
#define BG_E_HTTP_ERROR_201              0x801900C9L

//
// MessageId: BG_E_HTTP_ERROR_202
//
// MessageText:
//
//  The request has been accepted for processing, but the processing has not been completed.
//
#define BG_E_HTTP_ERROR_202              0x801900CAL

//
// MessageId: BG_E_HTTP_ERROR_203
//
// MessageText:
//
//  The returned meta information in the entity-header is not the definitive set available from the origin server.
//
#define BG_E_HTTP_ERROR_203              0x801900CBL

//
// MessageId: BG_E_HTTP_ERROR_204
//
// MessageText:
//
//  The server has fulfilled the request, but there is no new information to send back.
//
#define BG_E_HTTP_ERROR_204              0x801900CCL

//
// MessageId: BG_E_HTTP_ERROR_205
//
// MessageText:
//
//  The request has been completed, and the client program should reset the document view that caused the request to be sent to allow the user to easily initiate another input action.
//
#define BG_E_HTTP_ERROR_205              0x801900CDL

//
// MessageId: BG_E_HTTP_ERROR_206
//
// MessageText:
//
//  The server has fulfilled the partial GET request for the resource.
//
#define BG_E_HTTP_ERROR_206              0x801900CEL

//
// MessageId: BG_E_HTTP_ERROR_300
//
// MessageText:
//
//  The server couldn't decide what to return. 
//
#define BG_E_HTTP_ERROR_300              0x8019012CL

//
// MessageId: BG_E_HTTP_ERROR_301
//
// MessageText:
//
//  The requested resource has been assigned to a new permanent URI (Uniform Resource Identifier), and any future references to this resource should be done using one of the returned URIs.
//
#define BG_E_HTTP_ERROR_301              0x8019012DL

//
// MessageId: BG_E_HTTP_ERROR_302
//
// MessageText:
//
//  The requested resource resides temporarily under a different URI (Uniform Resource Identifier).
//
#define BG_E_HTTP_ERROR_302              0x8019012EL

//
// MessageId: BG_E_HTTP_ERROR_303
//
// MessageText:
//
//  The response to the request can be found under a different URI (Uniform Resource Identifier) and should be retrieved using a GET method on that resource.
//
#define BG_E_HTTP_ERROR_303              0x8019012FL

//
// MessageId: BG_E_HTTP_ERROR_304
//
// MessageText:
//
//  The requested resource has not been modified. 
//
#define BG_E_HTTP_ERROR_304              0x80190130L

//
// MessageId: BG_E_HTTP_ERROR_305
//
// MessageText:
//
//  The requested resource must be accessed through the proxy given by the location field. 
//
#define BG_E_HTTP_ERROR_305              0x80190131L

//
// MessageId: BG_E_HTTP_ERROR_307
//
// MessageText:
//
//  The redirected request keeps the same verb. HTTP/1.1 behavior. 
//
#define BG_E_HTTP_ERROR_307              0x80190133L

//
// MessageId: BG_E_HTTP_ERROR_400
//
// MessageText:
//
//  The request could not be processed by the server due to invalid syntax.
//
#define BG_E_HTTP_ERROR_400              0x80190190L

//
// MessageId: BG_E_HTTP_ERROR_401
//
// MessageText:
//
//  The requested resource requires user authentication.
//
#define BG_E_HTTP_ERROR_401              0x80190191L

//
// MessageId: BG_E_HTTP_ERROR_402
//
// MessageText:
//
//  Not currently implemented in the HTTP protocol.
//
#define BG_E_HTTP_ERROR_402              0x80190192L

//
// MessageId: BG_E_HTTP_ERROR_403
//
// MessageText:
//
//  The server understood the request, but is refusing to fulfill it.
//
#define BG_E_HTTP_ERROR_403              0x80190193L

//
// MessageId: BG_E_HTTP_ERROR_404
//
// MessageText:
//
//  The server has not found anything matching the requested URI (Uniform Resource Identifier).
//
#define BG_E_HTTP_ERROR_404              0x80190194L

//
// MessageId: BG_E_HTTP_ERROR_405
//
// MessageText:
//
//  The method used is not allowed.
//
#define BG_E_HTTP_ERROR_405              0x80190195L

//
// MessageId: BG_E_HTTP_ERROR_406
//
// MessageText:
//
//  No responses acceptable to the client were found.
//
#define BG_E_HTTP_ERROR_406              0x80190196L

//
// MessageId: BG_E_HTTP_ERROR_407
//
// MessageText:
//
//  Proxy authentication required.
//
#define BG_E_HTTP_ERROR_407              0x80190197L

//
// MessageId: BG_E_HTTP_ERROR_408
//
// MessageText:
//
//  The server timed out waiting for the request.
//
#define BG_E_HTTP_ERROR_408              0x80190198L

//
// MessageId: BG_E_HTTP_ERROR_409
//
// MessageText:
//
//  The request could not be completed due to a conflict with the current state of the resource. The user should resubmit with more information.
//
#define BG_E_HTTP_ERROR_409              0x80190199L

//
// MessageId: BG_E_HTTP_ERROR_410
//
// MessageText:
//
//  The requested resource is no longer available at the server, and no forwarding address is known.
//
#define BG_E_HTTP_ERROR_410              0x8019019AL

//
// MessageId: BG_E_HTTP_ERROR_411
//
// MessageText:
//
//  The server refuses to accept the request without a defined content length.
//
#define BG_E_HTTP_ERROR_411              0x8019019BL

//
// MessageId: BG_E_HTTP_ERROR_412
//
// MessageText:
//
//  The precondition given in one or more of the request header fields evaluated to false when it was tested on the server.
//
#define BG_E_HTTP_ERROR_412              0x8019019CL

//
// MessageId: BG_E_HTTP_ERROR_413
//
// MessageText:
//
//  The server is refusing to process a request because the request entity is larger than the server is willing or able to process.
//
#define BG_E_HTTP_ERROR_413              0x8019019DL

//
// MessageId: BG_E_HTTP_ERROR_414
//
// MessageText:
//
//  The server is refusing to service the request because the request URI (Uniform Resource Identifier) is longer than the server is willing to interpret.
//
#define BG_E_HTTP_ERROR_414              0x8019019EL

//
// MessageId: BG_E_HTTP_ERROR_415
//
// MessageText:
//
//  The server is refusing to service the request because the entity of the request is in a format not supported by the requested resource for the requested method.
//
#define BG_E_HTTP_ERROR_415              0x8019019FL

//
// MessageId: BG_E_HTTP_ERROR_416
//
// MessageText:
//
//  The server could not satisfy the range request.
//
#define BG_E_HTTP_ERROR_416              0x801901A0L

//
// MessageId: BG_E_HTTP_ERROR_417
//
// MessageText:
//
//  The expectation given in an Expect request-header field could not be met by this server.
//
#define BG_E_HTTP_ERROR_417              0x801901A1L

//
// MessageId: BG_E_HTTP_ERROR_449
//
// MessageText:
//
//  The request should be retried after doing the appropriate action. 
//
#define BG_E_HTTP_ERROR_449              0x801901C1L

//
// MessageId: BG_E_HTTP_ERROR_500
//
// MessageText:
//
//  The server encountered an unexpected condition that prevented it from fulfilling the request. 
//
#define BG_E_HTTP_ERROR_500              0x801901F4L

//
// MessageId: BG_E_HTTP_ERROR_501
//
// MessageText:
//
//  The server does not support the functionality required to fulfill the request. 
//
#define BG_E_HTTP_ERROR_501              0x801901F5L

//
// MessageId: BG_E_HTTP_ERROR_502
//
// MessageText:
//
//  The server, while acting as a gateway or proxy, received an invalid response from the upstream server it accessed in attempting to fulfill the request. 
//
#define BG_E_HTTP_ERROR_502              0x801901F6L

//
// MessageId: BG_E_HTTP_ERROR_503
//
// MessageText:
//
//  The service is temporarily overloaded. 
//
#define BG_E_HTTP_ERROR_503              0x801901F7L

//
// MessageId: BG_E_HTTP_ERROR_504
//
// MessageText:
//
//  The request was timed out waiting for a gateway. 
//
#define BG_E_HTTP_ERROR_504              0x801901F8L

//
// MessageId: BG_E_HTTP_ERROR_505
//
// MessageText:
//
//  The server does not support, or refuses to support, the HTTP protocol version that was used in the request message.
//
#define BG_E_HTTP_ERROR_505              0x801901F9L

#endif //_BGCPYMSG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\dialog.h ===
class CAssemblyDownload;

typedef enum
{
    DOWNLOADDLG_STATE_INIT = 0,
    DOWNLOADDLG_STATE_GETTING_APP_MANIFEST,
    DOWNLOADDLG_STATE_GETTING_OTHER_FILES,
    DOWNLOADDLG_STATE_ALL_DONE,
    DOWNLOADDLG_STATE_MAX
} DOWNLOADDLG_STATE;

class CDownloadDlg
{
    private:

    DOWNLOADDLG_STATE _eState;

    public:

    HWND _hwndDlg;
    IBackgroundCopyJob *_pJob;

    CDownloadDlg();
    ~CDownloadDlg();

    const WCHAR * GetString(UINT id);

    VOID    SetWindowTime(HWND hwnd, FILETIME filetime);

    UINT64  GetSystemTimeAsUINT64();

    VOID   SignalAlert(HWND hwndDlg, UINT Type);

    const WCHAR *MapStateToString(BG_JOB_STATE state);

    UINT64   ScaleDownloadRate(double Rate, /*rate in seconds*/ const WCHAR **pFormat );

    UINT64   ScaleDownloadEstimate(double Time, /*time in seconds*/ const WCHAR **pFormat );

    VOID    UpdateDialog(HWND hwndDlg);
 
    VOID    InitDialog(HWND hwndDlg);

    VOID    CheckHR(HWND hwnd, HRESULT Hr, bool bThrow);

    VOID    BITSCheckHR(HWND hwnd, HRESULT Hr, bool bThrow);

    VOID    DoCancel(HWND hwndDlg, bool PromptUser);

    VOID    DoFinish(HWND hwndDlg);

    VOID    DoClose(HWND hwndDlg);

    VOID    HandleTimerTick(HWND hwndDlg);

    HRESULT HandleUpdate();


    HRESULT HandleCOMCallback(IBackgroundCopyJob* pJob, bool CriticalEvent);

    HRESULT CreateUI(int nShowCmd);

    VOID    CreateJob(WCHAR* szJobURL);

    VOID    ResumeJob(WCHAR* szJobGUID, WCHAR* szJobFileName);
    VOID    SetJob(IBackgroundCopyJob * pJob);

    VOID    SetJobObject(IBackgroundCopyJob *pJob);

    VOID    SetDlgState(DOWNLOADDLG_STATE eState);
    
};


    INT_PTR CALLBACK DialogProc(
        HWND hwndDlg,  // handle to dialog box
        UINT uMsg,     // message
        WPARAM wParam, // first message parameter
        LPARAM lParam  // second message parameter
        );

HRESULT CreateDialogObject(CDownloadDlg **ppDlg, IBackgroundCopyJob *pJob);
#define WM_FINISH_DOWNLOAD WM_USER+1
#define WM_CANCEL_DOWNLOAD WM_USER+2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\fusenetincludes.h ===
#pragma once

#ifndef __FUSENET_INCLUDES_H__
#define __INCLUDES__

#include <windows.h>
#include <fusenet.h>
#include <util.h>
#include <shlwapi.h>
#include <cstrings.h>
#include <serialst.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\cstrings.h ===
#pragma once

#define CRT_ALLOC 0
#define COM_ALLOC 1

//-----------------------------------------------------------------------------
// Minimal string class
//-----------------------------------------------------------------------------
class CString
{
    public:

    enum AllocFlags
    {
        COM_Allocator = 0,
        CRT_Allocator
    };

    enum HashFlags
    {
        CaseInsensitive = 0,
        CaseSensitive 
    };


    DWORD     _dwSig;
    HRESULT    _hr;
    LPWSTR     _pwz;          // Str ptr.
    DWORD     _cc;           // String length
    DWORD     _ccBuf;        // Buffer length
    AllocFlags    _eAlloc;       // Allocator
    
    // ctor
    CString();
    
    // ctor w/ allocator
    CString(AllocFlags eAlloc);

    // dtor
    ~CString();

    // Allocations
    HRESULT ResizeBuffer(DWORD ccNew);


    // Deallocations
    VOID FreeBuffer();

	// Assume control for a buffer.
    HRESULT TakeOwnership(WCHAR* pwz, DWORD cc);
    HRESULT TakeOwnership(LPWSTR pwz);
    
    // Release control.
    HRESULT ReleaseOwnership();
            
    // Direct copy assign from string.
    HRESULT Assign(LPWSTR pwzSource);

    // Direct copy assign from CString
    HRESULT Assign(CString& sSource);

    // Append given wchar string.
    HRESULT Append(LPWSTR pwzSource);

    // Append given CString
    HRESULT Append(CString& sSource);

    // Return ith element.
    WCHAR&  operator [] (DWORD i);

    HRESULT LastElement(CString &sSource);

    HRESULT RemoveLastElement();

    HRESULT Combine(LPWSTR pwzSource, BOOL fUrl);

    HRESULT PathCombine(LPWSTR pwzSource);

    HRESULT PathCombine(CString &sSource);

    HRESULT UrlCombine(LPWSTR pwzSource);

    HRESULT UrlCombine(CString &sSource);

    HRESULT PathFindFileName(LPWSTR *ppwz);

    HRESULT PathFindFileName(CString &sPath);

    HRESULT PathPrefixMatch(LPWSTR pwzPrefix);
            
    // / -> \ in string
    VOID PathNormalize();\
	VOID Get65599Hash(LPDWORD pdwHash, DWORD dwFlags);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\lock.h ===
#pragma once

class CCriticalSection
{
    public:
        CCriticalSection(CRITICAL_SECTION *pcs)
        : _pcs(pcs)
        {
//            ASSERT(pcs);
        }

        HRESULT Lock()
        {
            HRESULT                          hr = S_OK;
            
            __try {
                ::EnterCriticalSection(_pcs);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                hr = E_OUTOFMEMORY;
            }

            return hr;
        }

        HRESULT Unlock()
        {
            ::LeaveCriticalSection(_pcs);

            return S_OK;
        }

    private:
        CRITICAL_SECTION                    *_pcs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\manifestimport.h ===
#pragma once
#include <comdef.h>

class CAssemblyManifestImport : public IAssemblyManifestImport
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD(GetAssemblyIdentity)( 
        /* out */ LPASSEMBLY_IDENTITY *ppAssemblyId);

    STDMETHOD(GetManifestApplicationInfo)(
        /* out */ LPMANIFEST_APPLICATION_INFO* ppAppInfo);

    STDMETHOD(GetPollingInterval)(
        /* out */ DWORD *pollingInterval);

    STDMETHOD(GetNextFile)( 
        /* in  */ DWORD    nIndex,
        /* out */ LPASSEMBLY_FILE_INFO *ppAssemblyFile);
 
    STDMETHOD(QueryFile)(
        /* in  */ LPCOLESTR pwzFileName,
        /* out */ LPASSEMBLY_FILE_INFO *ppAssemblyFile);

    STDMETHOD(GetNextPatchAssemblyId)(
        /* in */    DWORD nIndex,
        /* out */   LPASSEMBLY_IDENTITY *ppAssemblyId);

    STDMETHOD(GetTargetPatchMapping)(
        /* in */ LPWSTR pwzTarget, 
        /* out */ LPWSTR *ppwzSource, 
        /* out */ LPWSTR *ppwzPatchFile);

    STDMETHOD(GetPatchFilePatchMapping)(
        /* in */ LPWSTR pwzPatchFile, 
        /* out */ LPWSTR *ppwzSource, 
        /* out */ LPWSTR *ppwzTarget);

    STDMETHOD(SetPatchAssemblyNode)(
        /* in */ DWORD nIndex);
        
    STDMETHOD(IsCABbed)(
        /* out */ LPWSTR *ppwzCabName);
    
    STDMETHOD(GetNextAssembly)( 
        /* in */ DWORD nIndex,
        /* out */ LPDEPENDENT_ASSEMBLY_INFO *ppDependAsm);

    STDMETHOD(ReportManifestType)(
        /*out*/  DWORD *pdwType);

    ~CAssemblyManifestImport();

    void static InitGlobalCritSect();

private:

    // Instance specific data
    DWORD                    _dwSig;
    HRESULT                  _hr;
    LONG                     _cRef;
    LPASSEMBLY_IDENTITY      _pAssemblyId;
    IXMLDOMDocument2        *_pXMLDoc;
    IXMLDOMNodeList         *_pXMLFileNodeList;            
    LONG                     _nFileNodes;
    IXMLDOMNodeList         *_pXMLAssemblyNodeList;
    LONG                     _nAssemblyNodes;
    BSTR                     _bstrManifestFilePath;

    IXMLDOMNodeList     *_pSourceAssemblyPatchNodeList;
    LONG                        _nSourceAssemblyPatchNodes;

    IXMLDOMNode         *_pPatchAssemblyNode;


    // Globals
    static LONG               g_nRefCount;
    static CRITICAL_SECTION   g_cs;
    
public:
    enum eStringTableId
    {
        Name = 0,
        Version,
        Language,
        PublicKey,
        PublicKeyToken,
        ProcessorArchitecture,
        Type,

        SelNameSpaces,
        NameSpace,
        SelLanguage,
        XPath,
        FileNode,
        FileName,
        FileHash,
        AssemblyId,
        DependentAssemblyNode,
        DependentAssemblyCodebase,
        Codebase,
        
        ShellState,
        FriendlyName,        // note: this must be in sync with MAN_APPLICATION in fusenet.idl
        EntryPoint,
        EntryImageType,
        IconFile,
        IconIndex,
        ShowCommand,
        HotKey,
        Patch,
        PatchInfo,
        Source,
        Target,
        PatchFile,
        AssemblyIdTag,
        Compressed,
        Subscription,
        PollingInterval,
        File,
        Cab,
        MAX_STRINGS
    };

private:
    struct StringTableEntry
    {
        const WCHAR *pwz;
        BSTR         bstr;
        SIZE_T       Cch;
    };


    static StringTableEntry g_StringTable[MAX_STRINGS];

    CAssemblyManifestImport();

    HRESULT Init(LPCOLESTR wzManifestFilePath);

    HRESULT ParseAttribute(IXMLDOMNode *pIXMLDOMNode, 
        BSTR bstrAttributeName, LPWSTR *ppwzAttributeValue, 
        LPDWORD pccAttributeValueOut);

    HRESULT LoadDocumentSync();

    HRESULT XMLtoAssemblyIdentity(IXMLDOMNode *pIDOMNode, LPASSEMBLY_IDENTITY *ppAssemblyFile);
    
    HRESULT CreateAssemblyFileEx(LPASSEMBLY_FILE_INFO * ppAssemblyFile, IXMLDOMNode * pIDOMNode);
    
friend HRESULT CreateAssemblyManifestImport(IAssemblyManifestImport** ppImport, 
    LPCOLESTR pwzManifestFilePath);



};

inline CAssemblyManifestImport::eStringTableId operator++(CAssemblyManifestImport::eStringTableId &rs, int)
{
    return rs = (CAssemblyManifestImport::eStringTableId) (rs+1);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\proxy\stub_dlldata.c ===
#include <dlldata.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by bits_ie.rc
//
#define IDS_LONGPROGRESS                1
#define IDS_ERROR                       2
#define IDS_SHORTPROGRESS               3
#define IDS_QUEUED                      4
#define IDS_CONNECTING                  5
#define IDS_TRANSFERRING                6
#define IDS_SUSPENDED                   7
#define IDS_FATALERROR                  8
#define IDS_TRANSIENTERROR              9
#define IDS_TRANSFERRED                 10
#define IDS_ACKNOWLEDGED                11
#define IDS_CANCELLED                   12
#define IDS_UNKNOWN                     13
#define IDS_DAYSFORMAT                  14
#define IDS_HOURSFORMAT                 15
#define IDS_MINUTESFORMAT               16
#define IDS_SECONDSFORMAT               17
#define IDS_FOREGROUND                  18
#define IDS_HIGH                        19
#define IDS_NORMAL                      20
#define IDS_LOW                         21
#define IDS_ERRORBOXTITLE               22
#define IDS_FILEDLGTITLE                23
#define IDS_CANCELCAPTION               24
#define IDS_CANCELTEXT                  25
#define IDS_NOHTTPORHTTPS               26
#define IDS_ALLFILES                    27
#define IDS_STARTUPLINK                 28
#define IDS_CLOSECAPTION                29
#define IDS_CLOSETEXT                   30
#define IDS_ALREADYFINISHED             31
#define IDS_ALREADYFINISHEDCAPTION      32
#define IDS_GIGAFORMAT                  33
#define IDS_MEGAFORMAT                  34
#define IDS_KILOFORMAT                  35
#define IDS_BYTEFORMAT                  36
#define IDS_MAX                          IDS_BYTEFORMAT
#define IDD_DIALOG                      101
#define IDI_ICON                        105
#ifdef SIMPLEUI
#define IDA_DOWNLOADING               106
#define IDC_ANIMATE_DOWNLOAD          1003
#endif
#define IDC_COMPLETE2                   1004
#define IDC_FINISH                      1004
#define IDC_CANCEL2                     1005
#define IDC_CANCEL                      1005
#define IDC_SUSPEND2                    1006
#define IDC_SUSPEND                     1006
#define IDC_PROGRESS                    1007
#define IDC_PROGRESSBAR                 1007
#define IDC_STATUSTXT                   1008
#define IDC_CREATIONTIMETXT             1009
#define IDC_MODIFICATONTIMETXT          1010
#define IDC_COMPLETIONTIMETXT           1011
#define IDC_ESTIMATEDTIMETXT            1012
#define IDC_TRANSFERRATETXT             1013
#define IDC_PRIORITY                    1014
#define IDC_RESUME2                     1015
#define IDC_RESUME                      1015
#define IDC_PRIORITYTXT                 1016
#define IDC_ERRORMSGTXT                 1017
#define IDC_STATUS                      1021
#define IDC_STARTTIME                   1022
#define IDC_MODIFICATIONTIME            1023
#define IDC_COMPLETIONTIME              1024
#define IDC_ESTIMATEDTIME               1025
#define IDC_TRANSFERRATE                1026
#define IDC_ERRORMSG                    1027
#define IDC_PROGRESSINFOTXT             1045
#define IDC_PROGRESSINFO                1046
#define IDC_DISPLAYNAME                 1047

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1037
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\includes\util.h ===
#undef SAFEDELETE
#define SAFEDELETE(p) if ((p) != NULL) { delete (p); (p) = NULL; };

#undef SAFEDELETEARRAY
#define SAFEDELETEARRAY(p) if ((p) != NULL) { delete[] (p); (p) = NULL; };

#undef SAFERELEASE
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; };


inline
WCHAR*
WSTRDupDynamic(LPCWSTR pwszSrc)
{
    LPWSTR pwszDest = NULL;
    if (pwszSrc != NULL)
    {
        const DWORD dwLen = lstrlenW(pwszSrc) + 1;
        pwszDest = new WCHAR[dwLen];
        if( pwszDest )
            memcpy(pwszDest, pwszSrc, dwLen * sizeof(WCHAR));
    }
    return pwszDest;
}


inline
LPBYTE
MemDupDynamic(const BYTE *pSrc, DWORD cb)
{
    LPBYTE  pDest = NULL;

    pDest = new BYTE[cb];
    if(pDest)
        memcpy(pDest, pSrc, cb);

    return pDest;
}

HRESULT
RemoveDirectoryAndChildren(LPWSTR szDir);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\client\client.cpp ===
//
// Client.cpp - client implementation
//
#include <objbase.h>
#include <iostream.h>
#include <assert.h>

#include "fusenet.h"
//#include "Util.h"
#include "server.h"
//#include "Iface.h"

#define INITGUID
#include <guiddef.h>

DEFINE_GUID(IID_IAssemblyUpdate,
0x301b3415,0xf52d,0x4d40,0xbd,0xf7,0x31,0xd8,0x27,0x12,0xc2,0xdc);

DEFINE_GUID(LIBID_ServerLib,
0xd3011ee0,0xb997,0x11cf,0xa6,0xbb,0x00,0x80,0xc7,0xb2,0xd6,0x82);

DEFINE_GUID(CLSID_CAssemblyUpdate,
0x37b088b8,0x70ef,0x4ecf,0xb1,0x1e,0x1f,0x3f,0x4d,0x10,0x5f,0xdd);


int __cdecl main()
{
    HRESULT hr;
    cout << "Client Running..." << endl;

    DWORD clsctx ;
    clsctx = CLSCTX_LOCAL_SERVER ;
    cout << "Attempt to create local component.";

    // Initialize COM Library
//    CoInitialize(NULL) ;
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED); 

    IAssemblyUpdate *pAssemblyUpdate = NULL;
    IAssemblyDownload *pDownload = NULL;
    
    hr = CoCreateInstance(CLSID_CAssemblyUpdate,
                                  NULL, clsctx, 
                                  IID_IAssemblyUpdate, (void**)&pAssemblyUpdate) ;
    if (SUCCEEDED(hr))
    {
        cout << "Successfully created component." << endl;
        cout << "Use interface IAssemblyUpdate." << endl;

        hr = CreateAssemblyDownload(&pDownload);    
        pDownload->DownloadManifestAndDependencies(L"http://adriaanc5/msnsubscription.manifest", 
                NULL, DOWNLOAD_FLAGS_PROGRESS_UI);
        hr = pAssemblyUpdate->RegisterAssemblySubscription(L"MARS Version 1.0", 
            L"http://adriaanc5/msnsubscription.manifest", 60000);

        cout << "hr for pAssemblyUpdate->RegisterAssemblySubscription() is " << hr << endl;

        cout << "Release IAssemblyUpdate." << endl;

       pAssemblyUpdate->Release() ;
    
    }
    else
    {
        cout << "Could not create component." << endl;
    }
    // Uninitialize COM Library
    CoUninitialize() ;

    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\manifest\applicationinfo.cpp ===
#include <fusenetincludes.h>
#include <applicationinfo.h>


// ---------------------------------------------------------------------------
// CreateManifestApplicationInfo
// ---------------------------------------------------------------------------
STDAPI
CreateManifestApplicationInfo(
    LPMANIFEST_APPLICATION_INFO* ppManifestApplicationInfo)
{
    HRESULT hr = S_OK;

    LPMANIFEST_APPLICATION_INFO pManifestApplicationInfo = NULL;

    if (ppManifestApplicationInfo == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *ppManifestApplicationInfo = NULL;

    pManifestApplicationInfo = new(CManifestApplicationInfo);
    if (!pManifestApplicationInfo)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    *ppManifestApplicationInfo = static_cast<IManifestApplicationInfo*> (pManifestApplicationInfo);

exit:
    return hr;
}


// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CManifestApplicationInfo::CManifestApplicationInfo()
    : _dwSig('OFIA'), _cRef(1), _hr(S_OK)
{
    memset(_ai, 0, sizeof(_ai));
}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CManifestApplicationInfo::~CManifestApplicationInfo()
{
    for (DWORD i = MAN_APPLICATION_FRIENDLYNAME; i < MAN_APPLICATION_MAX; i++)
        SAFEDELETEARRAY(_ai[i].pwzProperty);
}
// ---------------------------------------------------------------------------
// Set
// ---------------------------------------------------------------------------
HRESULT CManifestApplicationInfo::Set(DWORD dwId, LPCOLESTR pwzProperty)
{
    DWORD ccProperty = lstrlen(pwzProperty) + 1;
    LPWSTR pwzTmp = NULL;

	if (pwzProperty != NULL)
	{
	    pwzTmp = new WCHAR[ccProperty];
	    if (!pwzTmp)
	    {
	        _hr = E_OUTOFMEMORY;
	        goto exit;
	    }
	    memcpy(pwzTmp, pwzProperty, ccProperty * sizeof(WCHAR));
	}
	else
		ccProperty = 0;

    SAFEDELETEARRAY(_ai[dwId].pwzProperty);
    _ai[dwId].pwzProperty = pwzTmp;
    _ai[dwId].ccProperty = ccProperty;
    
exit:
    return _hr;
}

// ---------------------------------------------------------------------------
// Get
// ---------------------------------------------------------------------------
HRESULT CManifestApplicationInfo::Get(DWORD dwId, LPOLESTR *ppwzProperty, LPDWORD pccProperty)
{
    *ppwzProperty = NULL;
    *pccProperty = 0;
    DWORD ccProperty = _ai[dwId].ccProperty;
    LPWSTR pwzProperty = NULL;
 
    if (_ai[dwId].pwzProperty == NULL)
		goto exit;

	pwzProperty = new WCHAR[ccProperty];
    if (!pwzProperty)
    {
        _hr = E_OUTOFMEMORY;
        goto exit;
    }
    memcpy(pwzProperty, _ai[dwId].pwzProperty, ccProperty * sizeof(WCHAR));
    *ppwzProperty = pwzProperty;
    *pccProperty = ccProperty;

exit:
    return _hr;
}


// IUnknown Boilerplate

// ---------------------------------------------------------------------------
// CManifestApplicationInfo::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CManifestApplicationInfo::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IManifestApplicationInfo)
       )
    {
        *ppvObj = static_cast<IManifestApplicationInfo*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CManifestApplicationInfo::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CManifestApplicationInfo::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CManifestApplicationInfo::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CManifestApplicationInfo::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\manifest\manifestimport.cpp ===
#include <fusenetincludes.h>
#include <msxml2.h>
#include <manifestimport.h>
#include <sxsapi.h>
#include <lock.h>

#define WZ_NAMESPACES              L"xmlns:asm_namespace_v1='urn:schemas-microsoft-com:asm.v1'"
#define WZ_SELECTION_NAMESPACES    L"SelectionNamespaces"
#define WZ_SELECTION_LANGUAGE      L"SelectionLanguage"
#define WZ_XPATH                    L"XPath"
#define WZ_FILE_NODE                L"/assembly/file"
#define WZ_FILE_QUERYSTRING_PREFIX  L"/assembly/file[@name = \""
#define WZ_FILE_QUERYSTRING_SUFFIX  L"\"]"
#define WZ_ASSEMBLY_ID              L"/assembly/assemblyIdentity"
#define WZ_DEPENDENT_ASSEMBLY_NODE       L"/assembly/dependency/dependentAssembly/assemblyIdentity"
#define WZ_DEPENDENT_ASSEMBLY_CODEBASE  L"../install[@codebase]"
#define WZ_CODEBASE                L"codebase"
#define WZ_SHELLSTATE             L"/assembly/application/shellState"
#define WZ_FILE_NAME                L"name"
#define WZ_FILE_HASH                L"hash"
#define WZ_FRIENDLYNAME             L"friendlyName"
#define WZ_ENTRYPOINT               L"entryPoint"
#define WZ_ENTRYIMAGETYPE           L"entryImageType"
#define WZ_ICONFILE                 L"iconFile"
#define WZ_ICONINDEX               L"iconIndex"
#define WZ_SHOWCOMMAND           L"showCommand"
#define WZ_HOTKEY                   L"hotKey"
#define WZ_PATCH                    L"/assembly/Patch/SourceAssembly"
#define WZ_PATCHINFO                L"/PatchInfo/"
#define WZ_SOURCE                   L"source"
#define WZ_TARGET                   L"target"
#define WZ_PATCHFILE                L"patchfile"
#define WZ_ASSEMBLY_ID_TAG  L"assemblyIdentity"
#define WZ_COMPRESSED           L"compressed"
#define WZ_SUBSCRIPTION        L"/assembly/dependency/dependentAssembly/subscription"
#define WZ_POLLING_INTERVAL L"pollingInterval"
#define WZ_FILE L"file"
#define WZ_CAB L"cab"

#undef NUMBER_OF
#define NUMBER_OF(x) ( (sizeof(x) / sizeof(*x) ) )

#undef ENTRY
#define ENTRY(x) { x, NULL, NUMBER_OF(x) - 1 },

#undef IFALLOCFAILED_EXIT
#define IFALLOCFAILED_EXIT(_x) \
    do {if ((_x) == NULL) {_hr = E_OUTOFMEMORY; cs.Unlock(); goto exit; } } while (0)


CAssemblyManifestImport::StringTableEntry CAssemblyManifestImport::g_StringTable[] = 
{    
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE)
    ENTRY(WZ_SELECTION_NAMESPACES)
    ENTRY(WZ_NAMESPACES)
    ENTRY(WZ_SELECTION_LANGUAGE)
    ENTRY(WZ_XPATH)
    ENTRY(WZ_FILE_NODE)
    ENTRY(WZ_FILE_NAME)
    ENTRY(WZ_FILE_HASH)
    ENTRY(WZ_ASSEMBLY_ID)
    ENTRY(WZ_DEPENDENT_ASSEMBLY_NODE)
    ENTRY(WZ_DEPENDENT_ASSEMBLY_CODEBASE)
    ENTRY(WZ_CODEBASE)
    ENTRY(WZ_SHELLSTATE)
    ENTRY(WZ_FRIENDLYNAME)
    ENTRY(WZ_ENTRYPOINT)
    ENTRY(WZ_ENTRYIMAGETYPE)
    ENTRY(WZ_ICONFILE)
    ENTRY(WZ_ICONINDEX)
    ENTRY(WZ_SHOWCOMMAND)
    ENTRY(WZ_HOTKEY)
    ENTRY(WZ_PATCH)
    ENTRY(WZ_PATCHINFO)
    ENTRY(WZ_SOURCE)
    ENTRY(WZ_TARGET)
    ENTRY(WZ_PATCHFILE)
    ENTRY(WZ_ASSEMBLY_ID_TAG)
    ENTRY(WZ_COMPRESSED)
    ENTRY(WZ_SUBSCRIPTION)
    ENTRY(WZ_POLLING_INTERVAL)
    ENTRY(WZ_FILE)
    ENTRY(WZ_CAB)
};


LONG CAssemblyManifestImport::g_nRefCount                     = 0;
CRITICAL_SECTION CAssemblyManifestImport::g_cs;
    
// CLSID_XML DOM Document 3.0
class __declspec(uuid("f6d90f11-9c73-11d3-b32e-00c04f990bb4")) private_MSXML_DOMDocument30;


// Publics


// ---------------------------------------------------------------------------
// CreateAssemblyManifestImport
// ---------------------------------------------------------------------------
STDAPI CreateAssemblyManifestImport(IAssemblyManifestImport** ppImport, 
    LPCOLESTR pwzManifestFilePath)
{
    HRESULT hr = S_OK;

    CAssemblyManifestImport *pImport = new(CAssemblyManifestImport);
    if (!pImport)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (FAILED(hr = pImport->Init(pwzManifestFilePath)))
    {
        SAFERELEASE(pImport);
        goto exit;
    }

exit:

    *ppImport = (IAssemblyManifestImport*) pImport;

    return hr;
}


// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CAssemblyManifestImport::CAssemblyManifestImport()
    : _dwSig('TRPM'), _cRef(1), _hr(S_OK), _pAssemblyId(NULL), _pXMLDoc(NULL), 
      _pXMLFileNodeList(NULL), _pXMLAssemblyNodeList(NULL), _nFileNodes(0), 
      _nAssemblyNodes(0), _bstrManifestFilePath(NULL) ,
      _pSourceAssemblyPatchNodeList(NULL), _nSourceAssemblyPatchNodes(0), _pPatchAssemblyNode(NULL)
{
}


// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CAssemblyManifestImport::~CAssemblyManifestImport()
{
    SAFERELEASE(_pAssemblyId);
    SAFERELEASE(_pXMLFileNodeList);
    SAFERELEASE(_pXMLAssemblyNodeList);
    SAFERELEASE(_pXMLDoc);
    SAFERELEASE(_pSourceAssemblyPatchNodeList);
    SAFERELEASE(_pPatchAssemblyNode);

    if (_bstrManifestFilePath)
        ::SysFreeString(_bstrManifestFilePath);


    if (!InterlockedDecrement(&g_nRefCount))
    {    
        for (eStringTableId i = Name;  i <= MAX_STRINGS; i++)
            ::SysFreeString(g_StringTable[i].bstr);
    }
}


// ---------------------------------------------------------------------------
// GetPollingInterval
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::GetPollingInterval(DWORD *pollingInterval)
{
    LPWSTR pwzBuf = NULL;
    DWORD ccBuf;
    IXMLDOMNode *pIDOMNode = NULL;
    IXMLDOMNodeList *pXMLMatchingFileNodeList = NULL;
    LONG nMatchingFileNodes = 0;
    
    if ((_hr = _pXMLDoc->selectNodes(g_StringTable[Subscription].bstr, &pXMLMatchingFileNodeList)) != S_OK)
        goto exit;

   _hr = pXMLMatchingFileNodeList->get_length(&nMatchingFileNodes);

    if (nMatchingFileNodes > 1)
    {
        _hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        goto exit;
    }
    _hr = pXMLMatchingFileNodeList->reset();

    if ((_hr = pXMLMatchingFileNodeList->get_item(0, &pIDOMNode)) != S_OK)
    {
        _hr = E_FAIL;
        goto exit;
    }

    // BugBug, should we put in a default settign incase there is no polling info?   
    if (!(_hr = ParseAttribute(pIDOMNode, g_StringTable[PollingInterval].bstr, &pwzBuf, &ccBuf)) == S_OK)
    {
        _hr = E_FAIL;
        goto exit;
    }

    (*pollingInterval) = wcstol(pwzBuf, NULL, 10);
    
exit:
    SAFEDELETEARRAY(pwzBuf);
    SAFERELEASE(pIDOMNode);
    SAFERELEASE(pXMLMatchingFileNodeList);

    return _hr;
}

// ---------------------------------------------------------------------------
// GetNextFile
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::GetNextFile(DWORD nIndex, IAssemblyFileInfo **ppAssemblyFile)
{
    LPWSTR pwzBuf = NULL;
    DWORD  ccBuf = 0;

    CString sFileName;
    CString sFileHash;

    IXMLDOMNode *pIDOMNode = NULL;
    LPASSEMBLY_FILE_INFO pAssemblyFile = NULL;
    
    // Initialize the file node list if necessary.    
    if (!_pXMLFileNodeList)
    {
        if ((_hr = _pXMLDoc->selectNodes(g_StringTable[FileNode].bstr, 
            &_pXMLFileNodeList)) != S_OK)
            goto exit;

        _hr = _pXMLFileNodeList->get_length(&_nFileNodes);
        _hr = _pXMLFileNodeList->reset();
    }

    if (nIndex >= (DWORD) _nFileNodes)
    {
        _hr = S_FALSE;
        goto exit;
    }

    if ((_hr = _pXMLFileNodeList->get_item(nIndex, &pIDOMNode)) != S_OK)
        goto exit;

    CreateAssemblyFileEx (&pAssemblyFile, pIDOMNode);
 
    *ppAssemblyFile = pAssemblyFile;
    (*ppAssemblyFile)->AddRef();
    

exit:

    SAFERELEASE(pAssemblyFile);
    SAFERELEASE(pIDOMNode);

    return _hr;

}


// ---------------------------------------------------------------------------
// QueryFile
// return:
//    S_OK
//    S_FALSE -not exist or not match or missing attribute
//    E_*
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::QueryFile(LPCOLESTR pcwzFileName, IAssemblyFileInfo **ppAssemblyFile)
{
    CString sQueryString;
    BSTR bstrtQueryString = NULL;

    IXMLDOMNode *pIDOMNode = NULL;
    IXMLDOMNodeList *pXMLMatchingFileNodeList = NULL;
    LPASSEMBLY_FILE_INFO pAssemblyFile = NULL;
    LONG nMatchingFileNodes = 0;

    if (pcwzFileName == NULL || ppAssemblyFile == NULL)
    {
        _hr = E_INVALIDARG;
        goto exit;
    }

    *ppAssemblyFile = NULL;

    // XPath query string: "file[@name = "path\filename"]"
    if (FAILED(_hr=sQueryString.Assign(WZ_FILE_QUERYSTRING_PREFIX)))
        goto exit;
    if (FAILED(_hr=sQueryString.Append((LPWSTR)pcwzFileName)))
        goto exit;
    if (FAILED(_hr=sQueryString.Append(WZ_FILE_QUERYSTRING_SUFFIX)))
        goto exit;

    bstrtQueryString = ::SysAllocString(sQueryString._pwz);
    if (!bstrtQueryString)
    {
        _hr = E_OUTOFMEMORY;
        goto exit;
    }

    if ((_hr = _pXMLDoc->selectNodes(bstrtQueryString, &pXMLMatchingFileNodeList)) != S_OK)
        goto exit;

    _hr = pXMLMatchingFileNodeList->get_length(&nMatchingFileNodes);

    if (nMatchingFileNodes > 1)
    {
        // multiple file callouts having the exact same file name/path within a single manifest...
        _hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        goto exit;
    }

    _hr = pXMLMatchingFileNodeList->reset();

    if ((_hr = pXMLMatchingFileNodeList->get_item(0, &pIDOMNode)) != S_OK)
    {
        _hr = E_FAIL;
        goto exit;
    }

    CreateAssemblyFileEx (&pAssemblyFile, pIDOMNode);

    *ppAssemblyFile = pAssemblyFile;
    (*ppAssemblyFile)->AddRef();

exit:

    if (bstrtQueryString)
        ::SysFreeString(bstrtQueryString);
    
    SAFERELEASE(pIDOMNode);
    SAFERELEASE(pXMLMatchingFileNodeList);
    SAFERELEASE(pAssemblyFile);

    return _hr;

}


// ---------------------------------------------------------------------------
// CreateAssemblyFileEx
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::CreateAssemblyFileEx(LPASSEMBLY_FILE_INFO *ppAssemblyFile, IXMLDOMNode *pIDOMNode)
{
    LPWSTR pwzBuf;
    DWORD ccBuf;
    BOOL compressed;
    CString sFileName, sFileHash;

    LPASSEMBLY_FILE_INFO pAssemblyFile=NULL;

    // Create new AssemblyFile
    if (FAILED(_hr = CreateAssemblyFileInfo(&pAssemblyFile)))
        goto exit;

    // Parse out relevent information from IDOMNode       
    if (FAILED(_hr = ParseAttribute(pIDOMNode, g_StringTable[FileName].bstr,  &pwzBuf, &ccBuf)))
        goto exit;
    sFileName.TakeOwnership(pwzBuf, ccBuf);

    if (FAILED(_hr = ParseAttribute(pIDOMNode, g_StringTable[FileHash].bstr, &pwzBuf, &ccBuf)))
        goto exit;
    sFileHash.TakeOwnership(pwzBuf, ccBuf);

    // Set all aboved pased info into the AssemblyFIle    
    if (FAILED(_hr = pAssemblyFile->Set(ASM_FILE_NAME, sFileName._pwz)))
        goto exit;
    
    if (FAILED(_hr = pAssemblyFile->Set(ASM_FILE_HASH, sFileHash._pwz)))
        goto exit;
        
    *ppAssemblyFile = pAssemblyFile;
    (*ppAssemblyFile)->AddRef();

exit:
    SAFERELEASE (pAssemblyFile);

    return _hr;
}



// ---------------------------------------------------------------------------
// XMLtoAssemblyIdentiy IXMLDOMDocument2 *pXMLDoc
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::XMLtoAssemblyIdentity(IXMLDOMNode *pIDOMNode, LPASSEMBLY_IDENTITY *ppAssemblyId)
{
    LPASSEMBLY_IDENTITY pAssemblyId = NULL;
    LPWSTR pwzBuf = NULL;
    DWORD  ccBuf = 0;

    if (FAILED(_hr = CreateAssemblyIdentity(&pAssemblyId, 0)))
        goto exit;

    for (eStringTableId i = Name; i <= Type; i++)
    {
        CString sBuf;
        if (FAILED(_hr = ParseAttribute(pIDOMNode, g_StringTable[i].bstr, &pwzBuf, &ccBuf)))
            goto exit;

        if (_hr != S_FALSE)
        {
            sBuf.TakeOwnership(pwzBuf, ccBuf);
            _hr = pAssemblyId->SetAttribute(g_StringTable[i].pwz, 
                sBuf._pwz, sBuf._cc);    
        }
    }

    *ppAssemblyId = pAssemblyId;
    (*ppAssemblyId)->AddRef();

  exit:
    SAFERELEASE (pAssemblyId);
    return _hr;

}

// ---------------------------------------------------------------------------
// IsCABbed
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::IsCABbed(LPWSTR *ppwzCabName)
{
    LPWSTR pwzBuf=NULL;
    DWORD ccBuf;
    IXMLDOMNodeList     *pCABFileList;
    LONG                  nCABFiles;
    IXMLDOMNode          *pCABNode;  

    _hr = S_FALSE;
    if (_pPatchAssemblyNode)
    {
        if (_hr = _pPatchAssemblyNode->selectNodes(g_StringTable[Cab].bstr, &pCABFileList))
            goto exit;

        _hr = pCABFileList->get_length(&nCABFiles);
        _hr = pCABFileList->reset();
        
        if (nCABFiles == 0)
        {
            _hr = S_FALSE;
            goto exit;
        }
        else if (nCABFiles > 1)
        {
            _hr = E_FAIL;
            goto exit;
        }

        if (FAILED(_hr = pCABFileList->get_item(0, &pCABNode)))
            goto exit;

        if (FAILED(_hr = ParseAttribute(pCABNode, g_StringTable[File].bstr, &pwzBuf, &ccBuf)))
            goto exit;

        (*ppwzCabName) = pwzBuf;

    }

exit:
    return _hr;
}


// ---------------------------------------------------------------------------
// GetNextPatchAssemblyId
// ---------------------------------------------------------------------------

HRESULT CAssemblyManifestImport::GetNextPatchAssemblyId (DWORD nIndex, LPASSEMBLY_IDENTITY *ppAssemblyId)
{
    IXMLDOMNode *pIDOMSourceAssemblyNode= NULL;
    IXMLDOMNode *pIDOMAssemblyIdNode = NULL;
    LPASSEMBLY_IDENTITY pAssemblyId = NULL;
    CString sQueryString;

  if (!_pSourceAssemblyPatchNodeList)
    {
        if ((_hr = _pXMLDoc->selectNodes(g_StringTable[Patch].bstr, &_pSourceAssemblyPatchNodeList)) != S_OK)
            goto exit;

        _hr = _pSourceAssemblyPatchNodeList->get_length(&_nSourceAssemblyPatchNodes);
        _hr = _pSourceAssemblyPatchNodeList->reset();
    }
  
     if (nIndex >= (DWORD) _nSourceAssemblyPatchNodes)
    {
        _hr = S_FALSE;
        goto exit;
    }

     if (FAILED(_hr = _pSourceAssemblyPatchNodeList->get_item(nIndex, &pIDOMSourceAssemblyNode)))
        goto exit;

    if ((_hr = pIDOMSourceAssemblyNode->selectSingleNode(g_StringTable[AssemblyIdTag].bstr,  &pIDOMAssemblyIdNode)) != S_OK)
        goto exit;

    if (FAILED(_hr = XMLtoAssemblyIdentity(pIDOMAssemblyIdNode, &pAssemblyId)))
       goto exit;

    *ppAssemblyId = pAssemblyId;
    (*ppAssemblyId)->AddRef();
        
exit:
    SAFERELEASE(pIDOMSourceAssemblyNode);
    SAFERELEASE(pIDOMAssemblyIdNode);
    SAFERELEASE(pAssemblyId);

    return _hr;

}


// ---------------------------------------------------------------------------
// SetPatchAssemblyNode
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::SetPatchAssemblyNode(DWORD nIndex)
{
    IXMLDOMNode *pIDOMSourceAssemblyNode= NULL;

    SAFERELEASE(_pPatchAssemblyNode);

    if (nIndex >= (DWORD) _nSourceAssemblyPatchNodes)
    {
        _hr = S_FALSE;
        goto exit;
    }

    if (FAILED(_hr = _pSourceAssemblyPatchNodeList->get_item(nIndex, &pIDOMSourceAssemblyNode)))
        goto exit;

    _pPatchAssemblyNode = pIDOMSourceAssemblyNode;
    _pPatchAssemblyNode->AddRef();

exit:
    SAFERELEASE(pIDOMSourceAssemblyNode);
    return _hr;

}


// ---------------------------------------------------------------------------
// GetTargetPatchMapping
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::GetTargetPatchMapping(LPWSTR pwzTarget, LPWSTR *ppwzSource, 
            LPWSTR *ppwzPatchFile)
{
    LPWSTR pwzBuf= NULL;
    DWORD  ccBuf = 0;
    LPWSTR pwzPatchFile = NULL, pwzSource = NULL;
    CString sQueryString;
    BSTR bstrtQueryString;
    LONG nPatchFileNodes;
    IXMLDOMNodeList *pPatchFileNodeList = NULL;
    IXMLDOMNode *pPatchFileNode = NULL;
    
    // set up serach string
    _hr = sQueryString.Assign(L"PatchInfo[@file=\"");
    _hr = sQueryString.Append(pwzTarget);
    _hr = sQueryString.Append(L"\"] | PatchInfo[@target=\"");
    _hr = sQueryString.Append(pwzTarget);
    _hr = sQueryString.Append(L"\"]");
        
    bstrtQueryString = ::SysAllocString(sQueryString._pwz);
    if (!bstrtQueryString)
    {
        _hr = E_OUTOFMEMORY;
        goto exit;
    }

    if ((_hr = _pPatchAssemblyNode->selectNodes(bstrtQueryString, &pPatchFileNodeList)) != S_OK)
        goto exit;

    _hr = pPatchFileNodeList->get_length(&nPatchFileNodes);

    if (nPatchFileNodes > 1)
    {
        // multiple file callouts having the exact same file name/path within a single source assembly
        _hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        goto exit;
    }
    else if (nPatchFileNodes == 0)
    {
        _hr = S_FALSE;
        goto exit;
    }
    
    _hr = pPatchFileNodeList->reset();

    if ((_hr = pPatchFileNodeList->get_item(0, &pPatchFileNode)) != S_OK)
    {
        _hr = E_FAIL;
        goto exit;
    }

        if ((_hr = ParseAttribute(pPatchFileNode, g_StringTable[File].bstr,  &pwzBuf, &ccBuf)) == S_OK)
    {
            pwzSource = pwzBuf;
            pwzTarget =WSTRDupDynamic(pwzSource);
    }
    else if (_hr == S_FALSE)
    {
        if ((_hr = ParseAttribute(pPatchFileNode, g_StringTable[Source].bstr,  &pwzBuf, &ccBuf) != S_OK))
            goto exit;

        pwzSource =pwzBuf;
    }
    else
        goto exit;


    if ((_hr = ParseAttribute(pPatchFileNode, g_StringTable[PatchFile].bstr,  &pwzBuf, &ccBuf) != S_OK))
        goto exit;
    
     pwzPatchFile =pwzBuf;

    (*ppwzSource) = pwzSource;
    (*ppwzPatchFile) = pwzPatchFile;    

exit:
    if (bstrtQueryString)
        ::SysFreeString(bstrtQueryString);

    SAFERELEASE(pPatchFileNode);
    SAFERELEASE(pPatchFileNodeList);

    return _hr;
    
}


// ---------------------------------------------------------------------------
// GetPatchFilePatchMapping
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::GetPatchFilePatchMapping(LPWSTR pwzPatchFile, LPWSTR *ppwzSource, LPWSTR *ppwzTarget)
{
    LPWSTR pwzBuf= NULL;
    DWORD  ccBuf = 0;
    LPWSTR pwzSource = NULL, pwzTarget = NULL;
    CString sQueryString;
    BSTR bstrtQueryString;
    IXMLDOMNodeList *pPatchFileNodeList;
    LONG nPatchFileNodes;
    IXMLDOMNode *pPatchFileNode;

    // set up serach string
    _hr = sQueryString.Assign(L"PatchInfo[@patchfile=\"");
    _hr = sQueryString.Append(pwzPatchFile);
    _hr = sQueryString.Append(L"\"]");

    bstrtQueryString = ::SysAllocString(sQueryString._pwz);
    if (!bstrtQueryString)
    {
        _hr = E_OUTOFMEMORY;
        goto exit;
    }

    if ((_hr = _pPatchAssemblyNode->selectNodes(bstrtQueryString, &pPatchFileNodeList)) != S_OK)
        goto exit;

    _hr = pPatchFileNodeList->get_length(&nPatchFileNodes);

    if (nPatchFileNodes > 1)
    {
        // multiple file callouts having the exact same file name/path within a single source assembly
        _hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        goto exit;
    }
    _hr = pPatchFileNodeList->reset();

    if ((_hr = pPatchFileNodeList->get_item(0, &pPatchFileNode)) != S_OK)
    {
        _hr = E_FAIL;
        goto exit;
    }
    
    if ((_hr = ParseAttribute(pPatchFileNode, g_StringTable[File].bstr,  &pwzBuf, &ccBuf)) == S_OK)
    {
            pwzSource = pwzBuf;
            pwzTarget =WSTRDupDynamic(pwzSource);
    }
    else if (_hr == S_FALSE)
    {

// Commented out code makes NULL patching possible, Must remove following call to ParseAttribute for source.
/*        if (FAILED(_hr = ParseAttribute(pPatchFileNode, g_StringTable[Source].bstr,  &pwzBuf, &ccBuf)))
            goto exit;
        else if (_hr == S_FALSE)
            pwzBuf = NULL;
*/
        if ((_hr = ParseAttribute(pPatchFileNode, g_StringTable[Source].bstr,  &pwzBuf, &ccBuf) != S_OK))
            goto exit;

        pwzSource =pwzBuf;

        if ((_hr = ParseAttribute(pPatchFileNode, g_StringTable[Target].bstr,  &pwzBuf, &ccBuf) != S_OK))
            goto exit;
         pwzTarget=pwzBuf;
    }
    else
        goto exit;

    (*ppwzSource) = pwzSource;
    (*ppwzTarget) = pwzTarget;

exit:
    if (bstrtQueryString)
        ::SysFreeString(bstrtQueryString);

    SAFERELEASE(pPatchFileNode);
    SAFERELEASE(pPatchFileNodeList);

    return _hr;
    
}


// ---------------------------------------------------------------------------
// GetNextAssembly
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::GetNextAssembly(DWORD nIndex, 
    LPDEPENDENT_ASSEMBLY_INFO *ppDependAsm)
{
    CString sCodebase;
    
    IXMLDOMNode *pIDOMNode = NULL;
    IXMLDOMNode *pIDOMCodebaseNode = NULL;
    IXMLDOMNodeList *pXMLCodebaseNodeList = NULL;
    LPASSEMBLY_IDENTITY pAssemblyId = NULL;
    LPDEPENDENT_ASSEMBLY_INFO pDependAsm = NULL;
    LPWSTR pwzBuf = NULL;
    DWORD  ccBuf = NULL;
    LONG nCodebaseNodes = 0;

    if (ppDependAsm == NULL)
    {
        _hr = E_INVALIDARG;
        goto exit;
    }

    *ppDependAsm = NULL;
    
    // Initialize the assembly node list if necessary.    
    if (!_pXMLAssemblyNodeList)
    {
        if ((_hr = _pXMLDoc->selectNodes(g_StringTable[DependentAssemblyNode].bstr, 
            &_pXMLAssemblyNodeList)) != S_OK)
            goto exit;

        _hr = _pXMLAssemblyNodeList->get_length(&_nAssemblyNodes);
        _hr = _pXMLAssemblyNodeList->reset();
    }

    if (nIndex >= (DWORD) _nAssemblyNodes)
    {
        _hr = S_FALSE;
        goto exit;
    }

    if (FAILED(_hr = _pXMLAssemblyNodeList->get_item(nIndex, &pIDOMNode)))
        goto exit;

    if (FAILED(_hr = XMLtoAssemblyIdentity(pIDOMNode, &pAssemblyId)))
        goto exit;
    
    // note: check for multiple qualified nodes. As the use of "../install" XPath expression
    //      can result in either preceding _or_ following siblings with node name "install",
    //      this is to ensure codebase is not defined > 1 for this particular dependent
    // BUGBUG: should just take the 1st codebase and ignore all others?
    if ((_hr = pIDOMNode->selectNodes(g_StringTable[DependentAssemblyCodebase].bstr, &pXMLCodebaseNodeList)) != S_OK)
        goto exit;

    _hr = pXMLCodebaseNodeList->get_length(&nCodebaseNodes);

    if (nCodebaseNodes > 1)
    {
        // multiple codebases for a single dependent assembly identity...
        _hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        goto exit;
    }

    _hr = pXMLCodebaseNodeList->reset();

    if ((_hr = pXMLCodebaseNodeList->get_item(0, &pIDOMCodebaseNode)) != S_OK)
    {
        _hr = E_FAIL;
        goto exit;
    }

    if (FAILED(_hr = ParseAttribute(pIDOMCodebaseNode, g_StringTable[Codebase].bstr, 
            &pwzBuf, &ccBuf)))
        goto exit;
    sCodebase.TakeOwnership(pwzBuf, ccBuf);

    if (FAILED(_hr = CreateDependentAssemblyInfo(&pDependAsm)))
        goto exit;

    if (FAILED(_hr = pDependAsm->Set(DEPENDENT_ASM_CODEBASE, sCodebase._pwz)))
        goto exit;
    
    // Handout refcounted assemblyid.
    pDependAsm->SetAssemblyIdentity(pAssemblyId);
    
    *ppDependAsm = pDependAsm;
    (*ppDependAsm)->AddRef();

exit:

    SAFERELEASE(pIDOMCodebaseNode);
    SAFERELEASE(pXMLCodebaseNodeList);
    SAFERELEASE(pIDOMNode);
    SAFERELEASE(pAssemblyId);
    SAFERELEASE(pDependAsm);
    return _hr;

}


// ---------------------------------------------------------------------------
// GetAssemblyIdentity
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::GetAssemblyIdentity(LPASSEMBLY_IDENTITY *ppAssemblyId)
{
    IXMLDOMNode *pIDOMNode = NULL;
    LPASSEMBLY_IDENTITY pAssemblyId = NULL;
    LPWSTR pwzBuf = NULL;
    DWORD  ccBuf = 0;

    if (_pAssemblyId)
    {
        *ppAssemblyId = _pAssemblyId;
        (*ppAssemblyId)->AddRef();
        _hr = S_OK;
        goto exit;
    }
    
    if ((_hr = _pXMLDoc->selectSingleNode(g_StringTable[AssemblyId].bstr, 
        &pIDOMNode)) != S_OK)
        goto exit;

    if (FAILED(_hr = XMLtoAssemblyIdentity(pIDOMNode, &pAssemblyId)))
        goto exit;

    *ppAssemblyId = pAssemblyId;
    (*ppAssemblyId)->AddRef();

    // do not release AsmId, cache it
    _pAssemblyId = pAssemblyId;
    
exit:
    SAFERELEASE(pIDOMNode);

    return _hr;
}

// ---------------------------------------------------------------------------
// GetManifestApplicationInfo
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::GetManifestApplicationInfo(LPMANIFEST_APPLICATION_INFO* ppAppInfo)
{
    IXMLDOMNode *pIDOMNode = NULL;
    LPMANIFEST_APPLICATION_INFO pAppInfo = NULL;
    LPWSTR pwzBuf = NULL;
    DWORD  ccBuf = 0;

    if (ppAppInfo == NULL)
    {
        _hr = E_INVALIDARG;
        goto exit;
    }

    *ppAppInfo = NULL;

    if ((_hr = _pXMLDoc->selectSingleNode(g_StringTable[ShellState].bstr, &pIDOMNode)) != S_OK)
       goto exit;

    CreateManifestApplicationInfo(&pAppInfo);

    for (eStringTableId i = FriendlyName; i <= HotKey; i++)
    {
        CString sBuf;
        if (FAILED(_hr = ParseAttribute(pIDOMNode, g_StringTable[i].bstr, &pwzBuf, &ccBuf)))
            goto exit;

        if (_hr != S_FALSE)
        {
            sBuf.TakeOwnership(pwzBuf, ccBuf);
            if (FAILED(_hr = pAppInfo->Set(MAN_APPLICATION_FRIENDLYNAME+i-FriendlyName,
                sBuf._pwz)))
                goto exit;
        }
    }

    // reset so that S_FALSE is returned only if Subscription node is not found but not its attributes
    _hr = S_OK;

    *ppAppInfo = pAppInfo;
    (*ppAppInfo)->AddRef();

exit:
    SAFERELEASE(pIDOMNode);
    SAFERELEASE(pAppInfo);

    return _hr;
}

// IUnknown Boilerplate

// ---------------------------------------------------------------------------
// CAssemblyManifestImport::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyManifestImport::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyManifestImport)
       )
    {
        *ppvObj = static_cast<IAssemblyManifestImport*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyManifestImport::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyManifestImport::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyManifestImport::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyManifestImport::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}

// Privates


// ---------------------------------------------------------------------------
// Init
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::Init(LPCOLESTR pwzManifestFilePath)
{    
    CCriticalSection cs(&g_cs);

    if (!pwzManifestFilePath)
    {
        _hr = E_INVALIDARG;
        goto exit;
    }

    // Alloc globals if necessary
    if (!g_nRefCount)
    {        
        cs.Lock();

        if (!g_nRefCount)
        {
            for (eStringTableId i = Name; i < MAX_STRINGS; i++)
            {                
                if (!(g_StringTable[i].bstr = ::SysAllocString(g_StringTable[i].pwz)))
                {
                    cs.Unlock();
                    _hr = E_OUTOFMEMORY;
                    goto exit;
                }
            }
        }
        g_nRefCount++;        
        cs.Unlock();
    }
    else        
        // NOTENOTE:mem barrier needed if LeaveCriticalSection is previously executed?
        InterlockedIncrement(&g_nRefCount);

    // Alloc manifest file path.
    _bstrManifestFilePath    = ::SysAllocString((LPWSTR) pwzManifestFilePath);
    if (!_bstrManifestFilePath)
    {
        _hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Load the DOM document.
    _hr = LoadDocumentSync();

    // Release the cached AsmId
    SAFERELEASE(_pAssemblyId);

exit:

    return _hr;
}
    

// ---------------------------------------------------------------------------
// LoadDocumentSync
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::LoadDocumentSync()
{
    VARIANT             varURL;
    VARIANT             varNameSpaces;
    VARIANT             varXPath;
    VARIANT_BOOL        varb;

    IXMLDOMDocument2   *pXMLDoc   = NULL;

    // Create the DOM Doc interface
    if (FAILED(_hr = CoCreateInstance(__uuidof(private_MSXML_DOMDocument30), 
            NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument2, (void**)&_pXMLDoc)))
        goto exit;


    // Load synchronously
    if (FAILED(_hr = _pXMLDoc->put_async(VARIANT_FALSE)))
        goto exit;

    
    // Load xml document from the given URL or file path
    VariantInit(&varURL);
    varURL.vt = VT_BSTR;
    V_BSTR(&varURL) = _bstrManifestFilePath;
    if (FAILED(_hr = _pXMLDoc->load(varURL, &varb)))
        goto exit;

    if (_hr == S_FALSE)
    {
        // S_FALSE returned if the load fails
        _hr = E_FAIL;
        goto exit;
    }

    // Setup namespace filter
    VariantInit(&varNameSpaces);
    varNameSpaces.vt = VT_BSTR;
    V_BSTR(&varNameSpaces) = g_StringTable[NameSpace].bstr;
    if (FAILED(_hr = _pXMLDoc->setProperty(g_StringTable[SelNameSpaces].bstr, varNameSpaces)))
        goto exit;

    // Setup query type
    VariantInit(&varXPath);
    varXPath.vt = VT_BSTR;
    V_BSTR(&varXPath) = g_StringTable[XPath].bstr;
    if (FAILED(_hr = _pXMLDoc->setProperty(g_StringTable[SelLanguage].bstr, varXPath)))
        goto exit;

    _hr = S_OK;

exit:

    if (FAILED(_hr))
        SAFERELEASE(_pXMLDoc);

    return _hr;
}


// ---------------------------------------------------------------------------
// ParseAttribute
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::ParseAttribute(IXMLDOMNode *pIXMLDOMNode, 
    BSTR bstrAttributeName, LPWSTR *ppwzAttributeValue, LPDWORD pccAttributeValue)
{
    DWORD ccAttributeValue = 0;
    LPWSTR pwzAttributeValue = NULL;
    
    VARIANT varValue;
    IXMLDOMElement *pIXMLDOMElement = NULL;
            
    if (FAILED(_hr = pIXMLDOMNode->QueryInterface(IID_IXMLDOMElement, (void**) &pIXMLDOMElement)))
        goto exit;

    if ((_hr = pIXMLDOMElement->getAttribute(bstrAttributeName, 
        &varValue)) != S_OK)
        goto exit;
        
    // BUGBUG - what is meaning of NULL value here?
    if(varValue.vt != VT_NULL)
    {
         ccAttributeValue = ::SysStringLen(varValue.bstrVal) + 1;
         pwzAttributeValue = new WCHAR[ccAttributeValue];
         if (!pwzAttributeValue)
         {
            _hr = E_OUTOFMEMORY;
            goto exit;
         }
        memcpy(pwzAttributeValue, varValue.bstrVal, ccAttributeValue * sizeof(WCHAR));
        *ppwzAttributeValue = pwzAttributeValue;
        *pccAttributeValue = ccAttributeValue;
    }
    else
        _hr = S_FALSE;
exit:

    SAFERELEASE(pIXMLDOMElement);

    return _hr;
}


// ---------------------------------------------------------------------------
// InitGlobalCritSect
// ---------------------------------------------------------------------------
void CAssemblyManifestImport::InitGlobalCritSect()
{
    InitializeCriticalSection(&g_cs);
}


// ---------------------------------------------------------------------------
// ReportManifestType
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::ReportManifestType(DWORD *pdwType)
{
    LPWSTR pwzType = NULL;
    DWORD dwCC = 0;

    if (pdwType == NULL)
    {
        _hr = E_INVALIDARG;
        goto exit;
    }

    *pdwType = MANIFEST_TYPE_UNKNOWN;

    // ensure _pAssemblyId is initialized/cached
    if (!_pAssemblyId)
    {
        LPASSEMBLY_IDENTITY pAssemblyId = NULL;
        if ((_hr = GetAssemblyIdentity(&pAssemblyId)) != S_OK)
            goto exit;

        SAFERELEASE(pAssemblyId);
    }

    if ((_hr = _pAssemblyId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE, &pwzType, &dwCC)) == S_OK)
    {
        // note: case sensitive comparison
        if (wcscmp(pwzType, L"desktop") == 0)
            *pdwType = MANIFEST_TYPE_DESKTOP;
        else if (wcscmp(pwzType, L"subscription") == 0)
            *pdwType = MANIFEST_TYPE_SUBSCRIPTION;
        else if (wcscmp(pwzType, L"application") == 0)
            *pdwType = MANIFEST_TYPE_APPLICATION;
        // else MANIFEST_TYPE_UNKNOWN

        delete pwzType;
    }

exit:
    return _hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\proxy\stub_server_p.c ===
#include <server_p.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\proxy\stub_server_i.c ===
#include <server_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\server\cunknown.cpp ===
///////////////////////////////////////////////////////////
//
// CUnknown.cpp 
//
// Implementation of IUnknown Base class
//
#include "CUnknown.h"
#include "CFactory.h"
#include "Util.h"

static inline void trace(char* msg)
	{Util::Trace("CUnknown", msg, S_OK) ;} 
static inline void trace(char* msg, HRESULT hr)
	{Util::Trace("CUnknown", msg, hr) ;}

///////////////////////////////////////////////////////////
//
// Count of active objects
//   - Use to determine if we can unload the DLL.
//
long CUnknown::s_cActiveComponents = 0 ;


///////////////////////////////////////////////////////////
//
// Constructor
//
CUnknown::CUnknown(IUnknown* pUnknownOuter)
: m_cRef(1)
{
	// Set m_pUnknownOuter pointer.
	if (pUnknownOuter == NULL)
	{
	//	trace("Not aggregating; delegate to nondelegating IUnknown.") ;
		m_pUnknownOuter = reinterpret_cast<IUnknown*>
		                     (static_cast<INondelegatingUnknown*>
		                     (this)) ;  // notice cast
	}
	else
	{
		trace("Aggregating; delegate to outer IUnknown.") ;
		m_pUnknownOuter = pUnknownOuter ;
	}

	// Increment count of active components.
	::InterlockedIncrement(&s_cActiveComponents) ;
}

//
// Destructor
//
CUnknown::~CUnknown()
{
	::InterlockedDecrement(&s_cActiveComponents) ;

	// If this is an EXE server, shut it down.
	CFactory::CloseExe() ;
}

//
// FinalRelease - called by Release before it deletes the component
//
void CUnknown::FinalRelease()
{
	trace("Increment reference count for final release.") ;
	m_cRef = 1 ;
}

//
// Nondelegating IUnknown
//   - Override to handle custom interfaces.
//
HRESULT __stdcall 
	CUnknown::NondelegatingQueryInterface(const IID& iid, void** ppv)
{
	// CUnknown supports only IUnknown.
	if (iid == IID_IUnknown)
	{
		return FinishQI(reinterpret_cast<IUnknown*>
		                   (static_cast<INondelegatingUnknown*>(this)),
		                ppv) ;
	}	
	else
	{
		*ppv = NULL ;
		return E_NOINTERFACE ;
	}
}

//
// AddRef
//
ULONG __stdcall CUnknown::NondelegatingAddRef()
{
	return InterlockedIncrement(&m_cRef) ;
}

//
// Release
//
ULONG __stdcall CUnknown::NondelegatingRelease()
{
	InterlockedDecrement(&m_cRef) ;
	if (m_cRef == 0)
	{
		FinalRelease() ;
		delete this ;
		return 0 ;
	}
	return m_cRef ;
}

//
// FinishQI
//   - Helper function to simplify overriding
//     NondelegatingQueryInterface
//
HRESULT CUnknown::FinishQI(IUnknown* pI, void** ppv) 
{
	*ppv = pI ;
	pI->AddRef() ;
	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\server\cfactory.cpp ===
///////////////////////////////////////////////////////////
//
// CFactory
//   - Base class for reusing a single class factory for
//     all components in a DLL
//
#include <objbase.h>

#include "Registry.h"
#include "CFactory.h"

///////////////////////////////////////////////////////////
//
// Static variables
//
LONG CFactory::s_cServerLocks = 0 ;    // Count of locks

HMODULE CFactory::s_hModule = NULL ;   // DLL module handle

#ifdef _OUTPROC_SERVER_
DWORD CFactory::s_dwThreadID = 0 ;
#endif

///////////////////////////////////////////////////////////
//
// CFactory implementation
//

CFactory::CFactory(const CFactoryData* pFactoryData)
: m_cRef(1)
{
	m_pFactoryData = pFactoryData ;
}

//
// IUnknown implementation
//
HRESULT __stdcall CFactory::QueryInterface(REFIID iid, void** ppv)
{ 	
	IUnknown* pI ;
	if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
	{
		pI = this ; 
	}
	else
	{
	   *ppv = NULL;
		return E_NOINTERFACE;
	}
	pI->AddRef() ;
	*ppv = pI ;
	return S_OK;
}

ULONG __stdcall CFactory::AddRef() 
{ 
	return ::InterlockedIncrement(&m_cRef) ; 
}

ULONG __stdcall CFactory::Release() 
{
	if (::InterlockedDecrement(&m_cRef) == 0) 
	{
		delete this; 
		return 0 ;
	}   
	return m_cRef;
}

//
// IClassFactory implementation
//

HRESULT __stdcall CFactory::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv) 
{

	// Aggregate only if the requested IID is IID_IUnknown.
	if ((pUnknownOuter != NULL) && (iid != IID_IUnknown))
	{
		return CLASS_E_NOAGGREGATION ;
	}

	// Create the component.
	CUnknown* pNewComponent ;
	HRESULT hr = m_pFactoryData->CreateInstance(pUnknownOuter,
	                                            &pNewComponent) ;
	if (FAILED(hr))
	{
		return hr ;
	}

	// Initialize the component.
	hr = pNewComponent->Init();
	if (FAILED(hr))
	{
		// Initialization failed.  Release the component.
		pNewComponent->NondelegatingRelease() ;
		return hr ;
	}
	
	// Get the requested interface.
	hr = pNewComponent->NondelegatingQueryInterface(iid, ppv) ;

	// Release the reference held by the class factory.
	pNewComponent->NondelegatingRelease() ;
	return hr ;   
}

// LockServer
HRESULT __stdcall CFactory::LockServer(BOOL bLock) 
{
	if (bLock) 
	{
		::InterlockedIncrement(&s_cServerLocks) ; 
	}
	else
	{
		::InterlockedDecrement(&s_cServerLocks) ;
	}
	// If this is an out-of-proc server, check to see
	// whether we should shut down.
	CloseExe() ;  //@local

	return S_OK ;
}


///////////////////////////////////////////////////////////
//
// GetClassObject
//   - Create a class factory based on a CLSID.
//
HRESULT CFactory::GetClassObject(const CLSID& clsid, 
                                 const IID& iid, 
                                 void** ppv)
{
	if ((iid != IID_IUnknown) && (iid != IID_IClassFactory))
	{
		return E_NOINTERFACE ;
	}

	// Traverse the array of data looking for this class ID.
	for (int i = 0; i < g_cFactoryDataEntries; i++)
	{
		const CFactoryData* pData = &g_FactoryDataArray[i] ;
		if (pData->IsClassID(clsid))
		{

			// Found the ClassID in the array of components we can
			// create. So create a class factory for this component.
			// Pass the CFactoryData structure to the class factory
			// so that it knows what kind of components to create.
			*ppv = (IUnknown*) new CFactory(pData) ;
			if (*ppv == NULL)
			{
				return E_OUTOFMEMORY ;
			}
			return NOERROR ;
		}
	}
	return CLASS_E_CLASSNOTAVAILABLE ;
}

//
// Determine if the component can be unloaded.
//
HRESULT CFactory::CanUnloadNow()
{
	if (CUnknown::ActiveComponents() || IsLocked())
	{
		return S_FALSE ;
	}
	else
	{
		return S_OK ;
	}
}

//
// Register all components.
//
HRESULT CFactory::RegisterAll()
{
	for(int i = 0 ; i < g_cFactoryDataEntries ; i++)
	{
		RegisterServer(s_hModule,
		               *(g_FactoryDataArray[i].m_pCLSID),
		               g_FactoryDataArray[i].m_RegistryName,
		               g_FactoryDataArray[i].m_szVerIndProgID, 
		               g_FactoryDataArray[i].m_szProgID) ;
	}
	return S_OK ;
}   
	
HRESULT CFactory::UnregisterAll()
{
	for(int i = 0 ; i < g_cFactoryDataEntries ; i++)   
	{
		UnregisterServer(*(g_FactoryDataArray[i].m_pCLSID),
		                 g_FactoryDataArray[i].m_szVerIndProgID, 
		                 g_FactoryDataArray[i].m_szProgID) ;
	}
	return S_OK ;
}

#ifndef _OUTPROC_SERVER_
//////////////////////////////////////////////////////////
//
// Exported functions
//

STDAPI DllCanUnloadNow()
{
	return CFactory::CanUnloadNow() ; 
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv) 
{
	return CFactory::GetClassObject(clsid, iid, ppv) ;
}

//
// Server registration
//
STDAPI DllRegisterServer()
{
	return CFactory::RegisterAll() ;
}


STDAPI DllUnregisterServer()
{
	return CFactory::UnregisterAll() ;
}

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule, 
                      DWORD dwReason, 
                      void* lpReserved )
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		CFactory::s_hModule = (HMODULE) hModule ;
	}
	return TRUE ;
}

#else
//////////////////////////////////////////////////////////
//
// Out of process Server support
//

//
// Start factories
//
BOOL CFactory::StartFactories()
{
	CFactoryData* pStart = &g_FactoryDataArray[0] ;
	const CFactoryData* pEnd =
		&g_FactoryDataArray[g_cFactoryDataEntries - 1] ;

	for(CFactoryData* pData = pStart ; pData <= pEnd ; pData++)
	{
		// Initialize the class factory pointer and cookie.
		pData->m_pIClassFactory = NULL ;
		pData->m_dwRegister = NULL ;

		// Create the class factory for this component.
		IClassFactory* pIFactory = new CFactory(pData) ;

		// Register the class factory.
		DWORD dwRegister ;
		HRESULT hr = ::CoRegisterClassObject(
		                  *pData->m_pCLSID,
		                  static_cast<IUnknown*>(pIFactory),
		                  CLSCTX_LOCAL_SERVER,
		                  REGCLS_MULTIPLEUSE,
		                  // REGCLS_MULTI_SEPARATE, //@Multi
		                  &dwRegister) ;
		if (FAILED(hr))
		{
			pIFactory->Release() ;
			return FALSE ;
		}

		// Set the data.
		pData->m_pIClassFactory = pIFactory ;
		pData->m_dwRegister = dwRegister ;
	}
	return TRUE ;
}

//
// Stop factories
//
void CFactory::StopFactories()
{
	CFactoryData* pStart = &g_FactoryDataArray[0] ;
	const CFactoryData* pEnd =
		&g_FactoryDataArray[g_cFactoryDataEntries - 1] ;

	for (CFactoryData* pData = pStart ; pData <= pEnd ; pData++)
	{
		// Get the magic cookie and stop the factory from running.
		DWORD dwRegister = pData->m_dwRegister ;
		if (dwRegister != 0) 
		{
			::CoRevokeClassObject(dwRegister) ;
		}

		// Release the class factory.
		IClassFactory* pIFactory  = pData->m_pIClassFactory ;
		if (pIFactory != NULL) 
		{
			pIFactory->Release() ;
		}
	}
}

#endif //_OUTPROC_SERVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\server\guids.cpp ===
#define INITGUID
#include <guiddef.h>


DEFINE_GUID(IID_IAssemblyUpdate,
0x301b3415,0xf52d,0x4d40,0xbd,0xf7,0x31,0xd8,0x27,0x12,0xc2,0xdc);

DEFINE_GUID(LIBID_ServerLib,
0xd3011ee0,0xb997,0x11cf,0xa6,0xbb,0x00,0x80,0xc7,0xb2,0xd6,0x82);

DEFINE_GUID(CLSID_CAssemblyUpdate,
0x37b088b8,0x70ef,0x4ecf,0xb1,0x1e,0x1f,0x3f,0x4d,0x10,0x5f,0xdd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\server\cfactory.h ===
#ifndef __CFactory_h__
#define __CFactory_h__

#include "CUnknown.h"
///////////////////////////////////////////////////////////
 
// Forward reference
class CFactoryData ;

// Global data used by CFactory
extern CFactoryData g_FactoryDataArray[] ;
extern int g_cFactoryDataEntries ;

//////////////////////////////////////////////////////////
//
//  Component creation function
//
class CUnknown ;

typedef HRESULT (*FPCREATEINSTANCE)(IUnknown*, CUnknown**) ;

///////////////////////////////////////////////////////////
//
// CFactoryData
//   - Information CFactory needs to create a component
//     supported by the DLL
//
class CFactoryData
{
public:
	// The class ID for the component
	const CLSID* m_pCLSID ;

	// Pointer to the function that creates it
	FPCREATEINSTANCE CreateInstance ;

	// Name of the component to register in the registry
	const char* m_RegistryName ;

	// ProgID
	const char* m_szProgID ;

	// Version-independent ProgID
	const char* m_szVerIndProgID ;

	// Helper function for finding the class ID
	BOOL IsClassID(const CLSID& clsid) const
		{ return (*m_pCLSID == clsid) ;}

	//
	// Out of process server support
	//

	// Pointer to running class factory for this component
	IClassFactory* m_pIClassFactory ;

	// Magic cookie to identify running object
	DWORD m_dwRegister ;
} ;


///////////////////////////////////////////////////////////
//
// Class Factory
//
class CFactory : public IClassFactory
{
public:
	// IUnknown
	virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;
	virtual ULONG   __stdcall AddRef() ;
	virtual ULONG   __stdcall Release() ;
	
	// IClassFactory
	virtual HRESULT __stdcall CreateInstance(IUnknown* pUnknownOuter,
	                                         const IID& iid,
	                                         void** ppv) ;
	virtual HRESULT __stdcall LockServer(BOOL bLock) ; 

	// Constructor - Pass pointer to data of component to create.
	CFactory(const CFactoryData* pFactoryData) ;

	// Destructor
	~CFactory() { }

	//
	// Static FactoryData support functions
	//

	// DllGetClassObject support
	static HRESULT GetClassObject(const CLSID& clsid, 
	                              const IID& iid, 
	                              void** ppv) ;

	// Helper function for DllCanUnloadNow 
 	static BOOL IsLocked()
		{ return (s_cServerLocks > 0) ;}

	// Functions to [un]register all components
	static HRESULT RegisterAll() ;
	static HRESULT UnregisterAll() ;

	// Function to determine if component can be unloaded
	static HRESULT CanUnloadNow() ;


#ifdef _OUTPROC_SERVER_
	//
	// Out-of-process server support
	//

	static BOOL StartFactories() ;
	static void StopFactories() ;

	static DWORD s_dwThreadID ;

	// Shut down the application.
	static void CloseExe()
	{
		if (CanUnloadNow() == S_OK)
		{
			::PostThreadMessage(s_dwThreadID, WM_QUIT, 0, 0) ;
		}
	}
#else
	// CloseExe doesn't do anything if we are in process.
	static void CloseExe() { /*Empty*/ } 
#endif

public:
	// Reference Count
	LONG m_cRef ;

	// Pointer to information about class this factory creates
	const CFactoryData* m_pFactoryData ;

	// Count of locks
	static LONG s_cServerLocks ;   

	// Module handle
	static HMODULE s_hModule ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\server\outproc.cpp ===
#include <windows.h>
#include <stdlib.h>
#include <shlwapi.h>
#include <cstrings.h>
#include "CUnknown.h"
#include "CFactory.h"
#include "Resource.h"
#include <update.h>


///////////////////////////////////////////////////////////
//
// Outproc.cpp
//   - the component server
//
HWND g_hWndListBox = NULL ;

BOOL InitWindow(int nCmdShow) ;
extern "C" LONG APIENTRY MainWndProc(HWND hWnd,
                                     UINT message,
                                     UINT wParam,
                                     LONG lParam) ;


VOID CALLBACK MyTimerProc(
  HWND hwnd,         // handle to window
  UINT uMsg,         // WM_TIMER message
  UINT idEvent,  // timer identifier
  DWORD dwTime       // current system time
);

VOID InitializeSubscriptions();

//
// WinMain procedure
//
extern "C" int WINAPI WinMain(HINSTANCE hInstance, 
                              HINSTANCE hPrevInstance,
                              LPSTR lpCmdLine, 
                              int nCmdShow)
{
	// Controls whether UI is shown or not
	BOOL bUI = TRUE ;

	// If TRUE, don't loop.
	BOOL bExit = FALSE ;

    // DebugBreak();
    
	// Initialize the COM Library.
	HRESULT hr = CoInitialize(NULL) ;
	if (FAILED(hr))
	{
		return 0 ;
	}
   
   
	// Get Thread ID.
	CFactory::s_dwThreadID = ::GetCurrentThreadId() ;
	CFactory::s_hModule = hInstance ;

	// Read the command line.
	char szTokens[] = "-/" ;

	char* szToken = strtok(lpCmdLine, szTokens) ; 
	while (szToken != NULL)
	{
		if (strcmp(szToken, "UnregServer") == 0)
		{
			CFactory::UnregisterAll() ;
			// We are done, so exit.
			bExit = TRUE ;
			bUI = FALSE ;
		}
		else if (strcmp(szToken, "RegServer") == 0)
		{
			CFactory::RegisterAll() ;
			// We are done, so exit.
			bExit = TRUE ;
			bUI = FALSE ;
		}
		else if (strcmp(szToken, "Embedding") == 0)
		{
			// Don't display a window if we are embedded.
			bUI = FALSE ;
			break ;
		}
		szToken = strtok(NULL, szTokens) ;
	}

    nCmdShow = bUI? nCmdShow : SW_HIDE;
    if (!InitWindow(nCmdShow))
    {
        bExit = TRUE;
    }
    else
    {
        ::InterlockedIncrement(&CFactory::s_cServerLocks) ;
    }


/*
	// If the user started us, then show UI.
	if (bUI)
	{
		if (!InitWindow(nCmdShow))
		{
			// Exit since we can't show UI.
			bExit = TRUE ;
		}
		else
		{
			::InterlockedIncrement(&CFactory::s_cServerLocks) ;
		}
	}
*/
	if (!bExit)
	{
        // Initialize the subscription list and timers from registry.
        InitializeSubscriptions();
        
		// Register all of the class factories.
		CFactory::StartFactories() ;

		// Wait for shutdown.
		MSG msg ;
		while (::GetMessage(&msg, 0, 0, 0))
		{
			::DispatchMessage(&msg) ;
		}

		// Unregister the class factories.
		CFactory::StopFactories() ;
	}

	// Uninitialize the COM Library.
	CoUninitialize() ;
	return 0 ;
}


//
// Initialize window
//
BOOL InitWindow(int nCmdShow) 
{
	// Fill in window class structure with parameters
	// that describe the main window.
	WNDCLASS wcListview ;
	wcListview.style = 0 ;                     
	wcListview.lpfnWndProc = (WNDPROC)MainWndProc ; 
	wcListview.cbClsExtra = 0 ;              
	wcListview.cbWndExtra = 0 ;              
	wcListview.hInstance = CFactory::s_hModule ;
	wcListview.hIcon = ::LoadIcon(CFactory::s_hModule,
	                              MAKEINTRESOURCE(IDC_ICON)) ;
	wcListview.hCursor = ::LoadCursor(NULL, IDC_ARROW) ;
	wcListview.hbrBackground = (HBRUSH) ::GetStockObject(GRAY_BRUSH) ; 
	wcListview.lpszMenuName = NULL ;  
	wcListview.lpszClassName = L"MyServerWinClass" ;

	BOOL bResult = ::RegisterClass(&wcListview) ;
	if (!bResult)
	{
		return bResult ;
	}

	HWND hWndMain ;

	hWndMain = ::CreateWindow(
		L"MyServerWinClass",
		L"Assembly Update Server", 
		WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, CW_USEDEFAULT,
		CW_USEDEFAULT, CW_USEDEFAULT,
		NULL,               
		NULL,               
		CFactory::s_hModule,          
		NULL) ;

	// If window could not be created, return "failure".
	if (!hWndMain)
	{
		return FALSE ;
	}

	// Make the window visible; update its client area;
	// and return "success".
	::ShowWindow(hWndMain, nCmdShow) ;
	::UpdateWindow(hWndMain) ;
	return TRUE ;
}

//
// Main window procedure
//
extern "C" LONG APIENTRY MainWndProc(
	HWND hWnd,                // window handle
	UINT message,             // type of message
	UINT wParam,              // additional information
	LONG lParam)              // additional information
{
	DWORD dwStyle ;

	switch (message) 
	{
	case WM_CREATE:
		{
			// Get size of main window
			CREATESTRUCT* pcs = (CREATESTRUCT*) lParam ;

			// Create a listbox for output.
			g_hWndListBox = ::CreateWindow(
				L"LISTBOX",
				NULL, 
				WS_CHILD | WS_VISIBLE | LBS_USETABSTOPS
					| WS_VSCROLL | LBS_NOINTEGRALHEIGHT,
				0, 0, pcs->cx, pcs->cy,
				hWnd,               
				NULL,               
				CFactory::s_hModule,          
				NULL) ;
			if (g_hWndListBox  == NULL)
			{
				// Listbox not created.
				::MessageBox(NULL,
				             L"Listbox not created!",
				             NULL,
				             MB_OK) ;
				return -1 ;
			}
		}
		break ;

	case WM_SIZE:
		::MoveWindow(g_hWndListBox, 0, 0,
			LOWORD(lParam), HIWORD(lParam), TRUE) ;
		break;

	case WM_DESTROY:          // message: window being destroyed
		if (CFactory::CanUnloadNow() == S_OK)
		{
			// Only post the quit message, if there is
			// no one using the program.
			::PostQuitMessage(0) ;
		}
		break ;

	case WM_CLOSE:
		// Decrement the lock count.
		::InterlockedDecrement(&CFactory::s_cServerLocks) ;

		// The list box is going away.
		g_hWndListBox = NULL ;

		//Fall through 
	default:
		return (DefWindowProc(hWnd, message, wParam, lParam)) ;
	}
	return 0 ;
}


//BUGBUG - we always want a window so we can have WM_TIMER messages.
// and which enables us to call SetTimer below.
// however, we don't necessarily want to show the window as is currently necessary.
VOID InitializeSubscriptions()
{
    #define REG_KEY_FUSION_SETTINGS              TEXT("Software\\Microsoft\\Fusion\\Installer\\1.0.0.0\\Subscription")
    DWORD dwError = 0;

    HUSKEY hParentKey;
    HUSKEY hSubKey;

    WCHAR wzSubKey[MAX_PATH];
    DWORD nMilliseconds, cbDummy, dwType, dwHash, i = 0;
    WCHAR wzUrl[MAX_PATH];

    // Open registry entry
    dwError = SHRegCreateUSKey(REG_KEY_FUSION_SETTINGS, KEY_ALL_ACCESS, NULL, 
        &hParentKey, SHREGSET_FORCE_HKCU);

    while ((dwError = SHRegEnumUSKeyW(hParentKey, i++, wzSubKey, &(cbDummy = MAX_PATH), 
        SHREGENUM_HKCU)) == ERROR_SUCCESS)
    {
        CString sUrl;
        CString sSubKey;

        sSubKey.Assign(REG_KEY_FUSION_SETTINGS);
        sSubKey.Append(L"\\");
        sSubKey.Append(wzSubKey);

        //  Open subkey
        dwError = SHRegCreateUSKey(sSubKey._pwz, KEY_ALL_ACCESS, NULL, 
            &hSubKey, SHREGSET_FORCE_HKCU);

        // read url.
        dwError = SHRegQueryUSValue(hSubKey, L"Url", &(dwType = REG_SZ), 
            (LPVOID) wzUrl, &(cbDummy = MAX_PATH), FALSE, NULL, 0);

        // read polling interval
        dwError = SHRegQueryUSValue(hSubKey, L"PollingInterval", &(dwType = REG_DWORD), 
            (LPVOID) &nMilliseconds, &(cbDummy = sizeof(DWORD)), FALSE, NULL, 0);
      
        SHRegCloseUSKey(hSubKey);
        
        // Get url hash
        sUrl.Assign(wzUrl);
        sUrl.Get65599Hash(&dwHash, CString::CaseInsensitive);

        // BUGBUG - MyTimerProc needs to be global, just like the list box.
        // in fact, I need to consolidate stuff common to outproc and update
        SetTimer((HWND) g_hWndListBox, dwHash, nMilliseconds, MyTimerProc);

    }        

    SHRegCloseUSKey(hParentKey);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\server\registry.h ===
#ifndef __Registry_H__
#define __Registry_H__
//
// Registry.h
//   - Helper functions registering and unregistering a component.
//

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const char* szFriendlyName,
                       const char* szVerIndProgID,
                       const char* szProgID) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid,
                         const char* szVerIndProgID,
                         const char* szProgID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\server\registry.cpp ===
//
// Registry.cpp
//

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const char* pszPath,
                    const char* szSubkey,
                    const char* szValue) ;

// Convert a CLSID into a char string.
void CLSIDtochar(const CLSID& clsid, 
                 char* szCLSID,
                 int length) ;

// Determine if a particular subkey exists.
BOOL SubkeyExists(const char* pszPath,
                  const char* szSubkey) ;

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const char* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const char* szFriendlyName, // Friendly Name
                       const char* szVerIndProgID, // Programmatic
                       const char* szProgID)       //   IDs
{
	// Get server location.
	char szModule[512] ;
	DWORD dwResult =
		::GetModuleFileNameA(hModule, 
		                    szModule,
		                    sizeof(szModule)/sizeof(char)) ;
	assert(dwResult != 0) ;

	// Convert the CLSID into a char.
	char szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

	// Build the key CLSID\\{...}
	char szKey[64] ;
	strcpy(szKey, "CLSID\\") ;
	strcat(szKey, szCLSID) ;
  
	// Add the CLSID to the registry.
	setKeyAndValue(szKey, NULL, szFriendlyName) ;

	// Add the server filename subkey under the CLSID key.
#ifdef _OUTPROC_SERVER_
	setKeyAndValue(szKey, "LocalServer32", szModule) ;
#else
	setKeyAndValue(szKey, "InprocServer32", szModule) ;
#endif

	// Add the ProgID subkey under the CLSID key.
	setKeyAndValue(szKey, "ProgID", szProgID) ;

	// Add the version-independent ProgID subkey under CLSID key.
	setKeyAndValue(szKey, "VersionIndependentProgID",
	               szVerIndProgID) ;

	// Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szVerIndProgID, "CLSID", szCLSID) ;
	setKeyAndValue(szVerIndProgID, "CurVer", szProgID) ;

	// Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szProgID, "CLSID", szCLSID) ;

	return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid,         // Class ID
                      const char* szVerIndProgID, // Programmatic
                      const char* szProgID)       //   IDs
{
	// Convert the CLSID into a char.
	char szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

	// Build the key CLSID\\{...}
	char szKey[80] ;
	strcpy(szKey, "CLSID\\") ;
	strcat(szKey, szCLSID) ;

	// Check for a another server for this component.
#ifdef _OUTPROC_SERVER_
	if (SubkeyExists(szKey, "InprocServer32"))
#else
	if (SubkeyExists(szKey, "LocalServer32"))
#endif
	{
		// Delete only the path for this server.
#ifdef _OUTPROC_SERVER_
		strcat(szKey, "\\LocalServer32") ;
#else
		strcat(szKey, "\\InprocServer32") ;
#endif
		LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
		assert(lResult == ERROR_SUCCESS) ;
	}
	else
	{
		// Delete all related keys.
		// Delete the CLSID Key - CLSID\{...}
		LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
		assert((lResult == ERROR_SUCCESS) ||
		       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

		// Delete the version-independent ProgID Key.
		lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
		assert((lResult == ERROR_SUCCESS) ||
		       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

		// Delete the ProgID key.
		lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
		assert((lResult == ERROR_SUCCESS) ||
		       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
	}
	return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a char string.
void CLSIDtochar(const CLSID& clsid,
                 char* szCLSID,
                 int length)
{
	assert(length >= CLSID_STRING_SIZE) ;
	// Get CLSID
	LPOLESTR wszCLSID = NULL ;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
	assert(SUCCEEDED(hr)) ;

	// Covert from wide characters to non-wide.
	wcstombs(szCLSID, wszCLSID, length) ;

	// Free memory.
	CoTaskMemFree(wszCLSID) ;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const char* lpszKeyChild)  // Key to delete
{

	// Open the child.
	HKEY hKeyChild ;
	LONG lRes = RegOpenKeyExA(hKeyParent, lpszKeyChild, 0,
	                         KEY_ALL_ACCESS, &hKeyChild) ;
	if (lRes != ERROR_SUCCESS)
	{
		return lRes ;
	}

	// Enumerate all of the decendents of this child.
	FILETIME time ;
	char szBuffer[256] ;
	DWORD dwSize = 256 ;
	while (RegEnumKeyExA(hKeyChild, 0, szBuffer, &dwSize, NULL,
	                    NULL, NULL, &time) == S_OK)
	{
		// Delete the decendents of this child.
		lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
		if (lRes != ERROR_SUCCESS)
		{
			// Cleanup before exiting.
			RegCloseKey(hKeyChild) ;
			return lRes;
		}
		dwSize = 256 ;
	}

	// Close the child.
	RegCloseKey(hKeyChild) ;

	// Delete this child.
	return RegDeleteKeyA(hKeyParent, lpszKeyChild) ;

    return 0;
}

//
// Determine if a particular subkey exists.
//
BOOL SubkeyExists(const char* pszPath,    // Path of key to check
                  const char* szSubkey)   // Key to check
{

	HKEY hKey ;
	char szKeyBuf[80] ;

	// Copy keyname into buffer.
	strcpy(szKeyBuf, pszPath) ;

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
		strcat(szKeyBuf, "\\") ;
		strcat(szKeyBuf, szSubkey ) ;
	}

	// Determine if key exists by trying to open it.
	LONG lResult = ::RegOpenKeyExA(HKEY_CLASSES_ROOT, 
	                              szKeyBuf,
	                              0,
	                              KEY_ALL_ACCESS,
	                              &hKey) ;
	if (lResult == ERROR_SUCCESS)
	{
		RegCloseKey(hKey) ;
		return TRUE ;
	}
	return FALSE ;

return TRUE;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const char* szKey,
                    const char* szSubkey,
                    const char* szValue)
{

	HKEY hKey;
	char szKeyBuf[1024] ;

	// Copy keyname into buffer.
	strcpy(szKeyBuf, szKey) ;

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
		strcat(szKeyBuf, "\\") ;
		strcat(szKeyBuf, szSubkey ) ;
	}

	// Create and open key and subkey.
	long lResult = RegCreateKeyExA(HKEY_CLASSES_ROOT ,
	                              szKeyBuf, 
	                              0, NULL, REG_OPTION_NON_VOLATILE,
	                              KEY_ALL_ACCESS, NULL, 
	                              &hKey, NULL) ;
	if (lResult != ERROR_SUCCESS)
	{
		return FALSE ;
	}

	// Set the Value.
	if (szValue != NULL)
	{
		RegSetValueExA(hKey, NULL, 0, REG_SZ, 
		              (BYTE *)szValue, 
		              strlen(szValue)+1) ;
	}

	RegCloseKey(hKey) ;
	return TRUE ;

return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\server\cunknown.h ===
#ifndef __CUnknown_h__
#define __CUnknown_h__

#include <objbase.h>

///////////////////////////////////////////////////////////
//
// Nondelegating IUnknown interface
//   - Nondelegating version of IUnknown
//
interface INondelegatingUnknown
{
	virtual HRESULT __stdcall 
		NondelegatingQueryInterface(const IID& iid, void** ppv) = 0 ;
	virtual ULONG   __stdcall NondelegatingAddRef() = 0 ;
	virtual ULONG   __stdcall NondelegatingRelease() = 0 ;
} ;


///////////////////////////////////////////////////////////
//
// Declaration of CUnknown 
//   - Base class for implementing IUnknown
//

class CUnknown : public INondelegatingUnknown
{
public:
	// Nondelegating IUnknown implementation
	virtual HRESULT __stdcall NondelegatingQueryInterface(const IID&,
	                                                      void**) ;
	virtual ULONG   __stdcall NondelegatingAddRef() ;
	virtual ULONG   __stdcall NondelegatingRelease() ;

	// Constructor
	CUnknown(IUnknown* pUnknownOuter) ;

	// Destructor
	virtual ~CUnknown() ;

	// Initialization (especially for aggregates)
	virtual HRESULT Init() { return S_OK ;}

	// Notification to derived classes that we are releasing
	virtual void FinalRelease() ;

	// Count of currently active components
	static long ActiveComponents() 
		{ return s_cActiveComponents ;}
	
	// Helper function
	HRESULT FinishQI(IUnknown* pI, void** ppv) ;

protected:
	// Support for delegation
	IUnknown* GetOuterUnknown() const
		{ return m_pUnknownOuter ;}

private:
	// Reference count for this object
	long m_cRef ;
	
	// Pointer to (external) outer IUnknown
	IUnknown* m_pUnknownOuter ;

	// Count of all active instances
	static long s_cActiveComponents ; 
} ;


///////////////////////////////////////////////////////////
//
// Delegating IUnknown
//   - Delegates to the nondelegating IUnknown, or to the
//     outer IUnknown if the component is aggregated.
//
#define DECLARE_IUNKNOWN		                             \
	virtual HRESULT __stdcall	                             \
		QueryInterface(const IID& iid, void** ppv)           \
	{	                                                     \
		return GetOuterUnknown()->QueryInterface(iid,ppv) ;  \
	} ;	                                                     \
	virtual ULONG __stdcall AddRef()	                     \
	{	                                                     \
		return GetOuterUnknown()->AddRef() ;                 \
	} ;	                                                     \
	virtual ULONG __stdcall Release()	                     \
	{	                                                     \
		return GetOuterUnknown()->Release() ;                \
	} ;


///////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\server\resource.h ===
#define IDI_ICON                        101
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\includes\debbase.h ===
/*
 * debbase.h - Base debug macros and their retail translations.
 */


// BUGBUG: this should be fixed/beef up

/* Macros
 *********/

/* debug assertion macro */

/*
 * ASSERT() may only be used as a statement, not as an expression.
 *
 * E.g.,
 *
 * ASSERT(pszRest);
 */

#ifdef DEBUG

#define ASSERT(exp) \
   if (exp) \
      ; \
   else \
      ERROR_OUT(("assertion failed '%s'", (LPCWSTR)#exp))

#else

#define ASSERT(exp)

#endif   /* DEBUG */

/* debug evaluation macro */

/*
 * EVAL() may only be used as a logical expression.
 *
 * E.g.,
 *
 * if (EVAL(exp))
 *    bResult = TRUE;
 */

/*#ifdef DEBUG

#define EVAL(exp) \
   ((exp) || \
    (ERROR_OUT(("evaluation failed '%s'", (LPCWSTR)#exp)), 0))

#else
*/
#define EVAL(exp) \
   ((exp) != 0)

/*#endif*/   /* DEBUG */

/* handle validation macros */

extern BOOL IsValidHWND(HWND);

#ifdef DEBUG

extern BOOL IsValidHANDLE(HANDLE);
extern BOOL IsValidHEVENT(HANDLE);
extern BOOL IsValidHFILE(HANDLE);
extern BOOL IsValidHGLOBAL(HGLOBAL);
extern BOOL IsValidHMENU(HMENU);
extern BOOL IsValidHICON(HICON);
extern BOOL IsValidHINSTANCE(HINSTANCE);
extern BOOL IsValidHKEY(HKEY);
extern BOOL IsValidHMODULE(HMODULE);
extern BOOL IsValidHPROCESS(HANDLE);
extern BOOL IsValidHTEMPLATEFILE(HANDLE);

#endif

#ifdef DEBUG

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (ERROR_OUT(("invalid H" #type " - %#08lx", (hnd))), FALSE))

#else

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\server\server.cpp ===
#include "CFactory.h"
#include <cstrings.h>
#include "server.h"
//#include "Iface.h"
#include "update.h"

///////////////////////////////////////////////////////////
//
// Server.cpp
//
// This file contains the component server code.
// The FactoryDataArray contains the components that 
// can be served.
//

// Each component derived from CUnknown defines a static function
// for creating the component with the following prototype. 
// HRESULT CreateInstance(IUnknown* pUnknownOuter, 
//                        CUnknown** ppNewComponent) ;
// This function is used to create the component.
//

//
// The following array contains the data used by CFactory
// to create components. Each element in the array contains
// the CLSID, the pointer to the creation function, and the name
// of the component to place in the Registry.
//
CFactoryData g_FactoryDataArray[] =
{
	{&CLSID_CAssemblyUpdate, CAssemblyUpdate::CreateInstance, 
		"Assembly Update Service",
		"Assembly.Update.Service.4.1",
		"Assembly.UpdateService.4",
		NULL, 0}

} ;
int g_cFactoryDataEntries
	= sizeof(g_FactoryDataArray) / sizeof(CFactoryData) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\server\util.h ===
#ifndef __Util_h__
#define __Util_h__

//
// Util.h - Shared utilities
//
#include <strstrea.h>

namespace Util
{
	void Trace(char* szLabel, char* szText, HRESULT hr) ;

	void ErrorMessage(HRESULT hr) ;
} ;


//
// Overloaded insertion operator for converting from
// Unicode (wchar_t) to non-Unicode.
//
ostream& operator<< ( ostream& os, const wchar_t* wsz ) ;

#endif // __Util_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\server\util.cpp ===
//
//
// util.cpp - Common utilities for printing out messages
//
//
#include <objbase.h>
#include <stdio.h>    //sprintf
#include <stdlib.h>
#include <assert.h>
// #include <tchar.h>

#include "util.h"

#ifdef _OUTPROC_SERVER_ 
// We are building a local or remote server.
	// Listbox window handle
	extern HWND g_hWndListBox ;

	static inline void output(const char* sz)
	{
		::SendMessageA(g_hWndListBox, LB_ADDSTRING, 0, (LPARAM)sz) ;
	}

#else
// We are building an in-proc server.
#include <iostream.h>
	static inline void output(const char* sz)
	{
		cout << sz << endl ;
	}
#endif //_OUTPROC_SERVER_

//
// Utilities
//
namespace Util
{

//
// Print out a message with a label.
//
void Trace(char* szLabel, char* szText, HRESULT hr)
{
	char buf[256] ;
	sprintf(buf, "%s: \t%s", szLabel, szText) ;
	output(buf) ;

	if (FAILED(hr))
	{
		ErrorMessage(hr) ;
	}
}

//
// Print out the COM/OLE error string for an HRESULT.
//
void ErrorMessage(HRESULT hr)
{
	void* pMsgBuf ;
 
	::FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL,
		hr,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR)&pMsgBuf,
		0,
		NULL 
	) ;

	char buf[256] ;
	sprintf(buf, "Error (%x): %s", hr, (char*)pMsgBuf) ;
	output(buf) ;
		
	// Free the buffer.
	LocalFree(pMsgBuf) ;
}

} ; // End Namespace Util


//
// Overloaded ostream insertion operator
// Converts from wchar_t to char
//
ostream& operator<< ( ostream& os, const wchar_t* wsz )
{
	// Length of incoming string
	int iLength = wcslen(wsz)+1 ;

	// Allocate buffer for converted string.
	char* psz = new char[iLength] ;

	// Convert from wchar_t to char.
	wcstombs(psz, wsz, iLength) ;

	// Send it out.
	os << psz ;

	// cleanup
	delete [] psz ;
	return os ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\dll\shelldll.cpp ===
//
// Copyright (c) 2001 Microsoft Corporation
//
//

#include "shcut.h"
#include "mfilter.h"

HINSTANCE g_DllInstance = NULL;
LONG      g_cRef=0;

//----------------------------------------------------------------------------

BOOL WINAPI DllMain( HINSTANCE hInst, DWORD dwReason, LPVOID pvReserved )
{
    BOOL    ret = TRUE;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        // remember the instance
        g_DllInstance = hInst;
        DisableThreadLibraryCalls(hInst);
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return ret;
}

//----------------------------------------------------------------------------

STDAPI DllRegisterServer(void)
{
	// BUGBUG: should implement the registerserver
	return S_OK;
}


STDAPI DllUnregisterServer(void)
{
	// BUGBUG: should implement the unregisterserver
	return S_OK;
}


// ----------------------------------------------------------------------------
// DllAddRef
// ----------------------------------------------------------------------------

ULONG DllAddRef(void)
{
    return (ULONG)InterlockedIncrement(&g_cRef);
}

// ----------------------------------------------------------------------------
// DllRelease
// ----------------------------------------------------------------------------

ULONG DllRelease(void)
{
    return (ULONG)InterlockedDecrement(&g_cRef);
}

// ----------------------------------------------------------------------------

STDAPI
DllCanUnloadNow()
{
    return g_cRef > 0 ? S_FALSE : S_OK;
}

// ----------------------------------------------------------------------------

HRESULT 
GetShortcutClassObject(REFIID iid, void** ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

	CFusionShortcutClassFactory *pFusionShortcutClassFactory = new CFusionShortcutClassFactory();
	if (pFusionShortcutClassFactory != NULL)
	{
	    hr = pFusionShortcutClassFactory->QueryInterface(iid, ppv); 
	    pFusionShortcutClassFactory->Release(); 
	}

    return hr;
}

// ----------------------------------------------------------------------------

HRESULT 
GetMimeFilterClassObject(REFIID iid, void** ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

	CFusionMimeFilterClassFactory *pFusionMimeFilterClassFactory = new CFusionMimeFilterClassFactory();
	if (pFusionMimeFilterClassFactory != NULL)
	{
	    hr = pFusionMimeFilterClassFactory->QueryInterface(iid, ppv); 
	    pFusionMimeFilterClassFactory->Release(); 
	}

    return hr;
}

// ----------------------------------------------------------------------------
  
STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID *ppv)
{
    HRESULT hr = S_OK;

    if (clsid == CLSID_FusionShortcut)
    {
        hr = GetShortcutClassObject(iid, ppv);
    }
    else if (clsid == CLSID_FusionMimeFilter)
    {
        hr = GetMimeFilterClassObject(iid, ppv);
    }
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\includes\refcount.hpp ===
/*
 * refcount.hpp - RefCount class description.
 */

#pragma once

#include <objbase.h>
#include <windows.h>

/* Types
 ********/

/* Classes
 **********/

class RefCount
{
private:
   ULONG m_ulcRef;

public:
   RefCount(void);
   // Virtual destructor defers to destructor of derived class.
   virtual ~RefCount(void);

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
};
DECLARE_STANDARD_TYPES(RefCount);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\server\update.h ===
//
// update.cpp - assembly update
//
#include "server.h"
//#include "Iface.h"
#include "CUnknown.h" // Base class for IUnknown

///////////////////////////////////////////////////////////
//
// Component AssemblyUpdate
//
class CAssemblyUpdate : public CUnknown,
           public IAssemblyUpdate
{
public:	
	// Creation
	static HRESULT CreateInstance(IUnknown* pUnknownOuter,
	                              CUnknown** ppNewComponent) ;

private:
	// Declare the delegating IUnknown.
	DECLARE_IUNKNOWN

	// IUnknown
	virtual HRESULT __stdcall 
		NondelegatingQueryInterface( const IID& iid, void** ppv) ;			
	
	// Interface IAssemblyUpdate
	virtual HRESULT __stdcall RegisterAssemblySubscription(LPWSTR pwzDisplayName, 
		LPWSTR pwzUrl, DWORD nMilliseconds) ; 

	virtual HRESULT __stdcall UnRegisterAssemblySubscription(LPWSTR pwzDisplayName);

	// Initialization
 	virtual HRESULT Init() ;

	// Notify derived classes that we are releasing.
	virtual void FinalRelease() ;

	// Constructor
	CAssemblyUpdate(IUnknown* pUnknownOuter) ;

	// Destructor
	~CAssemblyUpdate() ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\service\server\update.cpp ===
//
// update.cpp -   assembly update
//
#include <windows.h>
#include <objbase.h>
#include <cstrings.h>
#include <fusenet.h>
#include <shlwapi.h>

//#include "Iface.h"
#include "server.h"
#include "Util.h"
#include "CUnknown.h" // Base class for IUnknown
#include "update.h"

HWND myhwnd;
extern HWND g_hWndListBox;

static inline void trace(char* msg)
	{ Util::Trace("CAssemblyUpdate", msg, S_OK) ;}
static inline void trace(char* msg, HRESULT hr)
	{ Util::Trace("CAssemblyUpdate", msg, hr) ;}




VOID CALLBACK MyTimerProc(
  HWND hwnd,         // handle to window
  UINT uMsg,         // WM_TIMER message
  UINT idEvent,  // timer identifier
  DWORD dwTime       // current system time
)
{
    #define REG_KEY_FUSION_SETTINGS              TEXT("Software\\Microsoft\\Fusion\\Installer\\1.0.0.0\\Subscription")
    DWORD dwError = 0;

    HUSKEY hParentKey;
    HUSKEY hSubKey;

    WCHAR wzSubKey[MAX_PATH];
    DWORD nMilliseconds, cbDummy, dwType, dwHash, i = 0;
    WCHAR wzUrl[MAX_PATH];

    // Open registry entry
    dwError = SHRegCreateUSKey(REG_KEY_FUSION_SETTINGS, KEY_ALL_ACCESS, NULL, 
        &hParentKey, SHREGSET_FORCE_HKCU);

    trace("Checking for update");

    while ((dwError = SHRegEnumUSKeyW(hParentKey, i++, wzSubKey, &(cbDummy = MAX_PATH), 
        SHREGENUM_HKCU)) == ERROR_SUCCESS)
    {
        CString sUrl;
        CString sSubKey;

        sSubKey.Assign(REG_KEY_FUSION_SETTINGS);
        sSubKey.Append(L"\\");
        sSubKey.Append(wzSubKey);

        //  Open subkey
        dwError = SHRegCreateUSKey(sSubKey._pwz, KEY_ALL_ACCESS, NULL, 
            &hSubKey, SHREGSET_FORCE_HKCU);

        // read url.
        dwError = SHRegQueryUSValue(hSubKey, L"Url", &(dwType = REG_SZ), 
            (LPVOID) wzUrl, &(cbDummy = MAX_PATH), FALSE, NULL, 0);

        // read polling interval
        dwError = SHRegQueryUSValue(hSubKey, L"PollingInterval", &(dwType = REG_DWORD), 
            (LPVOID) &nMilliseconds, &(cbDummy = sizeof(DWORD)), FALSE, NULL, 0);
      
        SHRegCloseUSKey(hSubKey);
        
        // Get url hash
        sUrl.Assign(wzUrl);
        sUrl.Get65599Hash(&dwHash, CString::CaseInsensitive);

        if (dwHash == idEvent)
        {
            ostrstream sout;
            sout << "Display Name: " << wzSubKey << ends;
            trace(sout.str());
            
            ostrstream sout1;
            sout1 << "Url: " << wzUrl << ends;
            trace(sout1.str());

            HRESULT hr;
            IAssemblyDownload *pAssemblyDownload = NULL;
            hr = CreateAssemblyDownload(&pAssemblyDownload);
            hr = pAssemblyDownload->DownloadManifestAndDependencies(wzUrl, NULL, DOWNLOAD_FLAGS_NO_NOTIFICATION);

            // And theoretically we can release this.
            pAssemblyDownload->Release();          
        }

    }        

    SHRegCloseUSKey(hParentKey);

}


///////////////////////////////////////////////////////////
//
// Interface IAssemblyUpdate
//
HRESULT __stdcall CAssemblyUpdate::RegisterAssemblySubscription(LPWSTR pwzDisplayName, 
    LPWSTR pwzUrl, DWORD nMilliseconds)
{ 
    #define REG_KEY_FUSION_SETTINGS              TEXT("Software\\Microsoft\\Fusion\\Installer\\1.0.0.0\\Subscription")
    HUSKEY hRegKey;
	ostrstream sout ;
    sout << "RegisterAssemblySubscription called" << ends;
	trace(sout.str()) ;

    DWORD dwHash = 0;
    
    // Get hash of url
    // BUGBUG - this could just be a global counter, right?
    CString sUrl;
    sUrl.Assign(pwzUrl);
    sUrl.Get65599Hash(&dwHash, CString::CaseInsensitive);
    
    // Form full regkey path.
    CString sSubscription;
    sSubscription.Assign(REG_KEY_FUSION_SETTINGS);
    sSubscription.Append(L"\\");
    sSubscription.Append(pwzDisplayName);
    
    // Create registry entry
    SHRegCreateUSKey(sSubscription._pwz, KEY_ALL_ACCESS, NULL, 
        &hRegKey, SHREGSET_FORCE_HKCU);

    // Write url
    SHRegWriteUSValue(hRegKey, L"Url", REG_SZ, (LPVOID) sUrl._pwz,
        (sUrl._cc + 1) * sizeof(WCHAR), SHREGSET_FORCE_HKCU);

    // Write polling interval
    SHRegWriteUSValue(hRegKey, L"PollingInterval", REG_DWORD, (LPVOID) &nMilliseconds,
        sizeof(DWORD), SHREGSET_FORCE_HKCU);

    SHRegCloseUSKey(hRegKey);

    SetTimer((HWND) g_hWndListBox, dwHash, nMilliseconds, MyTimerProc);

	return S_OK ;

}

HRESULT __stdcall CAssemblyUpdate::UnRegisterAssemblySubscription(LPWSTR pwzDisplayName)
{ 
	return S_OK ;
}



//
// Constructor
//
CAssemblyUpdate::CAssemblyUpdate(IUnknown* pUnknownOuter)
: CUnknown(pUnknownOuter)
{
	// Empty
}

//
// Destructor
//
CAssemblyUpdate::~CAssemblyUpdate()
{
//	trace("Destroy self.") ;
}

//
// NondelegatingQueryInterface implementation
//
HRESULT __stdcall CAssemblyUpdate::NondelegatingQueryInterface(const IID& iid,
                                                  void** ppv)
{ 	
	if (iid == IID_IAssemblyUpdate)
	{
		return FinishQI((IAssemblyUpdate*)this, ppv) ;
	}
	else if (iid == IID_IMarshal)
	{
//		trace("The COM Library asked for IMarshal.") ;
		// We don't implement IMarshal.
		return CUnknown::NondelegatingQueryInterface(iid, ppv) ;
	}
	else
	{
		return CUnknown::NondelegatingQueryInterface(iid, ppv) ;
	}
}


//
// Initialize the component by creating the contained component.
//
HRESULT CAssemblyUpdate::Init()
{

	//trace("Initing Component 4, which is not aggregated.") ;
	return S_OK ;
}

//
// FinalRelease - called by Release before it deletes the component
//
void CAssemblyUpdate::FinalRelease()
{
    // Nothing to do.
}



///////////////////////////////////////////////////////////
//
// Creation function used by CFactory
//
HRESULT CAssemblyUpdate::CreateInstance(IUnknown* pUnknownOuter,
                           CUnknown** ppNewComponent)
{
	if (pUnknownOuter != NULL)
	{
		return CLASS_E_NOAGGREGATION ;
	}
	
	*ppNewComponent = new CAssemblyUpdate(pUnknownOuter) ;
	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\host\host.cpp ===
#include <windows.h>
#include <objbase.h>
#include "fusenet.h"

#define INITGUID
#include <guiddef.h>

// Update services
#include "server.h"
DEFINE_GUID(IID_IAssemblyUpdate,
    0x301b3415,0xf52d,0x4d40,0xbd,0xf7,0x31,0xd8,0x27,0x12,0xc2,0xdc);

DEFINE_GUID(CLSID_CAssemblyUpdate,
    0x37b088b8,0x70ef,0x4ecf,0xb1,0x1e,0x1f,0x3f,0x4d,0x10,0x5f,0xdd);

// CLR Hosting
#import "..\..\clrhost\asmexec.tlb" raw_interfaces_only
using namespace asmexec;


// note: a bit hacky to use something that's implemented under shell\shortcut\util.cpp
#include "project.hpp"  // for extern HRESULT GetLastWin32Error(); only

#define WZ_TYPE_DOTNET  L".NetAssembly"
#define WZ_TYPE_WIN32   L"win32Executable"
#define WZ_TYPE_AVALON  L"avalon"
#define TYPE_DOTNET     1
#define TYPE_WIN32      2
#define TYPE_AVALON     3

IInternetSecurityManager*   g_pSecurityMgr = NULL;


#include <stdio.h> // for _snwprintf


// debug msg stuff
void
Msg(LPWSTR pwz)
{
    MessageBox(NULL, pwz, L"Fusion Manifest Host", 0);
}

// ----------------------------------------------------------------------------

HRESULT
RunCommand(LPWSTR wzCmdLine, LPCWSTR wzCurrentDir, BOOL fWait)
{
    HRESULT hr = S_OK;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));

    si.cb = sizeof(si);

    // wzCurrentDir: The string must be a full path and file name that includes a drive letter; or NULL
    if(!CreateProcess(NULL, wzCmdLine, NULL, NULL, TRUE, 0, NULL, wzCurrentDir, &si, &pi))
    {
        hr = GetLastWin32Error();
        goto exit;
    }

    if (fWait)
    {
        if(WaitForSingleObject(pi.hProcess, 180000L) == WAIT_TIMEOUT)
        {
            hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
            goto exit;
        }
    }

exit:
    if(pi.hProcess) CloseHandle(pi.hProcess);
    if(pi.hThread) CloseHandle(pi.hThread);

    return hr;
}

// ----------------------------------------------------------------------------

HRESULT
CopyToUSStartMenu(LPCWSTR pwzFilePath, LPCWSTR pwzRealFilename, BOOL bOverwrite)
{
	HRESULT hr = S_OK;
	WCHAR wzPath[MAX_PATH];

    // BUGBUG?: use SHGetFolderPath()
	if(GetEnvironmentVariable(L"USERPROFILE", wzPath, MAX_PATH-1) == 0)
	{
		hr = CO_E_PATHTOOLONG;
		goto exit;
	}

	if (!PathAppend(wzPath, L"Start Menu\\Programs\\"))
	{
		hr = E_FAIL;
		goto exit;
	}

	if (!PathAppend(wzPath, pwzRealFilename))
	{
		hr = E_FAIL;
		goto exit;
	}

	if (CopyFile(pwzFilePath, wzPath, !bOverwrite) == 0)
	{
		hr = GetLastWin32Error();
		//goto exit;
	}

exit:
	return hr;
}

// ----------------------------------------------------------------------------

// BUGBUG: should this be in-sync with what server does to register update?
#define REG_KEY_FUSION_SETTINGS       L"Software\\Microsoft\\Fusion\\Installer\\1.0.0.0\\Policy"

#define REG_VAL_INTRANET_DISALLOW     L"Download from Intranet Disallowed"
#define REG_VAL_TRUSTED_DISALLOW     L"Download from Trusted Zone Disallowed"
#define REG_VAL_INTERNET_DISALLOW     L"Download from Internet Disallowed"
#define REG_VAL_UNTRUSTED_DISALLOW   L"Download from Untrusted Zone Disallowed"


// BUGBUG hacky should move this from extricon.cpp to util.cpp and declare in project.hpp
extern LONG GetRegKeyValue(HKEY hkeyParent, PCWSTR pcwzSubKey,
                                   PCWSTR pcwzValue, PDWORD pdwValueType,
                                   PBYTE pbyteBuf, PDWORD pdwcbBufLen);

// return: S_OK for yes/ok, E_ABORT for no/abort
// default is allow all
HRESULT
CheckZonePolicy(LPWSTR pwzURL)
{
    HRESULT hr = S_OK;
    DWORD dwZone = 0;
    DWORD dwType = 0;
    DWORD dwValue = -1;
    DWORD dwSize = sizeof(dwValue);

    if (g_pSecurityMgr == NULL)
    {
        // lazy init.
    
   hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
                            IID_IInternetSecurityManager, (void**)&g_pSecurityMgr);
        if (FAILED(hr))
        {
            g_pSecurityMgr = NULL;
            goto exit;
        }
    }

    if (SUCCEEDED(hr = g_pSecurityMgr->MapUrlToZone(pwzURL, &dwZone, 0)))
    {
        // BUGBUG: hack up code here... not much error checking...
        switch(dwZone)
        {
            case 1: // Intranet Zone
                    // Get registry entry
                    if (GetRegKeyValue(HKEY_CURRENT_USER, 
                        REG_KEY_FUSION_SETTINGS, REG_VAL_INTRANET_DISALLOW,
                        &dwType, (PBYTE) &dwValue, &dwSize)
                        == ERROR_SUCCESS)
                    {
                        if (dwValue == 1)
                        {
                            hr = E_ABORT;
                            Msg(L"Zone policy: Download from Intranet is disallowed. Aborting...");
                        }
                    }
                    break;
            case 2: // Trusted Zone
                    // Get registry entry
                    if (GetRegKeyValue(HKEY_CURRENT_USER, 
                        REG_KEY_FUSION_SETTINGS, REG_VAL_TRUSTED_DISALLOW,
                        &dwType, (PBYTE) &dwValue, &dwSize)
                        == ERROR_SUCCESS)
                    {
                        if (dwValue == 1)
                        {
                            hr = E_ABORT;
                            Msg(L"Zone policy: Download from Trusted Zone is disallowed. Aborting...");
                        }
                    }
                    break;
            case 3: // Internet Zone
                    // Get registry entry
                    if (GetRegKeyValue(HKEY_CURRENT_USER, 
                        REG_KEY_FUSION_SETTINGS, REG_VAL_INTERNET_DISALLOW,
                        &dwType, (PBYTE) &dwValue, &dwSize)
                        == ERROR_SUCCESS)
                    {
                        if (dwValue == 1)
                        {
                            hr = E_ABORT;
                            Msg(L"Zone policy: Download from Internet is disallowed. Aborting...");
                        }
                    }
                    break;
            case 4: // Untrusted Zone
                    // Get registry entry
                    if (GetRegKeyValue(HKEY_CURRENT_USER, 
                        REG_KEY_FUSION_SETTINGS, REG_VAL_UNTRUSTED_DISALLOW,
                        &dwType, (PBYTE) &dwValue, &dwSize)
                        == ERROR_SUCCESS)
                    {
                        if (dwValue == 1)
                        {
                            hr = E_ABORT;
                            Msg(L"Zone policy: Download from Untrusted Zone is disallowed. Aborting...");
                        }
                    }
                    break;
            case 0: //Local machine
            default:
                    break;
        }
    }
    
exit:
    return hr;
}

// ----------------------------------------------------------------------------

// note: parameter pwzCodebase can be NULL
HRESULT
ResolveAndInstall(LPASSEMBLY_IDENTITY pAsmId, LPWSTR pwzCodebase, LPWSTR *ppwzManifestFileDir, LPWSTR *ppwzManifestFilePath, BOOL* pbIs1stTimeInstall)
{
    HRESULT hr = S_OK;
    LPASSEMBLY_CACHE_IMPORT pCacheImport = NULL;
    DWORD dwCC = 0;

    *pbIs1stTimeInstall = FALSE;

    // look into the cache

    if (FAILED(hr=CreateAssemblyCacheImport(&pCacheImport, pAsmId, CACHEIMP_CREATE_RESOLVE_REF)))
        goto exit;

    // hr from CreateAssemblyCacheImport() above
    
    // Case 1, cached copy exist
    // hr == S_OK

    // Case 2, cached copy (of the referenced version) not exist
    if (hr == S_FALSE)
    {
        LPASSEMBLY_DOWNLOAD pAsmDownload = NULL;

        // BUGBUG?: what if it is not a partial ref but there's actually another version installed?

        if (pwzCodebase == NULL)
        {
            Msg(L"No completed cached version of this application found and this manifest cannot be used to initiate an install. Cannot continue.");
            hr = E_FAIL;
            goto exit;
        }

        *pbIs1stTimeInstall = TRUE;

        // check policy before download
        if (FAILED(hr=CheckZonePolicy(pwzCodebase)))
            goto exit;

    	if (FAILED(hr=CreateAssemblyDownload(&pAsmDownload)))
    	    goto exit;

    	//BUGBUG: need ref def matching checks for desktop->subscription->app manifests' ids

        // (synchronous & ui) download from codebase
        hr=pAsmDownload->DownloadManifestAndDependencies(pwzCodebase, NULL, DOWNLOAD_FLAGS_PROGRESS_UI);
        pAsmDownload->Release();

        // hr from DownloadManifestAndDependencies() above
        if (FAILED(hr))
        {
            if (hr == E_ABORT)
                Msg(L"File download canceled.");                
            else
                Msg(L"Error in file download. Cannot continue.");

            goto exit;
        }

        // another version might have been completed at this time...
        // get cache dir again to ensure running the highest version
        if (FAILED(hr=CreateAssemblyCacheImport(&pCacheImport, pAsmId, CACHEIMP_CREATE_RESOLVE_REF)))
            goto exit;

        if (hr == S_FALSE)
        {
            Msg(L"No completed cached version found. Possible error in download cache commit. Cannot continue.");
            hr = E_ABORT;
            goto exit;
        }
    }

    pCacheImport->GetManifestFileDir(ppwzManifestFileDir, &dwCC);
    if (dwCC < 2)
    {
        // this should never happen
        hr = E_FAIL;
        goto exit;
    }

    pCacheImport->GetManifestFilePath(ppwzManifestFilePath, &dwCC);
    if (dwCC < 2)
    {
        hr = E_FAIL;
        goto exit;
    }

exit:
    if (pCacheImport)
        pCacheImport->Release();

    if (FAILED(hr))
    {
        if (*ppwzManifestFileDir)
        {
            delete *ppwzManifestFileDir;
            *ppwzManifestFileDir = NULL;
        }
        if (*ppwzManifestFilePath)
        {
            delete *ppwzManifestFilePath;
            *ppwzManifestFilePath = NULL;
        }
    }

    return hr;
}

// ----------------------------------------------------------------------------

/*void _stdcall 
  EntryPoint(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow); 

   hwnd - window handle that should be used as the owner window for
          any windows your DLL creates
   hinst - your DLL's instance handle
   lpszCmdLine - ASCIIZ command line your DLL should parse
   nCmdShow - describes how your DLL's windows should be displayed 
*/

// ---------------------------------------------------------------------------
// DisableCurrentVersionW
// The rundll32 entry point for rollback to previous version
// The function should be named as 'DisableCurrentVersion' on rundll32's command line
// ---------------------------------------------------------------------------

// BUGBUG: WARNING!! this is **major hacked up code** and does open up some holes in the logic
//      depends on the timing of this and check for max version in cache in app start....
//      ie. SHOULD NEVER BE RUNNING THIS AND START DOWNLOAD/UPDATE!
//
//      also, this depends on a few things such as how update service check if the
//      version exists etc..
void CALLBACK
DisableCurrentVersionW(HWND hwnd, HINSTANCE hinst, LPWSTR lpszCmdLine, int nCmdShow)
{
    HRESULT hr = S_OK;
    LPASSEMBLY_MANIFEST_IMPORT pManImport = NULL;
    LPASSEMBLY_IDENTITY pAsmId = NULL;
    LPMANIFEST_APPLICATION_INFO pAppInfo = NULL;
    LPASSEMBLY_CACHE_IMPORT pCacheImport = NULL;
    LPWSTR pwzCacheDir = NULL;
    LPWSTR pwzDisplayName = NULL;
    DWORD dwCC = 0;
    WCHAR wzBuf[1024];
	LONG lResult;
	HKEY hkeySubKey;

    if (FAILED(hr = CoInitialize(NULL)))
        goto exit;

    // hacked up commandline parsing code
    lpszCmdLine = lpszCmdLine+1;
    *(lpszCmdLine+lstrlen(lpszCmdLine)-1) = L'\0';

    if (FAILED(hr=CreateAssemblyManifestImport(&pManImport, lpszCmdLine)))
    {
        // temp msg
        Msg(L"ManImport error.");
        goto exit;
    }

    if (FAILED(hr=pManImport->GetManifestApplicationInfo(&pAppInfo)) || hr==S_FALSE)
    {
        // can't continue without this...
        hr = E_ABORT;
        Msg(L"This manifest does not have the proper format and cannot be used to start an application. Thus there is nothing to disable here.");
        goto exit;
    }

    if (FAILED(hr=pManImport->GetAssemblyIdentity(&pAsmId)))
    {
        // temp msg
        Msg(L"AsmId error.");
        goto exit;
    }
    
    if (FAILED(hr=CreateAssemblyCacheImport(&pCacheImport, pAsmId, CACHEIMP_CREATE_RESOLVE_REF)))
    {
        // temp msg
        Msg(L"CacheImport error.");
        goto exit;
    }

    if (hr == S_FALSE)
    {
        Msg(L"No completed cached version found. Nothing to disable.");
        hr = E_ABORT;
        goto exit;
    }

    pCacheImport->GetManifestFileDir(&pwzCacheDir, &dwCC);
    if (dwCC < 2)
    {
        // this should never happen
        hr = E_FAIL;
        goto exit;
    }
    // remove last L'\\'
    *(pwzCacheDir+dwCC-2) = L'\0';
    // find the name to use from the cache path
    pwzDisplayName = wcsrchr(pwzCacheDir, L'\\');

    // this has to be the same as how assemblycache does it!
    lstrcpy(wzBuf, L"Software\\Microsoft\\Fusion\\Installer\\1.0.0.0\\Cache\\");
    lstrcat(wzBuf, pwzDisplayName);

	lResult = RegOpenKeyEx(HKEY_CURRENT_USER, wzBuf, 0, KEY_SET_VALUE,
			&hkeySubKey);

	if (lResult == ERROR_SUCCESS)
	{
        DWORD dwValue = 0;

        // set to 0 to make it 'incomplete' so that StartW/host/cache will ignore it
        // when executing the app but keep the dir name so that download
        // will assume it is handled - assemblycache.cpp & assemblydownload.cpp's check
		lResult = RegSetValueEx(hkeySubKey, L"Complete", NULL, REG_DWORD,
				(PBYTE) &dwValue, sizeof(dwValue));

		if (lResult == ERROR_SUCCESS)
		{
		    // no error checking!
		    pCacheImport->Release();

		    hr=CreateAssemblyCacheImport(&pCacheImport, pAsmId, CACHEIMP_CREATE_RESOLVE_REF);
		    if (hr == S_FALSE)
		    {
                dwValue = 1;

                // change it back to what it was if no other completed version found
                // no error checking!
        		lResult = RegSetValueEx(hkeySubKey, L"Complete", NULL, REG_DWORD,
		    		(PBYTE) &dwValue, sizeof(dwValue));

                // BUGBUG: known problem for fully qualified ref, eg. app manifest's asm id
                //        Should check for it and display and different msg here.
                Msg(L"No other completed cached version found. Disabling current version cannot be done. Cancelling...");
		    }
		    else
		    {
		        Msg(L"Current version disabled. Next time another version of the app will run instead.");
		    }
		}
        
		RegCloseKey(hkeySubKey);
	}
	else
	{
	    Msg(L"Registry error.");
	}

exit:
    if (pCacheImport)
        pCacheImport->Release();

    if (pAsmId)
        pAsmId->Release();

    if (pAppInfo)
        pAppInfo->Release();

    if (pManImport)
        pManImport->Release();

    if (pwzCacheDir)
        delete pwzCacheDir;

    if (FAILED(hr))
    {
        if (hr != E_ABORT)
            Msg(L"Error occured.");
    }

    CoUninitialize();

    return;
}


// ---------------------------------------------------------------------------
// StartW
// The single rundll32 entry point for both shell (file type host) and mimefilter/url
// The function should be named as 'Start' on rundll32's command line
// ---------------------------------------------------------------------------
void CALLBACK
StartW(HWND hwnd, HINSTANCE hinst, LPWSTR lpszCmdLine, int nCmdShow)
{
    HRESULT hr = S_OK;
    LPASSEMBLY_MANIFEST_IMPORT pManImport = NULL;
    LPASSEMBLY_IDENTITY pAsmId = NULL;
    LPMANIFEST_APPLICATION_INFO pAppInfo = NULL;
    LPDEPENDENT_ASSEMBLY_INFO pDependAsmInfo = NULL;
    LPWSTR pwzShortcutPath = NULL;
    LPWSTR pwzShortcutUrl = NULL;
    LPWSTR pwzAppRootDir = NULL;
    LPWSTR pwzAppManifestPath = NULL;
    LPWSTR pwzEntrypoint = NULL;
    LPWSTR pwzType = NULL;
    LPWSTR pwzCmdLine = NULL;
    LPWSTR pwzCodebase = NULL;
    DWORD dwCC = 0;
    DWORD dwManifestType = MANIFEST_TYPE_UNKNOWN;
    BOOL bIsFromMimeFilter = FALSE;
    BOOL bIs1stTimeInstall = FALSE;
    int iAppType = 0;
    
    if (FAILED(hr = CoInitialize(NULL)))//CoInitializeEx(NULL, COINIT_MULTITHREADED); 
        goto exit;

    // parse commandline
    // accepted formats: "Path" <OR> "Path" "URL"
    if (*lpszCmdLine == L'\"')
    {
        LPWSTR pwz = NULL;
        
        pwz = wcschr(lpszCmdLine+1, L'\"');
        if (pwz != NULL)
        {
            *pwz = L'\0';

            // case 1 desktop/local, path to shortcut only
            pwzShortcutPath = lpszCmdLine+1;
            
            pwz = wcschr(pwz+1, L'\"');
            if (pwz != NULL)
            {
                pwzShortcutUrl = pwz+1;

                pwz = wcschr(pwzShortcutUrl, L'\"');
                if (pwz != NULL)
                {
                    *pwz = L'\0';
                    // case 2 url/mimefilter, path to temp shortcut and source URL
                    bIsFromMimeFilter = TRUE;
                }
            }
        }
    }

    // exit if invalid arguments. ShortcutUrl is incomplete if bIsFromMimeFilter is FALSE
    if (pwzShortcutPath == NULL || (pwzShortcutUrl != NULL && !bIsFromMimeFilter))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // valid start conditions to invoke this function, passing
    // 1. path to desktop manifest (install redirect to subscription manifest on server)
    // 2. path to desktop manifest (install redirect to applicaion manifest on server)
    // 3. BUGBUG TO-BE-FIXED//path to application (no install)
    // 4. URL to subscription manifest on server
    // 5. URL to application manifest on server

    if (FAILED(hr=CreateAssemblyManifestImport(&pManImport, pwzShortcutPath)))
    {
        Msg(L"Error in loading and parsing the manifest file.");
        goto exit;
    }

    pManImport->ReportManifestType(&dwManifestType);
    if (dwManifestType == MANIFEST_TYPE_UNKNOWN)
    {
        Msg(L"This manifest does not have a known format type.");
        hr = E_ABORT;
        goto exit;
    }

    // allow only valid start conditions

    if (bIsFromMimeFilter &&
        dwManifestType != MANIFEST_TYPE_SUBSCRIPTION &&
        dwManifestType != MANIFEST_TYPE_APPLICATION)
    {
        Msg(L"Not supported: URL pointing to a desktop manifest.");
        hr = E_ABORT;
        goto exit;
    }

    if (!bIsFromMimeFilter &&
        dwManifestType != MANIFEST_TYPE_DESKTOP)
        //&& dwManifestType != MANIFEST_TYPE_APPLICATION)
    {
        Msg(L"This manifest does not have the proper format and cannot be used to start an application.");
        hr = E_ABORT;
        goto exit;
    }

    // get data from the manifest file

    if (dwManifestType != MANIFEST_TYPE_SUBSCRIPTION)
    {
        if (FAILED(hr=pManImport->GetAssemblyIdentity(&pAsmId)))
        {
            Msg(L"This manifest does not have the proper format and contains no assembly identity.");
            goto exit;
        }
    }

    if (dwManifestType != MANIFEST_TYPE_APPLICATION)
    {
        // BUGBUG: hardcoded index '0'
    	pManImport->GetNextAssembly(0, &pDependAsmInfo);
    	if (pDependAsmInfo)
    	{
            if (dwManifestType == MANIFEST_TYPE_SUBSCRIPTION)
            {
            	pDependAsmInfo->GetAssemblyIdentity(&pAsmId);
            }

            pDependAsmInfo->Get(DEPENDENT_ASM_CODEBASE, &pwzCodebase, &dwCC);
       	}

    	if (!pAsmId || !pwzCodebase)
    	{
    	    Msg(L"This subscription manifest contains no dependent assembly identity or a subscription codebase.");
    	    hr = E_FAIL;
            goto exit;
    	}
    }
    else
    {
//        if (bIsFromMimeFilter)
//        {
        // if URL->app manifest (case 5), codebase is that URL
        // note: if path->app manifest (case 3), this does NOT apply

        // BUGBUG: HACK: this implies re-download of the app manifest. pref?

        size_t ccCodebase = wcslen(pwzShortcutUrl)+1;
        pwzCodebase = new WCHAR[ccCodebase];

        if (pwzCodebase == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        memcpy(pwzCodebase, pwzShortcutUrl, ccCodebase * sizeof(WCHAR));
//        }
    }

    // search cache, download/install if necessary

    if (FAILED(hr = ResolveAndInstall(pAsmId, pwzCodebase, &pwzAppRootDir, &pwzAppManifestPath, &bIs1stTimeInstall)))
        goto exit;

    // register for updates

    if (bIs1stTimeInstall && bIsFromMimeFilter && dwManifestType == MANIFEST_TYPE_SUBSCRIPTION)
    {
        // note: this code must be identical to what assemblydownload.cpp DoCacheUpdate() does!
        LPWSTR pwzName = NULL;

        if ((hr = pAsmId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwzName, &dwCC)) != S_OK)
        {
            Msg(L"Error in retrieving assembly name. Cannot register subscription for updates.");
            // note: This- no asm name- should not be allowed!
        }
        else
        {
            IAssemblyUpdate *pAssemblyUpdate = NULL;

            // register for updates
            hr = CoCreateInstance(CLSID_CAssemblyUpdate, NULL, CLSCTX_LOCAL_SERVER, 
                                    IID_IAssemblyUpdate, (void**)&pAssemblyUpdate);
            if (SUCCEEDED(hr))
            {
                DWORD pollingInterval;
                hr = pManImport->GetPollingInterval (&pollingInterval);

                hr = pAssemblyUpdate->RegisterAssemblySubscription(pwzName, 
                        pwzShortcutUrl, pollingInterval);

                pAssemblyUpdate->Release();
            }

            if (FAILED(hr))
            {
                Msg(L"Error in update services. Cannot register subscription for updates.");
                //goto exit; do not terminate!
            }
            // else
                // Error in update services. Cannot register subscription for updates - fail gracefully
                // BUGBUG: need a way to recover from this and register later

            delete pwzName;
        }
    }
    
    // execute the app

    if (bIsFromMimeFilter)
    {
        // if URL, crack the app manifest to get shell state info

        // BUGBUG: if URL->app manifest (case 5), pwzShortcutPath is a copy and is already cracked-so no need in that case?

        pManImport->Release();
        if (FAILED(hr=CreateAssemblyManifestImport(&pManImport, pwzAppManifestPath)))
        {
            Msg(L"Error in loading and parsing the application manifest file.");
            goto exit;
        }
    }

    if (FAILED(hr=pManImport->GetManifestApplicationInfo(&pAppInfo)) || hr==S_FALSE)
    {
        // can't continue without this...
        hr = E_ABORT;
        Msg(L"This manifest does not have the shell information and cannot be used to start an application.");
        goto exit;
    }

	if (FAILED(hr = pAppInfo->Get(MAN_APPLICATION_ENTRYPOINT, &pwzEntrypoint, &dwCC)))
	{
	    Msg(L"This application does not have an entrypoint specified.");
	    goto exit;
	}

    if (FAILED(hr = pAppInfo->Get(MAN_APPLICATION_ENTRYIMAGETYPE, &pwzType, &dwCC)))
    {
        Msg(L"Error in retrieving application type. Cannot continue.");
        goto exit;
    }

    // BUGBUG: use wcscmp case sensitive comparison?
    if (_wcsicmp(pwzType, WZ_TYPE_DOTNET) == 0)
        iAppType = TYPE_DOTNET;
    else if (_wcsicmp(pwzType, WZ_TYPE_WIN32) == 0)
        iAppType = TYPE_WIN32;
    else if (_wcsicmp(pwzType, WZ_TYPE_AVALON) == 0)
        iAppType = TYPE_AVALON;

    if (iAppType == TYPE_DOTNET || iAppType == TYPE_WIN32 || iAppType == TYPE_AVALON)
    {
        size_t ccWorkingDir = wcslen(pwzAppRootDir);
        size_t ccEntryPoint = wcslen(pwzEntrypoint)+1;
        pwzCmdLine = new WCHAR[ccWorkingDir+ccEntryPoint];	// 2 strings + '\0'

        if (pwzCmdLine == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        memcpy(pwzCmdLine, pwzAppRootDir, ccWorkingDir * sizeof(WCHAR));
        memcpy(pwzCmdLine+ccWorkingDir, pwzEntrypoint, ccEntryPoint * sizeof(WCHAR));

        // check if the entry point is in cache or not
        if (GetFileAttributes(pwzCmdLine) == (DWORD)-1)
        {
            Msg(L"Entry point does not exist. Cannot continue.");
            hr = E_ABORT;
            goto exit;
        }
    }

    if (iAppType == TYPE_DOTNET)// || iAppType == TYPE_AVALON)
    {
        DWORD dwZone;
//conexec        WCHAR wzCmdLine[1025];

        // note: at this point the codebase can be: URL to app manifest _or_ URL to subscription manifest
        //    (depends on how 1st time install is started with)
        if (pwzCodebase == NULL)
        {
            Msg(L"This application does not have a codebase specified. Cannot continue to execute .NetAssembly.");
            goto exit;
        }

        if (g_pSecurityMgr == NULL)
        {
            // lazy init.
        
   hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
                                IID_IInternetSecurityManager, (void**)&g_pSecurityMgr);
            if (FAILED(hr))
            {
                g_pSecurityMgr = NULL;
                goto exit;
            }
        }

        // BUGBUG?: shouldn't use codebase from ref manifest to set zone?
        if (FAILED(hr = g_pSecurityMgr->MapUrlToZone(pwzCodebase, &dwZone, 0)))
        {
            goto exit;
        }

/*conexec code path
        if (_snwprintf(wzCmdLine, sizeof(wzCmdLine)/sizeof(WCHAR),
                L"conexec.exe \"%s\" 3 %d %s", pwzCmdLine, dwZone, pwzCodebase) < 0)
        {
            hr = CO_E_PATHTOOLONG;
            goto exit;
        }

        // BUGBUG: start directory: what if the exe is in a subdir of pwzAppRootDir?
        
        // CreateProcess dislike having the filename in the path for the start directory
        if (FAILED(hr=RunCommand(wzCmdLine, pwzAppRootDir, FALSE)))
            goto exit;*/

        try
        {
            IAsmExecutePtr pIAsmExecute(__uuidof(AsmExecute));
            long lRetVal = -1;
            LPWSTR pwzArg = NULL;

            // BUGBUG: change AsmExec if it's no longer needed to send commandline argument
            //          clean up interface

            if (iAppType == TYPE_AVALON)
            {
                // call with manifest file path as a parameter

                pwzArg = pwzAppManifestPath;
            }

            //parameters: Codebase/filepath Flag Zone Url Arg
            // BUGBUG: DWORD is unsigned and long is signed

            hr = pIAsmExecute->Execute(_bstr_t(pwzCmdLine), 3, dwZone, _bstr_t(pwzCodebase), _bstr_t(pwzArg), &lRetVal);

            // BUGBUG: do something about lRetVal
        }
        catch (_com_error &e)
        {
            hr = e.Error();
            Msg((LPWSTR)e.ErrorMessage());
        }

        // hr from Execute() or inside catch(){} above
        if (FAILED(hr))
            goto exit;
    }
    else if (iAppType == TYPE_AVALON) //BUGBUG: a hack for avalon
    {
        WCHAR wzCmdLine[2048];

        if (_snwprintf(wzCmdLine, sizeof(wzCmdLine)/sizeof(WCHAR),
                L"\"%s\" \"%s\"", pwzCmdLine, pwzAppManifestPath) < 0)
        {
            hr = CO_E_PATHTOOLONG;
            goto exit;
        }

        // BUGBUG: start directory: what if the exe is in a subdir of pwzAppRootDir?

        // CreateProcess dislike having the filename in the path for the start directory
        if (FAILED(hr=RunCommand(wzCmdLine, pwzAppRootDir, FALSE)))
        {
            Msg(L"Avalon: Create process error.");
            goto exit;
        }

    }
    else if (iAppType == TYPE_WIN32)
    {
        // BUGBUG: Win32 app has no sandboxing... use SAFER?

        // BUGBUG: start directory: what if the exe is in a subdir of pwzAppRootDir?

        // CreateProcess dislike having the filename in the path for the start directory
        if (FAILED(hr=RunCommand(pwzCmdLine, pwzAppRootDir, FALSE)))
        {
            Msg(L"Win32Executable: Create process error.");
            goto exit;
        }
    }
    //else
        // unknown type....

exit:
    if (g_pSecurityMgr != NULL)
	{
		g_pSecurityMgr->Release();
        g_pSecurityMgr = NULL;
	}

    if (pAsmId)
        pAsmId->Release();

    if (pDependAsmInfo)
        pDependAsmInfo->Release();
    
    if (pAppInfo)
        pAppInfo->Release();

    if (pManImport)
        pManImport->Release();

    if (pwzAppManifestPath)
        delete pwzAppManifestPath;

    if (pwzAppRootDir)
        delete pwzAppRootDir;

    if (pwzEntrypoint)
        delete pwzEntrypoint;

    if (pwzType)
        delete pwzType;

    if (pwzCmdLine)
        delete pwzCmdLine;

    if (pwzCodebase)
        delete pwzCodebase;

    if (FAILED(hr))
    {
        if (hr != E_ABORT)
            Msg(L"Error occured.");
    }
    else
    {
        if (bIsFromMimeFilter && bIs1stTimeInstall)
        {
            // BUGBUG: should generate the desktop manifest file

  /*          // assume it's an URL
            LPWSTR pwzFilename = wcsrchr(pwzShortcutUrl, L'/');
            if (pwzFilename != NULL)
            {
                pwzFilename++;
                CopyToUSStartMenu(pwzShortcutPath, pwzFilename, FALSE);
            }
            //else
                // error as filename not found but ignore...*/
        }
    }

    if (bIsFromMimeFilter)
    {
        // delete the temp file from the mimefilter
        // ignore return value
        DeleteFile(pwzShortcutPath);
    }

    CoUninitialize();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\includes\mfilter.h ===
#pragma once
#ifndef _FILTER_DLL_H
#define _FILTER_DLL_H

#include <objbase.h>
#include <windows.h>

#include <wininet.h>

#define CONTENT_TYPE L"text/html"

// Clases and interfaces

class CFusionMimeFilterClassFactory : public IClassFactory
{
public:
    CFusionMimeFilterClassFactory	();

    // IUnknown Methods
    STDMETHOD_    (ULONG, AddRef)	();
    STDMETHOD_    (ULONG, Release)	();
    STDMETHOD     (QueryInterface)	(REFIID, void **);

    // IClassFactory Moethods
    STDMETHOD     (LockServer)		(BOOL);
    STDMETHOD     (CreateInstance)	(IUnknown*,REFIID,void**);

protected:
    long			_cRef;
};

class CFusionMimeFilter : public IInternetProtocol, public IInternetProtocolSink
{
public:
    CFusionMimeFilter     ();
    ~CFusionMimeFilter    ();

    // IUnknown methods
    STDMETHOD_        (ULONG, AddRef)			();
    STDMETHOD_        (ULONG, Release)			();
    STDMETHOD         (QueryInterface)			(REFIID, void **);

    // InternetProtocol methods
    STDMETHOD         (Start)					(LPCWSTR, IInternetProtocolSink *, IInternetBindInfo *, DWORD, DWORD);
    STDMETHOD         (Continue)				(PROTOCOLDATA *pProtData);
    STDMETHOD         (Abort)					(HRESULT hrReason,DWORD );
    STDMETHOD         (Terminate)				(DWORD );
    STDMETHOD         (Suspend)					();
    STDMETHOD         (Resume)					();
    STDMETHOD         (Read)					(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD         (Seek)					(LARGE_INTEGER , DWORD , ULARGE_INTEGER *) ;
    STDMETHOD         (LockRequest)				(DWORD );
    STDMETHOD         (UnlockRequest)			();

    // IInternetProtocolSink methods
    STDMETHOD         (ReportData)				(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax);
    STDMETHOD         (ReportProgress)			(ULONG ulStatusCode, LPCWSTR szStatusText);
    STDMETHOD         (ReportResult)			(HRESULT hrResult, DWORD dwError, LPCWSTR szResult);
    STDMETHOD         (Switch)					(PROTOCOLDATA *pProtocolData);

protected:
    HRESULT				OpenTempFile();
    HRESULT				CloseTempFile();

    long				_cRef;
    BOOL				_fFirstRead;
    BOOL				_fReadDone;

    IInternetProtocolSink* _pOutgoingProtSink;
    IInternetProtocol*	_pIncomingProt;

    DWORD				_grfSTI;							// STI flags handed to us 

    LPWSTR				_pwzUrl;                             // The URL

    WCHAR				_wzTempFile[MAX_PATH];
    HANDLE				_hFile;

    ULONG              _cbAdRead;
};

extern const GUID CLSID_FusionMimeFilter;

#endif // _FILTER_DLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\includes\shellres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by shelllc.rc
//
#define IDD_NAME                        200
#define IDD_HOTKEY                      1000
#define IDD_START_IN                    3002
#define IDD_ICON                        3301
#define IDD_LINE_1                      3327
#define IDD_LINE_2                      3328
#define IDD_CHANGE_ICON                 3407
#define IDD_SHOW_CMD                    3408
#define IDC_STATIC                      -1
#define DLG_FUS_SHORTCUT_PROP_SHEET_APPNAME 101
#define IDD_CODEBASE                    1001
#define IDD_VERSION                     1002
#define IDD_CULTURE                     1003
#define DLG_FUS_SHORTCUT_PROP_SHEET     1040
#define IDD_TYPE                        3303
#define IDD_ENTRYPOINT                  3304
#define IDD_DISPLAY_NAME                3305
#define IDD_PKT                         3306
#define IDS_SHOW_NORMAL                 1 // # must be in order
#define IDS_SHOW_MINIMIZED              2
#define IDS_SHOW_MAXIMIZED              3
#define IDS_TIP_NAME                      4
#define IDS_TIP_TYPE                      5
#define IDS_TIP_LOCATION                  6
#define IDS_TIP_CODEBASE                 7

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\includes\shcut.h ===
#pragma once
#ifndef _SHCUT_DLL_H
#define _SHCUT_DLL_H

#include <objbase.h>
#include <windows.h>

#include <shlobj.h>
#include "refcount.hpp"

#include "fusenet.h"

// Shortcut flags

typedef enum _fusshcutflags
{
	FUSSHCUT_FL_NOTDIRTY	= 0x0000,
	FUSSHCUT_FL_DIRTY		= 0x0001,

	ALL_FUSSHCUT_FLAGS   //= FUSSHCUT_FL_DIRTY
}
FUSSHCUTFLAGS;

#define DEFAULTSHOWCMD			SW_NORMAL


// BUGBUG?: revise length restrictions

#define DISPLAYNAMESTRINGLENGTH		26
#define TYPESTRINGLENGTH			20

#define MAX_URL_LENGTH				2084 // same as INTERNET_MAX_URL_LENGTH+1 from wininet.h


// Clases and interfaces

class CFusionShortcutClassFactory : public IClassFactory
{
public:
	CFusionShortcutClassFactory		();

	// IUnknown Methods
	STDMETHOD_    (ULONG, AddRef)	();
	STDMETHOD_    (ULONG, Release)	();
	STDMETHOD     (QueryInterface)	(REFIID, void **);

	// IClassFactory Moethods
	STDMETHOD     (LockServer)		(BOOL);
	STDMETHOD     (CreateInstance)	(IUnknown*,REFIID,void**);

protected:
	long			_cRef;
};

// Shortcut Shell extension

class CFusionShortcut : public RefCount,
					public IExtractIcon,
					public IPersistFile,
					public IShellExtInit,
					public IShellLink,
					public IShellPropSheetExt,
					public IQueryInfo
{
public:
	CFusionShortcut(void);
	~CFusionShortcut(void);

	// IUnknown methods

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
	ULONG   STDMETHODCALLTYPE AddRef(void);
	ULONG   STDMETHODCALLTYPE Release(void);

	// IExtractIcon methods

	HRESULT STDMETHODCALLTYPE GetIconLocation(UINT uFlags, LPWSTR pwzIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags);
	HRESULT STDMETHODCALLTYPE Extract(LPCWSTR pcwzFile, UINT uIconIndex, HICON* phiconLarge, HICON* phiconSmall, UINT ucIconSize);

	// IPersist method

	HRESULT STDMETHODCALLTYPE GetClassID(CLSID* pclsid);

	// IPersistFile methods

	HRESULT STDMETHODCALLTYPE IsDirty(void);
	HRESULT STDMETHODCALLTYPE Save(LPCOLESTR pcwszFileName, BOOL bRemember);
	HRESULT STDMETHODCALLTYPE SaveCompleted(LPCOLESTR pcwszFileName);
	HRESULT STDMETHODCALLTYPE Load(LPCOLESTR pcwszFileName, DWORD dwMode);
	HRESULT STDMETHODCALLTYPE GetCurFile(LPOLESTR *ppwszFileName);

	// IShellExtInit method

	HRESULT STDMETHODCALLTYPE Initialize(LPCITEMIDLIST pcidlFolder, IDataObject* pidobj, HKEY hkeyProgID);

	// IShellLink methods

	HRESULT STDMETHODCALLTYPE SetPath(LPCWSTR pcwzPath);
	HRESULT STDMETHODCALLTYPE GetPath(LPWSTR pwzFile, int ncFileBufLen, PWIN32_FIND_DATA pwfd, DWORD dwFlags);
	HRESULT STDMETHODCALLTYPE SetRelativePath(LPCWSTR pcwzRelativePath, DWORD dwReserved);
	HRESULT STDMETHODCALLTYPE SetIDList(LPCITEMIDLIST pcidl);
	HRESULT STDMETHODCALLTYPE GetIDList(LPITEMIDLIST *ppidl);
	HRESULT STDMETHODCALLTYPE SetDescription(LPCWSTR pcwzDescription);
	HRESULT STDMETHODCALLTYPE GetDescription(LPWSTR pwzDescription, int ncDesciptionBufLen);
	HRESULT STDMETHODCALLTYPE SetArguments(LPCWSTR pcwzArgs);
	HRESULT STDMETHODCALLTYPE GetArguments(LPWSTR pwzArgs, int ncArgsBufLen);
	HRESULT STDMETHODCALLTYPE SetWorkingDirectory(LPCWSTR pcwzWorkingDirectory);
	HRESULT STDMETHODCALLTYPE GetWorkingDirectory(LPWSTR pwzWorkingDirectory, int ncbLen);
	HRESULT STDMETHODCALLTYPE SetHotkey(WORD wHotkey);
	HRESULT STDMETHODCALLTYPE GetHotkey(PWORD pwHotkey);
	HRESULT STDMETHODCALLTYPE SetShowCmd(int nShowCmd);
	HRESULT STDMETHODCALLTYPE GetShowCmd(PINT pnShowCmd);
	HRESULT STDMETHODCALLTYPE SetIconLocation(LPCWSTR pcwzIconFile, int niIcon);
	HRESULT STDMETHODCALLTYPE GetIconLocation(LPWSTR pwzIconFile, int ncbLen, PINT pniIcon);
	HRESULT STDMETHODCALLTYPE Resolve(HWND hwnd, DWORD dwFlags);

	// IShellPropSheetExt methods

	HRESULT STDMETHODCALLTYPE AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
	HRESULT STDMETHODCALLTYPE ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam);

	// IQueryInfo methods

	HRESULT STDMETHODCALLTYPE GetInfoFlags(DWORD *pdwFlags);
	HRESULT STDMETHODCALLTYPE GetInfoTip(DWORD dwFlags, LPWSTR *ppwszTip);

	// other get/set methods (used by prop sheet)

	HRESULT STDMETHODCALLTYPE SetCodebase(LPCWSTR pcwzCodebase);
	HRESULT STDMETHODCALLTYPE GetCodebase(LPWSTR pwzCodebase, int ncbLen);

	// other methods

	HRESULT STDMETHODCALLTYPE GetAssemblyIdentity(LPASSEMBLY_IDENTITY* ppAsmId);
	HRESULT STDMETHODCALLTYPE GetCurFile(LPWSTR pwzFile, UINT ucbLen);
	HRESULT STDMETHODCALLTYPE Dirty(BOOL bDirty);

private:
	DWORD m_dwFlags;

	LPWSTR m_pwzShortcutFile;
	LPWSTR m_pwzPath;
	LPWSTR m_pwzDesc;
	LPWSTR m_pwzIconFile;
	int      m_niIcon;
	LPWSTR m_pwzWorkingDirectory;
	int      m_nShowCmd;
	WORD   m_wHotkey;

	LPWSTR	m_pwzCodebase;
	
	LPASSEMBLY_IDENTITY		m_pIdentity;
};

extern const GUID CLSID_FusionShortcut;

#endif // _SHCUT_DLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\includes\project.hpp ===
/*
 * project.hpp - project header file for CFusionShortcut Shell
 *               extension DLL.
 */

// * note: debug check/code incomplete.
//#define DEBUG

/* Common Headers
 *****************/

#define INC_OLE2				// for windows.h
#define CONST_VTABLE			// for objbase.h

#ifndef WIN32_LEAN_AND_MEAN		// NT builds define this for us
#define WIN32_LEAN_AND_MEAN		// for windows.h
#endif							//  WIN32_LEAN_AND_MEAN

#define NOSERVICE
#define NOMCX
#define NOIME
#define NOSOUND
#define NOCOMM
#define NOKANJI
#define NORPC
#define NOPROXYSTUB
#define NOIMAGE
#define NOTAPE 
   
#include <windows.h>

#include <shellapi.h>

#include <limits.h>				// for ULONG_MAX

#ifdef __cplusplus
extern "C" {					// Assume C declarations for C++.
#endif   /* __cplusplus */

#include "debbase.h"

#ifdef __cplusplus
}								// End of extern "C" {.
#endif   /* __cplusplus */



/* Project Headers
 ******************/

#include "shcut.h"
#include "refcount.hpp"

// for SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_*
#include "..\..\id\sxsid.h"

// bit flag manipulation ---

#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))
#define CLEAR_FLAG(dwAllFlags, dwFlag)    ((dwAllFlags) &= (~dwFlag))

#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))
#define IS_FLAG_CLEAR(dwAllFlags, dwFlag) (! (IS_FLAG_SET(dwAllFlags, dwFlag)))

#define E_FILE_NOT_FOUND         MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)
#define E_PATH_NOT_FOUND         MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_PATH_NOT_FOUND)

#define ARRAY_ELEMENTS(rg)                (sizeof(rg) / sizeof((rg)[0]))

// util stuff ---

HRESULT GetLastWin32Error();

bool PathAppend(LPWSTR wzDest, LPCWSTR wzSrc);

const WCHAR g_cwzWhiteSpace[]		= L" \t";
const WCHAR g_cwzPathSeparators[]	= L":/\\";
const WCHAR g_cwzEmptyString[]		= L"";

extern BOOL AnyNonWhiteSpace(LPCWSTR pcsz);

// debug stuff ---

extern BOOL IsValidPath(PCWSTR pcwzPath);
extern BOOL IsValidPathResult(HRESULT hr, PCWSTR pcwzPath, UINT ucbPathBufLen);
extern BOOL IsValidIconIndex(HRESULT hr, PCWSTR pcwzIconFile, UINT ucbIconFileBufLen, int niIcon);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\shortcut\extricon.cpp ===
/*
 * extricon.cpp - IExtractIcon implementation for CFusionShortcut class.
 */


/* Headers
 **********/

#include "project.hpp"
#include <stdio.h> // for _snwprintf

/* Global Constants
 *******************/

const WCHAR g_cwzDefaultIconKey[]	= L"manifestfile\\DefaultIcon";

const HKEY g_hkeySettings			= HKEY_CLASSES_ROOT;

/* Module Constants
 *******************/

const WCHAR s_cwzGenericIconFile[]	= L"fnsshell.dll";

const int s_ciGenericIconFileIndex	= 0;


void TrimString(PWSTR pwzTrimMe, PCWSTR pwzTrimChars)
{
	PWSTR pwz = pwzTrimMe;;
	PWSTR pwzStartMeat = NULL;

	if ( !pwzTrimMe || !pwzTrimChars )
		goto exit;

	// Trim leading characters.

	while (*pwz && wcschr(pwzTrimChars, *pwz))
	{
		//CharNext(pwz);
		if (*pwz != L'\0')	// this really will not be false...
			pwz++;
	}

	pwzStartMeat = pwz;

	// Trim trailing characters.

	if (*pwz)
	{
		pwz += wcslen(pwz);

		//CharPrev(pwzStartMeat, pwz);
		if (pwz != pwzStartMeat)	// this check is not really necessary...
			pwz--;

		if (pwz > pwzStartMeat)
		{
			while (wcschr(pwzTrimChars, *pwz))
			{
				//CharPrev(pwzStartMeat, pwz);
				if (pwz != pwzStartMeat)	// this really will not be false...
					pwz--;
			}

			//CharNext(pwz);
			if (*pwz != L'\0')	// this check is not really necessary...
				pwz++;

			ASSERT(pwz > pwzStartMeat);

			*pwz = L'\0';
		}
	}

	// Relocate stripped string.

	if (*pwzStartMeat && pwzStartMeat > pwzTrimMe)
		// (+ 1) for null terminator.
		// BUGBUG?: is this going to bite us later?
		MoveMemory(pwzTrimMe, pwzStartMeat, (wcslen(pwzStartMeat)+1) * sizeof(WCHAR));
	else if (!*pwzStartMeat)
		pwzTrimMe[0] = L'\0';
	else
		ASSERT(pwzStartMeat == pwzTrimMe);

exit:
	return;
}

/*
** TrimWhiteSpace()
**
** Trims leading and trailing white space from a string in place.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
void TrimWhiteSpace(PWSTR pwzTrimMe)
{
	TrimString(pwzTrimMe, g_cwzWhiteSpace);

	// TrimString() validates pwzTrimMe on output.

	return;
}

/*
** GetRegKeyValue()
**
** Retrieves the data from a registry key's value.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
LONG GetRegKeyValue(HKEY hkeyParent, PCWSTR pcwzSubKey,
                                   PCWSTR pcwzValue, PDWORD pdwValueType,
                                   PBYTE pbyteBuf, PDWORD pdwcbBufLen)
{
	LONG lResult;
	HKEY hkeySubKey;

	ASSERT(IS_VALID_HANDLE(hkeyParent, KEY));
	ASSERT(! pcwzSubKey || ! pcwzValue || ! pdwValueType || ! pbyteBuf);

	lResult = RegOpenKeyEx(hkeyParent, pcwzSubKey, 0, KEY_QUERY_VALUE,
			&hkeySubKey);

	if (lResult == ERROR_SUCCESS)
	{
		LONG lResultClose;

		lResult = RegQueryValueEx(hkeySubKey, pcwzValue, NULL, pdwValueType,
				pbyteBuf, pdwcbBufLen);

		lResultClose = RegCloseKey(hkeySubKey);

		if (lResult == ERROR_SUCCESS)
			lResult = lResultClose;
	}

	return(lResult);
}

/*
** GetRegKeyStringValue()
**
** Retrieves the data from a registry key's string value.
**
** Arguments:
**
** Returns: ERROR_CANTREAD if not string
**
** Side Effects:  none
*/
LONG GetRegKeyStringValue(HKEY hkeyParent, PCWSTR pcwzSubKey,
                                         PCWSTR pcwzValue, PWSTR pwzBuf,
                                         PDWORD pdwcbBufLen)
{
	LONG lResult;
	DWORD dwValueType;

	// GetRegKeyValue() will verify the parameters.

	lResult = GetRegKeyValue(hkeyParent, pcwzSubKey, pcwzValue, &dwValueType,
			(PBYTE)pwzBuf, pdwcbBufLen);

	if (lResult == ERROR_SUCCESS &&	dwValueType != REG_SZ)
		lResult = ERROR_CANTREAD;

	return(lResult);
}


/*
** GetDefaultRegKeyValue()
**
** Retrieves the data from a registry key's default string value.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
LONG GetDefaultRegKeyValue(HKEY hkeyParent, PCWSTR pcwzSubKey,
                                          PWSTR pwzBuf, PDWORD pdwcbBufLen)
{
	// GetRegKeyStringValue() will verify the parameters.

	return(GetRegKeyStringValue(hkeyParent, pcwzSubKey, NULL, pwzBuf,
			pdwcbBufLen));
}

/***************************** Private Functions *****************************/

/*
** ParseIconEntry()
**
**
** Arguments:
**
** Returns:       S_OK if icon entry parsed successfully.
**                S_FALSE if not (empty string).
**                (get 0 if icon index empty, or
**                 if icon index parsing fails)
**
** Side Effects:  The contents of pwzIconEntry are modified.
**
*/
HRESULT ParseIconEntry(LPWSTR pwzIconEntry, PINT pniIcon)
{
	HRESULT hr = S_OK;
	LPWSTR pwzComma;

	// caller GetGenericIcon() will verify the parameters.

	pwzComma = wcschr(pwzIconEntry, L',');

	if (pwzComma)
	{
		*pwzComma++ = L'\0';
		LPWSTR pwzStopString=NULL;
		*pniIcon = (int) wcstol(pwzComma, &pwzStopString, 10);
	}
	else
	{
		*pniIcon = 0;
	}

	TrimWhiteSpace(pwzIconEntry);

	if (pwzIconEntry[0] == L'\0')
	{
		hr = S_FALSE;
	}

	ASSERT(IsValidIconIndex(hr, pwzIconEntry, MAX_PATH, *pniIcon));

	return(hr);
}


/*
** GetFallBackGenericIcon()
**
**
** Arguments:
**
** Returns:       S_OK if fallback generic icon information retrieved
**                successfully.
**                E_FAIL if not.
**
** Side Effects:  none
*/
HRESULT GetFallBackGenericIcon(LPWSTR pwzIconFile,
                                               UINT ucbIconFileBufLen,
                                               PINT pniIcon)
{
	HRESULT hr = S_OK;

	// Fall back to first icon in this module.
	// caller GetGenericIcon() will verify the parameters.

	if (ucbIconFileBufLen >= ( sizeof(s_cwzGenericIconFile) / sizeof(WCHAR) ))
	{
		wcscpy(pwzIconFile, s_cwzGenericIconFile);
		*pniIcon = s_ciGenericIconFileIndex;

	}
	else
	{
		hr = E_FAIL;
	}

	ASSERT(IsValidIconIndex(hr, pwzIconFile, ucbIconFileBufLen, *pniIcon));

	return(hr);
}


/*
** GetGenericIcon()
**
**
** Arguments:
**
** Returns:       S_OK if generic icon information retrieved successfully.
**                Otherwise error (E_FAIL).
**
** Side Effects:  none
*/
// assumptions: always structure the reg key value and fallback path so that the iconfile
//       can be found by the shell!!
//       should also consider making it a fully qualify path
//       finally the iconfile must exist
HRESULT GetGenericIcon(LPWSTR pwzIconFile,
                                       UINT ucbIconFileBufLen, PINT pniIcon)
{
	HRESULT hr = S_OK;
	DWORD dwcbLen = ucbIconFileBufLen;

	// caller GetIconLocation() will verify parameters

	ASSERT(IS_VALID_HANDLE(g_hkeySettings, KEY));

	if (GetDefaultRegKeyValue(g_hkeySettings, g_cwzDefaultIconKey, pwzIconFile, &dwcbLen)
			== ERROR_SUCCESS)
		hr = ParseIconEntry(pwzIconFile, pniIcon);
	else
	{
		// no icon entry
		hr = S_FALSE;
	}

	if (hr == S_FALSE)
		hr = GetFallBackGenericIcon(pwzIconFile, ucbIconFileBufLen, pniIcon);

	ASSERT(IsValidIconIndex(hr, pwzIconFile, ucbIconFileBufLen, *pniIcon));

	return(hr);
}


/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetIconLocation(UINT uInFlags,
                                                      LPWSTR pwzIconFile,
                                                      UINT ucbIconFileBufLen,
                                                      PINT pniIcon,
                                                      PUINT puOutFlags)
{
	// is there any pref hit by doing this logic/probing here?
	//  maybe this can be done in IPersistFile::Load instead?

	// always attempt to return S_OK or S_FALSE
	// only exception is that one case of E_INVALIDARG right below
	HRESULT hr=S_OK;

	if (!pwzIconFile || !pniIcon || ucbIconFileBufLen <= 0)
	{
		// should this return S_FALSE anyway so that the default shell icon is used?
		hr = E_INVALIDARG;
		goto exit;
	}

	if (IS_FLAG_CLEAR(uInFlags, GIL_OPENICON))
	{
		// .. this get the path ...
		hr = GetIconLocation(pwzIconFile, ucbIconFileBufLen, pniIcon);

		if (hr == S_OK && GetFileAttributes(pwzIconFile) == (DWORD)-1)
		{
			// if the file specified by iconfile does not exist, try again in working dir
			// it can be a relative path...

			// see note in shlink.cpp for string array size
			LPWSTR pwzWorkingDir = new WCHAR[ucbIconFileBufLen];

			hr = GetWorkingDirectory(pwzWorkingDir, ucbIconFileBufLen);
			if (hr != S_OK)
				hr = S_FALSE;
			else
			{
				LPWSTR pwzPath = new WCHAR[ucbIconFileBufLen];

				// working dir does not end w/ '\'
				_snwprintf(pwzPath, ucbIconFileBufLen, L"%s\\%s", pwzWorkingDir, pwzIconFile);

				if (GetFileAttributes(pwzPath) == (DWORD)-1)
					hr = S_FALSE;
				else
					wcscpy(pwzIconFile, pwzPath);

				delete pwzPath;
			}

			delete pwzWorkingDir;
		}

		// BUGBUG?: change to '!= S_OK'?
		// no need because GetIconLocation(,,) only returns S_OK/S_FALSE here
		if (hr == S_FALSE)
		{
			if (m_pwzPath)
			{
				// no icon file, use the entry point...
				// BUGBUG?: passing NULL as PWIN32_FIND_DATA will assert..
				hr = GetPath(pwzIconFile, ucbIconFileBufLen, NULL, SLGP_SHORTPATH); //?????? 0);
				if (hr != S_OK || GetFileAttributes(pwzIconFile) == (DWORD)-1)
					hr = S_FALSE;

				*pniIcon = 0;
			}
			/*else
				hr = S_FALSE;*/

			if (hr == S_FALSE)
			{
				// ... there's nothing?
				// Use generic URL icon.

				// see assumptions on GetGenericIcon()
				hr = GetGenericIcon(pwzIconFile, ucbIconFileBufLen, pniIcon);

				if (FAILED(hr))
					// worst case: ask shell to use its generic icon
					hr = S_FALSE;
			}
		}
	}
	else
		// No "open look" icon.
		hr = S_FALSE;

	if (hr != S_OK)
	{
		// see shelllink?
		if (ucbIconFileBufLen > 0)
			*pwzIconFile = L'\0';

		*pniIcon = 0;
	}

exit:
	if (puOutFlags)
		*puOutFlags = 0;
	// ignore puOutFlags == NULL case

	ASSERT(IsValidIconIndex(hr, pwzIconFile, ucbIconFileBufLen, *pniIcon))// &&

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::Extract(LPCWSTR pcwzIconFile,
                                                    UINT uiIcon,
                                                    HICON* phiconLarge,
                                                    HICON* phiconSmall,
                                                    UINT ucIconSize)
{
	HRESULT hr;

	ASSERT(IsValidIconIndex(S_OK, pcwzIconFile, MAX_PATH, uiIcon));

	// FEATURE: Validate ucIconSize here.

	if (phiconLarge)
		*phiconLarge = NULL;
	if (phiconSmall)
		*phiconSmall = NULL;

	// Use caller's default implementation of ExtractIcon().
	// GetIconLocation() should return good path and index

	hr = S_FALSE;

	ASSERT((hr == S_OK &&
		IS_VALID_HANDLE(*phiconLarge, ICON) &&
		IS_VALID_HANDLE(*phiconSmall, ICON)) ||
		(hr != S_OK &&
		! *phiconLarge &&
		! *phiconSmall));

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\shortcut\refcount.cpp ===
/*
 * refcount.cpp - RefCount class implementation.
 */


/* Headers
 **********/

#include "project.hpp" // for ULONG_MAX...
#include "refcount.hpp"

extern ULONG DllAddRef(void);
extern ULONG DllRelease(void);

/********************************** Methods **********************************/


RefCount::RefCount(void)
{
	// Don't validate this until after initialization.

	m_ulcRef = 1;
	DllAddRef();

	return;
}


RefCount::~RefCount(void)
{
	// m_ulcRef may be any value.

	DllRelease();

	return;
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
	ULONG ulRet = 0;

	// this is really bad... returns an error of some kind
	if(m_ulcRef >= ULONG_MAX)
	{
		ulRet = 0;
		goto exit;
	}

	m_ulcRef++;

	ulRet = m_ulcRef;
exit:
	return(ulRet);
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
	ULONG ulcRef;

	if (m_ulcRef > 0)
		m_ulcRef--;

	ulcRef = m_ulcRef;

	if (! ulcRef)
		delete this;

	return(ulcRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\includes\version.h ===
/**
 * Version strings for Project CFusionShortcut
 * 
 * Copyright (c) 2001 Microsoft Corporation
 */

// Standard version includes

#pragma once

#include <winver.h>
#include <ntverp.h>

//
// Version
//
// Version numbers can be assigned in newbuild.cmd
//

#ifndef FUS_VER_MAJORVERSION
#define FUS_VER_MAJORVERSION 1
#endif

#ifndef FUS_VER_MINORVERSION
#define FUS_VER_MINORVERSION 0
#endif

#ifndef FUS_VER_PRODUCTBUILD
#define FUS_VER_PRODUCTBUILD 0
#endif

#ifndef FUS_VER_PRODUCTBUILD_QFE
#define FUS_VER_PRODUCTBUILD_QFE 0
#endif

//
// Allow a component to override values in individual rc files
// by checking if these are already defined
//
#ifndef FUS_VER_PRODUCTNAME_STR
#define FUS_VER_PRODUCTNAME_STR      "Microsoft (R) Fusion Network Services Shell Support"
#endif

#ifndef FUS_VER_INTERNALNAME_STR
#define FUS_VER_INTERNALNAME_STR     "FNSSHELL"
#endif

// the followings are defined in individual RC files:
//      FUS_VER_ORIGINALFILENAME_STR
//      FUS_VER_FILEDESCRIPTION_STR

//
// Don't edit the remainder of this file to change version values.
// Edit above instead.
//

#if FUSBLDTYPE_FREE
#define FUS_BLDTYPE_STR     "Free"
#elif FUSBLDTYPE_ICECAP
#define FUS_BLDTYPE_STR     "Icecap"
#elif FUSBLDTYPE_RETAIL
#define FUS_BLDTYPE_STR     "Retail"
#else //FUSBLDTYPE_DEBUG
#define FUS_BLDTYPE_STR     "Debug"
#endif

//
// undefine these values as some are defined in sdk\inc\ntverp.h
//

#ifdef VER_MAJORVERSION
#undef VER_MAJORVERSION
#endif

#ifdef VER_MINORVERSION
#undef VER_MINORVERSION
#endif

#ifdef VER_PRODUCTBUILD
#undef VER_PRODUCTBUILD
#endif

#ifdef VER_PRODUCTBUILD_QFE
#undef VER_PRODUCTBUILD_QFE
#endif

#ifdef VER_PRODUCTNAME_STR
#undef VER_PRODUCTNAME_STR
#endif

#ifdef VER_INTERNALNAME_STR
#undef VER_INTERNALNAME_STR
#endif

#ifdef VER_ORIGINALFILENAME_STR
#undef VER_ORIGINALFILENAME_STR
#endif

#ifdef VER_FILEDESCRIPTION_STR
#undef VER_FILEDESCRIPTION_STR
#endif

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif

#ifdef VER_FILEVERSION_STR
#undef VER_FILEVERSION_STR
#endif

#ifdef VER_FILEVERSION
#undef VER_FILEVERSION
#endif

#ifdef VER_FILETYPE
#undef VER_FILETYPE
#endif

#ifdef VER_FILESUBTYPE
#undef VER_FILESUBTYPE
#endif

#define VER_MAJORVERSION         FUS_VER_MAJORVERSION
#define VER_MINORVERSION         FUS_VER_MINORVERSION
#define VER_PRODUCTBUILD         FUS_VER_PRODUCTBUILD
#define VER_PRODUCTBUILD_QFE     FUS_VER_PRODUCTBUILD_QFE

#define VER_PRODUCTNAME_STR      FUS_VER_PRODUCTNAME_STR
#define VER_INTERNALNAME_STR     FUS_VER_INTERNALNAME_STR
#define VER_ORIGINALFILENAME_STR FUS_VER_ORIGINALFILENAME_STR
#define VER_FILEDESCRIPTION_STR  FUS_VER_FILEDESCRIPTION_STR

#define CONCAT5HELPER(a, b, c, d, e)      #a "." #b "." #c "." #d " " e
#define CONCAT5(a, b, c, d, e)            CONCAT5HELPER(a, b, c, d, e)

#define CONCAT5HELPER_L(a, b, c, d, e)    L ## #a L"." L ## #b L"." L ## #c L"." L ## #d L" " L ## e
#define CONCAT5_L(a, b, c, d, e)          CONCAT5HELPER_L(a, b, c, d, e)

#define VER_PRODUCTVERSION_STR   CONCAT5(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, FUS_BLDTYPE_STR)
#define VER_PRODUCTVERSION_STR_L CONCAT5_L(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, FUS_BLDTYPE_STR)

#define VER_PRODUCTVERSION       VER_MAJORVERSION,VER_MINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#define VER_FILEVERSION_STR      CONCAT5(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, FUS_BLDTYPE_STR)
#define VER_FILEVERSION_STR_L    CONCAT5_L(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, FUS_BLDTYPE_STR)

#define VER_FILEVERSION          VER_MAJORVERSION,VER_MINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          VFT2_UNKNOWN
//#define VER_FILESUBTYPE             VFT_UNKNOWN


// Standard NT build defines

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\shortcut\persist.cpp ===
/*
 * persist.cpp - IPersist, IPersistFile implementations for
 *               CFusionShortcut class.
 */


/* Headers
 **********/

#include "project.hpp" // for GetLastWin32Error

/* Global Constants
 *******************/

const WCHAR g_cwzDefaultFileNamePrompt[]  = L"*.manifest";

// ----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CFusionShortcut::GetCurFile(LPWSTR pwzFile,
                                                       UINT ucbLen)
{
	HRESULT hr=S_OK;

	if (m_pwzShortcutFile)
	{
		wcsncpy(pwzFile, m_pwzShortcutFile, ucbLen-1);
		pwzFile[ucbLen-1] = L'\0';
	}
	else
		hr = S_FALSE;

	ASSERT(hr == S_OK ||
			hr == S_FALSE);

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::Dirty(BOOL bDirty)
{
	HRESULT hr=S_OK;

	if (bDirty)
	{
		SET_FLAG(m_dwFlags, FUSSHCUT_FL_DIRTY);
		//m_dwFlags = FUSSHCUT_FL_DIRTY;
	}
	else
	{
		CLEAR_FLAG(m_dwFlags, FUSSHCUT_FL_DIRTY);
		//m_dwFlags = FUSSHCUT_FL_NOTDIRTY;
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetClassID(CLSID* pclsid)
{
	HRESULT hr=S_OK;

	if (pclsid == NULL)
		hr = E_INVALIDARG;
	else
		*pclsid = CLSID_FusionShortcut;

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::IsDirty(void)
{
	HRESULT hr;

	if (IS_FLAG_SET(m_dwFlags, FUSSHCUT_FL_DIRTY))
	//if (m_dwFlags == FUSSHCUT_FL_DIRTY)
		// modified
		hr = S_OK;
	else
		// not modified
		hr = S_FALSE;

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::Save(LPCOLESTR pcwszFile,
                                                 BOOL bRemember)
{
	// BUGBUG: no save for now!
	return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SaveCompleted(LPCOLESTR pcwszFile)
{
	// BUGBUG: no save for now!
	return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::Load(LPCOLESTR pcwszFile,
                                                 DWORD dwMode)
{
	HRESULT hr = S_OK;
	LPWSTR pwzWorkingDir = NULL;
	LPWSTR pwzValue = NULL;
	DWORD dwCC = 0;
	LPASSEMBLY_MANIFEST_IMPORT	pManImport = NULL;
	LPASSEMBLY_CACHE_IMPORT   pCacheImport = NULL;
	LPMANIFEST_APPLICATION_INFO pAppInfo = NULL;
	LPDEPENDENT_ASSEMBLY_INFO pDependAsmInfo = NULL;

	// FEATURE: Validate dwMode here.
	// FEAUTRE: Implement dwMode flag support.

	if (!pcwszFile)
	{
		hr = E_INVALIDARG;
		goto exit;
	}

	// a hack check
	// BUGBUG?: this shouldn't be called more than once?
	// BUT: the rest of this code works even if called multiple times
	if (m_pwzWorkingDirectory)
	{
		hr = E_FAIL;
		goto exit;
	}

	// store the shortcut file name
	if (m_pwzShortcutFile)
		delete m_pwzShortcutFile;

	// (+ 1) for null terminator.
    m_pwzShortcutFile = new(WCHAR[wcslen(pcwszFile) + 1]);
    if (m_pwzShortcutFile)
    {
    	wcscpy(m_pwzShortcutFile, pcwszFile);
    }
    else
    {
    	hr = E_OUTOFMEMORY;
    	goto exit;
    }

	if (FAILED(hr = CreateAssemblyManifestImport(&pManImport, m_pwzShortcutFile)))
	    goto exit;

    // check this 1st for pref...
	if (FAILED(hr=pManImport->GetManifestApplicationInfo(&pAppInfo)))
		goto exit;

	// can't continue without this...
	if (hr==S_FALSE)
	{
	    hr = E_FAIL;
	    goto exit;
	}

	if (m_pIdentity)
		m_pIdentity->Release();

	if (FAILED(hr = pManImport->GetAssemblyIdentity(&m_pIdentity)))
		goto exit;

	// can't continue without a cache dir, 'cos otherwise unknown behavior
	// BUGBUG: should check/code to ensure some continue to work
	//    even without the complete name, eg. shell icon path, part of infotip
    if (FAILED(hr = CreateAssemblyCacheImport(&pCacheImport, m_pIdentity, CACHEIMP_CREATE_RESOLVE_REF_EX)))
        goto exit;

    pCacheImport->GetManifestFileDir(&pwzWorkingDir, &dwCC);
    if (dwCC < 2)
    {
        // this should never happen
        hr = E_UNEXPECTED;
        goto exit;
    }
    // remove last L'\\'
    *(pwzWorkingDir+dwCC-2) = L'\0';

	if (FAILED(hr=SetWorkingDirectory(pwzWorkingDir)))
		goto exit;

	// ignore failure
	pAppInfo->Get(MAN_APPLICATION_SHOWCOMMAND, &pwzValue, &dwCC);
	if (pwzValue != NULL)
	{
		// default is normal
		int nShowCmd = SW_SHOWNORMAL;

		if (!_wcsicmp(pwzValue, L"maximized"))
		{
			nShowCmd = SW_SHOWMAXIMIZED;
		}
		else if (!_wcsicmp(pwzValue, L"minimized"))
		{
			nShowCmd = SW_SHOWMINIMIZED;
		}

		if (FAILED(hr=SetShowCmd(nShowCmd)))
			goto exit;

		delete pwzValue;
	}

	// ignore failure
	pAppInfo->Get(MAN_APPLICATION_ENTRYPOINT, &pwzValue, &dwCC);
	if (pwzValue != NULL)
	{
        size_t ccWorkingDir = wcslen(pwzWorkingDir)+1;
        size_t ccEntryPoint = wcslen(pwzValue)+1;
        LPWSTR pwzTemp = new WCHAR[ccWorkingDir+ccEntryPoint];	// 2 strings + '\\' + '\0'

        // like .lnk or .url, entry point is under wzWorkingDir
        // 'path' is the target file of the shortcut, ie. the entry point of the app in this case

        if (pwzTemp == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        memcpy(pwzTemp, pwzWorkingDir, ccWorkingDir * sizeof(WCHAR));
        if (!PathAppend(pwzTemp, pwzValue))
            hr = E_FAIL;
        else
            hr=SetPath(pwzTemp);

        delete pwzTemp;
        if (FAILED(hr))
            goto exit;

        delete pwzValue;
	}
	//else
	// ... if no entry point leave it blank so that the default icon will be used

	// ignore failure
	pAppInfo->Get(MAN_APPLICATION_FRIENDLYNAME, &pwzValue, &dwCC);
	if (pwzValue != NULL)
	{
		if (FAILED(hr=SetDescription(pwzValue)))
			goto exit;

		delete pwzValue;
	}

	// ignore failure
	pAppInfo->Get(MAN_APPLICATION_ICONFILE, &pwzValue, &dwCC);
	if (pwzValue != NULL)
	{
		LPWSTR pwzValue2 = NULL;

		pAppInfo->Get(MAN_APPLICATION_ICONINDEX, &pwzValue2, &dwCC);
		if (pwzValue2 != NULL)
		{
			LPWSTR pwzStopString = NULL;
			hr=SetIconLocation(pwzValue, (int) wcstol(pwzValue2, &pwzStopString, 10));
			delete pwzValue2;
			if (FAILED(hr))
				goto exit;
		}

		delete pwzValue;
	}

	// ignore failure
	pAppInfo->Get(MAN_APPLICATION_HOTKEY, &pwzValue, &dwCC);
	if (pwzValue != NULL)
	{
		LPWSTR pwzStopString = NULL;
		if (FAILED(hr=SetHotkey((WORD) wcstol(pwzValue, &pwzStopString, 10))))
			goto exit;

		delete pwzValue;
	}

    // note: this method of getting the codebase is only valid for desktop (and subscription) manifests
    //    thus the hardcoded index '0'
	// ignore failure
	pManImport->GetNextAssembly(0, &pDependAsmInfo);
	if (pDependAsmInfo != NULL)
	{
    	pDependAsmInfo->Get(DEPENDENT_ASM_CODEBASE, &pwzValue, &dwCC);
    	if (pwzValue != NULL)
	    {
    		if (FAILED(hr=SetCodebase(pwzValue)))
    			goto exit;

    		delete pwzValue;
    	}
	}

    pwzValue = NULL;

exit:
	if (pwzValue != NULL)
		delete pwzValue;

	if (pwzWorkingDir != NULL)
		delete pwzWorkingDir;

    if (pDependAsmInfo != NULL)
        pDependAsmInfo->Release();
    
	if (pAppInfo != NULL)
		pAppInfo->Release();

    if (pCacheImport != NULL)
        pCacheImport->Release();

	if (pManImport != NULL)
		pManImport->Release();

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetCurFile(LPOLESTR *ppwszFile)
{
	HRESULT hr = S_OK;
	LPOLESTR pwszTempFile;

	if (ppwszFile == NULL)
	{
		hr = E_INVALIDARG;
		goto exit;
	}
	// BUGBUG?: ensure *ppwszFile NULL?

	if (m_pwzShortcutFile)
	{
		pwszTempFile = m_pwzShortcutFile;
	}
	else
	{
		pwszTempFile = (LPWSTR) g_cwzDefaultFileNamePrompt;

		hr = S_FALSE;
	}

	*ppwszFile = (LPOLESTR) CoTaskMemAlloc((wcslen(pwszTempFile) + 1) * sizeof(*pwszTempFile));

	if (*ppwszFile)
		wcscpy(*ppwszFile, pwszTempFile);
	else
		hr = E_OUTOFMEMORY;

exit:
	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\shortcut\infotip.cpp ===
/*
 * infotip.cpp - IQueryInfo implementation
 */


/* Headers
 **********/

#include "project.hpp"
#include <stdio.h>    // for _snwprintf
#include "shellres.h"

const UINT s_ucMaxNameLen		= 20;
const UINT s_ucMaxTypeLen		= 10;
const UINT s_ucMaxLocationLen	= 15;
const UINT s_ucMaxCodebaseLen	= 15;

// see GetInfoTip() for how the tip string/string-length is assembled
const UINT s_ucMaxTipLen		= s_ucMaxNameLen+s_ucMaxTypeLen+s_ucMaxLocationLen \
								+s_ucMaxCodebaseLen+DISPLAYNAMESTRINGLENGTH \
								+TYPESTRINGLENGTH+MAX_PATH+MAX_URL_LENGTH+8;

extern HINSTANCE g_DllInstance;

// ----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CFusionShortcut::GetInfoFlags(DWORD *pdwFlags)
{
	if (!pdwFlags)
		*pdwFlags = 0;

	return S_OK; //E_NOTIMPL?
}

// ----------------------------------------------------------------------------

// BUGBUG?: maybe replace the use of g_cwzEmptyString with L"(unknown)"?
HRESULT STDMETHODCALLTYPE CFusionShortcut::GetInfoTip(DWORD dwFlags, LPWSTR *ppwszTip)
{
	HRESULT hr = S_OK;
  	LPMALLOC lpMalloc = NULL;

  	WCHAR wzTip[s_ucMaxTipLen];
  	WCHAR wzNameHint[s_ucMaxNameLen];
  	WCHAR wzTypeHint[s_ucMaxTypeLen];
  	WCHAR wzLocationHint[s_ucMaxLocationLen];
  	WCHAR wzCodebaseHint[s_ucMaxCodebaseLen];

	LPWSTR pwzName = (m_pwzDesc ? m_pwzDesc : (LPWSTR) g_cwzEmptyString);
	LPWSTR pwzLocation = (m_pwzPath ? m_pwzPath : (LPWSTR) g_cwzEmptyString);
	LPWSTR pwzCodebase = (m_pwzCodebase ? m_pwzCodebase : (LPWSTR) g_cwzEmptyString);
	LPWSTR pwzAppType = NULL;

	LPASSEMBLY_IDENTITY pId = NULL;

	// dwFlags ignored

	if (ppwszTip)
		*ppwszTip = NULL;
	else
	{
		hr = E_INVALIDARG;
		goto exit;
	}

	// Allocate a shell memory object.
	hr = SHGetMalloc (&lpMalloc);
	if (FAILED (hr))
		goto exit;

	wzTip[0] = L'\0';

	// load resources
	if (!LoadString(g_DllInstance, IDS_TIP_NAME, wzNameHint, s_ucMaxNameLen))
	{
		// do not fail
		wzNameHint[0] = L'\0';
	}

	if (!LoadString(g_DllInstance, IDS_TIP_TYPE, wzTypeHint, s_ucMaxTypeLen))
	{
		// do not fail
		wzTypeHint[0] = L'\0';
	}

	if (!LoadString(g_DllInstance, IDS_TIP_LOCATION, wzLocationHint, s_ucMaxLocationLen))
	{
		// do not fail
		wzLocationHint[0] = L'\0';
	}

	if (!LoadString(g_DllInstance, IDS_TIP_CODEBASE, wzCodebaseHint, s_ucMaxCodebaseLen))
	{
		// do not fail
		wzCodebaseHint[0] = L'\0';
	}

	if (SUCCEEDED(hr = GetAssemblyIdentity(&pId)))
	{
	    DWORD ccString = 0;

		if (FAILED(pId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE, &pwzAppType, &ccString)))
			pwzAppType = NULL;

		pId->Release();
		pId = NULL;
	}
	
	// ignore error
	// BUGBUG?: "(null)" is displayed if m_pwzDesc or m_pwzPath == NULL...
	_snwprintf(wzTip, s_ucMaxTipLen, L"%s %s\n%s %s\n%s %s\n%s %s",
		wzNameHint, pwzName, wzTypeHint, (pwzAppType ? pwzAppType : g_cwzEmptyString), wzLocationHint, pwzLocation, wzCodebaseHint, pwzCodebase);
		
	// Get some memory
	*ppwszTip = (LPWSTR) lpMalloc->Alloc ((wcslen(wzTip)+1)*sizeof(WCHAR));
	if (! *ppwszTip)
	{
		hr = E_OUTOFMEMORY;
		goto exit; // Error - could not allocate memory
	}

	wcscpy(*ppwszTip, wzTip);

exit:
	if (pwzAppType)
		delete pwzAppType;

	if (lpMalloc)
		lpMalloc->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\tools\mangen\md5.h ===
#ifndef MD5_H
#define MD5_H

#ifdef __alpha
typedef unsigned int uint32;
#else
typedef unsigned long uint32;
#endif

struct MD5Context {
        uint32 buf[4];
        uint32 bits[2];
        unsigned char in[64];
};

//extern void MD5Init();
void MD5Init(struct MD5Context *ctx);
//extern void MD5Update();
void MD5Update(struct MD5Context *ctx, unsigned char *buf, unsigned len);
//extern void MD5Final();
void MD5Final(unsigned char digest[16], struct MD5Context *ctx);
//extern void MD5Transform();
void MD5Transform(uint32 buf[4], uint32 in[16]);

#endif /* !MD5_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\shortcut\propsht.cpp ===
/*
 * propsht.cpp - IPropSheetExt implementation for CFusionShortcut class.
 */



// * NOTE!!: this code is incomplete. Also error checking (any leak?),
// *        restructuring (for better coding/efficiency) to be done.
// *        Make 'Get'/'Set' private and use 'friend'?


//BUGBUG: need wrappers around calls to m_pIdentity->SetAttribute() to also call Dirty(TRUE)...


// * this file uses CharNext etc as it needs User32 anyway *

/* Headers
 **********/

#include "project.hpp"

#include <prsht.h>

#include "shellres.h"

extern "C" WINSHELLAPI int   WINAPI PickIconDlg(HWND hwnd, LPWSTR pwzIconPath, UINT cbIconPath, int *piIconIndex);

extern HINSTANCE g_DllInstance;

/* Types
 ********/

// Fusion Shortcut property sheet data

typedef enum _fusshcutpropsheetpgs
{
	FUSIONSHCUT_PS_SHCUT_PAGE	= 0x0000,
	FUSIONSHCUT_PS_REF_PAGE 		= 0x0001,

	ALL_FUSIONSHCUT_PS_PAGES
}
FUSIONSHCUTPSPAGES;

typedef struct _fsps
{
	CFusionShortcut* pfusshcut;

	WCHAR rgchIconFile[MAX_PATH];

	int niIcon;

	FUSIONSHCUTPSPAGES eCurPage;
}
FSPS;
DECLARE_STANDARD_TYPES(FSPS);

typedef FSPS* PFSPS;

/* Module Constants
 *******************/

// Tray notification window class

//copied from shell32!
#define WNDCLASS_TRAYNOTIFY     L"Shell_TrayWnd"    //internal_win40
const WCHAR s_cwzTrayNotificationClass[]  = WNDCLASS_TRAYNOTIFY;

// HACKHACK: WMTRAY_SCREGISTERHOTKEY and WMTRAY_SCUNREGISTERHOTKEY are stolen
// from shelldll\link.c.
typedef const UINT CUINT;
CUINT WMTRAY_SCREGISTERHOTKEY			= (WM_USER + 233);
CUINT WMTRAY_SCUNREGISTERHOTKEY			= (WM_USER + 234);

// show commands - N.b., the order of these constants must match the order of
// the corresponding IDS_ string table constants.

const UINT s_ucMaxShowCmdLen			= MAX_PATH;
const UINT s_ucMaxTypeLen				= TYPESTRINGLENGTH;

const int s_rgnShowCmds[] =
{
	SW_SHOWNORMAL,
	SW_SHOWMINNOACTIVE,
	SW_SHOWMAXIMIZED
};


/*
** ExtractFileName()
**
** Extracts the file name from a path name.
**
** Arguments:     pcwzPathName - path string from which to extract file name
**
** Returns:       Pointer to file name in path string.
**
** Side Effects:  none
*/
#define BACKSLASH		L'/'
#define SLASH			L'\\'
#define COLON			L':'
#define IS_SLASH(ch)	((ch) == SLASH || (ch) == BACKSLASH)
PCWSTR ExtractFileName(PCWSTR pcwzPathName)
{
	PCWSTR pcwzLastComponent;
	PCWSTR pcwz;

	for (pcwzLastComponent = pcwz = pcwzPathName; *pcwz; pcwz = CharNext(pcwz))
	{
		if (IS_SLASH(*pcwz) || *pcwz == COLON)
			pcwzLastComponent = CharNext(pcwz);
	}

	ASSERT(IsValidPath(pcwzLastComponent));

	return(pcwzLastComponent);
}

/***************************** Private Functions *****************************/


UINT CALLBACK FSPSCallback(HWND hwnd, UINT uMsg,
                    LPPROPSHEETPAGE ppsp)
{
	// this is called after FSPS_DlgProc WM_DESTROY (ie. FSPS_Destroy)
	// this func should do the frees/releases

	UINT uResult = TRUE;
	PFSPS pfsps = (PFSPS)(ppsp->lParam);

	// uMsg may be any value.

	ASSERT(! hwnd ||
		IS_VALID_HANDLE(hwnd, WND));

	switch (uMsg)
	{
		case PSPCB_CREATE:
			// from MSDN: A dialog box for a page is being created.
			// Return nonzero to allow it to be created, or zero to prevent it.
			break;

		case PSPCB_RELEASE:
			// ???? need checking if NULL

			pfsps->pfusshcut->Release();

			// free the FSPS structure, this is created in AddFSPS
			// delete only after the ref is removed
			delete pfsps;
			ppsp->lParam = NULL;

			break;

		default:
			// ignore other msg - unhandled
			break;
	}

	return(uResult);
}


void SetFSPSIcon(HWND hdlg, HICON hicon)
{
	HICON hiconOld;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));
	ASSERT(IS_VALID_HANDLE(hicon, ICON));

	hiconOld = (HICON)SendDlgItemMessage(hdlg, IDD_ICON, STM_SETICON,
		(WPARAM)hicon, 0);

	if (hiconOld)
		DestroyIcon(hiconOld);

	return;
}


void SetFSPSFileNameAndIcon(HWND hdlg)
{
	HRESULT hr;
	CFusionShortcut* pfusshcut;
	WCHAR rgchFile[MAX_PATH];

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

	hr = pfusshcut->GetCurFile(rgchFile, sizeof(rgchFile) / sizeof(WCHAR));

	if (hr == S_OK)
	{
		SHFILEINFO shfi;
		DWORD_PTR dwResult;

		dwResult = SHGetFileInfo(rgchFile, 0, &shfi, sizeof(shfi),
			(SHGFI_DISPLAYNAME | SHGFI_ICON));

		if (dwResult)
		{
			LPWSTR pwzFileName;

			pwzFileName = (LPWSTR)ExtractFileName(shfi.szDisplayName);

			EVAL(SetDlgItemText(hdlg, IDD_NAME, pwzFileName));

			SetFSPSIcon(hdlg, shfi.hIcon);
		}
		else
		{
			hr = E_FAIL;

		}
	}


	if (hr != S_OK)
		EVAL(SetDlgItemText(hdlg, IDD_NAME, g_cwzEmptyString));

	return;
}


void SetFSPSWorkingDirectory(HWND hdlg)
{
	CFusionShortcut* pfusshcut;
	HRESULT hr;
	WCHAR rgchWorkingDirectory[MAX_PATH];

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

	hr = pfusshcut->GetWorkingDirectory(rgchWorkingDirectory,
			sizeof(rgchWorkingDirectory) / sizeof(WCHAR));

	if (hr == S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_START_IN, rgchWorkingDirectory));
	}
	else
	{
		EVAL(SetDlgItemText(hdlg, IDD_START_IN, g_cwzEmptyString));
	}

	return;
}


void InitFSPSHotkey(HWND hdlg)
{
	CFusionShortcut* pfusshcut;
	WORD wHotkey;
	HRESULT hr;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	// Set hotkey combinations.

	SendDlgItemMessage(hdlg, IDD_HOTKEY, HKM_SETRULES,
		(HKCOMB_NONE | HKCOMB_A | HKCOMB_C | HKCOMB_S),
		(HOTKEYF_CONTROL | HOTKEYF_ALT));

	// Set current hotkey.

	pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

	hr = pfusshcut->GetHotkey(&wHotkey);
	SendDlgItemMessage(hdlg, IDD_HOTKEY, HKM_SETHOTKEY, wHotkey, 0);

	return;
}


void InitFSPSShowCmds(HWND hdlg)
{
	int niShowCmd;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	for (niShowCmd = IDS_SHOW_NORMAL;
		niShowCmd <= IDS_SHOW_MAXIMIZED;
		niShowCmd++)
	{
		WCHAR rgchShowCmd[s_ucMaxShowCmdLen];

		if (LoadString(g_DllInstance, niShowCmd, rgchShowCmd,	//MLLoadStringA
			s_ucMaxShowCmdLen))//sizeof(rgchShowCmd)))
		{
			SendDlgItemMessage(hdlg, IDD_SHOW_CMD, CB_ADDSTRING, 0,
				(LPARAM)rgchShowCmd);
		}
	}

	return;
}


void SetFSPSShowCmd(HWND hdlg)
{
	CFusionShortcut* pfusshcut;
	int nShowCmd;
	int i;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

	pfusshcut->GetShowCmd(&nShowCmd);

	for (i = 0; i < ARRAY_ELEMENTS(s_rgnShowCmds); i++)
	{
		if (s_rgnShowCmds[i] == nShowCmd)
			break;
	}

	if (i >= ARRAY_ELEMENTS(s_rgnShowCmds))
	{
		ASSERT(i == ARRAY_ELEMENTS(s_rgnShowCmds));

		i = 0; // default is 0 == 'normal'
	}

	SendDlgItemMessage(hdlg, IDD_SHOW_CMD, CB_SETCURSEL, i, 0);

	return;
}


void SetFSPSFriendlyName(HWND hdlg)
{
	CFusionShortcut* pfusshcut;
	HRESULT hr;
	WCHAR rgchString[DISPLAYNAMESTRINGLENGTH];

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

	hr = pfusshcut->GetDescription(rgchString, sizeof(rgchString) / sizeof(WCHAR));

	if (hr == S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_DISPLAY_NAME, rgchString));
	}
	else
	{
		EVAL(SetDlgItemText(hdlg, IDD_DISPLAY_NAME, g_cwzEmptyString));
	}

	return;
}


void SetFSPSName(HWND hdlg)
{
	CFusionShortcut* pfusshcut;
	HRESULT hr;
    DWORD ccString = 0;
	LPWSTR pwzString = NULL;
	LPASSEMBLY_IDENTITY pId = NULL;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

	if (SUCCEEDED(hr = pfusshcut->GetAssemblyIdentity(&pId)))
	{
		hr = pId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwzString, &ccString);

		if (hr == S_OK)
		{
			EVAL(SetDlgItemText(hdlg, IDD_NAME, pwzString));
			delete pwzString;
		}

		pId->Release();
	}

	if (hr != S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_NAME, g_cwzEmptyString));
	}

	return;
}


void SetFSPSVersion(HWND hdlg)
{
	CFusionShortcut* pfusshcut;
	HRESULT hr;
    DWORD ccString = 0;
	LPWSTR pwzString = NULL;
	LPASSEMBLY_IDENTITY pId = NULL;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

	if (SUCCEEDED(hr = pfusshcut->GetAssemblyIdentity(&pId)))
	{
		hr = pId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION, &pwzString, &ccString);

		if (hr == S_OK)
		{
			EVAL(SetDlgItemText(hdlg, IDD_VERSION, pwzString));
			delete pwzString;
		}

		pId->Release();
	}

	if (hr != S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_VERSION, g_cwzEmptyString));
	}

	return;
}


void SetFSPSCulture(HWND hdlg)
{
	CFusionShortcut* pfusshcut;
	HRESULT hr;
    DWORD ccString = 0;
	LPWSTR pwzString = NULL;
	LPASSEMBLY_IDENTITY pId = NULL;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

	if (SUCCEEDED(hr = pfusshcut->GetAssemblyIdentity(&pId)))
	{
		hr = pId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE, &pwzString, &ccString);

		if (hr == S_OK)
		{
			EVAL(SetDlgItemText(hdlg, IDD_CULTURE, pwzString));
			delete pwzString;
		}

		pId->Release();
	}

	if (hr != S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_CULTURE, g_cwzEmptyString));
	}

	return;
}


void SetFSPSPKT(HWND hdlg)
{
	CFusionShortcut* pfusshcut;
	HRESULT hr;
    DWORD ccString = 0;
	LPWSTR pwzString = NULL;
	LPASSEMBLY_IDENTITY pId = NULL;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

	if (SUCCEEDED(hr = pfusshcut->GetAssemblyIdentity(&pId)))
	{
		hr = pId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN, &pwzString, &ccString);

		if (hr == S_OK)
		{
			EVAL(SetDlgItemText(hdlg, IDD_PKT, pwzString));
			delete pwzString;
		}

		pId->Release();
	}

	if (hr != S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_PKT, g_cwzEmptyString));
	}

	return;
}


void SetFSPSCodebase(HWND hdlg)
{
	CFusionShortcut* pfusshcut;
	HRESULT hr;
	WCHAR rgchString[MAX_URL_LENGTH];

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

	hr = pfusshcut->GetCodebase(rgchString, sizeof(rgchString) / sizeof(WCHAR));

	if (hr == S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_CODEBASE, rgchString));
	}
	else
	{
		EVAL(SetDlgItemText(hdlg, IDD_CODEBASE, g_cwzEmptyString));
	}

	return;
}


void SetFSPSEntrypoint(HWND hdlg)
{
	CFusionShortcut* pfusshcut;
	HRESULT hr;
	WCHAR rgchString[MAX_PATH];

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

	hr = pfusshcut->GetPath(rgchString, sizeof(rgchString) / sizeof(WCHAR), NULL, 0);

	if (hr == S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_ENTRYPOINT, rgchString));
	}
	else
	{
		EVAL(SetDlgItemText(hdlg, IDD_ENTRYPOINT, g_cwzEmptyString));
	}

	return;
}


void SetFSPSType(HWND hdlg)
{
	CFusionShortcut* pfusshcut;
	HRESULT hr;
    DWORD ccString = 0;
	LPWSTR pwzString = NULL;
	LPASSEMBLY_IDENTITY pId = NULL;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

	if (SUCCEEDED(hr = pfusshcut->GetAssemblyIdentity(&pId)))
	{
		hr = pId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE, &pwzString, &ccString);

		if (hr == S_OK)
		{
			EVAL(SetDlgItemText(hdlg, IDD_TYPE, pwzString));
			delete pwzString;
		}

		pId->Release();
	}

	if (hr != S_OK)
	{
		EVAL(SetDlgItemText(hdlg, IDD_TYPE, g_cwzEmptyString));
	}

	return;
}


BOOL FSPS_InitDialog(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
	// wparam may be any value.

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	// this set PROPSHEETPAGE struct to DWLP_USER
	SetWindowLongPtr(hdlg, DWLP_USER, lparam);

	// Initialize control contents.

	if (((PFSPS)(((PROPSHEETPAGE*)lparam)->lParam))->eCurPage == FUSIONSHCUT_PS_SHCUT_PAGE)
	{
		SetFSPSFileNameAndIcon(hdlg);

		// note: need limits on all editbox!
		SetFSPSFriendlyName(hdlg);

		SendDlgItemMessage(hdlg, IDD_CODEBASE, EM_LIMITTEXT, MAX_URL_LENGTH - 1, 0);
		SetFSPSCodebase(hdlg);

		//InitFSPSType(hdlg);
		SetFSPSType(hdlg);

		SendDlgItemMessage(hdlg, IDD_ENTRYPOINT, EM_LIMITTEXT, MAX_PATH - 1, 0);
		SetFSPSEntrypoint(hdlg);

		SendDlgItemMessage(hdlg, IDD_START_IN, EM_LIMITTEXT, MAX_PATH - 1, 0);
		SetFSPSWorkingDirectory(hdlg);

		InitFSPSHotkey(hdlg);

		InitFSPSShowCmds(hdlg);
		SetFSPSShowCmd(hdlg);
	}
	else if (((PFSPS)(((PROPSHEETPAGE*)lparam)->lParam))->eCurPage == FUSIONSHCUT_PS_REF_PAGE)
	{
		// note: need limits on all editbox!
		SetFSPSFriendlyName(hdlg);
		SetFSPSName(hdlg);
		SetFSPSVersion(hdlg);
		SetFSPSCulture(hdlg);
		SetFSPSPKT(hdlg);
	}
	// else do nothing?

	return(TRUE);
}


BOOL FSPS_Destroy(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
	// FSPSCallback is called after this func. The remaining frees/releases are there

	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	SetWindowLongPtr(hdlg, DWLP_USER, NULL);

	return(TRUE);
}


void FSPSChanged(HWND hdlg)
{
	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	PropSheet_Changed(GetParent(hdlg), hdlg);

	return;
}


HRESULT ChooseIcon(HWND hdlg)
{
	HRESULT hr;
	PFSPS pfsps;
	CFusionShortcut* pfusshcut;
	WCHAR rgchTempIconFile[MAX_PATH];
	int niIcon;
	UINT uFlags;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pfsps = (PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam);
	pfusshcut = pfsps->pfusshcut;

	if (pfusshcut->GetIconLocation(0, rgchTempIconFile,
			sizeof(rgchTempIconFile)/sizeof(WCHAR), &niIcon, &uFlags) != S_OK)
	{
		rgchTempIconFile[0] = '\0';
		niIcon = 0;
	}

	ASSERT(wcslen(rgchTempIconFile) < (sizeof(rgchTempIconFile)/sizeof(WCHAR)));

	// a private shell32.dll export (by ordinal)...
	if (PickIconDlg(hdlg, rgchTempIconFile, sizeof(rgchTempIconFile), &niIcon))	//??? sizeof
	{
		ASSERT(wcslen(rgchTempIconFile) < (sizeof(pfsps->rgchIconFile)/sizeof(WCHAR)));
		wcscpy(pfsps->rgchIconFile, rgchTempIconFile);
		pfsps->niIcon = niIcon;

		hr = S_OK;
	}
	else
	{
		hr = E_FAIL;
	}

	return(hr);
}


void UpdateFSPSIcon(HWND hdlg)
{
	PFSPS pfsps;
	HICON hicon;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pfsps = (PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam);
	ASSERT(pfsps->rgchIconFile[0]);

	hicon = ExtractIcon(g_DllInstance, pfsps->rgchIconFile, pfsps->niIcon);

	if (hicon)
		SetFSPSIcon(hdlg, hicon);

	return;
}


BOOL FSPS_Command(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
	BOOL bMsgHandled = FALSE;
	WORD wCmd;

	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	wCmd = HIWORD(wparam);

	switch (LOWORD(wparam))
	{
		case IDD_CODEBASE:
		case IDD_HOTKEY:
		case IDD_ENTRYPOINT:
		case IDD_START_IN:
		case IDD_DISPLAY_NAME:
		case IDD_NAME:
		case IDD_VERSION:
		case IDD_CULTURE:
		case IDD_PKT:
		case IDD_TYPE:
				if (wCmd == EN_CHANGE)
				{
					FSPSChanged(hdlg);

					bMsgHandled = TRUE;
				}
				break;

		case IDD_SHOW_CMD:
				if (wCmd == LBN_SELCHANGE)
				{
					FSPSChanged(hdlg);

					bMsgHandled = TRUE;
				}
				break;

		case IDD_CHANGE_ICON:
				// Ignore return value.
				if (ChooseIcon(hdlg) == S_OK)
				{
					UpdateFSPSIcon(hdlg);
					FSPSChanged(hdlg);
				}
				bMsgHandled = TRUE;
				break;

		default:
				break;
	}

	return(bMsgHandled);
}


HRESULT InjectFSPSData(HWND hdlg)
{
	// BUGBUG: TODO: this function should validate the user's changes...

	HRESULT hr = S_OK;
	PFSPS pfsps;
	CFusionShortcut* pfusshcut;
	LPWSTR pwzURL;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pfsps = (PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam);
	pfusshcut = pfsps->pfusshcut;

	return(hr);
}


HRESULT FSPSSave(HWND hdlg)
{
	HRESULT hr;
	CFusionShortcut* pfusshcut;

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	pfusshcut = ((PFSPS)(((PROPSHEETPAGE*)GetWindowLongPtr(hdlg, DWLP_USER))->lParam))->pfusshcut;

	if (pfusshcut->IsDirty() == S_OK)
	{
		// BUGBUG: TODO: IPersistFile::Save is not implemented
		hr = pfusshcut->Save((LPCOLESTR)NULL, FALSE);
	}
	else
	{
		hr = S_OK;
	}

	return(hr);
}


BOOL FSPS_Notify(HWND hdlg, WPARAM wparam, LPARAM lparam)
{
	BOOL bMsgHandled = FALSE;

	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	switch (((NMHDR*)lparam)->code)
	{
		case PSN_APPLY:
			SetWindowLongPtr(hdlg, DWLP_MSGRESULT, FSPSSave(hdlg) == S_OK ?
			                PSNRET_NOERROR :
			                PSNRET_INVALID_NOCHANGEPAGE);
			bMsgHandled = TRUE;
			break;

		case PSN_KILLACTIVE:
			SetWindowLongPtr(hdlg, DWLP_MSGRESULT, FAILED(InjectFSPSData(hdlg)));
			bMsgHandled = TRUE;
			break;

		default:
			break;
	}

	return(bMsgHandled);
}


INT_PTR CALLBACK FSPS_DlgProc(HWND hdlg, UINT uMsg, WPARAM wparam,
                    LPARAM lparam)
{
	INT_PTR bMsgHandled = FALSE;

	// uMsg may be any value.
	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hdlg, WND));

	switch (uMsg)
	{
		case WM_INITDIALOG:
			bMsgHandled = FSPS_InitDialog(hdlg, wparam, lparam);
			break;

		case WM_DESTROY:
			bMsgHandled = FSPS_Destroy(hdlg, wparam, lparam);
			break;

		case WM_COMMAND:
			bMsgHandled = FSPS_Command(hdlg, wparam, lparam);
			break;

		case WM_NOTIFY:
			bMsgHandled = FSPS_Notify(hdlg, wparam, lparam);
			break;

		default:
			break;
	}

	return(bMsgHandled);
}


HRESULT AddFSPS(CFusionShortcut* pfusshcut,
                 LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lparam)
{
	HRESULT hr = S_OK;
	PFSPS pfsps;
	PROPSHEETPAGE psp;
	HPROPSHEETPAGE hpsp;

	PFSPS pfsps2;
	PROPSHEETPAGE psp2;
	HPROPSHEETPAGE hpsp2;

	// lparam may be any value.

	// this is deleted in FSPSCallback
	pfsps = new FSPS;
	ZeroMemory(pfsps, sizeof(*pfsps));

	psp.dwSize = sizeof(psp);
	psp.dwFlags = (PSP_DEFAULT | PSP_USECALLBACK);
	psp.hInstance = g_DllInstance; //MLGetHinst();
	psp.pszTemplate = MAKEINTRESOURCE(DLG_FUS_SHORTCUT_PROP_SHEET);
	psp.pfnDlgProc = &FSPS_DlgProc;
	psp.pfnCallback = &FSPSCallback;
	psp.lParam = (LPARAM)pfsps;
	psp.hIcon = 0;			// not used
	psp.pszTitle = NULL;	// not used
	psp.pcRefParent = 0;	// not used

	pfsps->pfusshcut = pfusshcut;
	pfsps->eCurPage = FUSIONSHCUT_PS_SHCUT_PAGE; // page 1

	// will psp be copied in this func? else this won't work...!!??
	hpsp = CreatePropertySheetPage(&psp);

	if (hpsp)
	{
		if ((*pfnAddPage)(hpsp, lparam))
		{
			pfusshcut->AddRef();
		}
		else
		{
			DestroyPropertySheetPage(hpsp);
			hr = E_FAIL;
			goto exit;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}

	// this is deleted in FSPSCallback
	pfsps2 = new FSPS;
	ZeroMemory(pfsps2, sizeof(*pfsps2));

	psp2.dwSize = sizeof(psp2);
	psp2.dwFlags = (PSP_DEFAULT | PSP_USECALLBACK);
	psp2.hInstance = g_DllInstance; //MLGetHinst();
	psp2.pszTemplate = MAKEINTRESOURCE(DLG_FUS_SHORTCUT_PROP_SHEET_APPNAME);
	psp2.pfnDlgProc = &FSPS_DlgProc;
	psp2.pfnCallback = &FSPSCallback;
	psp2.lParam = (LPARAM)pfsps2;
	psp2.hIcon = 0;			// not used
	psp2.pszTitle = NULL;	// not used
	psp2.pcRefParent = 0;	// not used

	pfsps2->pfusshcut = pfusshcut;
	pfsps2->eCurPage = FUSIONSHCUT_PS_REF_PAGE; // page 2

	// will psp be copied in this func? else this won't work...!!??
	hpsp2 = CreatePropertySheetPage(&psp2);

	if (hpsp2)
	{
		if ((*pfnAddPage)(hpsp2, lparam))
		{
			pfusshcut->AddRef();
		}
		else
		{
			DestroyPropertySheetPage(hpsp2);
			hr = E_FAIL;
			goto exit;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}

exit:
	return(hr);
}


/****************************** Public Functions *****************************/


BOOL RegisterGlobalHotkey(WORD wOldHotkey, WORD wNewHotkey,
                      LPCWSTR pcwzPath)
{
	// BUGBUG?: does this work??

	BOOL bResult = FALSE;
	HWND hwndTray;

	ASSERT(! wOldHotkey || IsValidHotkey(wOldHotkey));
	ASSERT(! wNewHotkey || IsValidHotkey(wNewHotkey));
	ASSERT(IsValidPath(pcwzPath));

	hwndTray = FindWindow(s_cwzTrayNotificationClass, 0);

	if (hwndTray)
	{
		if (wOldHotkey)
		{
			SendMessage(hwndTray, WMTRAY_SCUNREGISTERHOTKEY, wOldHotkey, 0);
		}

		if (wNewHotkey)
		{
			ATOM atom = GlobalAddAtom(pcwzPath);
			ASSERT(atom);
			if (atom)
			{
				SendMessage(hwndTray, WMTRAY_SCREGISTERHOTKEY, wNewHotkey, (LPARAM)atom);
				GlobalDeleteAtom(atom);
			}
		}

		bResult = TRUE;
	}
	/*else
	{
		bResult = FALSE;
	}*/

	return(bResult);
}

/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE CFusionShortcut::Initialize(LPCITEMIDLIST pcidlFolder,
                              IDataObject* pido,
                              HKEY hkeyProgID)
{
	HRESULT hr;
	STGMEDIUM stgmed;
	FORMATETC fmtetc = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
	ASSERT(NULL != pido);
	ASSERT(IS_VALID_HANDLE(hkeyProgID, KEY));

	hr = pido->GetData(&fmtetc, &stgmed);
	if (hr == S_OK)
	{
		WCHAR wzPath[MAX_PATH];
		if (DragQueryFile((HDROP)stgmed.hGlobal, 0, wzPath, sizeof(wzPath)/sizeof(*wzPath)))
		{
			//mode is ignored for now
			hr = Load(wzPath, 0);
		}
		// else path len > MAX_PATH or other error

		ReleaseStgMedium(&stgmed);
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage,
                         LPARAM lparam)
{
	HRESULT hr;

	// lparam may be any value.

	hr = AddFSPS(this, pfnAddPage, lparam);

	// BUGBUG: why this does not work?
	// From MSDN:
	//With version 4.71 and later, you can request that a particular property
	//sheet page be displayed first, instead of the default page. To do so,
	//return the one-based index of the desired page. For example, if you
	//want the second of three pages displayed, the return value should be 2.
	//Note that this return value is a request. The property sheet may still
	//display the default page. --> see doc for AddPages()
	if (SUCCEEDED(hr))
		hr = HRESULT(4); // or 3??

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::ReplacePage(UINT uPageID,
                      LPFNADDPROPSHEETPAGE pfnReplaceWith,
                      LPARAM lparam)
{
	HRESULT hr;

	// lparam may be any value.
	// uPageID may be any value.

	hr = E_NOTIMPL;

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetCodebase(LPCWSTR pcwzCodebase)
{
	HRESULT hr = S_OK;
	BOOL bDifferent;
	LPWSTR pwzNewCodebase = NULL;

	// Set m_pwzCodebase to codebase.

	// check if empty string?
	
	bDifferent = ! ((! pcwzCodebase && ! m_pwzCodebase) ||
				(pcwzCodebase && m_pwzCodebase &&
				! wcscmp(pcwzCodebase, m_pwzCodebase)));

	if (bDifferent && pcwzCodebase)
	{
		// (+ 1) for null terminator.

		pwzNewCodebase = new(WCHAR[wcslen(pcwzCodebase) + 1]);

		if (pwzNewCodebase)
			wcscpy(pwzNewCodebase, pcwzCodebase);
		else
			hr = E_OUTOFMEMORY;
	}

	if (hr == S_OK && bDifferent)
	{
		if (m_pwzCodebase)
			delete m_pwzCodebase;

		m_pwzCodebase = pwzNewCodebase;

		Dirty(TRUE);
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetCodebase(LPWSTR pwzCodebase,
                                                      int ncBufLen)
{
	HRESULT hr = S_OK;

	// Get description from m_pwzCodebase.

	if (m_pwzCodebase)
	{
		if (pwzCodebase == NULL || ncBufLen <= 0)
			hr = E_INVALIDARG;
		else
		{
			wcsncpy(pwzCodebase, m_pwzCodebase, ncBufLen-1);
			pwzCodebase[ncBufLen-1] = L'\0';
		}
	}
	else
	{
		if (ncBufLen > 0 && pwzCodebase != NULL)
			pwzCodebase = L'\0';
	}

	ASSERT(hr == S_OK &&
		(ncBufLen <= 0 ||
		EVAL(wcslen(pwzCodebase) < ncBufLen)));

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\shortcut\shcut.cpp ===
//
// Copyright (c) 2001 Microsoft Corporation
//
//

#include "shcut.h"

// {b95ec110-5c3e-433c-b969-701c10521ef2}
static const GUID CLSID_FusionShortcut = 
{ 0xb95ec110, 0x5c3e, 0x433c, { 0xb9, 0x69, 0x70, 0x1c, 0x10, 0x52, 0x1e, 0xf2 } };

extern ULONG DllAddRef(void);
extern ULONG DllRelease(void);

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

CFusionShortcutClassFactory::CFusionShortcutClassFactory()
{
	_cRef = 1;
}

// ----------------------------------------------------------------------------

HRESULT
CFusionShortcutClassFactory::QueryInterface(REFIID iid, void **ppv)
{
	HRESULT hr = S_OK;

    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IClassFactory)
    {
        *ppv = (IClassFactory *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    ((IUnknown *)*ppv)->AddRef();

exit:
    return hr;
}

// ----------------------------------------------------------------------------

ULONG
CFusionShortcutClassFactory::AddRef()
{
    return (ULONG) InterlockedIncrement(&_cRef);
}

ULONG
CFusionShortcutClassFactory::Release()
{
	LONG ulCount = InterlockedDecrement(&_cRef);

	if (ulCount <= 0)
	{
		delete this;
	}

    return (ULONG) ulCount;
}

HRESULT
CFusionShortcutClassFactory::LockServer(BOOL lock)
{
    return (lock ? 
            DllAddRef() :
            DllRelease());
}

// ----------------------------------------------------------------------------

HRESULT
CFusionShortcutClassFactory::CreateInstance(IUnknown* pUnkOuter, REFIID iid, void** ppv)
{
    HRESULT hr = S_OK;
    CFusionShortcut *pFusionShortcut = NULL;

	*ppv = NULL;

    if (pUnkOuter && iid != IID_IUnknown)
    {
    	hr = CLASS_E_NOAGGREGATION;
    	goto exit;
    }

    pFusionShortcut = new CFusionShortcut();
    if (pFusionShortcut == NULL)
    {
    	hr = E_OUTOFMEMORY;
    	goto exit;
    }

    if (iid == IID_IUnknown)
    {
        *ppv = (IShellLink *)pFusionShortcut;
        pFusionShortcut->AddRef();
    }
    else
    {
        hr = pFusionShortcut->QueryInterface(iid, ppv);
        if (FAILED(hr))
        	goto exit;
    }

exit:
    if (pFusionShortcut)
        pFusionShortcut->Release();

    return hr;
}

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

CFusionShortcut::CFusionShortcut()
	: RefCount()
{
	// Don't validate this until after construction.

	m_dwFlags = FUSSHCUT_FL_NOTDIRTY;
	m_pwzShortcutFile = NULL;
	m_pwzPath = NULL;
	m_pwzDesc = NULL;
	m_pwzIconFile = NULL;
	m_niIcon = 0;
	m_pwzWorkingDirectory = NULL;
	m_nShowCmd = DEFAULTSHOWCMD;
	m_wHotkey = 0;
	m_pwzCodebase = NULL;

	m_pIdentity = NULL;

	return;
}

CFusionShortcut::~CFusionShortcut(void)
{
	if (m_pwzShortcutFile)
	{
		delete m_pwzShortcutFile;
		m_pwzShortcutFile = NULL;
	}

	if (m_pwzPath)
	{
		delete m_pwzPath;
		m_pwzPath = NULL;
	}

	if (m_pwzDesc)
	{
		delete m_pwzDesc;
		m_pwzDesc = NULL;
	}

	if (m_pwzIconFile)
	{
		delete m_pwzIconFile;
		m_pwzIconFile = NULL;
		m_niIcon = 0;
	}

	if (m_pwzWorkingDirectory)
	{
		delete m_pwzWorkingDirectory;
		m_pwzWorkingDirectory = NULL;
	}

	if (m_pwzCodebase)
	{
		delete m_pwzCodebase;
		m_pwzCodebase = NULL;
	}

	if (m_pIdentity)
	{
		m_pIdentity->Release();
	}

	RefCount::~RefCount();

	return;
}


HRESULT CFusionShortcut::GetAssemblyIdentity(LPASSEMBLY_IDENTITY* ppAsmId)
{
	HRESULT hr = S_OK;
	
	if (ppAsmId == NULL)
	{
		hr = E_INVALIDARG;
		goto exit;
	}

	if (m_pIdentity)
	{
		m_pIdentity->AddRef();
 		*ppAsmId = m_pIdentity;
	}
	else
 		*ppAsmId = NULL;

exit:
 	return hr;
}


ULONG STDMETHODCALLTYPE CFusionShortcut::AddRef(void)
{
	ULONG ulcRef;

	ulcRef = RefCount::AddRef();

	return(ulcRef);
}


ULONG STDMETHODCALLTYPE CFusionShortcut::Release(void)
{
	ULONG ulcRef;

	ulcRef = RefCount::Release();

	return(ulcRef);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::QueryInterface(REFIID riid,
                                                           PVOID *ppvObject)
{
	HRESULT hr = S_OK;

	if (riid == IID_IExtractIcon)
	{
	  *ppvObject = (IExtractIcon*)this;
	}
	else if (riid == IID_IPersist)
	{
	  *ppvObject = (IPersist*)(IPersistFile*)this;
	}
	else if (riid == IID_IPersistFile)
	{
	  *ppvObject = (IPersistFile*)this;
	}
	else if (riid == IID_IShellExtInit)
	{
	  *ppvObject = (IShellExtInit*)this;
	}
	else if (riid == IID_IShellLink)
	{
	  *ppvObject = (IShellLink*)this;
	}
	else if (riid == IID_IShellPropSheetExt)
	{
	  *ppvObject = (IShellPropSheetExt*)this;
	}
	else if (riid == IID_IQueryInfo)
	{
	  *ppvObject = (IQueryInfo*)this;
	}
	else if (riid == IID_IUnknown)
	{
	  *ppvObject = (IUnknown*)(IShellLink*)this;
	}
	else
	{
	  *ppvObject = NULL;
	  hr = E_NOINTERFACE;
	}

	if (hr == S_OK)
	  AddRef();

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\shortcut\shlink.cpp ===
/*
 * shlink.cpp - IShellLink implementation for CFusionShortcut class.
 */


// note: BUGBUG?
// from MSDN, it's unclear that for the GetX methods the len arguments
// are counting the terminating NULL or not.
// "size of the buffer pointed by szX"
// so here, and other methods, assume they do -ie. wcslen(s) + L'\0'

/* Headers
 **********/

#include "project.hpp"

/* Types
 ********/

/*typedef enum isl_getpath_flags
{
   // flag combinations

   ALL_ISL_GETPATH_FLAGS   = (SLGP_SHORTPATH |
                              SLGP_UNCPRIORITY)
}
ISL_GETPATH_FLAGS;*/


/********************************** Methods **********************************/


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetPath(LPCWSTR pcwzPath)
{
	HRESULT hr = S_OK;
	WCHAR rgchNewPath[MAX_PATH];
	BOOL bChanged = FALSE;
	LPWSTR pwzOriPath = (LPWSTR) pcwzPath; // still, pwzOriPath shouldn't be modified
	LPWSTR pwzFixedPath = NULL;

	ASSERT(! pwzOriPath)

	// ... this checks if all space in string...
	if (! AnyNonWhiteSpace(pwzOriPath))
		pwzOriPath = NULL;

	if (pwzOriPath)
	{
		LPWSTR pwzFileName;

		// this ignores "If the lpBuffer buffer is too small, the return value is the size
		//  of the buffer, in WCHARs, required to hold the path"
		if (GetFullPathName(pwzOriPath, sizeof(rgchNewPath)/sizeof(WCHAR),
					rgchNewPath, &pwzFileName) > 0)
			pwzOriPath = rgchNewPath;
		else
			hr = GetLastWin32Error();
	}

	if (hr == S_OK)
	{
		bChanged = ! ((! pwzOriPath && ! m_pwzPath) ||
				(pwzOriPath && m_pwzPath &&
				! wcscmp(pwzOriPath, m_pwzPath)));

		if (bChanged && pwzOriPath)
		{
			 // (+ 1) for null terminator.

			pwzFixedPath = new(WCHAR[wcslen(pwzOriPath) + 1]);

			if (pwzFixedPath)
				wcscpy(pwzFixedPath, pwzOriPath);
			else
				hr = E_OUTOFMEMORY;
		}
	}

	if (hr == S_OK && bChanged)
	{
		if (m_pwzPath)
			delete m_pwzPath;

		m_pwzPath = pwzFixedPath;

		Dirty(TRUE);
   }

	ASSERT(hr == S_OK || FAILED(hr));

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetPath(LPWSTR pwzFile,
                                                    int ncFileBufLen,
                                                    PWIN32_FIND_DATA pwfd,
                                                    DWORD dwFlags)
{
	HRESULT hr = S_OK;

	ASSERT(NULL == pwfd);
	// Ignore dwFlags.

	if (pwfd)
		ZeroMemory(pwfd, sizeof(*pwfd));

	if (m_pwzPath)
	{
		if (pwzFile == NULL || ncFileBufLen <= 0)
			hr = E_INVALIDARG;
		else
		{
			wcsncpy(pwzFile, m_pwzPath, ncFileBufLen-1);
			pwzFile[ncFileBufLen-1] = L'\0';
		}
	}
	else
	{
		if (ncFileBufLen > 0 && pwzFile != NULL)
			*pwzFile = L'\0';

		hr = S_FALSE;
	}

	ASSERT((hr == S_OK && ncFileBufLen < 1) ||
			(hr == S_FALSE && 
			(ncFileBufLen < 1 || ! *pwzFile)));

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetRelativePath(LPCWSTR pcwzRelativePath,
                                                      DWORD dwReserved)
{
	HRESULT hr;

	// dwReserved may be any value.

	hr = E_NOTIMPL;

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetIDList(LPCITEMIDLIST pcidl)
{
	HRESULT hr;

	hr = E_NOTIMPL;

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetIDList(LPITEMIDLIST *ppidl)
{
	HRESULT hr;

	if (ppidl != NULL)
		*ppidl = NULL;

	hr = E_NOTIMPL;

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetDescription(LPCWSTR pcwzDescription)
{
	HRESULT hr = S_OK;
	BOOL bDifferent;
	LPWSTR pwzNewDesc = NULL;

	// Set m_pwzDesc to description.

	bDifferent = ! ((! pcwzDescription && ! m_pwzDesc) ||
				(pcwzDescription && m_pwzDesc &&
				! wcscmp(pcwzDescription, m_pwzDesc)));

	if (bDifferent && pcwzDescription)
	{
		// (+ 1) for null terminator.

		pwzNewDesc = new(WCHAR[wcslen(pcwzDescription) + 1]);

		if (pwzNewDesc)
			wcscpy(pwzNewDesc, pcwzDescription);
		else
			hr = E_OUTOFMEMORY;
	}

	if (hr == S_OK && bDifferent)
	{
		if (m_pwzDesc)
			delete m_pwzDesc;

		m_pwzDesc = pwzNewDesc;

		Dirty(TRUE);
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetDescription(LPWSTR pwzDescription,
                                                      int ncDesciptionBufLen)
{
	HRESULT hr = S_OK;

	// Get description from m_pwzDesc.

	if (m_pwzDesc)
	{
		if (pwzDescription == NULL || ncDesciptionBufLen <= 0)
			hr = E_INVALIDARG;
		else
		{
			wcsncpy(pwzDescription, m_pwzDesc, ncDesciptionBufLen-1);
			pwzDescription[ncDesciptionBufLen-1] = L'\0';
		}
	}
	else
	{
		if (ncDesciptionBufLen > 0 && pwzDescription != NULL)
			pwzDescription = L'\0';
	}

	ASSERT(hr == S_OK &&
		(ncDesciptionBufLen <= 0 ||
		EVAL(wcslen(pwzDescription) < ncDesciptionBufLen)));

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetArguments(LPCWSTR pcwzArgs)
{
   HRESULT hr;

   hr = E_NOTIMPL;

   return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetArguments(LPWSTR pwzArgs,
                                                         int ncArgsBufLen)
{
   HRESULT hr;

   if (ncArgsBufLen > 0 && pwzArgs != NULL)
      *pwzArgs = L'\0';

   hr = E_NOTIMPL;

   return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetWorkingDirectory(LPCWSTR pcwzWorkingDirectory)
{
	HRESULT hr = S_OK;
	WCHAR rgchNewPath[MAX_PATH];
	BOOL bChanged = FALSE;
	LPWSTR pwzOriWorkingDirectory = (LPWSTR) pcwzWorkingDirectory; // still, pwzOriWorkingDirectory shouldn't be modified
	LPWSTR pwzFixedWorkingDirectory = NULL;

	ASSERT(! pwzOriWorkingDirectory)

	// ... this checks if all space in string...
	if (! AnyNonWhiteSpace(pwzOriWorkingDirectory))
		pwzOriWorkingDirectory = NULL;

	if (pwzOriWorkingDirectory)
	{
		LPWSTR pwzFileName;

		// this ignores "If the lpBuffer buffer is too small, the return value is the size
		//  of the buffer, in WCHARs, required to hold the path"
		if (GetFullPathName(pwzOriWorkingDirectory, sizeof(rgchNewPath)/sizeof(WCHAR),
					rgchNewPath, &pwzFileName) > 0)
			pwzOriWorkingDirectory = rgchNewPath;
		else
			hr = GetLastWin32Error();
	}

	if (hr == S_OK)
	{
		bChanged = ! ((! pwzOriWorkingDirectory && ! m_pwzWorkingDirectory) ||
				(pwzOriWorkingDirectory && m_pwzWorkingDirectory &&
				! wcscmp(pwzOriWorkingDirectory, m_pwzWorkingDirectory)));

		if (bChanged && pwzOriWorkingDirectory)
		{
			// (+ 1) for null terminator.

			pwzFixedWorkingDirectory = new(WCHAR[wcslen(pwzOriWorkingDirectory) + 1]);

			if (pwzFixedWorkingDirectory)
				wcscpy(pwzFixedWorkingDirectory, pwzOriWorkingDirectory);
			else
				hr = E_OUTOFMEMORY;
		}
	}

	if (hr == S_OK && bChanged)
	{
		if (m_pwzWorkingDirectory)
			delete m_pwzWorkingDirectory;

		m_pwzWorkingDirectory = pwzFixedWorkingDirectory;

		Dirty(TRUE);
	}

	ASSERT(hr == S_OK || FAILED(hr));

	return(hr);
}

HRESULT STDMETHODCALLTYPE CFusionShortcut::GetWorkingDirectory(LPWSTR pwzWorkingDirectory,
                                                int ncbWorkingDirectoryBufLen)
{
	HRESULT hr = S_OK;

	if (m_pwzWorkingDirectory)
	{
		if (pwzWorkingDirectory == NULL || ncbWorkingDirectoryBufLen <= 0)
			hr = E_INVALIDARG;
		else
		{
			wcsncpy(pwzWorkingDirectory, m_pwzWorkingDirectory,
				ncbWorkingDirectoryBufLen-1);
			pwzWorkingDirectory[ncbWorkingDirectoryBufLen-1] = L'\0';
		}
	}
	else
	{
		if (ncbWorkingDirectoryBufLen > 0 && pwzWorkingDirectory != NULL)
			*pwzWorkingDirectory = L'\0';

		hr = S_FALSE;
	}

	ASSERT(IsValidPathResult(hr, pwzWorkingDirectory, ncbWorkingDirectoryBufLen));
	ASSERT(hr == S_OK ||
		hr == S_FALSE);

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetHotkey(WORD wHotkey)
{
	HRESULT hr=S_OK;

	ASSERT(! wHotkey)

	if (wHotkey != m_wHotkey)
	{
		m_wHotkey = wHotkey;
		
		Dirty(TRUE);
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetHotkey(PWORD pwHotkey)
{
	HRESULT hr=S_OK;

	if (pwHotkey == NULL)
		hr = E_INVALIDARG;
	else
		*pwHotkey = m_wHotkey;

	ASSERT(! *pwHotkey)

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetShowCmd(int nShowCmd)
{
	HRESULT hr=S_OK;

	ASSERT(IsValidShowCmd(nShowCmd));

	if (nShowCmd != m_nShowCmd)
	{
		m_nShowCmd = nShowCmd;

		Dirty(TRUE);
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetShowCmd(PINT pnShowCmd)
{
	HRESULT hr=S_OK;

	if (pnShowCmd == NULL)
		hr = E_INVALIDARG;
	else
		*pnShowCmd = m_nShowCmd;

	ASSERT(IsValidShowCmd(m_nShowCmd));

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::SetIconLocation(LPCWSTR pcwzIconFile,
                                                            int niIcon)
{
	HRESULT hr = S_OK;
	BOOL bNewNonWhiteSpace;

	ASSERT(IsValidIconIndex(pcwzIconFile ? S_OK : S_FALSE, pcwzIconFile, MAX_PATH, niIcon));

	bNewNonWhiteSpace = AnyNonWhiteSpace(pcwzIconFile);

	if (hr == S_OK)
	{
		WCHAR rgchOldPath[MAX_PATH];
		int niOldIcon;
		UINT uFlags;

		hr = GetIconLocation(0, rgchOldPath, sizeof(rgchOldPath)/sizeof(WCHAR), &niOldIcon,
			&uFlags);

		// should this continue even if there's error getting icon location??
		if (SUCCEEDED(hr))
		{
			BOOL bOldNonWhiteSpace;
			BOOL bChanged = FALSE;
			LPWSTR pwzNewIconFile = NULL;
			int niNewIcon = 0;

			bOldNonWhiteSpace = AnyNonWhiteSpace(rgchOldPath);

			ASSERT(! *rgchOldPath || bOldNonWhiteSpace);

			// check
			bChanged = ((! bOldNonWhiteSpace && bNewNonWhiteSpace) ||
				(bOldNonWhiteSpace && ! bNewNonWhiteSpace) ||
				(bOldNonWhiteSpace && bNewNonWhiteSpace &&
				(wcscmp(rgchOldPath, pcwzIconFile) != 0 ||
				niIcon != niOldIcon)));

			// clear hr
			hr = S_OK;
			if (bChanged && bNewNonWhiteSpace)
			{
				// (+ 1) for null terminator.

				// BUGBUG: slightly not optimize as it makes a copy even if only the index changes
				pwzNewIconFile = new(WCHAR[wcslen(pcwzIconFile) + 1]);

				if (pwzNewIconFile)
				{
					wcscpy(pwzNewIconFile, pcwzIconFile);
					niNewIcon = niIcon;
				}
				else
					hr = E_OUTOFMEMORY;
			}
 
			if (hr == S_OK && bChanged)
			{
				if (m_pwzIconFile)
					delete m_pwzIconFile;

				m_pwzIconFile = pwzNewIconFile;
				m_niIcon = niNewIcon;

				Dirty(TRUE);
			}
		}
	}

	ASSERT(hr == S_OK ||
		hr == E_OUTOFMEMORY ||
		hr == E_FILE_NOT_FOUND);

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::GetIconLocation(LPWSTR pwzIconFile,
                                                         int ncbIconFileBufLen,
                                                         PINT pniIcon)
{
	HRESULT hr=S_OK;

	// this ignores icon index (even if set) if icon file path is not
	if (m_pwzIconFile)
	{
		if (pwzIconFile == NULL || ncbIconFileBufLen <= 0)
			hr = E_INVALIDARG;
		else
		{
			wcsncpy(pwzIconFile, m_pwzIconFile, ncbIconFileBufLen-1);
			pwzIconFile[ncbIconFileBufLen-1] = L'\0';

			if (pniIcon == NULL)
				hr = E_INVALIDARG;
			else
				*pniIcon = m_niIcon;
			
		}
	}
	else
	{
		if (ncbIconFileBufLen > 0 && pwzIconFile != NULL)
			*pwzIconFile = L'\0';

		if (pniIcon != NULL)
			*pniIcon = 0;

		hr = S_FALSE;
	}

	ASSERT(IsValidIconIndex(hr, pwzIconFile, ncbIconFileBufLen, *pniIcon));

	return(hr);
}


HRESULT STDMETHODCALLTYPE CFusionShortcut::Resolve(HWND hwnd, DWORD dwFlags)
{
	HRESULT hr;

	ASSERT(IS_VALID_HANDLE(hwnd, WND));

	// BUGBUG?: check dwFlags

	hr = S_OK;

	// BUGBUG?: should this check the shortcut and do the UI/update/save?

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\tools\mangen\md5.cpp ===
/*
 * This code implements the MD5 message-digest algorithm.
 * The algorithm is due to Ron Rivest.	This code was
 * written by Colin Plumb in 1993, no copyright is claimed.
 * This code is in the public domain; do with it what you wish.
 *
 * Equivalent code is available from RSA Data Security, Inc.
 * This code has been tested against that, and is equivalent,
 * except that you don't need to include two pages of legalese
 * with every copy.
 *
 * To compute the message digest of a chunk of bytes, declare an
 * MD5Context structure, pass it to MD5Init, call MD5Update as
 * needed on buffers full of bytes, and then call MD5Final, which
 * will fill a supplied 16-byte array with the digest.
 */

/* Brutally hacked by John Walker back from ANSI C to K&R (no
   prototypes) to maintain the tradition that Netfone will compile
   with Sun's original "cc". */
/* Changed by felixybc back to ANSI C */

#include <memory.h>		 /* for memcpy() */
#include "md5.h"

#ifdef sgi
#define HIGHFIRST
#endif

#ifdef sun
#define HIGHFIRST
#endif

#ifndef HIGHFIRST
#define byteReverse(buf, len)	/* Nothing */
#else
/*
 * Note: this code is harmless on little-endian machines.
 */
void byteReverse(unsigned char *buf, unsigned longs)
{
    uint32 t;
    do {
    t = (uint32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
        ((unsigned) buf[1] << 8 | buf[0]);
    *(uint32 *) buf = t;
    buf += 4;
    } while (--longs);
}
#endif

/*
 * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
 * initialization constants.
 */
void MD5Init(struct MD5Context *ctx)
{
    ctx->buf[0] = 0x67452301;
    ctx->buf[1] = 0xefcdab89;
    ctx->buf[2] = 0x98badcfe;
    ctx->buf[3] = 0x10325476;

    ctx->bits[0] = 0;
    ctx->bits[1] = 0;
}

/*
 * Update context to reflect the concatenation of another buffer full
 * of bytes.
 */
void MD5Update(struct MD5Context *ctx, unsigned char *buf, unsigned len)
{
    uint32 t;

    /* Update bitcount */

    t = ctx->bits[0];
    if ((ctx->bits[0] = t + ((uint32) len << 3)) < t)
    ctx->bits[1]++; 	/* Carry from low to high */
    ctx->bits[1] += len >> 29;

    t = (t >> 3) & 0x3f;	/* Bytes already in shsInfo->data */

    /* Handle any leading odd-sized chunks */

    if (t) {
    unsigned char *p = (unsigned char *) ctx->in + t;

    t = 64 - t;
    if (len < t) {
        memcpy(p, buf, len);
        return;
    }
    memcpy(p, buf, t);
    byteReverse(ctx->in, 16);
    MD5Transform(ctx->buf, (uint32 *) ctx->in);
    buf += t;
    len -= t;
    }
    /* Process data in 64-byte chunks */

    while (len >= 64) {
    memcpy(ctx->in, buf, 64);
    byteReverse(ctx->in, 16);
    MD5Transform(ctx->buf, (uint32 *) ctx->in);
    buf += 64;
    len -= 64;
    }

    /* Handle any remaining bytes of data. */

    memcpy(ctx->in, buf, len);
}

/*
 * Final wrapup - pad to 64-byte boundary with the bit pattern 
 * 1 0* (64-bit count of bits processed, MSB-first)
 */
void MD5Final(unsigned char digest[16], struct MD5Context *ctx)
{
    unsigned count;
    unsigned char *p;

    /* Compute number of bytes mod 64 */
    count = (ctx->bits[0] >> 3) & 0x3F;

    /* Set the first char of padding to 0x80.  This is safe since there is
       always at least one byte free */
    p = ctx->in + count;
    *p++ = 0x80;

    /* Bytes of padding needed to make 64 bytes */
    count = 64 - 1 - count;

    /* Pad out to 56 mod 64 */
    if (count < 8) {
    /* Two lots of padding:  Pad the first block to 64 bytes */
    memset(p, 0, count);
    byteReverse(ctx->in, 16);
    MD5Transform(ctx->buf, (uint32 *) ctx->in);

    /* Now fill the next block with 56 bytes */
    memset(ctx->in, 0, 56);
    } else {
    /* Pad block to 56 bytes */
    memset(p, 0, count - 8);
    }
    byteReverse(ctx->in, 14);

    /* Append length in bits and transform */
    ((uint32 *) ctx->in)[14] = ctx->bits[0];
    ((uint32 *) ctx->in)[15] = ctx->bits[1];

    MD5Transform(ctx->buf, (uint32 *) ctx->in);
    byteReverse((unsigned char *) ctx->buf, 4);
    memcpy(digest, ctx->buf, 16);
    memset(ctx, 0, sizeof(ctx));        /* In case it's sensitive */
}


/* The four core functions - F1 is optimized somewhat */

/* #define F1(x, y, z) (x & y | ~x & z) */
#define F1(x, y, z) (z ^ (x & (y ^ z)))
#define F2(x, y, z) F1(z, x, y)
#define F3(x, y, z) (x ^ y ^ z)
#define F4(x, y, z) (y ^ (x | ~z))

/* This is the central step in the MD5 algorithm. */
#define MD5STEP(f, w, x, y, z, data, s) \
	( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )

/*
 * The core of the MD5 algorithm, this alters an existing MD5 hash to
 * reflect the addition of 16 longwords of new data.  MD5Update blocks
 * the data and converts bytes into longwords for this routine.
 */
void MD5Transform(uint32 buf[4], uint32 in[16])
{
    register uint32 a, b, c, d;

    a = buf[0];
    b = buf[1];
    c = buf[2];
    d = buf[3];

    MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
    MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
    MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
    MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
    MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
    MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
    MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
    MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
    MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
    MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
    MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
    MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
    MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
    MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
    MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
    MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

    MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
    MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
    MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
    MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
    MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
    MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
    MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
    MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
    MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
    MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
    MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
    MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
    MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
    MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
    MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
    MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

    MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
    MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
    MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
    MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
    MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
    MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
    MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
    MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
    MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
    MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
    MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
    MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
    MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
    MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
    MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
    MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

    MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
    MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
    MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
    MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
    MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
    MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
    MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
    MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
    MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
    MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
    MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
    MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
    MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
    MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
    MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
    MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);

    buf[0] += a;
    buf[1] += b;
    buf[2] += c;
    buf[3] += d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\tools\mangen\mangen.cpp ===
#include <shlwapi.h>
#include <stdio.h> // for _snprintf
#include "md5.h"
#define HASHLENGTH          32
#define HASHSTRINGLENGTH    HASHLENGTH+1

#ifdef _UNICODE
#error this program should not be compiled with UNICODE
#endif // _UNICODE
#ifdef _MBCS
#error this program should not be compiled with MBCS
#endif // _MBCS

// Note: this is not really a WCHAR/Unicode/UTF implementation!

// ???? UTF-8?
// BUGBUG: Files are never saved as UTF-8 encoding and format
const char szHeader[] = { "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n<assembly xmlns:asm_namespace_v1=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">\r\n<assemblyIdentity \r\n" };

// asm id
const char szAsmidtype[] = { "\ttype=\"" };
const char szAsmidname[] = { "\"\r\n\tname=\"" };
const char szAsmidver[] = { "\"\r\n\tversion=\"" };
const char szAsmidprocessor[] = { "\"\r\n\tprocessorArchitecture=\"" };
const char szAsmidpkt[] = { "\"\r\n\tpublicKeyToken=\"" };
const char szAsmidlang[] = { "\"\r\n\tlanguage=\"" };

const char szAsmidtypeapp[] = { "application" };
const char szAsmidtypesub[] = { "subscription" };

const char szEndheader1[] = { "\"\r\n/>\r\n\r\n<description>" };
const char szEndheader2[] = { "</description>\r\n\r\n" };

// app manifest only
const char szShellstateprefix[] = { "<application>\r\n\t<shellState \r\n\t\tfriendlyName=\"" };
const char szShellentry[] = { "\"\r\n\t\tentryPoint=\"" };
const char szShellimagetype[] = { "\"\r\n\t\tentryImageType=\"" };
const char szShellhotkey[] = { "\"\r\n\t\thotKey=\"" };
const char szShelliconfile[] = { "\"\r\n\t\ticonFile=\"" };
const char szShelliconindex[] = { "\"\r\n\t\ticonIndex=\"" };
const char szShellshowcommand[] = { "\"\r\n\t\tshowCommand=\"" };
const char szShellstatepostfix[] = { "\"\r\n\t/>\r\n</application>\r\n\r\n" };

const char szFileprefix[] = { "\t<file name=\""};
const char szHashprefix[] = { "\"\r\n\t\t  hash=\"" };
const char szHashpostfix[] = { "\" />\r\n" };

// subscription manifest only
const char szDepend[] = { "<dependency>\r\n\t<dependentAssembly>\r\n\t\t<assemblyIdentity \r\n" };
const char szAsmidtype2[] = { "\t\t\ttype=\"" };
const char szAsmidname2[] = { "\"\r\n\t\t\tname=\"" };
const char szAsmidver2[] = { "\"\r\n\t\t\tversion=\"" };
const char szAsmidprocessor2[] = { "\"\r\n\t\t\tprocessorArchitecture=\"" };
const char szAsmidpkt2[] = { "\"\r\n\t\t\tpublicKeyToken=\"" };
const char szAsmidlang2[] = { "\"\r\n\t\t\tlanguage=\"" };
const char szDependcodebase[] = { "\"\r\n\t\t/>\r\n\r\n\t\t<install codebase=\"" };
const char szDependpolling[] = { "\"/>\r\n\t\t<subscription pollingInterval=\"" };
const char szEndDepend[] = { "\"/>\r\n\r\n\t</dependentAssembly>\r\n</dependency>\r\n" };

const char szEndfile[] = { "</assembly>" };

const char szDefaultdescription[] = { "This is a description of the app" };

//assume not unicode file, use ReadFile()  then cast it as char[]

/////////////////////////////////////////////////////////////////////////////////////////////////

void getHash(const char* szFilename, char* szHash)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwLength;

    unsigned char buffer[16384], signature[HASHLENGTH/2];
    struct MD5Context md5c;
    int i;
    char* p;

    // minimal error checking here...
    if (szHash == NULL)
        goto exit;

    szHash[0] = '\0';

    MD5Init(&md5c);

    hFile = CreateFile(szFilename, GENERIC_READ, 0, NULL, 
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if(hFile == INVALID_HANDLE_VALUE)
    {
//      hr = GetLastWin32Error();
        printf("Open file error during hashing\n");
        goto exit;
    }

    ZeroMemory(buffer, sizeof(buffer));

    while ( ReadFile (hFile, buffer, sizeof(buffer), &dwLength, NULL) && dwLength )
    {
        MD5Update(&md5c, buffer, (unsigned) dwLength);
    }
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    // note: the next few lines should follow the previous ReadFile()
    if (dwLength != 0)
    {
        printf("Read error during hashing\n");
        goto exit;
    }

    MD5Final(signature, &md5c);

    // convert hash from byte array to hex
    p = szHash;
    for (int i = 0; i < sizeof(signature); i++)
    {
        // BUGBUG?: format string 0 does not work w/ X according to MSDN? why is this working?
        sprintf(p, "%02X", signature[i]);
        p += 2;
    }

exit:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;
   
    return;
}

/////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT write(HANDLE hFile, const char* string)
{
    HRESULT hr = S_OK;
    DWORD dwLength = strlen(string);  //????
    DWORD dwWritten = 0;

    if ( !WriteFile(hFile, string, dwLength, &dwWritten, NULL) || dwWritten != dwLength)
    {
        printf("Manifest file write error\n");
        hr = E_FAIL;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// szPath is the path and name of the directory w/o the last '\'
// szPath, szPathFromAppRoot will be used/modified during runs
HRESULT doFiles(HANDLE hFile, char* szPath, char* szPathFromAppRoot)
{
// find all files, in all sub dir, get hash, output

    HRESULT hr = S_OK;
    char szSearchPath[MAX_PATH];
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fdFile;
    DWORD dwLastError = 0;
    BOOL fNeedSetCurrentDir = TRUE;

    // this has trailing "\*"
    if (_snprintf(szSearchPath, MAX_PATH, "%s\\*", szPath) < 0)
    {
        hr = CO_E_PATHTOOLONG;
        printf("Error: Search path too long\n");
        goto exit;
    }

    hFind = FindFirstFile(szSearchPath, &fdFile);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL; //GetLastWin32Error();
        printf("Find file error\n");
        goto exit;
    }

    while (dwLastError != ERROR_NO_MORE_FILES)
    {
        // ignore "." and ".."
        if (strcmp(fdFile.cFileName, ".") != 0 && strcmp(fdFile.cFileName, "..") != 0)
        {
            if ((fdFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
            {
                // recurse into dirs
                char* p = NULL;

                if (!PathAppend(szPath, fdFile.cFileName))
                {
                    hr = E_FAIL;
                    printf("Path append error\n");
                    goto exit;
                }

                if (szPathFromAppRoot[0] == '\0')
                    strncpy(szPathFromAppRoot, fdFile.cFileName, MAX_PATH-1);
                else if (!PathAppend(szPathFromAppRoot, fdFile.cFileName))
                {
                    hr = E_FAIL;
                    printf("Path append error\n");
                    goto exit;
                }

                if (FAILED(hr=doFiles(hFile, szPath, szPathFromAppRoot)))
                    goto exit;

                p = PathFindFileName(szPath);
                if (p <= szPath)
                {
                    // this should not happen!
                    hr = E_FAIL;
                    printf("Path error\n");
                    goto exit;
                }
                *(p-1) = '\0';

                p = PathFindFileName(szPathFromAppRoot);
                if (p <= szPathFromAppRoot)
                {
                    szPathFromAppRoot[0] = '\0';
                }
                else
                    *(p-1) = '\0';

                fNeedSetCurrentDir = TRUE;
            }
            else
            {
                char szHash[HASHSTRINGLENGTH];

                if (fNeedSetCurrentDir)
                {
                    if (!SetCurrentDirectory(szPath))
                    {
                        hr = E_FAIL; //GetLastWin32Error();
                        printf("Set current directory error\n");
                        goto exit;
                    }

                    fNeedSetCurrentDir = FALSE;
                }

                // get hash from that file in the current dir
                getHash(fdFile.cFileName, szHash);

                // write into the manifest file
                if (FAILED(write(hFile, szFileprefix)))
                    goto exit;

                // path to the file from app root
                if (szPathFromAppRoot[0] != '\0')
                {
                    if (FAILED(write(hFile, szPathFromAppRoot)))
                        goto exit;
                    if (FAILED(write(hFile, "\\")))
                        goto exit;
                }

                if (FAILED(write(hFile, fdFile.cFileName)))
                    goto exit;

                if (FAILED(write(hFile, szHashprefix)))
                    goto exit;

                if (FAILED(write(hFile, szHash)))
                    goto exit;

                if (FAILED(write(hFile, szHashpostfix)))
                    goto exit;
            }
        }

        if (!FindNextFile(hFind, &fdFile))
        {
            dwLastError = GetLastError();
            continue;
        }
    }

exit:
    if (hFind != INVALID_HANDLE_VALUE)
    {
        if (!FindClose(hFind))
        {
            hr = E_FAIL; //GetLastWin32Error();
            printf("Find handle close error\n");
        }
    }

    return hr;

}

/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////

const UINT s_ucMaxNameLen       = 45;
const UINT s_ucMaxVerLen            = 25;
const UINT s_ucMaxProArchLen    = 10;
const UINT s_ucMaxPktLen            = 20;
const UINT s_ucMaxLangLen          = 10;

int __cdecl main( int argc, char *argv[ ], char *envp[ ] )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwRead, dwWritten, dwAttrib;
    char buffer[1024];
    char* pszExt = NULL;
    char szManifestName[MAX_PATH];
    char szAppDir[MAX_PATH];
    char szPathFromAppDir[MAX_PATH]; // relative from app dir - temp use only
    char szName[s_ucMaxNameLen];
    char szVer[s_ucMaxVerLen];
    char szProArch[s_ucMaxProArchLen];
    char szPkt[s_ucMaxPktLen];
    char szLang[s_ucMaxLangLen];

    // ???? need to check path are current and sub dir of current ??? or not? - see known issues

    szPathFromAppDir[0] = '\0';
    if (argc < 3)
    {
        printf("Fusion manifest generator v1.0.0.0\n\n usage-\n\t mangen manifestName appDir [description]\n\n\n");
        goto exit;
    }

    if (PathIsRelative(argv[2]))
    {
        // findfirstfile findnextfile will not work if path is relative...?
        printf("Error: App dir (%s) should not be relative\n", argv[2]);
        goto exit;
    }

    if (!PathCanonicalize(szAppDir, argv[2]))
    {
        printf("App dir (%s) canonicalize error\n", argv[2]);
        goto exit;
    }

    dwAttrib = GetFileAttributes(szAppDir);
    if (dwAttrib == (DWORD)-1 || (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) == 0)
    {
        printf("Error: Invalid app dir (%s)\n", szAppDir);
        goto exit;
    }

    pszExt = PathFindExtension(argv[1]);
    if (strcmp(pszExt, ".manifest") != 0)
    {
        if (_snprintf(szManifestName, MAX_PATH, "%s.manifest", argv[1]) < 0)
        {
            printf("Invalid manifest name/extension, error adding extension\n");
            goto exit;
        }
    }
    else
        strcpy(szManifestName, argv[1]);

    if (PathFileExists(szManifestName))
    {
        int ch = 0;

        printf("Application manifest file exists! Overwrite(y/N)?");
        ch = getchar();
        if (ch != 'Y' && ch != 'y')
            goto exit;

        // clear newline char
        ch = getchar();
        printf("\n");
    }

    // always overwrite...
    hFile = CreateFile(szManifestName, GENERIC_WRITE, 0, NULL, 
            CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    // Failed to open the disk file
    if(hFile == INVALID_HANDLE_VALUE)
    {
        printf("Application manifest file open error\n");
        goto exit;
    }

    if (FAILED(write(hFile, szHeader)))
        goto exit;

    if (FAILED(write(hFile, szAsmidtype)))
        goto exit;

    if (FAILED(write(hFile, szAsmidtypeapp)))
        goto exit;

    // BUGBUG: no error checking and buffer overflow check
    // BUGBUG: use _getws

    if (FAILED(write(hFile, szAsmidname)))
        goto exit;

    printf("enter asm id name (eg. microsoft.webApps.fusionTest): ");
    gets(szName);
    if (FAILED(write(hFile, szName)))
        goto exit;

    if (FAILED(write(hFile, szAsmidver)))
        goto exit;

    printf("enter asm id version (eg. 1.0.0.0): ");
    gets(szVer);
    if (FAILED(write(hFile, szVer)))
        goto exit;

    if (FAILED(write(hFile, szAsmidprocessor)))
        goto exit;

    //optional?? check valid? x86
    printf("enter asm id processor architecture (eg. x86): ");
    gets(szProArch);
    if (FAILED(write(hFile, szProArch)))
        goto exit;

    if (FAILED(write(hFile, szAsmidpkt)))
        goto exit;

    //?? 16 char or 8 byte or 64 bits? 
    printf("enter asm id public key token (eg. 6595b64144ccf1df): ");
    gets(szPkt);
    if (FAILED(write(hFile, szPkt)))
        goto exit;

    if (FAILED(write(hFile, szAsmidlang)))
        goto exit;

    //?? check valid
    printf("enter asm id language (eg. en): ");
    gets(szLang);
    if (FAILED(write(hFile, szLang)))
        goto exit;

    if (FAILED(write(hFile, szEndheader1)))
        goto exit;

    if (argc >= 5)
    {
        if (FAILED(write(hFile, argv[3])))
            goto exit;
    }
    else
    {
        if (FAILED(write(hFile, szDefaultdescription)))
            goto exit;
    }

    if (FAILED(write(hFile, szEndheader2)))
        goto exit;

    // BUGBUG: no error checking and buffer overflow check
    // BUGBUG: use _getws

    if (FAILED(write(hFile, szShellstateprefix)))
        goto exit;

    printf("enter app friendly name (eg. Fusion ClickOnce Test App): ");
    gets(buffer);
    if (FAILED(write(hFile, buffer)))
        goto exit;

    if (FAILED(write(hFile, szShellentry)))
        goto exit;

    printf("enter app entry point (eg. foo.exe): ");
    gets(buffer);
    if (FAILED(write(hFile, buffer)))
        goto exit;

    if (FAILED(write(hFile, szShellimagetype)))
        goto exit;

    printf("enter app entry point's image type {win32Executable, .NetAssembly}: ");
    gets(buffer);
    if (FAILED(write(hFile, buffer)))
        goto exit;

    printf("enter app shortcut hotkey value (optional) (eg. 0): ");
    gets(buffer);

    if (strlen(buffer) != 0)
    {
        if (FAILED(write(hFile, szShellhotkey)))
            goto exit;

        if (FAILED(write(hFile, buffer)))
            goto exit;
    }

    printf("enter app shortcut icon file (optional) (eg. bar.dll): ");
    gets(buffer);

    if (strlen(buffer) != 0)
    {
        if (FAILED(write(hFile, szShelliconfile)))
            goto exit;

        if (FAILED(write(hFile, buffer)))
            goto exit;
    }

    printf("enter app shortcut icon index in the icon file (optional) (eg. 0): ");
    gets(buffer);

    if (strlen(buffer) != 0)
    {
        if (FAILED(write(hFile, szShelliconindex)))
            goto exit;

        if (FAILED(write(hFile, buffer)))
            goto exit;
    }

    printf("enter app shortcut show command (optional) {normal, maximized, minimized}: ");
    gets(buffer);

    if (strlen(buffer) != 0)
    {
        if (FAILED(write(hFile, szShellshowcommand)))
            goto exit;

        if (FAILED(write(hFile, buffer)))
            goto exit;
    }

    if (FAILED(write(hFile, szShellstatepostfix)))
        goto exit;

    printf("\nprocessing app dir...\n");

    {
        char szCurDir[MAX_PATH];
        DWORD ret = 0;

        // note: big hack. doFiles will change current directory
        //     so save it now - 'cos might need it for creating
        //     a subscription manifest

        // ignore error...
        // BUGBUG: > MAX_PATH?
        ret = GetCurrentDirectory(MAX_PATH, szCurDir);

        if (FAILED(doFiles(hFile, szAppDir, szPathFromAppDir)))
            goto exit;

        // set back current dir
        if (ret != 0)
        {
            SetCurrentDirectory(szCurDir);
        }
    }

    if (FAILED(write(hFile, szEndfile)))
        goto exit;

    printf("* Application manifest generated successfully *\n");

    {
        int ch = 0;

        printf("Generate a subscription manifest (y/N)?");
        ch = getchar();
        if (ch != 'Y' && ch != 'y')
            goto exit;

        // clear newline char
        ch = getchar();
        printf("\n");
    }

    pszExt = PathFindExtension(szManifestName);
    *pszExt = '\0';
    {
        int len = lstrlen(szManifestName);

        if (lstrcpyn(szManifestName+len, "subscription.manifest", MAX_PATH-len) == NULL)
        {
            printf("Invalid manifest name/extension, error adding subscription extension\n");
            goto exit;
        }
    }

    if (PathFileExists(szManifestName))
    {
        int ch = 0;

        printf("Subscription manifest file exists! Overwrite(y/N)?");
        ch = getchar();
        if (ch != 'Y' && ch != 'y')
            goto exit;

        // clear newline char
        ch = getchar();
        printf("\n");
    }

    CloseHandle(hFile);

    // always overwrite...
    hFile = CreateFile(szManifestName, GENERIC_WRITE, 0, NULL, 
            CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    // Failed to open the disk file
    if(hFile == INVALID_HANDLE_VALUE)
    {
        printf("Subscription manifest file open error\n");
        goto exit;
    }

    if (FAILED(write(hFile, szHeader)))
        goto exit;
    if (FAILED(write(hFile, szAsmidtype)))
        goto exit;
    if (FAILED(write(hFile, szAsmidtypesub)))
        goto exit;
    if (FAILED(write(hFile, szAsmidname)))
        goto exit;
    if (FAILED(write(hFile, szName)))
        goto exit;
    if (FAILED(write(hFile, ".subscription")))  //.subscription
        goto exit;     
    if (FAILED(write(hFile, szAsmidver)))
        goto exit;
    if (FAILED(write(hFile, szVer))) // have another (auto-generated?) version for subscription?
        goto exit;
    if (FAILED(write(hFile, szAsmidprocessor)))
        goto exit;
    if (FAILED(write(hFile, szProArch)))
        goto exit;
    if (FAILED(write(hFile, szAsmidpkt)))
        goto exit;
    if (FAILED(write(hFile, szPkt)))
        goto exit;
    if (FAILED(write(hFile, szAsmidlang)))
        goto exit;
    if (FAILED(write(hFile, szLang)))
        goto exit;
    if (FAILED(write(hFile, szEndheader1)))
        goto exit;

    if (argc >= 5)
    {
        if (FAILED(write(hFile, argv[3])))
            goto exit;
    }
    else
    {
        if (FAILED(write(hFile, szDefaultdescription)))
            goto exit;
    }

    if (FAILED(write(hFile, szEndheader2)))
        goto exit;

    if (FAILED(write(hFile, szDepend)))
        goto exit;

    if (FAILED(write(hFile, szAsmidtype2)))
        goto exit;
    if (FAILED(write(hFile, szAsmidtypeapp)))
        goto exit;
    if (FAILED(write(hFile, szAsmidname2)))
        goto exit;
    if (FAILED(write(hFile, szName)))
        goto exit;
    if (FAILED(write(hFile, szAsmidver2)))
        goto exit;
    if (FAILED(write(hFile, szVer)))
        goto exit;
    if (FAILED(write(hFile, szAsmidprocessor2)))
        goto exit;
    if (FAILED(write(hFile, szProArch)))
        goto exit;
    if (FAILED(write(hFile, szAsmidpkt2)))
        goto exit;
    if (FAILED(write(hFile, szPkt)))
        goto exit;
    if (FAILED(write(hFile, szAsmidlang2)))
        goto exit;
    if (FAILED(write(hFile, szLang)))
        goto exit;

    if (FAILED(write(hFile, szDependcodebase)))
        goto exit;

    printf("enter codebase for app manifest (eg. http://www.microsoft.com/fooApp/microsoft.webApps.fusionTest.manifest): ");
    gets(buffer);
    if (FAILED(write(hFile, buffer)))
        goto exit;

    if (FAILED(write(hFile, szDependpolling)))
        goto exit;

    printf("enter update polling interval (in milliseconds) (eg. 21600000): ");
    gets(buffer);
    if (FAILED(write(hFile, buffer)))
        goto exit;

    if (FAILED(write(hFile, szEndDepend)))
        goto exit;

    if (FAILED(write(hFile, szEndfile)))
        goto exit;

    printf("* Subscription manifest generated successfully *\n");

exit:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    return 0;
}

// known issues:
// 1. the target manifest file and the import file if present in the app dir
// this program will try to open them up for hashing but will fail because they are already opened
// -> all files in/under the app dir will be listed and hashed as is...
// 2. Note. Be careful with %USERPROFILE% etc when they have space in them. Use quotes.
// 3. Note. Error messages are not the most descriptive. But - you can probably figure out from the
// resulted manifest file. That should be relative easy.

// note: should rename application manifest to app asm id name. application manifest's filename
//      has to be the same as asm id name.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\shortcut\util.cpp ===
#include "project.hpp"
#include <stdio.h>    // for _snwprintf

// * note: debug check/code incomplete.

// ----------------------------------------------------------------------------

//
// Return last Win32 error as an HRESULT.
//
HRESULT
GetLastWin32Error()
{
    // Win 95 can return 0, even when there's an error.
    DWORD dw = GetLastError();
    return dw ? HRESULT_FROM_WIN32(dw) : E_FAIL;
}

// ----------------------------------------------------------------------------

bool
PathAppend(LPWSTR wzDest, LPCWSTR wzSrc)
{
    // shlwapi PathAppend-like
	bool bRetVal = TRUE;
	int iPathLen = 0;
	static WCHAR wzWithSeparator[] = L"\\%s";
	static WCHAR wzWithoutSeparator[] = L"%s";

	if (!wzDest || !wzSrc)
	{
		bRetVal = FALSE;
		goto exit;
	}

	iPathLen = wcslen(wzDest);

    if (_snwprintf(wzDest+iPathLen, MAX_PATH-iPathLen, 
    	(wzDest[iPathLen-1] == L'\\' ? wzWithoutSeparator : wzWithSeparator), wzSrc) < 0)
	{
		bRetVal = FALSE;
	}

exit:
	return bRetVal;
}

// ----------------------------------------------------------------------------

/*----------------------------------------------------------
Purpose: Returns an integer value specifying the length of
         the substring in psz that consists entirely of 
         characters in pszSet.  If psz begins with a character
         not in pszSet, then this function returns 0.

         This is a DBCS-safe version of the CRT strspn().  

Returns: see above
Cond:    --
*/
/*int StrSpnW(LPCWSTR psz, LPCWSTR pszSet)
{
	LPCWSTR pszT;
	LPCWSTR pszSetT;

	ASSERT(psz);
	ASSERT(pszSet);

	// Go thru the string to be inspected 

	for (pszT = psz; *pszT; pszT++)
    {
	    // Go thru the char set

	    for (pszSetT = pszSet; *pszSetT != *pszT; pszSetT++)
	    {
	        if (0 == *pszSetT)
	        {
	            // Reached end of char set without finding a match
	            return (int)(pszT - psz);
	        }
	    }
    }

	return (int)(pszT - psz);
}*/

// find leading spaces
BOOL AnyNonWhiteSpace(PCWSTR pcwz)
{
   ASSERT(! pcwz );

   return(pcwz ? wcsspn(pcwz, g_cwzWhiteSpace) < wcslen(pcwz) : FALSE);	// use (size_t) StrSpnW as above?
}

// ----------------------------------------------------------------------------

BOOL IsValidPath(PCWSTR pcwzPath)
{
   // FEATURE: Beef up path validation.

   return(EVAL((UINT)wcslen(pcwzPath) < MAX_PATH));
}

BOOL IsValidPathResult(HRESULT hr, PCWSTR pcwzPath,
                                   UINT ucbPathBufLen)
{
   return((hr == S_OK &&
           EVAL(IsValidPath(pcwzPath)) &&
           EVAL((UINT)wcslen(pcwzPath) < ucbPathBufLen)) ||
          (hr != S_OK &&
           EVAL(! ucbPathBufLen ||
                ! pcwzPath ||
                ! *pcwzPath)));
}

BOOL IsValidIconIndex(HRESULT hr, PCWSTR pcwzIconFile,
                                  UINT ucbIconFileBufLen, int niIcon)
{
   return(EVAL(IsValidPathResult(hr, pcwzIconFile, ucbIconFileBufLen)) &&
          EVAL(hr == S_OK ||
               ! niIcon));
}

// ----------------------------------------------------------------------------

BOOL IsValidHWND(HWND hwnd)
{
   // Ask User if this is a valid window.

   return(IsWindow(hwnd));
}

#ifdef DEBUG

BOOL IsValidHANDLE(HANDLE hnd)
{
   return(EVAL(hnd != INVALID_HANDLE_VALUE));
}

BOOL IsValidHEVENT(HANDLE hevent)
{
   return(IsValidHANDLE(hevent));
}

BOOL IsValidHFILE(HANDLE hf)
{
   return(IsValidHANDLE(hf));
}

BOOL IsValidHGLOBAL(HGLOBAL hg)
{
   return(IsValidHANDLE(hg));
}

BOOL IsValidHMENU(HMENU hmenu)
{
   return(IsValidHANDLE(hmenu));
}

BOOL IsValidHINSTANCE(HINSTANCE hinst)
{
   return(IsValidHANDLE(hinst));
}

BOOL IsValidHICON(HICON hicon)
{
   return(IsValidHANDLE(hicon));
}

BOOL IsValidHKEY(HKEY hkey)
{
   return(IsValidHANDLE(hkey));
}

BOOL IsValidHMODULE(HMODULE hmod)
{
   return(IsValidHANDLE(hmod));
}

BOOL IsValidHPROCESS(HANDLE hprocess)
{
   return(IsValidHANDLE(hprocess));
}

BOOL IsValidHTEMPLATEFILE(HANDLE htf)
{
   return(IsValidHANDLE(htf));
}

BOOL IsValidShowCmd(int nShow)
{
   BOOL bResult;

   switch (nShow)
   {
      case SW_HIDE:
      case SW_MINIMIZE:
      case SW_MAXIMIZE:
      case SW_RESTORE:
      case SW_SHOW:
      case SW_SHOWNORMAL:
      case SW_SHOWDEFAULT:
      case SW_SHOWMINIMIZED:
      case SW_SHOWMAXIMIZED:
      case SW_SHOWNOACTIVATE:
      case SW_SHOWMINNOACTIVE:
      case SW_SHOWNA:
      case SW_FORCEMINIMIZE:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidShowCmd(): Invalid show command %d.",
                    nShow));
         break;
   }

   return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\tools\test\test.cpp ===
#include <windows.h>
#include <fusenet.h>


int __cdecl wmain(int argc, LPWSTR *argv)
{
    HRESULT hr = S_OK;
    LPASSEMBLY_MANIFEST_IMPORT  pManifestImport;
    IXMLDOMNodeList *pPatchInfoList;
    LPASSEMBLY_IDENTITY pAssemblyId = NULL;
    LPWSTR source, target, patchfile;
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED); 

/*    //hr = CreateAssemblyIdentityEx(&pAssemblyId, 0, L"x86_peters.app_ABCDEFG_1.2.3.4_en");
    hr = CreateAssemblyManifestImport(&pManifestImport, L"C:\\Documents and Settings\\t-peterf\\Desktop\\microsoft.webapps.msn6.manifest");
    hr = pManifestImport -> GetNextPatchAssemblyId (0, &pAssemblyId);
    hr = pManifestImport -> GetNextPatchMapping(2, pAssemblyId, &source, &target, &patchfile);
  */  
    HANDLE hNamedEvent;
    

//    hNamedEvent = CreateEventA(NULL,FALSE,FALSE,NULL);

    IAssemblyDownload *pDownload;
    hr = CreateAssemblyDownload(&pDownload);    
    pDownload->DownloadManifestAndDependencies(argv[1], NULL, DOWNLOAD_FLAGS_PROGRESS_UI);

//    pDownload->DownloadManifestAndDependencies(L"http://adriaanc5//microsoft.webapps.msn6.manifest",NULL, DOWNLOAD_FLAGS_PROGRESS_UI);
//    WaitForSingleObject(hNamedEvent, INFINITE); 

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\util\cstrings.cpp ===
#pragma once

#define CRT_ALLOC 0
#define COM_ALLOC 1

#include <windows.h>
#include <shlwapi.h>
#include <util.h>
#include <objbase.h>
#include <cstrings.h>



//-----------------------------------------------------------------------------
// Minimal string class
//-----------------------------------------------------------------------------

// ctor
CString::CString()
{
    _dwSig = 'NRTS';
    _pwz = NULL;
    _cc = 0;
    _ccBuf = 0;
    _eAlloc = CRT_Allocator;
    _hr = S_OK;
}


// ctor w/ allocator
CString::CString(AllocFlags eAlloc)
{
    _dwSig = 'NRTS';
    _pwz = NULL;
    _cc = 0;
    _ccBuf = 0;
    _eAlloc = eAlloc;
    _hr = S_OK;
}





// dtor
CString::~CString()
{
    FreeBuffer();
}

// Allocations
HRESULT CString::ResizeBuffer(DWORD ccNew)
{
    LPWSTR pwzNew = NULL;
    DWORD  ccOriginal = 0;
    
    if (ccNew < _ccBuf)
        return (_hr = S_OK);

    if (_eAlloc == CRT_Allocator)
        pwzNew = new WCHAR[ccNew];
    else if (_eAlloc == COM_Allocator)
        pwzNew = (LPWSTR) CoTaskMemAlloc(ccNew * sizeof(WCHAR));
    
    if (!pwzNew)
        return (_hr = E_OUTOFMEMORY);

    if (_pwz && _cc)
        memcpy(pwzNew, _pwz, _cc * sizeof(WCHAR));
    
    ccOriginal = _cc;
    
    FreeBuffer();
    
    _pwz = pwzNew;
    _cc  = ccOriginal;
    _ccBuf = ccNew;
    
    return _hr;
}


// Deallocations
VOID CString::FreeBuffer()
{
    if (_eAlloc == CRT_Allocator)
    {    
        SAFEDELETEARRAY(_pwz);
    }
    else if (_eAlloc == COM_Allocator)
    {
        if (_pwz)
            CoTaskMemFree(_pwz);
        _pwz = NULL;
    }
    _cc = 0;
    _ccBuf = 0;
}

// assume control for a buffer.
HRESULT CString::TakeOwnership(WCHAR* pwz, DWORD cc)
{
    if (!pwz)
        return (_hr = E_INVALIDARG);

    FreeBuffer();
    _pwz = pwz;

    if (cc)
        _cc = _ccBuf = cc;
    else
        _cc = _ccBuf = lstrlen(_pwz) + 1;
    return S_OK;
}

HRESULT CString::TakeOwnership(LPWSTR pwz)
{
    return TakeOwnership(pwz, 0);
}

// Release control.
HRESULT CString::ReleaseOwnership()
{
    _pwz = NULL;
    _cc = _ccBuf = 0;
    return S_OK;
}
        
// Direct copy assign from string.
HRESULT CString::Assign(LPWSTR pwzSource)
{
    if (!pwzSource)
        return(_hr = E_INVALIDARG);

    FreeBuffer();
    
    DWORD ccSource = lstrlen(pwzSource) + 1;
    if (FAILED(_hr = ResizeBuffer(ccSource)))
        return _hr;
    
    _cc = ccSource;
    memcpy(_pwz, pwzSource, _cc * sizeof(WCHAR));
    return _hr;        
}

// Direct copy assign from CString
HRESULT CString::Assign(CString& sSource)
{
    return Assign(sSource._pwz);
}

// Append given wchar string.
HRESULT CString::Append(LPWSTR pwzSource)
{
    DWORD ccSource, ccRequired;

    if (!pwzSource)
        return (_hr = E_INVALIDARG);
    
    ccSource = lstrlen(pwzSource) + 1;
    ccRequired = _cc + ccSource;
    if (_cc)
        ccRequired--;
    
    if (FAILED(_hr = ResizeBuffer(ccRequired)))
        return _hr;

    memcpy(_pwz + (_cc ? _cc-1 : 0), 
        pwzSource, ccSource * sizeof(WCHAR));

    _cc = ccRequired;

    return _hr;
}

// Append given CString
HRESULT CString::Append(CString& sSource)
{        
    DWORD ccSource, ccRequired;

    if ((!sSource._pwz)
        || (!(sSource._eAlloc == _eAlloc)))
        return (_hr = E_INVALIDARG);
            
    ccRequired = _cc + sSource._cc;
    if (_cc)
        ccRequired--;

    if (FAILED(_hr = ResizeBuffer(ccRequired)))
        return _hr;

    memcpy(_pwz + (_cc ? _cc-1 : 0), sSource._pwz, sSource._cc * sizeof(WCHAR));

    _cc = ccRequired;
    return _hr;
}

// Return ith element.
WCHAR&  CString::operator [] (DWORD i) 
{ 
    return _pwz[i]; 
}


// last element as string
HRESULT CString::LastElement(CString &sSource)
{
    LPWSTR pwz = _pwz + _cc;
    while ((pwz != _pwz) && (*pwz != L'\\') && (*pwz != L'/'))
        pwz--;

    sSource.Assign(pwz+1);
    return S_OK;
}


// remove last element, also the L'\\' or L'/'
HRESULT CString::RemoveLastElement()
{
    LPWSTR pwz = _pwz + _cc;
    while ((pwz != _pwz) && (*pwz != L'\\') && (*pwz != L'/'))
        pwz--;

    *pwz = L'\0';
    _cc = lstrlen(_pwz) + 1;        
    return S_OK;
}

// shlwapi either path- or url-combine
HRESULT CString::Combine(LPWSTR pwzSource, BOOL fUrl)
{
    LPWSTR pwzDir = NULL;
    DWORD ccSource = 0, ccCombined = 0, dwFlags = 0;
    ccSource = lstrlen(pwzSource) + 1;
    ccCombined = _cc + ccSource;

    if (FAILED(_hr = ResizeBuffer(ccCombined)))
        return _hr;

    pwzDir = WSTRDupDynamic(_pwz);
    if (fUrl)
        // see msdn on UrlCombine...
        ::UrlCombine(pwzDir, pwzSource, _pwz, &ccCombined, dwFlags);
    else
        ::PathCombine(_pwz, pwzDir, pwzSource);
        
    _cc = lstrlen(_pwz) + 1;
    SAFEDELETEARRAY(pwzDir);
    return S_OK;
}

HRESULT CString::PathCombine(LPWSTR pwzSource)
{
    return Combine(pwzSource, FALSE);
}

HRESULT CString::PathCombine(CString &sSource)
{
    return Combine(sSource._pwz, FALSE);
}

HRESULT CString::UrlCombine(LPWSTR pwzSource)
{
    return Combine(pwzSource, TRUE);
}

HRESULT CString::UrlCombine(CString &sSource)
{
    return Combine(sSource._pwz, TRUE);
}


HRESULT CString::PathFindFileName(LPWSTR *ppwz)
{
    *ppwz = ::PathFindFileName(_pwz);
    return S_OK;
}

HRESULT CString::PathFindFileName(CString &sPath)
{
    LPWSTR pwzFileName = NULL;
    pwzFileName = ::PathFindFileName(_pwz);
    sPath.Assign(pwzFileName);
    return S_OK;
}

HRESULT CString::PathPrefixMatch(LPWSTR pwzPrefix)
{
    DWORD ccPrefix = lstrlen(pwzPrefix);
    if (!StrNCmpI(_pwz, pwzPrefix, ccPrefix))
        return S_OK;
    return S_FALSE;
}
        

// / -> \ in string
VOID CString::PathNormalize()
{
    LPWSTR ptr = _pwz;

    while (*ptr)
    {
        if (*ptr == L'/')
            *ptr = L'\\';
        ptr++;
    }
}

VOID CString::Get65599Hash(LPDWORD pdwHash, DWORD dwFlags)
{
    ULONG TmpHashValue = 0;

    if (pdwHash != NULL)
        *pdwHash = 0;

    DWORD cc = _cc;
    LPWSTR pwz = _pwz;
    
    if (dwFlags == CaseSensitive)
    {
        while (cc-- != 0)
        {
            WCHAR Char = *pwz++;
            TmpHashValue = (TmpHashValue * 65599) + (WCHAR) ::CharUpperW((PWSTR) Char);
        }
    }
    else
    {
        while (cc-- != 0)
            TmpHashValue = (TmpHashValue * 65599) + *pwz++;
    }

    *pdwHash = TmpHashValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\oleaut32\whistler\dllmain.cpp ===
#include <windows.h>
 
// #pragma comment(linker, "-ignore:4222")

#if DBG
EXTERN_C
NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#else
#define ASSERT( exp ) /* nothing */
#endif // DBG

HINSTANCE g_hInstance;

EXTERN_C
BOOL
DllMain(
    HINSTANCE hInstDLL,
    DWORD dwReason,
    LPVOID pvReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        ::DisableThreadLibraryCalls(hInstDLL);
        break;
    }

    return TRUE;
}

STDAPI
DllCanUnloadNow()
{
    return S_FALSE;
}

STDAPI
DllRegisterServer()
{
    // You should not register the side-by-side oleaut32...
    ASSERT(FALSE);
    return E_UNEXPECTED;
}

STDAPI
DllUnregisterServer()
{
    // You should not register/unregister the side-by-side oleaut32...
    ASSERT(FALSE);
    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\shell\mimefilter\mfilter.cpp ===
//
// Copyright (c) 2001 Microsoft Corporation
//
//

#include "mfilter.h"
#include <stdio.h> // for _snwprintf

// note: a bit hacky to use something that's implemented under shell\shortcut
#include "project.hpp"  // for extern HRESULT GetLastWin32Error(); only


// {2B3C580C-9BE6-44c5-9BB5-558F7EEF58E2}
static const GUID CLSID_FusionMimeFilter = 
{ 0x2b3c580c, 0x9be6, 0x44c5, { 0x9b, 0xb5, 0x55, 0x8f, 0x7e, 0xef, 0x58, 0xe2 } };

extern ULONG DllAddRef(void);
extern ULONG DllRelease(void);


WCHAR g_wzAdString[] = { L"<html><head><title>Downloading Fusion ClickOnce App...</title></head><body><form><script Language=\"JScript\">\ndocument.write('<font face=\"Arial, Helvetica, Geneva, sans-serif\">Brought to you by <b>Microsoft</b>,<br><b>Fusion ClickOnce</b><br><br><a target=\"_blank\" href=\"http://www.microsoft.com\"><img src=\"http://www.microsoft.com/library/homepage/images/ms-banner.gif\" border=0 width=250 height=60></a></font>\\n');\nresizeTo(350, 300);\nwindow.status=\"download started\";\n</script><noscript>Brought to you by Microsoft,<br>Fusion ClickOnce<br><br><a target=\"_blank\" href=\"http://www.microsoft.com\"><img src=\"http://www.microsoft.com/library/homepage/images/ms-banner.gif\" border=0 width=250 height=60></a></noscript><br></form></body></html>" };
ULONG g_cbAdLen = sizeof(g_wzAdString)-sizeof(WCHAR);    //strlen - ending L'\0'


// BUGBUG: look for the Open verb and its command string in the registry and execute that instead
// rundll32.exe should be in c:\windows\system32
#define WZ_EXEC_STRING      L"rundll32.exe fnsshell.dll,Start \"%s\" \"%s\""


// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

CFusionMimeFilterClassFactory::CFusionMimeFilterClassFactory()
{
    _cRef = 1;
}

// ----------------------------------------------------------------------------

HRESULT
CFusionMimeFilterClassFactory::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IClassFactory)
    {
        *ppv = (IClassFactory *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    ((IUnknown *)*ppv)->AddRef();

exit:
    return hr;
}

// ----------------------------------------------------------------------------

ULONG
CFusionMimeFilterClassFactory::AddRef()
{
    return (ULONG) InterlockedIncrement(&_cRef);
}

ULONG
CFusionMimeFilterClassFactory::Release()
{
    LONG ulCount = InterlockedDecrement(&_cRef);

    if (ulCount <= 0)
    {
        delete this;
    }

    return (ULONG) ulCount;
}

HRESULT
CFusionMimeFilterClassFactory::LockServer(BOOL lock)
{
    return (lock ? 
            DllAddRef() :
            DllRelease());
}

// ----------------------------------------------------------------------------

HRESULT
CFusionMimeFilterClassFactory::CreateInstance(IUnknown* pUnkOuter, REFIID iid, void** ppv)
{
    HRESULT hr = S_OK;
    CFusionMimeFilter *pMimeFilter = NULL;

	*ppv = NULL;

    if (pUnkOuter && iid != IID_IUnknown)
    {
        hr = CLASS_E_NOAGGREGATION;
        goto exit;
    }

    pMimeFilter = new CFusionMimeFilter();
    if (pMimeFilter == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (iid == IID_IUnknown)
    {
        *ppv = (IInternetProtocol *)pMimeFilter;
        pMimeFilter->AddRef();
    }
    else
    {
        hr = pMimeFilter->QueryInterface(iid, ppv);
        if (FAILED(hr))
            goto exit;
    }

exit:
    if (pMimeFilter)
        pMimeFilter->Release();

    return hr;
}

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

#define BUFFER_READ_SIZE 4096
static BYTE g_buffer[BUFFER_READ_SIZE + sizeof(WCHAR)]; // BUGBUG?: why '+sizeof(WCHAR)?'

// ----------------------------------------------------------------------------
// CFusionMimeFilter

CFusionMimeFilter::CFusionMimeFilter()
{
    _cRef = 1;
    _fFirstRead = TRUE;
    _fReadDone = FALSE;
    _pOutgoingProtSink = NULL;
    _pIncomingProt = NULL;
    _grfSTI = 0;

    _pwzUrl = NULL;

    _wzTempFile[0] = L'\0';
    _hFile = 0; //INVALID_HANDLE_VALUE;

    _cbAdRead = 0;
}

CFusionMimeFilter::~CFusionMimeFilter()
{
    if (_pwzUrl)
        delete _pwzUrl;

    if (_pIncomingProt)
    {
        _pIncomingProt->Release();
        _pIncomingProt = NULL;
    }

    if (_pOutgoingProtSink)
    {
        _pOutgoingProtSink->Release();
        _pOutgoingProtSink = NULL;
    }

    CloseTempFile();	// ignore return value
}

// ----------------------------------------------------------------------------

HRESULT
CFusionMimeFilter::QueryInterface(REFIID iid,  void** ppv)
{
    HRESULT hr = S_OK;
    *ppv = NULL;

    if (iid == IID_IInternetProtocol ||
        iid == IID_IInternetProtocolRoot ||
        iid == IID_IUnknown)
    {
        *ppv = (IInternetProtocol *)this;
    }
    else if (iid == IID_IInternetProtocolSink)
    {
        *ppv = (IInternetProtocolSink *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    ((IUnknown *)*ppv)->AddRef();

exit:
    return hr;
}

// ----------------------------------------------------------------------------

ULONG
CFusionMimeFilter::AddRef()
{
    return (ULONG) InterlockedIncrement(&_cRef);
}

ULONG
CFusionMimeFilter::Release()
{
    LONG ulCount = InterlockedDecrement(&_cRef);

    if (ulCount <= 0)
    {
        delete this;
    }

    return (ULONG) ulCount;
}

// ----------------------------------------------------------------------------
// IInternetProtocol interface

HRESULT
CFusionMimeFilter::Start(
        LPCWSTR wzUrl,
        IInternetProtocolSink *pIProtSink,
        IInternetBindInfo *pIBindInfo,
        DWORD grfSTI,
        DWORD dwReserved)
{
    HRESULT hr = E_FAIL;
    _grfSTI = grfSTI;

    if (!(grfSTI & PI_FILTER_MODE))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        WCHAR* string[1];
        ULONG ulCount = 0;

        string[0] = NULL;
        // copy the URL
        // param wzUrl is the mime Content Type for plug mime filter
        // so have to get the real url this way
        if (FAILED(hr=pIBindInfo->GetBindString(BINDSTRING_URL, string, 1, &ulCount)))
            goto exit;

        if (_pwzUrl)
            delete _pwzUrl;

        _pwzUrl = new WCHAR[wcslen(string[0])+1];
        if (!_pwzUrl)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        wcscpy(_pwzUrl, string[0]);

        // get the protocol pointer from reserved pointer
        PROTOCOLFILTERDATA* ProtFiltData = (PROTOCOLFILTERDATA*) dwReserved;
        if (NULL != _pIncomingProt)
        {
            hr = E_UNEXPECTED;
            goto exit;
        }
		
        if (NULL == ProtFiltData->pProtocol)
        {
            // !! We can't do anything without an interface to read from
            hr = E_INVALIDARG;
            goto exit;
        }

        _pIncomingProt = ProtFiltData->pProtocol;
        _pIncomingProt->AddRef();

        // hold onto the sink as well
        if (NULL != _pOutgoingProtSink)
        {
            hr = E_UNEXPECTED;
            goto exit;
        }

        _pOutgoingProtSink = pIProtSink;
        _pOutgoingProtSink->AddRef();

        _fFirstRead = TRUE;

        hr = S_OK;
    }

exit:
    return hr;
}

HRESULT
CFusionMimeFilter::Continue(PROTOCOLDATA *pProtData)
{
    HRESULT hr;
    if (NULL == _pIncomingProt)
        hr = E_UNEXPECTED;
	else
	    hr = _pIncomingProt->Continue(pProtData);

	return hr;
}

HRESULT
CFusionMimeFilter::Abort(HRESULT hrReason,DWORD dwOptions)
{
    HRESULT hr;
    if (NULL == _pIncomingProt)
        hr = E_UNEXPECTED;
	else
	    hr = _pIncomingProt->Abort(hrReason, dwOptions);

	return hr;
}

HRESULT
CFusionMimeFilter::Terminate(DWORD dwOptions)
{
    HRESULT hr = S_OK;

    // Release the sink
    if (_pOutgoingProtSink)
        _pOutgoingProtSink->Release();

    if (NULL == _pIncomingProt)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    hr = _pIncomingProt->Terminate(dwOptions);

exit:
    return hr;
}

HRESULT
CFusionMimeFilter::Suspend()
{
    HRESULT hr;
    if (NULL == _pIncomingProt)
        hr = E_UNEXPECTED;
    else
        hr = _pIncomingProt->Suspend();

    return hr;
}

HRESULT
CFusionMimeFilter::Resume()
{
    HRESULT hr;
    if (NULL == _pIncomingProt)
        hr = E_UNEXPECTED;
    else
        hr = _pIncomingProt->Resume();

    return hr;
}

HRESULT
CFusionMimeFilter::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr = S_OK;
    HRESULT hrFromProt;

    BYTE* pbuff = g_buffer;
    ULONG cbReadFromProt;
    DWORD cbWritten = 0;

    // Read() can be called multiple times after it is done (and Prot Handler will return S_FALSE)
    // this ensure the followings are called once only
    if (!_fReadDone)
    {
        // retrieve requested amount of data from protocol handler
        hrFromProt = _pIncomingProt->Read((void*)pbuff, BUFFER_READ_SIZE, &cbReadFromProt);
        if (E_PENDING != hrFromProt) // may have some extra data in our buffer, so continue
        {
            if (FAILED(hrFromProt))
            {
                hr = hrFromProt;
                goto exit;
            }
            else 
            {
                // write data to a temp file
                if (cbReadFromProt > 0)
                {
                    if (_fFirstRead)
                    {
                        if (FAILED(hr=OpenTempFile()))
                            goto exit;

                        _fFirstRead = FALSE;
                    }
                    if ( !WriteFile(_hFile, pbuff, cbReadFromProt, &cbWritten, NULL) || 
                        cbWritten != cbReadFromProt )
                    {
                        hr = GetLastWin32Error();
                        goto exit;
                    }
                }

                // prot handler will let us know when there is no more data left
                if (S_FALSE == hrFromProt)
                {
                    STARTUPINFO si;
                    PROCESS_INFORMATION pi;
                    WCHAR wzCmdLine[MAX_PATH];  // BUGBUG: string length limitation...

                    if (FAILED(hr=CloseTempFile()))
                        goto exit;

                    if (_snwprintf(wzCmdLine, sizeof(wzCmdLine),
                        WZ_EXEC_STRING, _wzTempFile, _pwzUrl) < 0)
                    {
                        hr = CO_E_PATHTOOLONG;
                        goto exit;
                    }

                    ZeroMemory(&si, sizeof(si));
                    ZeroMemory(&pi, sizeof(pi));
                    si.cb = sizeof(si);

                    // this child process must delete the temp file....
                    if(!CreateProcess(NULL, wzCmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
                    {
                        hr = GetLastWin32Error();
                    }

                    if(pi.hThread) CloseHandle(pi.hThread);
                    if(pi.hProcess) CloseHandle(pi.hProcess);

                    _fReadDone = TRUE;

                    // note: this few lines must follow the CreateProcess
                    if (FAILED(hr))
                        goto exit;
                }
            }
        }
    }

    // switch the MIME type here
    _pOutgoingProtSink->ReportProgress(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, CONTENT_TYPE);

    // return customer's ad in the browser - this can be taken from a file on disk or inside the file this is read above
    // right now it's just a simple implementation
    if (_cbAdRead >= g_cbAdLen)
    {
        if (_fReadDone)
            hr = S_FALSE;
        else
            // hold till _pIncomingProt is done
            hr = E_PENDING;
    }
    else
    {
        ULONG cbDataAvail = g_cbAdLen-_cbAdRead;
        
        if (cb < cbDataAvail)
            cbDataAvail = cb;

        // note BYTE pointer increment not LPWSTR pointer style
        memcpy(pv, ((BYTE*)g_wzAdString)+_cbAdRead, cbDataAvail);
        _cbAdRead += cbDataAvail;
        *pcbRead = cbDataAvail;

        hr = S_OK;
    }
    
exit:
    return hr;
}

HRESULT
CFusionMimeFilter::Seek(
        LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER *plibNewPosition)
{
    return E_NOTIMPL;
}

HRESULT
CFusionMimeFilter::LockRequest(DWORD dwOptions)
{
    return S_OK;
}

HRESULT
CFusionMimeFilter::UnlockRequest()
{
    return S_OK;
}

// ----------------------------------------------------------------------------
// IInternetProtocolSink interface
HRESULT
CFusionMimeFilter::Switch(PROTOCOLDATA __RPC_FAR *pProtocolData)
{
    HRESULT hr;
    if (NULL == _pOutgoingProtSink)
        hr = E_UNEXPECTED;
    else
        hr = _pOutgoingProtSink->Switch(pProtocolData);

    return hr;
}

HRESULT
CFusionMimeFilter::ReportProgress(ULONG ulStatusCode, LPCWSTR szStatusText)
{
    HRESULT hr;
    if (NULL == _pOutgoingProtSink)
        hr = E_UNEXPECTED;
    else
	    hr = _pOutgoingProtSink->ReportProgress(ulStatusCode, szStatusText);

    return hr;
}

HRESULT
CFusionMimeFilter::ReportData(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax)
{
    HRESULT hr;
    if (NULL == _pOutgoingProtSink)
        hr = E_UNEXPECTED;
    else
	    hr = _pOutgoingProtSink->ReportData(grfBSCF, ulProgress, ulProgressMax);

    return hr;
}

HRESULT
CFusionMimeFilter::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR szResult)
{
    HRESULT hr;
    if (NULL == _pOutgoingProtSink)
        hr = E_UNEXPECTED;
    else
        hr = _pOutgoingProtSink->ReportResult(hrResult, dwError, szResult);

    return hr;
}

// ----------------------------------------------------------------------------

HRESULT
CFusionMimeFilter::OpenTempFile()
{
    HRESULT hr = S_OK;
    HANDLE hTempFile;

    static WCHAR wzTempPath[MAX_PATH+32] = {0};

    if (!wzTempPath[0])
    {
        if (GetTempPath(MAX_PATH, wzTempPath) == 0)
        {
            hr = GetLastWin32Error();
            goto exit;
        }
    }

    if (_wzTempFile[0] == L'\0')
    {
        if (GetTempFileName(wzTempPath, L"FMA", 0, _wzTempFile))	// fusion manifest file
        {
            // the file should be deleted afterwards
            DWORD dwFileAtr = FILE_ATTRIBUTE_TEMPORARY;

            // the handling child process must delete the temp file....
            hTempFile = CreateFile(_wzTempFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, dwFileAtr, NULL);
            if (hTempFile == INVALID_HANDLE_VALUE)
            {
                _hFile = 0;
                hr = GetLastWin32Error();
                goto exit;
            }
            else
            {
                _pOutgoingProtSink->ReportProgress(BINDSTATUS_CACHEFILENAMEAVAILABLE, _wzTempFile);
                _hFile = hTempFile;
            }
        }
    }

exit:
    return hr;
}

HRESULT
CFusionMimeFilter::CloseTempFile()
{
    HRESULT hr = E_FAIL;

    if (_hFile)
    {
        CloseHandle(_hFile);
        _hFile = 0;
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\installer\util\serialst.cpp ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    serialst.cxx

Abstract:

    Functions to deal with a serialized list. These are replaced by macros in
    the retail version

    Contents:
        [InitializeSerializedList]
        [TerminateSerializedList]
        [LockSerializedList]
        [UnlockSerializedList]
        [InsertAtHeadOfSerializedList]
        [InsertAtTailOfSerializedList]
        [RemoveFromSerializedList]
        [IsSerializedListEmpty]
        [HeadOfSerializedList]
        [TailOfSerializedList]
        [CheckEntryOnSerializedList]
        [(CheckEntryOnList)]
        SlDequeueHead
        SlDequeueTail
        IsOnSerializedList

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Environment:

    Win-32 user level

Revision History:

    16-Feb-1995 rfirth
        Created

    05-Jul-1999 adriaanc
        nabbed for fusion
--*/

#include "debmacro.h"
#include <windows.h>
#include "serialst.h"



#if DBG

#if !defined(PRIVATE)
#define PRIVATE static
#endif

#if !defined(DEBUG_FUNCTION)
#define DEBUG_FUNCTION
#endif

#if !defined(DEBUG_PRINT)
#define DEBUG_PRINT(foo, bar, baz)
#endif

#if !defined(ENDEXCEPT)
#define ENDEXCEPT
#endif

#if !defined(DEBUG_BREAK)
#define DEBUG_BREAK(foo) DebugBreak()
#endif

//
// manifests
//

#define SERIALIZED_LIST_SIGNATURE   'tslS'

//
// private prototypes
//

PRIVATE
DEBUG_FUNCTION
BOOL
CheckEntryOnList(
    IN PLIST_ENTRY List,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    );

//
// data
//

BOOL fCheckEntryOnList = FALSE;
BOOL ReportCheckEntryOnListErrors = FALSE;

//
// functions
//


DEBUG_FUNCTION
VOID
InitializeSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    initializes a serialized list

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    None.

--*/

{
    ASSERT(SerializedList != NULL);

    SerializedList->Signature = SERIALIZED_LIST_SIGNATURE;
    SerializedList->LockCount = 0;

#if 0
    // removed 1/7/2000 by mgrier - bad debug build
    INITIALIZE_RESOURCE_INFO(&SerializedList->ResourceInfo);
#endif // 0

    InitializeListHead(&SerializedList->List);
    SerializedList->ElementCount = 0;
    InitializeCriticalSection(&SerializedList->Lock);
}


DEBUG_FUNCTION
VOID
TerminateSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Undoes InitializeSerializeList

Arguments:

    SerializedList  - pointer to serialized list to terminate

Return Value:

    None.

--*/

{
    ASSERT(SerializedList != NULL);
    ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    ASSERT(SerializedList->ElementCount == 0);

    if (SerializedList->ElementCount != 0) {

        DEBUG_PRINT(SERIALST,
                    ERROR,
                    ("list @ %#x has %d elements, first is %#x\n",
                    SerializedList,
                    SerializedList->ElementCount,
                    SerializedList->List.Flink
                    ));

    } else {

        ASSERT(IsListEmpty(&SerializedList->List));

    }
    DeleteCriticalSection(&SerializedList->Lock);
}


DEBUG_FUNCTION
VOID
LockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Acquires a serialized list locks

Arguments:

    SerializedList  - SERIALIZED_LIST to lock

Return Value:

    None.

--*/

{
    ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    ASSERT(SerializedList->LockCount >= 0);

    EnterCriticalSection(&SerializedList->Lock);
    if (SerializedList->LockCount != 0) {

        ASSERT(SerializedList->ResourceInfo.Tid == GetCurrentThreadId());

    }
    ++SerializedList->LockCount;
    SerializedList->ResourceInfo.Tid = GetCurrentThreadId();
}


DEBUG_FUNCTION
VOID
UnlockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Releases a serialized list lock

Arguments:

    SerializedList  - SERIALIZED_LIST to unlock

Return Value:

    None.

--*/

{
    ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    ASSERT(SerializedList->ResourceInfo.Tid == GetCurrentThreadId());
    ASSERT(SerializedList->LockCount > 0);

    --SerializedList->LockCount;
    LeaveCriticalSection(&SerializedList->Lock);
}


DEBUG_FUNCTION
VOID
InsertAtHeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Adds an item to the head of a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to update

    Entry           - thing to update it with

Return Value:

    None.

--*/

{
    ASSERT(Entry != &SerializedList->List);

    LockSerializedList(SerializedList);
    if (fCheckEntryOnList) {
        CheckEntryOnList(&SerializedList->List, Entry, FALSE);
    }
    InsertHeadList(&SerializedList->List, Entry);
    ++SerializedList->ElementCount;

    ASSERT(SerializedList->ElementCount > 0);

    UnlockSerializedList(SerializedList);
}


DEBUG_FUNCTION
VOID
InsertAtTailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Adds an item to the head of a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to update

    Entry           - thing to update it with

Return Value:

    None.

--*/

{
    ASSERT(Entry != &SerializedList->List);

    LockSerializedList(SerializedList);
    if (fCheckEntryOnList) {
        CheckEntryOnList(&SerializedList->List, Entry, FALSE);
    }
    InsertTailList(&SerializedList->List, Entry);
    ++SerializedList->ElementCount;

    ASSERT(SerializedList->ElementCount > 0);

    UnlockSerializedList(SerializedList);
}


VOID
DEBUG_FUNCTION
RemoveFromSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Removes the entry from a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to remove entry from

    Entry           - pointer to entry to remove

Return Value:

    None.

--*/

{
    ASSERT((Entry->Flink != NULL) && (Entry->Blink != NULL));

    LockSerializedList(SerializedList);
    if (fCheckEntryOnList) {
        CheckEntryOnList(&SerializedList->List, Entry, TRUE);
    }

    ASSERT(SerializedList->ElementCount > 0);

    RemoveEntryList(Entry);
    --SerializedList->ElementCount;
    Entry->Flink = NULL;
    Entry->Blink = NULL;
    UnlockSerializedList(SerializedList);
}


DEBUG_FUNCTION
BOOL
IsSerializedListEmpty(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Checks if a serialized list contains any elements

Arguments:

    SerializedList  - pointer to list to check

Return Value:

    BOOL

--*/

{
    LockSerializedList(SerializedList);

    ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    BOOL empty;

    if (IsListEmpty(&SerializedList->List)) {

        ASSERT(SerializedList->ElementCount == 0);

        empty = TRUE;
    } else {

        ASSERT(SerializedList->ElementCount != 0);

        empty = FALSE;
    }

    UnlockSerializedList(SerializedList);

    return empty;
}


DEBUG_FUNCTION
PLIST_ENTRY
HeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Returns the element at the tail of the list, without taking the lock

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    PLIST_ENTRY
        pointer to element at tail of list

--*/

{
    ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    return SerializedList->List.Flink;
}


DEBUG_FUNCTION
PLIST_ENTRY
TailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Returns the element at the tail of the list, without taking the lock

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    PLIST_ENTRY
        pointer to element at tail of list

--*/

{
    ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    return SerializedList->List.Blink;
}


DEBUG_FUNCTION
BOOL
CheckEntryOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    )

/*++

Routine Description:

    Checks an entry exists (or doesn't exist) on a list

Arguments:

    SerializedList  - pointer to serialized list

    Entry           - pointer to entry

    ExpectedResult  - TRUE if expected on list, else FALSE

Return Value:

    BOOL
        TRUE    - expected result

        FALSE   - unexpected result

--*/

{
    ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    LockSerializedList(SerializedList);

    BOOL result;

    __try {
        result = CheckEntryOnList(&SerializedList->List, Entry, ExpectedResult);
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DEBUG_PRINT(SERIALST,
                    FATAL,
                    ("List @ %#x (%d elements) is bad\n",
                    SerializedList,
                    SerializedList->ElementCount
                    ));

        result = FALSE;
    }
    ENDEXCEPT
    UnlockSerializedList(SerializedList);

    return result;
}


PRIVATE
DEBUG_FUNCTION
BOOL
CheckEntryOnList(
    IN PLIST_ENTRY List,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    )
{
    BOOLEAN found = FALSE;
    PLIST_ENTRY p;

    if (!IsListEmpty(List)) {
        for (p = List->Flink; p != List; p = p->Flink) {
            if (p == Entry) {
                found = TRUE;
                break;
            }
        }
    }
    if (found != ExpectedResult) {
        if (ReportCheckEntryOnListErrors) {

            LPSTR description;

            description = found
                        ? "Entry %#x already on list %#x\n"
                        : "Entry %#x not found on list %#x\n"
                        ;

            DEBUG_PRINT(SERIALST,
                        ERROR,
                        (description,
                        Entry,
                        List
                        ));

            DEBUG_BREAK(SERIALST);

        }
        return FALSE;
    }
    return TRUE;
}

#endif // DBG

//
// functions that are always functions
//


LPVOID
SlDequeueHead(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Dequeues the element at the head of the queue and returns its address or
    NULL if the queue is empty

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST to dequeue from

Return Value:

    LPVOID

--*/

{
    LPVOID entry;

    if (!IsSerializedListEmpty(SerializedList)) {
        LockSerializedList(SerializedList);
        if (!IsSerializedListEmpty(SerializedList)) {
            entry = (LPVOID)HeadOfSerializedList(SerializedList);
            RemoveFromSerializedList(SerializedList, (PLIST_ENTRY)entry);
        } else {
            entry = NULL;
        }
        UnlockSerializedList(SerializedList);
    } else {
        entry = NULL;
    }
    return entry;
}


LPVOID
SlDequeueTail(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Dequeues the element at the tail of the queue and returns its address or
    NULL if the queue is empty

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST to dequeue from

Return Value:

    LPVOID

--*/

{
    LPVOID entry;

    if (!IsSerializedListEmpty(SerializedList)) {
        LockSerializedList(SerializedList);
        if (!IsSerializedListEmpty(SerializedList)) {
            entry = (LPVOID)TailOfSerializedList(SerializedList);
            RemoveFromSerializedList(SerializedList, (PLIST_ENTRY)entry);
        } else {
            entry = NULL;
        }
        UnlockSerializedList(SerializedList);
    } else {
        entry = NULL;
    }
    return entry;
}


BOOL
IsOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Checks if an entry is on a serialized list. Useful to call before
    RemoveFromSerializedList() if multiple threads can remove the element

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

    Entry           - pointer to element to check

Return Value:

    BOOL
        TRUE    - Entry is on SerializedList

        FALSE   -   "    " not on     "

--*/

{
    BOOL onList = FALSE;
    LPVOID entry;

    if (!IsSerializedListEmpty(SerializedList)) {
        LockSerializedList(SerializedList);
        if (!IsSerializedListEmpty(SerializedList)) {
            for (PLIST_ENTRY entry = HeadOfSerializedList(SerializedList);
                entry != (PLIST_ENTRY)SlSelf(SerializedList);
                entry = entry->Flink) {

                if (entry == Entry) {
                    onList = TRUE;
                    break;
                }
            }
        }
        UnlockSerializedList(SerializedList);
    }
    return onList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\settings\load.cpp ===
#include "stdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\settings\save.cpp ===
#include "stdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\settings\values.cpp ===
#include "stdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\oleaut32\whistler\loadregtypelib.cpp ===
#include <windows.h>
#include <rpc.h>

#define _OLEAUT32_

// #include <ocidl.h>
#include <oaidl.h>

struct ProcedureData
{
    PVOID m_pfn;
    PCSTR m_pszProcedureName;
};

extern
VOID
__fastcall
SetFunctionPointer(
    ProcedureData *pProcedureData
    );

HRESULT
__RPC_USER
LoadRegTypeLib(
    REFGUID rguid,
    WORD wVerMajor,
    WORD wVerMinor,
    LCID lcid,
    ITypeLib **pptlib
    )
{
    OutputDebugStringW(L"In private LoadRegTypeLib()...\n");

    ACTCTX_SECTION_KEYED_DATA askd;

    askd.cbSize = sizeof(askd);
    ::FindActCtxSectionGuid(0, NULL, 100, &rguid, &askd);

    typedef HRESULT (__RPC_USER * PFN_T)(REFGUID, WORD, WORD, LCID, ITypeLib **);

    static struct
    {
        PFN_T m_pfn;
        PCSTR m_pszProcedureName;
    } s_data =
    {
        NULL,
        "LoadRegTypeLib"
    };

    if (s_data.m_pfn == NULL)
        ::SetFunctionPointer((ProcedureData *) &s_data);

    return (*s_data.m_pfn)(rguid, wVerMajor, wVerMinor, lcid, pptlib);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\oleaut32\whistler\forwards.cpp ===
#include <windows.h>
#include <rpc.h>

// We define _OLEAUT32_ so that the linkages are __declspec(dllexport)
#define _OLEAUT32_
#include <oaidl.h>
#include <olectl.h>

// from ocidl.acf:
typedef HWND UserHWND;
typedef HACCEL UserHACCEL;
typedef HDC UserHDC;
typedef HFONT UserHFONT;
typedef MSG UserMSG;
typedef BSTR UserBSTR;
typedef VARIANT UserVARIANT;
typedef EXCEPINFO UserEXCEPINFO;

HINSTANCE g_hInstanceOleAut32;

EXTERN_C
ULONG
__cdecl
DbgPrintEx(
    ULONG ComponentId,
    ULONG Level,
    PCH Format,
    ...
    );

#pragma optimize("ty", on)

HINSTANCE
GetRealOleAut32HInstance()
{
    if (g_hInstanceOleAut32 == NULL)
    {
        HINSTANCE hInstanceOleAut32 = NULL;
        WCHAR rgwszBuffer[MAX_PATH];
        DWORD dwResult;

        dwResult = ::ExpandEnvironmentStringsW(L"%SystemRoot%\\System32\\OLEAUT32.DLL", rgwszBuffer, MAX_PATH);
        // If SystemRoot is too long, we're really hosed.
        if (dwResult == 0)
            return NULL;

        hInstanceOleAut32 = ::LoadLibraryW(rgwszBuffer);

        if (hInstanceOleAut32 == NULL)
        {
            const DWORD dwLastError = ::GetLastError();

            // Wow, this is bad.
            ::OutputDebugStringW(L"Side-by-side OLEAUT32 terminating; unable to load %SystemRoot%\\OLEAUT32.DLL\n");
            ::ExitProcess(dwLastError);
        }

        if (::InterlockedCompareExchangePointer((PVOID *) &g_hInstanceOleAut32, hInstanceOleAut32, NULL) != NULL)
            ::FreeLibrary(hInstanceOleAut32);
    }

    return g_hInstanceOleAut32;
}

VOID
GetFunctionPointer(
    PCSTR szApi,
    PVOID *ppvFunction
    )
{
    HINSTANCE hInstance = ::GetRealOleAut32HInstance();
    PVOID pvFunction = ::GetProcAddress(hInstance, szApi);
    if (pvFunction == NULL)
    {
        const DWORD dwLastError = ::GetLastError();
        // wow this is bad too!
        ::OutputDebugStringW(L"Side-by-side OLEAUT32 terminating process; unable to find OLEAUT32 export:\n");
        ::OutputDebugStringA(szApi);
        ::ExitProcess(dwLastError);
    }
    ::InterlockedCompareExchangePointer(ppvFunction, pvFunction, NULL);
}

struct ProcedureData
{
    PVOID m_pfn;
    PCSTR m_pszProcedureName;
};

VOID
__fastcall
GetFunctionPointer2(
    ProcedureData *pProcedureData
    )
{
    HINSTANCE hInstance = ::GetRealOleAut32HInstance();
    PVOID pvFunction = ::GetProcAddress(hInstance, pProcedureData->m_pszProcedureName);
    if (pvFunction == NULL)
    {
        const DWORD dwLastError = ::GetLastError();
        // wow this is bad too!
        ::OutputDebugStringW(L"Side-by-side OLEAUT32 terminating process; unable to find OLEAUT32 export:\n");
        ::OutputDebugStringA(pProcedureData->m_pszProcedureName);
        ::OutputDebugStringW(L"\n");
        ::ExitProcess(dwLastError);
    }
    pProcedureData->m_pfn = pvFunction;
}

VOID
__fastcall
SetFunctionPointer(
    ProcedureData *pProcedureData
    )
{
    if (pProcedureData->m_pfn == NULL)
        ::GetFunctionPointer2(pProcedureData);
}

typedef VOID (__fastcall * PFN_SETTER)(ProcedureData *pProcedureData);

#define RETURN_(_x) return (_x)
#define NORETURN_(_x) (_x)

#define _FORWARD_N_(_ReturnType, _ReturnMacro, _FunctionName, _ArgList, _ParamList) \
typedef _ReturnType (__RPC_USER *PFN_ ## _FunctionName ## _T) _ArgList; \
static struct \
{ \
    PFN_ ## _FunctionName ##_T m_pfn; \
    PCSTR m_pszProcedureName; \
} s_data ## _FunctionName = \
{ \
    NULL, \
    #_FunctionName \
}; \
_ReturnType \
__RPC_USER \
_FunctionName _ArgList \
{ \
    if (s_data ## _FunctionName.m_pfn == NULL) \
        ::SetFunctionPointer((ProcedureData *) &s_data ## _FunctionName); \
    _ReturnMacro((*s_data ## _FunctionName .m_pfn) _ParamList); \
}

#if 0
static _ReturnType __RPC_USER _FunctionName ## _Resolver _ArgList; \
_ReturnType \
__RPC_USER \
_FunctionName ## _Resolver _ArgList \
{ \
    ::GetFunctionPointer2((ProcedureData *) &s_data ##_FunctionName); \
    _ReturnMacro((*s_data ## _FunctionName .m_pfn) _ParamList); \
} \

#endif

#define _FORWARD_0_(_ReturnType, _ReturnMacro, _FunctionName) _FORWARD_N_(_ReturnType, _ReturnMacro, _FunctionName, (), ())
#define FORWARD_0(_FunctionName) _FORWARD_0_(void, NORETURN_, _FunctionName)
#define FORWARD_0_(_ReturnType, _FunctionName) _FORWARD_0_(_ReturnType, RETURN_, _FunctionName)

#define _FORWARD_1_(_ReturnType, _ReturnMacro, _FunctionName, _T1) _FORWARD_N_(_ReturnType, _ReturnMacro, _FunctionName, (_T1 p1), (p1))
#define FORWARD_1(_FunctionName, _T1) _FORWARD_1_(void, NORETURN_, _FunctionName, _T1)
#define FORWARD_1_(_ReturnType, _FunctionName, _T1) _FORWARD_1_(_ReturnType, RETURN_, _FunctionName, _T1)

#define _FORWARD_2_(_ReturnType, _ReturnMacro, _FunctionName, _T1, _T2) _FORWARD_N_(_ReturnType, _ReturnMacro, _FunctionName, (_T1 p1, _T2 p2), (p1, p2))
#define FORWARD_2_(_ReturnType, _FunctionName, _T1, _T2)  _FORWARD_2_(_ReturnType, RETURN_, _FunctionName, _T1, _T2)
#define FORWARD_2(_FunctionName, _T1, _T2)  _FORWARD_2_(void, NORETURN_, _FunctionName, _T1, _T2)

#define _FORWARD_3_(_ReturnType, _ReturnMacro, _FunctionName, _T1, _T2, _T3) _FORWARD_N_(_ReturnType, _ReturnMacro, _FunctionName, (_T1 p1, _T2 p2, _T3 p3), (p1, p2, p3))
#define FORWARD_3_(_ReturnType, _FunctionName, _T1, _T2, _T3)  _FORWARD_3_(_ReturnType, RETURN_, _FunctionName, _T1, _T2, _T3)
#define FORWARD_3(_FunctionName, _T1, _T2, _T3)  _FORWARD_3_(void, NORETURN_, _FunctionName, _T1, _T2, _T3)

#define _FORWARD_4_(_ReturnType, _ReturnMacro, _FunctionName, _T1, _T2, _T3, _T4) _FORWARD_N_(_ReturnType, _ReturnMacro, _FunctionName, (_T1 p1, _T2 p2, _T3 p3, _T4 p4), (p1, p2, p3, p4))
#define FORWARD_4_(_ReturnType, _FunctionName, _T1, _T2, _T3, _T4)  _FORWARD_4_(_ReturnType, RETURN_, _FunctionName, _T1, _T2, _T3, _T4)
#define FORWARD_4(_FunctionName, _T1, _T2, _T3, _T4)  _FORWARD_4_(void, NORETURN_, _FunctionName, _T1, _T2, _T3, _T4)

#define _FORWARD_5_(_ReturnType, _ReturnMacro, _FunctionName, _T1, _T2, _T3, _T4, _T5) _FORWARD_N_(_ReturnType, _ReturnMacro, _FunctionName, (_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5), (p1, p2, p3, p4, p5))
#define FORWARD_5_(_ReturnType, _FunctionName, _T1, _T2, _T3, _T4, _T5)  _FORWARD_5_(_ReturnType, RETURN_, _FunctionName, _T1, _T2, _T3, _T4, _T5)
#define FORWARD_5(_FunctionName, _T1, _T2, _T3, _T4, _T5)  _FORWARD_5_(void, NORETURN_, _FunctionName, _T1, _T2, _T3, _T4, _T5)

#define _FORWARD_6_(_ReturnType, _ReturnMacro, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6) _FORWARD_N_(_ReturnType, _ReturnMacro, _FunctionName, (_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6), (p1, p2, p3, p4, p5, p6))
#define FORWARD_6_(_ReturnType, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6)  _FORWARD_6_(_ReturnType, RETURN_, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6)
#define FORWARD_6(_FunctionName, _T1, _T2, _T3, _T4, _T5, _T6)  _FORWARD_6_(void, NORETURN_, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6)

#define _FORWARD_7_(_ReturnType, _ReturnMacro, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7) _FORWARD_N_(_ReturnType, _ReturnMacro, _FunctionName, (_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7), (p1, p2, p3, p4, p5, p6, p7))
#define FORWARD_7_(_ReturnType, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7)  _FORWARD_7_(_ReturnType, RETURN_, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7)
#define FORWARD_7(_FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7)  _FORWARD_7_(void, NORETURN_, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7)

#define _FORWARD_8_(_ReturnType, _ReturnMacro, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8) _FORWARD_N_(_ReturnType, _ReturnMacro, _FunctionName, (_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8), (p1, p2, p3, p4, p5, p6, p7, p8))
#define FORWARD_8(_FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8) _FORWARD_8_(void, NORETURN_, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8)
#define FORWARD_8_(_ReturnType, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8) _FORWARD_8_(_ReturnType, RETURN_, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8)

#define _FORWARD_9_(_ReturnType, _ReturnMacro, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9) _FORWARD_N_(_ReturnType, _ReturnMacro, _FunctionName, (_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9), (p1, p2, p3, p4, p5, p6, p7, p8, p9))
#define FORWARD_9(_FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9) _FORWARD_9_(void, NORETURN_, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9)
#define FORWARD_9_(_ReturnType, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9) _FORWARD_9_(_ReturnType, RETURN_, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9)

#define _FORWARD_10_(_ReturnType, _ReturnMacro, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10) _FORWARD_N_(_ReturnType, _ReturnMacro, _FunctionName, (_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10), (p1, p2, p3, p4, p5, p6, p7, p8, p9, p10))
#define FORWARD_10(_FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10) _FORWARD_10_(void, NORETURN_, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10)
#define FORWARD_10_(_ReturnType, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10) _FORWARD_10_(_ReturnType, RETURN_, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10)

#define _FORWARD_11_(_ReturnType, _ReturnMacro, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11) _FORWARD_N_(_ReturnType, _ReturnMacro, _FunctionName, (_T1 p1, _T2 p2, _T3 p3, _T4 p4, _T5 p5, _T6 p6, _T7 p7, _T8 p8, _T9 p9, _T10 p10, _T11 p11), (p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11))
#define FORWARD_11(_FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11) _FORWARD_11_(void, NORETURN_, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11)
#define FORWARD_11_(_ReturnType, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11) _FORWARD_11_(_ReturnType, RETURN_, _FunctionName, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10, _T11)

FORWARD_3_(HRESULT, DllGetClassObject, REFCLSID, REFIID, PVOID *)

FORWARD_2_(HRESULT, VectorFromBstr, BSTR, SAFEARRAY **)
FORWARD_2_(HRESULT, BstrFromVector, SAFEARRAY *, BSTR *)

#define FORWARD_USER_MARSHAL(_TypeName) \
FORWARD_3_(unsigned long, _TypeName ## _UserSize, unsigned long *, unsigned long, _TypeName *) \
FORWARD_3_(unsigned char *, _TypeName ## _UserMarshal, unsigned long *, unsigned char *, _TypeName *) \
FORWARD_3_(unsigned char *, _TypeName ## _UserUnmarshal, unsigned long *, unsigned char *, _TypeName *) \
FORWARD_2(_TypeName ## _UserFree, unsigned long *, _TypeName *)

#define FORWARD_MARSHAL(_TypeName) \
FORWARD_3_(unsigned long, _TypeName ## _Size, unsigned long *, unsigned long, _TypeName *) \
FORWARD_3_(unsigned char *, _TypeName ## _Marshal, unsigned long *, unsigned char *, _TypeName *) \
FORWARD_3_(unsigned char *, _TypeName ## _Unmarshal, unsigned long *, unsigned char *, _TypeName *)

#define FORWARD_WIRE_MARSHAL(_TypeName) \
FORWARD_2(User ## _TypeName ## _from_local, _TypeName *, User ## _TypeName **) \
FORWARD_1(User ## _TypeName ## _free_inst, User ## _TypeName *) \
FORWARD_2(User ## _TypeName ## _to_local, User ## _TypeName *, _TypeName *) \
FORWARD_1(User ## _TypeName ## _free_local, _TypeName *)

FORWARD_USER_MARSHAL(BSTR)
FORWARD_USER_MARSHAL(CLEANLOCALSTORAGE)
FORWARD_USER_MARSHAL(VARIANT)
FORWARD_USER_MARSHAL(LPSAFEARRAY)
FORWARD_USER_MARSHAL(EXCEPINFO)
FORWARD_MARSHAL(LPSAFEARRAY)

FORWARD_WIRE_MARSHAL(HWND)
FORWARD_WIRE_MARSHAL(MSG)
FORWARD_WIRE_MARSHAL(BSTR)
FORWARD_WIRE_MARSHAL(VARIANT)
FORWARD_WIRE_MARSHAL(EXCEPINFO)

FORWARD_0_(ULONG, OaBuildVersion)
FORWARD_1(ClearCustData, LPCUSTDATA)

FORWARD_5_(HRESULT, DispGetParam, DISPPARAMS *, UINT, VARTYPE, VARIANT *, UINT *)
FORWARD_4_(HRESULT, DispGetIDsOfNames, ITypeInfo *, OLECHAR **, UINT, DISPID *)
FORWARD_8_(HRESULT, DispInvoke, void *, ITypeInfo *, DISPID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *)
FORWARD_3_(HRESULT, CreateDispTypeInfo, INTERFACEDATA *, LCID, ITypeInfo **)
FORWARD_4_(HRESULT, CreateStdDispatch, IUnknown *, void *, ITypeInfo *, IUnknown **)
FORWARD_8_(HRESULT, DispCallFunc, void *, ULONG, CALLCONV, VARTYPE, UINT, VARTYPE *, VARIANTARG **, VARIANT *)
FORWARD_2_(HRESULT, SetErrorInfo, ULONG, IErrorInfo *)
FORWARD_2_(HRESULT, GetErrorInfo, ULONG, IErrorInfo **)
FORWARD_1_(HRESULT, CreateErrorInfo, ICreateErrorInfo **)

FORWARD_3_(HRESULT, LoadTypeLibEx, LPCOLESTR, REGKIND, ITypeLib **)
// FORWARD_5_(HRESULT, LoadRegTypeLib, REFGUID, WORD, WORD, LCID, ITypeLib **)
FORWARD_5_(HRESULT, QueryPathOfRegTypeLib, REFGUID, USHORT, USHORT, LCID, LPBSTR)
FORWARD_3_(HRESULT, RegisterTypeLib, ITypeLib *, OLECHAR *, OLECHAR *)
FORWARD_5_(HRESULT, UnRegisterTypeLib, REFGUID, WORD, WORD, LCID, SYSKIND)
FORWARD_3_(HRESULT, CreateTypeLib, SYSKIND, const OLECHAR  *, ICreateTypeLib **)
FORWARD_3_(HRESULT, CreateTypeLib2, SYSKIND, LPCOLESTR, ICreateTypeLib2 **)
FORWARD_3_(HRESULT, OACreateTypeLib2, SYSKIND, LPCOLESTR, ICreateTypeLib2 **)

FORWARD_3_(ULONG, LHashValOfNameSysA, SYSKIND, LCID, LPCSTR)
FORWARD_3_(ULONG, LHashValOfNameSys, SYSKIND, LCID, const OLECHAR *)
FORWARD_2_(HRESULT, LoadTypeLib, const OLECHAR *, ITypeLib **)


FORWARD_11_(HRESULT, OleCreatePropertyFrame, HWND, UINT, UINT, LPCOLESTR, ULONG, LPUNKNOWN FAR*, ULONG, LPCLSID, LCID, DWORD, LPVOID)
FORWARD_1_(HRESULT, OleCreatePropertyFrameIndirect, LPOCPFIPARAMS)
FORWARD_3_(HRESULT, OleTranslateColor, OLE_COLOR, HPALETTE, COLORREF*)
FORWARD_3_(HRESULT, OleCreateFontIndirect, LPFONTDESC, REFIID, LPVOID FAR*)
FORWARD_4_(HRESULT, OleCreatePictureIndirect, LPPICTDESC, REFIID, BOOL, LPVOID FAR*)
FORWARD_5_(HRESULT, OleLoadPicture, LPSTREAM, LONG, BOOL, REFIID, LPVOID FAR*)
FORWARD_8_(HRESULT, OleLoadPictureEx, LPSTREAM, LONG, BOOL, REFIID, DWORD, DWORD, DWORD, LPVOID FAR*)
FORWARD_6_(HRESULT, OleLoadPicturePath, LPOLESTR, LPUNKNOWN, DWORD, OLE_COLOR, REFIID, LPVOID *)
FORWARD_2_(HRESULT, OleLoadPictureFile, VARIANT, LPDISPATCH*)
FORWARD_5_(HRESULT, OleLoadPictureFileEx, VARIANT, DWORD, DWORD, DWORD, LPDISPATCH*)
FORWARD_2_(HRESULT, OleSavePictureFile, LPDISPATCH, BSTR)
FORWARD_2_(HCURSOR, OleIconToCursor, HINSTANCE, HICON)


FORWARD_4_(HRESULT, RegisterActiveObject, IUnknown *, REFCLSID, DWORD, DWORD *)
FORWARD_2_(HRESULT, RevokeActiveObject, DWORD, void *)
FORWARD_3_(HRESULT, GetActiveObject, REFCLSID, void *, IUnknown **)
FORWARD_2_(HRESULT, GetRecordInfoFromTypeInfo, ITypeInfo *, IRecordInfo **)
FORWARD_6_(HRESULT, GetRecordInfoFromGuids, REFGUID, ULONG, ULONG, LCID, REFGUID, IRecordInfo **)
FORWARD_3_(HRESULT, VarDateFromUdate, UDATE *, ULONG, DATE *)
FORWARD_4_(HRESULT, VarDateFromUdateEx, UDATE *, LCID, ULONG, DATE *)
FORWARD_3_(HRESULT, VarUdateFromDate, DATE, ULONG, UDATE *)
FORWARD_2_(HRESULT, GetAltMonthNames, LCID, LPOLESTR * *)
FORWARD_6_(HRESULT, VarFormat, LPVARIANT, LPOLESTR, int, int, ULONG, BSTR *)
FORWARD_4_(HRESULT, VarFormatDateTime, LPVARIANT, int, ULONG, BSTR *)
FORWARD_7_(HRESULT, VarFormatNumber, LPVARIANT, int, int, int, int, ULONG, BSTR *)
FORWARD_7_(HRESULT, VarFormatPercent, LPVARIANT, int, int, int, int, ULONG, BSTR *)
FORWARD_7_(HRESULT, VarFormatCurrency, LPVARIANT, int, int, int, int, ULONG, BSTR *)
FORWARD_5_(HRESULT, VarWeekdayName, int, int, int, ULONG, BSTR *)
FORWARD_4_(HRESULT, VarMonthName, int, int, ULONG, BSTR *)
FORWARD_6_(HRESULT, VarFormatFromTokens, LPVARIANT, LPOLESTR, LPBYTE, ULONG, BSTR *, LCID)
FORWARD_7_(HRESULT, VarTokenizeFormatString, LPOLESTR, LPBYTE, int, int, int, LCID, int *)
FORWARD_1_(BSTR, SysAllocString, const OLECHAR *)
FORWARD_2_(INT, SysReAllocString, BSTR *, const OLECHAR *)
FORWARD_2_(BSTR, SysAllocStringLen, const OLECHAR *, UINT)
FORWARD_3_(INT, SysReAllocStringLen, BSTR *, const OLECHAR *, UINT)
FORWARD_1(SysFreeString, BSTR)
FORWARD_1_(UINT, SysStringLen, BSTR)
FORWARD_1_(UINT, SysStringByteLen, BSTR)
FORWARD_2_(BSTR, SysAllocStringByteLen, LPCSTR, UINT)
FORWARD_3_(INT, DosDateTimeToVariantTime, USHORT, USHORT, DOUBLE *)
FORWARD_3_(INT, VariantTimeToDosDateTime, DOUBLE, USHORT *, USHORT *)
FORWARD_2_(INT, SystemTimeToVariantTime, LPSYSTEMTIME, DOUBLE *)
FORWARD_2_(INT, VariantTimeToSystemTime, DOUBLE, LPSYSTEMTIME)
FORWARD_2_(HRESULT, SafeArrayAllocDescriptor, UINT, SAFEARRAY **)
FORWARD_3_(HRESULT, SafeArrayAllocDescriptorEx, VARTYPE, UINT, SAFEARRAY **)
FORWARD_1_(HRESULT, SafeArrayAllocData, SAFEARRAY *)
FORWARD_3_(SAFEARRAY *, SafeArrayCreate, VARTYPE, UINT, SAFEARRAYBOUND *)
FORWARD_4_(SAFEARRAY *, SafeArrayCreateEx, VARTYPE, UINT, SAFEARRAYBOUND *, PVOID)
FORWARD_2_(HRESULT, SafeArrayCopyData, SAFEARRAY *, SAFEARRAY *)
FORWARD_1_(HRESULT, SafeArrayDestroyDescriptor, SAFEARRAY *)
FORWARD_1_(HRESULT, SafeArrayDestroyData, SAFEARRAY *)
FORWARD_1_(HRESULT, SafeArrayDestroy, SAFEARRAY *)
FORWARD_2_(HRESULT, SafeArrayRedim, SAFEARRAY *, SAFEARRAYBOUND *)
FORWARD_1_(UINT, SafeArrayGetDim, SAFEARRAY *)
FORWARD_1_(UINT, SafeArrayGetElemsize, SAFEARRAY *)
FORWARD_3_(HRESULT, SafeArrayGetUBound, SAFEARRAY *, UINT, LONG *)
FORWARD_3_(HRESULT, SafeArrayGetLBound, SAFEARRAY *, UINT, LONG *)
FORWARD_1_(HRESULT, SafeArrayLock, SAFEARRAY *)
FORWARD_1_(HRESULT, SafeArrayUnlock, SAFEARRAY *)
FORWARD_2_(HRESULT, SafeArrayAccessData, SAFEARRAY *, void **)
FORWARD_1_(HRESULT, SafeArrayUnaccessData, SAFEARRAY *)
FORWARD_3_(HRESULT, SafeArrayGetElement, SAFEARRAY *, LONG *, void *)
FORWARD_3_(HRESULT, SafeArrayPutElement, SAFEARRAY *, LONG *, void *)
FORWARD_2_(HRESULT, SafeArrayCopy, SAFEARRAY *, SAFEARRAY **)
FORWARD_3_(HRESULT, SafeArrayPtrOfIndex, SAFEARRAY *, LONG *, void **)
FORWARD_2_(HRESULT, SafeArraySetRecordInfo, SAFEARRAY *, IRecordInfo *)
FORWARD_2_(HRESULT, SafeArrayGetRecordInfo, SAFEARRAY *, IRecordInfo **)
FORWARD_2_(HRESULT, SafeArraySetIID, SAFEARRAY *, REFGUID)
FORWARD_2_(HRESULT, SafeArrayGetIID, SAFEARRAY *, GUID *)
FORWARD_2_(HRESULT, SafeArrayGetVartype, SAFEARRAY *, VARTYPE *)
FORWARD_3_(SAFEARRAY *, SafeArrayCreateVector, VARTYPE, LONG, ULONG)
FORWARD_4_(SAFEARRAY *, SafeArrayCreateVectorEx, VARTYPE, LONG, ULONG, PVOID)
FORWARD_1(VariantInit, VARIANTARG *)
FORWARD_1_(HRESULT, VariantClear, VARIANTARG *)
FORWARD_2_(HRESULT, VariantCopy, VARIANTARG *, VARIANTARG *)
FORWARD_2_(HRESULT, VariantCopyInd, VARIANT *, VARIANTARG *)
FORWARD_4_(HRESULT, VariantChangeType, VARIANTARG *, VARIANTARG *, USHORT, VARTYPE)
FORWARD_5_(HRESULT, VariantChangeTypeEx, VARIANTARG *, VARIANTARG *, LCID, USHORT, VARTYPE)

#define FORWARD_COERCION_(_ToTypeName, _ToTypeType, _FromTypeName, _FromTypeType) \
FORWARD_2_(HRESULT, Var ## _ToTypeName ## From ## _FromTypeName, _FromTypeType, _ToTypeType *)

#if 1
#define FORWARD_ALL_COERCIONS_TO_TYPE(_ToTypeName, _ToTypeType) \
FORWARD_COERCION_(_ToTypeName, _ToTypeType, UI1, BYTE) \
FORWARD_COERCION_(_ToTypeName, _ToTypeType, UI2, USHORT) \
FORWARD_COERCION_(_ToTypeName, _ToTypeType, UI4, ULONG) \
FORWARD_COERCION_(_ToTypeName, _ToTypeType, I1, CHAR) \
FORWARD_COERCION_(_ToTypeName, _ToTypeType, I2, SHORT) \
FORWARD_COERCION_(_ToTypeName, _ToTypeType, I4, LONG) \
FORWARD_COERCION_(_ToTypeName, _ToTypeType, R4, FLOAT) \
FORWARD_COERCION_(_ToTypeName, _ToTypeType, R8, DOUBLE) \
FORWARD_COERCION_(_ToTypeName, _ToTypeType, Cy, CY) \
FORWARD_COERCION_(_ToTypeName, _ToTypeType, Date, DATE) \
FORWARD_COERCION_(_ToTypeName, _ToTypeType, Bool, VARIANT_BOOL) \
FORWARD_COERCION_(_ToTypeName, _ToTypeType, Dec, DECIMAL *) \
FORWARD_4_(HRESULT, Var ## _ToTypeName ## FromStr, OLECHAR *, LCID, ULONG, _ToTypeType *) \
FORWARD_3_(HRESULT, Var ## _ToTypeName ## FromDisp, IDispatch *, LCID, _ToTypeType *)
#else
#define FORWARD_ALL_COERCIONS_TO_TYPE(_ToTypeName, _ToTypeType) \
FORWARD_COERCION_(_ToTypeName, _ToTypeType, UI4, ULONG)
#endif

#ifdef VarUI4FromUI4
#undef VarUI4FromUI4
#endif

#ifdef VarI4FromI4
#undef VarI4FromI4
#endif

FORWARD_ALL_COERCIONS_TO_TYPE(UI1, BYTE)
FORWARD_ALL_COERCIONS_TO_TYPE(UI2, USHORT)
FORWARD_ALL_COERCIONS_TO_TYPE(UI4, ULONG)
FORWARD_ALL_COERCIONS_TO_TYPE(I1, CHAR)
FORWARD_ALL_COERCIONS_TO_TYPE(I2, SHORT)
FORWARD_ALL_COERCIONS_TO_TYPE(I4, LONG)
FORWARD_ALL_COERCIONS_TO_TYPE(R4, FLOAT)
FORWARD_ALL_COERCIONS_TO_TYPE(R8, DOUBLE)
FORWARD_ALL_COERCIONS_TO_TYPE(Bstr, BSTR)
FORWARD_ALL_COERCIONS_TO_TYPE(Bool, VARIANT_BOOL)
FORWARD_ALL_COERCIONS_TO_TYPE(Cy, CY)
FORWARD_ALL_COERCIONS_TO_TYPE(Date, DATE)

//
// Since DECIMAL is passed by reference for both input and output, it does
// not follow the same pattern as all the other types and requires special
// handling.
//

FORWARD_COERCION_(Dec, DECIMAL *, UI1, BYTE)
FORWARD_COERCION_(Dec, DECIMAL *, UI2, USHORT)
FORWARD_COERCION_(Dec, DECIMAL *, UI4, ULONG)
FORWARD_COERCION_(Dec, DECIMAL *, I1, CHAR)
FORWARD_COERCION_(Dec, DECIMAL *, I2, SHORT)
FORWARD_COERCION_(Dec, DECIMAL *, I4, LONG)
FORWARD_COERCION_(Dec, DECIMAL *, R4, FLOAT)
FORWARD_COERCION_(Dec, DECIMAL *, R8, DOUBLE)
FORWARD_COERCION_(Dec, DECIMAL *, Cy, CY)
FORWARD_COERCION_(Dec, DECIMAL *, Date, DATE)
FORWARD_COERCION_(Dec, DECIMAL *, Bool, VARIANT_BOOL)
FORWARD_COERCION_(Dec, DECIMAL *, Dec, DECIMAL *)
FORWARD_4_(HRESULT, VarDecFromStr, OLECHAR *, LCID, ULONG, DECIMAL * *)
FORWARD_3_(HRESULT, VarDecFromDisp, IDispatch *, LCID, DECIMAL * *)






FORWARD_3_(HRESULT, VarAdd, LPVARIANT, LPVARIANT, LPVARIANT)
FORWARD_3_(HRESULT, VarAnd, LPVARIANT, LPVARIANT, LPVARIANT)
FORWARD_3_(HRESULT, VarCat, LPVARIANT, LPVARIANT, LPVARIANT)
FORWARD_3_(HRESULT, VarDiv, LPVARIANT, LPVARIANT, LPVARIANT)
FORWARD_3_(HRESULT, VarEqv, LPVARIANT, LPVARIANT, LPVARIANT)
FORWARD_3_(HRESULT, VarIdiv, LPVARIANT, LPVARIANT, LPVARIANT)
FORWARD_3_(HRESULT, VarImp, LPVARIANT, LPVARIANT, LPVARIANT)
FORWARD_3_(HRESULT, VarMod, LPVARIANT, LPVARIANT, LPVARIANT)
FORWARD_3_(HRESULT, VarMul, LPVARIANT, LPVARIANT, LPVARIANT)
FORWARD_3_(HRESULT, VarOr, LPVARIANT, LPVARIANT, LPVARIANT)
FORWARD_3_(HRESULT, VarPow, LPVARIANT, LPVARIANT, LPVARIANT)
FORWARD_3_(HRESULT, VarSub, LPVARIANT, LPVARIANT, LPVARIANT)
FORWARD_3_(HRESULT, VarXor, LPVARIANT, LPVARIANT, LPVARIANT)
FORWARD_2_(HRESULT, VarAbs, LPVARIANT, LPVARIANT)
FORWARD_2_(HRESULT, VarFix, LPVARIANT, LPVARIANT)
FORWARD_2_(HRESULT, VarInt, LPVARIANT, LPVARIANT)
FORWARD_2_(HRESULT, VarNeg, LPVARIANT, LPVARIANT)
FORWARD_2_(HRESULT, VarNot, LPVARIANT, LPVARIANT)
FORWARD_3_(HRESULT, VarRound, LPVARIANT, int, LPVARIANT)
FORWARD_4_(HRESULT, VarCmp, LPVARIANT, LPVARIANT, LCID, ULONG )
FORWARD_3_(HRESULT, VarDecAdd, LPDECIMAL, LPDECIMAL, LPDECIMAL)
FORWARD_3_(HRESULT, VarDecDiv, LPDECIMAL, LPDECIMAL, LPDECIMAL)
FORWARD_3_(HRESULT, VarDecMul, LPDECIMAL, LPDECIMAL, LPDECIMAL)
FORWARD_3_(HRESULT, VarDecSub, LPDECIMAL, LPDECIMAL, LPDECIMAL)
FORWARD_2_(HRESULT, VarDecAbs, LPDECIMAL, LPDECIMAL)
FORWARD_2_(HRESULT, VarDecFix, LPDECIMAL, LPDECIMAL)
FORWARD_2_(HRESULT, VarDecInt, LPDECIMAL, LPDECIMAL)
FORWARD_2_(HRESULT, VarDecNeg, LPDECIMAL, LPDECIMAL)
FORWARD_3_(HRESULT, VarDecRound, LPDECIMAL, int, LPDECIMAL)
FORWARD_2_(HRESULT, VarDecCmp, LPDECIMAL, LPDECIMAL)
FORWARD_2_(HRESULT, VarDecCmpR8, LPDECIMAL, double)
FORWARD_3_(HRESULT, VarCyAdd, CY, CY, LPCY)
FORWARD_3_(HRESULT, VarCyMul, CY, CY, LPCY)
FORWARD_3_(HRESULT, VarCyMulI4, CY, long, LPCY)
FORWARD_3_(HRESULT, VarCySub, CY, CY, LPCY)
FORWARD_2_(HRESULT, VarCyAbs, CY, LPCY)
FORWARD_2_(HRESULT, VarCyFix, CY, LPCY)
FORWARD_2_(HRESULT, VarCyInt, CY, LPCY)
FORWARD_2_(HRESULT, VarCyNeg, CY, LPCY)
FORWARD_3_(HRESULT, VarCyRound, CY, int, LPCY)
FORWARD_2_(HRESULT, VarCyCmp, CY, CY)
FORWARD_2_(HRESULT, VarCyCmpR8, CY, double)
FORWARD_3_(HRESULT, VarBstrCat, BSTR, BSTR, LPBSTR)
FORWARD_4_(HRESULT, VarBstrCmp, BSTR, BSTR, LCID, ULONG)
FORWARD_3_(HRESULT, VarR8Pow, double, double, double *)
FORWARD_2_(HRESULT, VarR4CmpR8, float, double)
FORWARD_3_(HRESULT, VarR8Round, double, int, double *)


FORWARD_5_(HRESULT, VarParseNumFromStr, OLECHAR * , LCID , ULONG , NUMPARSE * , BYTE * )
FORWARD_4_(HRESULT, VarNumFromParseNum, NUMPARSE * , BYTE * , ULONG , VARIANT * )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\settings\settingsp.h ===
#if !defined(_FUSION_SETTINGS_SETTINGSP_H_INCLUDED_)
#define _FUSION_SETTINGS_SETTINGSP_H_INCLUDED_

#pragma once

typedef struct _SXSP_SETTINGS_KEY SXSP_SETTINGS_KEY;
typedef struct _SXSP_SETTINGS_KEY *PSXSP_SETTINGS_KEY;
typedef const struct _SXSP_SETTINGS_KEY *PCSXSP_SETTINGS_KEY;

typedef struct _SXSP_SETTINGS_VALUE SXSP_SETTINGS_VALUE;
typedef struct _SXSP_SETTINGS_VALUE *PSXSP_SETTINGS_VALUE;
typedef const struct _SXSP_SETTINGS_VALUE *PCSXSP_SETTINGS_VALUE;

typedef struct _SXSP_SETTINGS_VALUE
{
    PCWSTR m_pszValueName;
    BYTE *m_pbValue;
    ULONG m_cchValueName;
    ULONG m_cbValue;
    DWORD m_dwValueType;
} SXSP_SETTINGS_VALUE, *PSXSP_SETTINGS_VALUE;

#define SXSP_SETTINGS_KEY_FLAG_DETACHED (0x00000001)

typedef struct _SXSP_SETTINGS_KEY
{
    PSXSP_SETTINGS_KEY m_Parent;
    PSXSP_SETTINGS_KEY *m_prgSubKeys;
    PSXSP_SETTINGS_VALUE *m_prgValues;
    PCWSTR m_pszKeyName;
    PCWSTR m_pszClassName;
    LONG m_cRef;
    DWORD m_dwFlags;
    ULONG m_cchKeyName;
    ULONG m_cchClassName;
    ULONG m_cSubKeys;
    ULONG m_cSubKeyArraySize;
    ULONG m_cValues;
    ULONG m_cValueArraySize;
} SXSP_SETTINGS_KEY, *PSXSP_SETTINGS_KEY;

typedef const struct _SXSP_SETTINGS_KEY *PCSXSP_SETTINGS_KEY;

typedef struct _SXS_SETTINGS_KEY
{
    PSXSP_SETTINGS_KEY m_InternalKey;
    REGSAM m_SamGranted;
} SXS_SETTINGS_KEY;

void
SxspAddRefSettingsKey(
    PSXSP_SETTINGS_KEY Key
    );

void
SxspReleaseSettingsKey(
    PSXSP_SETTINGS_KEY Key
    );

int __cdecl
SxspCompareKeys(
    const void *pv1,
    const void *pv2
    );

LONG
SxspInternalKeyToExternalKey(
    PSXSP_SETTINGS_KEY KeyIn,
    REGSAM samGranted,
    PSXS_SETTINGS_KEY &KeyOut
    );

LONG
SxspNavigateKey(
    DWORD Flags,
    PSXSP_SETTINGS_KEY KeyIn,
    PCWSTR SubKeyPath,
    ULONG &SubKeyPathConsumed,
    PSXSP_SETTINGS_KEY &KeyOut
    );

void
SxspDestroySettingsValue(
    PSXSP_SETTINGS_VALUE Value
    );

void
SxspDetachSettingsKey(
    PSXSP_SETTINGS_KEY Key
    );

#endif // !defined(_FUSION_SETTINGS_SETTINGSP_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\settings\keys.cpp ===
#include "stdinc.h"

int __cdecl
SxspCompareKeys(
    const void *pv1,
    const void *pv2
    )
{
    const struct _SXSP_SETTINGS_KEY *pkey1 = reinterpret_cast<PCSXSP_SETTINGS_KEY>(pv1);
    const struct _SXSP_SETTINGS_KEY *pkey2 = reinterpret_cast<PCSXSP_SETTINGS_KEY>(pv2);

    return ::FusionpCompareStrings(
        pkey1->m_pszKeyName,
        pkey1->m_cchKeyName,
        pkey2->m_pszKeyName,
        pkey2->m_cchKeyName,
        true);
}

LONG
SxspInternalKeyToExternalKey(
    PSXSP_SETTINGS_KEY KeyIn,
    REGSAM samGranted,
    PSXS_SETTINGS_KEY &KeyOut
    )
{
    LONG lResult = ERROR_INTERNAL_ERROR;
    FN_TRACE_REG(lResult);

    PSXS_SETTINGS_KEY KeyTemp = NULL;

    KeyOut = NULL;

    INTERNAL_ERROR_CHECK(KeyIn != NULL);

    IFALLOCFAILED_EXIT(KeyTemp = new SXS_SETTINGS_KEY);

    ::InterlockedIncrement(&KeyIn->m_cRef);
    KeyTemp->m_InternalKey = KeyIn;
    KeyTemp->m_SamGranted = samGranted;

    KeyOut = KeyTemp;
    lResult = ERROR_SUCCESS;

Exit:
    return lResult;
}

void
SxspDestroySettingsKey(
    PSXSP_SETTINGS_KEY Key
    )
{
    FN_TRACE();
    ULONG i;

    ASSERT(Key != NULL);
    if (Key == NULL)
        return;

    ASSERT(Key->m_cRef == 0);

    for (i=0; i<Key->m_cValues; i++)
    {
        PSXSP_SETTINGS_VALUE &ValueRef = Key->m_prgValues[i];
        ::SxspDestroySettingsValue(ValueRef);
        ValueRef = NULL;
    }

    for (i=0; i<Key->m_cSubKeys; i++)
    {
        PSXSP_SETTINGS_KEY &KeyRef = Key->m_prgSubKeys[i];
        const PSXSP_SETTINGS_KEY SubKey = KeyRef;

        ::SxspDetachSettingsKey(SubKey);
        ::SxspReleaseSettingsKey(SubKey);
        KeyRef = NULL;
    }

    FUSION_RAW_DEALLOC(const_cast<PWSTR>(Key->m_pszKeyName));
    FUSION_DELETE_SINGLETON(Key);
}

void
SxspDetachSettingsKey(
    PSXSP_SETTINGS_KEY Key
    )
{
    FN_TRACE();

    ASSERT(Key != NULL);
    if (Key == NULL)
        return;

    // You shouldn't detach a key more than once...
    ASSERT((Key->m_dwFlags & SXSP_SETTINGS_KEY_FLAG_DETACHED) == 0);
    if (Key->m_dwFlags & SXSP_SETTINGS_KEY_FLAG_DETACHED)
        return;

    ULONG i;

    // Detaching a key also detaches all its children...

    for (i=0; i<Key->m_cSubKeys; i++)
        ::SxspDetachSettingsKey(Key->m_prgSubKeys[i]);
}

void
SxspAddRefSettingsKey(
    PSXSP_SETTINGS_KEY Key
    )
{
    ASSERT_NTC(Key != NULL);
    if (Key != NULL)
    {
        ASSERT_NTC(Key->m_cRef != 0);
        ::InterlockedIncrement(&Key->m_cRef);
    }
}

void
SxspReleaseSettingsKey(
    PSXSP_SETTINGS_KEY Key
    )
{
    ASSERT_NTC(Key != NULL);
    if (Key != NULL)
    {
        if (::InterlockedDecrement(&Key->m_cRef) == 0)
            ::SxspDestroySettingsKey(Key);
    }
}

LONG
WINAPI
SxsCloseSettingsKey(
    PSXS_SETTINGS_KEY Key
    )
{
    LONG lResult = ERROR_INTERNAL_ERROR;
    FN_TRACE_REG(lResult);

    PARAMETER_CHECK(Key != NULL);

    ::SxspReleaseSettingsKey(Key->m_InternalKey);
    Key->m_InternalKey = NULL;

    FUSION_DELETE_SINGLETON(Key);

    lResult = ERROR_SUCCESS;
Exit:
    return lResult;
}

LONG
SxspFindSubkey(
    DWORD dwFlags,
    PSXSP_SETTINGS_KEY pKeyIn,
    PCWSTR pszSubKey,
    ULONG cchSubKey,
    PSXSP_SETTINGS_KEY &rpKeyOut
    )
{
    LONG lResult = ERROR_INTERNAL_ERROR;
    FN_TRACE_REG(lResult);

    SXSP_SETTINGS_KEY KeyToFind;

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK(pKeyIn != NULL);
    PARAMETER_CHECK(cchSubKey == 0 || pszSubKey != NULL);

    KeyToFind.m_pszKeyName = pszSubKey;
    KeyToFind.m_cchKeyName = cchSubKey;

    rpKeyOut = reinterpret_cast<PSXSP_SETTINGS_KEY>(bsearch(&KeyToFind, pKeyIn->m_prgSubKeys, pKeyIn->m_cSubKeys, sizeof(SXSP_SETTINGS_KEY), &SxspCompareKeys));

    lResult = ERROR_SUCCESS;
Exit:
    return lResult;
}

LONG
SxspNavigateKey(
    DWORD dwFlags,
    PSXSP_SETTINGS_KEY pKeyIn,
    PCWSTR pszSubKeyPath,
    ULONG cchSubKeyPath,
    ULONG &rcchSubKeyPathConsumed,
    PSXSP_SETTINGS_KEY &rpKeyOut
    )
{
    LONG lResult = ERROR_INTERNAL_ERROR;
    FN_TRACE_REG(lResult);

//    PCWSTR pszThisSegmentStart = pszSubKeyPath;
//    PCWSTR pszSeparator = NULL;
    ULONG cchSearched = 0;
//    PSXSP_SETTINGS_KEY pKeyFound = NULL;

    rpKeyOut = NULL;
    rcchSubKeyPathConsumed = 0;

    INTERNAL_ERROR_CHECK(dwFlags == 0);
    INTERNAL_ERROR_CHECK(pKeyIn != NULL);

    while (cchSearched < cchSubKeyPath)
    {
        const WCHAR wch = pszSubKeyPath[cchSearched];

        if (wch == NULL)
        {
            ASSERT(cchSearched == cchSubKeyPath);

            if (cchSearched != cchSubKeyPath)
            {
                lResult = ERROR_INVALID_PARAMETER;
                goto Exit;
            }



            break;
        }
        else if (wch == L'\\')
        {
            break;
        }
        else
        {

        }
    }

    lResult = ERROR_SUCCESS;
Exit:
    return lResult;
}


LONG
WINAPI
SxsCreateSettingsKeyExW(
    PSXS_SETTINGS_KEY lpKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PSXS_SETTINGS_KEY *lplpKeyResult,
    LPDWORD lpdwDisposition
    )
{
    LONG lResult = ERROR_INTERNAL_ERROR;
    FN_TRACE_REG(lResult);
    ULONG cchSubKey = 0;
    ULONG cchClass = 0;

    if (lplpKeyResult != NULL)
        *lplpKeyResult = NULL;

    if (lpdwDisposition != NULL)
        *lpdwDisposition = 0; // is there a better "i don't know yet?" value?

    PARAMETER_CHECK(lpKey != NULL);
    PARAMETER_CHECK(lpSubKey != NULL);
    PARAMETER_CHECK(dwOptions == 0);
    PARAMETER_CHECK(lpSecurityAttributes == NULL); // or should we just permit them and ignore them?
    PARAMETER_CHECK(lplpKeyResult != NULL);

    cchSubKey = wcslen(lpSubKey);

    if (lpClass != NULL)
        cchClass = wcslen(lpClass);

    lResult = ERROR_SUCCESS;
Exit:
    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\settings\sources.inc ===
!IF 0
Copyright (c) 2000-2001  Microsoft Corporation
!ENDIF

MAJORCOMP=fusion
MINORCOMP=settings

TARGETNAME=$(FUSION_BUILD_TYPE_PREFIX)settings
TARGETTYPE=LIBRARY

INCLUDES=\
    ..;\
    $(FUSION_INC_PATH);\
    $(FUSION_PATH)\external\inc;\
    $(FUSION_PATH)\idl\$(O); \
    $(INCLUDES);\
    $(COM_INC_PATH)

SOURCES= \
    values.cpp \
    keys.cpp \
    load.cpp \
    save.cpp

SOURCES_USED=..\sources.inc

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdinc.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\settings\stdinc.h ===
#if !defined(_FUSION_SETTINGS_STDINC_H_INCLUDED_)
#define _FUSION_SETTINGS_STDINC_H_INCLUDED_

#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "fusionlastwin32error.h"
#include <stdio.h>
#include <limits.h>
#include "fusionunused.h"

#include <windows.h>
#include <sxsapi.h>
#include "settingsp.h"

#include "util.h"
#include "fusiontrace.h"

#endif // !defined(_FUSION_SETTINGS_STDINC_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\actctxgenctx.h ===
#if !defined(_FUSION_SXS_ACTCTXGENCTX_H_INCLUDED_)
#define _FUSION_SXS_ACTCTXGENCTX_H_INCLUDED_

#pragma once

#include "fusionbuffer.h"
#include "pendingassembly.h"

typedef struct _ACTCTXGENCTX
{
    _ACTCTXGENCTX();
    ~_ACTCTXGENCTX();

    CActivationContextGenerationContextContributor *m_Contributors;
    ULONG m_ContributorCount;
    USHORT m_ProcessorArchitecture;
    CSmallStringBuffer m_SpecificLanguage;
    CSmallStringBuffer m_GenericLanguage;
    CSmallStringBuffer m_SpecificSystemLanguage;
    CSmallStringBuffer m_GenericSystemLanguage;
    LANGID m_LangID;
    LANGID m_SystemLangID;
    CStringBuffer m_AssemblyRootDirectoryBuffer;
    ULONG m_AssemblyRootDirectoryPathType;
    CStringBuffer m_ApplicationDirectoryBuffer;
    ULONG m_ApplicationDirectoryPathType;
    CImpersonationData m_ImpersonationData;
    DWORD m_Flags; // these are the same flags as ACTCTXCTB_CBHEADER::m_Flags
    ULONG m_ManifestOperation;
    DWORD m_ManifestOperationFlags;
    ACTCTXCTB_INSTALLATION_CONTEXT m_InstallationContext;
    CClsidMap m_ClsidMap;
    ACTCTXCTB_CLSIDMAPPING_CONTEXT m_ClsidMappingContext;
    ULONG m_NextAssemblyRosterIndex;
    BOOL  m_fClsidMapInitialized;
    ULONG m_InitializedContributorCount;
    bool m_NoInherit;
    bool m_ApplicationDirectoryHasBeenProbedForLanguageSubdirs;
    bool m_ApplicationDirectoryHasSpecificLanguageSubdir;
    bool m_ApplicationDirectoryHasGenericLanguageSubdir;
    bool m_ApplicationDirectoryHasSpecificSystemLanguageSubdir;
    bool m_ApplicationDirectoryHasGenericSystemLanguageSubdir;
    ULONG m_ulFileCount;

    CCaseInsensitiveUnicodeStringPtrTable<ASSEMBLY, CAssemblyTableHelper> m_AssemblyTable;
    CCaseInsensitiveUnicodeStringPtrTable<CPolicyStatement> m_ApplicationPolicyTable;
    CCaseInsensitiveUnicodeStringPtrTable<CPolicyStatement> m_ComponentPolicyTable;
    CDeque<ASSEMBLY, offsetof(ASSEMBLY, m_Linkage)> m_AssemblyList;
    CDeque<CPendingAssembly, offsetof(CPendingAssembly, m_Linkage)> m_PendingAssemblyList;

    CNodeFactory * m_pNodeFactory;

private:
    _ACTCTXGENCTX(const _ACTCTXGENCTX &);
    void operator =(const _ACTCTXGENCTX &);
} ACTCTXGENCTX, *PACTCTXGENCTX;

typedef const struct _ACTCTXGENCTX *PCACTCTXGENCTX;

#endif // !defined(_FUSION_SXS_ACTCTXGENCTX_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\actctxgen.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    actctxgen.cpp

Abstract:

    APIs for generating activation contexts.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:
    xiaoyuw     09/2000         replace attributes with assembly identity
--*/

#include "stdinc.h"
#include <windows.h>
#include <sxsp.h>
#include <ole2.h>
#include <xmlparser.h>
#include "nodefactory.h"
#include <wchar.h>
#include "filestream.h"
#include "fusionhandle.h"
#include "cteestream.h"
#include "cresourcestream.h"
#include "fusionfacilities.h"
#include "fusionxml.h"
#include "util.h"
#include "sxsexceptionhandling.h"
#include "csxspreservelasterror.h"
#include "smartptr.h"
#include "cstreamtap.h"
#include "pendingassembly.h"
#include "actctxgenctx.h"

static
BOOL
SxspFindAssemblyByName(
    PACTCTXGENCTX pActCtxGenCtx,
    PCWSTR AssemblyName,
    SIZE_T AssemblyNameCch,
    PASSEMBLY *AssemblyFound
    );

static BOOL
SxspAddAssemblyToActivationContextGenerationContext(
    PACTCTXGENCTX pActCtxGenCtx,
    PASSEMBLY Asm
    );

_ACTCTXGENCTX::_ACTCTXGENCTX()
:
    m_Contributors(NULL),
    m_ContributorCount(0),
    m_ProcessorArchitecture(0),
    m_LangID(0),
    m_Flags(0),
    m_ManifestOperation(MANIFEST_OPERATION_INVALID),
    m_ManifestOperationFlags(0),
    m_NextAssemblyRosterIndex(1),
    m_fClsidMapInitialized(FALSE),
    m_InitializedContributorCount(0),
    m_NoInherit(false),
    m_pNodeFactory(NULL),
    m_ulFileCount(0),
    m_ApplicationDirectoryHasBeenProbedForLanguageSubdirs(false),
    m_ApplicationDirectoryHasSpecificLanguageSubdir(false),
    m_ApplicationDirectoryHasGenericLanguageSubdir(false),
    m_ApplicationDirectoryHasSpecificSystemLanguageSubdir(false),
    m_ApplicationDirectoryHasGenericSystemLanguageSubdir(false)
{
}

_ACTCTXGENCTX::~_ACTCTXGENCTX()
{
    while (m_InitializedContributorCount)
    {
        m_InitializedContributorCount -= 1;
        CActivationContextGenerationContextContributor *Ctb = &m_Contributors[m_InitializedContributorCount];

        Ctb->Fire_ParseEnded(this, NULL);
        Ctb->Fire_ActCtxGenEnded(this);
    }

    FUSION_DELETE_ARRAY(m_Contributors);
    m_Contributors = NULL;

    m_AssemblyTable.ClearNoCallback();
    m_ComponentPolicyTable.ClearNoCallback();
    m_PendingAssemblyList.Clear(&CPendingAssembly::DeleteYourself);
    m_AssemblyList.Clear(&ASSEMBLY::Release);

    if (m_fClsidMapInitialized)
    {
        m_fClsidMapInitialized = false;
        VERIFY_NTC(m_ClsidMap.Uninitialize());
    }

    FUSION_DELETE_SINGLETON(m_pNodeFactory);
    m_pNodeFactory = NULL;
}

BOOL
SxspInitActCtxGenCtx(
    PACTCTXGENCTX pActCtxGenCtx,
    ULONG ulManifestOperation,
    DWORD dwFlags,
    DWORD dwManifestOperationFlags,
    const CImpersonationData &ImpersonationData,
    USHORT ProcessorArchitecture,
    LANGID LangId,
    ULONG ApplicationDirectoryPathType,
    SIZE_T ApplicationDirectoryCch,
    PCWSTR ApplicationDirectory
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PACTCTXCTB Ctb = NULL;
    CSxsLockCriticalSection lock(g_ActCtxCtbListCritSec);
    CStringBufferAccessor acc; // used for LangID String buffer
    LANGID SystemLangId = ::GetSystemDefaultUILanguage();
    bool fEqual;

    PARAMETER_CHECK(pActCtxGenCtx != NULL);

    PARAMETER_CHECK(
        (ulManifestOperation == SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_PARSE_ONLY) ||
        (ulManifestOperation == SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_GENERATE_ACTIVATION_CONTEXT) ||
        (ulManifestOperation == SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_INSTALL));

    PARAMETER_CHECK(
        (ApplicationDirectoryPathType == ACTIVATION_CONTEXT_PATH_TYPE_NONE) ||
        (ApplicationDirectoryPathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE));

    PARAMETER_CHECK(dwFlags == 0);

    switch (ulManifestOperation)
    {
    case SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_PARSE_ONLY:
        PARAMETER_CHECK(dwManifestOperationFlags == 0);
        break;

    case SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_GENERATE_ACTIVATION_CONTEXT:
        PARAMETER_CHECK(dwManifestOperationFlags == 0);
        break;

    case SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_INSTALL:
        PARAMETER_CHECK(
            (dwManifestOperationFlags & ~(
                MANIFEST_OPERATION_INSTALL_FLAG_NOT_TRANSACTIONAL |
                MANIFEST_OPERATION_INSTALL_FLAG_NO_VERIFY |
                MANIFEST_OPERATION_INSTALL_FLAG_REPLACE_EXISTING |
                MANIFEST_OPERATION_INSTALL_FLAG_ABORT |
                MANIFEST_OPERATION_INSTALL_FLAG_FROM_DIRECTORY |
                MANIFEST_OPERATION_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE |
                MANIFEST_OPERATION_INSTALL_FLAG_MOVE |
                MANIFEST_OPERATION_INSTALL_FLAG_INCLUDE_CODEBASE |
                MANIFEST_OPERATION_INSTALL_FLAG_FROM_RESOURCE |
                MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_DARWIN |
                MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_OSSETUP |
                MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE |
                MANIFEST_OPERATION_INSTALL_FLAG_REFERENCE_VALID |
                MANIFEST_OPERATION_INSTALL_FLAG_REFRESH |
                MANIFEST_OPERATION_INSTALL_FLAG_COMMIT)) == 0);
        break;
    }

    pActCtxGenCtx->m_ProcessorArchitecture = ProcessorArchitecture;
    pActCtxGenCtx->m_LangID = LangId;
    pActCtxGenCtx->m_SystemLangID = SystemLangId;

    pActCtxGenCtx->m_SpecificLanguage.Clear();

    IFW32FALSE_EXIT(pActCtxGenCtx->m_ApplicationDirectoryBuffer.Win32Assign(ApplicationDirectory, ApplicationDirectoryCch));
    pActCtxGenCtx->m_ApplicationDirectoryPathType = ApplicationDirectoryPathType;

    IFW32FALSE_EXIT(::SxspMapLANGIDToCultures(LangId, pActCtxGenCtx->m_GenericLanguage, pActCtxGenCtx->m_SpecificLanguage));
    IFW32FALSE_EXIT(::SxspMapLANGIDToCultures(SystemLangId, pActCtxGenCtx->m_GenericSystemLanguage, pActCtxGenCtx->m_SpecificSystemLanguage));

    // If these match the user's language, clear them to avoid the probing later on.
    IFW32FALSE_EXIT(pActCtxGenCtx->m_SpecificSystemLanguage.Win32Equals(pActCtxGenCtx->m_SpecificLanguage, fEqual, true));
    if (fEqual)
        pActCtxGenCtx->m_SpecificSystemLanguage.Clear();

    IFW32FALSE_EXIT(pActCtxGenCtx->m_GenericSystemLanguage.Win32Equals(pActCtxGenCtx->m_GenericLanguage, fEqual, true));
    if (fEqual)
        pActCtxGenCtx->m_GenericSystemLanguage.Clear();

    pActCtxGenCtx->m_ImpersonationData = ImpersonationData;
    pActCtxGenCtx->m_ManifestOperation = ulManifestOperation;
    pActCtxGenCtx->m_Flags = dwFlags;
    pActCtxGenCtx->m_ManifestOperationFlags = dwManifestOperationFlags;

    IFW32FALSE_EXIT(pActCtxGenCtx->m_AssemblyTable.Initialize());
    IFW32FALSE_EXIT(pActCtxGenCtx->m_ComponentPolicyTable.Initialize());
    IFW32FALSE_EXIT(pActCtxGenCtx->m_ApplicationPolicyTable.Initialize());

    IFW32FALSE_EXIT(pActCtxGenCtx->m_ClsidMap.Initialize());
    pActCtxGenCtx->m_fClsidMapInitialized = TRUE;
    pActCtxGenCtx->m_ClsidMappingContext.Map = &(pActCtxGenCtx->m_ClsidMap);

    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(pActCtxGenCtx->m_AssemblyRootDirectoryBuffer));
    pActCtxGenCtx->m_AssemblyRootDirectoryPathType = ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE;

    lock.Lock();

    IFALLOCFAILED_EXIT(pActCtxGenCtx->m_Contributors = FUSION_NEW_ARRAY(CActivationContextGenerationContextContributor, g_ActCtxCtbListCount));
    pActCtxGenCtx->m_ContributorCount = g_ActCtxCtbListCount;

    for (
        (pActCtxGenCtx->m_InitializedContributorCount = 0), (Ctb=g_ActCtxCtbListHead);
        (Ctb != NULL) && (pActCtxGenCtx->m_InitializedContributorCount < g_ActCtxCtbListCount);
        (pActCtxGenCtx->m_InitializedContributorCount++), (Ctb = Ctb->m_Next)
        )
    {
        ACTCTXCTB_CBACTCTXGENBEGINNING CBData;

        IFW32FALSE_EXIT(::SxspPrepareContributor(Ctb));

        CBData.Header.Reason = ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING;
        CBData.Header.ExtensionGuid = Ctb->GetExtensionGuidPtr();
        CBData.Header.SectionId = Ctb->m_SectionId;
        CBData.Header.ContributorContext = Ctb->m_ContributorContext;
        CBData.Header.ActCtxGenContext = NULL;
        CBData.Header.ManifestParseContext = NULL;
        CBData.Header.ManifestOperation = ulManifestOperation;
        CBData.Header.ManifestOperationFlags = dwManifestOperationFlags;
        CBData.Header.Flags = dwFlags;
        CBData.Header.pOriginalActCtxGenCtx = pActCtxGenCtx;
        CBData.Header.InstallationContext = &(pActCtxGenCtx->m_InstallationContext);
        CBData.Header.ClsidMappingContext = &(pActCtxGenCtx->m_ClsidMappingContext);
        CBData.ApplicationDirectory = pActCtxGenCtx->m_ApplicationDirectoryBuffer;
        CBData.ApplicationDirectoryCch = pActCtxGenCtx->m_ApplicationDirectoryBuffer.Cch();
        CBData.ApplicationDirectoryPathType = pActCtxGenCtx->m_ApplicationDirectoryPathType;
        CBData.Success = TRUE;

        (*(Ctb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

        if (!CBData.Success)
        {
            ASSERT(::FusionpGetLastWin32Error() != ERROR_SUCCESS);
            if (::FusionpGetLastWin32Error() == ERROR_SUCCESS)
                ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);

            goto Exit;
        }

        IFW32FALSE_EXIT(pActCtxGenCtx->m_Contributors[pActCtxGenCtx->m_InitializedContributorCount].Initialize(Ctb, CBData.Header.ActCtxGenContext));
    }
    // If the list count is correct, we should be both at the end of the list
    // and at the max index.
    ASSERT(pActCtxGenCtx->m_InitializedContributorCount == g_ActCtxCtbListCount);
    ASSERT(Ctb == NULL);

    qsort(pActCtxGenCtx->m_Contributors, pActCtxGenCtx->m_ContributorCount, sizeof(CActivationContextGenerationContextContributor), &CActivationContextGenerationContextContributor::Compare);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspFireActCtxGenEnding(
    PACTCTXGENCTX pActCtxGenCtx
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG i;

    PARAMETER_CHECK(pActCtxGenCtx != NULL);

    for (i=0; i<pActCtxGenCtx->m_InitializedContributorCount; i++)
        IFW32FALSE_EXIT(pActCtxGenCtx->m_Contributors[i].Fire_ActCtxGenEnding(pActCtxGenCtx));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspResolvePartialReference(
    DWORD Flags,
    PCASSEMBLY ParsingAssemblyContext,
    PACTCTXGENCTX pActCtxGenCtx,
    const CAssemblyReference &PartialReference,
    CProbedAssemblyInformation &ProbedAssemblyInformation,
    bool &rfFound
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    CProbedAssemblyInformation TestReference;
    CSmallStringBuffer buffProcessorArchitecture;
    bool fWildcardedLanguage = false;
    bool fWildcardedProcessorArchitecture = false;
    bool fAutoWow64Probing = false;
    bool fHasPKToken = false;
    bool fFound = false;
    bool fSetMSPKToken = false;
    USHORT wCurrentProcessorArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
    DWORD dwProbeAssemblyFlags = 0;

    fHasPKToken = false;
    rfFound = false;

    PARAMETER_CHECK(pActCtxGenCtx != NULL);
    IFINVALID_FLAGS_EXIT_WIN32(Flags, SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_OPTIONAL |
                                      SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_SKIP_WORLDWIDE);

    //
    //  A partial reference needs to have processor architecture, assembly name and
    //  assembly version filled in.  We only probe based on langid.
    //

    // Copy the attributes over...
    IFW32FALSE_EXIT(TestReference.Initialize(PartialReference));

    fWildcardedProcessorArchitecture = false;
    fAutoWow64Probing = false;

    // Find out if we're either processing a processorArchitecture="*" bind or
    // if we're supposed to do wow64 probing

    IFW32FALSE_EXIT(PartialReference.IsProcessorArchitectureWildcarded(fWildcardedProcessorArchitecture));

    if (pActCtxGenCtx->m_ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA32_ON_WIN64)
    {
        IFW32FALSE_EXIT(PartialReference.IsProcessorArchitectureX86(fAutoWow64Probing));
    }

    if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
    {
        wCurrentProcessorArchitecture = pActCtxGenCtx->m_ProcessorArchitecture;
        IFW32FALSE_EXIT(::FusionpFormatProcessorArchitecture(wCurrentProcessorArchitecture, buffProcessorArchitecture));
        IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));

        // We do not probe for private wow64 assemblies.
        if (wCurrentProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA32_ON_WIN64)
            dwProbeAssemblyFlags |= CProbedAssemblyInformation::ProbeAssembly_SkipPrivateAssemblies;
    }

    IFW32FALSE_EXIT(TestReference.SetOriginalReference(PartialReference));

TryItAllAgain:

    // Let's try the few languages we can.

    IFW32FALSE_EXIT(PartialReference.IsLanguageWildcarded(fWildcardedLanguage));
    if (!fWildcardedLanguage)
    {
        // If there's no language="*" in the dependency, let's just look for the exact match and
        // call it a day.
        IFW32FALSE_EXIT(TestReference.ResetProbedToOriginal());
        if (fSetMSPKToken)
            IFW32FALSE_EXIT(TestReference.SetPublicKeyToken(SXS_MS_PUBLIC_KEY_TOKEN_DEFAULT, NUMBER_OF( SXS_MS_PUBLIC_KEY_TOKEN_DEFAULT ) - 1));
        if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
            IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));

        IFW32FALSE_EXIT(TestReference.ProbeAssembly(dwProbeAssemblyFlags, pActCtxGenCtx, CProbedAssemblyInformation::eExplicitBind, fFound));
    }
    else
    {
        // Let's try the user's language...
        if (pActCtxGenCtx->m_SpecificLanguage[0] != L'\0')
        {
            // Since this is the first probe, we don't have to reset to original...
            IFW32FALSE_EXIT(TestReference.ResetProbedToOriginal());
            if (fSetMSPKToken)
                IFW32FALSE_EXIT(TestReference.SetPublicKeyToken(SXS_MS_PUBLIC_KEY_TOKEN_DEFAULT, NUMBER_OF( SXS_MS_PUBLIC_KEY_TOKEN_DEFAULT ) - 1));
            if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
                IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));
            IFW32FALSE_EXIT(TestReference.SetLanguage(pActCtxGenCtx->m_SpecificLanguage));
            IFW32FALSE_EXIT(TestReference.ProbeAssembly(dwProbeAssemblyFlags, pActCtxGenCtx, CProbedAssemblyInformation::eSpecificLanguage, fFound));
        }

        if (!fFound && (pActCtxGenCtx->m_GenericLanguage[0] != L'\0'))
        {
            // Try the user's slightly more generic version of the language...
            IFW32FALSE_EXIT(TestReference.ResetProbedToOriginal());
            if (fSetMSPKToken)
                IFW32FALSE_EXIT(TestReference.SetPublicKeyToken(SXS_MS_PUBLIC_KEY_TOKEN_DEFAULT, NUMBER_OF( SXS_MS_PUBLIC_KEY_TOKEN_DEFAULT ) - 1));
            if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
                IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));
            IFW32FALSE_EXIT(TestReference.SetLanguage(pActCtxGenCtx->m_GenericLanguage));
            IFW32FALSE_EXIT(TestReference.ProbeAssembly(dwProbeAssemblyFlags, pActCtxGenCtx, CProbedAssemblyInformation::eGenericLanguage, fFound));
        }

        // Let's try the system's installed language...
        if (!fFound && (pActCtxGenCtx->m_SpecificSystemLanguage[0] != L'\0'))
        {
            // Since this is the first probe, we don't have to reset to original...
            IFW32FALSE_EXIT(TestReference.ResetProbedToOriginal());
            if (fSetMSPKToken)
                IFW32FALSE_EXIT(TestReference.SetPublicKeyToken(SXS_MS_PUBLIC_KEY_TOKEN_DEFAULT, NUMBER_OF( SXS_MS_PUBLIC_KEY_TOKEN_DEFAULT ) - 1));
            if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
                IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));
            IFW32FALSE_EXIT(TestReference.SetLanguage(pActCtxGenCtx->m_SpecificSystemLanguage));
            IFW32FALSE_EXIT(TestReference.ProbeAssembly(dwProbeAssemblyFlags, pActCtxGenCtx, CProbedAssemblyInformation::eSpecificSystemLanguage, fFound));
        }

        if (!fFound && (pActCtxGenCtx->m_GenericSystemLanguage[0] != L'\0'))
        {
            // Try the user's slightly more generic version of the language...
            IFW32FALSE_EXIT(TestReference.ResetProbedToOriginal());
            if (fSetMSPKToken)
                IFW32FALSE_EXIT(TestReference.SetPublicKeyToken(SXS_MS_PUBLIC_KEY_TOKEN_DEFAULT, NUMBER_OF( SXS_MS_PUBLIC_KEY_TOKEN_DEFAULT ) - 1));
            if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
                IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));
            IFW32FALSE_EXIT(TestReference.SetLanguage(pActCtxGenCtx->m_GenericSystemLanguage));
            IFW32FALSE_EXIT(TestReference.ProbeAssembly(dwProbeAssemblyFlags, pActCtxGenCtx, CProbedAssemblyInformation::eGenericSystemLanguage, fFound));
        }

        // If we haven't found a language specific one and the caller did not
        // request us to skip the language-dependent ones, try for a language neutral
        if (!fFound &
            ((Flags & SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_SKIP_WORLDWIDE) == 0))
        {
            // Try with no language!
            IFW32FALSE_EXIT(TestReference.ResetProbedToOriginal());
            if (fSetMSPKToken)
                IFW32FALSE_EXIT(TestReference.SetPublicKeyToken(SXS_MS_PUBLIC_KEY_TOKEN_DEFAULT, NUMBER_OF( SXS_MS_PUBLIC_KEY_TOKEN_DEFAULT ) - 1));
            if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
                IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));
            IFW32FALSE_EXIT(TestReference.ClearLanguage());
            IFW32FALSE_EXIT(TestReference.ProbeAssembly(dwProbeAssemblyFlags, pActCtxGenCtx, CProbedAssemblyInformation::eLanguageNeutral, fFound));
        }
    }

    if (!fFound)
    {
        // If we're automatically searching for wow64 assemblies and the processor architecture we just tried
        // was ia32-on-win64, try again with plain PROCESSOR_ARCHITECTURE_INTEL.
        if (fAutoWow64Probing && (wCurrentProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA32_ON_WIN64))
        {
            wCurrentProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
            dwProbeAssemblyFlags &= ~(CProbedAssemblyInformation::ProbeAssembly_SkipPrivateAssemblies);

            IFW32FALSE_EXIT(::FusionpFormatProcessorArchitecture(wCurrentProcessorArchitecture, buffProcessorArchitecture));
            IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));
            IFW32FALSE_EXIT(TestReference.SetOriginalReference(PartialReference));
            goto TryItAllAgain;
        }

        // If we're handling a processorArchitecture="*" bind and the current processor architecture hasn't fallen
        // back to PROCESSOR_ARCHITECTURE_UNKNOWN ( == data-only assemblies), fall back now.
        if (fWildcardedProcessorArchitecture && (wCurrentProcessorArchitecture != PROCESSOR_ARCHITECTURE_UNKNOWN))
        {
            wCurrentProcessorArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
            // data-only private assemblies cannot be found with processorArchitecture="*"
            dwProbeAssemblyFlags |= CProbedAssemblyInformation::ProbeAssembly_SkipPrivateAssemblies;

            IFW32FALSE_EXIT(::FusionpFormatProcessorArchitecture(wCurrentProcessorArchitecture, buffProcessorArchitecture));
            IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));
            IFW32FALSE_EXIT(TestReference.SetOriginalReference(PartialReference));
            goto TryItAllAgain;
        }

        // If it wasn't optional, declare an error.
        if ((Flags & SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_OPTIONAL) == 0)
        {
            PCWSTR AssemblyName = L"<error retrieving assembly name>";
            SIZE_T AssemblyNameCch = NUMBER_OF(L"<error retrieving assembly name>") - 1;

            TestReference.GetAssemblyName(&AssemblyName, &AssemblyNameCch);

            ::FusionpLogError(
                MSG_SXS_MANIFEST_PARSE_DEPENDENCY,
                CUnicodeString(AssemblyName, AssemblyNameCch),
                CEventLogLastError(ERROR_SXS_ASSEMBLY_NOT_FOUND));

            ORIGINATE_WIN32_FAILURE_AND_EXIT(AssemblyProbingFailed, ERROR_SXS_ASSEMBLY_NOT_FOUND);
        }
    }
    else
        IFW32FALSE_EXIT(ProbedAssemblyInformation.Assign(TestReference));

    rfFound = fFound;

    fSuccess = TRUE;

Exit:
    if (!fSuccess)
    {
        CSxsPreserveLastError ple;
        PCWSTR pszAssemblyName = NULL;
        SIZE_T AssemblyNameCch;

        PartialReference.GetAssemblyName(&pszAssemblyName, &AssemblyNameCch);

        ::FusionpLogError(
            MSG_SXS_FUNCTION_CALL_FAIL,
            CEventLogString(L"Resolve Partial Assembly"),
            (pszAssemblyName != NULL) ? CEventLogString(static_cast<PCWSTR>(pszAssemblyName)) : CEventLogString(L"Assembly Name Unknown"),
            CEventLogLastError(ple.LastError()));

        ple.Restore();
    }

    return fSuccess;
}

BOOL
SxspAddManifestToActCtxGenCtx(
    PACTCTXGENCTX pActCtxGenCtx,
    CProbedAssemblyInformation &ProbedInformation,
    PASSEMBLY *AssemblyOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY Asm = NULL;
    PCWSTR ProbedAssemblyName;
    SIZE_T ProbedAssemblyNameCch;

    if (AssemblyOut != NULL)
        *AssemblyOut = NULL;

    PARAMETER_CHECK(pActCtxGenCtx != NULL);
    IFW32FALSE_EXIT(ProbedInformation.GetAssemblyName(&ProbedAssemblyName, &ProbedAssemblyNameCch));

    // First, let's see if we've already found this assembly.
    IFW32FALSE_EXIT(::SxspFindAssemblyByName(pActCtxGenCtx, ProbedAssemblyName, ProbedAssemblyNameCch, &Asm));
    // Same name... if the metadata is different, we're in trouble.
    if (Asm != NULL)
    {
        BOOL fEqualIdentity;

        // Both identities should be definitions, so no need to set the ref-matches-def flag...
        IFW32FALSE_EXIT(
            ::SxsAreAssemblyIdentitiesEqual(
                SXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_FLAG_ALLOW_REF_TO_MATCH_DEF,
                Asm->GetAssemblyIdentity(),
                ProbedInformation.GetAssemblyIdentity(),
                &fEqualIdentity));

        if (!fEqualIdentity)
        {
            PCWSTR MP1 = L"<unavailable>";
            PCWSTR MP2 = MP1;

            ProbedInformation.GetManifestPath(&MP1, NULL);
            Asm->m_Information.GetManifestPath(&MP2, NULL);

            Asm = NULL;
            ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: Failing to add new manifest %S to activation context because it conflicts with existing %S\n", MP1, MP2);
            ORIGINATE_WIN32_FAILURE_AND_EXIT(VersionConflict, ERROR_SXS_VERSION_CONFLICT);
        }
    }

    if (Asm == NULL)
    {
        IFALLOCFAILED_EXIT(Asm = FUSION_NEW_SINGLETON(ASSEMBLY));
        IFW32FALSE_EXIT(::SxspInitAssembly(Asm, ProbedInformation));
        IFW32FALSE_EXIT(::SxspAddAssemblyToActivationContextGenerationContext(pActCtxGenCtx, Asm));


    }

    if (AssemblyOut != NULL)
    {
        *AssemblyOut = Asm;
        Asm = NULL;
    }

    fSuccess = TRUE;

Exit:
    if (Asm != NULL)
        Asm->Release();

    return fSuccess;
}

BOOL
SxspAddAssemblyToActivationContextGenerationContext(
    PACTCTXGENCTX pActCtxGenCtx,
    PASSEMBLY Asm
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(pActCtxGenCtx != NULL);
    PARAMETER_CHECK(Asm != NULL);

    // If you hit either of these asserts, either the assembly structure has been trashed or
    // it's already been added to the generation context.
    ASSERT(Asm->m_AssemblyRosterIndex == 0);
    Asm->m_AssemblyRosterIndex = pActCtxGenCtx->m_NextAssemblyRosterIndex++;
    pActCtxGenCtx->m_AssemblyList.AddToTail(Asm);
    Asm->AddRef();
    if (pActCtxGenCtx->m_ManifestOperation != MANIFEST_OPERATION_INSTALL)
    {
        PCWSTR AssemblyName = NULL;
        IFW32FALSE_EXIT(Asm->GetAssemblyName(&AssemblyName, NULL));
        IFW32FALSE_EXIT(pActCtxGenCtx->m_AssemblyTable.Insert(AssemblyName, Asm, ERROR_SXS_DUPLICATE_ASSEMBLY_NAME));
    }

    fSuccess = TRUE;
Exit:

#if 0
    if ( !fSuccess)
    {
        ::FusionpLogError(
            MSG_SXS_FUNCTION_CALL_FAIL,
            CEventLogString(L"Generate Activation Fail while dealing with Assembly"),
            (AssemblyName != NULL) ? CEventLogString(static_cast<PCWSTR>(AssemblyName)) : CEventLogString(L"Assembly Name Unknown"),
            CEventLogLastError());
    }
#endif // 0

    return fSuccess;
}

BOOL
SxspFindAssemblyByName(
    PACTCTXGENCTX pActCtxGenCtx,
    PCWSTR AssemblyName,
    SIZE_T AssemblyNameCch,
    PASSEMBLY *AssemblyOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CStringBuffer AssemblyNameBuffer;
    PASSEMBLY Result = NULL;

    if (AssemblyOut != NULL)
        *AssemblyOut = NULL;

    PARAMETER_CHECK(AssemblyOut != NULL);
    PARAMETER_CHECK(pActCtxGenCtx != NULL);

    // Unfortunately, we really need the string to be null terminated...
    IFW32FALSE_EXIT(AssemblyNameBuffer.Win32Assign(AssemblyName, AssemblyNameCch));
    AssemblyName = AssemblyNameBuffer;

    IFW32FALSE_EXIT(pActCtxGenCtx->m_AssemblyTable.Find(AssemblyName, Result));

    if (Result != NULL)
        Result->AddRef();

    *AssemblyOut = Result;
    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspAddRootManifestToActCtxGenCtx(
    PACTCTXGENCTX pActCtxGenCtx,
    PCSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CProbedAssemblyInformation AssemblyInfo;

    PARAMETER_CHECK(Parameters != NULL);
    PARAMETER_CHECK(pActCtxGenCtx != NULL);

#define IS_NT_DOS_PATH(_x) (((_x)[0] == L'\\') && ((_x)[1] == L'?') && ((_x)[2] == L'?') && ((_x)[3] == L'\\'))

    HARD_VERIFY((Parameters->AssemblyDirectory == NULL) || (IS_NT_DOS_PATH(Parameters->AssemblyDirectory) == FALSE));
    HARD_VERIFY((Parameters->AssemblyDirectory == NULL) || (IS_NT_DOS_PATH(Parameters->AssemblyDirectory) == FALSE));
    HARD_VERIFY((Parameters->Manifest.Path == NULL) || (IS_NT_DOS_PATH(Parameters->Manifest.Path) == FALSE));
    HARD_VERIFY((Parameters->Policy.Path == NULL) || (IS_NT_DOS_PATH(Parameters->Policy.Path) == FALSE));

    IFW32FALSE_EXIT(AssemblyInfo.Initialize());
    IFW32FALSE_EXIT(AssemblyInfo.SetManifestPath(
            ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE,
            Parameters->Manifest.Path,
            (Parameters->Manifest.Path != NULL) ? ::wcslen(Parameters->Manifest.Path) : 0));
    ASSERT(Parameters->Manifest.Stream != NULL);
    IFW32FALSE_EXIT(AssemblyInfo.SetManifestStream(Parameters->Manifest.Stream));
    IFW32FALSE_EXIT(AssemblyInfo.SetManifestFlags(ASSEMBLY_MANIFEST_FILETYPE_STREAM));

    IFW32FALSE_EXIT(AssemblyInfo.SetPolicyPath(
        ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE,
        Parameters->Policy.Path,
        (Parameters->Policy.Path != NULL) ? ::wcslen(Parameters->Policy.Path) : 0));
    IFW32FALSE_EXIT(AssemblyInfo.SetPolicyStream(Parameters->Policy.Stream));
    IFW32FALSE_EXIT(AssemblyInfo.SetPolicyFlags(ASSEMBLY_POLICY_FILETYPE_STREAM));

    IFW32FALSE_EXIT(::SxspAddManifestToActCtxGenCtx(pActCtxGenCtx, AssemblyInfo, NULL));

    fSuccess = TRUE;
Exit:
#undef IS_NT_DOS_PATH
    return fSuccess;
}

BOOL
SxspInitAssembly(
    PASSEMBLY Asm,
    CProbedAssemblyInformation &AssemblyInfo
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(Asm != NULL);

    IFW32FALSE_EXIT(Asm->m_Information.Initialize(AssemblyInfo));
    Asm->m_Incorporated = FALSE;
    Asm->m_ManifestVersionMajor = 0;
    Asm->m_ManifestVersionMinor = 0;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspIncorporateAssembly(
    PACTCTXGENCTX pActCtxGenCtx,
    PASSEMBLY Asm
    )
{
    HRESULT hr;
    ULONG i;
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    const bool fInstalling = (pActCtxGenCtx->m_ManifestOperation == MANIFEST_OPERATION_INSTALL);
    ULONG ManifestType = (Asm->m_Information.GetManifestFlags() & ASSEMBLY_MANIFEST_FILETYPE_MASK);
    CImpersonate impersonate(pActCtxGenCtx->m_ImpersonationData);
    SXS_POLICY_SOURCE s;
#if FUSION_XML_TREE
    SXS_XML_STRING LocalStringArray[128];
    PSXS_XML_STRING ActualStringArray = LocalStringArray;
#endif
    STATSTG statstg;

    // declaration order here is partially deliberate, to control cleanup order.
    // normally, declaration order is determined by not declaring until you have
    // the data to initialize with the ctor, but the use of goto messes that up
    CFileStream FileStream;
    SMARTPTR(CResourceStream) ResourceStream;
    SMARTPTR(CTeeStreamWithHash) TeeStreamForManifestInstall;
#if FUSION_PRECOMPILED_MANIFEST
    SMARTPTR(CPrecompiledManifestWriterStream) pcmWriterStream;
#endif
    CNodeFactory *pNodeFactory = NULL;
    CSmartRef<IXMLParser> pIXMLParser;
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;

    CStringBuffer TextuallyEncodedIdentityBuffer;
    SIZE_T TextuallyEncodedIdentityBufferBytes = 0;
    CStringBufferAccessor acc;
    SIZE_T ActualSize = 0;
    PCWSTR ManifestPath = NULL;

    PARAMETER_CHECK(Asm != NULL);
    PARAMETER_CHECK(!Asm->m_Incorporated);
    PARAMETER_CHECK(pActCtxGenCtx != NULL);

    // set flags
    AssemblyContext.Flags = 0;
    s = Asm->m_Information.GetPolicySource();

    if ( s == SXS_POLICY_SYSTEM_POLICY)
        AssemblyContext.Flags |= ACTCTXCTB_ASSEMBLY_CONTEXT_ASSEMBLY_POLICY_APPLIED;
    else if (s == SXS_POLICY_ROOT_POLICY)
        AssemblyContext.Flags |= ACTCTXCTB_ASSEMBLY_CONTEXT_ROOT_POLICY_APPLIED;

    if (Asm->IsRoot())
        AssemblyContext.Flags |= ACTCTXCTB_ASSEMBLY_CONTEXT_IS_ROOT_ASSEMBLY;

    if (Asm->m_Information.IsPrivateAssembly())
        AssemblyContext.Flags |= ACTCTXCTB_ASSEMBLY_CONTEXT_IS_PRIVATE_ASSEMBLY;

    if (Asm->m_Information.GetAssemblyIdentity() != NULL)
    {
        // Convert the identity into a somewhat human-readable form that we can log etc.
        IFW32FALSE_EXIT(::SxsComputeAssemblyIdentityEncodedSize(0, Asm->m_Information.GetAssemblyIdentity(), NULL, SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL, &TextuallyEncodedIdentityBufferBytes));
        INTERNAL_ERROR_CHECK((TextuallyEncodedIdentityBufferBytes % sizeof(WCHAR)) == 0);
        IFW32FALSE_EXIT(TextuallyEncodedIdentityBuffer.Win32ResizeBuffer((TextuallyEncodedIdentityBufferBytes / sizeof(WCHAR)) + 1, eDoNotPreserveBufferContents));

        acc.Attach(&TextuallyEncodedIdentityBuffer);

        IFW32FALSE_EXIT(::SxsEncodeAssemblyIdentity(0, Asm->m_Information.GetAssemblyIdentity(), NULL, SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL, acc.GetBufferCb(), acc.GetBufferPtr(), &ActualSize));
        INTERNAL_ERROR_CHECK(TextuallyEncodedIdentityBufferBytes == ActualSize);
        acc.GetBufferPtr()[ActualSize / sizeof(WCHAR)] = L'\0';

        acc.Detach();

        AssemblyContext.TextuallyEncodedIdentity = TextuallyEncodedIdentityBuffer;
        AssemblyContext.TextuallyEncodedIdentityCch = ActualSize / sizeof(WCHAR);
    }
    else
    {
        AssemblyContext.TextuallyEncodedIdentity = L"<identity unavailable>";
        AssemblyContext.TextuallyEncodedIdentityCch = 22;
    }

    // copy assembly-identity info
    IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_ALLOW_NULL, Asm->m_Information.GetAssemblyIdentity(), &AssemblyIdentity));
    AssemblyContext.AssemblyIdentity = AssemblyIdentity; // assign to pointer-to-const in the struct; can't pass struct member pointer directly

    IFW32FALSE_EXIT(Asm->m_Information.GetManifestPath(&AssemblyContext.ManifestPath, &AssemblyContext.ManifestPathCch));
    AssemblyContext.ManifestPathType = Asm->GetManifestPathType();
    IFW32FALSE_EXIT(Asm->m_Information.GetPolicyPath(AssemblyContext.PolicyPath, AssemblyContext.PolicyPathCch));
    AssemblyContext.PolicyPathType = Asm->GetPolicyPathType();
    AssemblyContext.AssemblyRosterIndex = Asm->m_AssemblyRosterIndex;

    if (fInstalling)
    {
        IFW32FALSE_EXIT(TeeStreamForManifestInstall.Win32Allocate(__FILE__, __LINE__));
        AssemblyContext.TeeStreamForManifestInstall = TeeStreamForManifestInstall;
        AssemblyContext.InstallationInfo = pActCtxGenCtx->m_InstallationContext.InstallSource;
        AssemblyContext.SecurityMetaData = pActCtxGenCtx->m_InstallationContext.SecurityMetaData;
        AssemblyContext.InstallReferenceData = pActCtxGenCtx->m_InstallationContext.InstallReferenceData;
#if FUSION_PRECOMPILED_MANIFEST
        IFW32FALSE_EXIT(pcmWriterStream.Win32Allocate(__FILE__, __LINE__);
        AssemblyContext.pcmWriterStream = pcmWriterStream ;
#endif
    }
    else
    {
        AssemblyContext.SecurityMetaData = NULL;
        AssemblyContext.TeeStreamForManifestInstall = NULL;
        AssemblyContext.InstallationInfo = NULL;
#if FUSION_PRECOMPILED_MANIFEST
        AssemblyContext.pcmWriterStream = NULL;
#endif
    }

    if (pActCtxGenCtx->m_pNodeFactory == NULL)
    {
        IFALLOCFAILED_EXIT(pActCtxGenCtx->m_pNodeFactory = new CNodeFactory);
        pActCtxGenCtx->m_pNodeFactory->AddRef(); // faked function
    }
    else
        pActCtxGenCtx->m_pNodeFactory->ResetParseState();

    IFW32FALSE_EXIT(pActCtxGenCtx->m_pNodeFactory->Initialize(pActCtxGenCtx, Asm, &AssemblyContext));
    pNodeFactory = pActCtxGenCtx->m_pNodeFactory;
    ASSERT(pNodeFactory != NULL);

    // Everyone's ready; let's get the XML parser:
    IFW32FALSE_EXIT(::SxspGetXMLParser(IID_IXMLParser, (LPVOID *) &pIXMLParser));
    IFCOMFAILED_EXIT(pIXMLParser->SetFactory(pNodeFactory));

    //
    // open the file or map the resource into memory
    //
    IStream* Stream; // deliberatly not "smart", we don't refcount it
    Stream = NULL;
    { // scope for impersonation for file open

        IFW32FALSE_EXIT(impersonate.Impersonate());

        if (ManifestType == ASSEMBLY_MANIFEST_FILETYPE_AUTO_DETECT)
        {
            //
            // decide between xml in its own text file or a resource
            // in a "portable executable" by checking for the portable executable
            // signature, "MZ".
            //
            BYTE buffer[2] = {0,0};
            ULONG cbRead = 0;
            CFileStream ProbeFileTypeStream;

            IFW32FALSE_EXIT(Asm->m_Information.GetManifestPath(&ManifestPath, NULL));
            IFW32FALSE_EXIT(
                ProbeFileTypeStream.OpenForRead(
                    ManifestPath,
                    CImpersonationData(),
                    FILE_SHARE_READ,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN));

            IFCOMFAILED_EXIT(ProbeFileTypeStream.Read(&buffer, 2, &cbRead));

            if (cbRead != 2)
                ORIGINATE_WIN32_FAILURE_AND_EXIT(ManifestLessThanTwoBytesLong, ERROR_SXS_MANIFEST_FORMAT_ERROR);

            IFW32FALSE_EXIT(ProbeFileTypeStream.Close());

            // MS-DOS stub, Mark Zbikowski
            if (buffer[0] == 'M' && buffer[1] == 'Z')
            {
                // should we do further checking, like that PE\0\0 occurs
                // where the MS-DOS header says it is?
                ManifestType = ASSEMBLY_MANIFEST_FILETYPE_RESOURCE;
            }
            else
            {
                ManifestType = ASSEMBLY_MANIFEST_FILETYPE_FILE;
            }
        }
        switch (ManifestType)
        {
            case ASSEMBLY_MANIFEST_FILETYPE_RESOURCE:
                {
                    if (ManifestPath == NULL)
                        IFW32FALSE_EXIT(Asm->m_Information.GetManifestPath(&ManifestPath, NULL));
                    IFW32FALSE_EXIT(ResourceStream.Win32Allocate(__FILE__, __LINE__));
                    IFW32FALSE_EXIT(ResourceStream->Initialize(ManifestPath, MAKEINTRESOURCEW(RT_MANIFEST)));
                    Stream = ResourceStream;
                    break;
                }
            case ASSEMBLY_MANIFEST_FILETYPE_FILE:
                {
                    if (ManifestPath == NULL)
                        IFW32FALSE_EXIT(Asm->m_Information.GetManifestPath(&ManifestPath, NULL));
                    IFW32FALSE_EXIT(
                        FileStream.OpenForRead(
                            ManifestPath,
                            CImpersonationData(),
                            FILE_SHARE_READ,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN));
                    Stream = &FileStream;
                    break;
                }
            case ASSEMBLY_MANIFEST_FILETYPE_STREAM:
                Stream = Asm->m_Information.GetManifestStream();
                break;
            default:
                ASSERT2(FALSE, "unknown manifest file type");
                break;
        }

        IFW32FALSE_EXIT(impersonate.Unimpersonate());
    }

    //
    // Optionally "tee" the manifest so it gets copied into
    // the store while we read it, buffering until we know where in
    // the store it goes. The manifest itself is not referenced
    // in the manifest.
    //
    if (fInstalling)
    {
        IFW32FALSE_EXIT(TeeStreamForManifestInstall->InitCryptHash(CALG_SHA1));
        TeeStreamForManifestInstall->SetSource(Stream);
        Stream = TeeStreamForManifestInstall;
    }

    //
    // We get E_NOTIMPL on the OutOfProcessMemoryStreams in the AppCompat case.
    //
    IFCOMFAILED_EXIT(((hr = Stream->Stat(&statstg, STATFLAG_NONAME)) != E_NOTIMPL) ? hr : NOERROR);
    if (hr == E_NOTIMPL)
    {
        statstg.mtime.dwLowDateTime = 0;
        statstg.mtime.dwHighDateTime = 0;
    }

    IFW32FALSE_EXIT(
        pNodeFactory->SetParseType(
            XML_FILE_TYPE_MANIFEST,
            Asm->m_Information.GetManifestPathType(),
            Asm->m_Information.GetManifestPath(),
            statstg.mtime));

    INTERNAL_ERROR_CHECK(Stream != NULL);

    IFCOMFAILED_EXIT(pIXMLParser->SetInput(Stream));
    IFCOMFAILED_EXIT(pIXMLParser->Run(-1));
    IFW32FALSE_EXIT(FileStream.Close());
    IFW32FALSE_EXIT((AssemblyContext.TeeStreamForManifestInstall == NULL) || (TeeStreamForManifestInstall->Close()));
#if FUSION_PRECOMPILED_MANIFEST
    IFW32FALSE_EXIT((AssemblyContext.pcmWriterStream == NULL) || (pcmWriterStream.Close()));
#endif

    // Tell the contributors we're done parsing this file
    for (i=0; i<pActCtxGenCtx->m_ContributorCount; i++)
        IFW32FALSE_EXIT(
            pActCtxGenCtx->m_Contributors[i].Fire_ParseEnding(
                pActCtxGenCtx,
                &AssemblyContext));

#if FUSION_XML_TREE
    // Now let's fill in the document's string table.
    StringTableEntryCount = pNodeFactory->m_ParseTreeStringPool.GetEntryCount() + 1;

    if (StringTableEntryCount > NUMBER_OF(LocalStringArray))
        IFALLOCFAILED_EXIT(ActualStringArray = FUSION_NEW_ARRAY(SXS_XML_STRING, StringTableEntryCount));

    IFW32FALSE_EXIT(pNodeFactory->m_ParseTreeStringPool.FillInStringArray(StringTableEntryCount, ActualStringArray, EntriesFilledIn));
    // The size should have been an exact match.
    ASSERT(EntriesFilledIn == StringTableEntryCount);

    pNodeFactory->m_XmlDocument.StringCount = EntriesFilledIn;
    pNodeFactory->m_XmlDocument.Strings = ActualStringArray;

    ::SxspDumpXmlTree(0, &(pNodeFactory->m_XmlDocument));

    pNodeFactory->m_XmlDocument.StringCount = 0;
    pNodeFactory->m_XmlDocument.Strings = NULL;

    if (ActualStringArray != LocalStringArray)
    {
        FUSION_DELETE_ARRAY(ActualStringArray);
        ActualStringArray = NULL;
    }
#endif // FUSION_XML_TREE

    Asm->m_Incorporated = TRUE;
    fSuccess = TRUE;

Exit:
    // And tell them we're done.
    for (i=0; i<pActCtxGenCtx->m_ContributorCount; i++)
        pActCtxGenCtx->m_Contributors[i].Fire_ParseEnded(pActCtxGenCtx, &AssemblyContext);

    return fSuccess;
}

BOOL
SxspEnqueueAssemblyReference(
    PACTCTXGENCTX pActCtxGenCtx,
    PASSEMBLY SourceAssembly,
    PCASSEMBLY_IDENTITY Identity,
    bool Optional,
    bool MetadataSatellite
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    SMARTPTR(CPendingAssembly) PendingAssembly;

    PARAMETER_CHECK(Identity != NULL);
    PARAMETER_CHECK(pActCtxGenCtx != NULL);

    IFW32FALSE_EXIT(PendingAssembly.Win32Allocate(__FILE__, __LINE__));
    IFW32FALSE_EXIT(PendingAssembly->Initialize(SourceAssembly, Identity, Optional, MetadataSatellite));

    pActCtxGenCtx->m_PendingAssemblyList.AddToTail(PendingAssembly.Detach());
    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspProcessPendingAssemblies(
    PACTCTXGENCTX pActCtxGenCtx
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CPendingAssembly *EntryToDelete = NULL;
    PASSEMBLY_IDENTITY MuiAssemblyIdentity = NULL;

    CDequeIterator<CPendingAssembly, offsetof(CPendingAssembly, m_Linkage)> Iter(&pActCtxGenCtx->m_PendingAssemblyList);
    PARAMETER_CHECK(pActCtxGenCtx != NULL);

    for (Iter.Reset(); Iter.More(); Iter.Next())
    {
        bool fFound = false;
        CAssemblyReference TargetAssemblyRef;
        CProbedAssemblyInformation AssemblyFound;
        PASSEMBLY Assembly = NULL;

        if (EntryToDelete != NULL)
        {
            pActCtxGenCtx->m_PendingAssemblyList.Remove(EntryToDelete);
            FUSION_DELETE_SINGLETON(EntryToDelete);
        }

        EntryToDelete = NULL;

        IFW32FALSE_EXIT(AssemblyFound.Initialize());
        IFW32FALSE_EXIT(TargetAssemblyRef.Initialize(Iter->GetIdentity()));

        IFW32FALSE_EXIT(
            ::SxspResolvePartialReference(
                Iter->IsOptional() ? SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_OPTIONAL : 0,
                Iter->SourceAssembly(),
                pActCtxGenCtx,
                TargetAssemblyRef,
                AssemblyFound,
                fFound));

        INTERNAL_ERROR_CHECK(fFound || Iter->IsOptional());

        if (fFound)
        {
            PCWSTR szLanguage;
            SIZE_T cchLanguage;

            IFW32FALSE_EXIT(::SxspAddManifestToActCtxGenCtx(pActCtxGenCtx, AssemblyFound, &Assembly));

            if (Iter->IsMetadataSatellite())
                Iter->SourceAssembly()->m_MetadataSatelliteRosterIndex = Assembly->m_AssemblyRosterIndex;

            // If it's a worldwide assembly, we want to auto-probe for the MUI assembly

            IFW32FALSE_EXIT(
                ::SxspGetAssemblyIdentityAttributeValue(
                    SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                    AssemblyFound.GetAssemblyIdentity(),
                    &s_IdentityAttribute_language,
                    &szLanguage,
                    &cchLanguage));

            if (cchLanguage == 0)
            {
                CSmallStringBuffer buffName;
                PCWSTR szName;
                SIZE_T cchName;
                CProbedAssemblyInformation MuiAssemblyFound;
                CAssemblyReference MuiAssemblyRef;

                if (MuiAssemblyIdentity != NULL)
                {
                    ::SxsDestroyAssemblyIdentity(MuiAssemblyIdentity);
                    MuiAssemblyIdentity = NULL;
                }

                IFW32FALSE_EXIT(
                    ::SxsDuplicateAssemblyIdentity(
                        0,
                        AssemblyFound.GetAssemblyIdentity(),      // PCASSEMBLY_IDENTITY Source,
                        &MuiAssemblyIdentity));

                IFW32FALSE_EXIT(
                    ::SxspSetAssemblyIdentityAttributeValue(
                        SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
                        MuiAssemblyIdentity,
                        &s_IdentityAttribute_language,
                        L"*",
                        1));

                IFW32FALSE_EXIT(
                    ::SxspGetAssemblyIdentityAttributeValue(
                        0,
                        MuiAssemblyIdentity,
                        &s_IdentityAttribute_name,
                        &szName,
                        &cchName));

                IFW32FALSE_EXIT(buffName.Win32Assign(szName, cchName));
                IFW32FALSE_EXIT(buffName.Win32Append(L".mui", 4));

                IFW32FALSE_EXIT(
                    ::SxspSetAssemblyIdentityAttributeValue(
                        SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
                        MuiAssemblyIdentity,
                        &s_IdentityAttribute_name,
                        buffName,
                        buffName.Cch()));

                IFW32FALSE_EXIT(MuiAssemblyFound.Initialize());
                IFW32FALSE_EXIT(MuiAssemblyRef.Initialize(MuiAssemblyIdentity));

                IFW32FALSE_EXIT(
                    ::SxspResolvePartialReference(
                        SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_OPTIONAL |
                            SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_SKIP_WORLDWIDE,
                        Iter->SourceAssembly(),
                        pActCtxGenCtx,
                        MuiAssemblyRef,
                        MuiAssemblyFound,
                        fFound));

                if (fFound)
                    IFW32FALSE_EXIT(::SxspAddManifestToActCtxGenCtx(pActCtxGenCtx, MuiAssemblyFound, NULL));
            }

            if (Assembly != NULL)
            {
                Assembly->Release();
                Assembly = NULL;
            }
        }

        EntryToDelete = Iter;
    }

    if (EntryToDelete != NULL)
    {
        pActCtxGenCtx->m_PendingAssemblyList.Remove(EntryToDelete);
        FUSION_DELETE_SINGLETON(EntryToDelete);
    }

    fSuccess = TRUE;
Exit:
    if (MuiAssemblyIdentity != NULL)
    {
        CSxsPreserveLastError ple;
        ::SxsDestroyAssemblyIdentity(MuiAssemblyIdentity);
        ple.Restore();
    }

    return fSuccess;
}

BOOL
SxspCloseManifestGraph(
    PACTCTXGENCTX pActCtxGenCtx
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CDequeIterator<ASSEMBLY, offsetof(ASSEMBLY, m_Linkage)> Iter(&pActCtxGenCtx->m_AssemblyList);
    PARAMETER_CHECK(pActCtxGenCtx != NULL);

    // We need to just walk the list of assemblies, incorporating any that aren't already
    // incorporated into the actctx data.  New ones found during incorporation are appended
    // to the end of the list, so we should complete everything with a single walk.
    for (Iter.Reset(); Iter.More(); Iter.Next())
    {
        if (!Iter->m_Incorporated)
        {
            IFW32FALSE_EXIT(::SxspIncorporateAssembly(pActCtxGenCtx, Iter));
        }
        else
        {
            PCWSTR AssemblyName = L"<assembly name unavailable>";
            PCWSTR ManifestPath = L"<manifest path unavailable>";
            Iter->m_Information.GetAssemblyName(&AssemblyName, NULL);
            Iter->m_Information.GetManifestPath(&ManifestPath, NULL);
#if DBG
            ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_INFO, "SXS.DLL: Skipping already incorporated assembly %S (manifest: %S)\n", AssemblyName, ManifestPath);
#endif
        }

        IFW32FALSE_EXIT(::SxspProcessPendingAssemblies(pActCtxGenCtx));
    }

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspBuildActCtxData(
    PACTCTXGENCTX pActCtxGenCtx,
    PHANDLE SectionHandle
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CActivationContextGenerationContextContributor *Ctb = NULL;
    SIZE_T SectionTotalSize = 0;
    SIZE_T TotalHeaderSize = 0;
    SIZE_T AssemblyRosterSize = 0;
    ULONG SectionCount = 0;
    ULONG ExtendedSectionCount = 0;
    ULONG NonExtendedSectionCount = 0;
    CSxsArrayPointer<GUID> ExtendedSectionGuids;
    ULONG ExtensionGuidCount = 0;
    PACTIVATION_CONTEXT_DATA ActCtxData = NULL;
    CMappedViewOfFile VoidActCtxData;
    CFileMapping TempMappingHandle;
    BYTE *Cursor = NULL;
    ULONG i;
    CDequeIterator<ASSEMBLY, offsetof(ASSEMBLY, m_Linkage)> AssemblyIter(&pActCtxGenCtx->m_AssemblyList);
    PACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader = NULL;
    PACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY AssemblyRosterEntry = NULL;
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER AssemblyInformationSection = NULL;  // we use this after the main part of
                                                                                        // processing to fill in the assembly roster
    PARAMETER_CHECK(pActCtxGenCtx != NULL);
    INTERNAL_ERROR_CHECK(pActCtxGenCtx->m_ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);

    // Let's see how big this whole thing is going to be now.
    SectionTotalSize = 0;
    SectionCount = 0;
    ExtendedSectionCount = 0;
    NonExtendedSectionCount = 0;

    for (i=0; i<pActCtxGenCtx->m_ContributorCount; i++)
    {
        Ctb = &pActCtxGenCtx->m_Contributors[i];

        IFW32FALSE_EXIT(Ctb->Fire_AllParsingDone(pActCtxGenCtx));
        IFW32FALSE_EXIT(Ctb->Fire_GetSectionSize(pActCtxGenCtx));

        if (Ctb->SectionSize() > ULONG_MAX)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Contributor %S wants more than ULONG_MAX bytes for its section; failing activation context creation.\n",
                Ctb->Name());

            ORIGINATE_WIN32_FAILURE_AND_EXIT(ContributorNeedsMoreThan2ToThe32ndBytes, ERROR_INSUFFICIENT_BUFFER);
        }

        SectionTotalSize += Ctb->SectionSize();

        if (Ctb->SectionSize() != 0)
        {
            SectionCount++;

            if (Ctb->IsExtendedSection())
                ExtendedSectionCount++;
            else
                NonExtendedSectionCount++;
        }
    }

    ASSERT(SectionCount == (ExtendedSectionCount + NonExtendedSectionCount));

    // If we had any extended sections, we need to figure out how many
    // unique extension GUIDs were present.

    ExtensionGuidCount = 0;

    if (ExtendedSectionCount != 0)
    {
        // There may only be one GUID with 1000 instances, but for the sake of
        // simplicity, we'll just allocate an array equal in size to the number
        // of extended sections, and do a linear search to find dups.  This
        // is a clear candidate for rewriting if the extensibility story
        // takes off.  -mgrier 2/24/2000
        IFALLOCFAILED_EXIT(ExtendedSectionGuids = FUSION_NEW_ARRAY(GUID, ExtendedSectionCount));

        for (i=0; i<pActCtxGenCtx->m_ContributorCount; i++)
        {
            Ctb = &pActCtxGenCtx->m_Contributors[i];

            if ((Ctb->SectionSize() != 0) &&
                Ctb->IsExtendedSection())
            {
                ULONG i;

                for (i=0; i<ExtensionGuidCount; i++)
                {
                    if (ExtendedSectionGuids[i] == Ctb->ExtensionGuid())
                        break;
                }

                if (i == ExtensionGuidCount)
                    ExtendedSectionGuids[ExtensionGuidCount++] = Ctb->ExtensionGuid();
            }
        }
    }

    // Figure out the entire size.  SectionTotalSize already includes all the
    // particular data from the sections; now we need to add in space for the
    // headers etc.

    TotalHeaderSize = 0;

    // The header for the whole thing
    TotalHeaderSize += sizeof(ACTIVATION_CONTEXT_DATA);

    if (NonExtendedSectionCount != 0)
    {
        // The header for the default section TOC
        TotalHeaderSize += sizeof(ACTIVATION_CONTEXT_DATA_TOC_HEADER);
        // The entry for each non-extended section entry in the TOC.  For now we'll
        // just put the entries in whatever order they're in in the contributor list.
        // the code is in place to do the linear searches and we can optimize this
        // later.
        TotalHeaderSize += (sizeof(ACTIVATION_CONTEXT_DATA_TOC_ENTRY) * NonExtendedSectionCount);
    }

    if (ExtensionGuidCount != 0)
    {
        ULONG i;

        // The header for the extension GUID TOC
        TotalHeaderSize += sizeof(ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER);
        // The entry for each extension GUID
        TotalHeaderSize += (sizeof(ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY) * ExtensionGuidCount);

        for (i=0; i<ExtensionGuidCount; i++)
        {
            ULONG SectionCountForThisExtension = 0;
            for (i=0; i<pActCtxGenCtx->m_ContributorCount; i++)
            {
                Ctb = &pActCtxGenCtx->m_Contributors[i];

                if ((Ctb->SectionSize() != 0) &&
                    Ctb->IsExtendedSection() &&
                    (Ctb->ExtensionGuid() == ExtendedSectionGuids[i]))
                    SectionCountForThisExtension++;
            }

            TotalHeaderSize += sizeof(ACTIVATION_CONTEXT_DATA_TOC_HEADER);
            TotalHeaderSize += (sizeof(ACTIVATION_CONTEXT_DATA_TOC_ENTRY) * SectionCountForThisExtension);
        }
    }

    SectionTotalSize += TotalHeaderSize;

    // Allocate space for the assembly roster and the one dead entry at the beginning of the array.
    AssemblyRosterSize =
        sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER)
        + sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY)
        + (sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) * pActCtxGenCtx->m_AssemblyList.GetEntryCount());

    SectionTotalSize += AssemblyRosterSize;

    if (SectionTotalSize > ULONG_MAX)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Total size of activation context exceeds ULONG_MAX; failing activation context creation.\n");

        ORIGINATE_WIN32_FAILURE_AND_EXIT(SectionSizeTotalMoreThan2ToThe32nd, ERROR_INSUFFICIENT_BUFFER);

        goto Exit;
    }

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ACTCTX,
        "SXS.DLL: Creating %lu byte file mapping\n", static_cast<ULONG>(SectionTotalSize));

    IFW32NULL_EXIT(
        TempMappingHandle.Win32CreateFileMapping(
            INVALID_HANDLE_VALUE,       // Pagefile backed section
            PAGE_READWRITE,
            SectionTotalSize));

    IFW32NULL_EXIT(VoidActCtxData.Win32MapViewOfFile(TempMappingHandle, FILE_MAP_WRITE));
    ActCtxData = reinterpret_cast<PACTIVATION_CONTEXT_DATA>(static_cast<PVOID>(VoidActCtxData));

    ActCtxData->Magic = ACTIVATION_CONTEXT_DATA_MAGIC;
    ActCtxData->HeaderSize = sizeof(ACTIVATION_CONTEXT_DATA);
    ActCtxData->FormatVersion = ACTIVATION_CONTEXT_DATA_FORMAT_WHISTLER;
    ActCtxData->TotalSize = static_cast<ULONG>(SectionTotalSize);
    ActCtxData->Flags = 0;

    if (pActCtxGenCtx->m_NoInherit)
        ActCtxData->Flags |= ACTIVATION_CONTEXT_FLAG_NO_INHERIT;

    Cursor = (BYTE *) (ActCtxData + 1);

    AssemblyRosterHeader = (PACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) Cursor;

    Cursor = (BYTE *) (AssemblyRosterHeader + 1);

    AssemblyRosterHeader->HeaderSize = sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER);
    AssemblyRosterHeader->HashAlgorithm = FUSION_HASH_ALGORITHM;
    AssemblyRosterHeader->EntryCount = static_cast<ULONG>(pActCtxGenCtx->m_AssemblyList.GetEntryCount() + 1);
    AssemblyRosterHeader->FirstEntryOffset = static_cast<LONG>(((LONG_PTR) Cursor) - ((LONG_PTR) ActCtxData));

    AssemblyRosterEntry = (PACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) Cursor;
    Cursor = (BYTE *) (AssemblyRosterEntry + AssemblyRosterHeader->EntryCount);

    // First assembly roster entry is a blank one for index 0
    AssemblyRosterEntry[0].Flags = ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID;
    AssemblyRosterEntry[0].AssemblyNameLength = 0;
    AssemblyRosterEntry[0].AssemblyNameOffset = 0;
    AssemblyRosterEntry[0].PseudoKey = 0;

    // Fill in the roster with bogus data to start with; we'll fill it in for real after
    // we've found the assembly information section.
    for (AssemblyIter.Reset(), i = 1; AssemblyIter.More(); AssemblyIter.Next(), i++)
    {
        AssemblyRosterEntry[i].Flags = ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID;

        if (AssemblyIter->IsRoot())
            AssemblyRosterEntry[i].Flags |= ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_ROOT;
    }

    ActCtxData->AssemblyRosterOffset = static_cast<LONG>(((LONG_PTR) AssemblyRosterHeader) - ((LONG_PTR) ActCtxData));

    if (NonExtendedSectionCount != 0)
    {
        PACTIVATION_CONTEXT_DATA_TOC_HEADER Toc = (PACTIVATION_CONTEXT_DATA_TOC_HEADER) Cursor;
        PACTIVATION_CONTEXT_DATA_TOC_ENTRY Entry = (PACTIVATION_CONTEXT_DATA_TOC_ENTRY) (Toc + 1);
        ULONG iEntry = 0;
        ULONG i;
        ULONG LastSectionId;

        Toc->HeaderSize = sizeof(ACTIVATION_CONTEXT_DATA_TOC_HEADER);
        Toc->EntryCount = NonExtendedSectionCount;
        Toc->FirstEntryOffset = static_cast<LONG>(((LONG_PTR) Entry) - ((LONG_PTR) ActCtxData));

        Cursor = (BYTE *) (Entry + NonExtendedSectionCount);

        // Since we sorted the providers prior to building the array, we can set the
        // inorder bit so that we at least do a binary search at runtime.
        // We'll assume it's dense also; if we find out that it isn't while we're
        // building, we'll clear the dense bit.
        Toc->Flags = ACTIVATION_CONTEXT_DATA_TOC_HEADER_INORDER | ACTIVATION_CONTEXT_DATA_TOC_HEADER_DENSE;

        for (i=0; i<pActCtxGenCtx->m_ContributorCount; i++)
        {
            Ctb = &pActCtxGenCtx->m_Contributors[i];

            LastSectionId = 0;

            if ((Ctb->SectionSize() != 0) &&
                !Ctb->IsExtendedSection())
            {
                if (iEntry != 0)
                {
                    if (Ctb->SectionId() != (LastSectionId + 1))
                        Toc->Flags &= ~ACTIVATION_CONTEXT_DATA_TOC_HEADER_DENSE;
                }

                LastSectionId = Ctb->SectionId();

                Entry->Id = Ctb->SectionId();
                Entry->Offset = static_cast<LONG>(((LONG_PTR) Cursor) - ((LONG_PTR) ActCtxData));
                Entry->Length = static_cast<ULONG>(Ctb->SectionSize());
                Entry->Format = Ctb->SectionFormat();

                IFW32FALSE_EXIT(Ctb->Fire_GetSectionData(pActCtxGenCtx, Cursor));

                // We have special knowledge about the assembly metadata section; we reference it
                // in the assembly roster.
                if (Ctb->SectionId() == ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION)
                    AssemblyInformationSection = (PCACTIVATION_CONTEXT_STRING_SECTION_HEADER) Cursor;

                Cursor = (BYTE *) (((ULONG_PTR) Cursor) + Ctb->SectionSize());
                Entry++;
                iEntry++;
            }
        }

        ActCtxData->DefaultTocOffset = static_cast<LONG>(((LONG_PTR) Toc) - ((LONG_PTR) ActCtxData));
    }
    else
        ActCtxData->DefaultTocOffset = 0;

    if (ExtensionGuidCount != 0)
    {
        ULONG i;
        PACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER ExtToc = (PACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER) Cursor;
        PACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY ExtTocEntry = (PACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY) (ExtToc + 1);

        Cursor = (BYTE *) (ExtTocEntry + ExtensionGuidCount);

        ExtToc->HeaderSize = sizeof(ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER);
        ExtToc->EntryCount = ExtensionGuidCount;
        ExtToc->FirstEntryOffset = static_cast<LONG>(((LONG_PTR) ExtTocEntry) - ((LONG_PTR) ActCtxData));
        ExtToc->Flags = 0;

        for (i=0; i<ExtensionGuidCount; i++)
        {
            ULONG j;
            ULONG SectionCountForThisExtension = 0;
            PACTIVATION_CONTEXT_DATA_TOC_HEADER Toc = (PACTIVATION_CONTEXT_DATA_TOC_HEADER) Cursor;
            PACTIVATION_CONTEXT_DATA_TOC_ENTRY Entry = (PACTIVATION_CONTEXT_DATA_TOC_ENTRY) (Toc + 1);

            ExtTocEntry->ExtensionGuid = ExtendedSectionGuids[i];

            for (j=0; i<pActCtxGenCtx->m_ContributorCount; j++)
            {
                Ctb = &pActCtxGenCtx->m_Contributors[j];

                if ((Ctb->SectionSize() != 0) &&
                    Ctb->IsExtendedSection() &&
                    (Ctb->ExtensionGuid() == ExtendedSectionGuids[i]))
                {
                    SectionCountForThisExtension++;
                }
            }

            Cursor = (BYTE *) (Entry + SectionCountForThisExtension);

            Toc->HeaderSize = sizeof(ACTIVATION_CONTEXT_DATA_TOC_HEADER);
            Toc->EntryCount = SectionCountForThisExtension;
            Toc->FirstEntryOffset = static_cast<LONG>(((LONG_PTR) Entry) - ((LONG_PTR) ActCtxData));
            Toc->Flags = 0;

            for (j=0; i<pActCtxGenCtx->m_ContributorCount; j++)
            {
                Ctb = &pActCtxGenCtx->m_Contributors[j];

                if ((Ctb->SectionSize() != 0) &&
                    Ctb->IsExtendedSection() &&
                    (Ctb->ExtensionGuid() == ExtendedSectionGuids[i]) &&
                    (Ctb->SectionId() != 0) )
                {
                    SIZE_T SectionSize = Ctb->SectionSize();

                    Entry->Id = Ctb->SectionId();
                    Entry->Offset = static_cast<LONG>(((LONG_PTR) Cursor) - ((LONG_PTR) ActCtxData));
                    Entry->Length = static_cast<ULONG>(SectionSize);
                    Entry->Format = Ctb->SectionFormat();

                    IFW32FALSE_EXIT(Ctb->Fire_GetSectionData(pActCtxGenCtx, Cursor));

                    Cursor = (BYTE *) (((ULONG_PTR) Cursor) + SectionSize);
                    Entry++;
                }
            }
        }

        ActCtxData->ExtendedTocOffset = static_cast<LONG>(((LONG_PTR) ExtToc) - ((LONG_PTR) ActCtxData));
    }
    else
        ActCtxData->ExtendedTocOffset = 0;

    ASSERT(AssemblyInformationSection != NULL);
    // Go back and fill in the assembly roster...
    if (AssemblyInformationSection != NULL)
    {
        PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY Entries = (PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY)
            (((ULONG_PTR) AssemblyInformationSection) + AssemblyInformationSection->ElementListOffset);
        LONG_PTR SectionOffset = ((LONG_PTR) AssemblyInformationSection) - ((LONG_PTR) ActCtxData);

        AssemblyRosterHeader->HashAlgorithm = AssemblyInformationSection->HashAlgorithm;
        AssemblyRosterHeader->AssemblyInformationSectionOffset = static_cast<ULONG>(SectionOffset);

        // If there are 3 assemblies, there must be 3 entries in the section and 4 roster entries
        // (counting the bogus entry 0).
        ASSERT(AssemblyInformationSection->ElementCount == (AssemblyRosterHeader->EntryCount - 1));
        if (AssemblyInformationSection->ElementCount != (AssemblyRosterHeader->EntryCount - 1))
        {
            ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
            goto Exit;
        }

        for (i=0; i<AssemblyInformationSection->ElementCount; i++)
        {
            ULONG iRoster = Entries[i].AssemblyRosterIndex;

            ASSERT(iRoster != 0);
            ASSERT(iRoster < AssemblyRosterHeader->EntryCount);

            if ((iRoster == 0) ||
                (iRoster >= AssemblyRosterHeader->EntryCount))
            {
                ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
                goto Exit;
            }

            // Make sure that we're not repeating an index somehow...
            ASSERT(AssemblyRosterEntry[iRoster].Flags & ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID);
            if ((AssemblyRosterEntry[iRoster].Flags & ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID) == 0)
            {
                ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
                goto Exit;
            }

            // Turn off the invalid flag...
            AssemblyRosterEntry[iRoster].Flags &= ~ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID;

            // Point to the data already in the string section header
            AssemblyRosterEntry[iRoster].AssemblyNameLength = Entries[i].KeyLength;

            if (Entries[i].KeyOffset != 0)
                AssemblyRosterEntry[iRoster].AssemblyNameOffset = static_cast<LONG>(Entries[i].KeyOffset + SectionOffset);
            else
                AssemblyRosterEntry[iRoster].AssemblyNameOffset = 0;

            AssemblyRosterEntry[iRoster].AssemblyInformationLength = Entries[i].Length;
            AssemblyRosterEntry[iRoster].AssemblyInformationOffset = static_cast<LONG>(Entries[i].Offset + SectionOffset);
            AssemblyRosterEntry[iRoster].PseudoKey = Entries[i].PseudoKey;
        }
    }
    else
    {
        // the assembly metadata section provider should have contributed *something*
        ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
        goto Exit;
    }

    if (::FusionpDbgWouldPrintAtFilterLevel(FUSION_DBG_LEVEL_ACTCTX))
    {
        CSmallStringBuffer buffPrefix;
        ::SxspDbgPrintActivationContextData(FUSION_DBG_LEVEL_ACTCTX, ActCtxData, buffPrefix);
    }

    IFW32FALSE_EXIT(VoidActCtxData.Win32Close());
    *SectionHandle = TempMappingHandle.Detach();

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

CPendingAssembly::CPendingAssembly() :
    m_SourceAssembly(NULL),
    m_Identity(NULL),
    m_Optional(false),
    m_MetadataSatellite(false)
{
}

CPendingAssembly::~CPendingAssembly()
{
    if (m_Identity != NULL)
    {
        ::SxsDestroyAssemblyIdentity(m_Identity);
        m_Identity = NULL;
    }
}

BOOL
CPendingAssembly::Initialize(
    PASSEMBLY Assembly,
    PCASSEMBLY_IDENTITY Identity,
    bool Optional,
    bool MetadataSatellite
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(m_Identity == NULL);

    PARAMETER_CHECK(Identity != NULL);

    IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(0, Identity, &m_Identity));
    m_SourceAssembly = Assembly;
    m_Optional = Optional;
    m_MetadataSatellite = MetadataSatellite;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\assemblyreference.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    assemblyreference.cpp

Abstract:

    Class the contains all the attributes of an assembly reference.

Author:

    Michael J. Grier (MGrier) 10-May-2000

Revision History:
    xiaoyuw     09/2000     revise the code using Assembly Identity
                            A couple of APIs in this class are kind of out of date, such as GetXXX, SetXXX, XXXSpecified : they
                            are not called at all.
--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsapi.h"
#include "sxsp.h"
#include "assemblyreference.h"
#include "sxsid.h"
#include "sxsidp.h"
#include "fusionparser.h"
#include "fusionheap.h"
#include "SxsExceptionHandling.h"

CAssemblyReference::CAssemblyReference()
    : m_pAssemblyIdentity(NULL)
{
}

CAssemblyReference::~CAssemblyReference()
{
    CSxsPreserveLastError ple;
    if (m_pAssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(m_pAssemblyIdentity);
    ple.Restore();
}

BOOL
CAssemblyReference::Initialize()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity == NULL);

    IFW32FALSE_EXIT(::SxsCreateAssemblyIdentity(0, ASSEMBLY_IDENTITY_TYPE_REFERENCE, &m_pAssemblyIdentity, 0, NULL));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CAssemblyReference::Initialize(
    PCASSEMBLY_IDENTITY Identity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(Identity != NULL);
    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity == NULL);

    IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(0, Identity, &m_pAssemblyIdentity));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CAssemblyReference::Initialize(
    const CAssemblyReference &r
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity == NULL);
    INTERNAL_ERROR_CHECK(r.m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxsDuplicateAssemblyIdentity(
            0,                      // DWORD Flags,
            r.m_pAssemblyIdentity,  // PCASSEMBLY_IDENTITY Source,
            &m_pAssemblyIdentity)); //  PASSEMBLY_IDENTITY *Destination

    fSuccess = TRUE;
Exit:

    return fSuccess;
}

BOOL
CAssemblyReference::Hash(
    ULONG &rulPseudoKey
    ) const
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxsHashAssemblyIdentity(
            0,                      // DWORD dwFlags,
            m_pAssemblyIdentity,    // ASSEMBLY_IDENTITY pAssemblyIdentity,
            &rulPseudoKey));        // ULONG & rfulPseudoKey

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CAssemblyReference::SetAssemblyName(
    PCWSTR AssemblyNameValue,
    SIZE_T AssemblyNameValueCch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(AssemblyNameValue != NULL);
    PARAMETER_CHECK(AssemblyNameValueCch != 0);

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxspSetAssemblyIdentityAttributeValue(
            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
            m_pAssemblyIdentity,
            &s_IdentityAttribute_name,
            AssemblyNameValue,
            AssemblyNameValueCch));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

// if m_pAssemblyIdentity  is NULL, return TRUE with Cch == 0
BOOL
CAssemblyReference::GetAssemblyName(
    PCWSTR *pAssemblyName,
    SIZE_T *Cch
    ) const
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T CchTemp;

    if (Cch != NULL)
        *Cch = 0;

    if (pAssemblyName != NULL)
        *pAssemblyName = NULL;

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            m_pAssemblyIdentity,
            &s_IdentityAttribute_name,
            pAssemblyName,
            &CchTemp));

    if (Cch != NULL)
        *Cch = CchTemp;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CAssemblyReference::TakeValue(
    const CAssemblyReference &r
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity == NULL);
    INTERNAL_ERROR_CHECK(r.m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(0, r.m_pAssemblyIdentity, &m_pAssemblyIdentity));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL CAssemblyReference::ClearAssemblyName()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(::SxspRemoveAssemblyIdentityAttribute(0, m_pAssemblyIdentity, &s_IdentityAttribute_name));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CAssemblyReference::SetLanguage(
    const CBaseStringBuffer &rbuff
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxspSetAssemblyIdentityAttributeValue(
            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
            m_pAssemblyIdentity,
            &s_IdentityAttribute_language,
            rbuff,
            rbuff.Cch()));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CAssemblyReference::ClearLanguage()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);
    IFW32FALSE_EXIT(::SxspRemoveAssemblyIdentityAttribute(SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS, m_pAssemblyIdentity, &s_IdentityAttribute_language));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CAssemblyReference::IsLanguageWildcarded(
    bool &rfWildcarded
    ) const
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    const WCHAR *Value = NULL;
    SIZE_T Cch = 0;

    rfWildcarded = false;

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, m_pAssemblyIdentity, &s_IdentityAttribute_language, &Value, &Cch));

    if (Cch == 1)
    {
        INTERNAL_ERROR_CHECK(Value != NULL);

        if (Value[0] == L'*')
            rfWildcarded = true;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CAssemblyReference::IsProcessorArchitectureWildcarded(
    bool &rfWildcarded
    ) const
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    const WCHAR *Value = NULL;
    SIZE_T Cch = 0;

    rfWildcarded = false;

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, m_pAssemblyIdentity, &s_IdentityAttribute_processorArchitecture, &Value, &Cch));

    if (Cch == 1)
    {
        INTERNAL_ERROR_CHECK(Value != NULL);

        if (Value[0] == L'*')
            rfWildcarded = true;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CAssemblyReference::IsProcessorArchitectureX86(
    bool &rfX86
    ) const
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    const WCHAR *Value = NULL;
    SIZE_T Cch = 0;

    rfX86 = false;

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, m_pAssemblyIdentity, &s_IdentityAttribute_processorArchitecture, &Value, &Cch));

    if (Cch == 3)
    {
        INTERNAL_ERROR_CHECK(Value != NULL);

        if (((Value[0] == L'x') || (Value[0] == L'X')) &&
            (Value[1] == L'8') &&
            (Value[2] == L'6'))
            rfX86 = true;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CAssemblyReference::SetProcessorArchitecture(
    const WCHAR *String,
    SIZE_T Cch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK((String != NULL) || (Cch == 0));

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxspSetAssemblyIdentityAttributeValue(
            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
            m_pAssemblyIdentity,
            &s_IdentityAttribute_processorArchitecture,
            String,
            Cch));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CAssemblyReference::Assign(
    const CAssemblyReference &r
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY IdentityCopy = NULL;

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);
    INTERNAL_ERROR_CHECK(r.m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(0, r.m_pAssemblyIdentity, &IdentityCopy));
    ::SxsDestroyAssemblyIdentity(m_pAssemblyIdentity);
    m_pAssemblyIdentity = IdentityCopy;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

//dupilicate the input parameter
BOOL
CAssemblyReference::SetAssemblyIdentity(
    PCASSEMBLY_IDENTITY pAssemblyIdentitySource
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY TempAssemblyIdentity = NULL;

    PARAMETER_CHECK(pAssemblyIdentitySource != NULL);
    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL); // you should have initialized to start with...

    IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(
        0,
        pAssemblyIdentitySource,
        &TempAssemblyIdentity));

    ::SxsDestroyAssemblyIdentity(m_pAssemblyIdentity);
    m_pAssemblyIdentity = TempAssemblyIdentity;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CAssemblyReference::GetPublicKeyToken(
    CBaseStringBuffer *pbuffPublicKeyToken,
    BOOL &rfHasPublicKeyToken
    ) const
{
    FN_PROLOG_WIN32

    PCWSTR wchString = NULL;
    SIZE_T cchString = NULL;

    rfHasPublicKeyToken = FALSE;

    if (pbuffPublicKeyToken != NULL)
        pbuffPublicKeyToken->Clear();

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            m_pAssemblyIdentity,
            &s_IdentityAttribute_publicKeyToken,
            &wchString,
            &cchString));

    if (cchString != 0)
    {
        rfHasPublicKeyToken = TRUE;
        if (pbuffPublicKeyToken != NULL)
            IFW32FALSE_EXIT(pbuffPublicKeyToken->Win32Assign(wchString, cchString));
    }

    FN_EPILOG
}

BOOL CAssemblyReference::SetPublicKeyToken(
    const CBaseStringBuffer &rbuffPublicKeyToken
    )
{
    return this->SetPublicKeyToken(rbuffPublicKeyToken, rbuffPublicKeyToken.Cch());
}

BOOL CAssemblyReference::SetPublicKeyToken(
    PCWSTR pszPublicKeyToken,
    SIZE_T cchPublicKeyToken
    )
{
    BOOL bSuccess = FALSE;
    FN_TRACE_WIN32( bSuccess );

    PARAMETER_CHECK( (pszPublicKeyToken != NULL ) || ( cchPublicKeyToken == 0 ) );
    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxspSetAssemblyIdentityAttributeValue(
            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
            m_pAssemblyIdentity,
            &s_IdentityAttribute_publicKeyToken,
            pszPublicKeyToken,
            cchPublicKeyToken));

    bSuccess = TRUE;
Exit:
    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\fusion\sxs\actctxctb.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    actctxctb.cpp

Abstract:

    Code to manage the list of activation context contributors in sxs.dll.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"

CCriticalSectionNoConstructor g_ActCtxCtbListCritSec;
PACTCTXCTB g_ActCtxCtbListHead;
ULONG g_ActCtxCtbListCount;

#if SXSP_EXTENSIBLE_CONTRIBUTORS

BOOL
SxspAddActCtxContributor(
    PCWSTR DllName,
    PCSTR Prefix,
    SIZE_T PrefixCch,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    ULONG Format,
    PCWSTR ContributorName
    )
{
    CSxsPointer<ACTCTXCTB> Contrib;
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(
        (Format == ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE) || (Format == ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE));
    PARAMETER_CHECK(PrefixCch <= ACTCTXCTB_MAX_PREFIX_LENGTH);
    PARAMETER_CHECK(ContributorName != NULL);
    PARAMETER_CHECK(DllName != NULL);

    IFALLOCFAILED_EXIT(Contrib = new ACTCTXCTB);

    Contrib->m_Format = Format;

    if (ExtensionGuid != NULL)
    {
        Contrib->m_ExtensionGuid = *ExtensionGuid;
        Contrib->m_IsExtendedSection = ((Contrib->m_ExtensionGuid != GUID_NULL) != FALSE);
    }
    else
    {
        Contrib->m_ExtensionGuid = GUID_NULL;
        Contrib->m_IsExtendedSection = false;
    }

    IFW32FALSE_EXIT(Contrib->m_ContributorNameBuffer.Win32Assign(ContributorName, ::wcslen(ContributorName)));
    IFW32FALSE_EXIT(Contrib->m_DllNameBuffer.Win32Assign(DllName, ::wcslen(DllName)));

    if (PrefixCch != 0)
        IFW32FALSE_EXIT(Contrib->m_PrefixBuffer.Win32Assign(Prefix, PrefixCch));

    Contrib->m_PrefixCch = PrefixCch;
    Contrib->m_SectionId = SectionId;
    Contrib->m_RefCount = 1;
    {
        CSxsLockCriticalSection lock(g_ActCtxCtbListCritSec);
        IFW32FALSE_EXIT(lock.Lock());
        Contrib->m_Next = g_ActCtxCtbListHead;
        g_ActCtxCtbListHead = Contrib.Detach();
        g_ActCtxCtbListCount++;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

#endif

BOOL
SxspAddBuiltinActCtxContributor(
    ACTCTXCTB_CALLBACK_FUNCTION CallbackFunction,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    ULONG Format,
    PCWSTR ContributorName
    )
{
    SMARTPTR(ACTCTXCTB) Contrib;
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(
        (Format == ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE) ||
        (Format == ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE) ||
        (Format == 0));
    PARAMETER_CHECK(CallbackFunction != NULL);
    PARAMETER_CHECK(ContributorName != NULL);

    IFW32FALSE_EXIT(Contrib.Win32Allocate(__FILE__, __LINE__));

    Contrib->m_BuiltinContributor = true;
    Contrib->m_CallbackFunction = CallbackFunction;

    if (ExtensionGuid != NULL)
    {
        Contrib->m_ExtensionGuid = *ExtensionGuid;
        Contrib->m_IsExtendedSection = ((Contrib->m_ExtensionGuid != GUID_NULL) != FALSE);
    }
    else
    {
        Contrib->m_ExtensionGuid = GUID_NULL;
        Contrib->m_IsExtendedSection = false;
    }

    IFW32FALSE_EXIT(Contrib->m_ContributorNameBuffer.Win32Assign(ContributorName, ::wcslen(ContributorName)));

    Contrib->m_SectionId = SectionId;
    Contrib->m_Format = Format;
    Contrib->m_RefCount = 1;
    {
        CSxsLockCriticalSection lock(g_ActCtxCtbListCritSec);
        IFW32FALSE_EXIT(lock.Lock());
        Contrib->m_Next = g_ActCtxCtbListHead;
        g_ActCtxCtbListHead = Contrib.Detach();
        g_ActCtxCtbListCount++;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspInitActCtxContributors(
    )
{
    FN_PROLOG_WIN32;

    IFW32FALSE_EXIT(g_ActCtxCtbListCritSec.ConstructWithSEH());

    ASSERT(g_ActCtxCtbListHead == NULL);
    ASSERT(g_ActCtxCtbListCount == 0);

    IFW32FALSE_EXIT(::SxspAddBuiltinActCtxContributor(
                &SxspAssemblyMetadataContributorCallback,
                NULL,
                ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION,
                ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE,
                L"Builtin Assembly Metadata Contributor"));

    IFW32FALSE_EXIT(::SxspAddBuiltinActCtxContributor(
                &SxspDllRedirectionContributorCallback,
                NULL,
                ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION,
                ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE,
                L"Builtin DLL Redirection contributor"));

    IFW32FALSE_EXIT(::SxspAddBuiltinActCtxContributor(
                &SxspWindowClassRedirectionContributorCallback,
                NULL,
                ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION,
                ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE,
                L"Builtin Window Class Redirection contributor"));

    IFW32FALSE_EXIT(::SxspAddBuiltinActCtxContributor(
                &SxspComClassRedirectionContributorCallback,
                NULL,
                ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION,
                ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE,
                L"Builtin COM Server Redirection contributor"));

    IFW32FALSE_EXIT(::SxspAddBuiltinActCtxContributor(
                &SxspComProgIdRedirectionContributorCallback,
                NULL,
                ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION,
                ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE,
                L"Builtin COM ProgId redirection contributor"));

    IFW32FALSE_EXIT(::SxspAddBuiltinActCtxContributor(
                &SxspComTypeLibRedirectionContributorCallback,
                NULL,
                ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION,
                ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE,
                L"Builtin COM Type Library redirection contributor"));

    IFW32FALSE_EXIT(::SxspAddBuiltinActCtxContributor(
                &SxspComInterfaceRedirectionContributorCallback,
                NULL,
                ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION,
                ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE,
                L"Builtin COM interface redirection contributor"));

    IFW32FALSE_EXIT(::SxspAddBuiltinActCtxContributor(
                &SxspClrInteropContributorCallback,
                NULL,
                ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES,
                ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE,
                L"Builtin NDP surrogate data contributor"));

    FN_EPILOG;
}

VOID
SxspUninitActCtxContributors(
    VOID
    )
{
    FN_TRACE();
    PACTCTXCTB pCtb;

    g_ActCtxCtbListCritSec.Destruct();

    pCtb = g_ActCtxCtbListHead;

    while (pCtb != NULL)
    {
        PACTCTXCTB pNext = pCtb->m_Next;
        pCtb->Release();
        pCtb = pNext;
    }
}

BOOL
SxspPrepareContributor(
    PACTCTXCTB Contrib
    )
{
#if SXSP_EXTENSIBLE_CONTRIBUTORS
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CDynamicLinkLibrary DllHandle;

    PARAMETER_CHECK(Contrib != NULL);

    if ((Contrib->m_DllHandle == NULL) &&
        (!Contrib->m_BuiltinContributor))
    {
        ACTCTXCTB_CBINIT InitData;
        ACTCTXCTB_CALLBACK_FUNCTION CallbackFunction = NULL;

#define PROCEDURE_NAME "ContributeActCtxSection"

        CHAR ProcNameBuffer[ACTCTXCTB_MAX_PREFIX_LENGTH + sizeof(PROCEDURE_NAME)];
        PCSTR ProcName = PROCEDURE_NAME;

        IFW32FALSE_EXIT(DllHandle.Create(Contrib->m_DllNameBuffer));

        if (Contrib->m_PrefixBuffer[0] != NULL)
        {
            strcpy(ProcNameBuffer, Contrib->m_PrefixBuffer);
            strcat(ProcNameBuffer, PROCEDURE_NAME);
            ProcName = ProcNameBuffer;
        }

        IFW32FALSE_EXIT(DllHandle.GetProcAddress(ProcName, &CallbackFunction));

        // We're pretty much all set.  Initialize the contributor.
        InitData.Header.Reason = ACTCTXCTB_CBREASON_INIT;
        InitData.Header.ExtensionGuid = Contrib->GetExtensionGuidPtr();
        InitData.Header.SectionId = Contrib->m_SectionId;
        InitData.Header.ContributorContext = NULL;
        InitData.Header.Flags = 0;

        IFW32FALSE_EXIT(((*CallbackFunction)((PACTCTXCTB_CALLBACK_DATA) &InitData.Header)));

        ASSERT(InitData.Header.Reason == ACTCTXCTB_CBREASON_INIT);
        ASSERT(InitData.Header.ExtensionGuid == Contrib->GetExtensionGuidPtr());
        ASSERT(InitDa