///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : SPHProp.h
// Purpose  : Define the class that implements the RTP SPH
//            filter property page.
// Contents : 
//      class CSPHPropertyPage
//*M*/

#ifndef _SPHPROP_H_
#define _SPHPROP_H_

class 
CSPHPropertyPage 
: public CBasePropertyPage
{
	DWORD m_dwIDD_Base;

    static CUnknown * WINAPI
	CreateInstance2( LPUNKNOWN punk, HRESULT *phr, DWORD IDD_Base );
	
public:
    static CUnknown * WINAPI
	CreateInstance_aud( LPUNKNOWN punk, HRESULT *phr );

    static CUnknown * WINAPI
	CreateInstance_gena( LPUNKNOWN punk, HRESULT *phr );

    static CUnknown * WINAPI
	CreateInstance_genv( LPUNKNOWN punk, HRESULT *phr );

    static CUnknown * WINAPI
	CreateInstance_h26x( LPUNKNOWN punk, HRESULT *phr );

protected:
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate () ;
    HRESULT OnApplyChanges();

    CSPHPropertyPage( LPUNKNOWN punk, HRESULT *phr, DWORD IDD_Base);

    BOOL OnInitDialog( void );
    BOOL OnCommand( int iButton, int iNotify, LPARAM lParam );

    void SetDirty();

protected:
	IRTPSPHFilter	*m_pIRTPSPHFilter;
    BOOL m_bIsInitialized;  // Will be false while we set init values in Dlg

	BOOL m_bPayloadScanned;
	BOOL m_bMTUScanned;
	int m_dwPayloadType;
	DWORD m_dwMTUsize;
};

#endif _SPHPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\common\sphgipin.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : sphgipin.cpp
// Purpose  : RTP SPH Generic filter input pin implementation.
// Contents : 
//*M*/

#include <winsock2.h>
#include <streams.h>
#include <list.h>
#include <stack.h>
#include <ippm.h>
#include <sph.h>
#include <sphgipin.h>

CSPHGENIPin::CSPHGENIPin(
        TCHAR *pObjectName,
        CTransformFilter *pTransformFilter,
        HRESULT * phr,
        LPCWSTR pName) : CTransformInputPin(pObjectName,
						   pTransformFilter,
						   phr,
						   pName
						   )
{
}

HRESULT CSPHGENIPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
	return ((CSPHBase *)m_pTransformFilter)->GetInputPinMediaType(iPosition, 
		pMediaType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\common\sphgipin.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : rphipin.h
// Purpose  : Define the class that implements/overrides the RTP RPH input pins.
// Contents : 
//*M*/


#ifndef _SPHGIPIN_H_
#define _SPHGIPIN_H_

#include <sph.h>

class CSPHGENIPin : public CTransformInputPin
{ 
public:
    CSPHGENIPin(
        TCHAR *pObjectName,
        CTransformFilter *pTransformFilter,
        HRESULT * phr,
        LPCWSTR pName);

    virtual HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);

}; //CSPHGENIPin

#endif _SPHGIPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\common\sphres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#if !defined(_SPHRES_H_)
#define      _SPHRES_H_

#define IDD_SPHAUD_BASE                 3400
#define IDD_SPHGENA_BASE                3420
#define IDD_SPHGENV_BASE                3440
#define IDD_SPHH26X_BASE                3460

#define IDD_SPH_PROPPAGE_IDX            1
#define IDC_SPH_PAYLOADTYPE_IDX         2
#define IDC_SPH_MTU_IDX                 3

#define IDD_SPHAUD_SPH_PROPPAGE         3401
#define IDC_SPHAUD_PAYLOADTYPE          3402
#define IDC_SPHAUD_MTU                  3403

#define IDD_SPHGENA_SPH_PROPPAGE        3421
#define IDC_SPHGENA_PAYLOADTYPE         3422
#define IDC_SPHGENA_MTU                 3423
#define IDD_SPHGENA_SPHGENA_PROPPAGE    3425
#define IDC_SPHGENA_OUTPUTPINLIST       3426

#define IDD_SPHGENV_SPH_PROPPAGE        3441
#define IDC_SPHGENV_PAYLOADTYPE         3442
#define IDC_SPHGENV_MTU                 3443
#define IDD_SPHGENV_SPHGENV_PROPPAGE    3445
#define IDC_SPHGENV_OUTPUTPINLIST       3446

#define IDD_SPHH26X_SPH_PROPPAGE        3461
#define IDC_SPHH26X_PAYLOADTYPE         3462
#define IDC_SPHH26X_MTU                 3463

#define IDS_SPHGEN                      3481
#define IDS_SPHGEN_AUDIO                3482
#define IDS_SPHGEN_VIDEO                3483
#define IDS_RTPSPH_PACKETSIZE_TOOSMALL  3484
#define IDS_RTPSPH_PACKETSIZE_OTHER     3485
#define IDS_RTPSPH_PACKETSIZE_ERRTITLE  3486

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\common\sph.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : sph.cpp
// Purpose  : RTP SPH base class filter implementation.
// Contents : 
//*M*/

#include <winsock2.h>
#include <streams.h>
#include <ippm.h>
#include <amrtpuid.h>
#include <sph.h>
#include <ppmclsid.h>
#include <memory.h>

// ZCS 7-10-97: the minimum packet size a user can ask for.
// Set this to 12 + some more for possible header extensions.
#define MINIMUM_PACKET_SIZE 30

//
// Constructor
//
CSPHBase::CSPHBase(TCHAR *tszName,LPUNKNOWN punk,HRESULT *phr, CLSID clsid,
				   DWORD dwPacketNum,
				   DWORD dwPacketSize,
				   DWORD cPropPageClsids,
				   const CLSID **pPropPageClsids) :
    CTransformFilter(tszName, punk, clsid),
	CPersistStream(punk, phr),
	m_lBufferRequest(dwPacketNum),
	m_dwMaxPacketSize(dwPacketSize),
	m_cPropertyPageClsids(cPropPageClsids),
	m_pPropertyPageClsids(pPropPageClsids)
{
	DbgLog((LOG_TRACE,4,TEXT("CSPHBase::")));

    ASSERT(tszName);
    ASSERT(phr);

	m_pPPMSend = NULL;
	m_pPPM = NULL;
	m_pPPMCB = NULL;
	m_pPPMSession = NULL;
	m_pPPMSU = NULL;
	m_pIInputSample = NULL;
	m_PayloadType = -1;
	// CoInitialize(NULL);
	m_bPaused = TRUE;

	m_pIPPMErrorCP = NULL;	
	m_pIPPMNotificationCP = NULL;
	m_dwPPMErrCookie = 0;
	m_dwPPMNotCookie = 0;
	m_dwBufferSize = 0;
	m_bPTSet = FALSE;

} // CSPHBase

CSPHBase::~CSPHBase()
{
	//release and unload PPM
	if (m_pPPM) { m_pPPM->Release(); m_pPPM = NULL; }
	if (m_pPPMCB) {m_pPPMCB->Release(); m_pPPMCB = NULL; }
	if (m_pPPMSend) {m_pPPMSend->Release(); m_pPPMSend = NULL; }
	if (m_pPPMSession) {m_pPPMSession->Release(); m_pPPMSession = NULL; }
	if (m_dwPPMErrCookie) {m_pIPPMErrorCP->Unadvise(m_dwPPMErrCookie); m_dwPPMErrCookie = 0; }
	if (m_dwPPMNotCookie) {m_pIPPMNotificationCP->Unadvise(m_dwPPMNotCookie); m_dwPPMNotCookie = 0; }
	if (m_pIPPMErrorCP) {m_pIPPMErrorCP->Release(); m_pIPPMErrorCP = NULL; }
    if (m_pIPPMNotificationCP) {m_pIPPMNotificationCP->Release(); m_pIPPMNotificationCP = NULL; }

	// CoUninitialize();
}

//
// NonDelegatingQueryInterface
//
// Reveals IRTPSPHFilter and other custom inherited interfaces
//
STDMETHODIMP CSPHBase::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (riid == IID_IRTPSPHFilter) {
        return GetInterface((IRTPSPHFilter *) this, ppv);
	} else if (riid == IID_ISubmit) {
        return GetInterface((ISubmit *) this, ppv);
	} else if (riid == IID_ISubmitCallback) {
        return GetInterface((ISubmitCallback *) this, ppv);
	} else if (riid == IID_IPPMError) {
        return GetInterface((IPPMError *) this, ppv);
	} else if (riid == IID_IPPMNotification) {
        return GetInterface((IPPMNotification *) this, ppv);
	} else if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *) this, ppv);
	} else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);    
	} else {
        return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface

// Notes from CTransformFilter::GetPin:
// return a non-addrefed CBasePin * for the user to addref if he holds onto it
// for longer than his pointer to us. We create the pins dynamically when they
// are asked for rather than in the constructor. This is because we want to
// give the derived class an oppportunity to return different pin objects

// We return the objects as and when they are needed. If either of these fails
// then we return NULL, the assumption being that the caller will realise the
// whole deal is off and destroy us - which in turn will delete everything.

// Note: This is overridden here to provide a hook for the sphgen* filters to
//   provide their own pin so that they can provide GetMediaType for the input pins.
CBasePin *
CSPHBase::GetPin(int n)
{
	return CTransformFilter::GetPin(n);
}

//
// Receive
// Override from CTransformFilter because Transform() is only 1-1; we need 1-many
// This is the transform work engine along with Submit
//
HRESULT CSPHBase::Receive(IMediaSample *pSample)
{
    HRESULT hr;
    ASSERT(pSample);
	WSABUF pWSABuffer[2];
	REFERENCE_TIME AMTimeStart, AMTimeEnd;

	DbgLog((LOG_TRACE,4,TEXT("CSPHBase::Receive")));

    // If no output to deliver to then no point sending us data

    ASSERT (m_pOutput != NULL) ;

	//Make sure I have a PPM to talk to, or else
	if (m_pPPM == NULL) { return E_FAIL; }

	//Build the WSABUFs for PPM
	//Data
	hr = pSample->GetPointer ((BYTE**)&(pWSABuffer[0].buf));
	if (FAILED(hr)) {
		return VFW_E_SAMPLE_REJECTED;
	}

	
	pWSABuffer[0].len = pSample->GetActualDataLength();

#if 0
	DWORD checksum = 0;
	for (int i = 0; i < pWSABuffer[0].len; i++) {
		checksum += (short) *((BYTE*)pWSABuffer[0].buf+i);
	}

	DbgLog((LOG_TRACE,3,TEXT("CSPHBase::Receive New Data checksum %ld, length %d"), 
		checksum,pWSABuffer[0].len));
#endif


	//Timestamp
	hr = pSample->GetTime(&AMTimeStart,&AMTimeEnd);
	if (FAILED(hr)) {
		return VFW_E_SAMPLE_REJECTED;
	}

	DWORD dwTS = (DWORD) ConvertToMilliseconds(AMTimeStart);
	
	pWSABuffer[1].buf = (char *) &dwTS;
	pWSABuffer[1].len = sizeof(dwTS);

	DbgLog((LOG_TIMING,2,TEXT("CSPHBase::Receive got pSample timestamps of start %ld stop %ld"),
		ConvertToMilliseconds(AMTimeStart),
		ConvertToMilliseconds(AMTimeEnd)));

	LONGLONG TimeStart, TimeEnd;
	pSample->GetMediaTime(&TimeStart,&TimeEnd);

	DbgLog((LOG_TIMING,2,TEXT("CSPHBase::Receive pSample media timestamps are start %ld stop %ld"),
		(DWORD)TimeStart, (DWORD)TimeEnd));


	//Copy this into member variable so that our Submit can get the media times
	m_pIInputSample = pSample;
	pSample->AddRef();  //to be nice

	HRESULT hError = NOERROR;
	if ((pSample->IsDiscontinuity() == S_OK) || (m_bPaused)) {
		hError = HRESULT_BUFFER_START_STREAM;
		m_bPaused = FALSE;
	}
	hr = m_pPPM->Submit(pWSABuffer, 2, pSample, hError);

	//Here is where I need to propogate frame drop errors
	//lsc  Do additional checks for partial frame or frame drop
    if (FAILED(hr)) {
		DbgLog((LOG_TRACE,4,TEXT("CSPHBase::Receive Error from PPM::Submit")));
        m_bSampleSkipped = TRUE;
        if (!m_bQualityChanged) {
            NotifyEvent(EC_QUALITY_CHANGE,0,0);
            m_bQualityChanged = TRUE;
        }
        hr = NOERROR;
    }


	//Since these calls to PPM return synchronously, I've gotten all my 
	//callbacks by now, so regardless of send error, I can release the buffer
	pSample->Release();

	if (FAILED(hr)) {
		hr = VFW_E_RUNTIME_ERROR;
	}

	return hr;
}


// Submit
// Some code from CTransformFilter because Transform() is only 1-1; we need 1-many
// This is the transform work engine, along with Receive
// This function is called from PPM to give SPH the packet buffers
//
STDMETHODIMP CSPHBase::Submit(WSABUF *pWSABuffer, DWORD BufferCount, 
							void *pUserToken, HRESULT Error)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CSPHBase::Submit")));

    HRESULT hr;
	IMediaSample *pSample = m_pIInputSample;
	IMediaSample *pOutSample;
	char *pSampleData = NULL;

    CRefTime tStart, tStop;
    REFERENCE_TIME * pStart = NULL;
    REFERENCE_TIME * pStop = NULL;
    if (NOERROR == pSample->GetTime((REFERENCE_TIME*)&tStart, (REFERENCE_TIME*)&tStop)) {
	pStart = (REFERENCE_TIME*)&tStart;
	pStop  = (REFERENCE_TIME*)&tStop;
    }

	//If I don't have a PPM to talk to, I can't do anything
	if (m_pPPMCB == NULL)
		return E_FAIL;

    // this may block for an indeterminate amount of time
    hr = m_pOutput->GetDeliveryBuffer( &pOutSample
                             , pStart
                             , pStop
                             , m_bSampleSkipped ? AM_GBF_PREVFRAMESKIPPED : 0
                                     );
    if (FAILED(hr)) {
#if 0
		char msg[128];
		wsprintf(msg,"CSPHBase::Submit: m_pOutput->GetDeliveryBuffer() "
				 "failed: 0x%X\n", hr);
		OutputDebugString(msg);
#endif
		//Release PPM's packet buffer
		m_pPPMCB->SubmitComplete(pUserToken, hr);
		
		return hr;
    }

    ASSERT(pOutSample);
    pOutSample->SetTime(pStart, pStop);
    pOutSample->SetSyncPoint(pSample->IsSyncPoint() == S_OK);
    pOutSample->SetDiscontinuity(m_bSampleSkipped ||
                                 pSample->IsDiscontinuity() == S_OK);
    m_bSampleSkipped = FALSE;

    // Copy the media times

    LONGLONG MediaStart, MediaEnd;
    if (pSample->GetMediaTime(&MediaStart,&MediaEnd) == NOERROR) {
        pOutSample->SetMediaTime(&MediaStart,&MediaEnd);
    }

	DbgLog((LOG_TIMING,2,TEXT("CSPHBase::Submit pOutSample media timestamps being set to %ld stop %ld"),
		(DWORD)MediaStart, (DWORD)MediaEnd));

    // Start timing the transform (if PERF is defined)
    MSR_START(m_idTransform);

    // have the derived class transform the data

	//We don't do this because the work is done in Submit and Receive
	//hr = Transform(pSample, pOutSample);

	//do copy to sample here
	int offset = 0;
	BYTE *DataPtr = NULL;
	hr = pOutSample->GetPointer(&DataPtr);
    if (FAILED(hr)) {
#if 0
		char msg[128];
		wsprintf(msg,"CSPHBase::Submit: pOutSample->GetPointer() failed: "
				 "0x%X\n", hr);
		OutputDebugString(msg);
		DebugBreak();
#endif
		//Release PPM's packet buffer
		m_pPPMCB->SubmitComplete(pUserToken, hr);

		return hr;
    }

	for (unsigned int i = 0; i < BufferCount; i++) {
		memcpy((void *)(DataPtr+offset), 
			(const void *)pWSABuffer[i].buf, 
			pWSABuffer[i].len);
		offset += pWSABuffer[i].len;
	}

	pOutSample->SetActualDataLength(offset);

#if 0
	DWORD checksum = 0;
	for (int i = 0; i < pOutSample->GetActualDataLength(); i++) {
		checksum += (short) *((BYTE*)pWSABuffer[0].buf+i);
	}

	DbgLog((LOG_TRACE,3,TEXT("CSPHBase::Submit sending Data checksum %ld, length %d"), 
		checksum,pOutSample->GetActualDataLength()));
#endif

    // Stop the clock and log it (if PERF is defined)
    MSR_STOP(m_idTransform);


	hr = m_pOutput->Deliver(pOutSample);

    // release the output buffer. If the connected pin still needs it,
    // it will have addrefed it itself.
    pOutSample->Release();

	//Release PPM's packet buffer
	m_pPPMCB->SubmitComplete(pUserToken, hr);

    return hr;
}

//
// DecideBufferSize
//
// Tell the output pin's allocator what size buffers we
// require. Can only do this when the input is connected
//
HRESULT CSPHBase::DecideBufferSize(IMemAllocator *pAlloc,ALLOCATOR_PROPERTIES *pProperties)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CSPHBase::DecideBufferSize")));

    // Is the input pin connected

    if (m_pInput->IsConnected() == FALSE) {
        return E_UNEXPECTED;
    }

    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    pProperties->cBuffers = m_lBufferRequest;

	//Set the size of the buffers to MTU size
	m_dwBufferSize = m_dwMaxPacketSize;
    pProperties->cbBuffer = m_dwBufferSize;

    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    if (pProperties->cBuffers > Actual.cBuffers ||
            pProperties->cbBuffer > Actual.cbBuffer) {
                return E_FAIL;
    }
    return NOERROR;

} // DecideBufferSize

//
// GetInputPinMediaType
//
// This will never be called except for those filters which provide
//  their own input pin implementation for GetMediaType and call this
//  from it.  The generic filters use this to control the media type
//  of the input pin, based on SetInputPinMediaType.  This function is
//  called from CSPHGIPIN::GetMediaType.  This is an overloaded function.
//  The other function with this name is the one that is part of the SPH
//  custom interface, IRTPSPHFilter.
//
HRESULT CSPHBase::GetInputPinMediaType(int iPosition, CMediaType *pMediaType)
{
	return NOERROR;
}

//
// GetMediaType
//
// I support one type, namely the type that was set in CompleteConnect
// We must be connected to support the single output type
//
HRESULT CSPHBase::GetMediaType(int iPosition, CMediaType *pMediaType)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CSPHBase::GetMediaType")));

    // Is the input pin connected

    if (m_pInput->IsConnected() == FALSE) {
        return E_UNEXPECTED;
    }

    // This should never happen

    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    // Do we have more items to offer

    if (iPosition > 0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    *pMediaType = m_pOutput->CurrentMediaType();
    return NOERROR;

} // GetMediaType

HRESULT
CSPHBase::Pause()
{
	m_bPaused = TRUE;
	return CTransformFilter::Pause();
}
// override these two functions if you want to inform something
// about entry to or exit from streaming state.

// StartStreaming
// This function is where PPM initialization occurs
//
HRESULT CSPHBase::StartStreaming()
{
	
	DbgLog((LOG_TRACE,4,TEXT("CSPHBase::StartStreaming")));

	ISubmitUser *pPPMSU = NULL;
	HRESULT hr;

	//Create and init PPM
	hr = CoCreateInstance(m_PPMCLSIDType, NULL, CLSCTX_INPROC_SERVER,
		IID_IPPMSend,(void**) &m_pPPMSend);
	if (FAILED(hr)) return E_FAIL;
	hr = m_pPPMSend->QueryInterface(IID_ISubmit,(void**)&m_pPPM);
	if (FAILED(hr)) {m_pPPMSend->Release(); m_pPPMSend = NULL; return E_FAIL;}
	hr = m_pPPMSend->QueryInterface(IID_ISubmitUser,(void**)&pPPMSU);
	if (FAILED(hr)) {
		m_pPPMSend->Release(); m_pPPMSend = NULL;
		m_pPPM->Release(); m_pPPM = NULL;
		return E_FAIL;
	}
	hr = m_pPPMSend->InitPPMSend(m_dwMaxPacketSize, NULL);
	if (FAILED(hr)) {
		m_pPPMSend->Release(); m_pPPMSend = NULL;
		m_pPPM->Release(); m_pPPM = NULL;
		pPPMSU->Release(); pPPMSU = NULL;
		return E_FAIL;
	}
	

	pPPMSU->SetOutput((ISubmit*)this);
	pPPMSU->Release(); pPPMSU = NULL;

	m_pPPM->InitSubmit((ISubmitCallback *)this);

	hr = m_pPPM->QueryInterface(IID_IPPMSendSession,(void**)&m_pPPMSession);
	if (FAILED(hr)) {
		m_pPPMSession = NULL;
	} else {
		SetPPMSession();
	}

	// Provide PPM with the Connection Point Sinks
	hr = GetPPMConnPt();
	if (FAILED(hr)) {
		// should we do something here if the Connection Points fail
		DbgLog((LOG_ERROR,1,TEXT("CSPHBase::StartStreaming - GetPPMConnPt() Failed!")));
	}

	return NOERROR;
}

// SetPPMSession
// This function is where PPM::SetSession is called and may be specific to payload
//  handler.  Minimum function is to set the payload type.
HRESULT CSPHBase::SetPPMSession() 
{
	HRESULT hr;
	if (m_pPPMSession) {
		hr = m_pPPMSession->SetPayloadType((unsigned char)m_PayloadType);
		return hr;
	} else {
		return E_FAIL;
	}
}


// StopStreaming
// This function is where PPM gets released
//
HRESULT CSPHBase::StopStreaming()
{
	
	DbgLog((LOG_TRACE,4,TEXT("CSPHBase::StopStreaming")));

	//release and unload PPM
	if (m_pPPM) m_pPPM->Flush();
	if (m_pPPM) {m_pPPM->Release(); m_pPPM = NULL; }
	if (m_pPPMCB) {m_pPPMCB->Release(); m_pPPMCB = NULL; }
	if (m_pPPMSend) {m_pPPMSend->Release(); m_pPPMSend = NULL; }
	if (m_pPPMSession) {m_pPPMSession->Release(); m_pPPMSession = NULL; }
	if (m_dwPPMErrCookie) {m_pIPPMErrorCP->Unadvise(m_dwPPMErrCookie); m_dwPPMErrCookie = 0; }
	if (m_dwPPMNotCookie) {m_pIPPMNotificationCP->Unadvise(m_dwPPMNotCookie); m_dwPPMNotCookie = 0; }
	if (m_pIPPMErrorCP) {m_pIPPMErrorCP->Release(); m_pIPPMErrorCP = NULL; }
    if (m_pIPPMNotificationCP) {m_pIPPMNotificationCP->Release(); m_pIPPMNotificationCP = NULL; }

    return NOERROR;
}

// ISubmit methods for PPM

// InitSubmit
// This function is called from PPM to set up the callback pointer to PPM
//
HRESULT CSPHBase::InitSubmit(ISubmitCallback *pSubmitCallback)
{
	if (!pSubmitCallback) return E_POINTER;

	m_pPPMCB = pSubmitCallback;
	m_pPPMCB->AddRef();
	return NOERROR;
}

void CSPHBase::ReportError(HRESULT Error){}
HRESULT CSPHBase::Flush(void){return NOERROR;}

// ISubmitCallback methods for PPM

// SubmitComplete
// This function is called from PPM to return to SPH the media buffers
//
void CSPHBase::SubmitComplete(void *pUserToken, HRESULT Error)
{
	//I don't have to release the sample buffer here, since all calls from PPM
	//return synchronously to SPH; the release is done in Receive()
	return;
}
	
void CSPHBase::ReportError(HRESULT Error, int Placeholder){}

// IRTPSPHFilter methods

// OverridePayloadType
// Overrides the payload type used in the RTP packets
// Needs to be called before PPM initialization (StartStreaming) to be useful
//
HRESULT CSPHBase::OverridePayloadType(BYTE bPayloadType)
{
	DbgLog((LOG_TRACE,4,TEXT("CSPHBase::OverridePayloadType")));

    CAutoLock l(&m_cStateLock);

    // ZCS bugfix 6-12-97
	if (m_State != State_Stopped)
		return VFW_E_NOT_STOPPED;
	
	if ((bPayloadType <0) || (bPayloadType > 127))
		return E_INVALIDARG;

    SetDirty(TRUE); // So that our state will be saved if we are in a .grf    

	m_PayloadType = (int) bPayloadType;
	m_bPTSet = TRUE;

	return NOERROR;
}

// GetPayloadType
// Gets the payload type used in the RTP packets
// Only useful if called after StartStreaming has been called at least once,
//  because unless overridden, the type is set after pin connection
//
HRESULT CSPHBase::GetPayloadType(BYTE __RPC_FAR *lpbPayloadType)
{
	DbgLog((LOG_TRACE,4,TEXT("CSPHBase::GetPayloadType")));

	if (!lpbPayloadType) return E_POINTER;

	*lpbPayloadType = (unsigned char)m_PayloadType;
	return NOERROR;
}

// SetMaxPacketSize
// Sets the maximum packet size for fragmentation
// Needs to be called before PPM initialization (StartStreaming) to be useful
// in setting maximum packet size.  Once DecideBufferSize has been called,
// size can be set, but can never be larger than at the time of that call to
// DecideBufferSize.
//
HRESULT CSPHBase::SetMaxPacketSize(DWORD dwMaxPacketSize)
{
    CAutoLock l(&m_cStateLock);

    // ZCS bugfix 7-10-97
	// We shouldn't try to reconnect pins while we're running!!!
	if (m_State != State_Stopped)
		return VFW_E_NOT_STOPPED;

	// ZCS bugfix 7-10-97
	// We will fail later on if we ask for buffers that are too tiny. 0 would
	// cause an assertion failure, and < the size of the RTP header causes
	// division by zero errors! RTP headers are normally 12 bytes but can
	// have various extensions. See the top of this file for the #define...
	if (dwMaxPacketSize < MINIMUM_PACKET_SIZE)
		return E_INVALIDARG;
	
    SetDirty(TRUE); // So that our state will be saved if we are in a .grf    

	// update the max packet size
	m_dwMaxPacketSize = dwMaxPacketSize;

	// ZCS 7-10-97: Now we must reconnect our output so that we can renegotiate the
	// buffer size with the output pin's allocator.	That's the rest of this function...

	// if we have an output pin...
	if (m_pOutput)
	{
		IPin *pOtherPin = NULL;
		
		// if we are connected...
		if (SUCCEEDED(m_pOutput->ConnectedTo(&pOtherPin)) && pOtherPin)
		{
			FILTER_INFO info;
			EXECUTE_ASSERT(SUCCEEDED(QueryFilterInfo(&info)));
			
			// if we aren't in a filter graph there's not much we can do.
			if (info.pGraph != NULL)
			{
				// reconnect had better succeed, because we were already connected.
				EXECUTE_ASSERT(SUCCEEDED(info.pGraph->Reconnect(m_pOutput)));
				info.pGraph->Release(); // we got an addrefed handle...
			}
			
			pOtherPin->Release(); // we got an addrefed handle...
		}
	}
	
	return NOERROR;
}

// GetMaxPacketSize
// Gets the current maximum packet size for fragmentation
//
HRESULT CSPHBase::GetMaxPacketSize(LPDWORD lpdwMaxPacketSize)
{
    CAutoLock l(&m_cStateLock);

	if (!lpdwMaxPacketSize) return E_POINTER;

	*lpdwMaxPacketSize = m_dwMaxPacketSize;
	return NOERROR;
}

// SetOutputPinMinorType
// Sets the type of the output pin
// Needs to be called before CheckTransform and the last CheckInputType to be useful
// We don't expect to get called for this in other than the generic filters
//
HRESULT CSPHBase::SetOutputPinMinorType(GUID gMinorType)
{
	return E_UNEXPECTED;
}

// GetOutputPinMinorType
// Gets the type of the output pin
// We don't expect to get called for this in other than the generic filters
//
//lsc - or do we?
HRESULT CSPHBase::GetOutputPinMinorType(GUID *lpgMinorType)
{
	return E_UNEXPECTED;
}

// SetInputPinMediaType
// Sets the type of the input pin
// Needs to be called before CheckInputType to be useful
// We don't expect to get called for this in other than the generic filters
//
HRESULT CSPHBase::SetInputPinMediaType(AM_MEDIA_TYPE *lpMediaPinType)
{
	return E_UNEXPECTED;
}

// GetInputPinMediaType
// Gets the type of the input pin
// We don't expect to get called for this in other than the generic filters
// This is an overloaded function.  The other function with this name is
// called from SPHGIPIN::GetMediaType.  This function is part of the
// IRTPSPHFilter custom interface
//
HRESULT CSPHBase::GetInputPinMediaType(AM_MEDIA_TYPE **ppMediaPinType)
{
	return E_UNEXPECTED;
}


//
// PPMError Connection point interface implementation
//
HRESULT CSPHBase::PPMError( HRESULT hError,
						   DWORD dwSeverity,
						   DWORD dwCookie,
						   unsigned char pData[],
						   unsigned int iDatalen)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CSPHBase::PPMError")));

	return NOERROR;
}

//
// PPMNotification Connection point interface implementation
//
HRESULT CSPHBase::PPMNotification(THIS_ HRESULT hStatus,
								  DWORD dwSeverity,
								  DWORD dwCookie,
								  unsigned char pData[],
								  unsigned int iDatalen)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CSPHBase::PPMNotification")));

	return NOERROR;
}

//
// Provide sinks for the IPPMError and IPPMNotification connection points
//
HRESULT CSPHBase::GetPPMConnPt( )
{
	
	DbgLog((LOG_TRACE,4,TEXT("CSPHBase::GetPPMConnPt")));
	HRESULT hErr;

    IConnectionPointContainer *pIConnectionPointContainer;
    hErr = m_pPPMSend->QueryInterface(IID_IConnectionPointContainer, 
                                        (PVOID *) &pIConnectionPointContainer);
    if (FAILED(hErr)) {
		DbgLog((LOG_ERROR,1,TEXT("CSPHBase::GetPPMConnPt Failed to get connection point from ppm!")));
        return hErr;
    } /* if */

    hErr = pIConnectionPointContainer->FindConnectionPoint(IID_IPPMError, &m_pIPPMErrorCP);
    if (FAILED(hErr)) {
		DbgLog((LOG_ERROR,1,TEXT("CSPHBase::GetPPMConnPt Failed to get IPPMError connection point!")));
        pIConnectionPointContainer->Release();
        return hErr;
    } /* if */
    hErr = pIConnectionPointContainer->FindConnectionPoint(IID_IPPMNotification, &m_pIPPMNotificationCP);
    if (FAILED(hErr)) {
		DbgLog((LOG_ERROR,1,TEXT("CSPHBase::GetPPMConnpt Failed to get IPPMNotification connection point!")));
        pIConnectionPointContainer->Release();
        return hErr;
    } /* if */
	hErr = m_pIPPMErrorCP->Advise((IPPMError *) this, &m_dwPPMErrCookie);
	if (FAILED(hErr)) {
        DbgLog((LOG_ERROR,1,TEXT("CSPHBase::GetPPMConnpt Failed to advise IPPMError connection point!")));
        pIConnectionPointContainer->Release();
		return hErr;
    } /* if */
	hErr = m_pIPPMNotificationCP->Advise((IPPMNotification *) this, &m_dwPPMNotCookie);
	if (FAILED(hErr)) {
        DbgLog((LOG_ERROR,1,TEXT("CSPHBase::GetPPMConnpt Failed to advise IPPMNotification connection point!")));
        pIConnectionPointContainer->Release();
		return hErr;
    } /* if */

    pIConnectionPointContainer->Release();

	return NOERROR;
}

//  Name    : CSPHBase::GetPages()
//  Purpose : Return the CLSID of the property page we support.
//  Context : Called when the FGM wants to show our property page.
//  Returns : 
//      E_OUTOFMEMORY   Unable to allocate structure to return property pages in.
//      NOERROR         Successfully returned property pages.
//  Params  :
//      pcauuid Pointer to a structure used to return property pages.
//  Notes   : None.

HRESULT 
CSPHBase::GetPages(
    CAUUID *pcauuid) 
{
	UINT i = 0;

    DbgLog((LOG_TRACE, 3, TEXT("CSPHBase::GetPages called")));

    pcauuid->cElems = m_cPropertyPageClsids;
    pcauuid->pElems =
		(GUID *) CoTaskMemAlloc(m_cPropertyPageClsids * sizeof(GUID));
	
    if (pcauuid->pElems == NULL) {
        return E_OUTOFMEMORY;
    }

   	for( i = 0; i < m_cPropertyPageClsids; i++)
	{
		pcauuid->pElems[i] = *m_pPropertyPageClsids[ i ];
	}
    return NOERROR;
} /* CSPHBase::GetPages() */

// CPersistStream methods

// ReadFromStream
// This is the call that will read persistent data from file
//
HRESULT CSPHBase::ReadFromStream(IStream *pStream) 
{
	DbgLog((LOG_TRACE, 4, TEXT("CSPHBase::ReadFromStream")));
	HRESULT hr;

	int iPayloadType;
	DWORD dwMaxPacketSize;
	ULONG uBytesRead;

	DbgLog((LOG_TRACE, 4, 
			TEXT("CSPHBase::ReadFromStream: Loading payload type")));
	hr = pStream->Read(&iPayloadType, sizeof(iPayloadType), &uBytesRead);
	if (FAILED(hr)) {
		DbgLog((LOG_ERROR, 2, 
				TEXT("CSPHBase::ReadFromStream: Error 0x%08x reading payload type"),
				hr));
		return hr;
	} else if (uBytesRead != sizeof(iPayloadType)) {
		DbgLog((LOG_ERROR, 2, 
				TEXT("CSPHBase::ReadFromStream: Mismatch in (%d/%d) bytes read for payload type"),
				uBytesRead, sizeof(iPayloadType)));
		return E_INVALIDARG;
	}
	if (iPayloadType != -1) {
		DbgLog((LOG_TRACE, 4, 
				TEXT("CSPHBase::ReadFromStream: Restoring payload type")));
		hr = OverridePayloadType((unsigned char)iPayloadType);
		if (FAILED(hr)) {
			DbgLog((LOG_ERROR, 2, 
					TEXT("CSPHBase::ReadFromStream: Error 0x%08x restoring payload type"),
					hr));
		}
	}

	DbgLog((LOG_TRACE, 4, 
			TEXT("CSPHBase::ReadFromStream: Loading maximum packet buffer size")));
	hr = pStream->Read(&dwMaxPacketSize, sizeof(dwMaxPacketSize), &uBytesRead);
	if (FAILED(hr)) {
		DbgLog((LOG_ERROR, 2, 
				TEXT("CSPHBase::ReadFromStream: Error 0x%08x reading maximum packet buffer size"),
				hr));
		return hr;
	} else if (uBytesRead != sizeof(dwMaxPacketSize)) {
		DbgLog((LOG_ERROR, 2, 
				TEXT("CSPHBase::ReadFromStream: Mismatch in (%d/%d) bytes read for maximum packet buffer size"),
				uBytesRead, sizeof(dwMaxPacketSize)));
		return E_INVALIDARG;
	}
	DbgLog((LOG_TRACE, 4, 
			TEXT("CSPHBase::ReadFromStream: Restoring maximum packet buffer size")));
	hr = SetMaxPacketSize(dwMaxPacketSize);
	if (FAILED(hr)) {
		DbgLog((LOG_ERROR, 2, 
				TEXT("CSPHBase::ReadFromStream: Error 0x%08x restoring maximum packet buffer size"),
				hr));
	}

	return NOERROR; 
}

// WriteToStream
// This is the call that will write persistent data to file
//
HRESULT CSPHBase::WriteToStream(IStream *pStream) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CSPHBase::WriteToStream")));
    HRESULT hr;
    ULONG uBytesWritten = 0;

    DbgLog((LOG_TRACE, 4, 
            TEXT("CSPHBase::WriteToStream: Writing payload type")));
    hr = pStream->Write(&m_PayloadType, sizeof(m_PayloadType), &uBytesWritten);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CSPHBase::WriteToStream: Error 0x%08x writing payload type"),
                hr));
        return hr;
    } else if (uBytesWritten != sizeof(m_PayloadType)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CSPHBase::WriteToStream: Mismatch in (%d/%d) bytes written for payload type"),
                uBytesWritten, sizeof(m_PayloadType)));
        return E_INVALIDARG;
    }

    DbgLog((LOG_TRACE, 4, 
            TEXT("CSPHBase::WriteToStream: Writing maximum packet buffer size")));
    hr = pStream->Write(&m_dwMaxPacketSize, sizeof(m_dwMaxPacketSize), &uBytesWritten);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CSPHBase::WriteToStream: Error 0x%08x writing maximum packet buffer size"),
                hr));
        return hr;
    } else if (uBytesWritten != sizeof(m_dwMaxPacketSize)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CSPHBase::WriteToStream: Mismatch in (%d/%d) bytes written for maximum packet buffer size"),
                uBytesWritten, sizeof(m_dwMaxPacketSize)));
        return E_INVALIDARG;
    } 

	return NOERROR; 
}

// SizeMax
// This returns the amount of storage space required for my persistent data
//
int CSPHBase::SizeMax(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CSPHBase::SizeMax")));

    return sizeof(m_PayloadType)
         + sizeof(m_dwMaxPacketSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\common\sphprop.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : sphprop.cpp
// Purpose  : RTP SPH Property Page.
// Contents : 
//*M*/


#include <winsock2.h>
#include <streams.h>
#include <ippm.h>
#include <amrtpuid.h>
#include <sph.h>
#include <ppmclsid.h>
#include <memory.h>
#include <sphres.h>
#include <sphprop.h>
#include <commctrl.h>

#include "sphres.h"

EXTERN_C const CLSID CLSID_INTEL_SPHPropertyPage;

#define IDC_PAYLOADTYPE  (m_dwIDD_Base + IDC_SPH_PAYLOADTYPE_IDX)
#define IDC_MTU          (m_dwIDD_Base + IDC_SPH_MTU_IDX)

CUnknown * WINAPI 
CSPHPropertyPage::CreateInstance_aud(LPUNKNOWN punk, HRESULT *phr)
{
	return(CreateInstance2(punk, phr, IDD_SPHAUD_BASE));
}

CUnknown * WINAPI 
CSPHPropertyPage::CreateInstance_gena(LPUNKNOWN punk, HRESULT *phr)
{
	return(CreateInstance2(punk, phr, IDD_SPHGENA_BASE));
}

CUnknown * WINAPI 
CSPHPropertyPage::CreateInstance_genv(LPUNKNOWN punk, HRESULT *phr)
{
	return(CreateInstance2(punk, phr, IDD_SPHGENV_BASE));
}

CUnknown * WINAPI 
CSPHPropertyPage::CreateInstance_h26x(LPUNKNOWN punk, HRESULT *phr)
{
	return(CreateInstance2(punk, phr, IDD_SPHH26X_BASE));
}

CUnknown * WINAPI 
CSPHPropertyPage::CreateInstance2( 
    LPUNKNOWN punk, 
    HRESULT *phr,
	DWORD IDD_Base)
{
    CSPHPropertyPage *pNewObject
        = new CSPHPropertyPage( punk, phr, IDD_Base);

    if( pNewObject == NULL )
        *phr = E_OUTOFMEMORY;

    return pNewObject;
} /* CSPHPropertyPage::CreateInstance() */


CSPHPropertyPage::CSPHPropertyPage( 
    LPUNKNOWN pUnk,
    HRESULT *phr,
	DWORD IDD_Base)
    : CBasePropertyPage(NAME("Intel RTP SPH Property Page"),pUnk,
        IDD_Base+IDD_SPH_PROPPAGE_IDX, IDS_SPHGEN)
    , m_pIRTPSPHFilter (NULL)
    , m_bIsInitialized(FALSE)
	, m_bPayloadScanned(FALSE)
	, m_bMTUScanned(FALSE)
	, m_dwIDD_Base(IDD_Base)	

{
    DbgLog((LOG_TRACE, 3, TEXT("CSPHPropertyPage::CSPHPropertyPage: Constructed at 0x%08x"), this));
} /* CSPHPropertyPage::CSPHPropertyPage() */

void 
CSPHPropertyPage::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
} /* CSPHPropertyPage::SetDirty() */

INT_PTR 
CSPHPropertyPage::OnReceiveMessage(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSPHPropertyPage::OnReceiveMessage: Entered")));
    switch (uMsg) {
    case WM_INITDIALOG:
		return OnInitDialog();
		break;

    case WM_COMMAND:
        if (m_bIsInitialized) {
            if (OnCommand( (int) LOWORD( wParam ), (int) HIWORD( wParam ), lParam ) == TRUE) {
                return (LRESULT) 1;
            } /* if */
        } else {
			return(LRESULT) 1;
//            return CSPHPropertyPage::OnInitDialog();
        } /* if */
        break;
    } /* switch */

    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
} /* CSPHPropertyPage::OnReceiveMessage() */


HRESULT 
CSPHPropertyPage::OnConnect(
    IUnknown    *pUnknown)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSPHPropertyPage::OnConnect: Entered")));
    ASSERT(m_pIRTPSPHFilter == NULL);
    DbgLog((LOG_TRACE, 2, TEXT("CSPHPropertyPage::OnConnect: Called with IUnknown 0x%08x"), pUnknown));

	HRESULT hr = pUnknown->QueryInterface(IID_IRTPSPHFilter, (void **) &m_pIRTPSPHFilter);
	if(FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, TEXT("CSPHPropertyPage::OnConnect: Error 0x%08x getting IRTPSPHFilter interface!"), hr));
	    return hr;
    } /* if */
	ASSERT( m_pIRTPSPHFilter != NULL );
    m_bIsInitialized = FALSE;
    DbgLog((LOG_TRACE, 3, TEXT("CSPHPropertyPage::OnConnect: Got IRTPSPHFilter interface at 0x%08x"), m_pIRTPSPHFilter));

    return NOERROR;
} /* CSPHPropertyPage::OnConnect() */


HRESULT 
CSPHPropertyPage::OnDisconnect(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSPHPropertyPage::OnDisconnect: Entered")));

    if (m_pIRTPSPHFilter == NULL)
    {
        return E_UNEXPECTED;
    }

	m_pIRTPSPHFilter->Release();
	m_pIRTPSPHFilter = NULL;
    return NOERROR;
} /* CSPHPropertyPage::OnDisconnect() */


HRESULT 
CSPHPropertyPage::OnActivate(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSPHPropertyPage::OnActivate: Entered")));

	m_bIsInitialized = TRUE;
    return NOERROR;
} /* CSPHPropertyPage::OnActivate() */


BOOL 
CSPHPropertyPage::OnInitDialog(void)
{
	BYTE tmpByte;
	DWORD dwMaxPacketSize;
	int PayloadType;
	HRESULT hErr;

    DbgLog((LOG_TRACE, 4, TEXT("CSPHPropertyPage::OnInitDialog: Entered")));

	hErr = m_pIRTPSPHFilter->GetPayloadType(&tmpByte);

	if (tmpByte == 0xff)
		PayloadType = -1;
	else
		PayloadType = tmpByte;

	if (!FAILED(hErr) && (PayloadType != -1))
		SetDlgItemInt(m_Dlg, IDC_PAYLOADTYPE, PayloadType, TRUE);

	hErr = m_pIRTPSPHFilter->GetMaxPacketSize(&dwMaxPacketSize);

	SetDlgItemInt(m_Dlg, IDC_MTU, dwMaxPacketSize, TRUE);

	// ZCS 7-10-97: Now let's ask the filter for its state...
	FILTER_STATE state;
	DWORD        dwMilliSecsTimeout = 0; // we ignore this
    EXECUTE_ASSERT( SUCCEEDED( ( (CSPHBase *) m_pIRTPSPHFilter )
		-> GetState( dwMilliSecsTimeout, &state ) ) );

	// ZCS 7-10-97: ...and if it's not stopped, let's gray out all the properties.
	if (state == State_Stopped)
		EnableWindow(m_Dlg, TRUE);
	else
		EnableWindow(m_Dlg, FALSE);

	return (LRESULT) 1;
} /* CSPHPropertyPage::OnInitDialog() */


BOOL 
CSPHPropertyPage::OnCommand( 
    int     iButton, 
    int     iNotify,
    LPARAM  lParam)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSPHPropertyPage::OnCommand: Entered")));
	switch(iButton-m_dwIDD_Base) {
	case IDC_SPH_PAYLOADTYPE_IDX:
		m_dwPayloadType = GetDlgItemInt(m_Dlg, IDC_PAYLOADTYPE, &m_bPayloadScanned, FALSE);
		break;
	case IDC_SPH_MTU_IDX:
		m_dwMTUsize = GetDlgItemInt(m_Dlg, IDC_MTU, &m_bMTUScanned, FALSE);
		break;
	default:
		break;
	} /* switch */
	
	if (m_bPayloadScanned || m_bMTUScanned)
		SetDirty();

    return (LRESULT) 1;
} /* CSPHPropertyPage::OnCommand() */


HRESULT 
CSPHPropertyPage::OnApplyChanges(void)
{
	HRESULT hErr;
	BYTE tmpByte;

    DbgLog((LOG_TRACE, 4, TEXT("CSPHPropertyPage::OnApplyChanges: Entered")));
    ASSERT( m_pIRTPSPHFilter != NULL );

	tmpByte = (m_dwPayloadType & 0x000000ff);
	if (m_bPayloadScanned) {
		if (m_dwPayloadType != -1)
			hErr = m_pIRTPSPHFilter->OverridePayloadType(tmpByte);
	}
	if (m_bMTUScanned) {
		hErr = m_pIRTPSPHFilter->SetMaxPacketSize(m_dwMTUsize);

		if (FAILED(hErr))
		{
			//
			// ZCS: bring up a message box to report the error (7-10-97)
			//

			// first load in the strings from the string table resource
			TCHAR szText[256], szCaption[256];
			LoadString(g_hInst, (hErr == E_INVALIDARG) ? IDS_RTPSPH_PACKETSIZE_TOOSMALL :
														 IDS_RTPSPH_PACKETSIZE_OTHER, szText, 255);
			LoadString(g_hInst, IDS_RTPSPH_PACKETSIZE_ERRTITLE, szCaption, 255);

			// now display it
			MessageBox(m_hwnd, szText, szCaption, MB_OK);
			// ...we don't care what they clicked

			// change the MTU number in the GUI back to what it was
			// the old text is a valid 32-bit decimal number and is therefore limited to ten digits
			// we are safe and use an 80 digit limit :)
			TCHAR szOldNumber[80];
			DWORD dwOldNumber = 0;

			// there's really no reason why it shouldn't succeed, but just to be safe...
			if (SUCCEEDED(m_pIRTPSPHFilter->GetMaxPacketSize(&dwOldNumber)))
			{
				wsprintf(szOldNumber, "%d", dwOldNumber);
				SetWindowText(GetDlgItem(m_hwnd, IDC_MTU), szOldNumber);
			}

			return hErr;
		}
	}
    return(NOERROR);

} /* CSPHPropertyPage::OnApplyChanges() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphgena\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphaud\template.h ===
/*********************************************************************
 *
 * Copyright (c) 1997 Microsoft Corporation
 *
 * File: sph\sphaud\template.h
 *
 * Abstract:
 *     Macros to define CFactoryTemplate templates
 *
 * History:
 *     10/28/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_SPHAUD_TEMPLATE_H_)
#define      _SPHAUD_TEMPLATE_H_

extern AMOVIESETUP_FILTER sudSPHAUD;

#define CFT_SPHAUD_FILTER \
{ \
	  L"Intel RTP SPH for G.711/G.723.1", \
	  &CLSID_INTEL_SPHAUD, \
	  CSPHAUD::CreateInstance, \
	  NULL, \
	  &sudSPHAUD \
	  }

#define CFT_SPHAUD_FILTER_PROP \
{ \
	  L"Intel RTP SPH Property Page", \
	  &CLSID_INTEL_SPHAUD_PROPPAGE, \
	  CSPHPropertyPage::CreateInstance_aud \
	  }

#define CFT_SPHAUD_ALL_FILTERS \
CFT_SPHAUD_FILTER, \
CFT_SPHAUD_FILTER_PROP

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphgena\genaprop.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : GENAProp.h
// Purpose  : Define the class that implements the RTP SPH
//            Generic Audio filter property page.
// Contents : 
//      class CSPHGENAPropertyPage
//*M*/

#ifndef _SPH_GENAPROP_H_
#define _SPH_GENAPROP_H_

//----------------------------------------------------------------------------
// RTP/RTCP: Registry information under:
//				HKEY_LOCAL_MACHINE\SOFTWARE\INTEL\ActiveMovie_Filters
//----------------------------------------------------------------------------

#define szRegAMRTPKey				TEXT("SOFTWARE\\Intel\\ActiveMovie Filters")


// Property Page Class for Generic Audio
class 
CSPHGENAPropertyPage 
: public CBasePropertyPage
{
	
public:
    static CUnknown * WINAPI CreateInstance( LPUNKNOWN punk, HRESULT *phr );

protected:
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate () ;
	HRESULT	OnDeactivate ();
    HRESULT OnApplyChanges();

    CSPHGENAPropertyPage( LPUNKNOWN punk, HRESULT *phr);

    BOOL OnInitDialog( void );
    BOOL OnCommand( int iButton, int iNotify, LPARAM lParam );

    void SetDirty();

protected:
	IRTPSPHFilter	*m_pIRTPSPHFilter;
    BOOL			m_bIsInitialized;  // Will be false while we set init values in Dlg
	GUID			*m_pGuidVal;
	int				m_nActiveItems;
	BOOL			m_bMinorTypeScanned;
};


#endif _GENAPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphaud\sphaud.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : sphaud.h
// Purpose  : Define the class that implements the RTP SPH G.711 (alaw/mulaw) 
//            and G.723.1 Audio filter.
// Contents : 
//*M*/


#ifndef _SPHAUD_H_
#define _SPHAUD_H_

#include <sph.h>

#define DEFAULT_PACKET_SIZE_SPHAUD 1450
#define DEFAULT_PACKETBUF_NUM_SPHAUD 2 // HUGEMEMORY 128->2
#define G711A_PT    8    //assigned RTP payload number for PCMA
#define G711_PT     0    //assigned RTP payload number for PCMU
#define G723_PT     4    //assigned RTP payload number for G.723.1

class CSPHAUD : public CSPHBase
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    DECLARE_IUNKNOWN;

    virtual HRESULT CheckInputType(const CMediaType *mtIn);
    virtual HRESULT CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut);
	virtual HRESULT CompleteConnect(PIN_DIRECTION dir,IPin *pPin);


	// CPersistStream methods
	virtual HRESULT ReadFromStream(IStream *pStream);
	virtual HRESULT _stdcall GetClassID(CLSID *pCLSID);
	virtual DWORD GetSoftwareVersion(void);

    // Setup helper
    virtual LPAMOVIESETUP_FILTER GetSetupData();

private:

    // Constructor
    CSPHAUD(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);
	virtual HRESULT SetPPMSession();

}; // CSPHAUD


#endif // _SPHAUD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphgenv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphgena\genaprop.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : genaprop.cpp
// Purpose  : RTP SPH Generic Audio Property Page.
// Contents : 
//*M*/

#include <winsock2.h>
#include <streams.h>
#include <ippm.h>
#include <amrtpuid.h>
#include <sph.h>
#include <ppmclsid.h>
#include <memory.h>
#include <resource.h>
#include <genaprop.h>

#include "sphres.h"

CUnknown * WINAPI 
CSPHGENAPropertyPage::CreateInstance( 
    LPUNKNOWN punk, 
    HRESULT *phr )
{
    CSPHGENAPropertyPage *pNewObject
        = new CSPHGENAPropertyPage( punk, phr);

    if( pNewObject == NULL )
        *phr = E_OUTOFMEMORY;

    return pNewObject;
} /* CSPHGENAPropertyPage::CreateInstance() */


CSPHGENAPropertyPage::CSPHGENAPropertyPage( 
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBasePropertyPage(NAME("Intel RTP SPH Generic Audio Property Page"),pUnk,
        IDD_SPHGENA_SPHGENA_PROPPAGE, IDS_SPHGEN_AUDIO)
    , m_pIRTPSPHFilter (NULL)
    , m_bIsInitialized(FALSE)
	, m_bMinorTypeScanned(FALSE)
	, m_nActiveItems(0)
	, m_pGuidVal(NULL)

{
    DbgLog((LOG_TRACE, 3, TEXT("CSPHGENAPropertyPage::CSPHGENAPropertyPage: Constructed at 0x%08x"), this));
} /* CSPHGENAPropertyPage::CSPHGENAPropertyPage() */

void 
CSPHGENAPropertyPage::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
} /* CSPHGENAPropertyPage::SetDirty() */


INT_PTR 
CSPHGENAPropertyPage::OnReceiveMessage(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENAPropertyPage::OnReceiveMessage: Entered")));

    switch (uMsg) {
    case WM_INITDIALOG:
		return OnInitDialog();
		break;

    case WM_COMMAND:
        if (m_bIsInitialized) {
            if (OnCommand( (int) LOWORD( wParam ), (int) HIWORD( wParam ), lParam ) == TRUE) {
               return (LRESULT) 1;
            } /* if */
        } else {
			return(LRESULT) 1;
        } /* if */
        break;

	case WM_DESTROY:
		CSPHGENAPropertyPage::OnDeactivate();
		break;
    } /* switch */

    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
} /* CSPHGENAPropertyPage::OnReceiveMessage() */


HRESULT 
CSPHGENAPropertyPage::OnConnect(
    IUnknown    *pUnknown)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENAPropertyPage::OnConnect: Entered")));
    ASSERT(m_pIRTPSPHFilter == NULL);
    DbgLog((LOG_TRACE, 2, TEXT("CSPHGENAPropertyPage::OnConnect: Called with IUnknown 0x%08x"), pUnknown));

	HRESULT hr = pUnknown->QueryInterface(IID_IRTPSPHFilter, (void **) &m_pIRTPSPHFilter);
	if(FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, TEXT("CSPHGENAPropertyPage::OnConnect: Error 0x%08x getting IRTPSPHFilter interface!"), hr));
	    return hr;
    } /* if */
	ASSERT( m_pIRTPSPHFilter != NULL );
    m_bIsInitialized = FALSE;
    DbgLog((LOG_TRACE, 3, TEXT("CSPHGENAPropertyPage::OnConnect: Got IRTPSPHFilter interface at 0x%08x"), m_pIRTPSPHFilter));

    return NOERROR;
} /* CSPHGENAPropertyPage::OnConnect() */


HRESULT 
CSPHGENAPropertyPage::OnDisconnect(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENAPropertyPage::OnDisconnect: Entered")));

    
	if (m_pIRTPSPHFilter == NULL)
        return E_UNEXPECTED;

	m_pIRTPSPHFilter->Release();
	m_pIRTPSPHFilter = NULL;

    return NOERROR;
} /* CSPHGENAPropertyPage::OnDisconnect() */


HRESULT 
CSPHGENAPropertyPage::OnActivate(void)
{
	HKEY	hKey;
	HKEY	hTypeKey;
	long	lRes;
	char	keyBfr[50];
	DWORD	dwBufLen, dwIndex, nTypekeys, nTypeNameLen;
	DWORD	nSubtypekeys, nSubtypeNameLen;
	DWORD	nValueNameLen, dwData, dwValLen;
	HANDLE	hHeap;
	LPTSTR	lpTypeBuf;
	BYTE	*lpValBuf;
	HWND	hCurrentListbox;
	char	szMediaType[]="Audio";
	LRESULT	lrCurrentItem;
	GUID	*pGuidVal;
	wchar_t	szCLSID[40];
    
	DbgLog((LOG_TRACE, 4, TEXT("CSPHGENAPropertyPage::OnActivate: Entered")));

    hCurrentListbox = GetDlgItem(m_hwnd, IDC_SPHGENA_OUTPUTPINLIST);

	// open the key
	strcpy (keyBfr, szRegAMRTPKey);
	lRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE, keyBfr, 0, KEY_READ, &hKey);

	lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, &nTypekeys, &nTypeNameLen,
							NULL, NULL, NULL, NULL, NULL, NULL);
	// Allocate memory
	hHeap = GetProcessHeap();
	lpTypeBuf = (char *)HeapAlloc(hHeap, 0, ++nTypeNameLen);
	
	// Retrieve Registry values for the Media Types
	for (dwIndex = 0; dwIndex < nTypekeys; dwIndex++)
	{
		dwBufLen = nTypeNameLen;
		lRes = RegEnumKeyEx(hKey, dwIndex, lpTypeBuf, &dwBufLen, NULL, NULL, NULL, NULL);
		lRes = RegOpenKeyEx (hKey, lpTypeBuf, 0, KEY_READ, &hTypeKey);
		lRes = RegQueryInfoKey(hTypeKey, NULL, NULL, NULL, &nSubtypekeys, &nSubtypeNameLen,
								 NULL, NULL, NULL, &nValueNameLen, NULL, NULL);
		lpValBuf = (BYTE *)HeapAlloc(hHeap, 0, ++nValueNameLen);
		dwValLen = nValueNameLen;
		lRes = RegQueryValueEx(hTypeKey, "Media Type", NULL, &dwData, lpValBuf, &dwValLen);
		if(strncmp((char *)lpValBuf, szMediaType, dwValLen) == 0)
		{
			// save the MEDIATYPE GUID for use later
			// retrieve the Subtype KEYS
			dwValLen = nValueNameLen;
			lRes = RegQueryValueEx(hTypeKey, "Description", NULL, &dwData, lpValBuf, &dwValLen);
			lrCurrentItem = SendMessage(hCurrentListbox, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(lpValBuf));
			pGuidVal = (GUID *)HeapAlloc(hHeap, 0, sizeof(GUID));
			int i;
			i = mbstowcs(szCLSID, lpTypeBuf, 40);
			CLSIDFromString(szCLSID, pGuidVal);
			SendMessage(hCurrentListbox, LB_SETITEMDATA, lrCurrentItem, (LPARAM) pGuidVal);
			// increment the number of active items in the Dialog Box
			// we'll use this to free the memory later.
			m_nActiveItems += 1;

			// ZCS fix 6-19-97: if this is the current output pin minor type, make it selected.			
			GUID *pGuidValFromPin = (GUID *)HeapAlloc(hHeap, 0, sizeof(GUID));
			ASSERT(pGuidValFromPin);
			if (SUCCEEDED(m_pIRTPSPHFilter->GetOutputPinMinorType(pGuidValFromPin))
													&& (*pGuidValFromPin == *pGuidVal))
				SendMessage(hCurrentListbox, LB_SETCURSEL, lrCurrentItem, 0);
			HeapFree(hHeap, 0, (void *)pGuidValFromPin);

			// HeapFree and RegCloseKey here
			HeapFree(hHeap, 0, lpValBuf);
			RegCloseKey(hTypeKey);
		}
		else
		{
			HeapFree(hHeap, 0, lpValBuf);
			RegCloseKey(hTypeKey);
		}
	}
	
	m_bIsInitialized = TRUE;

	HeapFree(hHeap, 0, lpTypeBuf);
	RegCloseKey(hKey);

    return NOERROR;
} /* CSPHGENAPropertyPage::OnActivate() */

HRESULT 
CSPHGENAPropertyPage::OnDeactivate(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENAPropertyPage::OnDeactivate: Entered")));
    
	HANDLE hHeap;
	GUID   *pGuidVal;
	HWND   hCurrentListbox = GetDlgItem(m_Dlg, IDC_SPHGENA_OUTPUTPINLIST);
	int	   i;

    if (m_pIRTPSPHFilter == NULL)
    {
        return E_UNEXPECTED;
    }

	hHeap = GetProcessHeap();

	for (i=0; i < m_nActiveItems; i++)
	{
        pGuidVal = reinterpret_cast<GUID *>(SendMessage(hCurrentListbox, LB_GETITEMDATA, i, 0));
		HeapFree(hHeap, 0, (void*)pGuidVal);
	}

	// Probably don't really need to do this as its likely the object is going
	// away .. but .. better safe than sorry
	m_nActiveItems = 0;

    return NOERROR;
} /* CSPHGENAPropertyPage::OnDeactivate() */

BOOL 
CSPHGENAPropertyPage::OnInitDialog(void)
{

    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENAPropertyPage::OnInitDialog: Entered")));

    return (LRESULT) 1;
} /* CSPHGENAPropertyPage::OnInitDialog() */


BOOL 
CSPHGENAPropertyPage::OnCommand( 
    int     iButton, 
    int     iNotify,
    LPARAM  lParam)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENAPropertyPage::OnCommand: Entered")));
	
	HWND hCurrentListbox;
	LRESULT lrCurrentSel;

    switch( iButton ){
	case IDC_SPHGENA_OUTPUTPINLIST:
		if(iNotify == IDOK)
		{
			m_bMinorTypeScanned = TRUE;
			hCurrentListbox = GetDlgItem(m_Dlg, IDC_SPHGENA_OUTPUTPINLIST);
			lrCurrentSel = SendMessage(hCurrentListbox, LB_GETCURSEL, 0, 0);
			m_pGuidVal = reinterpret_cast<GUID *>(SendMessage(hCurrentListbox,
															  LB_GETITEMDATA,
															  lrCurrentSel,
															  0));
			SetDirty();
		}
		break;
    default:
        break;
    } /* switch */	

    return (LRESULT) 1;
} /* CSPHGENAPropertyPage::OnCommand() */


HRESULT 
CSPHGENAPropertyPage::OnApplyChanges(void)
{

	HRESULT	hErr;

    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENAPropertyPage::OnApplyChanges: Entered")));
    ASSERT( m_pIRTPSPHFilter != NULL );

	if (m_bMinorTypeScanned) {
		hErr = m_pIRTPSPHFilter->SetOutputPinMinorType(*m_pGuidVal);
        if (FAILED(hErr)) {
            DbgLog((LOG_ERROR, 1, TEXT("CRPHGENVPropPage::OnApplyChanges: SetOutputPinMediaType returned 0x%08X"),
                hErr));
        }
	}
    return(NOERROR);

} /* CSPHGENAPropertyPage::OnApplyChanges() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphgena\template.h ===
/*********************************************************************
 *
 * Copyright (c) 1997 Microsoft Corporation
 *
 * File: sph\sphgena\template.h
 *
 * Abstract:
 *     Macros to define CFactoryTemplate templates
 *
 * History:
 *     10/28/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_SPHGENA_TEMPLATE_H_)
#define      _SPHGENA_TEMPLATE_H_

EXTERN_C const CLSID CLSID_INTEL_SPHGENA;
EXTERN_C const CLSID CLSID_INTEL_SPHGENA_PROPPAGE;
EXTERN_C const CLSID CLSID_INTEL_SPHGENA_PIN_PROPPAGE;

extern AMOVIESETUP_FILTER sudSPHGENA;

#define CFT_SPHGENA_FILTER \
{ \
	  L"Intel RTP SPH for Generic Audio", \
	  &CLSID_INTEL_SPHGENA, \
	  CSPHGENA::CreateInstance, \
	  NULL, \
	  &sudSPHGENA \
	  }

#define CFT_SPHGENA_FILTER_PROP \
{ \
	  L"Intel RTP SPH Property Page", \
	  &CLSID_INTEL_SPHGENA_PROPPAGE, \
	  CSPHPropertyPage::CreateInstance_gena \
	  }

#define CFT_SPHGENA_GENERIC_PROP \
{ \
	  L"Intel RTP SPH Generic Audio Property Page", \
	  &CLSID_INTEL_SPHGENA_PIN_PROPPAGE, \
	  CSPHGENAPropertyPage::CreateInstance \
	  }

#define CFT_SPHGENA_ALL_FILTERS \
CFT_SPHGENA_FILTER, \
CFT_SPHGENA_FILTER_PROP, \
CFT_SPHGENA_GENERIC_PROP

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphaud\sphaud.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : sphaud.cpp
// Purpose  : RTP SPH G.711 (alaw/mulaw) and G.723.1 Audio filter implementation.
// Contents : 
//*M*/

#include <winsock2.h>
#include <streams.h>
#if !defined(SPH_IN_DXMRTP)
#include <initguid.h>
#define INITGUID
#endif
#include <ippm.h>
#include <amrtpuid.h>
#include <auduids.h>
#include <uuids.h>
#include <sphaud.h>
#include <ppmclsid.h>
#include <memory.h>
#include <mmreg.h>
#include <sphprop.h>

#include "template.h"

// setup data

EXTERN_C const CLSID CLSID_INTEL_SPHAUD;
EXTERN_C const CLSID CLSID_INTEL_SPHAUD_PROPPAGE;

static const CLSID *pPropertyPageClsids[] =
{
    &CLSID_INTEL_SPHAUD_PROPPAGE
};

#define NUMPROPERTYPAGES \
    (sizeof(pPropertyPageClsids)/sizeof(pPropertyPageClsids[0]))

static AMOVIESETUP_MEDIATYPE sudOutputPinTypes[] =
{
	{
		&MEDIATYPE_RTP_Single_Stream,       // Major type
		&MEDIASUBTYPE_RTP_Payload_G711U     // Minor type
	},
	{
		&MEDIATYPE_RTP_Single_Stream,       // Major type
		&MEDIASUBTYPE_RTP_Payload_G711A     // Minor type
	},
	{
		&MEDIATYPE_RTP_Single_Stream,       // Major type
		&MEDIASUBTYPE_RTP_Payload_G723      // Minor type
	}
};

static AMOVIESETUP_MEDIATYPE sudInputPinTypes[] =
{
	{
		&MEDIATYPE_Audio,        // Major type
		&MEDIASUBTYPE_MULAWAudio // Minor type
	},
	{
		&MEDIATYPE_Audio,       // Major type
		&MEDIASUBTYPE_ALAWAudio // Minor type
	},
	{
		&MEDIATYPE_Audio,       // Major type
		&MEDIASUBTYPE_G723Audio // Minor type
	},
	{
		&MEDIATYPE_Audio,       // Major type
		&MEDIASUBTYPE_PCM       // Minor type
	},
	{
		&MEDIATYPE_Audio,       // Major type
		&MEDIASUBTYPE_NULL      // Minor type
	}
};

static AMOVIESETUP_PIN psudPins[] =
{
    {
        L"Input",           // String pin name
        FALSE,              // Is it rendered
        FALSE,              // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Output",          // Connects to pin
        3,                  // Number of types
        (AMOVIESETUP_MEDIATYPE *)&sudInputPinTypes },// The pin details
      { L"Output",          // String pin name
        FALSE,              // Is it rendered
        TRUE,               // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Input",           // Connects to pin
        5,                  // Number of types
        (AMOVIESETUP_MEDIATYPE *)&sudOutputPinTypes  // The pin details
    }
};


AMOVIESETUP_FILTER sudSPHAUD =
{
    &CLSID_INTEL_SPHAUD,    // Filter CLSID
    L"Intel RTP SPH for G.711/G.723.1", // Filter name
    MERIT_DO_NOT_USE, //MERIT_UNLIKELY,         // Its merit
    2,                      // Number of pins
    psudPins                // Pin details
};


// List of class IDs and creator functions for the class factory. This
// provides the link between the OLE entry point in the DLL and an object
// being created. The class factory will call the static CreateInstance

#if !defined(SPH_IN_DXMRTP)
CFactoryTemplate g_Templates[] = {
	CFT_SPHAUD_ALL_FILTERS
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif

//
// Constructor
//
CSPHAUD::CSPHAUD(TCHAR *tszName,LPUNKNOWN punk,HRESULT *phr) :
	CSPHBase(tszName, punk, phr, CLSID_INTEL_SPHAUD,
			 DEFAULT_PACKETBUF_NUM_SPHAUD,
			 DEFAULT_PACKET_SIZE_SPHAUD,
			 NUMPROPERTYPAGES,
			 pPropertyPageClsids)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CSPHAUD::")));

    ASSERT(tszName);
    ASSERT(phr);

} // CSPHAUD


//
// CreateInstance
//
// Provide the way for COM to create a CSPHAUD object
//
CUnknown *CSPHAUD::CreateInstance(LPUNKNOWN punk, HRESULT *phr) {

	DbgLog((LOG_TRACE,4,TEXT("CSPHAUD::CreateInstance")));

    CSPHAUD *pNewObject = new CSPHAUD(NAME("Intel RTP Send Payload Handler for G.711/G.723"), punk, phr);
    if (pNewObject == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return pNewObject;

} // CreateInstance


//
// GetSetupData
//
// Returns registry information for this filter
//
LPAMOVIESETUP_FILTER CSPHAUD::GetSetupData()
{
    return &sudSPHAUD;

} // GetSetupData



//
// CheckInputType
//
// Check the input type is OK, return an error otherwise
//
HRESULT CSPHAUD::CheckInputType(const CMediaType *mtIn)
{

	DbgLog((LOG_TRACE,4,TEXT("CSPHAUD::CheckInputType")));

	//Check major type first
    if (*mtIn->Type() != MEDIATYPE_Audio) 
    {
	    //We don't support this major type
        return E_FAIL;
    }

	//Check all supported minor types
	if (*mtIn->Subtype() == MEDIASUBTYPE_MULAWAudio) {
		if (m_bPTSet)
        {
            if (m_PayloadType != G711_PT)
            {
                return E_INVALIDARG;
            }
        }
        else
        {
            m_PayloadType = G711_PT;
        }
		m_PPMCLSIDType = CLSID_G711PPMSend;
    	return NOERROR;
	}

	if (*mtIn->Subtype() == MEDIASUBTYPE_ALAWAudio) {
		if (m_bPTSet)
        {
            if (m_PayloadType != G711A_PT)
            {
                return E_INVALIDARG;
            }
        }
        else
        {
            m_PayloadType = G711A_PT;
        }
		m_PPMCLSIDType = CLSID_G711APPMSend;
		return NOERROR;
	}

	if (*mtIn->Subtype() == MEDIASUBTYPE_G723Audio) {
		if (m_bPTSet)
        {
            if (m_PayloadType != G723_PT)
            {
                return E_INVALIDARG;
            }
        }
        else
        {
            m_PayloadType = G723_PT;
        }
		m_PPMCLSIDType = CLSID_G723PPMSend;
		return NOERROR;
	} 

	//Check all other supported minor types which require a WAVEFORMATEX
	if ((*mtIn->Subtype() == MEDIASUBTYPE_PCM) || 
		(*mtIn->Subtype() == MEDIASUBTYPE_NULL)) {
		//check format
		if (*mtIn->FormatType() == FORMAT_WaveFormatEx) {
		if ((void*)IsBadReadPtr(mtIn->Format(), sizeof (WAVEFORMATEX*))) return E_FAIL;
		if (mtIn->IsPartiallySpecified()) return E_FAIL;
		if (mtIn->Format() == NULL) return E_FAIL;
			if (((WAVEFORMATEX *)(mtIn->Format()))->wFormatTag ==
				WAVE_FORMAT_MULAW) {
				m_PPMCLSIDType = CLSID_G711PPMSend;
				if (!m_bPTSet) m_PayloadType = G711_PT;
				return NOERROR;
			}
			if (((WAVEFORMATEX *)(mtIn->Format()))->wFormatTag ==
				WAVE_FORMAT_ALAW) {
				m_PPMCLSIDType = CLSID_G711APPMSend;
				if (!m_bPTSet) m_PayloadType = G711A_PT;
				return NOERROR;
			}
#if 0
			if (((WAVEFORMATEX *)(mtIn->Format()))->wFormatTag ==
				WAVE_FORMAT_G723) {
				m_PPMCLSIDType = CLSID_G723PPMSend;
				if (!m_bPTSet) m_PayloadType = G723_PT;
				return NOERROR;
			}
#endif
		}
	} 

	//Otherwise, we don't support this input subtype
	return E_INVALIDARG;

} // CheckInputType


//
// CheckTransform
//
// To be able to transform the formats must be identical
//
HRESULT CSPHAUD::CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut)
{

	DbgLog((LOG_TRACE,4,TEXT("CSPHAUD::CheckTransform")));

	//Check all supported minor types
	if ((*mtIn->Subtype() == MEDIASUBTYPE_PCM) || 
		(*mtIn->Subtype() == MEDIASUBTYPE_NULL)) {
		if ((((WAVEFORMATEX *)mtIn->Format())->wFormatTag ==
						WAVE_FORMAT_MULAW) && 
			(*mtOut->Subtype() == MEDIASUBTYPE_RTP_Payload_G711U)) {
			return NOERROR;
		} 
		if ((((WAVEFORMATEX *)mtIn->Format())->wFormatTag ==
						WAVE_FORMAT_ALAW) && 
			(*mtOut->Subtype() == MEDIASUBTYPE_RTP_Payload_G711A)) {
			return NOERROR;
		} 
#if 0
		if ((((WAVEFORMATEX *)mtIn->Format())->wFormatTag ==
						WAVE_FORMAT_G723) && 
			(*mtOut->Subtype() == MEDIASUBTYPE_RTP_Payload_G723)) {
			return NOERROR;
		} 
#endif
	}
	//Check all supported minor types
	if ((*mtIn->Subtype() == MEDIASUBTYPE_MULAWAudio) && 
		(*mtOut->Subtype() == MEDIASUBTYPE_RTP_Payload_G711U)) {
		return NOERROR;
	} 
	if ((*mtIn->Subtype() == MEDIASUBTYPE_ALAWAudio) && 
		(*mtOut->Subtype() == MEDIASUBTYPE_RTP_Payload_G711A)) {
		return NOERROR;
	} 
	if ((*mtIn->Subtype() == MEDIASUBTYPE_G723Audio) && 
		(*mtOut->Subtype() == MEDIASUBTYPE_RTP_Payload_G723)) {
		return NOERROR;
	} 

    return E_FAIL;

} // CheckTransform


// CheckConnect
// This function is overridden so that we can set the type of the output pin
//
HRESULT CSPHAUD::CompleteConnect(PIN_DIRECTION dir,IPin *pPin)
{
	const GUID mtguid = MEDIATYPE_RTP_Single_Stream;
	const GUID pt711guid = MEDIASUBTYPE_RTP_Payload_G711U;
	const GUID pt711aguid = MEDIASUBTYPE_RTP_Payload_G711A;
	const GUID pt723guid = MEDIASUBTYPE_RTP_Payload_G723;

	DbgLog((LOG_TRACE,4,TEXT("CSPHAUD::CompleteConnect")));

	if (dir == PINDIR_INPUT) {
		CMediaType mtOut(&mtguid);

		//We're going to set our own output pin media type
		mtOut.SetVariableSize();
		if (m_PPMCLSIDType == CLSID_G711PPMSend) { //G711 mulaw
			mtOut.SetSubtype(&pt711guid);
		} else if (m_PPMCLSIDType == CLSID_G711APPMSend) {  //G711 alaw
			mtOut.SetSubtype(&pt711aguid);
		} else { //G723
#if 0 //def SETG723LICENSE
// This implementation does not allow other codecs to be used!! MIKECL
			PIN_INFO OutputPinInfo;
			HRESULT hr;
			//get the upstream filter's output pin info structure
			hr = pPin->QueryPinInfo(&OutputPinInfo);
			if (FAILED(hr)) 
				return E_FAIL;

			ICodecLicense *pLicIF = NULL;

			//query the filter interface for its license interface
			
			hr = OutputPinInfo.pFilter->QueryInterface(IID_ICodecLicense, (void **) &pLicIF);
            OutputPinInfo.pFilter->Release();
			if (FAILED(hr)) {
				DbgLog((LOG_ERROR,1,TEXT("CompleteConnect::Couldn't get IID_ICodecLicense"))); 
				return E_FAIL;
			}
			DWORD dword0 = G723KEY_PSword0;
			DWORD dword1 = G723KEY_PSword1;
			hr = pLicIF->put_LicenseKey(dword0,dword1);
			if (FAILED(hr)) {
				DbgLog((LOG_ERROR,1,TEXT("CompleteConnect::Couldn't set license"))); 
				if (pLicIF) pLicIF->Release(); pLicIF = NULL;
				return E_FAIL;
			}
			if (pLicIF) pLicIF->Release(); pLicIF = NULL;

#endif
			mtOut.SetSubtype(&pt723guid);
		}
		m_pOutput->SetMediaType(&mtOut);

		return NOERROR;

	} else {
		return NOERROR;
	}
}

// SetPPMSession
// This function is where PPM::SetSession is called and may be specific to payload
//  handler.  Minimum function is to set the payload type.
HRESULT CSPHAUD::SetPPMSession() 
{
	HRESULT hr;
	if (m_pPPMSession) {
		hr = m_pPPMSession->SetPayloadType((unsigned char)m_PayloadType);
		return hr;
	} else {
		return E_FAIL;
	}
}

// CPersistStream methods

// ReadFromStream
// This is the call that will read persistent data from file
//
HRESULT CSPHAUD::ReadFromStream(IStream *pStream) 
{ 
	DbgLog((LOG_TRACE, 4, TEXT("CSPHAUD::ReadFromStream")));
    if (mPS_dwFileVersion != 1) {
		DbgLog((LOG_ERROR, 2, 
				TEXT("CSPHAUD::ReadFromStream: Incompatible stream format")));
		return E_FAIL;
	}
	
	return CSPHBase::ReadFromStream(pStream);

}

// GetClassID
// This function returns my CLSID  
//  
HRESULT _stdcall CSPHAUD::GetClassID(CLSID *pCLSID) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CSPHAUD::GetClassID")));
	
	if (!pCLSID)
		return E_POINTER;
	*pCLSID = CLSID_INTEL_SPHAUD;
	return NOERROR; 
}

// GetSoftwareVersion
// This returns the version of this filter to be stored with the persistent data
//
DWORD CSPHAUD::GetSoftwareVersion(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CSPHAUD::GetSoftwareVersion")));
	
	return 1; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphh26x\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphgenv\genvprop.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : GENVProp.h
// Purpose  : Define the class that implements the RTP SPH
//            Generic Video filter property page.
// Contents : 
//      class CSPHGENVPropertyPage
//*M*/

#ifndef _SPH_GENVPROP_H_
#define _SPH_GENVPROP_H_

//----------------------------------------------------------------------------
// RTP/RTCP: Registry information under:
//				HKEY_LOCAL_MACHINE\SOFTWARE\INTEL\ActiveMovie_Filters
//----------------------------------------------------------------------------
#define szRegAMRTPKey				TEXT("SOFTWARE\\Intel\\ActiveMovie Filters")


// Property Page Class for Generic Audio
class 
CSPHGENVPropertyPage 
: public CBasePropertyPage
{
	
public:
    static CUnknown * WINAPI CreateInstance( LPUNKNOWN punk, HRESULT *phr );

protected:
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate () ;
	HRESULT	OnDeactivate ();
    HRESULT OnApplyChanges();

    CSPHGENVPropertyPage( LPUNKNOWN punk, HRESULT *phr);

    BOOL OnInitDialog( void );
    BOOL OnCommand( int iButton, int iNotify, LPARAM lParam );

    void SetDirty();

protected:
	IRTPSPHFilter	*m_pIRTPSPHFilter;
    BOOL m_bIsInitialized;  // Will be false while we set init values in Dlg
	GUID			*m_pGuidVal;
	int				m_nActiveItems;
	BOOL			m_bMinorTypeScanned;
};

#endif _GENVPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphgena\sphgena.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : sphgena.h
// Purpose  : Define the class that implements the RTP SPH Generic Audio filter.
// Contents : 
//*M*/


#ifndef _SPHGENA_H_
#define _SPHGENA_H_

#include <sph.h>

#define DEFAULT_PACKET_SIZE_SPHGENA 1450
#define DEFAULT_PACKETBUF_NUM_SPHGENA 2 // HUGEMEMORY 128->2

class CSPHGENA : public CSPHBase
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    DECLARE_IUNKNOWN;

    virtual HRESULT CheckInputType(const CMediaType *mtIn);
    virtual HRESULT CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut);
	virtual HRESULT CompleteConnect(PIN_DIRECTION dir,IPin *pPin);
	virtual CBasePin *GetPin(int n);
    virtual STDMETHODIMP SetOutputPinMinorType(GUID gMinorType);
    virtual STDMETHODIMP GetOutputPinMinorType(GUID *lpgMinorType);
    virtual STDMETHODIMP SetInputPinMediaType(AM_MEDIA_TYPE *lpMediaPinType);
    virtual STDMETHODIMP GetInputPinMediaType(AM_MEDIA_TYPE **ppMediaPinType);
	virtual STDMETHODIMP GetInputPinMediaType(int iPosition, CMediaType *pMediaType);


	virtual HRESULT ReadFromStream(IStream *pStream);
	virtual HRESULT WriteToStream(IStream *pStream);
	virtual int SizeMax(void);
	virtual HRESULT _stdcall GetClassID(CLSID *pCLSID);
	virtual DWORD GetSoftwareVersion(void);

    // Setup helper
    virtual LPAMOVIESETUP_FILTER GetSetupData();

private:

    // Constructor
    CSPHGENA(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);
	~CSPHGENA();

	virtual HRESULT SetPPMSession();

	GUID m_gMinorType;
	CMediaType *m_lpMediaIPinType;

}; // CSPHGENA


#endif // _SPHGENA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphgena\sphgena.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : sphgena.cpp
// Purpose  : RTP SPH Generic Audio filter implementation.
// Contents : 
//*M*/

#include <winsock2.h>
#include <streams.h>
#if !defined(SPH_IN_DXMRTP)
#include <initguid.h>
#define INITGUID
#endif
#include <ippm.h>
#include <amrtpuid.h>
#include <auduids.h>
#include <mmreg.h>
#include <sphgena.h>
#include <sphgipin.h>
#include <ppmclsid.h>
#include <memory.h>
#include <mmreg.h>
#include <sphprop.h>
#include "genaprop.h"

#include "template.h"

// setup data

static const CLSID *pPropertyPageClsids[] =
{
    &CLSID_INTEL_SPHGENA_PROPPAGE,
	&CLSID_INTEL_SPHGENA_PIN_PROPPAGE
};

#define NUMPROPERTYPAGES \
    (sizeof(pPropertyPageClsids)/sizeof(pPropertyPageClsids[0]))

static AMOVIESETUP_MEDIATYPE sudOutputPinTypes[] =
{
	{
		&MEDIATYPE_RTP_Single_Stream,       // Major type
		&MEDIASUBTYPE_NULL			        // Minor type
	}
};

static AMOVIESETUP_MEDIATYPE sudInputPinTypes[] =
{
	{
		&MEDIATYPE_Audio,        // Major type
		&MEDIASUBTYPE_NULL       // Minor type
	}
};

static AMOVIESETUP_PIN psudPins[] =
{
    {
        L"Input",           // String pin name
        FALSE,              // Is it rendered
        FALSE,              // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Output",          // Connects to pin
        1,                  // Number of types
        (AMOVIESETUP_MEDIATYPE *)&sudInputPinTypes },// The pin details
      { L"Output",          // String pin name
        FALSE,              // Is it rendered
        TRUE,               // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Input",           // Connects to pin
        1,                  // Number of types
        (AMOVIESETUP_MEDIATYPE *)&sudOutputPinTypes  // The pin details
    }
};


AMOVIESETUP_FILTER sudSPHGENA =
{
    &CLSID_INTEL_SPHGENA,   // Filter CLSID
    L"Intel RTP SPH for Generic Audio", // Filter name
    MERIT_DO_NOT_USE,       // Its merit
    2,                      // Number of pins
    psudPins                // Pin details
};


// List of class IDs and creator functions for the class factory. This
// provides the link between the OLE entry point in the DLL and an object
// being created. The class factory will call the static CreateInstance

#if !defined(SPH_IN_DXMRTP)
CFactoryTemplate g_Templates[] = {
	CFT_SPHGENA_ALL_FILTERS
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif

//
// Constructor
//
CSPHGENA::CSPHGENA(TCHAR *tszName,LPUNKNOWN punk,HRESULT *phr) :
	CSPHBase(tszName, punk, phr, CLSID_INTEL_SPHGENA,
			 DEFAULT_PACKETBUF_NUM_SPHGENA,
			 DEFAULT_PACKET_SIZE_SPHGENA,
			 NUMPROPERTYPAGES,
			 pPropertyPageClsids)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CSPHGENA::")));

    ASSERT(tszName);
    ASSERT(phr);
	m_gMinorType = MEDIASUBTYPE_NULL;
	m_PPMCLSIDType = CLSID_GEN_A_PPMSend;
	m_lpMediaIPinType = NULL;

} // CSPHGENA

//
// Destructor
//
CSPHGENA::~CSPHGENA()
{
	
	DbgLog((LOG_TRACE,4,TEXT("CSPHGENA::~")));

	if (m_lpMediaIPinType) delete m_lpMediaIPinType;

} // CSPHGENA


//
// CreateInstance
//
// Provide the way for COM to create a CSPHGENA object
//
CUnknown *CSPHGENA::CreateInstance(LPUNKNOWN punk, HRESULT *phr) {

	DbgLog((LOG_TRACE,4,TEXT("CSPHGENA::CreateInstance")));

    CSPHGENA *pNewObject = new CSPHGENA(NAME("Intel RTP Send Payload Handler for Generic Audio"), punk, phr);
    if (pNewObject == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return pNewObject;

} // CreateInstance


//
// GetSetupData
//
// Returns registry information for this filter
//
LPAMOVIESETUP_FILTER CSPHGENA::GetSetupData()
{
    return &sudSPHGENA;

} // GetSetupData


// Notes from CTransformFilter::GetPin:
// return a non-addrefed CBasePin * for the user to addref if he holds onto it
// for longer than his pointer to us. We create the pins dynamically when they
// are asked for rather than in the constructor. This is because we want to
// give the derived class an oppportunity to return different pin objects

// We return the objects as and when they are needed. If either of these fails
// then we return NULL, the assumption being that the caller will realise the
// whole deal is off and destroy us - which in turn will delete everything.

CBasePin *
CSPHGENA::GetPin(int n)
{
    HRESULT hr = S_OK;

    // Create an input pin if necessary

    if (m_pInput == NULL) {

        m_pInput = new CSPHGENIPin(NAME("Transform input pin"),
                                          this,              // Owner filter
                                          &hr,               // Result code
                                          L"XForm In");      // Pin name


        //  Can't fail
        ASSERT(SUCCEEDED(hr));
        if (m_pInput == NULL) {
            return NULL;
        }
        m_pOutput = (CTransformOutputPin *)
		   new CTransformOutputPin(NAME("Transform output pin"),
                                            this,            // Owner filter
                                            &hr,             // Result code
                                            L"XForm Out");   // Pin name


        // Can't fail
        ASSERT(SUCCEEDED(hr));
        if (m_pOutput == NULL) {
            delete m_pInput;
            m_pInput = NULL;
        }
    }

    // Return the appropriate pin

    if (n == 0) {
        return m_pInput;
    } else
    if (n == 1) {
        return m_pOutput;
    } else {
        return NULL;
    }
}

//
// GetInputPinMediaType
//
//  The generic filters use this to control the media type
//  of the input pin, based on SetInputPinMediaType.
//
HRESULT CSPHGENA::GetInputPinMediaType(int iPosition, CMediaType *pMediaType)
{
	DbgLog((LOG_TRACE,4,TEXT("CSPHGENA::GetInputPinMediaType")));

    // Is the input pin connected

    if (m_pInput->IsConnected() == FALSE) {
        return E_UNEXPECTED;
    }

    // This should never happen

    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    // Do we have more items to offer

    if (iPosition > 0) {
        return VFW_S_NO_MORE_ITEMS;
    }

	if (m_lpMediaIPinType)
		*pMediaType = *m_lpMediaIPinType;
	else {
		const GUID gMajorType = MEDIATYPE_Video;
		m_lpMediaIPinType = new CMediaType(&gMajorType);
		if (m_lpMediaIPinType) {
			*pMediaType = *m_lpMediaIPinType;
			m_lpMediaIPinType = NULL;
		} else {
			return E_OUTOFMEMORY;
		}
	}

    return NOERROR;
}

//
// CheckInputType
//
// Check the input type is OK, return an error otherwise
//
HRESULT CSPHGENA::CheckInputType(const CMediaType *mtIn)
{

	DbgLog((LOG_TRACE,4,TEXT("CSPHGENA::CheckInputType")));


	if (m_lpMediaIPinType) {
		if (m_lpMediaIPinType == mtIn)
			return NOERROR;
		else
			return E_FAIL;
	}

	//Check major type first
    if (*mtIn->Type() == MEDIATYPE_Audio) {
		return NOERROR;
	}

	//We don't support this major type
    return E_FAIL;

} // CheckInputType


//
// CheckTransform
//
// To be able to transform the formats must be identical
//
HRESULT CSPHGENA::CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut)
{

	DbgLog((LOG_TRACE,4,TEXT("CSPHGENA::CheckTransform")));

	//Check user set type
	if (m_lpMediaIPinType) {
		if ((m_lpMediaIPinType == mtIn) &&
			(*mtOut->Subtype() == m_gMinorType))
			return NOERROR;
		else
			return E_FAIL;
	}

	//Check all supported minor types
	if ((*mtIn->Type() == MEDIATYPE_Audio) && 
		(*mtOut->Subtype() == m_gMinorType)) {
		return NOERROR;
	} 
    return E_FAIL;

} // CheckTransform


// CheckConnect
// This function is overridden so that we can set the type of the output pin
//
HRESULT CSPHGENA::CompleteConnect(PIN_DIRECTION dir,IPin *pPin)
{
	const GUID mtguid = MEDIATYPE_RTP_Single_Stream;

	DbgLog((LOG_TRACE,4,TEXT("CSPHGENA::CompleteConnect")));

	if (dir == PINDIR_INPUT) {
		CMediaType mtOut(&mtguid);

		//We're going to set our own output pin media type
		mtOut.SetVariableSize();

		mtOut.SetSubtype(&m_gMinorType);

		m_pOutput->SetMediaType(&mtOut);


	} 
	return NOERROR;
}

// SetPPMSession
// This function is where PPM::SetSession is called and may be specific to payload
//  handler.  Minimum function is to set the payload type.
HRESULT CSPHGENA::SetPPMSession() 
{
	HRESULT hr;
	if (m_pPPMSession) {
		hr = m_pPPMSession->SetPayloadType((unsigned char)m_PayloadType);
		return hr;
	} else {
		return E_FAIL;
	}
}

// SetOutputPinMinorType
// Sets the type of the output pin
// Needs to be called before CheckTransform to be useful
// We don't expect to get called for this in other than the generic filters
//
HRESULT CSPHGENA::SetOutputPinMinorType(GUID gMinorType)
{
	DbgLog((LOG_TRACE,4,TEXT("CSPHGENA::SetOutputPinMinorType")));

    CAutoLock l(&m_cStateLock);

    if (!m_pOutput) return E_FAIL;

    if (m_pOutput->IsConnected() == TRUE) { 
        return VFW_E_ALREADY_CONNECTED;
    }

#if 0
	if (!((gMinorType == MEDIASUBTYPE_RTP_Payload_G711U) ||
	(gMinorType == MEDIASUBTYPE_RTP_Payload_G711A) ||
	(gMinorType == MEDIASUBTYPE_RTP_Payload_G723))) {
		return VFW_E_INVALIDSUBTYPE;
	}
#endif

    SetDirty(TRUE); // So that our state will be saved if we are in a .grf    

	m_gMinorType = gMinorType;

	const GUID mtguid = MEDIATYPE_RTP_Single_Stream;

	CMediaType mtOut(&mtguid);

	//We're going to set our own output pin media type
	mtOut.SetVariableSize();

	mtOut.SetSubtype(&m_gMinorType);

	// m_pOutput->SetMediaType(&mtOut);

	return NOERROR;
}

// GetOutputPinMinorType
// Gets the type of the output pin
// We don't expect to get called for this in other than the generic filters
//
HRESULT CSPHGENA::GetOutputPinMinorType(GUID *lpgMinorType)
{
    CAutoLock l(&m_cStateLock);

	if (!lpgMinorType) return E_POINTER;

	*lpgMinorType = m_gMinorType;
	return NOERROR;
}

// SetInputPinMediaType
// Sets the type of the input pin
// Needs to be called before CBasePin::GetMediaType to be useful
// We don't expect to get called for this in other than the generic filters
//
HRESULT CSPHGENA::SetInputPinMediaType(AM_MEDIA_TYPE *pMediaPinType)
{
	DbgLog((LOG_TRACE,4,TEXT("CSPHGENA::SetInputPinMediaType")));

    CAutoLock l(&m_cStateLock);

    if (m_pInput->IsConnected() == TRUE) {
        return VFW_E_ALREADY_CONNECTED;
    }

    SetDirty(TRUE); // So that our state will be saved if we are in a .grf 
	
	m_lpMediaIPinType = new CMediaType(*pMediaPinType);

	if (!m_lpMediaIPinType) 
		return E_OUTOFMEMORY;
		
	return NOERROR;
}

// GetInputPinMediaType
// Gets the type of the input pin
// We don't expect to get called for this in other than the generic filters
//
HRESULT CSPHGENA::GetInputPinMediaType(AM_MEDIA_TYPE **ppMediaPinType)
{
    CAutoLock l(&m_cStateLock);

	AM_MEDIA_TYPE *pMediaPinType = NULL;
	DbgLog((LOG_TRACE,4,TEXT("CSPHGENA::GetOutputPinMediaType")));

	if (!ppMediaPinType) return E_POINTER;

	if (!(pMediaPinType = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE)))) 
		return E_OUTOFMEMORY;

	CopyMemory((void*)pMediaPinType, (void*)((AM_MEDIA_TYPE *)&m_lpMediaIPinType),
		sizeof(AM_MEDIA_TYPE));
	
	if (!(pMediaPinType->pbFormat = (UCHAR *)CoTaskMemAlloc(m_lpMediaIPinType->cbFormat))) {
		CoTaskMemFree(pMediaPinType);
		return E_OUTOFMEMORY;
	}

	CopyMemory((void*)pMediaPinType->pbFormat, (void*)m_lpMediaIPinType->pbFormat,
		m_lpMediaIPinType->cbFormat);

	*ppMediaPinType = pMediaPinType;
	return NOERROR;
}

// CPersistStream methods

// ReadFromStream
// This is the call that will read persistent data from file
//
HRESULT CSPHGENA::ReadFromStream(IStream *pStream) 
{ 
	DbgLog((LOG_TRACE, 4, 
			TEXT("CSPHGENA::ReadFromStream")));
    if (mPS_dwFileVersion != 1) {
		DbgLog((LOG_ERROR, 2, 
				TEXT("CSPHGENA::ReadFromStream: Incompatible stream format")));
		return E_FAIL;
	}
	HRESULT hr;
	
	ULONG uBytesRead;

	hr = CSPHBase::ReadFromStream(pStream);
	if (FAILED(hr)) return hr;

    DbgLog((LOG_TRACE, 4, 
            TEXT("CSPHGENA::ReadFromStream: Loading media subtype")));

    GUID gMediaSubtype;

    hr = pStream->Read(&gMediaSubtype, sizeof(GUID), &uBytesRead);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CSPHGENA::ReadFromStream: Error 0x%08x reading media subtype"),
                hr));
        return hr;
    } else if (uBytesRead != sizeof(GUID)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CSPHGENA::ReadFromStream: Mismatch in (%d/%d) bytes read for media subtype"),
                uBytesRead, sizeof(GUID)));
        return E_INVALIDARG;
    } 

	// ZCS 6-30-97: My surgery in this section is all intended to allow the output
	// pin media type to be set when the graph is loaded from a file. None of this
	// should be attempted if the output pin type is GUID_NULL, because the code
	// below assumes that the filter will later be connected as part of the load-
	// from-file procedure. A non-GUID_NULL value can only occur if the filter
	// was connected when it was saved.

	if (gMediaSubtype != GUID_NULL)
	{
    	DbgLog((LOG_TRACE, 3, 
				TEXT("CSPHGENA::ReadFromStream: Restoring media subtype")));

		// ZCS 6-30-97: at this point we don't have any pins, so we can't set the output pin media type
		// just yet. Must first call GetPin(). Subsequent calls to GetPin() will be ok because it
		// doesn't allocate more pins as long as the original input and output pins are still there.
		EXECUTE_ASSERT(GetPin(0) != NULL);
	
		// ZCS 6-30-97:
		// In order for SetOutputPinMinorType() to succeed, the input pin must
		// have a major type that isn't GUID_NULL. This is a bit of subterfuge
		// to pretend we have an input pin major type -- the type doesn't matter as
		// long as it isn't GUID_NULL. We'll undo this shortly.
	
		GUID gTemp = MEDIATYPE_RTP_Single_Stream;
		m_pInput->CurrentMediaType().SetType(&gTemp);
		
		hr = SetOutputPinMinorType(gMediaSubtype);

		// ZCS: we don't really have an input major type, so undo what we did...
		gTemp = GUID_NULL;
		m_pInput->CurrentMediaType().SetType(&gTemp);
		
		// now check if SetOutputPinMinorType failed
	    if (FAILED(hr)) {
	        DbgLog((LOG_ERROR, 2, 
	                TEXT("CSPHGENA::ReadFromStream: Error 0x%08x setting media subtype"),
	                hr));
		
			return hr;
	    } 
	}

	return NOERROR; 
}

// WriteToStream
// This is the call that will write persistent data to file
//
HRESULT CSPHGENA::WriteToStream(IStream *pStream) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENA::WriteToStream")));
	
	HRESULT hr;
    ULONG uBytesWritten = 0;

	hr = CSPHBase::WriteToStream(pStream);
	if (FAILED(hr)) return hr;

    DbgLog((LOG_TRACE, 4, 
            TEXT("CSPHGENA::WriteToStream: Writing media subtype")));

	hr = pStream->Write(&m_gMinorType, sizeof(GUID), &uBytesWritten);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CSPHGENA::WriteToStream: Error 0x%08x reading media subtype"),
                hr));
        return hr;
    } else if (uBytesWritten != sizeof(GUID)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CSPHGENA::WriteToStream: Mismatch in (%d/%d) bytes read for media subtype"),
                uBytesWritten, sizeof(GUID)));
        return E_INVALIDARG;
    } 

	return NOERROR; 
}

// SizeMax
// This returns the amount of storage space required for my persistent data
//
int CSPHGENA::SizeMax(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENA::SizeMax")));
	
	return CSPHBase::SizeMax()
        + sizeof(GUID); 
}

// GetClassID
// This function returns my CLSID  
//  
HRESULT _stdcall CSPHGENA::GetClassID(CLSID *pCLSID) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENA::GetClassID")));
	
	if (!pCLSID)
		return E_POINTER;
	*pCLSID = CLSID_INTEL_SPHGENA;
	return NOERROR; 
}

// GetSoftwareVersion
// This returns the version of this filter to be stored with the persistent data
//
DWORD CSPHGENA::GetSoftwareVersion(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENA::GetSoftwareVersion")));
	
	return 1; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphgenv\sphgenv.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : sphgenv.cpp
// Purpose  : RTP SPH Generic Video filter implementation.
// Contents : 
//*M*/

#if !defined(NO_GENERIC_VIDEO)
#include <winsock2.h>
#include <streams.h>
#if !defined(SPH_IN_DXMRTP)
#include <initguid.h>
#define INITGUID
#endif
#include <ippm.h>
#include <amrtpuid.h>
#include <sphgenv.h>
#include <sphgipin.h>
#include <ppmclsid.h>
#include <memory.h>
#include <sphprop.h>
#include "genvprop.h"

#include "template.h"

// setup data

static const CLSID *pPropertyPageClsids[] =
{
    &CLSID_INTEL_SPHGENV_PROPPAGE,
	&CLSID_INTEL_SPHGENV_PIN_PROPPAGE
};

#define NUMPROPERTYPAGES \
    (sizeof(pPropertyPageClsids)/sizeof(pPropertyPageClsids[0]))

static AMOVIESETUP_MEDIATYPE sudOutputPinTypes[] =
{
	{
		&MEDIATYPE_RTP_Single_Stream,       // Major type
		&MEDIASUBTYPE_NULL			        // Minor type
	}
};

static AMOVIESETUP_MEDIATYPE sudInputPinTypes[] =
{
	{
		&MEDIATYPE_Video,       // Major type
		&MEDIASUBTYPE_NULL      // Minor type
	}
};

static AMOVIESETUP_PIN psudPins[] =
{
    {
        L"Input",           // String pin name
        FALSE,              // Is it rendered
        FALSE,              // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Output",          // Connects to pin
        1,                  // Number of types
        (AMOVIESETUP_MEDIATYPE *)&sudInputPinTypes },// The pin details
      { L"Output",          // String pin name
        FALSE,              // Is it rendered
        TRUE,               // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Input",           // Connects to pin
        1,                  // Number of types
        (AMOVIESETUP_MEDIATYPE *)&sudOutputPinTypes  // The pin details
    }
};


AMOVIESETUP_FILTER sudSPHGENV =
{
    &CLSID_INTEL_SPHGENV,   // Filter CLSID
    L"Intel RTP SPH for Generic Video", // Filter name
    MERIT_DO_NOT_USE,       // Its merit
    2,                      // Number of pins
    psudPins                // Pin details
};


// List of class IDs and creator functions for the class factory. This
// provides the link between the OLE entry point in the DLL and an object
// being created. The class factory will call the static CreateInstance

#if !defined(SPH_IN_DXMRTP)
CFactoryTemplate g_Templates[] = {
	CFT_SPHGENV_ALL_FILTERS
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif

//
// Constructor
//
CSPHGENV::CSPHGENV(TCHAR *tszName,LPUNKNOWN punk,HRESULT *phr) :
	CSPHBase(tszName, punk, phr, CLSID_INTEL_SPHGENV,
			 DEFAULT_PACKETBUF_NUM_SPHGENV,
			 DEFAULT_PACKET_SIZE_SPHGENV,
			 NUMPROPERTYPAGES,
			 pPropertyPageClsids)
{
	DbgLog((LOG_TRACE,4,TEXT("CSPHGENV::")));

    ASSERT(tszName);
    ASSERT(phr);
	m_gMinorType = MEDIASUBTYPE_NULL;
	m_PPMCLSIDType = CLSID_GenPPMSend;
	m_lpMediaIPinType = NULL;

} // SPHGENV

//
// Destructor
//
CSPHGENV::~CSPHGENV()
{
	
	DbgLog((LOG_TRACE,4,TEXT("CSPHGENV::~")));

	if (m_lpMediaIPinType) delete m_lpMediaIPinType;

} // CSPHGENA


//
// CreateInstance
//
// Provide the way for COM to create a CSPHGENV object
//
CUnknown *CSPHGENV::CreateInstance(LPUNKNOWN punk, HRESULT *phr) {

	DbgLog((LOG_TRACE,4,TEXT("CSPHGENV::CreateInstance")));

    CSPHGENV *pNewObject = new CSPHGENV(NAME("Intel RTP Send Payload Handler for Generic Video"), punk, phr);
    if (pNewObject == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return pNewObject;

} // CreateInstance


//
// GetSetupData
//
// Returns registry information for this filter
//
LPAMOVIESETUP_FILTER CSPHGENV::GetSetupData()
{
    return &sudSPHGENV;

} // GetSetupData

// Notes from CTransformFilter::GetPin:
// return a non-addrefed CBasePin * for the user to addref if he holds onto it
// for longer than his pointer to us. We create the pins dynamically when they
// are asked for rather than in the constructor. This is because we want to
// give the derived class an oppportunity to return different pin objects

// We return the objects as and when they are needed. If either of these fails
// then we return NULL, the assumption being that the caller will realise the
// whole deal is off and destroy us - which in turn will delete everything.

CBasePin *
CSPHGENV::GetPin(int n)
{
    HRESULT hr = S_OK;

    // Create an input pin if necessary

    if (m_pInput == NULL) {

        m_pInput = new CSPHGENIPin(NAME("Transform input pin"),
                                          this,              // Owner filter
                                          &hr,               // Result code
                                          L"XForm In");      // Pin name


        //  Can't fail
        ASSERT(SUCCEEDED(hr));
        if (m_pInput == NULL) {
            return NULL;
        }
        m_pOutput = (CTransformOutputPin *)
		   new CTransformOutputPin(NAME("Transform output pin"),
                                            this,            // Owner filter
                                            &hr,             // Result code
                                            L"XForm Out");   // Pin name


        // Can't fail
        ASSERT(SUCCEEDED(hr));
        if (m_pOutput == NULL) {
            delete m_pInput;
            m_pInput = NULL;
        }
    }

    // Return the appropriate pin

    if (n == 0) {
        return m_pInput;
    } else
    if (n == 1) {
        return m_pOutput;
    } else {
        return NULL;
    }
}

//
// GetInputPinMediaType
//
//  The generic filters use this to control the media type
//  of the input pin, based on SetInputPinMediaType.
//
HRESULT CSPHGENV::GetInputPinMediaType(int iPosition, CMediaType *pMediaType)
{
	DbgLog((LOG_TRACE,4,TEXT("CSPHGENV::GetInputPinMediaType")));

    // Is the input pin connected

    if (m_pInput->IsConnected() == FALSE) {
        return E_UNEXPECTED;
    }

    // This should never happen

    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    // Do we have more items to offer

    if (iPosition > 0) {
        return VFW_S_NO_MORE_ITEMS;
    }

	if (m_lpMediaIPinType)
		*pMediaType = *m_lpMediaIPinType;
	else {
		const GUID gMajorType = MEDIATYPE_Video;
		m_lpMediaIPinType = new CMediaType(&gMajorType);
		if (m_lpMediaIPinType) {
			*pMediaType = *m_lpMediaIPinType;
			m_lpMediaIPinType = NULL;
		} else {
			return E_OUTOFMEMORY;
		}
	}

    return NOERROR;
}


//
// CheckInputType
//
// Check the input type is OK, return an error otherwise
//
HRESULT CSPHGENV::CheckInputType(const CMediaType *mtIn)
{

	DbgLog((LOG_TRACE,4,TEXT("CSPHGENV::CheckInputType")));


	if (m_lpMediaIPinType) {
		if (m_lpMediaIPinType == mtIn)
			return NOERROR;
		else
			return E_FAIL;
	}

	//Check major type first
    if (*mtIn->Type() == MEDIATYPE_Video) {
		return NOERROR;
	}

	//We don't support this major type
    return E_FAIL;

} // CheckInputType


//
// CheckTransform
//
// To be able to transform the formats must be identical
//
HRESULT CSPHGENV::CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CSPHGENV::CheckTransform")));

	//Check user set type
	if (m_lpMediaIPinType) {
		if ((m_lpMediaIPinType == mtIn) &&
			(*mtOut->Subtype() == m_gMinorType))
			return NOERROR;
		else
			return E_FAIL;
	}

	//Check all supported minor types
	if ((*mtIn->Type() == MEDIATYPE_Video) && 
		(*mtOut->Subtype() == m_gMinorType)) {
		return NOERROR;
	} 
    return E_FAIL;

} // CheckTransform


// CheckConnect
// This function is overridden so that the RTP support interface from the codec
//   can be retrieved and the extended bitstream generation turned on
//
HRESULT CSPHGENV::CompleteConnect(PIN_DIRECTION dir,IPin *pPin)
{
	const GUID mtguid = MEDIATYPE_RTP_Single_Stream;

	DbgLog((LOG_TRACE,4,TEXT("CSPHGENV::CompleteConnect")));

	if (dir == PINDIR_INPUT) {
		CMediaType mtOut(&mtguid);

		//We're going to set our own output pin media type
		mtOut.SetVariableSize();

		mtOut.SetSubtype(&m_gMinorType);

		m_pOutput->SetMediaType(&mtOut);


	} 
	return NOERROR;
}

// SetPPMSession
// This function is where PPM::SetSession is called and may be specific to payload
//  handler.  Minimum function is to set the payload type.
HRESULT CSPHGENV::SetPPMSession() 
{
	HRESULT hr;
	if (m_pPPMSession) {
		hr = m_pPPMSession->SetPayloadType(m_PayloadType);
		return hr;
	} else {
		return E_FAIL;
	}
}

// SetOutputPinMinorType
// Sets the type of the output pin
// Needs to be called before CheckTransform to be useful
// We don't expect to get called for this in other than the generic filters
//
HRESULT CSPHGENV::SetOutputPinMinorType(GUID gMinorType)
{
	DbgLog((LOG_TRACE,4,TEXT("CSPHGENV::SetOutputPinMinorType")));

    CAutoLock l(&m_cStateLock);

	if (!m_pOutput) return E_FAIL;

	if (m_pOutput->IsConnected() == TRUE) {
        return VFW_E_ALREADY_CONNECTED;
    }

#if 0
	if (!((gMinorType == MEDIASUBTYPE_RTP_Payload_H261) ||
	(gMinorType == MEDIASUBTYPE_RTP_Payload_H263))) {
		return VFW_E_INVALIDSUBTYPE;
	}
#endif

    SetDirty(TRUE); // So that our state will be saved if we are in a .grf    

	m_gMinorType = gMinorType;

	const GUID mtguid = MEDIATYPE_RTP_Single_Stream;

	CMediaType mtOut(&mtguid);

	//We're going to set our own output pin media type
	mtOut.SetVariableSize();

	mtOut.SetSubtype(&m_gMinorType);

	return NOERROR;
}

// GetOutputPinMinorType
// Gets the type of the output pin
// We don't expect to get called for this in other than the generic filters
//
HRESULT CSPHGENV::GetOutputPinMinorType(GUID *lpgMinorType)
{
    CAutoLock l(&m_cStateLock);

	if (!lpgMinorType) return E_POINTER;

	*lpgMinorType = m_gMinorType;
	return NOERROR;
}

// SetInputPinMediaType
// Sets the type of the input pin
// Needs to be called before CBasePin::GetMediaType to be useful
// We don't expect to get called for this in other than the generic filters
//
HRESULT CSPHGENV::SetInputPinMediaType(AM_MEDIA_TYPE *pMediaPinType)
{
	DbgLog((LOG_TRACE,4,TEXT("CSPHGENV::SetInputPinMediaType")));

    CAutoLock l(&m_cStateLock);

    if (m_pInput->IsConnected() == TRUE) {
        return VFW_E_ALREADY_CONNECTED;
    }

    SetDirty(TRUE); // So that our state will be saved if we are in a .grf 
	
	m_lpMediaIPinType = new CMediaType(*pMediaPinType);

	if (!m_lpMediaIPinType) 
		return E_OUTOFMEMORY;
		
	return NOERROR;
}

// GetInputPinMediaType
// Gets the type of the input pin
// We don't expect to get called for this in other than the generic filters
//
HRESULT CSPHGENV::GetInputPinMediaType(AM_MEDIA_TYPE **ppMediaPinType)
{
    CAutoLock l(&m_cStateLock);

	AM_MEDIA_TYPE *pMediaPinType = NULL;
	DbgLog((LOG_TRACE,4,TEXT("CSPHGENV::GetOutputPinMediaType")));

	if (!ppMediaPinType) return E_POINTER;

	if (!(pMediaPinType = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE)))) 
		return E_OUTOFMEMORY;

	CopyMemory((void*)pMediaPinType, (void*)((AM_MEDIA_TYPE *)&m_lpMediaIPinType),
		sizeof(AM_MEDIA_TYPE));
	
	if (!(pMediaPinType->pbFormat = (UCHAR *)CoTaskMemAlloc(m_lpMediaIPinType->cbFormat))) {
		CoTaskMemFree(pMediaPinType);
		return E_OUTOFMEMORY;
	}

	CopyMemory((void*)pMediaPinType->pbFormat, (void*)m_lpMediaIPinType->pbFormat,
		m_lpMediaIPinType->cbFormat);

	*ppMediaPinType = pMediaPinType;
	return NOERROR;
}

// CPersistStream methods

// ReadFromStream
// This is the call that will read persistent data from file
//
HRESULT CSPHGENV::ReadFromStream(IStream *pStream) 
{ 
	DbgLog((LOG_TRACE, 4, TEXT("CSPHGENV::ReadFromStream")));
    if (mPS_dwFileVersion != 1) {
		DbgLog((LOG_ERROR, 2, 
				TEXT("CSPHGENV::ReadFromStream: Incompatible stream format")));
		return E_FAIL;
	}
	HRESULT hr;
	
	ULONG uBytesRead;

	hr = CSPHBase::ReadFromStream(pStream);
	if (FAILED(hr)) return hr;

    DbgLog((LOG_TRACE, 4, 
            TEXT("CSPHGENV::ReadFromStream: Loading media subtype")));

    GUID gMediaSubtype;

    hr = pStream->Read(&gMediaSubtype, sizeof(GUID), &uBytesRead);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CSPHGENV::ReadFromStream: Error 0x%08x reading media subtype"),
                hr));
        return hr;
    } else if (uBytesRead != sizeof(GUID)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CSPHGENV::ReadFromStream: Mismatch in (%d/%d) bytes read for media subtype"),
                uBytesRead, sizeof(GUID)));
        return E_INVALIDARG;
    } 

	// ZCS 6-30-97: My surgery in this section is all intended to allow the output
	// pin media type to be set when the graph is loaded from a file. None of this
	// should be attempted if the output pin type is GUID_NULL, because the code
	// below assumes that the filter will later be connected as part of the load-
	// from-file procedure. A non-GUID_NULL value can only occur if the filter
	// was connected when it was saved.

	if (gMediaSubtype != GUID_NULL)
	{
	    DbgLog((LOG_TRACE, 3, 
				TEXT("CSPHGENV::ReadFromStream: Restoring media subtype")));

		// ZCS 6-30-97: at this point we don't have any pins, so we can't set the output pin media type
		// just yet. Must first call GetPin(). Subsequent calls to GetPin() will be ok because it
		// doesn't allocate more pins as long as the original input and output pins are still there.
		EXECUTE_ASSERT(GetPin(0) != NULL);
	
		// ZCS 6-30-97:
		// In order for SetOutputPinMinorType() to succeed, the input pin must
		// have a major type that isn't GUID_NULL. This is a bit of subterfuge
		// to pretend we have an input pin major type -- the type doesn't matter as
		// long as it isn't GUID_NULL. We'll undo this shortly.
	
		GUID gTemp = MEDIATYPE_RTP_Single_Stream;
		m_pInput->CurrentMediaType().SetType(&gTemp);
	
		hr = SetOutputPinMinorType(gMediaSubtype);

		// ZCS: we don't really have an input major type, so undo what we did...
		gTemp = GUID_NULL;
		m_pInput->CurrentMediaType().SetType(&gTemp);
		
		// now check if SetOutputPinMinorType failed
	    if (FAILED(hr)) {
	        DbgLog((LOG_ERROR, 2, 
	                TEXT("CSPHGENV::ReadFromStream: Error 0x%08x setting media subtype"),
	                hr));
		
			return hr;
	    } 
	}

	return NOERROR; 
}

// WriteToStream
// This is the call that will write persistent data to file
//
HRESULT CSPHGENV::WriteToStream(IStream *pStream) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENV::WriteToStream")));
	
	HRESULT hr;
    ULONG uBytesWritten = 0;

	hr = CSPHBase::WriteToStream(pStream);
	if (FAILED(hr)) return hr;

    DbgLog((LOG_TRACE, 4, 
            TEXT("CSPHGENV::WriteToStream: Writing media subtype")));

	hr = pStream->Write(&m_gMinorType, sizeof(GUID), &uBytesWritten);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CSPHGENV::WriteToStream: Error 0x%08x reading media subtype"),
                hr));
        return hr;
    } else if (uBytesWritten != sizeof(GUID)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CSPHGENV::WriteToStream: Mismatch in (%d/%d) bytes read for media subtype"),
                uBytesWritten, sizeof(GUID)));
        return E_INVALIDARG;
    } 

	return NOERROR; 
}

// SizeMax
// This returns the amount of storage space required for my persistent data
//
int CSPHGENV::SizeMax(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENV::SizeMax")));
	
	return CSPHBase::SizeMax()
        + sizeof(GUID); 
}

// GetClassID
// This function returns my CLSID  
//  
HRESULT _stdcall CSPHGENV::GetClassID(CLSID *pCLSID) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENV::GetClassID")));
	
	if (!pCLSID)
		return E_POINTER;
	*pCLSID = CLSID_INTEL_SPHGENV;
	return NOERROR; 
}

// GetSoftwareVersion
// This returns the version of this filter to be stored with the persistent data
//
DWORD CSPHGENV::GetSoftwareVersion(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENV::GetSoftwareVersion")));
	
	return 1; 
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphgenv\genvprop.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : genvprop.cpp
// Purpose  : RTP SPH Generic Video Property Page.
// Contents : 
//*M*/

#if !defined(NO_GENERIC_VIDEO)
#include <winsock2.h>
#include <streams.h>
#include <ippm.h>
#include <amrtpuid.h>
#include <sph.h>
#include <ppmclsid.h>
#include <memory.h>
#include <resource.h>
#include <genvprop.h>

#include "sphres.h"

CUnknown * WINAPI 
CSPHGENVPropertyPage::CreateInstance( 
    LPUNKNOWN punk, 
    HRESULT *phr )
{
    CSPHGENVPropertyPage *pNewObject
        = new CSPHGENVPropertyPage( punk, phr);

    if( pNewObject == NULL )
        *phr = E_OUTOFMEMORY;

    return pNewObject;
} /* CSPHGENVPropertyPage::CreateInstance() */


CSPHGENVPropertyPage::CSPHGENVPropertyPage( 
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBasePropertyPage(NAME("Intel RTP SPH Generic Video Property Page"),pUnk,
        IDD_SPHGENV_SPHGENV_PROPPAGE, IDS_SPHGEN_VIDEO)
    , m_pIRTPSPHFilter (NULL)
    , m_bIsInitialized(FALSE)
	, m_bMinorTypeScanned(FALSE)
	, m_nActiveItems(0)
	, m_pGuidVal(NULL)


{
    DbgLog((LOG_TRACE, 3, TEXT("CSPHGENVPropertyPage::CSPHGENVPropertyPage: Constructed at 0x%08x"), this));
} /* CSPHGENVPropertyPage::CSPHGENVPropertyPage() */

void 
CSPHGENVPropertyPage::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
} /* CSPHGENVPropertyPage::SetDirty() */

INT_PTR 
CSPHGENVPropertyPage::OnReceiveMessage(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENVPropertyPage::OnReceiveMessage: Entered")));
    switch (uMsg) {
    case WM_INITDIALOG:
		return OnInitDialog();
		break;

    case WM_COMMAND:
        if (m_bIsInitialized) {
            if (OnCommand( (int) LOWORD( wParam ), (int) HIWORD( wParam ), lParam ) == TRUE) {
                return (LRESULT) 1;
            } /* if */
        } else {
			return(LRESULT) 1;
        } /* if */
        break;

	case WM_DESTROY:
		CSPHGENVPropertyPage::OnDeactivate();
		break;
    } /* switch */

    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
} /* CSPHGENVPropertyPage::OnReceiveMessage() */


HRESULT 
CSPHGENVPropertyPage::OnConnect(
    IUnknown    *pUnknown)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENVPropertyPage::OnConnect: Entered")));
    ASSERT(m_pIRTPSPHFilter == NULL);
    DbgLog((LOG_TRACE, 2, TEXT("CSPHGENVPropertyPage::OnConnect: Called with IUnknown 0x%08x"), pUnknown));

	HRESULT hr = pUnknown->QueryInterface(IID_IRTPSPHFilter, (void **) &m_pIRTPSPHFilter);
	if(FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, TEXT("CSPHGENVPropertyPage::OnConnect: Error 0x%08x getting IRTPSPHFilter interface!"), hr));
	    return hr;
    } /* if */
	ASSERT( m_pIRTPSPHFilter != NULL );
    m_bIsInitialized = FALSE;
    DbgLog((LOG_TRACE, 3, TEXT("CSPHGENVPropertyPage::OnConnect: Got IRTPSPHFilter interface at 0x%08x"), m_pIRTPSPHFilter));

    return NOERROR;
} /* CSPHGENVPropertyPage::OnConnect() */


HRESULT 
CSPHGENVPropertyPage::OnDisconnect(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENVPropertyPage::OnDisconnect: Entered")));

    if (m_pIRTPSPHFilter == NULL)
    {
        return E_UNEXPECTED;
    }

	m_pIRTPSPHFilter->Release();
	m_pIRTPSPHFilter = NULL;
    return NOERROR;
} /* CSPHGENVPropertyPage::OnDisconnect() */


HRESULT 
CSPHGENVPropertyPage::OnActivate(void)
{
	HKEY	hKey;
	HKEY	hTypeKey;
	long	lRes;
	char	keyBfr[50];
	DWORD	dwBufLen, dwIndex, nTypekeys, nTypeNameLen;
	DWORD	nSubtypekeys, nSubtypeNameLen;
	DWORD	nValueNameLen, dwData, dwValLen;
	HANDLE	hHeap;
	LPTSTR	lpTypeBuf;
	BYTE	*lpValBuf;
	HWND	hCurrentListbox;
	char	szMediaType[]="Video";
	int		iCurrentItem;
	GUID	*pGuidVal;
	wchar_t	szCLSID[40];
    
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENVPropertyPage::OnActivate: Entered")));

	hCurrentListbox = GetDlgItem(m_hwnd, IDC_SPHGENV_OUTPUTPINLIST);

	// open the key
	strcpy (keyBfr, szRegAMRTPKey);
	lRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE, keyBfr, 0, KEY_READ, &hKey);

	lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, &nTypekeys, &nTypeNameLen,
							NULL, NULL, NULL, NULL, NULL, NULL);
	// Allocate memory
	hHeap = GetProcessHeap();
	lpTypeBuf = (char *)HeapAlloc(hHeap, 0, ++nTypeNameLen);
	
	// Retrieve Registry values for the Media Types
	for (dwIndex = 0; dwIndex < nTypekeys; dwIndex++)
	{
		dwBufLen = nTypeNameLen;
		lRes = RegEnumKeyEx(hKey, dwIndex, lpTypeBuf, &dwBufLen, NULL, NULL, NULL, NULL);
		lRes = RegOpenKeyEx (hKey, lpTypeBuf, 0, KEY_READ, &hTypeKey);
		lRes = RegQueryInfoKey(hTypeKey, NULL, NULL, NULL, &nSubtypekeys, &nSubtypeNameLen,
								 NULL, NULL, NULL, &nValueNameLen, NULL, NULL);
		lpValBuf = (BYTE *)HeapAlloc(hHeap, 0, ++nValueNameLen);
		dwValLen = nValueNameLen;
		lRes = RegQueryValueEx(hTypeKey, "Media Type", NULL, &dwData, lpValBuf, &dwValLen);
		if(strncmp((char *)lpValBuf, szMediaType, dwValLen) == 0)
		{
			// save the MEDIATYPE GUID for use later
			// retrieve the Subtype KEYS
			dwValLen = nValueNameLen;
			lRes = RegQueryValueEx(hTypeKey, "Description", NULL, &dwData, lpValBuf, &dwValLen);
			iCurrentItem = SendMessage(hCurrentListbox, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(lpValBuf));
			pGuidVal = (GUID *)HeapAlloc(hHeap, 0, sizeof(GUID));
			int i;
			i = mbstowcs(szCLSID, lpTypeBuf, 40);
			CLSIDFromString(szCLSID, pGuidVal);
			SendMessage(hCurrentListbox, LB_SETITEMDATA, iCurrentItem, (LPARAM) pGuidVal);
			
			// increment the number of active items in the Dialog Box
			// we'll use this to free the memory later.
			m_nActiveItems += 1;

			// ZCS fix 6-19-97: if this is the current output pin minor type, make it selected.			
			GUID *pGuidValFromPin = (GUID *)HeapAlloc(hHeap, 0, sizeof(GUID));
			ASSERT(pGuidValFromPin);
			if (SUCCEEDED(m_pIRTPSPHFilter->GetOutputPinMinorType(pGuidValFromPin))
													&& (*pGuidValFromPin == *pGuidVal))
				SendMessage(hCurrentListbox, LB_SETCURSEL, iCurrentItem, 0);
			HeapFree(hHeap, 0, (void *)pGuidValFromPin);

			// HeapFree and RegCloseKey here
			HeapFree(hHeap, 0, lpValBuf);
			RegCloseKey(hTypeKey);
		}
		else
		{
			HeapFree(hHeap, 0, lpValBuf);
			RegCloseKey(hTypeKey);
		}
	}
	
	m_bIsInitialized = TRUE;

	HeapFree(hHeap, 0, lpTypeBuf);
	RegCloseKey(hKey);

    return NOERROR;
} /* CSPHGENVPropertyPage::OnActivate() */

HRESULT 
CSPHGENVPropertyPage::OnDeactivate(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENVPropertyPage::OnDeactivate: Entered")));
    
	HANDLE hHeap;
	GUID   *pGuidVal;
	HWND   hCurrentListbox = GetDlgItem(m_Dlg, IDC_SPHGENV_OUTPUTPINLIST);
	int	   i;

    if (m_pIRTPSPHFilter == NULL)
    {
        return E_UNEXPECTED;
    }

	hHeap = GetProcessHeap();

	for (i=0; i < m_nActiveItems; i++)
	{
        pGuidVal = reinterpret_cast<GUID *>(SendMessage(hCurrentListbox, LB_GETITEMDATA, i, 0));
		HeapFree(hHeap, 0, (void*)pGuidVal);
	}

	// Probably don't really need to do this as its likely the object is going
	// away .. but .. better safe than sorry
	m_nActiveItems = 0;

    return NOERROR;
} /* CSPHGENVPropertyPage::OnDeactivate() */

BOOL 
CSPHGENVPropertyPage::OnInitDialog(void)
{

    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENVPropertyPage::OnInitDialog: Entered")));

    return (LRESULT) 1;
} /* CSPHGENVPropertyPage::OnInitDialog() */


BOOL 
CSPHGENVPropertyPage::OnCommand( 
    int     iButton, 
    int     iNotify,
    LPARAM  lParam)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENVPropertyPage::OnCommand: Entered")));
	
	HWND hCurrentListbox;
	int iCurrentSel;

    switch( iButton ){
	case IDC_SPHGENV_OUTPUTPINLIST:
		if(iNotify == IDOK)
		{
			m_bMinorTypeScanned = TRUE;
			hCurrentListbox = GetDlgItem(m_Dlg, IDC_SPHGENV_OUTPUTPINLIST);
			iCurrentSel = SendMessage(hCurrentListbox, LB_GETCURSEL, 0, 0);
			m_pGuidVal = reinterpret_cast<GUID *>(SendMessage(hCurrentListbox,
															  LB_GETITEMDATA,
															  iCurrentSel,
															  0));
			SetDirty();
		}
		break;
    default:
        break;
    } /* switch */	

    return (LRESULT) 1;
} /* CSPHGENVPropertyPage::OnCommand() */


HRESULT 
CSPHGENVPropertyPage::OnApplyChanges(void)
{

	HRESULT hErr;

    DbgLog((LOG_TRACE, 4, TEXT("CSPHGENVPropertyPage::OnApplyChanges: Entered")));
    ASSERT( m_pIRTPSPHFilter != NULL );

	if (m_bMinorTypeScanned) {
		hErr = m_pIRTPSPHFilter->SetOutputPinMinorType(*m_pGuidVal);
        if (FAILED(hErr)) {
            DbgLog((LOG_ERROR, 1, TEXT("CRPHGENVPropPage::OnApplyChanges: SetOutputPinMediaType returned 0x%08X"),
                hErr));
        }
	}

    return(NOERROR);

} /* CSPHGENVPropertyPage::OnApplyChanges() */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphgenv\sphgenv.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : SPHGENV.h
// Purpose  : Define the class that implements the RTP SPH Generic Video filter.
// Contents : 
//*M*/


#ifndef _SPHGENV_H_
#define _SPHGENV_H_

#include <sph.h>

#define DEFAULT_PACKET_SIZE_SPHGENV 1450
#define DEFAULT_PACKETBUF_NUM_SPHGENV 2 // HUGEMEMORY 128->2

class CSPHGENV : public CSPHBase
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    DECLARE_IUNKNOWN;

    virtual HRESULT CheckInputType(const CMediaType *mtIn);
    virtual HRESULT CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut);
	virtual HRESULT CompleteConnect(PIN_DIRECTION dir,IPin *pPin);
	virtual CBasePin *GetPin(int n);
    virtual STDMETHODIMP SetOutputPinMinorType(GUID gMinorType);
    virtual STDMETHODIMP GetOutputPinMinorType(GUID *lpgMinorType);
    virtual STDMETHODIMP SetInputPinMediaType(AM_MEDIA_TYPE *lpMediaPinType);
    virtual STDMETHODIMP GetInputPinMediaType(AM_MEDIA_TYPE **ppMediaPinType);
	virtual STDMETHODIMP GetInputPinMediaType(int iPosition, CMediaType *pMediaType);


	virtual HRESULT ReadFromStream(IStream *pStream);
	virtual HRESULT WriteToStream(IStream *pStream);
	virtual int SizeMax(void);
	virtual HRESULT _stdcall GetClassID(CLSID *pCLSID);
	virtual DWORD GetSoftwareVersion(void);

    // Setup helper
    virtual LPAMOVIESETUP_FILTER GetSetupData();

private:

    // Constructor
    CSPHGENV(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);
	~CSPHGENV();

	virtual HRESULT SetPPMSession();

	GUID m_gMinorType;
	CMediaType *m_lpMediaIPinType;

}; // CSPHGENV


#endif // _SPHGENV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphgenv\template.h ===
/*********************************************************************
 *
 * Copyright (c) 1997 Microsoft Corporation
 *
 * File: sph\sphgenv\template.h
 *
 * Abstract:
 *     Macros to define CFactoryTemplate templates
 *
 * History:
 *     10/28/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_SPHGENV_TEMPLATE_H_)
#define      _SPHGENV_TEMPLATE_H_

extern AMOVIESETUP_FILTER sudSPHGENV;

EXTERN_C const CLSID CLSID_INTEL_SPHGENV;
EXTERN_C const CLSID CLSID_INTEL_SPHGENV_PROPPAGE;
EXTERN_C const CLSID CLSID_INTEL_SPHGENV_PIN_PROPPAGE;

#define CFT_SPHGENV_FILTER \
{ \
	  L"Intel RTP SPH for Generic Video", \
	  &CLSID_INTEL_SPHGENV, \
	  CSPHGENV::CreateInstance, \
	  NULL, \
	  &sudSPHGENV \
	  }

#define CFT_SPHGENV_FILTER_PROP \
{ \
	  L"Intel RTP SPH Property Page", \
	  &CLSID_INTEL_SPHGENV_PROPPAGE, \
	  CSPHPropertyPage::CreateInstance_genv \
	  }

#define CFT_SPHGENV_GENERIC_PROP \
{ \
	  L"Intel RTP SPH Generic Video Property Page", \
	  &CLSID_INTEL_SPHGENV_PIN_PROPPAGE, \
	  CSPHGENVPropertyPage::CreateInstance \
	  }

#define CFT_SPHGENV_ALL_FILTERS \
CFT_SPHGENV_FILTER, \
CFT_SPHGENV_FILTER_PROP, \
CFT_SPHGENV_GENERIC_PROP

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\perfdll\perfctr.h ===
//
//  Offset definition file for extensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the 
//  "First Counter" and "First Help" values for the device they belong to, 
//  in order to determine the absolute location of the counter and 
//  object names and corresponding Explain text in the registry.
//
//  This file is used by the extensible counter DLL code as well as the 
//  counter name and Explain text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define TAPIOBJ                 0
#define LINES                   2
#define PHONES                  4
#define LINESINUSE              6
#define PHONESINUSE             8
#define TOTALOUTGOINGCALLS      10
#define TOTALINCOMINGCALLS      12
#define CLIENTAPPS              14
#define ACTIVEOUTGOINGCALLS     16
#define ACTIVEINCOMINGCALLS     18
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphh26x\sphh26x.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : sphh26x.cpp
// Purpose  : RTP SPH H.26x Video filter implementation.
// Contents : 
//*M*/

#include <winsock2.h>
#include <streams.h>
#if !defined(SPH_IN_DXMRTP)
#include <initguid.h>
#define INITGUID
#endif
#include <ippm.h>
#include <amrtpuid.h>
#include <sphh26x.h>
#include <ih26xcd.h>
#include <ppmclsid.h>
#include <memory.h>
#include <sphprop.h>

#include "template.h"

// setup data

EXTERN_C const CLSID CLSID_INTEL_SPHH26X;
EXTERN_C const CLSID CLSID_INTEL_SPHH26X_PROPPAGE;

static const CLSID *pPropertyPageClsids[] =
{
    &CLSID_INTEL_SPHH26X_PROPPAGE
};

#define NUMPROPERTYPAGES \
    (sizeof(pPropertyPageClsids)/sizeof(pPropertyPageClsids[0]))

static AMOVIESETUP_MEDIATYPE sudOutputPinTypes[] =
{
	{
		&MEDIATYPE_RTP_Single_Stream,       // Major type
		&MEDIASUBTYPE_RTP_Payload_H263      // Minor type
	},
	{
		&MEDIATYPE_RTP_Single_Stream,       // Major type
		&MEDIASUBTYPE_RTP_Payload_H261      // Minor type
	}
};

static AMOVIESETUP_MEDIATYPE sudInputPinTypes[] =
{
	{
		&MEDIATYPE_Video,       // Major type
		&MEDIASUBTYPE_H263EX    // Minor type
	},
	{
		&MEDIATYPE_Video,       // Major type
		&MEDIASUBTYPE_H261EX    // Minor type
	},
	{
		&MEDIATYPE_Video,       // Major type
		&MEDIASUBTYPE_H263      // Minor type
	},
	{
		&MEDIATYPE_Video,       // Major type
		&MEDIASUBTYPE_H261      // Minor type
	}
};

static AMOVIESETUP_PIN psudPins[] =
{
    {
        L"Input",           // String pin name
        FALSE,              // Is it rendered
        FALSE,              // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Output",          // Connects to pin
        4,                  // Number of types
        (AMOVIESETUP_MEDIATYPE *)&sudInputPinTypes },// The pin details
      { L"Output",          // String pin name
        FALSE,              // Is it rendered
        TRUE,               // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Input",           // Connects to pin
        2,                  // Number of types
        (AMOVIESETUP_MEDIATYPE *)&sudOutputPinTypes  // The pin details
    }
};


AMOVIESETUP_FILTER sudSPHH26X =
{
    &CLSID_INTEL_SPHH26X,   // Filter CLSID
    L"Intel RTP SPH for H.263/H.261", // Filter name
    MERIT_DO_NOT_USE, //MERIT_UNLIKELY,         // Its merit
    2,                      // Number of pins
    psudPins                // Pin details
};


// List of class IDs and creator functions for the class factory. This
// provides the link between the OLE entry point in the DLL and an object
// being created. The class factory will call the static CreateInstance

#if !defined(SPH_IN_DXMRTP)
CFactoryTemplate g_Templates[] = {
	CFT_SPHH26X_ALL_FILTERS
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif

//
// Constructor
//
CSPHH26X::CSPHH26X(TCHAR *tszName,LPUNKNOWN punk,HRESULT *phr) :
	CSPHBase(tszName, punk, phr, CLSID_INTEL_SPHH26X,
			 DEFAULT_PACKETBUF_NUM_SPHH26X,
			 DEFAULT_PACKET_SIZE_SPHH26X,
			 NUMPROPERTYPAGES,
			 pPropertyPageClsids)
{
	DbgLog((LOG_TRACE,4,TEXT("CSPHH26X::")));

    ASSERT(tszName);
    ASSERT(phr);

} // SPHH26X


//
// CreateInstance
//
// Provide the way for COM to create a CSPHH26X object
//
CUnknown *CSPHH26X::CreateInstance(LPUNKNOWN punk, HRESULT *phr) {

	DbgLog((LOG_TRACE,4,TEXT("CSPHH26X::CreateInstance")));

    CSPHH26X *pNewObject = new CSPHH26X(NAME("Intel RTP Send Payload Handler for H26X"), punk, phr);
    if (pNewObject == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return pNewObject;

} // CreateInstance


//
// GetSetupData
//
// Returns registry information for this filter
//
LPAMOVIESETUP_FILTER CSPHH26X::GetSetupData()
{
    return &sudSPHH26X;

} // GetSetupData



//
// CheckInputType
//
// Check the input type is OK, return an error otherwise
//
HRESULT CSPHH26X::CheckInputType(const CMediaType *mtIn)
{

	DbgLog((LOG_TRACE,4,TEXT("CSPHH26X::CheckInputType")));


	//Check major type first
    if (*mtIn->Type() == MEDIATYPE_Video) {
		//Check all supported minor types
		if (*mtIn->Subtype() == MEDIASUBTYPE_H263EX) {
			m_PPMCLSIDType = CLSID_H263PPMSend;
			if (!m_bPTSet) m_PayloadType = H263_PT;
			return NOERROR;
		} 
		if (*mtIn->Subtype() == MEDIASUBTYPE_H261EX) {
			m_PPMCLSIDType = CLSID_H261PPMSend;
			if (!m_bPTSet) m_PayloadType = H261_PT;
			return NOERROR;
		}
		if (*mtIn->Subtype() == MEDIASUBTYPE_H263) {
			m_PPMCLSIDType = CLSID_H263PPMSend;
			if (!m_bPTSet) m_PayloadType = H263_PT;
			return NOERROR;
		}
		if (*mtIn->Subtype() == MEDIASUBTYPE_H261) {
			m_PPMCLSIDType = CLSID_H261PPMSend;
			if (!m_bPTSet) m_PayloadType = H261_PT;
			return NOERROR;
		}
		//Otherwise, we don't support this input subtype
		return E_INVALIDARG;
	}

	//We don't support this major type
    return E_FAIL;

} // CheckInputType


//
// CheckTransform
//
// To be able to transform the formats must be identical
//
HRESULT CSPHH26X::CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut)
{
	
	DbgLog((LOG_TRACE,4,TEXT("CSPHH26X::CheckTransform")));

	//Check all supported minor types
	if (((*mtIn->Subtype() == MEDIASUBTYPE_H263EX) ||
		(*mtIn->Subtype() == MEDIASUBTYPE_H263 )) && 
		(*mtOut->Subtype() == MEDIASUBTYPE_RTP_Payload_H263)) {
		return NOERROR;
	} 
	if (((*mtIn->Subtype() == MEDIASUBTYPE_H261EX) ||
		(*mtIn->Subtype() == MEDIASUBTYPE_H261 )) && 
		(*mtOut->Subtype() == MEDIASUBTYPE_RTP_Payload_H261)) {
		return NOERROR;
	} 
    return E_FAIL;

} // CheckTransform


// CheckConnect
// This function is overridden so that the RTP support interface from the codec
//   can be retrieved and the extended bitstream generation turned on
//
HRESULT CSPHH26X::CompleteConnect(PIN_DIRECTION dir,IPin *pPin)
{
	const GUID mtguid = MEDIATYPE_RTP_Single_Stream;
	const GUID pt263guid = MEDIASUBTYPE_RTP_Payload_H263;
	const GUID pt261guid = MEDIASUBTYPE_RTP_Payload_H261;

	DbgLog((LOG_TRACE,4,TEXT("CSPHH26X::CompleteConnect")));

	if (dir == PINDIR_INPUT) {
		PIN_INFO OutputPinInfo;
		HRESULT hr;
		CMediaType mtOut(&mtguid);

		//We're going to set our own output pin media type
		mtOut.SetVariableSize();
		if (m_PPMCLSIDType == CLSID_H263PPMSend) {
			mtOut.SetSubtype(&pt263guid);
		} else { //H.261
			mtOut.SetSubtype(&pt261guid);
		}
		m_pOutput->SetMediaType(&mtOut);

		//get the upstream filter's output pin info structure
		hr = pPin->QueryPinInfo(&OutputPinInfo);
		if (FAILED(hr)) 
			return E_FAIL;

		CMediaType mtIn = m_pInput->CurrentMediaType();

		if(!((*mtIn.Subtype() == MEDIASUBTYPE_H263EX) || 
			(*mtIn.Subtype() == MEDIASUBTYPE_H261EX))) {

			IH26XRTPControl *pRTPif;
			ENC_RTP_DATA EncData;
			//query the filter interface for its RTP interface
			
			hr = OutputPinInfo.pFilter->QueryInterface(IID_IH26XRTPControl, (void **) &pRTPif);
			if (FAILED(hr)) {
			
				DbgLog((LOG_ERROR,1,TEXT("CompleteConnect::Couldn't get IID_IH26XRTPControl"))); 

				return E_FAIL;
			}
			//set RTP info on in codec
			hr = pRTPif->get_RTPCompression(&EncData);
			if (FAILED(hr)) 
				return hr;
			//set RTP extended bitstream generation ON and set the packet size
			if (EncData.bRTPHeader == FALSE) {
				EncData.bRTPHeader = TRUE;
				EncData.dwPacketSize = m_dwMaxPacketSize - 24;
				hr = pRTPif->set_RTPCompression(&EncData);
                if (FAILED(hr))
                    return hr;
			}
			pRTPif->Release();
            OutputPinInfo.pFilter->Release();
		}
		return NOERROR;

	} else {
		return NOERROR;
	}
}

// SetPPMSession
// This function is where PPM::SetSession is called and may be specific to payload
//  handler.  Minimum function is to set the payload type.
HRESULT CSPHH26X::SetPPMSession() 
{
	HRESULT hr;
	if (m_pPPMSession) {
		hr = m_pPPMSession->SetPayloadType((unsigned char)m_PayloadType);
		return hr;
	} else {
		return E_FAIL;
	}

}

// CPersistStream methods

// ReadFromStream
// This is the call that will read persistent data from file
//
HRESULT CSPHH26X::ReadFromStream(IStream *pStream) 
{ 
	DbgLog((LOG_TRACE, 4, TEXT("CSPHH26X::ReadFromStream")));
    if (mPS_dwFileVersion != 1) {
		DbgLog((LOG_ERROR, 2, 
				TEXT("CSPHH26X::ReadFromStream: Incompatible stream format")));
		return E_FAIL;
	}
	
	return CSPHBase::ReadFromStream(pStream);

}

// GetClassID
// This function returns my CLSID  
//  
HRESULT _stdcall CSPHH26X::GetClassID(CLSID *pCLSID) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CSPHH26X::GetClassID")));
	
	if (!pCLSID)
		return E_POINTER;
	*pCLSID = CLSID_INTEL_SPHH26X;
	return NOERROR; 
}

// GetSoftwareVersion
// This returns the version of this filter to be stored with the persistent data
//
DWORD CSPHH26X::GetSoftwareVersion(void) 
{ 
    DbgLog((LOG_TRACE, 4, TEXT("CSPHH26X::GetSoftwareVersion")));
	
	return 1; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphh26x\sphh26x.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : SPHH26X.h
// Purpose  : Define the class that implements the RTP SPH H.26x filter.
// Contents : 
//*M*/


#ifndef _SPHH26X_H_
#define _SPHH26X_H_

#include <sph.h>

#define DEFAULT_PACKET_SIZE_SPHH26X 1450
#define DEFAULT_PACKETBUF_NUM_SPHH26X 2 // HUGEMEMORY 128->2
#define H261_PT   31    //assigned RTP payload number for H.261
#define H263_PT   34    //assigned RTP payload number for H.263

class CSPHH26X : public CSPHBase
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    DECLARE_IUNKNOWN;

    virtual HRESULT CheckInputType(const CMediaType *mtIn);
    virtual HRESULT CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut);
	virtual HRESULT CompleteConnect(PIN_DIRECTION dir,IPin *pPin);


	// CPersistStream methods
	virtual HRESULT ReadFromStream(IStream *pStream);
	virtual HRESULT _stdcall GetClassID(CLSID *pCLSID);
	virtual DWORD GetSoftwareVersion(void);

    // Setup helper
    virtual LPAMOVIESETUP_FILTER GetSetupData();

private:

    // Constructor
    CSPHH26X(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);
	virtual HRESULT SetPPMSession();

}; // CSPHH26X


#endif // _SPHH26X_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\sph\sphh26x\template.h ===
/*********************************************************************
 *
 * Copyright (c) 1997 Microsoft Corporation
 *
 * File: sph\sphh26x\template.h
 *
 * Abstract:
 *     Macros to define CFactoryTemplate templates
 *
 * History:
 *     10/28/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_SPHH26X_TEMPLATE_H_)
#define      _SPHH26X_TEMPLATE_H_

extern AMOVIESETUP_FILTER sudSPHH26X;

#define CFT_SPHH26X_FILTER \
{ \
	  L"Intel RTP SPH for H.263/H.261", \
	  &CLSID_INTEL_SPHH26X, \
	  CSPHH26X::CreateInstance, \
	  NULL, \
	  &sudSPHH26X \
	  }

#define CFT_SPHH26X_FILTER_PROP \
{ \
	  L"Intel RTP SPH Property Page", \
	  &CLSID_INTEL_SPHH26X_PROPPAGE, \
	  CSPHPropertyPage::CreateInstance_h26x \
	  }

#define CFT_SPHH26X_ALL_FILTERS \
CFT_SPHH26X_FILTER, \
CFT_SPHH26X_FILTER_PROP

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rca\precomp.h ===
#include <ntddk.h>
#include <ndis.h>
#include <windef.h>
#include <ndisprv.h>

// order important -- KS first
#include <ks.h>
#include <mmsystem.h>
#include <swenum.h>
#include <pxuser.h>

#define NDIS_TAPI_CURRENT_VERSION   0x20000
#include <ndistapi.h>

#include "RCA.h"
#include "RCAdebug.h"
#include "RCANdis.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\perfdll\tapiperf.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfTAPI.c

Abstract:

    This file implements the Extensible Objects for the TAPI object type

Revision History


--*/

//
//  Include Files
//

#include <windows.h>
#include <string.h>
#include <tapi.h>
#include <tspi.h>
#include "client.h"
#include "clntprivate.h"
#include "tapsrv.h"
#include <ntprfctr.h>
#include "perfctr.h"
#include "tapiperf.h"

//
//  References to constants which initialize the Object type definitions
//


HINSTANCE                   ghInst;
HINSTANCE                   ghTapiInst = NULL;
extern TAPI_DATA_DEFINITION TapiDataDefinition;
DWORD                       dwOpenCount = 0;        // count of "Open" threads
BOOL                        bInitOK = FALSE;        // true = DLL initialized OK
HLINEAPP                    hLineApp;
HPHONEAPP                   hPhoneApp;
BOOL                        bTapiSrvRunning = FALSE;
DWORD                       gdwLineDevs, gdwPhoneDevs;

void CheckForTapiSrv();
LONG WINAPI Tapi32Performance(PPERFBLOCK);
//
// Tapi data structures
//

HANDLE hTapiSharedMemory;                // Handle of Tapi Shared Memory
PPERF_COUNTER_BLOCK pCounterBlock;

typedef  LONG (* PERFPROC)(PERFBLOCK *);

#define SZINTERNALPERF          TEXT("internalPerformance")
#define SZTAPI32                TEXT("tapi32.dll")
#define SZTAPISRVKEY            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony")

PERFPROC    glpfnInternalPerformance;

//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC        OpenTapiPerformanceData;
PM_COLLECT_PROC     CollectTapiPerformanceData;
PM_CLOSE_PROC       CloseTapiPerformanceData;


//
//  Constant structure initializations
//      defined in datatapi.h
//

TAPI_DATA_DEFINITION TapiDataDefinition =
{
        {
                sizeof(TAPI_DATA_DEFINITION) + SIZE_OF_TAPI_PERFORMANCE_DATA,
                sizeof(TAPI_DATA_DEFINITION),
                sizeof(PERF_OBJECT_TYPE),
                TAPIOBJ,
                0,
                TAPIOBJ,
                0,
                PERF_DETAIL_NOVICE,
                (sizeof(TAPI_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
                        sizeof(PERF_COUNTER_DEFINITION),
                0,
                -1,
                0
        },

        {
                sizeof(PERF_COUNTER_DEFINITION),
                LINES,
                0,
                LINES,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_RAWCOUNT,
                sizeof(DWORD),
                LINES_OFFSET
        },

        {
                sizeof(PERF_COUNTER_DEFINITION),
                PHONES,
                0,
                PHONES,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_RAWCOUNT,
                sizeof(DWORD),
                PHONES_OFFSET
        },

        {
                sizeof(PERF_COUNTER_DEFINITION),
                LINESINUSE,
                0,
                LINESINUSE,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_RAWCOUNT,
                sizeof(DWORD),
                LINESINUSE_OFFSET
        },

        {
                sizeof(PERF_COUNTER_DEFINITION),
                PHONESINUSE,
                0,
                PHONESINUSE,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_RAWCOUNT,
                sizeof(DWORD),
                PHONESINUSE_OFFSET
        },
        {
                sizeof(PERF_COUNTER_DEFINITION),
                TOTALOUTGOINGCALLS,
                0,
                TOTALOUTGOINGCALLS,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_COUNTER,
                sizeof(DWORD),
                TOTALOUTGOINGCALLS_OFFSET
        },
        {
                sizeof(PERF_COUNTER_DEFINITION),
                TOTALINCOMINGCALLS,
                0,
                TOTALINCOMINGCALLS,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_COUNTER,
                sizeof(DWORD),
                TOTALINCOMINGCALLS_OFFSET
        },

        {
                sizeof(PERF_COUNTER_DEFINITION),
                CLIENTAPPS,
                0,
                CLIENTAPPS,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_RAWCOUNT,
                sizeof(DWORD),
                CLIENTAPPS_OFFSET
        }
 ,
        {
                sizeof(PERF_COUNTER_DEFINITION),
                ACTIVEOUTGOINGCALLS,
                0,
                ACTIVEOUTGOINGCALLS,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_RAWCOUNT,
                sizeof(DWORD),
                ACTIVEOUTGOINGCALLS_OFFSET
        },
        {
                sizeof(PERF_COUNTER_DEFINITION),
                ACTIVEINCOMINGCALLS,
                0,
                ACTIVEINCOMINGCALLS,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_RAWCOUNT,
                sizeof(DWORD),
                ACTIVEINCOMINGCALLS_OFFSET
        }


};


DWORD APIENTRY
OpenTapiPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open and map the memory used by the TAPI driver to
    pass performance data in. This routine also initializes the data
    structures used to pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (TAPI)


Return Value:

    None.

--*/

{
    LONG status;
    TCHAR szMappedObject[] = TEXT("TAPI_COUNTER_BLOCK");
    HKEY hKeyDriverPerf;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
    HKEY  hTapiKey;
    DWORD   dwType;
    DWORD   dwSize;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    if (!dwOpenCount)
    {

        // get counter and help index base values
        //      update static data structures by adding base to
        //          offset value in structure.

        // these values are from <ntprfctr.h>
        dwFirstCounter  = TAPI_FIRST_COUNTER_INDEX;
        dwFirstHelp     = TAPI_FIRST_HELP_INDEX;

        TapiDataDefinition.TapiObjectType.ObjectNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.TapiObjectType.ObjectHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.Lines.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.Lines.CounterHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.Phones.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.Phones.CounterHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.LinesInUse.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.LinesInUse.CounterHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.PhonesInUse.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.PhonesInUse.CounterHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.TotalOutgoingCalls.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.TotalOutgoingCalls.CounterHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.TotalIncomingCalls.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.TotalIncomingCalls.CounterHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.ClientApps.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.ClientApps.CounterHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.CurrentOutgoingCalls.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.CurrentOutgoingCalls.CounterHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.CurrentIncomingCalls.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.CurrentIncomingCalls.CounterHelpTitleIndex += dwFirstHelp;

        bInitOK = TRUE; // ok to use this function
    }

    dwOpenCount++;  // increment OPEN counter

    // get number of devices from tapi


    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      SZTAPISRVKEY,
                                      0,
                                      KEY_READ,
                                      &hTapiKey))
    {
        gdwLineDevs = 0;
        gdwPhoneDevs = 0;
    }
    else
    {
        dwSize = sizeof(DWORD);

        if (ERROR_SUCCESS != RegQueryValueEx(hTapiKey,
                                             TEXT("Perf1"),
                                             NULL,
                                             &dwType,
                                             (LPBYTE)&gdwLineDevs,
                                             &dwSize))
        {
            gdwLineDevs = 0;
        }
        else
        {
            gdwLineDevs -= 'PERF';
        }

        dwSize = sizeof(DWORD);

        if (ERROR_SUCCESS != RegQueryValueEx(hTapiKey,
                                             TEXT("Perf2"),
                                             NULL,
                                             &dwType,
                                             (LPBYTE)&gdwPhoneDevs,
                                             &dwSize))
        {
            gdwPhoneDevs = 0;
        }
        else
        {
            gdwPhoneDevs -= 'PERF';
        }

        RegCloseKey(hTapiKey);
    }


    status = ERROR_SUCCESS; // for successful exit

    return status;

}

DWORD APIENTRY
CollectTapiPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the TAPI counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is written to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is written to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    //  Variables for reformatting the data

    ULONG SpaceNeeded;
    PDWORD pdwCounter;
    PERF_COUNTER_BLOCK *pPerfCounterBlock;
    TAPI_DATA_DEFINITION *pTapiDataDefinition;

    //  Variables for collecting data about TAPI Resouces

    LPWSTR                              lpFromString;
    LPWSTR                              lpToString;
    INT                                 iStringLength;

    // variables used for error logging

    DWORD                               dwDataReturn[2];
    DWORD                               dwQueryType;

    PPERFBLOCK                          pPerfBlock;
    static BOOL                         bFirst = TRUE;

    //
    // before doing anything else, see if Open went OK
    //

    if (!bInitOK)
    {
        // unable to continue because open failed.
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN)
    {
        // this routine does not service requests for data from
        // Non-NT computers
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;

        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS)
    {
        if ( !(IsNumberInUnicodeList (TapiDataDefinition.TapiObjectType.ObjectNameTitleIndex, lpValueName)))
        {

            // request received for data object not provided by this routine
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    pTapiDataDefinition = (TAPI_DATA_DEFINITION *) *lppData;

    SpaceNeeded = sizeof(TAPI_DATA_DEFINITION) +
                  SIZE_OF_TAPI_PERFORMANCE_DATA;

    if ( *lpcbTotalBytes < SpaceNeeded )
    {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;

        return ERROR_MORE_DATA;
    }

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    if (!bTapiSrvRunning)
    {
        CheckForTapiSrv();
    }

    pPerfBlock = (PPERFBLOCK)GlobalAlloc(GPTR, sizeof(PERFBLOCK));
	if (NULL == pPerfBlock)
	{
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
		return ERROR_SUCCESS;
	}

    if (!bTapiSrvRunning)
    {
        // don't do anything, but succeed

        FillMemory(pPerfBlock,
                   sizeof(PERFBLOCK),
                   0);

        pPerfBlock->dwLines = gdwLineDevs;
        pPerfBlock->dwPhones = gdwPhoneDevs;
    }
    else
    {
        pPerfBlock->dwSize = sizeof(PERFBLOCK);
        glpfnInternalPerformance (pPerfBlock);

        // don't count me as a client app!
        if (0 != pPerfBlock->dwClientApps)
        {
            pPerfBlock->dwClientApps--;
        }
    }

    memmove(pTapiDataDefinition,
            &TapiDataDefinition,
            sizeof(TAPI_DATA_DEFINITION));

    //
    //  Format and collect TAPI data from shared memory
    //

    pPerfCounterBlock = (PERF_COUNTER_BLOCK *) &pTapiDataDefinition[1];

    pPerfCounterBlock->ByteLength = SIZE_OF_TAPI_PERFORMANCE_DATA;

    pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

    // make sure we don't have funky values
    if (((LONG)pPerfBlock->dwTotalOutgoingCalls) < 0)
    {
        pPerfBlock->dwTotalOutgoingCalls = 0;
    }

    if (((LONG)pPerfBlock->dwTotalIncomingCalls) < 0)
    {
        pPerfBlock->dwTotalIncomingCalls = 0;
    }

    if (((LONG)pPerfBlock->dwCurrentOutgoingCalls) < 0)
    {
        pPerfBlock->dwCurrentOutgoingCalls = 0;
    }

    if (((LONG)pPerfBlock->dwCurrentIncomingCalls) < 0)
    {
        pPerfBlock->dwCurrentIncomingCalls = 0;
    }

    *pdwCounter =   pPerfBlock->dwLines;
    *++pdwCounter = pPerfBlock->dwPhones;
    *++pdwCounter = pPerfBlock->dwLinesInUse;
    *++pdwCounter = pPerfBlock->dwPhonesInUse;
    *++pdwCounter = pPerfBlock->dwTotalOutgoingCalls;
    *++pdwCounter = pPerfBlock->dwTotalIncomingCalls;
    *++pdwCounter = pPerfBlock->dwClientApps;
    *++pdwCounter = pPerfBlock->dwCurrentOutgoingCalls;
    *++pdwCounter = pPerfBlock->dwCurrentIncomingCalls;

    *lppData = (PVOID) ++pdwCounter;

    // update arguments for return

    *lpNumObjectTypes = 1;

    *lpcbTotalBytes = (DWORD)
        ((PBYTE) pdwCounter - (PBYTE) pTapiDataDefinition);

    GlobalFree(pPerfBlock);

    bFirst = FALSE;

    return ERROR_SUCCESS;
}


DWORD APIENTRY
CloseTapiPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to TAPI device performance counters

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{

    return ERROR_SUCCESS;

}

void CALLBACK LineCallbackFunc(DWORD dw1,
                               DWORD dw2,
                               DWORD dw3,
                               DWORD dw4,
                               DWORD dw5,
                               DWORD dw6)
{
}



//////////////////////////////////////////////////////////////////////
//
// PERF UTILITY STUFF BELOW!
//
//////////////////////////////////////////////////////////////////////
#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

ULONG                   ulInfoBufferSize = 0;


                              // initialized in Open... routines


DWORD  dwLogUsers = 0;        // count of functions using event log

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foreign" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    BOOL    bReturnValue;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not found

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimiter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList

BOOL
WINAPI
DllEntryPoint(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            ghInst = hDLL;

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            break;
        }
        case DLL_THREAD_ATTACH:

            break;

        case DLL_THREAD_DETACH:
        {
            break;
        }

    } // switch

    return TRUE;
}

void CheckForTapiSrv()
{
    SC_HANDLE               sc, scTapiSrv;
    SERVICE_STATUS          ServStat;


    sc = OpenSCManager (NULL, NULL, GENERIC_READ);

    if (NULL == sc)
    {
        return;
    }

    bTapiSrvRunning = FALSE;

    scTapiSrv = OpenService (sc, "TAPISRV", SERVICE_QUERY_STATUS);

    if (!QueryServiceStatus (scTapiSrv, &ServStat))
    {
    }

    if (ServStat.dwCurrentState != SERVICE_RUNNING)
    {
    }
    else
    {
        bTapiSrvRunning = TRUE;
    }

    if (bTapiSrvRunning)
    {
        if (!ghTapiInst)
        {
            ghTapiInst = LoadLibrary (SZTAPI32);

            glpfnInternalPerformance = (PERFPROC)GetProcAddress(
                ghTapiInst,
                SZINTERNALPERF
                );

            if (!glpfnInternalPerformance)
            {
            }
        }
    }

    CloseServiceHandle(scTapiSrv);
    CloseServiceHandle(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rca\rca.h ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

	RCA.h

Abstract:

	The module defines the constants, structures and function templates for
	the NDIS RCA

Author:

	Richard Machin (RMachin)


Revision History:

	Who         When        What
	--------	--------	----------------------------------------------
	RMachin     10-3-96     created
	JameelH     4-18-98     Cleanup
	SPATHER		4-20-99		Cleanup, separated out all NDIS components

--*/

#ifndef _RCA__H
#define _RCA__H

#include "mmsystem.h"
#define NOBITMAP
#include "mmreg.h"
#undef NOBITMAP
#include "ks.h"
#include "ksmedia.h"
#include <pxdebug.h>
#include <ntddk.h>
#include <windef.h>

#define	AUDIO_SINK_FLAG		1	

//
// Signature used for all pool allocs
//
#define rca_signature			' ACR'

#define MODULE_INIT				0x00010000
#define MODULE_NTINIT			0x00020000
#define MODULE_CO				0x00030000
#define MODULE_CL				0x00040000
#define MODULE_DEBUG			0x00050000
#define MODULE_CM				0x00060000
#define MODULE_UTIL				0x00070000
#define MODULE_CFG				0x00080000
#define MODULE_TAPI				0x00100000
#define MODULE_FLT				0x00200000
#define MODULE_STRM				0x00300000
#define MODULE_COCL				0x00400000
#define MODULE_NDIS				0x00500000
#define MODULE_KSNDIS			0x00600000

#ifndef ULONG_MAX
#define ULONG_MAX				0xffffffffUL
#endif

#if DBG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#if MY_ASSERT
#undef	ASSERT
#define	ASSERT(exp)	\
   if (!(exp)) \
   {\
      DbgPrint( #exp, __FILE__, __LINE__, NULL );\
      DbgBreakPoint();\
   }
      
#endif

#if PACKET_POOL_OPTIMIZATION    		
// SendPPOpt - Start
#define SENDPPOPT_NUM_BUCKETS 10000

extern LONG				g_alSendPPOptBuckets[SENDPPOPT_NUM_BUCKETS];
extern LONG				g_lSendPPOptOutstanding;
extern NDIS_SPIN_LOCK	g_SendPPOptLock;
// SendPPOpt - End


// RecvPPOpt - Start
#define RECVPPOPT_NUM_BUCKETS 10000

extern LONG				g_alRecvPPOptBuckets[RECVPPOPT_NUM_BUCKETS];
extern LONG				g_lRecvPPOptOutstanding;
extern NDIS_SPIN_LOCK	g_RecvPPOptLock;
// RecvPPOpt - End
#endif // PACKET_POOL_OPTIMIZATION

//
// Various constants used all over. 
//

#define MAXNUM_PIN_TYPES		2
#define MIN_PACKETS_POOL		40
#define MAX_PACKETS_POOL		10000
#define ID_DEVIO_PIN			1
#define ID_BRIDGE_PIN			0
#define RCA_SAP_REG_TIMEOUT		5000	// MS to block filterdispatchcreate waiting for SAP registration to finish.

//
// Structure and macros used to block / unblock the current thread.
//
typedef struct _RCABlockStruc {
	NDIS_EVENT 		Event;
	NDIS_STATUS 	TheStatus;
} RCABlockStruc, *PRCABlockStruc;


/*++
VOID
RCAInitBlockStruc(
	IN	RCABlockStruc		*pBlock
	);
--*/
#define RCAInitBlockStruc(pBlock)	NdisInitializeEvent(&(pBlock)->Event)

/*++
VOID
RCABlock(
	IN	RCABlockStruc		*pBlock,
	OUT	NDIS_STATUS		*pStatus
	);
--*/
#define RCABlock(pBlock, pStatus)				\
	{							\
		NdisWaitEvent(&(pBlock)->Event, 0);		\
		*(pStatus) = (pBlock)->TheStatus;			\
	}

/*++
VOID
RCABlockTimeOut(
	IN	RCABlockStruc		*pBlock,
	IN 	UINT			MsToWait
	OUT	NDIS_STATUS		*pStatus
	);
--*/
#define RCABlockTimeOut(pBlock, MsToWait, pStatus)		\
	{							\
		if (NdisWaitEvent(&(pBlock)->Event, MsToWait))	\
			*(pStatus) = (pBlock)->TheStatus;		\
		else						\
			*(pStatus) = STATUS_TIMEOUT;		\
	}


/*++
VOID
RCASignal(
	IN  RCABlockStruc		*pBlock,
	IN  UINT			Status
	);
--*/
#define RCASignal(pBlock, Status)				\
	{							\
		(pBlock)->TheStatus = Status;			\
		NdisSetEvent(&((pBlock)->Event));		\
	}



typedef ULONG_PTR		FILTER_TYPE;

#define	FilterTypeRender	(FILTER_TYPE)0
#define	FilterTypeCapture	(FILTER_TYPE)1

typedef struct _DEVICE_INSTANCE
{
	//
	// KS-managed header
	//
	KSDEVICE_HEADER			Header;
	KSPIN_CINSTANCES		PinInstances[ MAXNUM_PIN_TYPES ];
} DEVICE_INSTANCE, *PDEVICE_INSTANCE;


//
// The RCA Stream Header structure (this incorparates a KS Stream Header)
//

typedef struct _RCA_STREAM_HEADER {
	LIST_ENTRY			ListEntry;
	KSSTREAM_HEADER		Header;	
	PNDIS_PACKET		NdisPacket;	// CLEANUP: Take this out.
	ULONG				RefCount;	// FIXME: NOT YET IMPLEMENTED
} RCA_STREAM_HEADER, *PRCA_STREAM_HEADER;


//
// The Stream Header Pool structure
//
typedef struct _RCA_SH_POOL {
	LONG		    		FailCount; 
	IO_STATUS_BLOCK 		IoStatus;	// HACK:Common IO Status block for all stream IRPs
	NPAGED_LOOKASIDE_LIST	LookAsideList;	
} RCA_SH_POOL, *PRCA_SH_POOL;


//
// Our global device extension
//
PDEVICE_INSTANCE	DeviceExtension;

//
// Globals
//
extern const KSDISPATCH_TABLE FilterDispatchTable;
extern const KSPIN_CINSTANCES PinInstances[MAXNUM_PIN_TYPES];

//
// Here's where we keep info that's common across FDOs (shared
// by capture and render devices)
//
typedef struct RCA_GLOBAL
{
	ULONG					Status;
	LONG					QueueSize;
	NDIS_SPIN_LOCK			SpinLock;				// SpinLock for this structure
	PDRIVER_OBJECT			pDriverObject;  		// passed in DriverEntry
	PDEVICE_OBJECT			pFunctionalDeviceObject;// created by IoCreateDevice
	KSOBJECT_CREATE_ITEM	FilterCreateItems[2];
	RCA_SH_POOL				SHPool;		// Pool of stream headers that Capture devices use
	BOOL					bProtocolInitialized; // True if RCACoNdisInitialize has been called.
}  RCA_GLOBAL, *PRCA_GLOGBAL;

extern RCA_GLOBAL RcaGlobal;

#define	RCA_ACQUIRE_GLOBAL_LOCK()	RCAAcquireLock(&RcaGlobal.SpinLock);

#define	RCA_RELEASE_GLOBAL_LOCK()	RCAReleaseLock(&RcaGlobal.SpinLock);



//
// Pin constants
//

// 2 PINs on each type of filter (capture or render): bridge-to-net, and dataio
extern const KSPIN_DESCRIPTOR PinDescriptors[2];	// CLEANUP: This is sketchy, see if it's really needed.

typedef struct _FILTER_CONNECTION
{
	LIST_ENTRY	  		ListEntry;		 // used only for destination lists
	PFILE_OBJECT		FileObject;		 // The connected pin file object.
	PFILE_OBJECT		NextFileObject;		 // The chained file object
} FILTER_CONNECTION;

typedef struct
{
	KSOBJECT_HEADER			Header;
	ULONG			        PinId;
} PIN_INSTANCE_HEADER, *PPIN_INSTANCE_HEADER;

typedef struct _FILTER_INSTANCE	FILTER_INSTANCE, *PFILTER_INSTANCE;

typedef struct
{
	PIN_INSTANCE_HEADER		InstanceHdr;
	LIST_ENTRY				EventQueue;
	FAST_MUTEX				EventQueueLock;
	KSSTATE					DeviceState;
	PVOID					VcContext;
	PFILTER_INSTANCE		FilterInstance;
	BOOL					ConnectedAsSink;
	LIST_ENTRY				ActiveQueue;
	KSPIN_LOCK				QueueLock;
	PVOID					AllocatorObject;
} PIN_INSTANCE_DEVIO, *PPIN_INSTANCE_DEVIO;


typedef struct
{
	PIN_INSTANCE_HEADER		InstanceHdr;
	LIST_ENTRY				EventQueue;
	FAST_MUTEX				EventQueueLock;
	KSSTATE					Unused;
	PVOID					VcContext;
	NDIS_WORK_ITEM			WorkItem;
	BOOL					bWorkItemQueued;
	LIST_ENTRY				WorkQueue;
	PFILTER_INSTANCE		FilterInstance;
	KSPIN_LOCK				SpinLock;
	KIRQL					OldIrql;
	RCABlockStruc			Block;
	BOOL					SignalMe;   
	PKSDATAFORMAT			pDataFormat;
	LONGLONG				PendingSendsCount;
	RCABlockStruc			PendingSendsBlock;
	BOOL					SignalWhenSendsComplete;
} PIN_INSTANCE_BRIDGE, *PPIN_INSTANCE_BRIDGE;


#if DBG
#define	RCA_ACQUIRE_BRIDGE_PIN_LOCK(pBridgePin)	\
{\
	KeAcquireSpinLock(&((pBridgePin)->SpinLock), &((pBridgePin)->OldIrql));\
	if (RCADebugLevel == RCA_LOCKS) {\
		DbgPrint("BRIDGE PIN LOCK (0x%x) ACQUIRED at module %x, line %d\n",\
			 &((pBridgePin)->SpinLock), MODULE_NUMBER >> 16, __LINE__);\
	}\
}

#define	RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePin)	\
{\
	KeReleaseSpinLock(&((pBridgePin)->SpinLock), (pBridgePin)->OldIrql);\
	if (RCADebugLevel == RCA_LOCKS) { \
		DbgPrint("BRIDGE PIN LOCK (0x%x) RELEASED at module %x, line %d\n",\
			 &((pBridgePin)->SpinLock), MODULE_NUMBER >> 16, __LINE__);\
	} \
}

#else 
#define	RCA_ACQUIRE_BRIDGE_PIN_LOCK(pBridgePin)		KeAcquireSpinLock(&((pBridgePin)->SpinLock), &((pBridgePin)->OldIrql));

#define	RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePin)		KeReleaseSpinLock(&((pBridgePin)->SpinLock), (pBridgePin)->OldIrql);




#endif

typedef struct _FILTER_INSTANCE
{
	KSOBJECT_HEADER				Header;
	FILTER_TYPE					FilterType;
	KMUTEX						ControlMutex;
	PFILE_OBJECT				PinFileObjects[SIZEOF_ARRAY(PinDescriptors)];
	PPIN_INSTANCE_BRIDGE		BridgePin;
	PPIN_INSTANCE_DEVIO			DevIoPin;
	PKSDATAFORMAT_WAVEFORMATEX 	WaveFormat;
	KSDATAFORMAT				DataFormat;
	PFILE_OBJECT				NextFileObject, ConnectedFileObject;
	FILTER_CONNECTION			Connections[2];
	KSPIN_CINSTANCES			PinInstances[2];
} FILTER_INSTANCE, *PFILTER_INSTANCE;

NTSTATUS
PnpAddDevice(
	IN	PDRIVER_OBJECT	DriverObject,
	IN	PDEVICE_OBJECT	PhysicalDeviceObject
	);

NTSTATUS
PinDispatchCreate(
	IN	PDEVICE_OBJECT	DeviceObject,
	IN	PIRP			Irp
	);

#define	LinkDoubleAtHead(_pHead, _p, Next, Prev)			\
	{								\
		(_p)->Next = (_pHead);					\
		(_p)->Prev = &(_pHead);					\
		if ((_pHead) != NULL)					\
		(_pHead)->Prev = &(_p)->Next;				\
			(_pHead) = (_p);				\
	}

#define	LinkDoubleAtTail(_pThis, _pLast, Next, Prev)			\
	{								\
		(_pLast)->Next = (_pThis);				\
		(_pThis)->Prev = &(_pLast)->Next;			\
		(_pThis)->Next = NULL;					\
	}

#define	InsertDoubleBefore(_pThis, _pBefore, Next, Prev)		\
	{								\
		(_pThis)->Next = (_pBefore);				\
		(_pThis)->Prev = (_pBefore)->Prev;			\
		(_pBefore)->Prev = &(_pThis)->Next;			\
		*((_pThis)->Prev) = (_pThis);				\
	}

#define	UnlinkDouble(_p, Next, Prev)					\
	{								\
		*((_p)->Prev) = (_p)->Next;				\
		if ((_p)->Next != NULL)					\
			(_p)->Next->Prev = (_p)->Prev;			\
	}

//
// Work Queue list entry
//

typedef struct
{
	LIST_ENTRY  			ListEntry;
	union {
		PVOID			    PacketContext;
		PRCA_STREAM_HEADER	StreamHeader;
	};

	union { 
  //  	PRCA_VC			pRcaVc;	//CLEANUP: Remove this
		PMDL			Mdl;
	};

	BOOL					bFreeThisPacket;

} WORK_ITEM, PKT_RSVD, *PWORK_ITEM, *PPKT_RSVD;

#define	PKT_RSVD_FROM_PKT(_pPkt)	((PPKT_RSVD)((_pPkt)->ProtocolReserved))
#define	WORK_ITEM_FROM_PKT(_pPkt)	((PWORK_ITEM)((_pPkt)->ProtocolReserved))



#ifndef STRUCT_OF
#define STRUCT_OF(_Type, _Addr, _Field)	CONTAINING_RECORD(_Addr, _Type, _Field)
#endif

#ifndef MAX
#define MAX(Fred, Shred)	(((Fred) > (Shred)) ? (Fred) : (Shred))
#endif // MAX


#ifndef MIN
#define MIN(Fred, Shred)	(((Fred) < (Shred)) ? (Fred) : (Shred))
#endif // MIN


/*++
VOID
RCAMemSet(
	IN	POPAQUE				Pointer,
	IN	UCHAR				Value,
	IN	ULONG				Length
	);
--*/
#define RCAMemSet(Pointer, Value, Length)	NdisFillMemory((PUCHAR)(Pointer), (ULONG)(Length), (UCHAR)(Value))

/*++
VOID
RCAMemCopy(
	IN	POPAQUE				Destn,
	IN	POPAQUE				Source,
	IN	ULONG				Length
	);
--*/
#define RCAMemCopy(Destn, Source, Length)	NdisMoveMemory((Destn), (Source), (Length))


#define RCA_TAG	 ((ULONG)'FACR')	 

#if DBG
#undef AUDIT_MEM 
#define AUDIT_MEM 1
#endif

/*++
PVOID
RCAAllocMem(
	IN  ULONG				Size
	);
--*/
#if AUDIT_MEM


#define RCAAllocMem(Pointer, TYPE, Size)	Pointer = (TYPE *)RCAAuditAllocMem((PVOID)(&(Pointer)), Size, _FILENUMBER, __LINE__);
#else // AUDIT_MEM
#define	RCAAllocMem(Pointer, TYPE, Size)	NdisAllocateMemoryWithTag((PVOID)(&Pointer), (ULONG)Size, RCA_TAG)
#endif // AUDIT_MEM

/*++
VOID
RCAFreeMem(
	IN	PVOID			Pointer
	);
--*/
#if AUDIT_MEM
#define RCAFreeMem(Pointer)	RCAAuditFreeMem((PVOID)Pointer)
#else
#define RCAFreeMem(Pointer)	NdisFreeMemory((PVOID)(Pointer), 0, 0)
#endif // AUDIT_MEM



/*++
VOID
RCAInitLock(
	IN  PNDIS_SPIN_LOCK		pLock
	);
--*/
#define RCAInitLock(pLock)	       	NdisAllocateSpinLock(pLock)

/*++
VOID
RCAFreeLock(
	IN  PNDIS_SPIN_LOCK		pLock
	);
--*/
#define RCAFreeLock(pLock)		NdisFreeSpinLock(pLock)

/*++
VOID
RCAAcquireLock(
	IN  PNDIS_SPIN_LOCK		pLock
	);
--*/
#define RCAAcquireLock(pLock)		NdisAcquireSpinLock(pLock)

/*++
VOID
RCAReleaseLock(
	IN  PNDIS_SPIN_LOCK		pLock
	);
--*/
#define RCAReleaseLock(pLock)		NdisReleaseSpinLock(pLock)


extern
VOID
RCASetMemory(
	IN	PUCHAR				pStart,
	IN	UCHAR				Value,
	IN	ULONG				NumberOfBytes
	);


extern
BOOLEAN
RCAInit(
	VOID
	);



extern
VOID
RCAUnload(
	IN	PDRIVER_OBJECT			DriverObject
	);

extern
NTSTATUS
FilterTopologyProperty(
	IN	PIRP				Irp,
	IN	PKSPROPERTY			Property,
	IN	OUT PVOID			Data
	);

extern
NTSTATUS
FilterPinProperty(
	IN	PIRP				Irp,
	IN	PKSPROPERTY			Property,
	IN	OUT PVOID			Data
	);

extern
NTSTATUS
FilterPinInstances(
	IN	PIRP				Irp,
	IN	PKSP_PIN			Pin,
	OUT PKSPIN_CINSTANCES	Instances
	);

extern
NTSTATUS
FilterPinIntersection(
	IN	PIRP				Irp,
	IN	PKSP_PIN			Pin,
	OUT	PVOID				Data
	);

extern
NTSTATUS
FilterDispatchClose(
	IN	PDEVICE_OBJECT			DeviceObject,
	IN	PIRP				Irp
	);

extern
NTSTATUS
FilterDispatchIoControl(
	IN	PDEVICE_OBJECT			DeviceObject,
	IN	PIRP				Irp
	);

extern
NTSTATUS
PinDispatchCreate(
	IN	PDEVICE_OBJECT			DeviceObject,
	IN	PIRP				Irp
	);

extern
NTSTATUS
FilterDispatchCreate(
	IN	PDEVICE_OBJECT			DeviceObject,
	IN	PIRP				Irp
	);

extern
VOID
RCAReceiveCallback(
				   IN	PVOID			RcaVcContext,
				   IN 	PVOID			ClientReceiveContext,
				   IN	PNDIS_PACKET	pPacket
				   );



extern
VOID
RCASendCompleteCallback(
						IN	PVOID		RcaVcContext, 
						IN	PVOID		ClientSendContext,
						IN	PVOID		PacketContext,
						IN	PMDL		pSentMdl,
						IN	NDIS_STATUS	Status
						);

extern
VOID 
RCAVcCloseCallback(
				   IN	PVOID	RcaVcContext, 
				   IN	PVOID	ClientReceiveContext,
				   IN	PVOID	ClientSendContext
				   );


extern
NTSTATUS
WriteStream(
	IN	PIRP				Irp,
	IN	PPIN_INSTANCE_DEVIO		PinInstance
	);

extern
NTSTATUS
ReadStream(
	IN	PIRP				Irp,
	IN	PPIN_INSTANCE_DEVIO		PinInstance
	);

extern
NTSTATUS
PinDispatchIoControl(
	IN	PDEVICE_OBJECT			DeviceObject,
	IN	PIRP				Irp
	);

extern
NTSTATUS
InitializeDevIoPin(
	IN	PIRP				Irp,
	IN	BOOLEAN				Read,
	IN	PFILTER_INSTANCE		FilterInstance,
	IN	PKSDATAFORMAT			DataFormat
	);

extern
NTSTATUS
PinDispatchClose(
	IN	PDEVICE_OBJECT			DeviceObject,
	IN	PIRP				Irp
	);

extern
NTSTATUS
GetInterface(
	IN	PIRP				Irp,
	IN	PKSPROPERTY			Property,
	OUT PKSPIN_INTERFACE			Interface
	);


extern VOID 
RCAIoWorker(
	IN 	PNDIS_WORK_ITEM			pNdisWorkItem,
	IN	PVOID				Context
	);

extern
NTSTATUS
RCAIoComplete(
	IN	PDEVICE_OBJECT			DeviceObject,
	IN	PIRP		        	Irp,
	IN	PVOID				Context  
	);


extern 
VOID
RCASHPoolInit(
	       VOID
	      );


extern
PRCA_STREAM_HEADER
RCASHPoolGet(
	      VOID
	     );


extern
VOID                      
RCASHPoolReturn(
		 IN PRCA_STREAM_HEADER StreamHeader
		);


extern
VOID            
RCASHPoolFree(
	       VOID
	      );


extern
NTSTATUS
PinDeviceState(
	IN	PIRP				Irp,
	IN	PKSPROPERTY			Property,
	IN	OUT PKSSTATE			DeviceState
	);
	
extern
NTSTATUS
RCAGenericIntersection(
			  IN 	PIRP		Irp,
			  IN 	PKSDATARANGE	DataRange,
			  IN	ULONG		OutputBufferLength,
			  OUT 	PVOID		Data
			  );


extern
VOID
RCADumpGUID(
			INT		DebugLevel,	
			GUID 	*Guid
			);


extern
NTSTATUS 
RCADumpKsPropertyInfo(
					  INT	DebugLevel,
					  PIRP	pIrp
					  );


#if DBG
#define RCA_GET_ENTRY_IRQL(Irql)	Irql = KeGetCurrentIrql()

#define RCA_CHECK_EXIT_IRQL(EntryIrql)						\
{										\
	KIRQL	ExitIrql;							\
										\
	ExitIrql = KeGetCurrentIrql();						\
	if (ExitIrql != EntryIrql)						\
	{									\
		DbgPrint("File %s, Line %d, Exit IRQ %d != Entry IRQ %d\n", 	\
				__FILE__, __LINE__, ExitIrql, EntryIrql);	\
		DbgBreakPoint();						\
	}									\
}
#else
#define RCA_GET_ENTRY_IRQL(Irql)
#define RCA_CHECK_EXIT_IRQL(EntryIrql)
#endif // DBG



#endif  // _RCA__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rca\rcacocl.c ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

	RCACoCl.c

Abstract:

	The module implements the RCA Co-NDIS client. 

Author:

	Shyam Pather (SPATHER)


Revision History:

	Who         When        What
	--------	--------	----------------------------------------------
	SPATHER		04-20-99	Created / adapted from original RCA code by RMachin/JameelH

--*/

#include <precomp.h>

#define MODULE_NUMBER	MODULE_COCL
#define _FILENUMBER		'LCOC' 

#if PACKET_POOL_OPTIMIZATION    		
// RecvPPOpt - Start
LONG			g_alRecvPPOptBuckets[RECVPPOPT_NUM_BUCKETS];
LONG			g_lRecvPPOptOutstanding;
NDIS_SPIN_LOCK	g_RecvPPOptLock;
// RecvPPOpt - End
#endif


BOOLEAN
RCAReferenceVc(
	IN  PRCA_VC				pRcaVc
	)
{
	PRCA_ADAPTER	pAdapter = pRcaVc->pAdapter;
	BOOLEAN			rc = FALSE;

	RCADEBUGP(RCA_INFO, ("RCAReferenceVc: Enter\n"));

	ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);

	if ((pRcaVc->Flags & VC_CLOSING) == 0)
	{
		pRcaVc->RefCount++;
		rc = TRUE;
	}

	RCADEBUGP(RCA_LOUD, ("RCAReferenceVc: pRcaVc (0x%x) ref count is %d\n", 
						 pRcaVc, pRcaVc->RefCount));

	RELEASE_SPIN_LOCK(&pAdapter->SpinLock);

	RCADEBUGP(RCA_INFO, ("RCAReferenceVc: Exit, returning 0x%x\n", rc));

	return(rc);
}



VOID
RCADereferenceVc(
	IN  PRCA_VC				pRcaVc
	)
{
	PRCA_ADAPTER	pAdapter = pRcaVc->pAdapter;

	RCADEBUGP(RCA_INFO, ("RCADerefenceVc: Enter\n"));

	ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);

	pRcaVc->RefCount--;

	RCADEBUGP(RCA_LOUD, ("RCADereferenceVc: pRcaVc (0x%x) ref count is %d\n", 
					 pRcaVc, pRcaVc->RefCount));	

	if (pRcaVc->RefCount == 0)
	{

		ASSERT((pRcaVc->Flags & VC_ACTIVE) == 0);

		//
		// Take VC out of the adapter list
		//
		UnlinkDouble(pRcaVc, NextVcOnAdapter, PrevVcOnAdapter);
		RCADEBUGP(RCA_LOUD, ("RCADereferenceVc: Took vc out of list\n"));

		RCAFreeLock(&(pRcaVc->Lock));

		RCAFreeMem(pRcaVc);
	}

	RELEASE_SPIN_LOCK(&pAdapter->SpinLock);

	RCADEBUGP(RCA_INFO, ("RCADerefenceVc: Exit\n")); 	
}



VOID
RCACoSendComplete(
	IN	NDIS_STATUS			Status,
	IN	NDIS_HANDLE			ProtocolVcContext,
	IN	PNDIS_PACKET		pNdisPacket)
/*++

Routine Description
	Handle completion of a send. All we need to do is free the resources and
	complete the event.

Arguments
	Status			  - Result of the send
	ProtocolVcContext	- RCA VC
	Packet			  - The Packet sent

Return Value:
	None

--*/
{

	PRCA_PROTOCOL_CONTEXT	pProtocolContext = &GlobalContext;
	PMDL 					pMdl;
	
	RCADEBUGP(RCA_INFO, ("RCACoSendComplete: enter. VC=%x, Packet=%x\n", ProtocolVcContext, pNdisPacket));

	InterlockedDecrement(&((PRCA_VC)ProtocolVcContext)->PendingSends);

	//
	// Get the MDL out of the packet and give it back to the client.
	//

	pMdl = (PMDL) pNdisPacket->Private.Head;
    		
	ACQUIRE_SPIN_LOCK(&(((PRCA_VC)ProtocolVcContext)->SpinLock));

	if (pProtocolContext->Handlers.SendCompleteCallback) {

		pProtocolContext->Handlers.SendCompleteCallback((PVOID)ProtocolVcContext,
														((PRCA_VC)ProtocolVcContext)->ClientSendContext,
														PKT_RSVD_FROM_PKT(pNdisPacket)->PacketContext,
														pMdl,
														Status);
	} 

    RELEASE_SPIN_LOCK(&(((PRCA_VC)ProtocolVcContext)->SpinLock));

#if PACKET_POOL_OPTIMIZATION    		
    // SendPPOpt - Start
			
	NdisAcquireSpinLock(&g_SendPPOptLock);
		    
	g_lSendPPOptOutstanding--;

	NdisReleaseSpinLock(&g_SendPPOptLock);

	// SendPPOpt - End
#endif
	
	NdisFreePacket(pNdisPacket);

	RCADEBUGP(RCA_LOUD, ("RCACoSendComplete: exit\n"));
}




PNDIS_PACKET
RCAAllocCopyPacket(
	IN  PRCA_VC				pRcaVc,
	IN  PNDIS_PACKET		pNdisPacket
	)
/*++

Routine Description:

	Allocate and copy a received packet to a private packet.
	Note: We set the returned packet's status to NDIS_STATUS_RESOURCES,
	which lets us know later on that this packet belongs to us and
	not to the miniport.

Arguments:

	pRcaVc  - Pointer to our Adapter structure
	pNdisPacket - Packet to be copied.

Return Value:
	The allocated copy of the given packet, if successful. NULL otherwise.

--*/
{
	PUCHAR			pBuffer;
	NDIS_STATUS		Status;
	PNDIS_PACKET	pNewPacket;
	PNDIS_BUFFER	pNdisBuffer, pNewBuffer;
	ULONG			TotalLength;
	ULONG			BytesCopied;

	pBuffer = NULL;
	pNewPacket = NULL;
	pNewBuffer = NULL;

	do
	{
 		//
		//  Copy the received packet into this one. First get the
		//  length to copy.
		//
		NdisQueryPacket(pNdisPacket,
						NULL,
						NULL,
						NULL,
						&TotalLength);


		RCAAllocMem(pBuffer, UCHAR, TotalLength);
		if (pBuffer == NULL)
		{
			break;
		}

		//
		//  Get a new NDIS buffer.
		//
		NdisAllocateBuffer(&Status,
						   &pNewBuffer,
						   pRcaVc->pAdapter->RecvBufferPool,
						   pBuffer,
						   TotalLength);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		//  Allocate a new packet.
		//

#if PACKET_POOL_OPTIMIZATION    		
		// RecvPPOpt - Start
			
		NdisAcquireSpinLock(&g_RecvPPOptLock);
		
		g_alRecvPPOptBuckets[g_lRecvPPOptOutstanding]++;

		g_lRecvPPOptOutstanding++;

		NdisReleaseSpinLock(&g_RecvPPOptLock);

        // RecvPPOpt - End
#endif

		NdisAllocatePacket(&Status,
				   &pNewPacket,
				   pRcaVc->pAdapter->RecvPacketPool);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		NDIS_SET_PACKET_STATUS(pNewPacket, 0);

		//
		//  Link the buffer to the packet.
		//
		NdisChainBufferAtFront(pNewPacket, pNewBuffer);

		//copy the packet		  

		NdisCopyFromPacketToPacket(pNewPacket,
					   0,  // Destn offset
					   TotalLength,
					   pNdisPacket,
					   0,  // Src offset
					   &BytesCopied);

		RCAAssert(TotalLength == BytesCopied);
		NdisAdjustBufferLength(pNewBuffer, TotalLength);

	} while (FALSE);

	if (pNewPacket != (PNDIS_PACKET)NULL)
	{
		NDIS_SET_PACKET_STATUS(pNewPacket, NDIS_STATUS_RESOURCES);
	}
	else
	{
		if (pNewBuffer != NULL)
		{
			NdisFreeBuffer(pNewBuffer);
		}

		if (pBuffer != NULL)
		{
			RCAFreeMem(pBuffer);
		}
	}

	return(pNewPacket);
}



UINT
RCACoReceivePacket(
		   IN	NDIS_HANDLE		ProtocolBindingContext,
		   IN	NDIS_HANDLE		ProtocolVcContext,
		   IN	PNDIS_PACKET	pNdisPacket
		  )

/*++

Routine Description:

	Called by NDIS when a packet is received on a VC owned
	by RCA. If there's a 'streamto' device indicated in teh VC,
	we get an IRP, point the IR at teh MDL, and send it to
	the next streaming driver.

	If there is no 'streamto' device, since this is 'live' data
	we currently dump the packet.


Arguments:

	ProtocolBindingContext	  - our ClientBind structure for this adapter
	ProtocolVcContext			- our VC structure
	pNdisPacket				 - NDIS packet

Return Value:

	Success, whether we dumped or not.

--*/
{
	PRCA_PROTOCOL_CONTEXT 	pProtocolContext = &GlobalContext;
	PFN_RCARECEIVE_CALLBACK pfnReceiveCallback;
	NDIS_STATUS				Status = 0;
	PRCA_VC					pRcaVc = (PRCA_VC) ProtocolVcContext;
	PNDIS_PACKET			pCopiedPacket, pPacket;
	UINT					PacketRefs = 0;

	RCADEBUGP(RCA_INFO, ("RCACoReceivePacket: Enter\n"));

	do {

		ACQUIRE_SPIN_LOCK(&pRcaVc->SpinLock);

		pfnReceiveCallback = pProtocolContext->Handlers.ReceiveCallback;

		if (pfnReceiveCallback == NULL ||
			pRcaVc->ClientReceiveContext == NULL)  {

			PacketRefs = 0;
            RELEASE_SPIN_LOCK(&pRcaVc->SpinLock);

			break;
		}

		if (NDIS_GET_PACKET_STATUS (pNdisPacket) == NDIS_STATUS_RESOURCES) {  
			//
			// Miniport's short on resources. Copy the packet. 
			//

			RCADEBUGP(RCA_LOUD, ("RCACoReceivePacket: Miniport is low on resources, have to copy packet\n"));

			pCopiedPacket = RCAAllocCopyPacket(pRcaVc, pNdisPacket);
			PacketRefs = 0;

			if (pCopiedPacket == NULL) {
				RCADEBUGP(RCA_ERROR, ("RcaCoReceivePacket: Failed to copy packet\n"));
				RELEASE_SPIN_LOCK(&pRcaVc->SpinLock);
				break;
			}

			pPacket = pCopiedPacket;

			WORK_ITEM_FROM_PKT(pPacket)->bFreeThisPacket = TRUE;

		} else {
			PacketRefs = 1;
			pPacket = pNdisPacket;

			WORK_ITEM_FROM_PKT(pPacket)->bFreeThisPacket = FALSE;
		}

		pfnReceiveCallback((PVOID)pRcaVc,
						   pRcaVc->ClientReceiveContext,
						   pPacket);

        RELEASE_SPIN_LOCK(&pRcaVc->SpinLock);
		
	} while (FALSE);
	

	RCADEBUGP(RCA_INFO,("CoReceivePacket: Exit return %lu\n", PacketRefs));
	return(PacketRefs); 
}


VOID
RCAReceiveComplete(
				   IN	NDIS_HANDLE	ProtocolBindingContext
				   )
{
	RCADEBUGP(RCA_INFO, (" RCACoReceiveComplete: Enter\n"));

	RCADEBUGP(RCA_INFO, (" RCACoReceiveComplete: Exit\n"));
}


NDIS_STATUS
RCACreateVc(
	IN	NDIS_HANDLE 	ProtocolAfContext,
	IN	NDIS_HANDLE		NdisVcHandle,
	OUT PNDIS_HANDLE	pProtocolVcContext
	)
/*++

Routine Description:

	Entry point called by NDIS when the Call Manager wants to create
	a new endpoint (VC) for a new inbound call on our SAP.

	We accept the VC and do the main part of the work in our RCAIncomingCall
	function.

Arguments:

	ProtocolAfContext	- Actually a pointer to the client bind structure we specified on OpenAddressFamily
	NdisVcHandle		- Handle for this VC for all future references
	pProtocolVcContext  - Place where we (protocol) return our context for the VC

Return Value:

	NDIS_STATUS_SUCCESS if we could create a VC
	NDIS_STATUS_RESOURCES otherwise

--*/
{
	PRCA_ADAPTER		pAdapter;
	PRCA_VC				pRcaVc;
	NDIS_STATUS			Status = NDIS_STATUS_SUCCESS;

	RCADEBUGP(RCA_INFO, ("RCACreateVc - Enter\n"));

	pAdapter = (PRCA_ADAPTER)ProtocolAfContext;

	RCADEBUGP(RCA_LOUD, ("RCACreateVc: pAdapter is 0x%x\n", pAdapter));

	do
	{
		//
		// Allocate a new VC structure. 
		//

		RCAAllocMem(pRcaVc, RCA_VC, sizeof(RCA_VC));
	
		if(pRcaVc != (PRCA_VC)NULL)
		{
			RCADEBUGP(RCA_LOUD, ("RCACreateVc: Allocated Vc 0x%x\n", pRcaVc));
			
			//
			// Initialize the interesting fields.
			//
			RCAMemSet(pRcaVc, 0, sizeof(RCA_VC));
#if DBG
			pRcaVc->rca_sig = rca_signature;
#endif
			pRcaVc->pAdapter = pAdapter;

			pRcaVc->RefCount = 1;
			
            NdisAllocateSpinLock(&pRcaVc->SpinLock);
			
			pRcaVc->NdisVcHandle = NdisVcHandle;

			ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);

			LinkDoubleAtHead(pAdapter->VcList, pRcaVc, NextVcOnAdapter, PrevVcOnAdapter);

			RELEASE_SPIN_LOCK(&pAdapter->SpinLock);
			
			
		} else {
			RCADEBUGP(RCA_ERROR, ("RCACreateVc: Failed to allocate VC structure, "
								  "setting Status = NDIS_STATUS_RESOURCES\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		*pProtocolVcContext = (NDIS_HANDLE)pRcaVc;

	} while (FALSE);

	RCADEBUGP(RCA_INFO, ("RCACreateVc: Exit, returning Status 0x%x\n", Status));

	return(Status);
}


NDIS_STATUS
RCADeleteVc(
	IN NDIS_HANDLE		ProtocolVcContext
	)
/*++

Routine Description:

	Handles requests from a call mgr to delete a VC.
	
	We need to delete the VC pointer
	
	At this time, this VC structure should be free of any calls, and we
	simply free it.

Arguments:

	ProtocolVcContext	- pointer to our VC structure

Return Value:

	NDIS_STATUS_SUCCESS always

--*/
{
	PRCA_VC				pRcaVc;
	NDIS_STATUS			Status = NDIS_STATUS_SUCCESS;
	PRCA_ADAPTER			pAdapter;
	
	RCADEBUGP(RCA_INFO, ("RCADeleteVc: Enter\n"));
	
	pRcaVc = (PRCA_VC)ProtocolVcContext;
	pAdapter = pRcaVc->pAdapter;

	RCADEBUGP(RCA_INFO, ("RCADeleteVc: pRcaVc is 0x%x\n", pRcaVc));
 
	ASSERT((pRcaVc->ClientReceiveContext == NULL) && (pRcaVc->ClientSendContext == NULL));

	ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);

	pRcaVc->ClosingState |= CLOSING_DELETE_VC;
	
	RELEASE_SPIN_LOCK(&pAdapter->SpinLock);

    RCADereferenceVc(pRcaVc);

    ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);

 	if (pAdapter->VcList == NULL) {
	    
	    RCADEBUGP(RCA_LOUD, ("RCADeleteVc: All VCs gone, unblocking RCADeactivateAdapter().\n"));
	    	    
		if (pAdapter->BlockedOnClose) { 
			RCASignal(&pAdapter->CloseBlock, Status);
	    }

	} else {
	    RCADEBUGP(RCA_INFO, ("RCADeleteVc: There are still some VCs remaining.\n"));
	}

    RELEASE_SPIN_LOCK(&pAdapter->SpinLock);

	return(NDIS_STATUS_SUCCESS);
}


NDIS_STATUS
RCAIncomingCall(
	IN	NDIS_HANDLE				ProtocolSapContext,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	OUT PCO_CALL_PARAMETERS	pCallParams
	)
/*++

Routine Description:

	This handler is called when there is an incoming call matching:
	  - a SAP we registered on behalf of a client
	  - our own SAP (systemwide RCA for this adapter/AF.


Arguments:

	ProtocolSapContext		- Pointer to our SAP structure
	ProtocolVcContext		- Pointer to our RCA_VC structure
	pCallParameters			- Call parameters

Return Value:

	NDIS_STATUS_SUCCESS if we accept this call
	NDIS_STATUS_FAILURE if we reject it.

--*/
{
	PRCA_PROTOCOL_CONTEXT	pProtocolContext = &GlobalContext;
	PRCA_VC					pRcaVc = (PRCA_VC)ProtocolVcContext;
	ULONG					HashIndex = HASH_VC((ULONG_PTR)pRcaVc);

	RCADEBUGP(RCA_INFO, ("RCAIncomingCall: Adapter: 0x%x, RCAVC: 0x%x, pCallParams: 0x%x\n",
						 pRcaVc->pAdapter, pRcaVc, pCallParams));

	ACQUIRE_SPIN_LOCK(&pProtocolContext->SpinLock);

	RCADEBUGP(RCA_LOUD, ("RCAIncomingCall: Acquired global protocol context lock\n"));

	//
	//  Stick the RCA VC in the Hash Table at the hashed position.
	//
	LinkDoubleAtHead(pProtocolContext->VcHashTable[HashIndex], pRcaVc, NextVcOnHash, PrevVcOnHash);

	RELEASE_SPIN_LOCK(&pProtocolContext->SpinLock);
	
	RCADEBUGP(RCA_LOUD, ("RCAIncomingCall: Release global protocol context lock\n"));
		
	//
	// Copy the call parameters for use later.
	//

	RtlCopyMemory(&pRcaVc->CallParameters, pCallParams, sizeof(CO_CALL_PARAMETERS));

	//
	// Accept the call
	//
	NdisClIncomingCallComplete(NDIS_STATUS_SUCCESS,
							   pRcaVc->NdisVcHandle,
							   pCallParams);

	RCADEBUGP(RCA_INFO, ("RCAIncomingCall: Exit - Returning NDIS_STATUS_SUCCESS\n"));

	return(NDIS_STATUS_SUCCESS);
}


VOID
RCAIncomingCloseCall(
	IN	NDIS_STATUS		closeStatus,
	IN	NDIS_HANDLE		ProtocolVcContext,
	IN	PVOID			CloseData OPTIONAL,
	IN	UINT			Size OPTIONAL
	)
{
	PRCA_PROTOCOL_CONTEXT	pProtocolContext = &GlobalContext;
	PRCA_VC					pRcaVc;
	NDIS_STATUS				Status = NDIS_STATUS_PENDING;

	RCADEBUGP(RCA_INFO, ("RCAIncomingCloseCall: Enter\n"));
	
	//
	// First close the call from our perspective, then let the KS client know that the
	// call is closed by invoking the VC close callback. 
	//
	pRcaVc = (PRCA_VC)ProtocolVcContext;

    Status = RCACoNdisCloseCallOnVcNoWait((PVOID)pRcaVc);
	
	//
	// Call this callback only if we have either a send or a receive client
	// context - if we don't have either, assume no-one cares that this
	// VC is closing. The actual callback should check for NULL contexts.
	//

	ACQUIRE_SPIN_LOCK(&pRcaVc->SpinLock);

	if ((pRcaVc->ClientReceiveContext || pRcaVc->ClientSendContext) &&
		(pProtocolContext->Handlers.VcCloseCallback)) {

		//
		// Release the spin lock here because this callback will very likely 
		// call RCACoNdisReleaseXXxVcContext() etc which will want the lock.
		//
		// There is a teensy tiny race here - if someone releases the VC context 
		// between when we release the lock and when we call the callback, we
		// could be in trouble. 
		//  
		RELEASE_SPIN_LOCK(&pRcaVc->SpinLock);

		pProtocolContext->Handlers.VcCloseCallback((PVOID)pRcaVc, 
												   pRcaVc->ClientReceiveContext,
												   pRcaVc->ClientSendContext);
	} else {
		RELEASE_SPIN_LOCK(&pRcaVc->SpinLock);
	}


	
	
	RCADEBUGP(RCA_INFO, ("RCAIncomingCloseCall: Exit\n"));
}


VOID
RCACloseCallComplete(
	IN NDIS_STATUS 	Status,
	IN NDIS_HANDLE 	ProtocolVcContext,
	IN NDIS_HANDLE 	ProtocolPartyContext OPTIONAL
	)
/*++

Routine Description:

	This routine handles completion of a previous NdisClCloseCall.
	It is assumed that Status is always NDIS_STATUS_SUCCESS.

Arguments:

	Status					- Status of the Close Call.
	ProtocolVcContext		- Pointer to VC structure.
	ProtocolPartyContext	- Not used.

Return Value:

	None

--*/
{
	PRCA_PROTOCOL_CONTEXT	pProtocolContext = &GlobalContext;
	PRCA_VC					pRcaVc = (PRCA_VC)ProtocolVcContext;

	RCADEBUGP(RCA_INFO, ("RCACloseCallComplete: Enter\n"));		

	ACQUIRE_SPIN_LOCK(&(pRcaVc->pAdapter->SpinLock));

	pRcaVc->ClosingState |= CLOSING_CLOSE_COMPLETE;

    RELEASE_SPIN_LOCK(&(pRcaVc->pAdapter->SpinLock));

	ACQUIRE_SPIN_LOCK(&pProtocolContext->SpinLock);

	RCADEBUGP(RCA_LOUD, ("RCACloseCallComplete: Acquired global protocol context lock\n"));

	//
	// Take VC out of hash table
	//
	UnlinkDouble(pRcaVc, NextVcOnHash, PrevVcOnHash);

	RELEASE_SPIN_LOCK(&pProtocolContext->SpinLock);

    RCADEBUGP(RCA_LOUD, ("RCACloseCallComplete: Released global protocol context lock\n"));

	RCASignal(&pRcaVc->CloseBlock, Status);

	RCADEBUGP(RCA_INFO, ("RCACloseCallComplete: Exit\n"));
}


VOID
RCACallConnected(
	IN  NDIS_HANDLE		ProtocolVcContext
	)
/*++

Routine Description:

	This is the final step of an incoming call. The call on this VC
	is now fully set up.
	
	
Arguments:

	ProtocolVcContext	- Call Manager's VC

Return Value:
	None

--*/
{
	PRCA_VC pRcaVc = (PRCA_VC)ProtocolVcContext;

	RCADEBUGP(RCA_INFO, ("RCACallConnected: Enter\n"));

	ACQUIRE_SPIN_LOCK(&pRcaVc->pAdapter->SpinLock);

	pRcaVc = (PRCA_VC)ProtocolVcContext;
	pRcaVc->Flags |= VC_ACTIVE;

	RELEASE_SPIN_LOCK(&pRcaVc->pAdapter->SpinLock);

	RCADEBUGP(RCA_INFO, ("RCACallConnected: Exit\n"));
}


NDIS_STATUS
RCARequest(
	IN  NDIS_HANDLE			ProtocolAfContext,
	IN  NDIS_HANDLE			ProtocolVcContext		OPTIONAL,
	IN  NDIS_HANDLE			ProtocolPartyContext	OPTIONAL,
	IN OUT PNDIS_REQUEST	NdisRequest
	)
/*++

Routine Description:

	This routine is called by NDIS when a call manager sends us an NDIS Request.

Arguments:

	ProtocolAfContext			- Our context for the client binding
	ProtocolVcContext			- Our context for a VC
	ProtocolPartyContext		- Our context for a Party; RCA VC's Party list.
	pNdisRequest				- Pointer to the NDIS Request.

Return Value:

	NDIS_STATUS_SUCCESS
--*/

{
	PRCA_ADAPTER		pAdapter = (PRCA_ADAPTER)ProtocolAfContext;
	NDIS_STATUS			Status = NDIS_STATUS_SUCCESS;

	RCADEBUGP(RCA_INFO, ("RCARequest: Enter - pAdapter->NdisAfHandle = 0X%x\n", pAdapter->NdisAfHandle));
	
	if (NdisRequest->DATA.QUERY_INFORMATION.Oid == OID_CO_AF_CLOSE)
	{
		RCADEBUGP(RCA_LOUD, ("RCARequest: received OID_CO_AF_CLOSE\n"));
        
		ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);
		 
		if (!(pAdapter->AdapterFlags & RCA_ADAPTERFLAGS_DEACTIVATE_IN_PROGRESS)) {
			pAdapter->AdapterFlags |= RCA_ADAPTERFLAGS_DEACTIVATE_IN_PROGRESS;
			RELEASE_SPIN_LOCK(&pAdapter->SpinLock);
		
			Status = NdisScheduleWorkItem(&pAdapter->DeactivateWorkItem); 

			if (Status != NDIS_STATUS_SUCCESS) {
				RCADEBUGP(RCA_ERROR, ("RCARequest: NdisScheduleWorkItem failed with status 0x%x\n", Status));
			}
		} else {
			RELEASE_SPIN_LOCK(&pAdapter->SpinLock);
		}
	}

	RCADEBUGP(RCA_INFO, ("RCARequest: Exit - Returning NDIS_STATUS_SUCCESS\n"));

	return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rca\rcadebug.c ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

	rcadebug.c

Abstract:

	This module contains all debug-related code.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	rmachin     2-18-97 stolen from ArvindM's cmadebug file
	JameelH     4-18-98     Cleanup

Notes:

--*/


#include <precomp.h>

#define MODULE_NUMBER MODULE_DEBUG
#define _FILENUMBER 'BDCR'

INT			RCADebugLevel= RCA_ERROR;
ULONG			PXDebugMicos = 0xFF;


#ifdef PERF
LARGE_INTEGER   PerfTimeConnRequest;
LARGE_INTEGER   PerfTimeSetupSent;
LARGE_INTEGER   PerfTimeConnectReceived;
LARGE_INTEGER   PerfTimeConnConfirm;

LARGE_INTEGER   PerfTimeSetupReceived;
LARGE_INTEGER   PerfTimeConnIndication;
LARGE_INTEGER   PerfTimeConnResponse;
LARGE_INTEGER   PerfTimeConnectSent;

LARGE_INTEGER   PerfTimeFrequency;

#endif // PERF

#if DBG
#undef AUDIT_MEM 
#define AUDIT_MEM 1
#endif

//
// For debugging only: set this to 0x1 for to enable hardcoded data format, 0x0 otherwise.
//
ULONG	g_ulHardcodeDataFormat = 0x0;  

//
// For debugging only: set this to some positive value to indicate the buffer size to 
// advertise in our AllocatorFraming property handler, and the amount of data to copy
// in the WriteStream handler. If set to zero, this will be ignored.
//
ULONG	g_ulBufferSize = 0x0;


#if AUDIT_MEM

PVOID DebugVar1 = (PVOID)NULL;
PRCA_ALLOCATION RCAdMemoryHead = (PRCA_ALLOCATION)NULL;
PVOID DebugVar2 = (PVOID)NULL;
PRCA_ALLOCATION RCAdMemoryTail = (PRCA_ALLOCATION)NULL;
PVOID DebugVar3 = (PVOID)NULL;
ULONG			RCAdAllocCount = 0; // how many allocated so far (unfreed)
PVOID DebugVar4 = (PVOID)NULL;

NDIS_SPIN_LOCK	RCAdMemoryLock;
BOOLEAN			RCAdInitDone = FALSE;


PVOID
RCAAuditAllocMem(
	PVOID	pPointer,
	ULONG	Size,
	ULONG	FileNumber,
	ULONG	LineNumber
)
{
	PVOID				pBuffer;
	PRCA_ALLOCATION pAllocInfo = NULL;

	RCADEBUGP(RCA_VERY_LOUD+50, ("RCAAuditAllocMem(): Enter with size == %lu\n", Size));

	if (!RCAdInitDone)
	{
		RCAInitLock(&RCAdMemoryLock);
		DebugVar1 = (PVOID)(UINT_PTR)0x01010101;
		DebugVar2 = (PVOID)(UINT_PTR)0xabababab;
		DebugVar3 = (PVOID)(UINT_PTR)0xcdcdcdcd;
		DebugVar4 = (PVOID)(UINT_PTR)0xefefefef;
		RCAdInitDone = TRUE;
	}

	//pAllocInfo = (PRCA_ALLOCATION)CTEAllocMem(Size+sizeof(RCA_ALLOCATION));
	NdisAllocateMemoryWithTag((PVOID *)(&pAllocInfo),
							  (UINT)(Size + sizeof(RCA_ALLOCATION)),
							  RCA_TAG);

	if (pAllocInfo == (PRCA_ALLOCATION)NULL)
	{
		RCADEBUGP(RCA_VERY_LOUD+50,
			("RCAAuditAllocMem: file %d, line %d, Size %d failed!\n",
				FileNumber, LineNumber, Size));
		pBuffer = NULL;
	}
	else
	{
		pBuffer = (PVOID)&(pAllocInfo->UserData);
		RCAMemSet(pBuffer, 0xc, Size);
		pAllocInfo->Signature = RCA_MEMORY_SIGNATURE;
		pAllocInfo->FileNumber = FileNumber;
		pAllocInfo->LineNumber = LineNumber;
		pAllocInfo->Size = Size;
		pAllocInfo->Location = (ULONG_PTR)pPointer;
		pAllocInfo->Next = (PRCA_ALLOCATION)NULL;

		RCAAcquireLock(&RCAdMemoryLock);

		pAllocInfo->Prev = RCAdMemoryTail;
		if (RCAdMemoryTail == (PRCA_ALLOCATION)NULL)
		{
			// empty list
			RCAdMemoryHead = RCAdMemoryTail = pAllocInfo;
		}
		else
		{
			RCAdMemoryTail->Next = pAllocInfo;
		}
		RCAdMemoryTail = pAllocInfo;

		RCAdAllocCount++;
		RCAReleaseLock(&RCAdMemoryLock);
	}

	RCADEBUGP(RCA_VERY_LOUD+100,
	 ("RCAAuditAllocMem: file %c%c%c%c, line %d, %d bytes, [0x%x] <- 0x%x\n",
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber, Size, pPointer, pBuffer));

	return (pBuffer);

}


VOID
RCAAuditFreeMem(
	PVOID	Pointer
)
{
	PRCA_ALLOCATION pAllocInfo;

	pAllocInfo = STRUCT_OF(RCA_ALLOCATION, Pointer, UserData);

	if (pAllocInfo->Signature != RCA_MEMORY_SIGNATURE)
	{
		RCADEBUGP(RCA_ERROR,
		 ("RCAAuditFreeMem: unknown buffer 0x%x!\n", Pointer));

		DbgBreakPoint();

		return;
	}

	RCAAcquireLock(&RCAdMemoryLock);
	pAllocInfo->Signature = (ULONG)'DEAD';
	if (pAllocInfo->Prev != (PRCA_ALLOCATION)NULL)
	{
		pAllocInfo->Prev->Next = pAllocInfo->Next;
	}
	else
	{
		RCAdMemoryHead = pAllocInfo->Next;
	}
	if (pAllocInfo->Next != (PRCA_ALLOCATION)NULL)
	{
		pAllocInfo->Next->Prev = pAllocInfo->Prev;
	}
	else
	{
		RCAdMemoryTail = pAllocInfo->Prev;
	}
	RCAdAllocCount--;
	RCAReleaseLock(&RCAdMemoryLock);

	NdisFreeMemory(pAllocInfo, 0, 0);
}

#endif // AUDIT_MEM

VOID
RCADumpGUID(
			INT		DebugLevel,	
			GUID 	*Guid
			)
/*++
Routine Description:
	This routine prints a GUID in human-readable form.
	
Arguments:
	DebugLevel	-	The debug level that should be set before 
					the print becomes visible
    Guid		- 	The GUID structure to print   
		
Return Value:
	(None)

--*/
{

	if (DebugLevel <= RCADebugLevel) {

		DbgPrint("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
				 Guid->Data1, Guid->Data2, 
				 Guid->Data3, Guid->Data4[0],
				 Guid->Data4[1], Guid->Data4[2],
				 Guid->Data4[3], Guid->Data4[4],
				 Guid->Data4[5], Guid->Data4[6],
				 Guid->Data4[7]);
	};	

}


NTSTATUS 
RCADumpKsPropertyInfo(
					  INT	DebugLevel,
					  PIRP	pIrp
					  )

/*++
Routine Description:
	This routine prints the property information in stored in an
	IOCTL_KS_PROPERTY Irp. This helps to identify which property
	is being set/queried by means of the irp.
	
Arguments:
	DebugLevel	-	The debug level that should be set before 
					the print becomes visible
    pIrp		- 	The IOCTL_KS_PROPERTY Irp
		
Return Value:
	STATUS_SUCCESS if all goes well, or an appropriate error code
	otherwise.

--*/

{
	PIO_STACK_LOCATION	pIrpStack;
	ULONG		       	ulInputBufferLength;
	NTSTATUS			Status = STATUS_SUCCESS;
	PKSPROPERTY			pProperty;				

	RCADEBUGP(DebugLevel, ("RCADumpKsPropertyInfo - Enter\n"));

	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	ulInputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;

	do {

		if (ulInputBufferLength < sizeof(KSPROPERTY)) {
			RCADEBUGP(DebugLevel, ("RCADumpKsPropertyInfo: Irp's input buffer is too small\n"));
			Status = STATUS_INVALID_BUFFER_SIZE;
			break;
		}

		try {
			//
            // Validate the pointers if the client is not trusted.
            //
            if (pIrp->RequestorMode != KernelMode) {
                ProbeForRead(pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer, 
							 ulInputBufferLength, 
							 sizeof(BYTE));
            }

			pProperty = (PKSPROPERTY)pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer;

			RCADEBUGP(DebugLevel, ("RCADumpKsPropertyInfo: Property Set == "));
			RCADumpGUID(DebugLevel, &pProperty->Set);
			RCADEBUGP(DebugLevel, ("\nRcaDumpKsPropertyInfo: Property Id == %lu\n", pProperty->Id));
			RCADEBUGP(DebugLevel, ("RCADumpKsPropertyInfo: Property Flags == 0x%x\n", pProperty->Flags));

		} except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
			break;
        }
	} while (FALSE);

    RCADEBUGP(DebugLevel, ("RCADumpKsPropertyInfo - Exit, Returing Status == 0x%x\n", 
						   Status));

	return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rca\rcadebug.h ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

	RcaDebug.h

Abstract:

	Debug macros for RCA

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	rmachin     2-18-97     created -- after ArvindM's cmadebug.h
	JameelH     4-18-98     Cleanup

Notes:

--*/

#ifndef _RCADebug__H
#define _RCADebug__H

//
// Message verbosity: lower values indicate higher urgency
//
#define RCA_VERY_LOUD			10
#define RCA_LOUD			8
#define RCA_INFO			6
#define RCA_WARNING			4
#define RCA_ERROR			2
#define RCA_LOCKS			1
#define RCA_FATAL			0

#ifdef PERF
extern LARGE_INTEGER	PerfTimeConnRequest;
extern LARGE_INTEGER	PerfTimeSetupSent;
extern LARGE_INTEGER	PerfTimeConnectReceived;
extern LARGE_INTEGER	PerfTimeConnConfirm;

extern LARGE_INTEGER	PerfTimeSetupReceived;
extern LARGE_INTEGER	PerfTimeConnIndication;
extern LARGE_INTEGER	PerfTimeConnResponse;
extern LARGE_INTEGER	PerfTimeConnectSent;

extern LARGE_INTEGER	PerfTimeFrequency;

#endif // PERF

extern ULONG	g_ulHardcodeDataFormat;
extern ULONG	g_ulBufferSize;

#if DBG
#define CHECK_LOCK_COUNT(Count)								\
{															\
	if ((INT)(Count) < 0)									\
	{														\
		DbgPrint("Lock Count %d is < 0! File %s, Line %d\n",\
			Count, __FILE__, __LINE__);						\
		DbgBreakPoint();									\
	}														\
}
#else
#define CHECK_LOCK_COUNT(Count)
#endif

#if DBG

extern INT	RCADebugLevel;				// the value here defines what the user wants to see
										// all messages with this urgency and lower are enabled
#define RCADEBUGP(Level, Fmt)								\
{															\
	if (Level <= RCADebugLevel)								\
	{														\
		DbgPrint("***RCA*** (%x, %d) ",						\
				MODULE_NUMBER >> 16, __LINE__);				\
		DbgPrint Fmt;										\
	}														\
}

#define RCADEBUGPSTOP(Level, Fmt) \
{ \
      	RCADEBUGP(Level, Fmt); \
	DbgBreakPoint(); \
} 

#define ACQUIRE_SPIN_LOCK(lock)	\
{								\
	NdisAcquireSpinLock(lock);	\
	if (RCADebugLevel == RCA_LOCKS) {\
		DbgPrint("LOCK %s (0x%x) ACQUIRED, OldIrql set to %d at module %x, line %d\n", #lock, lock, (lock)->OldIrql, MODULE_NUMBER >> 16, __LINE__); \
	}\
}

#define RELEASE_SPIN_LOCK(lock) \
{								\
	if (RCADebugLevel == RCA_LOCKS) {\
		DbgPrint("About to RELEASE LOCK %s (0x%x) and restore old IRQL %d\n", #lock, lock, (lock)->OldIrql);\
	} \
	NdisReleaseSpinLock(lock);	\
	if (RCADebugLevel == RCA_LOCKS) {\
		DbgPrint("LOCK %s (0x%x) RELEASED at module %x, line %d\n", #lock, lock, MODULE_NUMBER >> 16, __LINE__);\
	} \
}

#define DPR_ACQUIRE_SPIN_LOCK(lock) \
{									\
	NdisDprAcquireSpinLock(lock);	\
	if (RCADebugLevel == RCA_LOCKS) { \
		DbgPrint("LOCK %s (0x%x) ACQUIRED (DPC) at module %x, line %d\n", \
				 #lock, lock, MODULE_NUMBER >> 16, __LINE__); \
	} \
}

#define DPR_RELEASE_SPIN_LOCK(lock)	\
{								\
	NdisDprReleaseSpinLock(lock);	\
	if (RCADebugLevel == RCA_LOCKS) {\
		DbgPrint("LOCK %s (0x%x) RELEASED (DPC) at module %x, line %d\n", \
				 #lock, lock, MODULE_NUMBER >> 16, __LINE__); \
	} \
}								


#ifdef PERF
#define RCAAssert(exp)
#else
//#define RCAAssert(exp)          PxAssert(exp)
// For now, just defin this to nothing.
#define RCAAssert(exp)			
#endif // PERF
//#define RCAStructAssert(s, t)	PxStructAssert(s, t)
// For now, just define this to nothing.
#define RCAStructAssert(s, t)
#else

//
// No debug
//
#define RCADEBUGP(lev, stmt)
#define RCAAssert(exp)
#define RCAStructAssert(s, t)

#define ACQUIRE_SPIN_LOCK(lock) 	NdisAcquireSpinLock(lock);	

#define RELEASE_SPIN_LOCK(lock) 	NdisReleaseSpinLock(lock);

#define DPR_ACQUIRE_SPIN_LOCK(lock) NdisDprAcquireSpinLock(lock);	

#define DPR_RELEASE_SPIN_LOCK(lock)	NdisDprReleaseSpinLock(lock);	


#endif	// DBG


#if DBG
#undef AUDIT_MEM 
#define AUDIT_MEM 1
#endif

      
#if AUDIT_MEM

//
// Memory Allocation/Freeing Auditing:
//

//
// The RCA_ALLOCATION structure stores all info about one CmaMemAlloc.
//
typedef struct _RCA_ALLOCATION
{
	ULONG					Signature;
	struct _RCA_ALLOCATION*	Next;
	struct _RCA_ALLOCATION*	Prev;
	ULONG					FileNumber;
	ULONG					LineNumber;
	ULONG					Size;
	ULONG_PTR				Location;	// where the returned pointer was put
	UCHAR					UserData;
} RCA_ALLOCATION, *PRCA_ALLOCATION;

#define RCA_MEMORY_SIGNATURE	(ULONG)'FACR'

extern
PVOID
RCAAuditAllocMem (
	IN	PVOID		pPointer,
	IN	ULONG		Size,
	IN	ULONG		FileNumber,
	IN	ULONG		LineNumber
	);

extern
VOID
RCAAuditFreeMem(
	IN	PVOID		Pointer
	);

#endif // AUDIT_MEM

#endif // _RCADebug__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rca\rcafltr.c ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

        rcafltr.c

Abstract:

        RCA Filter property sets.

Author:

        Richard Machin (RMachin)

Revision History:

        Who         When        What
        --------    --------    ----------------------------------------------
        RMachin     2-25-97     stolen/adapted from msfsread and mswaveio
        DChen       3-25-98     Clean up PinDispatchCreate and PinDispatchClose
        JameelH     4-18-98     Cleanup
        SPATHER         4-20-99         Cleanup. Separated NDIS parts from KS parts.

Notes:

--*/

#include <precomp.h>


#define MODULE_NUMBER MODULE_FLT
#define _FILENUMBER 'RTLF'

#define STREAM_BUFFER_SIZE                      8000
#define STREAM_BYTES_PER_SAMPLE         1


NTSTATUS
PinAllocatorFramingEx(
                                          IN    PIRP                                            Irp,
                                          IN    PKSPROPERTY                             Property,
                                          IN    OUT PKSALLOCATOR_FRAMING_EX     Framing
                                          );


NTSTATUS
GetStreamAllocator(
        IN      PIRP                                    Irp,
        IN      PKSPROPERTY                             Property,
        IN OUT  PVOID *                                 AllocatorHandle
        );

NTSTATUS
SetStreamAllocator(
        IN      PIRP                                    Irp,
        IN      PKSPROPERTY                             Property,
        IN OUT  PVOID *                                 AllocatorHandle
        );

NTSTATUS
RCASetProposedDataFormat(
                         IN PIRP                Irp,
                         IN PKSPROPERTY         Property,
                         IN PKSDATAFORMAT       DataFormat
                         );


#pragma alloc_text(PAGE, PnpAddDevice)
#pragma alloc_text(PAGE, FilterDispatchCreate)
#pragma alloc_text(PAGE, PinDispatchCreate)
#pragma alloc_text(PAGE, FilterDispatchClose)
#pragma alloc_text(PAGE, FilterDispatchIoControl)
#pragma alloc_text(PAGE, FilterTopologyProperty)
#pragma alloc_text(PAGE, FilterPinProperty)
#pragma alloc_text(PAGE, FilterPinInstances)
#pragma alloc_text(PAGE, FilterPinIntersection)

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif // ALLOC_DATA_PRAGMA

const KSDISPATCH_TABLE FilterDispatchTable =
{
        FilterDispatchIoControl,
        KsDispatchInvalidDeviceRequest,
        KsDispatchInvalidDeviceRequest,
        KsDispatchInvalidDeviceRequest,
        FilterDispatchClose,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
};

//
// Make these two a single table if there are no special dispatch funcs
// for the devio PIN..
//
static DEFINE_KSDISPATCH_TABLE(
        PinDevIoDispatchTable,
        PinDispatchIoControl,
        KsDispatchInvalidDeviceRequest,
        KsDispatchInvalidDeviceRequest,
        KsDispatchInvalidDeviceRequest,
        PinDispatchClose,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL);

static DEFINE_KSDISPATCH_TABLE(
        PinFileIoDispatchTable,
        PinDispatchIoControl,
        KsDispatchInvalidDeviceRequest,
        KsDispatchInvalidDeviceRequest,
        KsDispatchInvalidDeviceRequest,
        PinDispatchClose,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL);




//
// Bridge Pin Properties
//

DEFINE_KSPROPERTY_TABLE(BridgePinProperties)
{
        DEFINE_KSPROPERTY_ITEM_PIN_PROPOSEDATAFORMAT(RCASetProposedDataFormat)
};


DEFINE_KSPROPERTY_TABLE(BridgeConnectionProperties)
{
        DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING_EX(PinAllocatorFramingEx)
};


DEFINE_KSPROPERTY_SET_TABLE(BridgePropertySets)
{
                DEFINE_KSPROPERTY_SET(&KSPROPSETID_Pin,
                                                          SIZEOF_ARRAY(BridgePinProperties),
                                                          BridgePinProperties,
                                                          0, 
                                                          NULL),
                DEFINE_KSPROPERTY_SET(&KSPROPSETID_Connection,
                                                          SIZEOF_ARRAY(BridgeConnectionProperties),
                                                          BridgeConnectionProperties,
                                                          0,
                                                          NULL)
};

//
// DevIo Pin Properties
//


#if AUDIO_SINK_FLAG
DEFINE_KSPROPERTY_TABLE(DevIoStreamProperties)
{
        // DEFINE_KSPROPERTY_ITEM_STREAM_INTERFACE(GetInterface),
        // DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONTIME(GetPresentationTime, SetPresentationTime),
        // DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONEXTENT(GetPresentationExtent)
        DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(GetStreamAllocator,SetStreamAllocator)
};
#endif

DEFINE_KSPROPERTY_TABLE(DevIoConnectionProperties)
{
        DEFINE_KSPROPERTY_ITEM_CONNECTION_STATE(PinDeviceState,PinDeviceState ),

        DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING_EX(PinAllocatorFramingEx)
};




DEFINE_KSPROPERTY_SET_TABLE(DevIoPropertySets)
{
#if AUDIO_SINK_FLAG
        DEFINE_KSPROPERTY_SET(&KSPROPSETID_Stream,
                                                  SIZEOF_ARRAY(DevIoStreamProperties),
                                                  DevIoStreamProperties,
                                                  0,
                                                  NULL),
#endif
        DEFINE_KSPROPERTY_SET(&KSPROPSETID_Connection,
                                                  SIZEOF_ARRAY(DevIoConnectionProperties),
                                                  DevIoConnectionProperties,
                                                  0,
                                                  NULL)
};

DEFINE_KSEVENT_TABLE(ConnectionItems)
{
        DEFINE_KSEVENT_ITEM(KSEVENT_CONNECTION_ENDOFSTREAM,
                                                sizeof(KSEVENTDATA),
                                                0,
                                                NULL,
                                                NULL,
                                                NULL)
};

DEFINE_KSEVENT_SET_TABLE(EventSets)
{
        DEFINE_KSEVENT_SET(&KSEVENTSETID_Connection,
                                           SIZEOF_ARRAY(ConnectionItems),
                                           ConnectionItems)
};


// defined in KS.H
static const WCHAR DeviceTypeName[] = KSSTRING_Filter;

//
// The following structures build hierarchically into table of filter properties
// used by the KS library.
//

// "The KSDISPATCH_TABLE structure is used for dispatching IRPs to various
// types of objects contained under a single DRIVER_OBJECT."
//
static DEFINE_KSCREATE_DISPATCH_TABLE(DeviceCreateItems)
{
        DEFINE_KSCREATE_ITEM(FilterDispatchCreate, DeviceTypeName, 0)
};


// 'node' is basically not PINS -- i.e. functional blocks of the filter
static GUID Nodes[] =
{
        STATICGUIDOF(KSCATEGORY_MEDIUMTRANSFORM)
};

//
// Topology = Pins+Nodes. We have one filter node to which two Pins connect.
// Note each of our Pins is half-duplex. (If a Pin were full-duplex, there would be two
// connections to the filter node). KSFILTER_NODE is the filter itself, i.e. node -1. From
// the doc:
// "The simplest filter (2 pins) would contain just one connection, which would be from
// Node -1, Pin 0, to Node -1, Pin 1."
//
static const KSTOPOLOGY_CONNECTION RenderConnections[] =
{
        { KSFILTER_NODE, ID_DEVIO_PIN, 0, 0},
        { 0, 1, KSFILTER_NODE, ID_BRIDGE_PIN}
};

static const KSTOPOLOGY_CONNECTION CaptureConnections[] =
{
        { KSFILTER_NODE, ID_BRIDGE_PIN, 0, 0},
        { 0, 1, KSFILTER_NODE, ID_DEVIO_PIN}
};

// what this filter does -- in our case, transform devio stream to net bridge
static GUID TopologyNodes[] =
{
        STATICGUIDOF(KSCATEGORY_RENDER),
        STATICGUIDOF(KSCATEGORY_BRIDGE),
        STATICGUIDOF(KSCATEGORY_CAPTURE)
};

// this is the composite filter topology, defining the above Pins, Nodes and Connections
const KSTOPOLOGY RenderTopology =
{
        0,//2,                                                          // Functional category render, bridge
        NULL,                                                           //(GUID*) &TopologyNodes[ 0 ],
        2,
        (GUID*) &TopologyNodes[0],                      // Nodes
        SIZEOF_ARRAY( RenderConnections ),
        RenderConnections
};

const KSTOPOLOGY CaptureTopology =
{
        0,//2,                                                          // Functional category bridge, capture
        NULL,                                                           //(GUID*) &TopologyNodes[ 1 ],
        2,
        (GUID*) &TopologyNodes[1],                      // Nodes
        SIZEOF_ARRAY( CaptureConnections ),
        CaptureConnections
};


//
// "The DEFINE_KSPROPERTY_PINSET macro allows easier definition of a pin
// property set, as only a few parameters actually change from set to set."
// Used by KS to route PIN queries
//
static DEFINE_KSPROPERTY_PINSET(
        FilterPinProperties,                            // name of the set
        FilterPinProperty,                                      // handler
        FilterPinInstances,                                     // instances query handler
        FilterPinIntersection);                         // intersection query handler

// Used by KS to route Topology queries
static DEFINE_KSPROPERTY_TOPOLOGYSET(
        FilterTopologyProperties,                       // name of the set
        FilterTopologyProperty);                        // topology query handler

// A table of property sets for Topology and Pins.
static DEFINE_KSPROPERTY_SET_TABLE(FilterPropertySets)
{
        DEFINE_KSPROPERTY_SET(&KSPROPSETID_Pin,
                                                  SIZEOF_ARRAY(FilterPinProperties),
                                                  FilterPinProperties,
                                                  0,
                                                  NULL),
        DEFINE_KSPROPERTY_SET(&KSPROPSETID_Topology,
                                                  SIZEOF_ARRAY(FilterTopologyProperties),
                                                  FilterTopologyProperties,
                                                  0,
                                                  NULL)
};

//
// a table of interfaces describing Pin interfaces. In our case,
// all Pins have standard byte-position based streaming interface.
//
static DEFINE_KSPIN_INTERFACE_TABLE(PinInterfaces)
{
        DEFINE_KSPIN_INTERFACE_ITEM(KSINTERFACESETID_Standard,          // standard streaming
                                                                KSINTERFACE_STANDARD_STREAMING) // based on byte- rather than time-position
};

//
// 'Medium' for Pin communications -- standard IRP-based device-io
//
static DEFINE_KSPIN_MEDIUM_TABLE(PinMedia)
{
        DEFINE_KSPIN_MEDIUM_ITEM(KSMEDIUMSETID_Standard,
                                                         KSMEDIUM_TYPE_ANYINSTANCE)
};

//
// Data ranges = collective formats supported on our Pins.
//

//
// Define the wildcard data format.
//
const KSDATARANGE WildcardDataFormat =
{
        sizeof( KSDATARANGE ),
        0,                                                                                      // ULONG Flags
        0,                                                                                      // ULONG SampleSize
        0,                                                                                      // ULONG Reserved
        STATICGUIDOF( KSDATAFORMAT_TYPE_STREAM ),       //STREAM
        STATICGUIDOF( KSDATAFORMAT_SUBTYPE_WILDCARD ),
        STATICGUIDOF( KSDATAFORMAT_SPECIFIER_NONE )     //NONE
};


const KSDATARANGE SuperWildcardDataFormat = 
{
        sizeof(KSDATARANGE),
        0,
        0,
        0,
        STATICGUIDOF( KSDATAFORMAT_TYPE_WILDCARD ),     //STREAM
        STATICGUIDOF( KSDATAFORMAT_SUBTYPE_WILDCARD ),
        STATICGUIDOF( KSDATAFORMAT_SPECIFIER_WILDCARD ) //NONE
};

#if AUDIO_SINK_FLAG

//
// Data ranges = collective formats supported on our Pins.
// In our case, streams of unknown data
//typedef struct {
//      KSDATARANGE                       DataRange;
//      ULONG                             MaximumChannels;
//      ULONG                             MinimumBitsPerSample;
//      ULONG                             MaximumBitsPerSample;
//      ULONG                             MinimumSampleFrequency;
//      ULONG                             MaximumSampleFrequency;
//} KSDATARANGE_AUDIO, *PKSDATARANGE_AUDIO;

const KSDATARANGE_AUDIO AudioDataFormat = 
{
        {
                sizeof(KSDATARANGE_AUDIO),                      // (KSDATARANGE_AUDIO),
                0,
                0,
                0,
                STATIC_KSDATAFORMAT_TYPE_AUDIO,         // major format
                STATIC_KSDATAFORMAT_SUBTYPE_PCM,        // sub format (WILDCARD?)
                STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX
        },
                1,                                                              // 1 channels
                8,                
                8,  
                8000,                                                           // 22050,
                8000                                                            // 22050
};


#endif

//
// Array of above (only one for us).
// TBS: we should split this out into an array of specific types when we get more
// sophisticated in identifying the type of stream handled by the VC via CallParams
// -- e.g. audio, video with subformats of compression types. Eventually, we should
// create a bridge PIN of format corresponding to callparams info, then expose the
// full range of these types via the PIN factory. The PinDispatchCreate handler
// would look for a bridge PIN of the corresponding type.
//
PKSDATARANGE PinDevIoRanges[] =
{
#if AUDIO_SINK_FLAG
        //(PKSDATARANGE)&AudioDataFormat
        (PKSDATARANGE)&SuperWildcardDataFormat
#else
        (PKSDATARANGE)&WildcardDataFormat
#endif  
};

static const KSDATARANGE PinFileIoRange =
{
        sizeof(KSDATARANGE),
        0,
        0,
        0,
        STATICGUIDOF( KSDATAFORMAT_TYPE_STREAM ),
        STATICGUIDOF( KSDATAFORMAT_SUBTYPE_NONE ),
        STATICGUIDOF( KSDATAFORMAT_SPECIFIER_VC_ID ) //KSDATAFORMAT_SPECIFIER_FILENAME
};

//
// Array of above (only one for us).
// TBS: we should split this out into an array of specific types when we get more
// sophisticated in identifying the type of stream handled by the VC via CallParams
// -- e.g. audio, video with subformats of compression types. Eventually, we should
// create a bridge PIN of format corresponding to callparams info, then expose the
// full range of these types via the PIN factory. The PinDispatchCreate handler
// would look for a bridge PIN of the corresponding type.
//
static const PKSDATARANGE PinFileIoRanges[] =
{
        (PKSDATARANGE)&PinFileIoRange
};

//
// "The KSPIN_DESCRIPTOR structure contains the more dynamic information
// which a device would keep on a pin when using the built-in handlers
// for dealing with the Pin property set, and connections in general."
//
// We pass this to KS in our FilterPinPropertyHandler when KS wants to know what
// we look like, and let KS pick the bones out of it.
//
DEFINE_KSPIN_DESCRIPTOR_TABLE(CapturePinDescriptors)
{
        DEFINE_KSPIN_DESCRIPTOR_ITEMEX(                                 // PIN 0  bridge
                                        SIZEOF_ARRAY(PinInterfaces),
                                        PinInterfaces,
                                        SIZEOF_ARRAY(PinMedia),
                                        PinMedia,
                                        SIZEOF_ARRAY(PinFileIoRanges),
                                        (PKSDATARANGE*)PinFileIoRanges,
                                        KSPIN_DATAFLOW_IN,
                                        KSPIN_COMMUNICATION_BRIDGE,
                                        (GUID*) &TopologyNodes[1],
                                        (GUID*) &TopologyNodes[1]),             // no CSA connections to this PIN
        DEFINE_KSPIN_DESCRIPTOR_ITEMEX(                                 // PIN 1  output
                                        SIZEOF_ARRAY(PinInterfaces),
                                        PinInterfaces,
                                        SIZEOF_ARRAY(PinMedia),
                                        PinMedia,
                                        SIZEOF_ARRAY(PinDevIoRanges),
                                        (PKSDATARANGE*)PinDevIoRanges,
                                        KSPIN_DATAFLOW_OUT,
                                        KSPIN_COMMUNICATION_BOTH,               // SOURCE+SINK
                                        (GUID*) &TopologyNodes[2],
                                        (GUID*) &TopologyNodes[2])
};

DEFINE_KSPIN_DESCRIPTOR_TABLE(RenderPinDescriptors)
{
        DEFINE_KSPIN_DESCRIPTOR_ITEMEX(                 // PIN 0  bridge
                                SIZEOF_ARRAY(PinInterfaces),
                                PinInterfaces,
                                SIZEOF_ARRAY(PinMedia),
                                PinMedia,
                                SIZEOF_ARRAY(PinFileIoRanges),
                                (PKSDATARANGE*)PinFileIoRanges,
                                KSPIN_DATAFLOW_OUT,
                                KSPIN_COMMUNICATION_BRIDGE,
                                (GUID*) &TopologyNodes[1],
                                (GUID*) &TopologyNodes[1]),     // no CSA connections to this PIN
        DEFINE_KSPIN_DESCRIPTOR_ITEMEX(                 // PIN 1          input
                                SIZEOF_ARRAY(PinInterfaces),
                                PinInterfaces,
                                SIZEOF_ARRAY(PinMedia),
                                PinMedia,
                                SIZEOF_ARRAY(PinDevIoRanges),
                                (PKSDATARANGE*)PinDevIoRanges,
                                KSPIN_DATAFLOW_IN,
                                KSPIN_COMMUNICATION_SINK,
                                (GUID*) &TopologyNodes[0],
                                (GUID*) &TopologyNodes[0])      // we receive IRPs, not produce them
};

// How many instances of a Pin we can have, one entry for each Pin.
const KSPIN_CINSTANCES PinInstances[ MAXNUM_PIN_TYPES ] =
{
        // Indeterminate number of possible connections.

        {
                1, 0
        },

        {
                1, 0
        }
};

//
// Now the Pin dispatch info
//
static const WCHAR PinTypeName[] = KSSTRING_Pin;  // in KS.h

static DEFINE_KSCREATE_DISPATCH_TABLE(FilterObjectCreateDispatch)
{
        DEFINE_KSCREATE_ITEM(PinDispatchCreate, PinTypeName, 0)
};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif  // ALLOC_DATA_PRAGMA

NTSTATUS
PnpAddDevice(
        IN PDRIVER_OBJECT       DriverObject,
        IN PDEVICE_OBJECT       PhysicalDeviceObject
        )
/*++

Routine Description:

        When a new device is detected, PnP calls this entry point with the
        new PhysicalDeviceObject (PDO). The driver creates an associated
        FunctionalDeviceObject (FDO).

        Note that we keep global device info in a global structure, RcaGlobal.
        This info is common to all devices on this driver object (such as NDIS inititaliztion
        info, adapter queue etc). Since we get called here for EACH interface (capture, render) we
        can't keep global ingfo in the FDO device extension.

Arguments:

        DriverObject -
                Pointer to the driver object.

        PhysicalDeviceObject -
                Pointer to the new physical device object.

Return Values:

        STATUS_SUCCESS or an appropriate error condition.

--*/
{
        PDEVICE_OBJECT  FunctionalDeviceObject = NULL, PnpDeviceObject = NULL;
        NTSTATUS        Status = STATUS_SUCCESS;

        RCADEBUGP(RCA_INFO, ("PnPAddDevice: Enter\n"));

        do
        {
                Status = IoCreateDevice(DriverObject,
                                        sizeof(DEVICE_INSTANCE),
                                        NULL,
                                        FILE_DEVICE_KS,
                                        0,
                                        FALSE,
                                        &FunctionalDeviceObject);
        
                if (!NT_SUCCESS(Status)) {  
                        RCADEBUGP(RCA_ERROR, ("PnpAddDevice: "
                                              "IoCreateDevice() failed - Status == 0x%x\n", Status));
                        break;
                }
        
                DeviceExtension = (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;
        
                RtlCopyMemory(DeviceExtension->PinInstances,
                              PinInstances,
                              sizeof(PinInstances));
        
                RcaGlobal.FilterCreateItems[ FilterTypeRender ].Create = FilterDispatchCreate;
                RcaGlobal.FilterCreateItems[ FilterTypeRender ].Context = (PVOID) FilterTypeRender;
        
                RtlStringFromGUID(&KSCATEGORY_RENDER,
                                  &RcaGlobal.FilterCreateItems[ FilterTypeRender ].ObjectClass);
        
                RcaGlobal.FilterCreateItems[ FilterTypeRender ].SecurityDescriptor = NULL;
                RcaGlobal.FilterCreateItems[ FilterTypeRender ].Flags = 0;
        
                RcaGlobal.FilterCreateItems[ FilterTypeCapture ].Create = FilterDispatchCreate;
                RcaGlobal.FilterCreateItems[ FilterTypeCapture ].Context = (PVOID) FilterTypeCapture;
        
                RtlStringFromGUID(&KSCATEGORY_CAPTURE,
                                  &RcaGlobal.FilterCreateItems[ FilterTypeCapture ].ObjectClass);
        
                RcaGlobal.FilterCreateItems[ FilterTypeCapture ].SecurityDescriptor = NULL;
                RcaGlobal.FilterCreateItems[ FilterTypeCapture ].Flags = 0;
        
                //
                // This object uses KS to perform access through the DeviceCreateItems.
                //
                Status = KsAllocateDeviceHeader(&DeviceExtension->Header,
                                                SIZEOF_ARRAY(RcaGlobal.FilterCreateItems),
                                                RcaGlobal.FilterCreateItems);
        
                if (!NT_SUCCESS(Status)) {  
                        RCADEBUGP(RCA_ERROR, ("PnpAddDevice: "
                                              "KsAllocateDeviceHeader() failed - Status == 0x%x\n", Status)); 
                        break;
                }
        
                PnpDeviceObject = IoAttachDeviceToDeviceStack(FunctionalDeviceObject, PhysicalDeviceObject);

                if (PnpDeviceObject == NULL) {
                        RCADEBUGP(RCA_ERROR, ("PnpAddDevice: "
                                                                  "Could not attach our FDO to the device stack\n"));
                        break;
                }

                KsSetDevicePnpAndBaseObject(DeviceExtension->Header,
                                                                        PnpDeviceObject,
                                                                        FunctionalDeviceObject);
        
                FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
                FunctionalDeviceObject->Flags |= DO_POWER_PAGABLE;
        
                //
                // Finally, initialize as a Co-NDIS client.
                //

                if (RcaGlobal.bProtocolInitialized == FALSE) {
                        RCA_CO_NDIS_HANDLERS    Handlers;

                        Handlers.ReceiveCallback = RCAReceiveCallback;
                        Handlers.SendCompleteCallback = RCASendCompleteCallback;
                        Handlers.VcCloseCallback = RCAVcCloseCallback;

                        Status = RCACoNdisInitialize(&Handlers, RCA_SAP_REG_TIMEOUT);

                        if (!NT_SUCCESS(Status)) {
                                RCADEBUGP(RCA_ERROR, ("PnpAddDevice: "
                                                                          "Failed to initialize as a Co-Ndis client - Status == 0x%x\n",
                                                                          Status));
                                break;
                        }

                        RcaGlobal.bProtocolInitialized = TRUE;
                }

        } while (FALSE);

        if (!NT_SUCCESS(Status))
        {
                RCADEBUGP(RCA_ERROR, ("PnpAddDevice: "
                                      "Bad Status (0x%x) - calling IoDeleteDevice() on FDO\n", Status));
                
                if (PnpDeviceObject) 
                        IoDetachDevice(PnpDeviceObject);

                if (FunctionalDeviceObject)
                        IoDeleteDevice(FunctionalDeviceObject);
        }

        RCADEBUGP(RCA_INFO, ("PnpAddDevice: "
                             "Exit - Returning Status == 0x%x\n", Status));

        return(Status);
}

NTSTATUS
FilterDispatchClose(
        IN      PDEVICE_OBJECT  DeviceObject,
        IN      PIRP                    Irp
        )
/*++

Routine Description:

        Closes a previously opened Filter instance. This can only occur after the Pins have been
        closed, as they reference the Filter object when created. This also implies that all the
        resources the Pins use have been released or cleaned up.

Arguments:

        DeviceObject -
                Device object on which the close is occuring.

        Irp -
                Close Irp.

Return Values:

        Returns STATUS_SUCCESS.

--*/
{
        PFILTER_INSTANCE        FilterInstance;
#if DBG
        KIRQL   EntryIrql;
#endif

        RCA_GET_ENTRY_IRQL(EntryIrql);

        RCADEBUGP(RCA_INFO, ("FilterDispatchClose: Enter\n"));

        FilterInstance = (PFILTER_INSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;

        //
        // Notify the software bus that the device has been closed.
        //
        KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);

        //
        // These were allocated during the creation of the Filter instance.
        //
        KsFreeObjectHeader(FilterInstance->Header);
        RCAFreeMem(FilterInstance);

        Irp->IoStatus.Status = STATUS_SUCCESS;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);        

        RCA_CHECK_EXIT_IRQL(EntryIrql);

        RCADEBUGP(RCA_INFO, ("FilterDispatchClose: "
                             "Exit - Returning STATUS_SUCCESS\n"));
        
        return(STATUS_SUCCESS);
}


NTSTATUS
FilterDispatchIoControl(
        IN      PDEVICE_OBJECT  DeviceObject,
        IN      PIRP                    Irp
        )
/*++

Routine Description:

        Dispatches property requests on a Filter instance. These are enumerated in the
        FilterPropertySets list.

Arguments:

        DeviceObject -
                Device object on which the device control is occuring.

        Irp -
                Device control Irp.

Return Values:

        Returns STATUS_SUCCESS if the property was successfully manipulated, else an error.

--*/
{
        PIO_STACK_LOCATION  IrpStack;
        NTSTATUS                        Status;

        RCADEBUGP(RCA_INFO, ("FilterDispatchIoControl: Enter\n"));

        IrpStack = IoGetCurrentIrpStackLocation(Irp);
        switch(IrpStack->Parameters.DeviceIoControl.IoControlCode) { 
        case IOCTL_KS_PROPERTY:
                RCADEBUGP(RCA_INFO, ("FilterDispatchIoControl: KsPropertyHandler\n"));
                Status = KsPropertyHandler(Irp, SIZEOF_ARRAY(FilterPropertySets), FilterPropertySets);
                break;

        default:
                RCADEBUGP(RCA_WARNING, ("FilterDispatchIoControl: "
                                        "Invalid Device Request - Io Control Code 0x%x\n", 
                                        IrpStack->Parameters.DeviceIoControl.IoControlCode));

                Status = KsDefaultDeviceIoCompletion(DeviceObject, Irp);

                RCADEBUGP(RCA_WARNING, ("FilterDispatchIoControl: "
                                        "Returning Status == 0x%x\n", Status));
                return Status;
        }

        Irp->IoStatus.Status = Status;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        
        RCADEBUGP(RCA_INFO, ("FilterDispatchIoControl: "
                             "Exit - Returning Status == 0x%x\n", Status));
        return Status;
}


NTSTATUS
FilterTopologyProperty(
        IN      PIRP                    Irp,
        IN      PKSPROPERTY             Property,
        IN      OUT PVOID               Data
        )
/*++

Routine Description:

        This is the general handler for all Topology property requests, and is used to route
        the request to the KsTopologyPropertyHandler using the FilterTopology information.
        This request would have been routed through FilterDispatchIoControl, then
        KsPropertyHandler, which would have then called the handler for the property item,
        which is this function.

Arguments:

        Irp -
                Device control Irp.

        Property -
                Specific property request.

        Data -
                Property data.

Return Values:

        Returns STATUS_SUCCESS if the property was successfully manipulated, else an error.

--*/
{
        PFILTER_INSTANCE                FilterInstance;
        PIO_STACK_LOCATION              irpSp;
        NTSTATUS                Status = 0;

        RCADEBUGP(RCA_INFO, ("FilterTopologyProperty: Enter\n"));

        irpSp = IoGetCurrentIrpStackLocation( Irp );

        FilterInstance = (PFILTER_INSTANCE)irpSp->FileObject->FsContext;

        if (FilterInstance->FilterType == FilterTypeRender) { 
                Status = KsTopologyPropertyHandler( Irp, Property, Data, &RenderTopology);
                RCADEBUGP(RCA_INFO, ("FilterTopologyProperty: "
                                     "Render device - Returning Status == 0x%x\n", Status));
                return Status;
        } else {
                Status = KsTopologyPropertyHandler( Irp, Property, Data, &CaptureTopology);
                RCADEBUGP(RCA_INFO, ("FilterTopologyProperty: "
                                     "Capture device - Returning Status == 0x%x\n", Status));
                return Status;
        }
}


NTSTATUS
FilterPinProperty(
        IN      PIRP                    Irp,
        IN      PKSPROPERTY             Property,
        IN      OUT PVOID               Data
        )
/*++

Routine Description:

        This is the general handler for most Pin property requests, and is used to route
        the request to the KsPinPropertyHandler using the PinDescriptors information.
        This request would have been routed through FilterDispatchIoControl, then
        KsPropertyHandler, which would have then called the handler for the property item,
        which is this function.

Arguments:

        Irp -
                Device control Irp.

        Property -
                Specific property request. This actually contains a PKSP_PIN pointer in
                most cases.

        Data -
                Property data.

Return Values:


        Returns STATUS_SUCCESS if the property was successfully manipulated, else an error.

--*/
{
        PFILTER_INSTANCE        FilterInstance;
        PIO_STACK_LOCATION      IrpStack;
        NTSTATUS                Status = 0;

        RCADEBUGP(RCA_INFO,("FilterPinProperty: Enter\n"));
        
        IrpStack = IoGetCurrentIrpStackLocation(Irp);
        FilterInstance = (PFILTER_INSTANCE)IrpStack->FileObject->FsContext;

        RCADEBUGP(RCA_LOUD, ("FilterPinProperty: "
                             "FilterInstance == 0x%x, Type == 0x%x, Property == 0x%x, Property Id == 0x%x\n", 
                             FilterInstance, FilterInstance->FilterType, Property, Property->Id));
        
        Status = KsPinPropertyHandler(Irp,
                                      Property,
                                      Data,
                                      SIZEOF_ARRAY(RenderPinDescriptors), // same size both cases
                                      (FilterInstance->FilterType == FilterTypeRender ?
                                       RenderPinDescriptors : CapturePinDescriptors));

        RCADEBUGP(RCA_INFO, ("FilterPinProperty: "
                             "Exit - Returning Status == 0x%x, Data == 0x%x, "
                             "Irp->IoStatus.Information == 0x%x\n", 
                             Status, Data, Irp->IoStatus.Information));

        return Status;
}


NTSTATUS
FilterPinInstances(
        IN      PIRP                            Irp,
        IN      PKSP_PIN                        pPin,
        OUT     PKSPIN_CINSTANCES               pCInstances
        )
/*++

Routine Description:

        Handles the KSPROPERTY_PIN_CINSTANCES property in the Pin property set. Returns the
        total possible and current number of Pin instances available for a Pin factory.

Arguments:

        Irp -
                Device control Irp.

        Pin -
                Specific property request followed by Pin factory identifier.

        Instances -
                The place in which to return the instance information of the specified Pin factory.

Return Values:

        returns STATUS_SUCCESS, else STATUS_INVALID_PARAMETER.

--*/
{
        PIO_STACK_LOCATION      irpSp;
        PFILTER_INSTANCE        FilterInstance;

        RCADEBUGP(RCA_INFO, ("FilterPinInstances: Enter - "
                             "Pin ID == 0x%x\n", pPin->PinId));

        irpSp = IoGetCurrentIrpStackLocation(Irp);

        FilterInstance = (PFILTER_INSTANCE)irpSp->FileObject->FsContext;

        //
        // This count maintanied by KS
        //
        *pCInstances = FilterInstance->PinInstances[pPin->PinId];

        RCADEBUGP(RCA_LOUD, ("FilterPinInstances: "
                             "Pin Instance == 0x%x\n", DeviceExtension->PinInstances[pPin->PinId]));
        
        Irp->IoStatus.Information = sizeof( KSPIN_CINSTANCES );

        RCADEBUGP(RCA_INFO, ("FilterPinInstances: Exit - "
                             "pCInstances == 0x%x, Irp->IoStatus.Information == 0x%x, "
                             "Returning STATUS_SUCCESS\n", pCInstances, Irp->IoStatus.Information));

        return STATUS_SUCCESS;
}


//
// DEBUG - For debugging only - START

KSDATAFORMAT_WAVEFORMATEX       MyWaveFormatPCM = {
        {
                sizeof(KSDATAFORMAT_WAVEFORMATEX),
                        0,
                        0,
                        0,
            STATIC_KSDATAFORMAT_TYPE_AUDIO,     
                        STATIC_KSDATAFORMAT_SUBTYPE_PCM,        
                        STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX
        },
        {
                WAVE_FORMAT_PCM,
                        1,
                        8000,
                        8000,
                        1,
                        8,
                        0
        }
};

KSDATAFORMAT_WAVEFORMATEX       MyWaveFormatMULAW = {
        {
                sizeof(KSDATAFORMAT_WAVEFORMATEX),
                        0,
                        0,
                        0,
            STATIC_KSDATAFORMAT_TYPE_AUDIO,     
                        STATIC_KSDATAFORMAT_SUBTYPE_MULAW,      
                        STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX
        },
        {
                WAVE_FORMAT_MULAW,
                        1,
                        8000,
                        8000,
                        1,
                        8,
                        0
        }
};


// DEBUG - For debugging only - END
//


NTSTATUS
RCAGenericIntersection(
                          IN    PIRP            Irp,
                          IN    PKSDATARANGE    DataRange,
                          IN    ULONG           OutputBufferLength,
                          OUT   PVOID           Data
                          )
/*++

Routine Description:
        This routine computes the intersection of a given data range with the data format 
        specified by the app via the PIN_PROPOSEDATAFORMAT property. 

Arguments:

        Irp -
                Device control Irp.
  
        DataRange -
                Contains a specific data range to validate.
                
        OutputBufferLength -
                Length of the data buffer pointed to by "Data".         

        Data -
                The place in which to return the data format selected as the first intersection
                between the list of data ranges passed, and the acceptable formats.

Return Values:

        returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
        STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/

{
        BOOL                    bWCardFormat;
        PIO_STACK_LOCATION      irpSp;
        PFILTER_INSTANCE        pFilterInstance;
        PPIN_INSTANCE_BRIDGE    pBridgePin;
        PKSDATARANGE            DataRangeSource = NULL;
        BOOL                    bNeedReleaseLock = FALSE;
        NTSTATUS                Status = STATUS_SUCCESS;        

        RCADEBUGP(RCA_INFO, ("RCAGenericIntersection: Enter\n"));

        irpSp = IoGetCurrentIrpStackLocation(Irp);

        pFilterInstance = (PFILTER_INSTANCE)irpSp->FileObject->FsContext;

        pBridgePin = pFilterInstance->BridgePin;

        bWCardFormat = IsEqualGUIDAligned(&DataRange->SubFormat, &SuperWildcardDataFormat.SubFormat) &&
                IsEqualGUIDAligned(&DataRange->Specifier, &SuperWildcardDataFormat.Specifier);  

        RCADEBUGP(RCA_LOUD, ("RCAGenericIntersection: "
                             "bWCardFormat == 0x%x\n", bWCardFormat));          
        do {
                
                if (pBridgePin) {
                        RCA_ACQUIRE_BRIDGE_PIN_LOCK(pBridgePin);
                        RCADEBUGP(RCA_LOUD, ("RCAGenericIntersection: Acquired Bridge Pin Lock\n"));

                        bNeedReleaseLock = TRUE;
                        
                        if ((DataRangeSource = (PKSDATARANGE)pBridgePin->pDataFormat) == NULL) {
                                RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePin);
                                RCADEBUGP(RCA_LOUD, ("RCAGenericIntersection: Released Bridge Pin Lock\n"));

                                bNeedReleaseLock = FALSE;
                        }
                        //
                        // DEBUG - FOR DEBUGGING ONLY - Start 
                        
                        if (g_ulHardcodeDataFormat == 1) {
                                DataRangeSource = (PKSDATARANGE)&MyWaveFormatPCM;
                        } else if (g_ulHardcodeDataFormat == 2) {
                                DataRangeSource = (PKSDATARANGE)&MyWaveFormatMULAW;
                        }
                        
                        
                        // DEBUG - FOR DEBUGGING ONLY - End
                        //
                    
                } 

                if (DataRangeSource == NULL) {                  
                        if (bWCardFormat) {
                                RCADEBUGP(RCA_ERROR, ("RCAGenericIntersection: "
                                                      "Input data format was wildcard and we have no format "
                                                      "set - Setting Status == STATUS_NO_MATCH\n"));
                                Status = STATUS_NO_MATCH;
                                break;

                        } else {
                                DataRangeSource = DataRange;
                        }
                }

                
                if (OutputBufferLength == 0) {
                        Irp->IoStatus.Information = DataRangeSource->FormatSize;
                        RCADEBUGP(RCA_INFO, ("RCAGenericIntersection: "
                                             "Output buffer length was zero, placing size of "
                                             "data range (0x%x) into Irp->IoStatus.Information, "
                                             "Setting Status == STATUS_BUFFER_OVERFLOW\n", DataRangeSource->FormatSize)); 
                        
                        Status = STATUS_BUFFER_OVERFLOW;
                        break;
                }
                
                if (OutputBufferLength == sizeof(ULONG)) {
                        *(PULONG)Data = DataRangeSource->FormatSize;
                        Irp->IoStatus.Information = sizeof(ULONG);

                        RCADEBUGP(RCA_LOUD, ("RCAGenericIntersection: "
                                             "Output buffer is one ULONG big, placing size of "
                                             "data range (0x%x) in output buffer, "
                                             "Setting Status == STATUS_SUCCESS\n", DataRangeSource->FormatSize));
                
                        Status = STATUS_SUCCESS;
                        break;

                }
        
                if (OutputBufferLength < DataRangeSource->FormatSize) {
        
                        RCADEBUGP(RCA_ERROR, ("RCAGenericIntersection: "
                                              "Output buffer too small, Setting Status == STATUS_BUFFER_TOO_SMALL\n"));
                
                        Status = STATUS_BUFFER_TOO_SMALL;
                        break;
                }       
        
        } while(FALSE);

        if (Status == STATUS_SUCCESS) {
                Irp->IoStatus.Information = DataRangeSource->FormatSize;

                RtlCopyMemory(Data, DataRangeSource, DataRangeSource->FormatSize);

                RCADEBUGP(RCA_LOUD, ("RCAGenericIntersection: "
                                     "Copied data range to output, Leaving Status == STATUS_SUCCESS\n"));              
        
        }
        
        if (bNeedReleaseLock) {
                RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePin);
                RCADEBUGP(RCA_LOUD, ("RCAGenericIntersection: Released Bridge Pin Lock\n"));

                bNeedReleaseLock = FALSE;
        }

        RCADEBUGP(RCA_INFO, ("RCAGenericIntersection: Exit - Returning Status == 0x%x\n", Status));

        return Status;
}



NTSTATUS
RCAIntersect(
        IN      PIRP                    Irp,
        IN      PKSP_PIN                Pin,
        IN      PKSDATARANGE    DataRange,
        OUT PVOID                       Data
        )
/*++

Routine Description:
        This is the data range callback for KsPinDataIntersection, which is called by
        FilterPinIntersection to enumerate the given list of data ranges, looking for
        an acceptable match. If a data range is acceptable, a data format is copied
        into the return buffer. A STATUS_NO_MATCH continues the enumeration.

Arguments:

        Irp -
                Device control Irp.

        Pin -
                Specific property request followed by Pin factory identifier, followed by a
                KSMULTIPLE_ITEM structure. This is followed by zero or more data range structures.
                \This enumeration callback does not need to look at any of this though. It need
                only look at the specific pin identifier.

        DataRange -
                Contains a specific data range to validate.

        Data -
                The place in which to return the data format selected as the first intersection
                between the list of data ranges passed, and the acceptable formats.

Return Values:

        returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
        STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
        NTSTATUS                        Status = STATUS_SUCCESS;
        PFILTER_INSTANCE                FilterInstance;
        PIO_STACK_LOCATION              irpSp;
        ULONG                           OutputBufferLength;
        GUID                            SubFormat;
        BOOL                            SubFormatSet;
        BOOL                            CorrectAudioFormat = FALSE, WCardFormat = FALSE;

        RCADEBUGP(RCA_INFO, ("RCAIntersect: Enter - "
                             "DataRange size == %d\n", DataRange->FormatSize));

        irpSp = IoGetCurrentIrpStackLocation(Irp);

        FilterInstance = (PFILTER_INSTANCE)irpSp->FileObject->FsContext;

        OutputBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
        
        RCADEBUGP(RCA_LOUD, ("RCAIntersect: OutputBufferLength == %d\n", OutputBufferLength));

        //
        // All the major/sub/specifier checking has been done by the handler.
        //
        if (DataRange->FormatSize < sizeof( KSDATAFORMAT )) { 
                RCADEBUGP(RCA_ERROR, ("RCAIntersect: "
                                      "Format size is less than size of KSDATAFORMAT - "
                                      "Returning STATUS_NO_MATCH\n"));
                
                return STATUS_NO_MATCH;
        }

    RCADEBUGP(RCA_LOUD, ("RCAIntersect: DataRange->FormatSize == 0x%08x\n"
                                                 "RCAIntersect: DataRange->Flags      == 0x%08x\n"
                                                 "RCAIntersect: DataRange->SampleSize == 0x%08x\n"
                                                 "RCAIntersect: DataRange->Reserved   == 0x%08x\n",
                                                 DataRange->FormatSize,
                                                 DataRange->Flags,
                                                 DataRange->SampleSize,
                                                 DataRange->Reserved));

        RCADEBUGP(RCA_LOUD, ("RCAIntersect: DataRange->MajorFormat == "));
        RCADumpGUID(RCA_LOUD, &DataRange->MajorFormat);
        RCADEBUGP(RCA_LOUD, ("\n"
                                                 "RCAIntersect: DataRange->SubFormat == "));
        RCADumpGUID(RCA_LOUD, &DataRange->SubFormat);
        RCADEBUGP(RCA_LOUD, ("\n"
                                                 "RCAIntersect: DataRange->Specifier == "));
        RCADumpGUID(RCA_LOUD, &DataRange->Specifier);
        RCADEBUGP(RCA_LOUD, ("\n"));

        RCADEBUGP(RCA_LOUD, ("RCAIntersect: DataRange->FormatSize == 0x%08x\n"
                             "RCAIntersect: DataRange->Flags      == 0x%08x\n"
                             "RCAIntersect: DataRange->SampleSize == 0x%08x\n"
                             "RCAIntersect: DataRange->Reserved   == 0x%08x\n"
                             "RCAIntersect: DataRange->MajorFormat == %08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\n"
                             "RCAIntersect: DataRange->SubFormat   == %08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\n"
                             "RCAIntersect: DataRange->Specifier   == %08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\n",
                             DataRange->FormatSize,
                             DataRange->Flags,
                             DataRange->SampleSize,
                             DataRange->Reserved,
                             DataRange->MajorFormat.Data1, DataRange->MajorFormat.Data2, 
                             DataRange->MajorFormat.Data3, DataRange->MajorFormat.Data4[0],
                             DataRange->MajorFormat.Data4[1], DataRange->MajorFormat.Data4[2],
                             DataRange->MajorFormat.Data4[3], DataRange->MajorFormat.Data4[4],
                             DataRange->MajorFormat.Data4[5], DataRange->MajorFormat.Data4[6],
                             DataRange->MajorFormat.Data4[7],                        
                             DataRange->SubFormat.Data1, DataRange->SubFormat.Data2, 
                             DataRange->SubFormat.Data3, DataRange->SubFormat.Data4[0],
                             DataRange->SubFormat.Data4[1], DataRange->SubFormat.Data4[2],
                             DataRange->SubFormat.Data4[3], DataRange->SubFormat.Data4[4],
                             DataRange->SubFormat.Data4[5], DataRange->SubFormat.Data4[6],
                             DataRange->SubFormat.Data4[7],
                             DataRange->Specifier.Data1, DataRange->Specifier.Data2, 
                             DataRange->Specifier.Data3, DataRange->Specifier.Data4[0],
                             DataRange->Specifier.Data4[1], DataRange->Specifier.Data4[2],
                             DataRange->Specifier.Data4[3], DataRange->Specifier.Data4[4],
                             DataRange->Specifier.Data4[5], DataRange->Specifier.Data4[6],
                             DataRange->Specifier.Data4[7]));
                             

        if (Pin->PinId == ID_DEVIO_PIN) {
                                
                Status = RCAGenericIntersection(Irp, DataRange, OutputBufferLength, Data);

        } else {
                RCADEBUGP(RCA_LOUD, ("RCAIntersect: BRIDGE Pin\n"));

                if (OutputBufferLength == 0) {
                        Irp->IoStatus.Information = DataRange->FormatSize;
                        RCADEBUGP(RCA_INFO, ("RCAIntersect: "
                                             "Output buffer length was zero, placing size 0x%x "
                                             "in Irp->IoStatus.Information, "
                                             "Returning STATUS_BUFFER_OVERFLOW\n", DataRange->FormatSize)); 
                                
                        return STATUS_BUFFER_OVERFLOW;
                }
                        
                if (OutputBufferLength == sizeof(ULONG)) {
                        *(PULONG)Data = DataRange->FormatSize;
                        Irp->IoStatus.Information = sizeof(ULONG);

                        RCADEBUGP(RCA_LOUD, ("RCAIntersect: "
                                             "Output buffer is one ULONG big, placing size 0x%x "
                                             "in output buffer, "
                                             "Returning STATUS_SUCCESS\n", DataRange->FormatSize));
                        
                        return STATUS_SUCCESS;

                }
                
                if (OutputBufferLength < DataRange->FormatSize) {
                
                        RCADEBUGP(RCA_ERROR, ("RCAIntersect: "
                                              "Output buffer too small, returning STATUS_BUFFER_TOO_SMALL\n"));
                        
                        return STATUS_BUFFER_TOO_SMALL;
                }
                
                
                Irp->IoStatus.Information = DataRange->FormatSize;
                RtlCopyMemory(Data, DataRange, DataRange->FormatSize); 
        }

        RCADEBUGP(RCA_INFO, ("RCAIntersect: Exit - "
                             "Returning Status == 0x%x\n", Status));

        return Status;   
}


VOID 
LinkPinInstanceToVcContext(
                                                   IN   PVOID                                   VcContext,
                                                   IN   PPIN_INSTANCE_BRIDGE    pPinInstance
                                                   )
/*++
Routine Description:
        Sets the pointers to link a pin instance to its VC context (placed in 
        separate function to allow PinDispatchCreate() to remain pageable, since
        this operation requires a spin lock).
        
Arguments:
        VcContext               - Vc context we obtained when we referenced the VC
        pPinInstance    - Pointer to the PIN_INSTANCE_BRIDGE structure 
        
Return value:
        -none-          
--*/

{

        RCA_ACQUIRE_BRIDGE_PIN_LOCK(pPinInstance);

        pPinInstance->VcContext = VcContext;

        RCA_RELEASE_BRIDGE_PIN_LOCK(pPinInstance);
        
}


VOID 
LinkPinInstanceToFilterInstance(                                                              
                                                                IN PFILTER_INSTANCE             pFilterInstance,
                                                                IN PPIN_INSTANCE_BRIDGE         pPinInstance
                                                                )
/*++
Routine Description:
        Sets the pointers to link a pin instance to its filter instance (placed in 
        separate function to allow PinDispatchCreate() to remain pageable, since
        this operation requires a spin lock).
        
Arguments:
        VcContext               - Vc context we obtained when we referenced the VC
        pPinInstance    - Pointer to the PIN_INSTANCE_BRIDGE structure 
        
Return value:
        -none-          
--*/

{

        RCA_ACQUIRE_BRIDGE_PIN_LOCK(pPinInstance);

        pPinInstance->FilterInstance = pFilterInstance; // FIXME: This really needs to be protected by some filter-specific lock

        RCA_RELEASE_BRIDGE_PIN_LOCK(pPinInstance);
        
}


NTSTATUS
PinDispatchCreate(
        IN      PDEVICE_OBJECT  DeviceObject,
        IN      PIRP                    Irp
        )
/*++

Routine Description:

        Dispatches the creation of a Pin instance. Allocates the object header and initializes
        the data for this Pin instance.

Arguments:

        DeviceObject -
                Device object on which the creation is occuring.

        Irp -
                Creation Irp.

Return Values:

        Returns STATUS_SUCCESS on success, or an error.

--*/
{
        PIO_STACK_LOCATION  IrpStack;
        PKSPIN_CONNECT          Connect;
        NTSTATUS                        Status = 0;
        PKSDATAFORMAT           DataFormat;
        PFILTER_INSTANCE        FilterInstance;
        ULONG                           OppositePin;

        RCADEBUGP(RCA_INFO, ("PinDispatchCreate: Enter\n"));

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        //
        // Determine if this request is being sent to a valid Pin factory with valid
        // connection parameters.
        //
        //
        // get hold of our filter instance in the RELATED context (context will be the new PIN instance)
        //
        FilterInstance = (PFILTER_INSTANCE)IrpStack->FileObject->RelatedFileObject->FsContext;
        
        RCADEBUGP(RCA_LOUD, ("PinDispatchCreate: "
                             "FilterInstance == 0x%x\n", FilterInstance));

        Status = KsValidateConnectRequest(Irp,
                                          SIZEOF_ARRAY(PinDescriptors),
                                          (FilterInstance->FilterType == FilterTypeRender ? RenderPinDescriptors : CapturePinDescriptors),
                                          &Connect);    

        if (STATUS_SUCCESS != Status)
        {
                Irp->IoStatus.Status = Status;

                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                
                RCADEBUGP(RCA_ERROR, ("PinDispatchCreate: "
                                      "KsValidateConnectRequest failure. "
                                      "Setting Irp->IoStatus.Status and returing Status == 0x%x\n", Status));
                return Status;
        }

        RCADEBUGP(RCA_VERY_LOUD, ("PinDispatchCreate: FilterType == %lu\n", (ULONG)FilterInstance->FilterType));
        RCADEBUGP(RCA_VERY_LOUD, ("PinDispatchCreate: Connect->PinId == %lu\n", (ULONG)Connect->PinId));
        RCADEBUGP(RCA_VERY_LOUD, ("PinDispatchCreate: &Connect == %x\n", &Connect));

        OppositePin = Connect->PinId ^ 0x00000001;
        DataFormat = (PKSDATAFORMAT)(Connect + 1);

        RCADEBUGP(RCA_LOUD, ("PinDispatchCreate: DataFormat->FormatSize == 0x%08x\n"
                                                 "PinDispatchCreate: DataFormat->Flags      == 0x%08x\n"
                                                 "PinDispatchCreate: DataFormat->SampleSize == 0x%08x\n"
                                                 "PinDispatchCreate: DataFormat->Reserved   == 0x%08x\n",
                                                 DataFormat->FormatSize,
                                                 DataFormat->Flags,
                                                 DataFormat->SampleSize,
                                                 DataFormat->Reserved));

        RCADEBUGP(RCA_LOUD, ("PinDispatchCreate: DataFormat->MajorFormat == "));
        RCADumpGUID(RCA_LOUD, &DataFormat->MajorFormat);
        RCADEBUGP(RCA_LOUD, ("\n"
                                                         "PinDispatchCreate: DataFormat->SubFormat == "));
        RCADumpGUID(RCA_LOUD, &DataFormat->SubFormat);
        RCADEBUGP(RCA_LOUD, ("\n"
                                                 "PinDispatchCreate: DataFormat->Specifier == "));
        RCADumpGUID(RCA_LOUD, &DataFormat->Specifier);
        RCADEBUGP(RCA_LOUD, ("\n"));
                             

        // Exclude other Pin creation at this point.
        KeWaitForMutexObject(&FilterInstance->ControlMutex,
                             Executive,
                             KernelMode,
                             FALSE,
                             NULL);

        RCADEBUGP(RCA_LOUD, ("PinDispatchCreate: Acquired filter instance control mutex\n"));

        do {
        
                //
                // Make sure this Pin ID isn't already connected
                //
                if (FilterInstance->PinFileObjects[Connect->PinId]) {
                
                        RCADEBUGP(RCA_ERROR, ("PinDispatchCreate: "
                                              "Pin ID %lu is already connected, "
                                              "setting Status = STATUS_NOT_FOUND\n", Status));

                        Status = STATUS_NOT_FOUND;
                        break;            
                }

                if (Connect->PinId == ID_BRIDGE_PIN) {
                
                        // We're creating a 'bridge' pin to the network.  TAPI has set up
                        // a connection and returned the NDIS VC identifier, which
                        // must be in the connect structure.
                        //
                        PWSTR                                   pwstrNdisVcString = 0;
                        PPIN_INSTANCE_BRIDGE    PinInstance;
                        PVOID                                   VcContext;
                        NDIS_STRING                             UniString;
                        ULONG_PTR                               ulHexVcId;
                        NDIS_REQUEST                    Request;

                        RCADEBUGP(RCA_LOUD, ("PinDispatchCreate: Creating a bridge pin\n"));
                        RCADEBUGP(RCA_VERY_LOUD, ("PinDispatchCreate: Connect == 0x%x\n", Connect));

                        //
                        // Create the instance information.
                        //
                        RCAAllocMem( PinInstance,  PIN_INSTANCE_BRIDGE, sizeof(PIN_INSTANCE_BRIDGE));
                        if (!PinInstance) {                     
                                RCADEBUGP(RCA_ERROR, ("PinDispatchCreate: "
                                                      "Could not allocate memory for pin instance, "
                                                      "Setting Status = STATUS_INSUFFICIENT_RESOURCES\n"));
                                Status = STATUS_INSUFFICIENT_RESOURCES;
                                break;
                        }

                        RCAMemSet(PinInstance, 0, sizeof(PIN_INSTANCE_BRIDGE));
                                                                
                        KeInitializeSpinLock(&PinInstance->SpinLock);   
                        
                        //
                        // Initialize the block structure if we are on a capture filter.
                        //

                        if (FilterInstance->FilterType == FilterTypeCapture) {

                                RCAInitBlockStruc(&PinInstance->Block);
                        }

                        //
                        // This object uses KS to perform access through the PinFileIoDispatchTable. There
                        // are no create items attached to this object because it does not support a
                        // clock or allocator.
                        //
                        Status = KsAllocateObjectHeader(&PinInstance->InstanceHdr.Header,
                                                                                        0,
                                                                                        NULL,
                                                                                        Irp,
                                                                                        &PinFileIoDispatchTable);

                        if (!NT_SUCCESS(Status)) {
                        
                                RCADEBUGP(RCA_ERROR, ("PinDispatchCreate: "
                                                      "KsAllocateObjectHeader failed with Status == 0x%x, "
                                                      "Setting Status = STATUS_INVALID_PARAMETER\n", Status));
                                Status = STATUS_INVALID_PARAMETER;

                                RCAFreeMem(PinInstance);
                                break;
                        }
                        
                        if (FilterInstance->FilterType == FilterTypeCapture) {
                        
                                InitializeListHead(&(PinInstance->WorkQueue));
                        }
                        

                        //
                        // Crosslink PIN instance and filter instance
                        //
                        LinkPinInstanceToFilterInstance(FilterInstance, PinInstance);

                        //
                        // Obtain VC context for the VC handle we were given.
                        //
                        pwstrNdisVcString = (PWSTR)(DataFormat + 1);

                        NdisInitUnicodeString (&UniString, pwstrNdisVcString);

                        if (FilterInstance->FilterType == FilterTypeRender) {
                                Status = RCACoNdisGetVcContextForSend(UniString, 
                                                                                                          (PVOID) PinInstance, 
                                                                                                          &VcContext);
                        } else {
                                Status = RCACoNdisGetVcContextForReceive(UniString, 
                                                                                                                 (PVOID) PinInstance, 
                                                                                                                 &VcContext);
                        }
                        
                        if (Status != NDIS_STATUS_SUCCESS) {
                                Status = STATUS_INVALID_PARAMETER;
                                RCAFreeMem(PinInstance);
                                break;
                        }
                        
                        //
                        // Crosslink PIN instance and VC
                        //
                        LinkPinInstanceToVcContext(VcContext, PinInstance);
                        
                        //
                        // KS expects that the object data is in FsContext.
                        //
                        IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext = PinInstance;
                        
                        
                        RCADEBUGP(RCA_LOUD, ("PinDispatchCreate: Address of File Object == 0x%x\n",
                                             IoGetCurrentIrpStackLocation(Irp)->FileObject));

                        RCADEBUGP(RCA_LOUD, ("PinDispatchCreate: FsContext == 0x%x\n",
                                             IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext));

                        
                        FilterInstance->BridgePin = PinInstance;

                        Status = STATUS_SUCCESS;        
                } else if (Connect->PinId == ID_DEVIO_PIN) {
                        
                        RCADEBUGP(RCA_LOUD, ("PinDispatchCreate: Creating a devio pin\n"));

#if DUMP_CONNECT_FORMAT
                        //
                        // Print out the data format information.
                        //

                        if (IsEqualGUIDAligned(&DataFormat->Specifier, 
                                                                   &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)) {
                                PKSDATAFORMAT_WAVEFORMATEX      pWaveFormat;

                                pWaveFormat = (PKSDATAFORMAT_WAVEFORMATEX)DataFormat;

                                RCADEBUGP(RCA_INFO, ("PinDispatchCreate: wFormatTag                == 0x%x\n"
                                                                         "PinDispatchCreate: nChannels                 == 0x%x\n"
                                                                         "PinDispatchCreate: nSamplesPerSec            == 0x%x\n"
                                                                         "PinDispatchCreate: nAvgBytesPerSec           == 0x%x\n"
                                                                         "PinDispatchCreate: nBlockAlign               == 0x%x\n"    
                                                                         "PinDispatchCreate: wBitsPerSample            == 0x%x\n"
                                                                         "PinDispatchCreate: cbSize                    == 0x%x\n",
                                                                         pWaveFormat->WaveFormatEx.wFormatTag,
                                                                         pWaveFormat->WaveFormatEx.nChannels,
                                                                         pWaveFormat->WaveFormatEx.nSamplesPerSec,
                                                                         pWaveFormat->WaveFormatEx.nAvgBytesPerSec,
                                                                         pWaveFormat->WaveFormatEx.nBlockAlign,
                                                                         pWaveFormat->WaveFormatEx.wBitsPerSample,
                                                                         pWaveFormat->WaveFormatEx.cbSize));
                                

                        } else {
                                RCADEBUGP(RCA_ERROR, ("PinDispatchCreate: Data Format was not WAVEFORMATEX, don't know what to do\n"));
                                RCADEBUGP(RCA_ERROR, ("PinDispatchCreate: The specifier was: "));
                                RCADumpGUID(RCA_ERROR, &DataFormat->Specifier);
                                RCADEBUGP(RCA_ERROR, ("\n"));
                        }

#endif
                        //
                        // Check for RENDER or CAPTURE
                        //
                        if (FilterInstance->FilterType == FilterTypeRender) {                   
                                RCADEBUGP(RCA_VERY_LOUD, ("PinDispatchCreate: RENDER: Connect = 0x%x\n", 
                                                          Connect));

                                Status = InitializeDevIoPin(Irp, 0, FilterInstance, DataFormat);

                        } else {
                                //
                                // Capture device; streans data from the net; IRP source.
                                // Get the connectong filter's file handle so we can stream to it.
                                //

                                if (Connect->PinToHandle) {
                                        RCADEBUGP(RCA_LOUD, ("PinDispatchCreate: Creating a Source Pin\n"));
                                        Status = ObReferenceObjectByHandle(Connect->PinToHandle,        // other filter's PIN
                                                                           FILE_WRITE_DATA,
                                                                           NULL,
                                                                           ExGetPreviousMode(),
                                                                           &FilterInstance->NextFileObject, // &FilterInstance->NextFileObjects[Connect->PinId], // this is other file  object
                                                                           NULL);
                                        if (!NT_SUCCESS(Status)) {
                                        
                                                RCADEBUGP(RCA_ERROR, ("PinDispatchCreate: "
                                                                      "ObReferenceObjectByHandle failed with "
                                                                      "Status == 0x%x\n", Status));
                                                //
                                                // Get out of while loop (releases mutex and returns status)
                                                //
                                                break;
                                        }
                                } else {
                                        RCADEBUGP(RCA_LOUD, ("PinDispatchCreate: Creating a Sink Pin\n"));
                                        FilterInstance->NextFileObject = NULL;
                                }

                                Status = InitializeDevIoPin(Irp, 1, FilterInstance, DataFormat);

                                //
                                // Add the pin's target to the list of targets for
                                // recalculating IRP stack depth.
                                //

                                if (FilterInstance->NextFileObject != NULL) {
                                        if (NT_SUCCESS(Status)) {
                                                KsSetTargetDeviceObject(FilterInstance->Header,
                                                                                                IoGetRelatedDeviceObject(FilterInstance->NextFileObject));
                                        } else {
                                                ObDereferenceObject(FilterInstance->NextFileObject);
                                                FilterInstance->NextFileObject = NULL;
                                        }
                                }
                        }
                        
                        RtlCopyMemory(&FilterInstance->DataFormat, DataFormat, sizeof(KSDATAFORMAT));
                } else {
                        RCADEBUGP(RCA_ERROR, ("PinDispatchCreate: Not creating a bridge or a devio pin, "
                                              "Setting Status == STATUS_NOT_FOUND\n"));
                        Status = STATUS_NOT_FOUND;
                }

                if (NT_SUCCESS(Status)) {
                        PPIN_INSTANCE_HEADER    PinInstance;

                        //
                        // Store the common Pin information and increment the reference
                        // count on the parent Filter.
                        // The newly created PIN can subsequently be retreived from the filter instance
                        // header by specifying its type to  PinFileObjects[Connect->PinId]..
                        //
                        PinInstance = (PPIN_INSTANCE_HEADER)IrpStack->FileObject->FsContext;
                        PinInstance->PinId = Connect->PinId;
                        ObReferenceObject(IrpStack->FileObject->RelatedFileObject); // refs the FILTER object

                        //
                        // Set up Pin instance for retrieval later
                        //
                        FilterInstance->PinFileObjects[Connect->PinId] = IrpStack->FileObject;

                        RCADEBUGP(RCA_LOUD, ("PinDispatchCreate: "
                                             "Pin Created Successfully, Status == 0x%x\n", Status));
                } else {    
                        RCADEBUGP(RCA_ERROR, ("PinDispatchCreate: Failure, Status == 0x%x\n", Status));
                }

        } while(FALSE);

        KeReleaseMutex(&FilterInstance->ControlMutex, FALSE);
        RCADEBUGP(RCA_LOUD, ("PinDispatchCreate: Released filter instance control mutex\n"));

        Irp->IoStatus.Status = Status;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);


        RCADEBUGP(RCA_INFO, ("PinDispatchCreate: Exit - "
                             "Setting Irp->IoStatus.Status and returing Status == 0x%x\n", Status));
        return Status;
}

NTSTATUS
InitializeDevIoPin(
        IN      PIRP                            Irp,
        IN      BOOLEAN                         Read,
        IN      PFILTER_INSTANCE        FilterInstance,
        IN      PKSDATAFORMAT           DataFormat
        )
/*++

Routine Description:

        Allocates the Dev I/O Pin specific structure and initializes it.

Arguments:

        Irp     - Creation Irp.
        Read    - Read/Write boolean. Read = 1.

        DataFormat -
                The proposed data format.

Return Values:

        Returns STATUS_SUCCESS if everything could be allocated and opened, else an error.

--*/
{
        PFILE_OBJECT                    FileObject;
        PPIN_INSTANCE_BRIDGE    BridgePinInstance = NULL;
        PPIN_INSTANCE_DEVIO             PinInstance = NULL;
        PIO_STACK_LOCATION              IrpStack;
        NTSTATUS                                Status;

        RCADEBUGP(RCA_INFO, ("InitializeDevIoPin: Enter - DataFormat == 0x%x\n", DataFormat));

        //
        // The rest of the data format has already been verified by KsValidateConnectRequest,
        // however the FormatSize should be at least as big as the base format size.
        //
        if (DataFormat->FormatSize < sizeof(KSDATAFORMAT)) {
                RCADEBUGP(RCA_ERROR, ("InitializeDevIoPin: "
                                      "Data format size (0x%x) is less than size of KSDATAFORMAT\n", 
                                      DataFormat->FormatSize));
                
                return STATUS_CONNECTION_REFUSED;
        }

        //
        // check we have a bridge PIN on this filter instance supporting this data format.
        // The function locks the parent filter instance and looks for a conected FILEIO Pin.
        //
        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        if (!(BridgePinInstance = FilterInstance->BridgePin)) { 
                RCADEBUGP(RCA_ERROR, ("InitializeDevIoPin: "
                                      "Bridge pin is not yet connected, "
                                      "returning STATUS_CONNECTION_REFUSED\n"));
                return STATUS_CONNECTION_REFUSED;
        }

        // Create the instance information. This contains the Pin factory identifier, and
        // event queue information.
        //
        RCAAllocMem( PinInstance,  PIN_INSTANCE_DEVIO, sizeof(PIN_INSTANCE_DEVIO));

        if (PinInstance) {
                RCAMemSet(PinInstance, 0, sizeof(PIN_INSTANCE_DEVIO));

                //
                // This object uses KS to perform access through the PinDevIoDispatchTable. There
                // are no create items attached to this object because it does not support a
                // clock or allocator.
                //
                Status = KsAllocateObjectHeader(&PinInstance->InstanceHdr.Header,
                                                0,
                                                NULL,
                                                Irp,
                                                &PinDevIoDispatchTable);

                if (NT_SUCCESS(Status)) {  
                        InitializeListHead(&PinInstance->EventQueue);
                        ExInitializeFastMutex(&PinInstance->EventQueueLock);

                        if (Read) {   
#if AUDIO_SINK_FLAG
                                if (FilterInstance->NextFileObject == NULL) {
                                        InitializeListHead(&PinInstance->ActiveQueue);
                                        KeInitializeSpinLock(&PinInstance->QueueLock);
                                        PinInstance->ConnectedAsSink = TRUE;
                                        RCADEBUGP(RCA_LOUD, ("InitializeDevIoPin: "
                                                             "Set ConnectedAsSink == TRUE\n"));
                                } else {
                                        PinInstance->ConnectedAsSink = FALSE;
                                        RCADEBUGP(RCA_LOUD, ("InitializeDevIoPin: "
                                                             "Set ConnectedAsSink == FALSE\n"));
                                
                                }
                                
#endif

                        } else { // end of CAPTURE pin (from the net)

                                // This might be a bit misleading. On the render filter, the devio pin is 
                                // always a sink. But the ConnectedAsSink flag applies only to the capture side.
                                PinInstance->ConnectedAsSink = FALSE;
                                RCADEBUGP(RCA_LOUD, ("InitializeDevIoPin: "
                                                     "Set ConnectedAsSink == FALSE\n"));
                        }       

                        if (!NT_SUCCESS(Status)) {   
                                KsFreeObjectHeader (PinInstance->InstanceHdr.Header);
                                RCAFreeMem(PinInstance);
                                
                                return Status;
                        }

                        //
                        // Point DEVIO Pin at VC
                        //
                        RCA_ACQUIRE_BRIDGE_PIN_LOCK(BridgePinInstance);

                        PinInstance->VcContext = BridgePinInstance->VcContext;

            RCA_RELEASE_BRIDGE_PIN_LOCK(BridgePinInstance);

                        FilterInstance->DevIoPin = PinInstance;
                        PinInstance->FilterInstance = FilterInstance;

                        //
                        // KS expects that the object data is in FsContext.
                        //
                        IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext = PinInstance;
                        return STATUS_SUCCESS;
                } else {
                        RCADEBUGP(RCA_ERROR, ("InitializeDevIoPin: KsAllocateObjectHeader failed with "
                                              "Status == 0x%x\n", Status));
                }               
                RCAFreeMem(PinInstance);
        } else {
                //
                // Couldn't allocate PIN
                //
                RCADEBUGP(RCA_ERROR, ("InitializeDevIoPin: "
                                      "Could not allocate memory for pin, "
                                      "Setting Status = STATUS_INSUFFICIENT_RESOURCES\n"));
                Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        RCADEBUGP(RCA_INFO, ("InitializeDevIoPin: Exit - "
                             "Returning Status == 0x%x\n", Status));    

        return Status;
}


NTSTATUS
PinDispatchIoControl(
        IN PDEVICE_OBJECT       DeviceObject,
        IN PIRP                         Irp
        )
/*++

Routine Description:

        Dispatches property, event, and streaming requests on the Dev I/O Pin instance.

Arguments:

        DeviceObject -
                Device object on which the device control is occuring.

        Irp -
                Device control Irp.

Return Values:

        Returns STATUS_SUCCESS if the property was successfully manipulated, else an error.

--*/
{
        PIO_STACK_LOCATION              IrpStack;
        NTSTATUS                        Status;
        CCHAR                           PriorityBoost;  
        PPIN_INSTANCE_HEADER            PinInstanceHeader;
        UINT                            PendTheIrp = 0;

        RCADEBUGP(RCA_INFO, ("PinDispatchIoControl: Enter\n"));

        PriorityBoost = IO_NO_INCREMENT;
        IrpStack = IoGetCurrentIrpStackLocation(Irp);
        Irp->IoStatus.Status = STATUS_PENDING;
        IoMarkIrpPending (Irp);

        RCADEBUGP(RCA_VERY_LOUD, ("PinDispatchIoControl: Marked IRP Pending\n"));


        PinInstanceHeader = (PPIN_INSTANCE_HEADER)IrpStack->FileObject->FsContext;

        if (PinInstanceHeader->PinId == ID_DEVIO_PIN) {
                PPIN_INSTANCE_DEVIO             PinInstanceDevIo;
                
                RCADEBUGP(RCA_LOUD, ("PinDispatchIoControl: DEVIO pin\n"));

                PinInstanceDevIo = (PPIN_INSTANCE_DEVIO)IrpStack->FileObject->FsContext;
                
                switch(IrpStack->Parameters.DeviceIoControl.IoControlCode) {                                                                                                    
                case IOCTL_KS_PROPERTY:                                                                     
                     RCADEBUGP(RCA_LOUD, ("PinDispatchIoControl: IOCTL_KS_PROPERTY\n"));                 
                     Status = KsPropertyHandler(Irp,                                                       
                                                SIZEOF_ARRAY(DevIoPropertySets),   
                                                DevIoPropertySets);                
                     break;                                                                                      
                case IOCTL_KS_ENABLE_EVENT:                                                                 
                     RCADEBUGP(RCA_LOUD, ("PinDispatchIoControl: IOCTL_KS_ENABLE_EVENT\n"));             
                     Status = KsEnableEvent(Irp,                                                           
                                            SIZEOF_ARRAY(EventSets),                   
                                            EventSets,                                 
                                            &PinInstanceDevIo->EventQueue,                  
                                            KSEVENTS_FMUTEXUNSAFE,                     
                                            &PinInstanceDevIo->EventQueueLock);             
                     break;                                                                                
                                                                                                      
                case IOCTL_KS_DISABLE_EVENT:                                                                
                     RCADEBUGP(RCA_LOUD, ("PinDispatchIoControl: IOCTL_KS_DISABLE_EVENT\n"));            
                     Status = KsDisableEvent(Irp,                                                          
                                             &PinInstanceDevIo->EventQueue,             
                                             KSEVENTS_FMUTEXUNSAFE,                
                                             &PinInstanceDevIo->EventQueueLock);        
                     break;                                                                                
                                                                                                      
                case IOCTL_KS_READ_STREAM:
                     RCADEBUGP(RCA_LOUD, ("PinDispatchIoControl: IOCTL_KS_READ_STREAM\n"));            

                     if (NT_SUCCESS(Status = ReadStream(Irp, PinInstanceDevIo)))                                
                     {                                                                                     
                        PriorityBoost = IO_DISK_INCREMENT;                                            
                     } else {
                             RCADEBUGP(RCA_ERROR, ("PinDispatchIoControl: "
                                                   "ReadStream failed, Status == 0x%x\n", Status));
                     }
                     break;                                                                                
                                                                                                      
                case IOCTL_KS_WRITE_STREAM:                                                                 
                        RCADEBUGP(RCA_LOUD, ("PinDispatchIoControl: IOCTL_KS_WRITE_STREAM\n"));                             
                     Status = WriteStream(Irp, PinInstanceDevIo );                                              
                         
                     break;                                                                                
                                                                                                      
                default:                                                                                    
                     RCADEBUGP(RCA_WARNING, ("PinDispatchIoControl: "
                                             "Unknown IOCTL: 0x%x\n", 
                                             IrpStack->Parameters.DeviceIoControl.IoControlCode));                            
                     
                     Status = KsDefaultDeviceIoCompletion( DeviceObject, Irp ); 

                     RCADEBUGP(RCA_INFO, ("PinDispatchIoControl: "
                                          "Returning result of KsDefaultDeviceIoCompletion: 0x%x\n", Status));
                     return Status;                             
                }
        } else {                                                                                                                                                                
                PPIN_INSTANCE_BRIDGE            PinInstanceBridge;                
                                                                                      
                RCADEBUGP(RCA_LOUD, ("PinDispatchIoControl: BRIDGE pin\n")); 

                PinInstanceBridge = (PPIN_INSTANCE_BRIDGE)IrpStack->FileObject->FsContext;
                                                                                      
                switch(IrpStack->Parameters.DeviceIoControl.IoControlCode) {                                                                                                    
                case IOCTL_KS_PROPERTY:                                                                     
                     RCADEBUGP(RCA_LOUD, ("PinDispatchIoControl: IOCTL_KS_PROPERTY\n"));
                     
                         RCADumpKsPropertyInfo(RCA_LOUD, Irp);

                         Status = KsPropertyHandler(Irp,                                                       
                                                                                SIZEOF_ARRAY(BridgePropertySets),   
                                                                                BridgePropertySets);                
                         
                         RCADEBUGP(RCA_INFO, ("PinDispatchIoControl: "
                                          "Returning result of KsPropertyHandler: 0x%x\n",
                                          Status));
                         
                     break;
                                  
                case IOCTL_KS_ENABLE_EVENT:                                                                 
                     RCADEBUGP(RCA_LOUD,("PinDispatchIoControl: IOCTL_KS_ENABLE_EVENT\n"));             
                     Status = KsEnableEvent(Irp,                                                           
                                            SIZEOF_ARRAY(EventSets),                   
                                            EventSets,                                 
                                            &PinInstanceBridge->EventQueue,                  
                                            KSEVENTS_FMUTEXUNSAFE,                     
                                            &PinInstanceBridge->EventQueueLock);             
                     break;                                                                                
                                                                                                      
                case IOCTL_KS_DISABLE_EVENT:                                                                
                     RCADEBUGP(RCA_LOUD,("PinDispatchIoControl: IOCTL_KS_DISABLE_EVENT\n"));            
                     Status = KsDisableEvent(Irp,                                                          
                                             &PinInstanceBridge->EventQueue,             
                                             KSEVENTS_FMUTEXUNSAFE,                
                                             &PinInstanceBridge->EventQueueLock);        
                     break;                                                                                
                                                                                                      
                case IOCTL_KS_READ_STREAM:                                                                  
                     RCADEBUGP(RCA_LOUD, ("PinDispatchIoControl: IOCTL_KS_READ_STREAM\n"));                                                                                                                                    
                     Status = KsDefaultDeviceIoCompletion(DeviceObject, Irp);

                     RCADEBUGP(RCA_INFO, ("PinDispatchIoControl: "
                                          "Returning result of KsDefaultDeviceIoCompletion: 0x%x\n",
                                          Status));
                     
                     return Status;                              
                                                                                                                      
                case IOCTL_KS_WRITE_STREAM:                                                                 
                     RCADEBUGP(RCA_LOUD, ("PinDispatchIoControl: IOCTL_KS_WRITE_STREAM\n"));                             
                     Status = KsDefaultDeviceIoCompletion(DeviceObject, Irp);

                     RCADEBUGP(RCA_INFO, ("PinDispatchIoControl: "
                                          "Returning result of KsDefaultDeviceIoCompletion: 0x%x\n",
                                          Status));
                                          
                     return Status;                                                                                               
                                                                                                                      
                default:                                                                                    
                        RCADEBUGP(RCA_WARNING, ("PinDispatchIoControl: "
                                                "Unknown IOCTL: 0x%x\n", 
                                                IrpStack->Parameters.DeviceIoControl.IoControlCode));                            
                     
                        Status = KsDefaultDeviceIoCompletion(DeviceObject, Irp); 

                        RCADEBUGP(RCA_INFO, ("PinDispatchIoControl: "
                                             "Returning result of KsDefaultDeviceIoCompletion: 0x%x\n",
                                             Status));

                        return Status;                             
                }                                                                         
        }                                                                           
                

        if (Status != STATUS_PENDING) { 
                Irp->IoStatus.Status = Status;

                IoCompleteRequest( Irp, PriorityBoost );
                
                RCADEBUGP(RCA_VERY_LOUD, ("PinDispatchIoControl: Completed IRP\n"));
        }

        RCADEBUGP(RCA_INFO, ("PinDispatchIoControl: Exit - "
                             "Returning Status == 0x%x\n", Status));
        

        return Status;

}


NTSTATUS
PinDispatchClose(
        IN      PDEVICE_OBJECT  DeviceObject,
        IN      PIRP                    Irp
        )
/*++

Routine Description:

        Closes a previously opened Pin instance. This can occur at any time in any order.
        If this is a FILEIO (BRIDGE) Pin, just clear up the Pin. THe associated VC stays around
        until it gets cleared up via NDIS.

Arguments:

        DeviceObject -
                Device object on which the close is occuring.

        Irp -
                Close Irp.

Return Values:

        Returns STATUS_SUCCESS.

--*/
{
        PIO_STACK_LOCATION              IrpStack;
        PFILTER_INSTANCE                FilterInstance;
        PPIN_INSTANCE_HEADER            PinInstance;
        NDIS_STATUS                     CloseCallStatus = NDIS_STATUS_PENDING;

        RCADEBUGP(RCA_INFO,("PinDispatchIoClose: Enter\n"));

        IrpStack = IoGetCurrentIrpStackLocation(Irp);
        PinInstance = (PPIN_INSTANCE_HEADER)IrpStack->FileObject->FsContext;
        FilterInstance = (PFILTER_INSTANCE)IrpStack->FileObject->RelatedFileObject->FsContext;

        // The closing of the File I/O Pin instance must be synchronized with any access to
        // that object.
        KeWaitForMutexObject(&FilterInstance->ControlMutex,
                                                 Executive,
                                                 KernelMode,
                                                 FALSE,
                                                 NULL);

        RCADEBUGP(RCA_LOUD, ("PinDispatchClose: Acquired filter instance control mutex\n"));

        //
        // These were allocated during the creation of the Pin instance.
        //
        KsFreeObjectHeader(PinInstance->Header);

        FilterInstance->PinFileObjects[PinInstance->PinId] = NULL;
                
        // If DEVIO, clear up event list.
        if (ID_DEVIO_PIN == PinInstance->PinId) { 
                
                RCADEBUGP(RCA_LOUD, ("PinDispatchClose: DEVIO pin\n"));
                
                if (FilterInstance->FilterType == FilterTypeCapture) {  
                        PPIN_INSTANCE_BRIDGE    pBridgePinInstance = FilterInstance->BridgePin;
                        NDIS_STATUS             LocalStatus;

                        if (pBridgePinInstance != NULL) {
                                RCA_ACQUIRE_BRIDGE_PIN_LOCK(pBridgePinInstance);

                                pBridgePinInstance->SignalMe = pBridgePinInstance->bWorkItemQueued;
                        
                                RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePinInstance);

                                if (pBridgePinInstance->SignalMe) {
                                        RCADEBUGP(RCA_LOUD, ("PinDispatchClose: "
                                                             "Waiting for worker threads\n"));
                                        RCABlock(&pBridgePinInstance->Block, &LocalStatus);
                                }

                        }

                        if (FilterInstance->NextFileObject != NULL) {
                                ObDereferenceObject(FilterInstance->NextFileObject);
                                FilterInstance->NextFileObject = NULL;
                                RCADEBUGP(RCA_LOUD, ("PinDispatchClose: "
                                                     "Set FilterInstance->NextFileObject = NULL\n"));
                        }
                }
        
        if (((PPIN_INSTANCE_DEVIO)PinInstance)->AllocatorObject) {
            ObDereferenceObject(((PPIN_INSTANCE_DEVIO)PinInstance)->AllocatorObject);
        }       
                //
                // Clean up the event list of anything still outstanding.
                //
                // KsFreeEventList(//                    IrpStack->FileObject,
                //                       &((PPIN_INSTANCE_DEVIO)PinInstance)->EventQueue,
                //                       KSEVENTS_FMUTEXUNSAFE,
                //                       &((PPIN_INSTANCE_DEVIO)PinInstance)->EventQueueLock);

                RCAFreeMem((PPIN_INSTANCE_DEVIO)PinInstance);
                FilterInstance->DevIoPin = NULL;
                
                RCADEBUGP(RCA_LOUD, ("PinDispatchClose: "
                                     "Set FilterInstance->DevIoPin = NULL\n"));
        
        } else {
                PPIN_INSTANCE_BRIDGE    pBridgePinInstance;

                RCADEBUGP(RCA_WARNING,("PinDispatchIoClose: BRIDGE pin\n"));
                
                pBridgePinInstance = (PPIN_INSTANCE_BRIDGE)IrpStack->FileObject->FsContext;
                
                RCA_ACQUIRE_BRIDGE_PIN_LOCK(pBridgePinInstance);
                
                if (pBridgePinInstance->VcContext) {
            RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePinInstance);

                        RCACoNdisCloseCallOnVc(pBridgePinInstance->VcContext);

                        RCA_ACQUIRE_BRIDGE_PIN_LOCK(pBridgePinInstance);
                        
                        if (FilterInstance->FilterType == FilterTypeRender) {
                                RCACoNdisReleaseSendVcContext(pBridgePinInstance->VcContext);
                        } else {
                                RCACoNdisReleaseReceiveVcContext(pBridgePinInstance->VcContext);
                        }

                        pBridgePinInstance->VcContext = NULL;

                        if (pBridgePinInstance->FilterInstance->DevIoPin)
                                pBridgePinInstance->FilterInstance->DevIoPin->VcContext = NULL;

            RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePinInstance);
                } else {
                        RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePinInstance);
                }


                if (FilterInstance->FilterType == FilterTypeCapture) {
                    NDIS_STATUS         LocalStatus;
                        
                        RCA_ACQUIRE_BRIDGE_PIN_LOCK(pBridgePinInstance);

                        pBridgePinInstance->SignalMe = pBridgePinInstance->bWorkItemQueued;
                        
                        RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePinInstance);

                        if (pBridgePinInstance->SignalMe) {
                                RCADEBUGP(RCA_LOUD, ("PinDispatchClose: "
                                                     "Waiting for worker threads\n"));
                                
                                RCABlock(&pBridgePinInstance->Block, &LocalStatus);
                        }

                } 


                RCA_ACQUIRE_BRIDGE_PIN_LOCK(pBridgePinInstance);
                
                if (pBridgePinInstance->pDataFormat) {
                        RCAFreeMem(pBridgePinInstance->pDataFormat);
                }

                RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePinInstance);

                RCAFreeMem((PPIN_INSTANCE_BRIDGE)PinInstance);
                
                FilterInstance->BridgePin = NULL;
                
                RCADEBUGP(RCA_LOUD, ("PinDispatchClose: "
                                                         "Set FilterInstance->BridgePin = NULL\n"));
       

        }
        
        KeReleaseMutex(&FilterInstance->ControlMutex, FALSE );
                
        RCADEBUGP(RCA_LOUD, ("PinDispatchClose: Released filter instance control mutex\n"));
        
        //
        // All Pins are created with a root file object, which is the Filter, and was
        // previously referenced during creation.
        //
        RCADEBUGP(RCA_WARNING,("PinDispatchClose: ObDereferenceObject\n"));
        ObDereferenceObject(IrpStack->FileObject->RelatedFileObject);
        
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        RCADEBUGP(RCA_LOUD, ("PinDispatchClose: Completed IRP\n"));      
        
        RCADEBUGP(RCA_INFO, ("PinDispatchClose: Exit - Returning STATUS_SUCCESS"));

        return STATUS_SUCCESS;
}


NTSTATUS
FilterDispatchCreate(
        IN      PDEVICE_OBJECT  DeviceObject,
        IN      PIRP                    Irp
        )
/*++

Routine Description:

        Dispatches the creation of a Filter instance. Allocates the object header and initializes
        the data for this Filter instance.

Arguments:

        DeviceObject -
                Device object on which the creation is occuring.

        Irp -
                Creation Irp.

Return Values:

        Returns STATUS_SUCCESS on success, STATUS_INSUFFICIENT_RESOURCES or some related error
        on failure.

--*/
{
        PIO_STACK_LOCATION              irpSp;
        PKSOBJECT_CREATE_ITEM   CreateItem;
        NTSTATUS                                Status;

        RCADEBUGP(RCA_INFO, ("FilterDispatchCreate: Enter\n"));

        //
        // Notify the software bus that this device is in use.
        //
        Status = KsReferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);

        if (!NT_SUCCESS(Status)) {
                RCADEBUGP(RCA_ERROR, ("FilterDispatchCreate: "
                                                          "KsReferenceSoftwareBusObject failed, Status == 0x%x\n", Status));
        } else {  
                PFILTER_INSTANCE        FilterInstance;

                irpSp = IoGetCurrentIrpStackLocation( Irp );
                CreateItem = KSCREATE_ITEM_IRP_STORAGE( Irp );

                //
                // Create the instance information. This contains the list of current Pins, and
                // the mutex used when modifying pins.
                //
                RCAAllocMem( FilterInstance,  FILTER_INSTANCE, sizeof(FILTER_INSTANCE));
                
                if (FilterInstance)
                {
                        RCAMemSet((PUCHAR)FilterInstance, 0, sizeof(FILTER_INSTANCE));

                        //
                        // Render or Capture?
                        //
                        FilterInstance->FilterType = (FILTER_TYPE) CreateItem->Context;

                        RCADEBUGP(RCA_LOUD, ("FilterDispatchCreate: "
                                             "Creating filter of type 0x%x\n", FilterInstance->FilterType));


                        //
                        // This object uses KS to perform access through the FilterCreateItems and
                        // FilterDispatchTable.
                        //
                        Status = KsAllocateObjectHeader(&FilterInstance->Header,
                                                        SIZEOF_ARRAY(FilterObjectCreateDispatch),
                                                        (PKSOBJECT_CREATE_ITEM)FilterObjectCreateDispatch,
                                                        Irp,
                                                        (PKSDISPATCH_TABLE)&FilterDispatchTable);

                        if (!NT_SUCCESS(Status)) {
                                RCADEBUGP(RCA_ERROR, ("FilterDispatchCreate: "
                                                      "KsAllocateObjectHeader failed, Status == 0x%x\n",
                                                      Status));
                        } else {
                                ULONG           PinCount;

                                RtlCopyMemory(FilterInstance->PinInstances,
                                              PinInstances,
                                              sizeof(PinInstances));

                                KeInitializeMutex( &FilterInstance->ControlMutex, 1 );

                                //
                                // Initialize the list of Pins on this Filter to an unconnected state.
                                //
                                for (PinCount = SIZEOF_ARRAY(FilterInstance->PinFileObjects);
                                     PinCount;
                                     NOTHING)
                                {
                                        FilterInstance->PinFileObjects[--PinCount] = NULL;
                                }

                                //
                                // No audio data format set up yet for this filter instance. Wildcard it.
                                //
                                //RtlCopyMemory (&FilterInstance->DataFormat, &PinFileIoRange, sizeof (KSDATAFORMAT));

                                //
                                // KS expects that the filter object data is in FsContext.
                                //
                                IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext = FilterInstance;
                        }

                } else {
                        RCADEBUGP (RCA_ERROR, ("FilterDispatchCreate: "
                                               "Could not allocate memory for filter instance, "
                                               "Setting Status == STATUS_INSUFFICIENT_RESOURCES\n"));

                        KsDereferenceSoftwareBusObject(
                                                       ((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header );
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                }

        }


        Irp->IoStatus.Status = Status;
        
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        RCADEBUGP(RCA_LOUD, ("FilterDispatchCreate: Completed IRP\n"));

        RCADEBUGP(RCA_INFO, ("FilterDispatchCreate: Exit - "
                             "Setting Irp->IoStatus.Status and Returning 0x%x\n", Status));
                
        return Status;
}


NTSTATUS
FilterPinIntersection(
        IN      PIRP            Irp,
        IN      PKSP_PIN        Pin,
        OUT     PVOID           Data
        )
/*++

Routine Description:

        Handles the KSPROPERTY_PIN_DATAINTERSECTION property in the Pin property set.
        Returns the first acceptable data format given a list of data ranges for a specified
        Pin factory.

Arguments:

        Irp -
                Device control Irp.

        Pin -
                Specific property request followed by Pin factory identifier, followed by a
                KSMULTIPLE_ITEM structure. This is followed by zero or more data range structures.

        Data -
                The place in which to return the data format selected as the first intersection
                between the list of data ranges passed, and the acceptable formats.

Return Values:

        returns STATUS_SUCCESS, else STATUS_INVALID_PARAMETER or STATUS_BUFFER_TOO_SMALL.

--*/
{
        PFILTER_INSTANCE        FilterInstance;
        PIO_STACK_LOCATION  IrpStack;
        NTSTATUS                        Status = 0;

        RCADEBUGP(RCA_INFO, ("FilterPinIntersection: Enter\n"));
        
        IrpStack = IoGetCurrentIrpStackLocation(Irp);
        FilterInstance = (PFILTER_INSTANCE)IrpStack->FileObject->FsContext;
        
        RCADEBUGP(RCA_LOUD, ("FilterPinIntersection: FilterInstance == 0x%x\n", FilterInstance));

        Status = KsPinDataIntersection(Irp,
                                       Pin,
                                       Data,
                                       SIZEOF_ARRAY(PinDescriptors),
                                       (FilterInstance->FilterType == FilterTypeRender ?
                                        RenderPinDescriptors : CapturePinDescriptors),
                                       RCAIntersect);
                                                                   
        RCADEBUGP(RCA_INFO, ("FilterPinIntersection: Exit - "
                             "Returning Status == 0x%x\n", Status));
        
        return Status;
}


NTSTATUS
PinDeviceState(
        IN      PIRP                    Irp,
        IN      PKSPROPERTY     Property,
        IN      OUT PKSSTATE    DeviceState
        )

/*++

Routine Description:


Arguments:
        IN PIRP Irp -
                pointer to I/O request packet

        IN PKSPROPERTY Property -
                pointer to the property structure

        IN OUT PKSSTATE DeviceState -
                pointer to a KSSTATE, filled on GET otherwise contains
                the new state to set the pin

Return:
        STATUS_SUCCESS or an appropriate error code

--*/
{
        NTSTATUS                Status = STATUS_SUCCESS;
        PFILE_OBJECT            FileObject;
        PIO_STACK_LOCATION      irpSp;
        PFILTER_INSTANCE        FilterInstance;
        PPIN_INSTANCE_DEVIO     PinInstance;  
        PPIN_INSTANCE_BRIDGE    pBridgePinInstance;

        RCADEBUGP(RCA_INFO, ("PinDeviceState: Enter\n"));

        irpSp = IoGetCurrentIrpStackLocation( Irp );

        FilterInstance = (PFILTER_INSTANCE) irpSp->FileObject->RelatedFileObject->FsContext;

        PinInstance = (PPIN_INSTANCE_DEVIO) irpSp->FileObject->FsContext;

        pBridgePinInstance = FilterInstance->BridgePin;

        ASSERT((PinInstance->InstanceHdr).PinId == ID_DEVIO_PIN);

        //
        // Both sides of the connection must exist.
        //

        if (!(FileObject = FilterInstance->PinFileObjects[ID_BRIDGE_PIN]))
        {
                RCADEBUGP(RCA_ERROR, ("PinDeviceState: "
                                      "Bridge pin file object is NULL, "
                                      "returning STATUS_DEVICE_NOT_CONNECTED\n"));
                return STATUS_DEVICE_NOT_CONNECTED;
        }

        //
        // Synchronize pin state changes
        //

        KeWaitForMutexObject(&FilterInstance->ControlMutex,
                                                 Executive,
                                                 KernelMode,
                                                 FALSE,
                                                 NULL);

        RCADEBUGP(RCA_LOUD, ("PinDeviceState: Acquired Filter instance control mutex\n"));

        if (Property->Flags & KSPROPERTY_TYPE_GET)
        {
                if((PinInstance->DeviceState == KSSTATE_PAUSE) &&
                        (FilterInstance->FilterType == FilterTypeCapture)) 
                {

                        RCADEBUGP(RCA_ERROR, ("PinDeviceState: Capture device is paused, "
                                              "setting Status = STATUS_NO_DATA_DETECTED\n"));

                        Status = STATUS_NO_DATA_DETECTED;

                }
                
                *DeviceState = PinInstance->DeviceState;
                KeReleaseMutex( &FilterInstance->ControlMutex, FALSE );
                Irp->IoStatus.Information = sizeof( KSSTATE );
 
                RCADEBUGP(RCA_INFO, ("PinDeviceState: "
                                     "Returning DeviceState == 0x%x, Status == 0x%x\n",
                                     *DeviceState, Status));
   
                return Status;
        }

        Irp->IoStatus.Information = 0;

        if (PinInstance->DeviceState == *DeviceState)
        {
                KeReleaseMutex( &FilterInstance->ControlMutex, FALSE );

                RCADEBUGP(RCA_LOUD, ("PinDeviceState: Released Filter instance control mutex\n"));
                
                RCADEBUGP(RCA_INFO, ("PinDeviceState: State is unchanged, returning STATUS_SUCCESS\n"));
                
                return STATUS_SUCCESS;
        }

        switch(*DeviceState)
        {
          case KSSTATE_ACQUIRE:
                RCADEBUGP(RCA_INFO, ("PinDeviceState: Going to set state to ACQUIRE\n"));
                break;

          case KSSTATE_RUN:
                RCADEBUGP(RCA_INFO, ("PinDeviceState: Going to set state to RUN\n"));
                break;

          case KSSTATE_PAUSE:
                RCADEBUGP(RCA_INFO, ("PinDeviceState: Going to set state to PAUSE\n"));
                break;

          case KSSTATE_STOP:
                RCADEBUGP(RCA_INFO, ("PinDeviceState: Going to set state to STOP\n"));
#if AUDIO_SINK_FLAG
                if ((FilterInstance->FilterType == FilterTypeCapture) && (PinInstance->ConnectedAsSink))
                {
                        // Cancel all the pending IRPs on the ActiveQueue
                        KsCancelIo(&PinInstance->ActiveQueue, &PinInstance->QueueLock);
                        RCADEBUGP(RCA_LOUD, ("PinDeviceState: Cancelled I/O\n"));
                }
#endif

                if (FilterInstance->FilterType == FilterTypeCapture) {
                        if (pBridgePinInstance != NULL) {
                                NDIS_STATUS LocalStatus;
                                
                                RCA_ACQUIRE_BRIDGE_PIN_LOCK(pBridgePinInstance);

                                pBridgePinInstance->SignalMe = pBridgePinInstance->bWorkItemQueued;

                                RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePinInstance);

                                if (pBridgePinInstance->SignalMe) {
                                        RCADEBUGP(RCA_LOUD, ("PinDeviceState: "
                                                             "Waiting for worker threads\n"));
                                        RCABlock(&pBridgePinInstance->Block, &LocalStatus);
                                }

                        }
                } 
                
                KsRecalculateStackDepth(((PDEVICE_INSTANCE)irpSp->DeviceObject->DeviceExtension)->Header,
                                                                FALSE );
            
                break;
        }

        PinInstance->DeviceState = *DeviceState;

        KeReleaseMutex(&FilterInstance->ControlMutex, FALSE);
        
        RCADEBUGP(RCA_LOUD, ("PinDeviceState: Released Filter instance control mutex\n"));

        RCADEBUGP(RCA_INFO, ("PinDeviceState: Exit - Returning STATUS_SUCCESS\n"));

        return STATUS_SUCCESS;
}


NTSTATUS
PinAllocatorFramingEx(
        IN PIRP                         Irp,
        IN PKSPROPERTY                  Property,
        IN OUT PKSALLOCATOR_FRAMING_EX  FramingEx
        )
{
        NTSTATUS                        Status;
                PIO_STACK_LOCATION              pIrpSp;
                PPIN_INSTANCE_HEADER    pPin;
                FILTER_TYPE                             FilterType;
                PVOID                                   VcContext;
                ULONG                                   ulFrameSize;

                RCADEBUGP(RCA_INFO, ("PinAllocatorFramingEx: Enter\n"));

                pIrpSp = IoGetCurrentIrpStackLocation(Irp);
                
                pPin = (PPIN_INSTANCE_HEADER) pIrpSp->FileObject->FsContext;

                if (pPin->PinId == ID_DEVIO_PIN) {
            
                        PPIN_INSTANCE_DEVIO             pDevioPin;

                        pDevioPin = (PPIN_INSTANCE_DEVIO) pPin;
                        FilterType = pDevioPin->FilterInstance->FilterType;     
                        RCA_ACQUIRE_BRIDGE_PIN_LOCK(pDevioPin->FilterInstance->BridgePin);

                        VcContext = pDevioPin->VcContext;

            RCA_RELEASE_BRIDGE_PIN_LOCK(pDevioPin->FilterInstance->BridgePin);

                } else if (pPin->PinId == ID_BRIDGE_PIN) {
                        
                        PPIN_INSTANCE_BRIDGE    pBridgePin;

                        pBridgePin = (PPIN_INSTANCE_BRIDGE) pPin;
                        FilterType = pBridgePin->FilterInstance->FilterType;

                        RCA_ACQUIRE_BRIDGE_PIN_LOCK(pBridgePin);

                        VcContext = pBridgePin->VcContext;

                        RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePin);
        
                } else {
                        RCADEBUGP(RCA_FATAL, ("PinAllocatorFramingEx: Got an unkown pin ID 0x%d - returning STATUS_UNSUCCESSFUL\n", 
                                                                  pPin->PinId));
                        Irp->IoStatus.Information = 0;
                        return STATUS_UNSUCCESSFUL;
                }

                
                if (VcContext == NULL) {
                        RCADEBUGP(RCA_ERROR, 
                                          ("PinAllocatorFramingEx: Cannot determine max SDU sizes because we have no VC Context"
                                           " - returning STATUS_UNSUCCESSFUL\n"));
                        Irp->IoStatus.Information = 0;
                        return STATUS_UNSUCCESSFUL;
                }
                                
                //
                // FIXME: The VC could go away between the time when we release the bridge
                //        pin lock and here, so we could be handling a bogus vc context now. 
                //                Let's see if this causes any problems.  
                //
                
                if (FilterType == FilterTypeRender) {
                        RCACoNdisGetMaxSduSizes(VcContext,
                                                                        NULL,
                                                                        &ulFrameSize);
                } else {
                        RCACoNdisGetMaxSduSizes(VcContext,   
                                                                        &ulFrameSize,
                                                                        NULL);
                }
                
                //
                // For debugging only.
                //
        
                if (g_ulBufferSize > 0) {
                        RCADEBUGP(RCA_ERROR, ("PinAllocatorFramingEx: Hardcoded buffer size to 0x%x\n", g_ulBufferSize));
                        ulFrameSize = g_ulBufferSize;
                }

                RCADEBUGP(RCA_LOUD, ("PinAllocatorFramingEx: Frame size set to 0x%x\n", ulFrameSize));
                
                INITIALIZE_SIMPLE_FRAMING_EX(FramingEx, 
                                                                         KSMEMORY_TYPE_KERNEL_PAGED, 
                                                                         KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY, // Note: you don't set the  KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY here, so KsProxy thinks that you insist on your framing.
                                                                         8,  // number of frames
                                                                         FILE_QUAD_ALIGNMENT,
                                                                         ulFrameSize,  // min. requested frame size
                                                                         ulFrameSize   // max requested frame size
                                                                         );

        Irp->IoStatus.Information=sizeof(KSALLOCATOR_FRAMING_EX);

                RCADEBUGP(RCA_INFO, ("PinAllocatorFramingEx: Exit - Returning STATUS_SUCCESS\n"));
        
                return STATUS_SUCCESS;
}


NTSTATUS
GetStreamAllocator(
        IN      PIRP                                    Irp,
        IN      PKSPROPERTY                             Property,
        IN      OUT PVOID *                             AllocatorHandle
        )
{
        PIO_STACK_LOCATION        irpSp;
        PPIN_INSTANCE_DEVIO      PinInstance;

        RCADEBUGP(RCA_INFO,("GetStreamAllocator: enter\n"));

        irpSp = IoGetCurrentIrpStackLocation( Irp );
        PinInstance = (PPIN_INSTANCE_DEVIO) irpSp->FileObject->FsContext;

        *AllocatorHandle=(PVOID)NULL;

        Irp->IoStatus.Information=sizeof(PVOID);

        RCADEBUGP(RCA_INFO, ("GetStreamAllocator: Exit - Returning Status == STATUS_SUCCESS\n"));
        return STATUS_SUCCESS;
}


NTSTATUS
SetStreamAllocator(
        IN      PIRP                                    Irp,
        IN      PKSPROPERTY                             Property,
        IN      OUT PVOID *                             AllocatorHandle
        )
{
        PIO_STACK_LOCATION        irpSp;
        PPIN_INSTANCE_DEVIO      PinInstance;

        RCADEBUGP(RCA_INFO,("SetStreamAllocator: enter\n"));

        irpSp = IoGetCurrentIrpStackLocation( Irp );
        PinInstance = (PPIN_INSTANCE_DEVIO) irpSp->FileObject->FsContext;

        if (AllocatorHandle != NULL) { 

                if (PinInstance->AllocatorObject) {
                        //
                        // If we've already got an allocator object, get rid of it.
                        //
                        ObDereferenceObject(PinInstance->AllocatorObject);
                }


                ObReferenceObjectByHandle((HANDLE)*AllocatorHandle,
                                          0,
                                          NULL,
                                          KernelMode,
                                          &PinInstance->AllocatorObject,
                                          NULL);
        }

        Irp->IoStatus.Information=sizeof(ULONG);

        RCADEBUGP(RCA_INFO, ("SetStreamAllocator: Exit - Returning Status == STATUS_SUCCESS\n"));

        return STATUS_SUCCESS;
}


NTSTATUS
RCASetProposedDataFormat(
                         IN PIRP                        Irp,
                         IN PKSPROPERTY         Property,
                         IN PKSDATAFORMAT       DataFormat
                         )
/*++

Routine Description:
        This is the handler for setting the write only property
        KSPROPERTY_PIN_PROPOSEDATAFORMAT. It simply makes a copy
        of whatever data format is passed in. This copy will be
        the data format returned in all future data range 
        intersection requests. 

Arguments:
        IN PIRP Irp -
                Pointer to I/O request packet

        IN PKSPROPERTY Property -
                Pointer to the property structure

        IN DataFormat -
                Pointer to the data format to copy

Return:
        STATUS_SUCCESS or an appropriate error code

--*/

{
        NTSTATUS                Status = STATUS_SUCCESS;
        PIO_STACK_LOCATION      irpSp;
        PPIN_INSTANCE_BRIDGE    pBridgePin;
        
        RCADEBUGP(RCA_INFO, ("RCASetProposedDataFormat: Enter\n"));
        
        irpSp = IoGetCurrentIrpStackLocation(Irp);
        pBridgePin = (PPIN_INSTANCE_BRIDGE) irpSp->FileObject->FsContext;

        do {
                RCA_ACQUIRE_BRIDGE_PIN_LOCK(pBridgePin);
                 
                if (pBridgePin->pDataFormat) {
                        //
                        // If a data format was set by a previous call to this 
                        // routine, free the memory used by that data format.
                        //
                        RCAFreeMem(pBridgePin->pDataFormat);
                }

                RCAAllocMem(pBridgePin->pDataFormat, KSDATAFORMAT, DataFormat->FormatSize);

                if (pBridgePin->pDataFormat) {
                        
                        RtlCopyMemory(pBridgePin->pDataFormat, DataFormat, DataFormat->FormatSize);
                        
                } else {
                        RCADEBUGP(RCA_ERROR, ("RCASetProposedDataFormat: "
                                              "Failed to allocate memory for data format storage, setting "
                                              "Status = STATUS_INSUFFICIENT_RESOURCES\n"));
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                }

                RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePin);
        } while(FALSE);


        RCADEBUGP(RCA_INFO, ("RCASetProposedDataFormat: Exit - Returning Status == 0x%x\n",
                             Status));

        return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rca\rcandis.c ===
#include <precomp.h>

#define MODULE_NUMBER   MODULE_NDIS
#define _FILENUMBER             'SIDN' 


RCA_PROTOCOL_CONTEXT    GlobalContext;




NDIS_STATUS
RCACoNdisInitialize(
                                        IN      PRCA_CO_NDIS_HANDLERS   pHandlers,
                                        IN      ULONG                                   ulInitTimeout
                                        )
/*++
Routine Description:
        Initializes the Co-NDIS client.                 
        
Arguments:
        pHandlers               - Pointer to RCA_CO_NDIS_HANDLERS structure containing pointers
                                          to functions that will be called in response to various events.
        ulInitTimeout   - Number of milliseconds to allow initialization to proceed. If 
                          it has not completed in this time, it will abort.    
 
Return value:
        NDIS_STATUS_SUCCESS     if all went OK, NDIS_STATUS_FAILURE in the case of a timeout,
        or some other pertinent error code otherwise. 
--*/

{
        NDIS_STATUS                             Status;
        PRCA_PROTOCOL_CONTEXT   pProtocolContext = &GlobalContext;

        RCADEBUGP(RCA_INFO, ("RCACoNdisInitialize: Enter\n"));

        do {
        NDIS_PROTOCOL_CHARACTERISTICS   RCAProtocolCharacteristics;

                RCADEBUGP(RCA_LOUD, ("RCACoNdisInitialize: Protocol context block is at 0x%x\n", pProtocolContext));

                //
                // Initialize the protocol context.
                //
                NdisZeroMemory(pProtocolContext, sizeof(RCA_PROTOCOL_CONTEXT));
        
#if DBG
                pProtocolContext->rca_sig = rca_signature;
#endif

                NdisAllocateSpinLock(&pProtocolContext->SpinLock);

                RCAInitBlockStruc(&pProtocolContext->BindingInfo.Block);

                //
                // Copy the handlers passed to us. 
                //
                
                RtlCopyMemory(&pProtocolContext->Handlers, pHandlers, sizeof(RCA_CO_NDIS_HANDLERS));

                //
                // Set up our protocol characteristics and register as an NDIS protocol. 
                // 

        NdisZeroMemory (&RCAProtocolCharacteristics, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

                RCAProtocolCharacteristics.MajorNdisVersion = NDIS_MAJOR_VERSION;
                RCAProtocolCharacteristics.MinorNdisVersion = NDIS_MINOR_VERSION;
                RCAProtocolCharacteristics.Filler  = 0;
                RCAProtocolCharacteristics.Flags  =     NDIS_PROTOCOL_BIND_ALL_CO;
                RCAProtocolCharacteristics.CoAfRegisterNotifyHandler =  RCANotifyAfRegistration;
                RCAProtocolCharacteristics.OpenAdapterCompleteHandler =  RCAOpenAdapterComplete;
                RCAProtocolCharacteristics.CloseAdapterCompleteHandler = RCACloseAdapterComplete;
                RCAProtocolCharacteristics.TransferDataCompleteHandler = RCATransferDataComplete;
                RCAProtocolCharacteristics.ResetCompleteHandler = RCAResetComplete;
                RCAProtocolCharacteristics.SendCompleteHandler = RCASendComplete;
                RCAProtocolCharacteristics.RequestCompleteHandler =     RCARequestComplete;
                RCAProtocolCharacteristics.ReceiveHandler =     RCAReceive;
                RCAProtocolCharacteristics.ReceiveCompleteHandler =     RCAReceiveComplete;
                RCAProtocolCharacteristics.ReceivePacketHandler = RCAReceivePacket;
                RCAProtocolCharacteristics.StatusHandler = RCAStatus;
                RCAProtocolCharacteristics.StatusCompleteHandler = RCAStatusComplete;
                RCAProtocolCharacteristics.BindAdapterHandler = RCABindAdapter;
                RCAProtocolCharacteristics.UnbindAdapterHandler = RCAUnbindAdapter;
                RCAProtocolCharacteristics.PnPEventHandler = RCAPnPEventHandler;
                RCAProtocolCharacteristics.UnloadHandler = NULL;
                RCAProtocolCharacteristics.CoStatusHandler = RCACoStatus;
                RCAProtocolCharacteristics.CoReceivePacketHandler =     RCACoReceivePacket;
                RCAProtocolCharacteristics.CoSendCompleteHandler = RCACoSendComplete;
                NdisInitUnicodeString(&(RCAProtocolCharacteristics.Name), RCA_CL_NAME);

                NdisRegisterProtocol(&Status,
                                                         &pProtocolContext->RCAClProtocolHandle,
                                                         &RCAProtocolCharacteristics, 
                                                         sizeof(RCAProtocolCharacteristics));


                if (Status != NDIS_STATUS_SUCCESS) {
                        RCADEBUGP(RCA_ERROR, ("RCACoNdisInitialize: "
                                                                  "Failed to register as an NDIS Protocol - status == 0x%x\n",
                                                                  Status));
                        break;
                }

                //
                // Block waiting for indications/bindings to complete.
                //

                RCABlockTimeOut(&pProtocolContext->BindingInfo.Block, ulInitTimeout, &Status);
                

                if (Status == STATUS_TIMEOUT) {
                        Status = NDIS_STATUS_FAILURE;
                        
                        RCADEBUGP(RCA_ERROR, ("RCACoNdisInitialize: "
                                                                  "Initialization timed out, setting Status = NDIS_STATUS_FAILURE\n"));

                        break;
                }
                


        } while (FALSE);


        if (Status != NDIS_STATUS_SUCCESS) {
                //
                // Cleanup / bail out.
                //

                RCACoNdisUninitialize();

        } 


        RCADEBUGP(RCA_INFO, ("RCACoNdisInitialize: Exit - Returning status 0x%x\n", Status));
        return Status;
}



VOID
RCACoNdisUninitialize(
                                          
                                          )
/*++
Routine Description:
        Uninitializes the Co-NDIS client and frees up any resources used by it. 
        
Arguments:
        (None)

Return value:
        (None)    
--*/

{
        PRCA_PROTOCOL_CONTEXT   pProtocolContext = &GlobalContext;
        NDIS_STATUS                             Status;

        RCADEBUGP(RCA_INFO, ("RCACoNdisUninitialize: Enter\n"));

        //
        // Deregister our protocol.
        //
        if (pProtocolContext->RCAClProtocolHandle != (NDIS_HANDLE)NULL) {
                NdisDeregisterProtocol(&Status, pProtocolContext->RCAClProtocolHandle); 
        }

        RCADEBUGP(RCA_INFO, ("RCACoNdisUninitialize: Exit\n"));
}



NDIS_STATUS
RCAPnPSetPower(
               IN PRCA_ADAPTER          pAdapter, 
               IN PNET_PNP_EVENT        NetPnPEvent
               )
{
        PNET_DEVICE_POWER_STATE         pPowerState;
        NDIS_STATUS                                     Status;
        RCADEBUGP(RCA_INFO, ("RCAPnPSetPower: enter\n"));
        
        pPowerState = (PNET_DEVICE_POWER_STATE)NetPnPEvent->Buffer;

        switch (*pPowerState) {
                case NetDeviceStateD0:
                        Status = NDIS_STATUS_SUCCESS;
                        break;
                default:
                        Status = NDIS_STATUS_NOT_SUPPORTED;

        };

        RCADEBUGP(RCA_INFO, ("RCAPnPSetPower: exit\n"));
        return Status;
}

NDIS_STATUS
RCAPnPQueryPower(
                 IN PRCA_ADAPTER        pAdapter, 
                 IN PNET_PNP_EVENT      NetPnPEvent
                 )
{
        RCADEBUGP(RCA_INFO, ("RCAPnPQueryPower: enter\n"));

        RCADEBUGP(RCA_INFO, ("RCAPnPQueryPower: exit\n"));
        
        return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
RCAPnPQueryRemoveDevice(
                        IN PRCA_ADAPTER         pAdapter, 
                        IN PNET_PNP_EVENT       NetPnPEvent
                        )
{
        RCADEBUGP(RCA_INFO, ("RCAPnPQueryRemoveDevice: enter\n"));

        RCADEBUGP(RCA_INFO, ("RCAPnPQueryRemoveDevice: exit\n"));
        
        return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
RCAPnPCancelRemoveDevice(
                         IN PRCA_ADAPTER        pAdapter, 
                         IN PNET_PNP_EVENT      NetPnPEvent
                         )
{
        RCADEBUGP(RCA_INFO, ("RCAPnPCancelRemoveDevice: enter\n"));

        RCADEBUGP(RCA_INFO, ("RCAPnPCancelRemoveDevice: exit\n"));
        
        return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
RCAPnPEventBindsComplete(
                         IN PRCA_ADAPTER        pAdapter, 
                         IN PNET_PNP_EVENT      NetPnPEvent
                         )
{
        PRCA_PROTOCOL_CONTEXT   pProtocolContext = &GlobalContext;
        NDIS_STATUS                     Status = NDIS_STATUS_SUCCESS;

        RCADEBUGP(RCA_INFO, ("RCAPnPEventBindsComplete: enter\n"));
        
        ACQUIRE_SPIN_LOCK(&pProtocolContext->SpinLock);

        RCADEBUGP(RCA_LOUD, ("RCAPnPEventBindsComplete: Acquired global protocol context lock\n"));

        pProtocolContext->BindingInfo.BindingsComplete = TRUE;

        if (pProtocolContext->BindingInfo.SAPCnt == pProtocolContext->BindingInfo.AdapterCnt) {
                RCADEBUGP(RCA_INFO, ("RCAPnPEventBindsComplete: Unblocking RCACoNdisInitialize(), Counts == %d\n", 
                                                         pProtocolContext->BindingInfo.AdapterCnt)); 

                RCASignal(&pProtocolContext->BindingInfo.Block, Status);
        } else {
                RCADEBUGP(RCA_INFO, ("RCAPnPEventBindsComplete: "
                                                         "Not unblocking RCACoNdisInitialize()- SAPCnt == %d, AdapterCnt == %d\n",
                                                         pProtocolContext->BindingInfo.SAPCnt, pProtocolContext->BindingInfo.AdapterCnt));
        }       

        RELEASE_SPIN_LOCK(&pProtocolContext->SpinLock);
        
        RCADEBUGP(RCA_LOUD, ("RCAPnPEventBindsComplete: Released global protocol context lock\n"));

        RCADEBUGP(RCA_INFO, ("RCAPnPEventBindsComplete: exit\n"));

        return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
RCAPnPEventHandler(
                   IN   NDIS_HANDLE     ProtocolBindingContext,
                   IN   PNET_PNP_EVENT  NetPnPEvent
                   )
/*++

Routine Description:
        Called by NDIS in to indicate a PNP event.
        
Arguments:
        ProtocolBindingContext  -       Actually a pointer to the adapter structure
        NetPnPEvent             -       Pointer to the event
        
Return value:
        NDIS_STATUS_SUCCESS for those events we support, NDIS_STATUS_NOT_SUPPORTED for those we don't.          
        
--*/
{
        NDIS_STATUS Status;
        PRCA_ADAPTER pAdapter;

        RCADEBUGP(RCA_INFO, ("RCAPnPEventHandler: enter\n"));


        pAdapter = (PRCA_ADAPTER)ProtocolBindingContext;

        switch(NetPnPEvent->NetEvent) {
                case NetEventSetPower:          
                        Status = RCAPnPSetPower(pAdapter, NetPnPEvent);
                        break;
                case NetEventQueryPower:        
                        Status = RCAPnPQueryPower(pAdapter, NetPnPEvent);
                        break;
                case NetEventQueryRemoveDevice:
                        Status = RCAPnPQueryRemoveDevice(pAdapter, NetPnPEvent);
                        break;
                case NetEventCancelRemoveDevice:
                        Status = RCAPnPCancelRemoveDevice(pAdapter, NetPnPEvent);
                        break;
                case NetEventBindsComplete:
                        Status = RCAPnPEventBindsComplete(pAdapter, NetPnPEvent);
                        break;
                default:
                        Status = NDIS_STATUS_NOT_SUPPORTED;
        };


        RCADEBUGP(RCA_INFO, ("RCAPnPEventHandler: exit, returning %x\n", Status));
        
        return Status;
}


VOID
RCABindAdapter(
                           OUT PNDIS_STATUS             pStatus,
                           IN  NDIS_HANDLE              BindContext,
                           IN  PNDIS_STRING             DeviceName,
                           IN  PVOID                    SystemSpecific1,
                           IN  PVOID                    SystemSpecific2
                           )
/*++

Routine Description:
        Entry point that gets called by NDIS when an adapter appears on the
        system.

Arguments:
        pStatus - place for our Return Value
        BindContext - to be used if we call NdisCompleteBindAdapter; we don't
        DeviceName - Name of the adapter to be bound to
        SystemSpecific1 - Name of the protocol-specific entry in this adapter's
                        registry section
        SystemSpecific2 - Not used

Return Value:
        None. We set *pStatus to NDIS_STATUS_SUCCESS if everything goes off well,
        otherwise an NDIS error status.

--*/
{
        PRCA_PROTOCOL_CONTEXT   pProtocolContext = &GlobalContext;
        PRCA_ADAPTER                    *ppNextAdapter;
        NDIS_STATUS                             OpenError;
        UINT                                    SelectedIndex;
        PRCA_ADAPTER                    pAdapter;
        NDIS_MEDIUM                             Media[] = {NdisMediumAtm, NdisMediumCoWan}; // This should be more generic
        NDIS_STATUS                             Status;

        RCADEBUGP(RCA_INFO,("RCABindAdapter: Enter\n"));

        do
        {
                //
                // Allocate adapter structure. 
                // 
                RCAAllocMem(pAdapter, RCA_ADAPTER, sizeof(RCA_ADAPTER));

                if (pAdapter == (PRCA_ADAPTER)NULL) {           
                        RCADEBUGP(RCA_ERROR, ("RCABindAdapter: Could not allocate memory for adapter, "
                                                                  "setting status to NDIS_STATUS_RESOURCES\n"));
                        Status = NDIS_STATUS_RESOURCES;
                        break;
                }

                RCADEBUGP(RCA_INFO, ("RCABindAdapter: New adapter allocated at 0x%x\n", pAdapter));
                
                //
                // Initialize the new adapter structure
                //

                NdisZeroMemory(pAdapter, sizeof(RCA_ADAPTER));

#if     DBG
                pAdapter->rca_sig = rca_signature;
#endif
                
                RCAInitBlockStruc(&pAdapter->Block);
                
                NdisAllocateSpinLock(&pAdapter->SpinLock);
                
                NdisInitializeWorkItem(&pAdapter->DeactivateWorkItem, 
                                                           RCADeactivateAdapterWorker,
                                                           (PVOID)pAdapter);

                RCAInitBlockStruc(&pAdapter->DeactivateBlock);

                //
                // Link the adapter into the global list.
                //

                ACQUIRE_SPIN_LOCK(&pProtocolContext->SpinLock);
                
                RCADEBUGP(RCA_LOUD, ("RCABindAdapter: Acquired global protocol spinlock\n"));

                //
                // Now ppNextAdapter points to the new adapter's would-be predecessor's
                // Next pointer; chain the new adapter to follow this predecessor:
                //
                LinkDoubleAtHead(pProtocolContext->AdapterList, pAdapter, NextAdapter, PrevAdapter);
                
                RELEASE_SPIN_LOCK(&pProtocolContext->SpinLock);

        RCADEBUGP(RCA_LOUD, ("RCABindAdapter: Released global protocol spinlock\n"));
        
                //
                // Allocate send packet and buffer pools
                //
                NdisAllocatePacketPoolEx(&Status,
                                                                 &pAdapter->SendPacketPool,
                                                                 MIN_PACKETS_POOL,
                                                                 MAX_PACKETS_POOL-MIN_PACKETS_POOL,
                                                                 sizeof(PKT_RSVD));

                if (Status == NDIS_STATUS_SUCCESS)
                {
                        NdisAllocateBufferPool(&Status,
                                                                   &pAdapter->SendBufferPool,
                                                                   MAX_PACKETS_POOL);
                        if (Status != NDIS_STATUS_SUCCESS)
                        {
                                RCADEBUGP(RCA_ERROR, ("RCABindAdapter: "
                                                                          "Failed to allocate send buffer bool, freeing packet pool, status == 0x%x\n", Status));
                                NdisFreePacketPool(pAdapter->SendPacketPool);
                        }
                } else {
                                RCADEBUGP(RCA_ERROR, ("RCABindAdapter: Failed to allocate send packet pool, status == 0x%x\n", Status));
                }
                        


                if (Status == NDIS_STATUS_SUCCESS)
                {
                        //
                        // Allocate receive packet and buffer pools
                        //
                        NdisAllocatePacketPoolEx(&Status,
                                                 &pAdapter->RecvPacketPool,
                                                 MIN_PACKETS_POOL,
                                                 MAX_PACKETS_POOL-MIN_PACKETS_POOL,
                                                 sizeof(PKT_RSVD));

                        if (Status == NDIS_STATUS_SUCCESS)
                        {
                                NdisAllocateBufferPool(&Status,
                                                       &pAdapter->RecvBufferPool,
                                                       MAX_PACKETS_POOL);
                                if (Status != NDIS_STATUS_SUCCESS)
                                {
                                        RCADEBUGP(RCA_ERROR, ("RCABindAdapter: Failed to allocate receive buffer pool, freeing other pools, status == 0x%x\n", Status));
                                        NdisFreePacketPool(pAdapter->SendPacketPool);
                                        NdisFreeBufferPool(pAdapter->SendBufferPool);
                                        NdisFreePacketPool(pAdapter->RecvPacketPool);
                                }
                        } else {
                                RCADEBUGP(RCA_ERROR, ("RCABindAdapter: Failed to allocate receive packet pool, freeing send pools, status == 0x%x\n", Status));
                                NdisFreePacketPool(pAdapter->SendPacketPool);
                                NdisFreeBufferPool(pAdapter->SendBufferPool);
                        }
                }

                if (Status == NDIS_STATUS_SUCCESS) {

                        RCADEBUGP(RCA_LOUD, ("RCABindAdapter: About to open Adapter %ws\n", DeviceName));

                        NdisOpenAdapter(&Status,
                                                        &OpenError,
                                                        &pAdapter->NdisBindingHandle,
                                                        &SelectedIndex,
                                                        Media,
                                                        2,
                                                        pProtocolContext->RCAClProtocolHandle,
                                                        (NDIS_HANDLE)pAdapter,
                                                        DeviceName,
                                                        0,
                                                        NULL);

                        if (Status == NDIS_STATUS_PENDING) {
                                RCADEBUGP(RCA_LOUD, ("RCABindAdapter: NdisOpenAdapter returned NDIS_STATUS_PENDING, "
                                                                         "about to block\n"));

                                RCABlock(&pAdapter->Block, &Status);
                                
                                RCADEBUGP(RCA_LOUD, ("RCABindAdapter: Unblocked waiting for NdisOpenAdapter to complete\n"));
                        }

                        if (Status != NDIS_STATUS_SUCCESS) {
                                RCADEBUGP(RCA_ERROR, ("RCABindAdapter: Failed to open adapter - Status == 0x%x\n", Status));
                                NdisFreePacketPool(pAdapter->SendPacketPool);
                                NdisFreeBufferPool(pAdapter->SendBufferPool);
                                NdisFreePacketPool(pAdapter->RecvPacketPool);
                                NdisFreeBufferPool(pAdapter->RecvBufferPool);
                        }
                }

        } while (FALSE); 

        if (Status != NDIS_STATUS_SUCCESS) { 
                //
                // We had some sort of error. Clean up and free up.
                //
                RCADEBUGP(RCA_ERROR, ("RCABindAdapter: Bad status - 0x%x\n", Status));

                if (pAdapter != (PRCA_ADAPTER)NULL)
                {
                        RCAInitBlockStruc(&pAdapter->Block);
                        if (pAdapter->NdisBindingHandle != (NDIS_HANDLE)NULL)
                        {
                                NdisCloseAdapter(&Status, pAdapter->NdisBindingHandle);
                                if (Status == NDIS_STATUS_PENDING)
                                {
                                        RCABlock(&pAdapter->Block, &Status);
                                }
                                
                                ACQUIRE_SPIN_LOCK(&pProtocolContext->SpinLock);

                                RCADEBUGP(RCA_LOUD, ("RCABindAdapter: Acquired global protocol spinlock\n"));
                                
                                pProtocolContext->BindingInfo.AdapterCnt--;
                                RCADEBUGP(RCA_INFO, ("RCABindAdapter: Decremented adapter count, current value == %d\n", pProtocolContext->BindingInfo.AdapterCnt));
                                
                RELEASE_SPIN_LOCK(&pProtocolContext->SpinLock);

                                RCADEBUGP(RCA_LOUD, ("RCABindAdapter: Released global protocol spinlock\n"));
                                
                        }
                
                        ACQUIRE_SPIN_LOCK(&pProtocolContext->SpinLock);

                        RCADEBUGP(RCA_LOUD, ("RCABindAdapter: Acquired global protocol spinlock\n"));

                        UnlinkDouble(pAdapter, NextAdapter, PrevAdapter);
                        
                        RELEASE_SPIN_LOCK(&pProtocolContext->SpinLock);

                        RCADEBUGP(RCA_LOUD, ("RCABindAdapter: Released global protocol spinlock\n"));
                        
                        NdisFreeSpinLock(&pAdapter->Lock);

                        RCAFreeMem(pAdapter);

                        pAdapter = NULL;
                }
                
                Status = NDIS_STATUS_FAILURE;
        } 

        *pStatus = Status;
}


VOID
RCAOpenAdaperComplete(
        IN      NDIS_HANDLE                     BindingContext,
        IN      NDIS_STATUS                     Status,
        IN      NDIS_STATUS                     OpenErrorStatus
        )
/*++
Routine Description
        Our OpenAdapter completion handler. We signal whoever opened the
        adapter.

Arguments
        BindingContext    - A pointer to a RCA_ADAPTER structure.
        Status                    - Status of open attempt.
        OpenErrorStatus  - Additional status information.

Return Value:
        None

--*/
{
        PRCA_ADAPTER            pAdapter;

        RCADEBUGP(RCA_INFO, ("RCAOpenAdapterComplete: Enter\n"));

        pAdapter = (PRCA_ADAPTER)BindingContext;

        RCAStructAssert(pAdapter, rca);

        RCASignal(&pAdapter->Block, Status);

        RCADEBUGP(RCA_INFO, ("RCAOpenAdapterComplete: Exit\n"));
}



VOID
RCADeactivateAdapterWorker(
                                                        IN      PNDIS_WORK_ITEM pWorkItem,
                                                        IN      PVOID                   Context                                                 
                                                        )
/*++
Routine Description:
        This routine is called by a worker thread when a work item is scheduled to deactivate
        an adapter. 
        
Arguments:
        pWorkItem       - Pointer to the work item structure used to schedule this work item
        Context         - Actually a pointer to the RCA_ADAPTER structure for the adapter that
                                  will be deactivated.

Return Value:
        (None)                                  
--*/
{
        PRCA_ADAPTER    pAdapter = (PRCA_ADAPTER) Context;

        RCADEBUGP(RCA_INFO, ("RCADeactivateAdapterWorker: Enter - Context == 0x%x\n", Context));

        //
        // Wait for all AF registrations to complete. There is a window of opportunity for us
        // to be here even though we may not be done in RCANotifyAfRegistration() i.e. between
        // the call to NdisClOpenAddressFamily() and the end of the function. 
        //

        ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);
        
        while (pAdapter->AfRegisteringCount != 0) {
                NDIS_STATUS     DummyStatus;

                RELEASE_SPIN_LOCK(&pAdapter->SpinLock);
                
                RCABlock(&pAdapter->AfRegisterBlock, &DummyStatus);

                ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);
        }

    RELEASE_SPIN_LOCK(&pAdapter->SpinLock);

        RCADeactivateAdapter(pAdapter);

        RCASignal(&pAdapter->DeactivateBlock, NDIS_STATUS_SUCCESS);
        
        RCA_CLEAR_ADAPTER_FLAG_LOCKED(pAdapter, RCA_ADAPTERFLAGS_DEACTIVATE_IN_PROGRESS);

        RCADEBUGP(RCA_INFO, ("RCADeactivateAdapterWorker: Exit"));
        
}


VOID
RCADeactivateAdapter(
        IN  PRCA_ADAPTER                        pAdapter
        )
/*++

Routine Description:
        Free all VCs on this adapter. 
        
Arguments:
        pAdapter        - points to the Adapter the VCs are listed off

Calling Seqence
        Called from RCACmUnbindAdapter to ensure we're all clear
        before deallocating an adapter structure

Return Value:
        None

--*/
{
        PRCA_VC                                 pVc, pNextVc;
        NDIS_STATUS                             Status;
        PRCA_PROTOCOL_CONTEXT   pProtocolContext = &GlobalContext;

        RCADEBUGP(RCA_INFO, ("RCADeactivateAdapter: Enter - pAdapter 0x%x\n", pAdapter));

        //
        // Deregister Sap handle so we get no more incoming calls.
        //
        if (pAdapter->NdisSapHandle != NULL)
        {
                RCAInitBlockStruc(&pAdapter->Block);

                Status = NdisClDeregisterSap(pAdapter->NdisSapHandle);

                RCA_SET_ADAPTER_FLAG_LOCKED(pAdapter, RCA_ADAPTERFLAGS_DEREG_SAP);

                if (NDIS_STATUS_PENDING == Status)
                {
                        RCABlock(&pAdapter->Block, &Status);
                }
                pAdapter->NdisSapHandle = NULL;

        RCA_SET_ADAPTER_FLAG_LOCKED(pAdapter, RCA_ADAPTERFLAGS_DEREG_SAP_COMPLETE);
        }
        
        ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);
        
        if (pAdapter->VcList) {
               pAdapter->BlockedOnClose = TRUE;
                   RCAInitBlockStruc(&pAdapter->CloseBlock);
        }

        for (pVc = pAdapter->VcList; pVc != NULL; pVc = pNextVc)
        {
                pNextVc = pVc->NextVcOnAdapter;
                if (pVc->Flags & VC_ACTIVE)
                {
                        RELEASE_SPIN_LOCK(&pAdapter->SpinLock);
                        
                        RCACoNdisCloseCallOnVcNoWait((PVOID)pVc);

            //
                        // Call the VC Close callback if necessary.
                        //

                        ACQUIRE_SPIN_LOCK(&pVc->SpinLock);

                        if ((pVc->ClientReceiveContext || pVc->ClientSendContext) &&
                                (pProtocolContext->Handlers.VcCloseCallback)) {

                                //
                                // Release the spin lock here because this callback will very likely 
                                // call RCACoNdisReleaseXXxVcContext() etc which will want the lock.
                                //
                                // There is a teensy tiny race here - if someone releases the VC context 
                                // between when we release the lock and when we call the callback, we
                                // could be in trouble. 
                                //  
                                RELEASE_SPIN_LOCK(&pVc->SpinLock);

                                pProtocolContext->Handlers.VcCloseCallback((PVOID)pVc, 
                                                                                                   pVc->ClientReceiveContext,
                                                                                                   pVc->ClientSendContext);
                        } else {
                                RELEASE_SPIN_LOCK(&pVc->SpinLock);
                        }

                        ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);
                }
        }

        RELEASE_SPIN_LOCK(&pAdapter->SpinLock);
        
        //
        // Deregister Af handle
        //
        
        if (pAdapter->NdisAfHandle)
        {
                RCAInitBlockStruc(&pAdapter->Block);

                Status = NdisClCloseAddressFamily(pAdapter->NdisAfHandle);

        RCA_SET_ADAPTER_FLAG_LOCKED(pAdapter, RCA_ADAPTERFLAGS_CLOSE_AF);

                if (Status == NDIS_STATUS_PENDING)
                {
                        RCABlock(&pAdapter->Block, &Status);
                }
                pAdapter->NdisAfHandle = NULL;

                RCA_SET_ADAPTER_FLAG_LOCKED(pAdapter, RCA_ADAPTERFLAGS_CLOSE_AF_COMPLETE);
        }

        //
        // Block waiting for the actual VCs to be deleted, if any.
        //
        if (pAdapter->BlockedOnClose) {                
               RCABlock(&pAdapter->CloseBlock, &Status);
               pAdapter->BlockedOnClose = FALSE;
        }

        RCA_SET_ADAPTER_FLAG_LOCKED(pAdapter, RCA_ADAPTERFLAGS_DEACTIVATE_COMPLETE);

        RCADEBUGP(RCA_LOUD, ("RCADeactivateAdapter: Exit\n"));
}




VOID
RCAUnbindAdapter(
                                 OUT    PNDIS_STATUS    pStatus,
                                 IN     NDIS_HANDLE             ProtocolBindContext,
                                 IN     PNDIS_HANDLE    UnbindContext
                                 )
/*++

Routine Description:
        Our entry point called by NDIS when we need to destroy an existing
        adapter binding.
        
        Close and clean up the adapter.

Arguments:
        pStatus - where we return the status of this call
        ProtocolBindContext - actually a pointer to the Adapter structure
        UnbindContext - we should pass this value in NdisCompleteUnbindAdapter

Return Value:
        None; *pStatus contains the result code.

--*/
{
        PRCA_PROTOCOL_CONTEXT   pProtocolContext = &GlobalContext;
        PRCA_ADAPTER                    *ppNextAdapter;
        PRCA_ADAPTER                    pAdapter;
        NDIS_STATUS                             Status;

        pAdapter = (PRCA_ADAPTER)ProtocolBindContext;

        RCADEBUGP(RCA_LOUD, ("RCAUnbindAdapter: Enter - pAdapter 0x%x, UnbindContext 0x%x\n",
                                                 pAdapter, UnbindContext));

        //
        // Deactivate Adapter - This may already be in progress by a worker thread in response
        // to an OID_CO_AF_CLOSE.
        //

        ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);
        
        pAdapter->AdapterFlags |= RCA_ADAPTERFLAGS_UNBIND_IN_PROGRESS;

        while (pAdapter->AfRegisteringCount != 0) {
                RELEASE_SPIN_LOCK(&pAdapter->SpinLock);
                
                RCABlock(&pAdapter->AfRegisterBlock, &Status);

                ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);
        }

        if (pAdapter->AdapterFlags & RCA_ADAPTERFLAGS_DEACTIVATE_IN_PROGRESS) {
                RELEASE_SPIN_LOCK(&pAdapter->SpinLock);
                
                //
                // RCADeactivateAdapter() will be called by the worker thread, 
                // just wait for it to complete.
                //
                RCABlock(&pAdapter->DeactivateBlock, &Status);

        } else if (pAdapter->AdapterFlags & RCA_ADAPTERFLAGS_DEACTIVATE_COMPLETE) {
                RELEASE_SPIN_LOCK(&pAdapter->SpinLock);

                //
                // Already deactivated, nothing to do. 
                //
        } else {
                pAdapter->AdapterFlags |= RCA_ADAPTERFLAGS_DEACTIVATE_IN_PROGRESS;
                RELEASE_SPIN_LOCK(&pAdapter->SpinLock);

        //
                // Close Sap, Close Vcs and Close Af
                //
                RCADeactivateAdapter(pAdapter);

        RCASignal(&pAdapter->DeactivateBlock, NDIS_STATUS_SUCCESS);

                RCA_CLEAR_ADAPTER_FLAG_LOCKED(pAdapter, RCA_ADAPTERFLAGS_DEACTIVATE_IN_PROGRESS);
        }
        
        RCAInitBlockStruc (&pAdapter->Block);
        RCADEBUGP(RCA_LOUD, ("RCAUnbindAdapter: Calling NdisCloseAdapter\n"));

        NdisCloseAdapter(&Status, pAdapter->NdisBindingHandle);

        if (Status == NDIS_STATUS_PENDING)
        {
                RCABlock(&pAdapter->Block, &Status);
        }

        ACQUIRE_SPIN_LOCK(&pProtocolContext->SpinLock);

        RCADEBUGP(RCA_LOUD, ("RCAUnbindAdapter: Acquired global protocol context lock\n"));

        pProtocolContext->BindingInfo.AdapterCnt--;
        RCADEBUGP(RCA_INFO, ("RCAUnbindAdapter: Decremented adapter count, current value == %d\n", pProtocolContext->BindingInfo.AdapterCnt));
        
    RELEASE_SPIN_LOCK(&pProtocolContext->SpinLock);

        RCADEBUGP(RCA_LOUD, ("RCAUnbindAdapter: Released global protocol context lock\n"));
        
        if (pAdapter->VcList != NULL) {
                RCADEBUGP(RCA_LOUD, ("RCAUnbindAdapter: VcList not null, pAdapter is 0x%x\n", pAdapter));
                DbgBreakPoint();
        }

        // Delist and free the adapters from our Global info

        ACQUIRE_SPIN_LOCK(&pProtocolContext->SpinLock);
        
        RCADEBUGP(RCA_LOUD, ("RCAUnbindAdapter: Acquired global protocol context lock\n"));

        UnlinkDouble(pAdapter, NextAdapter, PrevAdapter);

    RELEASE_SPIN_LOCK(&pProtocolContext->SpinLock);

        RCADEBUGP(RCA_LOUD, ("RCAUnbindAdapter: Released global protocol context lock\n"));
           
        if (pAdapter->SendPacketPool != NULL)
        {
                NdisFreePacketPool(pAdapter->SendPacketPool);
        }

        if (pAdapter->SendBufferPool != NULL)
        {
                NdisFreeBufferPool(pAdapter->SendBufferPool);
        }

        if (pAdapter->RecvPacketPool != NULL)
        {
                NdisFreePacketPool(pAdapter->RecvPacketPool);
        }
        
        if (pAdapter->RecvBufferPool != NULL)
        {
                NdisFreeBufferPool(pAdapter->RecvBufferPool);
        }

        RCA_SET_ADAPTER_FLAG_LOCKED(pAdapter, RCA_ADAPTERFLAGS_UNBIND_COMPLETE);
        RCA_CLEAR_ADAPTER_FLAG_LOCKED(pAdapter, RCA_ADAPTERFLAGS_UNBIND_IN_PROGRESS);

        RCAFreeMem(pAdapter);

        RCADEBUGP(RCA_INFO, ("RCADeAllocateAdapter: exit\n"));

        *pStatus = NDIS_STATUS_SUCCESS;
}

VOID
RCAOpenAdapterComplete(
        IN      NDIS_HANDLE                     BindingContext,
        IN      NDIS_STATUS                     Status,
        IN      NDIS_STATUS                     OpenErrorStatus
        )
/*++
Routine Description
        Our OpenAdapter completion handler. We signal whoever opened the
        adapter.

Arguments
        BindingContext    - A pointer to a RCA_ADAPTER structure.
        Status                    - Status of open attempt.
        OpenErrorStatus  - Additional status information.

Return Value:
        None

--*/
{
        PRCA_PROTOCOL_CONTEXT   pProtocolContext = &GlobalContext;
        PRCA_ADAPTER                    pAdapter;

        pAdapter = (PRCA_ADAPTER)BindingContext;

        RCAStructAssert(pAdapter, rca);

        if (Status == NDIS_STATUS_SUCCESS) {
                
                ACQUIRE_SPIN_LOCK(&pProtocolContext->SpinLock);
                
                RCADEBUGP(RCA_LOUD, ("RCAOpenAdapterComplete: Acquired global protocol context lock\n"));
                
                pProtocolContext->BindingInfo.AdapterCnt++;
                RCADEBUGP(RCA_INFO, ("RCAOpenAdapterComplete: Incremented adapter count, current value == %d\n", pProtocolContext->BindingInfo.AdapterCnt));

                RELEASE_SPIN_LOCK(&pProtocolContext->SpinLock);
        
                RCADEBUGP(RCA_LOUD, ("RCAOpenAdapterComplete: Released global protocol context lock\n"));

        }       

        RCASignal(&pAdapter->Block, Status);
}


VOID
RCACloseAdapterComplete(
        IN      NDIS_HANDLE                     BindingContext,
        IN      NDIS_STATUS                     Status
        )
/*++
Routine Description

        Our CloseAdapter completion handler. We signal whoever closed the
        adapter.

Arguments
        BindingContext    - A pointer to a RCA_ADAPTER structure.
        Status                    - Status of close attempt.

Return Value:
        None
--*/
{
        PRCA_ADAPTER    pAdapter;

        pAdapter = (PRCA_ADAPTER)BindingContext;

        RCAStructAssert(pAdapter, rca);
        
        RCAAssert(Status == NDIS_STATUS_SUCCESS);

        RCASignal(&pAdapter->Block, Status);
}


VOID
RCANotifyAfRegistration(
        IN      NDIS_HANDLE                     BindingContext,
        IN      PCO_ADDRESS_FAMILY      pFamily
        )
/*++

Routine Description:

        We get called here each time a call manager registers an address family.

        This is where we open the address family if it's the Proxy.
        
Arguments:

        RCABindingContext               - our pointer to an adapter
        pFamily                          - The AF that's been registered

Return Value:
        None

--*/
{
        PRCA_PROTOCOL_CONTEXT                   pProtocolContext = &GlobalContext;
        NDIS_CLIENT_CHARACTERISTICS             RCAClientCharacteristics;
        PRCA_ADAPTER                                    pAdapter;
        PCO_SAP                                                 Sap;
        NDIS_STATUS                                             Status;
        UCHAR                                                   SapBuf[sizeof(CO_SAP) + sizeof(RCA_SAP_STRING)];
#if DBG
        KIRQL                                                   EntryIrql;
#endif

        RCA_GET_ENTRY_IRQL(EntryIrql);

        RCADEBUGP(RCA_LOUD,("RCANotifyAfRegistration: Enter - Adapter 0x%x, AF 0x%x\n", 
                                                BindingContext, pFamily->AddressFamily));

        pAdapter = (PRCA_ADAPTER)BindingContext;
        
        if ((pFamily->AddressFamily != CO_ADDRESS_FAMILY_TAPI) ||
                (pAdapter->NdisAfHandle != NULL))
        {
                //
                // Not Proxy or already bound -- do nothing
                //
                return;
        }

        RCADEBUGP(RCA_LOUD, ("RCANotifyAfRegistration: Opening Proxy AF\n"));

        //
        // Check that the adapter is not being unbound.
        //

        ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);
        
        if ((pAdapter->AdapterFlags & RCA_ADAPTERFLAGS_UNBIND_IN_PROGRESS) ||
                (pAdapter->AdapterFlags & RCA_ADAPTERFLAGS_UNBIND_COMPLETE) ||
                (pAdapter->AdapterFlags & RCA_ADAPTERFLAGS_DEACTIVATE_IN_PROGRESS) ||
                (pAdapter->AdapterFlags & RCA_ADAPTERFLAGS_DEACTIVATE_COMPLETE)) {

                RELEASE_SPIN_LOCK(&pAdapter->SpinLock);

                RCADEBUGP(RCA_INFO, ("RCANotifyAfRegistration: Adapter is being unbound - bailing\n"));
                return;
        }

        if (pAdapter->AfRegisteringCount == 0) {
                RCAInitBlockStruc(&pAdapter->AfRegisterBlock);
        }

        pAdapter->AfRegisteringCount++;
        
        pAdapter->OldAdapterFlags = pAdapter->AdapterFlags;
        pAdapter->AdapterFlags = 0;

        RELEASE_SPIN_LOCK(&pAdapter->SpinLock);



        do
        {
                //
                // Do the client open on the address family
                //
                NdisZeroMemory (&RCAClientCharacteristics, sizeof(NDIS_CLIENT_CHARACTERISTICS));

                RCAClientCharacteristics.MajorVersion = NDIS_MAJOR_VERSION;
                RCAClientCharacteristics.MinorVersion = NDIS_MINOR_VERSION;
                RCAClientCharacteristics.Reserved = 0;
                RCAClientCharacteristics.ClCreateVcHandler = RCACreateVc;
                RCAClientCharacteristics.ClDeleteVcHandler = RCADeleteVc;
                RCAClientCharacteristics.ClRequestHandler = RCARequest; 
                RCAClientCharacteristics.ClRequestCompleteHandler = RCACoRequestComplete;
                RCAClientCharacteristics.ClOpenAfCompleteHandler = RCAOpenAfComplete;
                RCAClientCharacteristics.ClCloseAfCompleteHandler = RCACloseAfComplete;
                RCAClientCharacteristics.ClRegisterSapCompleteHandler = RCARegisterSapComplete;
                RCAClientCharacteristics.ClDeregisterSapCompleteHandler = RCADeregisterSapComplete;
                RCAClientCharacteristics.ClCloseCallCompleteHandler =   RCACloseCallComplete;
                RCAClientCharacteristics.ClIncomingCallHandler = RCAIncomingCall;
                RCAClientCharacteristics.ClIncomingCallQoSChangeHandler = RCAIncomingCallQosChange;
                RCAClientCharacteristics.ClIncomingCloseCallHandler =   RCAIncomingCloseCall;
                RCAClientCharacteristics.ClCallConnectedHandler =       RCACallConnected;

                RCADEBUGP(RCA_INFO,("  NotifyAfRegistration -- NdisClOpenAddressFamily\n"));

                RCAInitBlockStruc(&pAdapter->Block);
                Status = NdisClOpenAddressFamily(pAdapter->NdisBindingHandle,
                                                                                 pFamily,
                                                                                 (NDIS_HANDLE)pAdapter,
                                                                                 &RCAClientCharacteristics,
                                                                                 sizeof(NDIS_CLIENT_CHARACTERISTICS),
                                                                                 &pAdapter->NdisAfHandle);

                if (Status == NDIS_STATUS_PENDING)
                {
                        RCABlock(&pAdapter->Block, &Status);
                }

                if (Status != NDIS_STATUS_SUCCESS)
                {
                        //
                        // Open AF failure.
                        //
                        RCADEBUGP(RCA_ERROR, ("RCANotifyAfRegistration -- open AF failure, status == 0x%x\n", Status));
                        break;
                }

                InterlockedIncrement(&pAdapter->AfOpenCount);

                RCADEBUGP(RCA_LOUD, ("RCANotifyAfRegistration -- calling RCARegisterSap\n"));

                RCAInitBlockStruc(&pAdapter->Block);
                Sap = (PCO_SAP)SapBuf;
                // Sap->SapType = SAP_TYPE_NSAP;
                Sap->SapLength = sizeof(SapBuf);
                RtlCopyMemory(&Sap->Sap, RCA_SAP_STRING, sizeof(RCA_SAP_STRING));

                Status = NdisClRegisterSap(pAdapter->NdisAfHandle,
                                                                   pAdapter,
                                                                   Sap,
                                                                   &pAdapter->NdisSapHandle);
                if (Status == NDIS_STATUS_PENDING)
                {
                        RCABlock(&pAdapter->Block, &Status);
                }

                if (Status != NDIS_STATUS_SUCCESS)
                {
                        //
                        // So we opned the AF, but the CM didn't let us register our SAP.
                        //
                        RCADEBUGP(RCA_ERROR, ("RCANotifyAfRegistration - "
                                                                  "RCARegisterSap on NdisAfHandle 0x%x and pAdapter 0x%x "
                                                                  "failed with status 0x%x\n", 
                                                                  pAdapter->NdisAfHandle, pAdapter, Status));

                        //
                        // Close AF
                        //
                        RCAInitBlockStruc(&pAdapter->Block);
                        Status = NdisClCloseAddressFamily(pAdapter->NdisAfHandle);
                        if (Status == NDIS_STATUS_PENDING)
                        {
                                RCABlock(&pAdapter->Block, &Status);
                        }
                        break;
                }
                
                ACQUIRE_SPIN_LOCK(&pProtocolContext->SpinLock);
                                
                RCADEBUGP(RCA_LOUD, ("RCANotifyAfRegistration: Acquired global protocol context lock\n"));
                                        
                pProtocolContext->BindingInfo.SAPCnt++;
                RCADEBUGP(RCA_INFO, ("RCANotifyAfRegistration: "
                                                         "Incremented SAP count, current value == %d\n", pProtocolContext->BindingInfo.SAPCnt));

                if (pProtocolContext->BindingInfo.BindingsComplete && 
                    (pProtocolContext->BindingInfo.SAPCnt == pProtocolContext->BindingInfo.AdapterCnt)) {
                        RCADEBUGP(RCA_INFO, ("RCANotifyAfRegistration: Unblocking RCACoNdisInitialize(), counts == %d\n", 
                                                                 pProtocolContext->BindingInfo.AdapterCnt)); 
                        RCASignal(&pProtocolContext->BindingInfo.Block, Status);
                
                } else {
                        RCADEBUGP(RCA_INFO, ("RCANotifyAfRegistration: Not unblocking RCACoNdisInitialize() - SAPCnt == %d, AdapterCnt == %d\n",
                                                                 pProtocolContext->BindingInfo.SAPCnt, 
                                                                 pProtocolContext->BindingInfo.AdapterCnt));
                }

                RELEASE_SPIN_LOCK(&pProtocolContext->SpinLock);
                
                RCADEBUGP(RCA_LOUD, ("RCANotifyAfRegistration: Released global protocol context lock\n"));

        } while (FALSE);

        ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);
        
        pAdapter->AfRegisteringCount--;

        if (pAdapter->AfRegisteringCount == 0) {
                RCASignal(&pAdapter->AfRegisterBlock, NDIS_STATUS_SUCCESS);
        }
        
        RELEASE_SPIN_LOCK(&pAdapter->SpinLock);

        RCA_CHECK_EXIT_IRQL(EntryIrql);

        RCADEBUGP(RCA_INFO, ("RCANotifyAfRegistration: Exit\n"));
}

VOID
RCAOpenAfComplete(
        IN      NDIS_STATUS     Status,
        IN      NDIS_HANDLE     ProtocolAfContext,
        IN      NDIS_HANDLE             NdisAfHandle
        )
{
        PRCA_ADAPTER            pAdapter;

        RCADEBUGP(RCA_INFO,("RCAOpenAfComplete: Enter - Status = 0X%x, AfHandle = 0X%x\n", 
                                                Status, NdisAfHandle));

        pAdapter = (PRCA_ADAPTER)ProtocolAfContext;

        RCAStructAssert(pAdapter, rca);

        if (NDIS_STATUS_SUCCESS == Status)
        {
                pAdapter->NdisAfHandle =  NdisAfHandle;
        }

        RCASignal(&pAdapter->Block, Status);

        RCADEBUGP(RCA_INFO, ("RCAOpenAfComplete: Exit\n"));
}

VOID
RCACloseAfComplete(
        IN      NDIS_STATUS             Status,
        IN      NDIS_HANDLE             ProtocolAfContext
        )
{
        PRCA_ADAPTER            pAdapter;

        RCADEBUGP(RCA_INFO, ("RCACloseAfComplete: Enter\n"));

        pAdapter = (PRCA_ADAPTER)ProtocolAfContext;
        pAdapter->NdisAfHandle = NULL;

        RCASignal(&pAdapter->Block, Status);

        RCADEBUGP(RCA_INFO, ("RCACloseAfComplete: Exit\n"));
}


VOID
RCARegisterSapComplete(
        IN  NDIS_STATUS                          Status,
        IN  NDIS_HANDLE                          ProtocolSapContext,
        IN  PCO_SAP                                      pSap,
        IN  NDIS_HANDLE                          NdisSapHandle
        )
/*++

Routine Description:

        This routine is called to indicate completion of a call to
        NdisClRegisterSap. If the call was successful, save the
        allocated NdisSapHandle in our SAP structure.

Arguments:

        Status                            - Status of Register SAP
        ProtocolSapContext        - Pointer to our SAP structure
        pSap                                    - SAP information we'd passed in the call
        NdisSapHandle                   - SAP Handle

Return Value:

        None

--*/
{
        PRCA_ADAPTER    pAdapter;

        RCADEBUGP(RCA_INFO, ("RCARegisterSapComplete: Enter\n"));

        pAdapter = (PRCA_ADAPTER)ProtocolSapContext;

        if (Status == NDIS_STATUS_SUCCESS)
        {
                pAdapter->NdisSapHandle = NdisSapHandle;
        }

        RCASignal(&pAdapter->Block, Status);

        RCADEBUGP(RCA_INFO, ("RCARegisterSapComplete: Exit\n"));
}


VOID
RCADeregisterSapComplete(
        IN      NDIS_STATUS                     Status,
        IN      NDIS_HANDLE             ProtocolSapContext
        )
{
        PRCA_ADAPTER            pAdapter;

        RCADEBUGP(RCA_LOUD,("RCADeregisterSapComplete: Enter\n"));

        pAdapter = (PRCA_ADAPTER)ProtocolSapContext;
        pAdapter->NdisSapHandle = NULL;
        RCASignal(&pAdapter->Block, Status);

        RCADEBUGP(RCA_LOUD,("RCADeregisterSapComplete: Exit\n"));
}


//
// Dummy NDIS functions
//
VOID
RCATransferDataComplete(
        IN      NDIS_HANDLE ProtocolBindingContext,
        IN      PNDIS_PACKET Packet,
        IN      NDIS_STATUS Status,
        IN      UINT BytesTransferred)

{
        RCAAssert(FALSE);
}


VOID
RCAResetComplete(
        IN      NDIS_HANDLE     ProtocolBindingContext,
        IN      NDIS_STATUS     Status
        )
{
        RCAAssert(FALSE);
}


VOID
RCARequestComplete(
        IN      NDIS_HANDLE             ProtocolBindingContext,
        IN      PNDIS_REQUEST   NdisRequest,
        IN      NDIS_STATUS             Status
        )
{
}

NDIS_STATUS
RCAReceive(
        IN      NDIS_HANDLE ProtocolBindingContext,
        IN      NDIS_HANDLE     MacReceiveContext,
        IN      PVOID           HeaderBuffer,
        IN      UINT            HeaderBufferSize,
        IN      PVOID           LookAheadBuffer,
        IN      UINT            LookAheadBufferSize,
        IN      UINT            PacketSize
        )
{
        RCAAssert(FALSE);
        return(NDIS_STATUS_FAILURE);
}


INT
RCAReceivePacket(
        IN      NDIS_HANDLE             ProtocolBindingContext,
        IN      PNDIS_PACKET    Packet
        )
{
        RCAAssert(FALSE);
        return(0);
}


VOID
RCAStatus(
        IN  NDIS_HANDLE                         ProtocolBindingContext,
        IN  NDIS_STATUS                         GeneralStatus,
        IN  PVOID                                       StatusBuffer,
        IN  UINT                                        StatusBufferSize)
{
}

VOID
RCAStatusComplete(
        IN      NDIS_HANDLE     ProtocolBindingContext
        )
{
}


VOID
RCACoStatus(
        IN      NDIS_HANDLE                      ProtocolBindingContext,
        IN      NDIS_HANDLE                      ProtocolVcContext      OPTIONAL,
        IN      NDIS_STATUS                      GeneralStatus,
        IN      PVOID                            StatusBuffer,
        IN      UINT                             StatusBufferSize)

{
        RCADEBUGP(RCA_INFO, (" RCACoStatus: Bind Ctx 0x%x, Status 0x%x\n",
                                                ProtocolBindingContext, GeneralStatus));
}


VOID
RCASendComplete(
        IN      NDIS_HANDLE             ProtocolBindingContext,
        IN      PNDIS_PACKET    Packet,
        IN      NDIS_STATUS             Status
        )
{
        RCAAssert(TRUE);
}


VOID
RCAModifyCallQosComplete(
        IN      NDIS_STATUS                     status,
        IN      NDIS_HANDLE                     ProtocolVcContext,
        IN      PCO_CALL_PARAMETERS     CallParameters
        )
{
        RCAAssert(TRUE);
}


VOID
RCAAddPartyComplete(
        IN      NDIS_STATUS                     status,
        IN      NDIS_HANDLE                     ProtocolPartyContext,
        IN      NDIS_HANDLE                     NdisPartyHandle,
        IN      PCO_CALL_PARAMETERS     CallParameters
        )
{
        RCAAssert(FALSE);
}

VOID
RCADropPartyComplete(
        IN      NDIS_STATUS     status,
        IN      NDIS_HANDLE     ProtocolPartyContext
        )
{
        RCAAssert(FALSE);
}


VOID
RCAIncomingCallQosChange(
        IN      NDIS_HANDLE                             ProtocolVcContext,
        IN      PCO_CALL_PARAMETERS             CallParameters
        )
{
        RCAAssert(TRUE);
}


VOID
RCAIncomingDropParty(
        IN      NDIS_STATUS             DropStatus,
        IN      NDIS_HANDLE             ProtocolPartyContext,
        IN      PVOID                   CloseData OPTIONAL,
        IN      UINT                    Size OPTIONAL)

{
        RCAAssert(TRUE);
}

VOID
RCACoRequestComplete(
                                         IN NDIS_STATUS NdisStatus,
                                         IN NDIS_HANDLE ProtocolAfContext,
                                         IN NDIS_HANDLE ProtocolVcContext OPTIONAL, 
                                         IN NDIS_HANDLE ProtocolPartyContext OPTIONAL, 
                                         IN OUT PNDIS_REQUEST NdisRequest
                                         )
{       
        RCADEBUGP(RCA_INFO, ("RCACoRequestComplete: Enter\n"));
        
        RCADEBUGP(RCA_INFO, ("RCACoRequestComplete: Exit\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rca\rcandis.h ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

	RCANdis.h

Abstract:

	The module defines the constants, structures and function templates for
	the NDIS side of RCA

Author:

	Shyam Pather (SPATHER)


Revision History:

	Who         When        What
	--------	--------	----------------------------------------------
	SPATHER		04-20-99	Created / adapted from original RCA code by RMachin/JameelH

--*/

#ifndef _RCANDIS__H
#define _RCANDIS__H


#define RCA_CL_NAME		L"RCA"
#define	RCA_SAP_STRING	L"WAN/RCA"
#define MAX_HASH_SIZE	64
#define NDIS_MAJOR_VERSION  0x05
#define NDIS_MINOR_VERSION  0x00


typedef VOID (*PFN_RCARECEIVE_CALLBACK) (
										IN	PVOID	 		RcaVcContext,
										IN 	PVOID			ClientReceiveContext,
										IN	PNDIS_PACKET	pPacket
										);


//
// Will be called with lock held. 
//
typedef VOID (*PFN_RCASENDCOMPLETE_CALLBACK) (
											 IN	PVOID		RcaVcContext, 
											 IN	PVOID		ClientSendContext,
											 IN	PVOID		PacketContext,
											 IN	PMDL		pSentMdl,
											 IN	NDIS_STATUS	Status 
											 );


//
// will be called at DISPATCH_LEVEL
// must not use vc context after this
//
typedef VOID (*PFN_VCCLOSE_CALLBACK) (
									 IN	PVOID	RcaVcContext, 
									 IN	PVOID	ClientReceiveContext,
									 IN PVOID	ClientSendContext
									 ); 



typedef struct _RCA_CO_NDIS_HANDLERS {
	PFN_RCARECEIVE_CALLBACK			ReceiveCallback;
	PFN_RCASENDCOMPLETE_CALLBACK	SendCompleteCallback;
	PFN_VCCLOSE_CALLBACK			VcCloseCallback;
} RCA_CO_NDIS_HANDLERS, *PRCA_CO_NDIS_HANDLERS;

//
// Structure to hold info about how many bindings/SAP registrations we've made.
//
typedef struct _RCA_BINDING_INFO {
	ULONG	 		AdapterCnt;
	ULONG			SAPCnt;
	BOOL			BindingsComplete;
	RCABlockStruc 	Block;
} RCA_BINDING_INFO, *PRCA_BINDING_INFO;


//
// Forward references
//

typedef	struct _RCA_VC		RCA_VC, *PRCA_VC;
typedef	struct _RCA_ADAPTER	RCA_ADAPTER, *PRCA_ADAPTER;



typedef struct _RCA_PROTOCOL_CONTEXT {
#if DBG
	ULONG					rca_sig;
#endif	
	PRCA_ADAPTER			AdapterList;			
	PRCA_VC					VcHashTable[MAX_HASH_SIZE];	
	NDIS_SPIN_LOCK			SpinLock;
    NDIS_HANDLE				RCAClProtocolHandle;	
	RCA_BINDING_INFO		BindingInfo;
	RCA_CO_NDIS_HANDLERS	Handlers;
} RCA_PROTOCOL_CONTEXT, *PRCA_PROTOCOL_CONTEXT;

extern RCA_PROTOCOL_CONTEXT	GlobalContext;



typedef struct _RCA_VC {
#if DBG
	ULONG					rca_sig;
#endif
	struct _RCA_VC 			*NextVcOnAdapter;
	struct _RCA_VC 			**PrevVcOnAdapter;
	struct _RCA_VC 			*NextVcOnHash;
	struct _RCA_VC 			**PrevVcOnHash;
	struct _RCA_ADAPTER		*pAdapter;
	ULONG					Flags;
	ULONG					RefCount;		
	NDIS_SPIN_LOCK			SpinLock;
	ULONGLONG				uqBytesRead;
	NDIS_HANDLE		       	NdisVcHandle;	  
	CO_CALL_PARAMETERS		CallParameters;
	RCABlockStruc			CloseBlock;
	ULONG 					ClosingState;
	PVOID					ClientReceiveContext;
	PVOID					ClientSendContext;
	LONG					PendingSends;
} RCA_VC, *PRCA_VC;

#define	VC_ACTIVE			0x0001
#define	VC_CLOSING			0x8000

#define CLOSING_INCOMING_CLOSE 		0x01
#define CLOSING_CLOSE_COMPLETE 		0x02
#define CLOSING_DELETE_VC      		0x04

#define	HASH_VC(_VcContext)		(PtrToUlong((PVOID)(((ULONG_PTR)_VcContext >> 4) % MAX_HASH_SIZE)))


//
//  We allocate one RCA_ADAPTER structure for each adapter that
//  the RCA opens. A pointer to this structure is passed to NdisOpenAdapter
//  as the BindingContext.
//

typedef struct _RCA_ADAPTER
{
#if DBG
	ULONG				rca_sig;
#endif
	ULONG				AdapterFlags;

#define RCA_ADAPTERFLAGS_DEACTIVATE_IN_PROGRESS	0x0001
#define RCA_ADAPTERFLAGS_DEACTIVATE_COMPLETE	0x0002 
#define RCA_ADAPTERFLAGS_DEREG_SAP				0x0004
#define RCA_ADAPTERFLAGS_DEREG_SAP_COMPLETE 	0x0008
#define RCA_ADAPTERFLAGS_CLOSE_AF				0x0010
#define RCA_ADAPTERFLAGS_CLOSE_AF_COMPLETE		0x0020
#define RCA_ADAPTERFLAGS_UNBIND_IN_PROGRESS		0x0040
#define RCA_ADAPTERFLAGS_UNBIND_COMPLETE		0x0080

	ULONG				AfRegisteringCount;
	RCABlockStruc		AfRegisterBlock;
	ULONG				AfOpenCount;
	ULONG	 			OldAdapterFlags;   
	struct _RCA_ADAPTER *NextAdapter;
	struct _RCA_ADAPTER **PrevAdapter;
	struct _RCA_VC 		*VcList;
	NDIS_HANDLE			NdisBindingHandle;		// set by NdisOpenAdapter
	NDIS_HANDLE			NdisAfHandle;			// set by NDIS on NdisOpenAddressFamily
	NDIS_HANDLE			NdisSapHandle;			// For calls to NDIS re this SAP
	RCABlockStruc		Block;				// used to block current thread
	NDIS_SPIN_LOCK		SpinLock;
	NDIS_WORK_ITEM		DeactivateWorkItem;
	RCABlockStruc		DeactivateBlock;
	NDIS_HANDLE			SendBufferPool;
	NDIS_HANDLE			RecvBufferPool;
	NDIS_HANDLE			SendPacketPool;
	NDIS_HANDLE			RecvPacketPool;
	RCABlockStruc		CloseBlock;
	BOOL				BlockedOnClose;
} RCA_ADAPTER, *PRCA_ADAPTER;


#define RCA_SET_ADAPTER_FLAG_LOCKED(_pAdapter, _FlagValue) \
	ACQUIRE_SPIN_LOCK(&_pAdapter->SpinLock);		\
	_pAdapter->AdapterFlags |= _FlagValue;			\
	RELEASE_SPIN_LOCK(&_pAdapter->SpinLock);


#define RCA_CLEAR_ADAPTER_FLAG_LOCKED(_pAdapter, _FlagValue) \
	ACQUIRE_SPIN_LOCK(&_pAdapter->SpinLock);		\
	_pAdapter->AdapterFlags &= ~_FlagValue;			\
	RELEASE_SPIN_LOCK(&_pAdapter->SpinLock);


extern
NDIS_STATUS
RCACoNdisInitialize(
					IN	PRCA_CO_NDIS_HANDLERS	pHandlers,
					IN	ULONG					ulInitTimeout
					);


extern
VOID
RCACoNdisUninitialize(
					  
					  );


extern
NDIS_STATUS
RCACoNdisGetVcContextForReceive(
								IN	UNICODE_STRING	VcHandle, 
								IN	PVOID			ClientReceiveContext,
								OUT	PVOID			*VcContext
								);


extern
NDIS_STATUS
RCACoNdisGetVcContextForSend(
							 IN		UNICODE_STRING	VcHandle, 
							 IN		PVOID			ClientSendContext,
							 OUT 	PVOID			*VcContext
							 );

extern
NDIS_STATUS
RCACoNdisReleaseSendVcContext(
							  IN	PVOID	VcContext
							  );


extern
NDIS_STATUS
RCACoNdisReleaseReceiveVcContext(
								 IN	PVOID	VcContext
								 );


extern
NDIS_STATUS
RCACoNdisCloseCallOnVc(
					   IN	PVOID	VcContext
					   );


extern
NDIS_STATUS
RCACoNdisCloseCallOnVcNoWait(
							 IN	PVOID	VcContext
							 );


extern
NDIS_STATUS
RCACoNdisSendFrame(
				   IN	PVOID	VcContext,
				   IN	PMDL	pMdl,
				   IN	PVOID	PacketContext
				   );

extern
NDIS_STATUS
RCACoNdisGetMdlFromPacket(
						  IN	PNDIS_PACKET	pPacket,
						  OUT	PMDL			*ppMdl
						  );

extern
VOID
RCACoNdisReturnPacket(
					  IN	PNDIS_PACKET	pPacket
					  );

extern
NDIS_STATUS
RCACoNdisGetMaxSduSizes(
						IN	PVOID	VcContext,
						OUT	ULONG	*RxMaxSduSize,
						OUT	ULONG	*TxMaxSduSize
						);

extern
NDIS_STATUS
RCAPnPSetPower(
	       IN PRCA_ADAPTER 		pAdapter, 
	       IN PNET_PNP_EVENT 	NetPnPEvent
	       );


extern
NDIS_STATUS
RCAPnPQueryPower(
		 IN PRCA_ADAPTER 	pAdapter, 
		 IN PNET_PNP_EVENT 	NetPnPEvent
		 );


extern
NDIS_STATUS
RCAPnPQueryRemoveDevice(
			IN PRCA_ADAPTER 	pAdapter, 
			IN PNET_PNP_EVENT 	NetPnPEvent
			);


extern
NDIS_STATUS
RCAPnPCancelRemoveDevice(
			 IN PRCA_ADAPTER 	pAdapter, 
			 IN PNET_PNP_EVENT 	NetPnPEvent
			 );


extern
NDIS_STATUS
RCAPnPEventBindsComplete(
			 IN PRCA_ADAPTER 	pAdapter, 
			 IN PNET_PNP_EVENT 	NetPnPEvent
			 );


extern
NDIS_STATUS
RCAPnPEventHandler(
		   IN	NDIS_HANDLE	ProtocolBindingContext,
		   IN	PNET_PNP_EVENT	NetPnPEvent
		   );


extern
VOID
RCABindAdapter(
			   OUT PNDIS_STATUS		pStatus,
			   IN  NDIS_HANDLE		BindContext,
			   IN  PNDIS_STRING		DeviceName,
			   IN  PVOID			SystemSpecific1,
			   IN  PVOID			SystemSpecific2
			   );


extern
VOID
RCAOpenAdaperComplete(
	IN	NDIS_HANDLE			BindingContext,
	IN	NDIS_STATUS			Status,
	IN	NDIS_STATUS			OpenErrorStatus
	);


extern
VOID
RCADeactivateAdapterWorker(
							IN	PNDIS_WORK_ITEM	pWorkItem,
							IN	PVOID			Context
							);


extern
VOID
RCADeactivateAdapter(
	IN  PRCA_ADAPTER			pAdapter
	);


extern
VOID
RCAUnbindAdapter(
				 OUT	PNDIS_STATUS	pStatus,
				 IN  	NDIS_HANDLE		ProtocolBindContext,
				 IN  	PNDIS_HANDLE	UnbindContext
				 );


extern
VOID
RCAOpenAdapterComplete(
	IN	NDIS_HANDLE			BindingContext,
	IN	NDIS_STATUS			Status,
	IN	NDIS_STATUS			OpenErrorStatus
	);


extern
VOID
RCACloseAdapterComplete(
	IN	NDIS_HANDLE			BindingContext,
	IN	NDIS_STATUS			Status
	);


extern
VOID
RCANotifyAfRegistration(
	IN	NDIS_HANDLE			BindingContext,
	IN	PCO_ADDRESS_FAMILY	pFamily
	);


extern
VOID
RCAOpenAfComplete(
	IN	NDIS_STATUS 	Status,
	IN	NDIS_HANDLE 	ProtocolAfContext,
	IN	NDIS_HANDLE		NdisAfHandle
	);


extern
VOID
RCACloseAfComplete(
	IN	NDIS_STATUS		Status,
	IN	NDIS_HANDLE		ProtocolAfContext
	);


extern
VOID
RCARegisterSapComplete(
	IN  NDIS_STATUS				 Status,
	IN  NDIS_HANDLE				 ProtocolSapContext,
	IN  PCO_SAP					 pSap,
	IN  NDIS_HANDLE				 NdisSapHandle
	);


extern
VOID
RCADeregisterSapComplete(
	IN	NDIS_STATUS			Status,
	IN	NDIS_HANDLE 		ProtocolSapContext
	);


//
// Dummy NDIS functions
//
extern
VOID
RCATransferDataComplete(
	IN	NDIS_HANDLE ProtocolBindingContext,
	IN	PNDIS_PACKET Packet,
	IN	NDIS_STATUS Status,
	IN	UINT BytesTransferred);


extern
VOID
RCAResetComplete(
	IN	NDIS_HANDLE	ProtocolBindingContext,
	IN	NDIS_STATUS	Status
	);


extern
VOID
RCARequestComplete(
	IN	NDIS_HANDLE		ProtocolBindingContext,
	IN	PNDIS_REQUEST	NdisRequest,
	IN	NDIS_STATUS		Status
	);


extern
NDIS_STATUS
RCAReceive(
	IN	NDIS_HANDLE ProtocolBindingContext,
	IN	NDIS_HANDLE	MacReceiveContext,
	IN	PVOID		HeaderBuffer,
	IN	UINT		HeaderBufferSize,
	IN	PVOID		LookAheadBuffer,
	IN	UINT		LookAheadBufferSize,
	IN	UINT		PacketSize
	);


extern
INT
RCAReceivePacket(
	IN	NDIS_HANDLE		ProtocolBindingContext,
	IN	PNDIS_PACKET	Packet
	);


extern
VOID
RCAStatus(
	IN  NDIS_HANDLE				ProtocolBindingContext,
	IN  NDIS_STATUS				GeneralStatus,
	IN  PVOID					StatusBuffer,
	IN  UINT					StatusBufferSize
	);


extern
VOID
RCAStatusComplete(
	IN	NDIS_HANDLE	ProtocolBindingContext
	);


extern
VOID
RCACoStatus(
	IN	NDIS_HANDLE			 ProtocolBindingContext,
	IN	NDIS_HANDLE			 ProtocolVcContext	OPTIONAL,
	IN	NDIS_STATUS			 GeneralStatus,
	IN	PVOID				 StatusBuffer,
	IN	UINT				 StatusBufferSize
	);


extern
VOID
RCASendComplete(
	IN	NDIS_HANDLE		ProtocolBindingContext,
	IN	PNDIS_PACKET	Packet,
	IN	NDIS_STATUS		Status
	);


extern
VOID
RCAModifyCallQosComplete(
	IN	NDIS_STATUS			status,
	IN	NDIS_HANDLE			ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS	CallParameters
	);


extern
VOID
RCAAddPartyComplete(
	IN	NDIS_STATUS			status,
	IN	NDIS_HANDLE			ProtocolPartyContext,
	IN	NDIS_HANDLE			NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS	CallParameters
	);


extern
VOID
RCADropPartyComplete(
	IN	NDIS_STATUS 	status,
	IN	NDIS_HANDLE 	ProtocolPartyContext
	);


extern
VOID
RCAIncomingCallQosChange(
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PCO_CALL_PARAMETERS		CallParameters
	);


extern
VOID
RCAIncomingDropParty(
	IN	NDIS_STATUS		DropStatus,
	IN	NDIS_HANDLE		ProtocolPartyContext,
	IN	PVOID			CloseData OPTIONAL,
	IN	UINT			Size OPTIONAL
	);


extern
VOID
RCACoRequestComplete(
					 IN NDIS_STATUS NdisStatus,
					 IN NDIS_HANDLE ProtocolAfContext,
					 IN NDIS_HANDLE ProtocolVcContext OPTIONAL, 
					 IN NDIS_HANDLE ProtocolPartyContext OPTIONAL, 
					 IN OUT PNDIS_REQUEST NdisRequest
					 );

//
// Co-NDIS client stuff.
//

extern
BOOLEAN
RCAReferenceVc(
	IN  PRCA_VC				pRcaVc
	);


extern
VOID
RCADereferenceVc(
	IN  PRCA_VC				pRcaVc
	);


extern
VOID
RCACoSendComplete(
	IN	NDIS_STATUS			Status,
	IN	NDIS_HANDLE			ProtocolVcContext,
	IN	PNDIS_PACKET		pNdisPacket
	);


extern
UINT
RCACoReceivePacket(
		   IN	NDIS_HANDLE		ProtocolBindingContext,
		   IN	NDIS_HANDLE		ProtocolVcContext,
		   IN	PNDIS_PACKET	pNdisPacket
		  );


extern
VOID
RCAReceiveComplete(
				   IN	NDIS_HANDLE	ProtocolBindingContext
				   );


extern
NDIS_STATUS
RCACreateVc(
	IN	NDIS_HANDLE 	ProtocolAfContext,
	IN	NDIS_HANDLE		NdisVcHandle,
	OUT PNDIS_HANDLE	pProtocolVcContext
	);


extern
NDIS_STATUS
RCADeleteVc(
	IN NDIS_HANDLE		ProtocolVcContext
	);


extern
NDIS_STATUS
RCAIncomingCall(
	IN	NDIS_HANDLE				ProtocolSapContext,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	OUT PCO_CALL_PARAMETERS	pCallParams
	);


extern
VOID
RCAIncomingCloseCall(
	IN	NDIS_STATUS		closeStatus,
	IN	NDIS_HANDLE		ProtocolVcContext,
	IN	PVOID			CloseData OPTIONAL,
	IN	UINT			Size OPTIONAL
	);


extern
VOID
RCACloseCallComplete(
	IN NDIS_STATUS 	Status,
	IN NDIS_HANDLE 	ProtocolVcContext,
	IN NDIS_HANDLE 	ProtocolPartyContext OPTIONAL
	);


extern
VOID
RCACallConnected(
	IN  NDIS_HANDLE		ProtocolVcContext
	);


extern
NDIS_STATUS
RCARequest(
	IN  NDIS_HANDLE			ProtocolAfContext,
	IN  NDIS_HANDLE			ProtocolVcContext		OPTIONAL,
	IN  NDIS_HANDLE			ProtocolPartyContext	OPTIONAL,
	IN OUT PNDIS_REQUEST	NdisRequest
	);


/*++
VOID
RCAFreeCopyPacket(
	IN	PNDIS_PACKET		pNdisPacket
	)

Routine Description:

	Free a local receive packet into our pool.

Arguments:

	pAdapter	- Pointer to our adapter structure
	pNdisPacket - Packet to be freed.

Return Value:
	None

--*/



#define RCAFreeCopyPacket(_pPacket)             \
    {                              				\
        PNDIS_BUFFER	pNdisBuffer;			\
		PUCHAR          pBuffer;                \
        ULONG           BufferLength;           \
						\
        NdisQueryPacket((_pPacket),             \
                        NULL,                   \
                        NULL,                   \
                        &pNdisBuffer,           \
                        NULL);                  \
						\
        NdisQueryBuffer(pNdisBuffer,            \
                        &pBuffer,               \
                        &BufferLength);         \
						\
        if (NULL != pNdisBuffer)                \
            NdisFreeBuffer(pNdisBuffer);        \
						\
        if (NULL != (_pPacket))                 \
            NdisFreePacket((_pPacket));         \
						\
        if (NULL != pBuffer)                    \
            RCAFreeMem(pBuffer);                \
    }



#endif // _RCANDIS__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rca\rcaksndi.c ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

	RCAKsNdi.c

Abstract:

	The module implements the Co-NDIS wrapper functions that the KS parts of 
	RCA use to avoid having to deal with Co-NDIS directly. 

Author:

	Shyam Pather (SPATHER)


Revision History:

	Who         When        What
	--------	--------	----------------------------------------------
	SPATHER		04-20-99	Created 

--*/

#include <precomp.h>

#define MODULE_NUMBER	MODULE_KSNDIS
#define _FILENUMBER		'DNSK' 

#if PACKET_POOL_OPTIMIZATION    		
// SendPPOpt - Start
LONG			g_alSendPPOptBuckets[SENDPPOPT_NUM_BUCKETS];
LONG			g_lSendPPOptOutstanding;
NDIS_SPIN_LOCK	g_SendPPOptLock;
// SendPPOpt - End
#endif


PRCA_VC
RCARefVcFromHashTable(
					  IN  PRCA_VC		VcContext
					  )
/*++

Routine Description:

	Searches for an RCA_VC structure in the hash table. If found, the structure is referenced.
	
Arguments:

	VcContext	  -- The RCA_VC structure to look for.

Return Value:

	RCA VC structure, or NULL if there's no entry. (Caller should assert this is never
	NULL, since both RCA and NDIS think their respective pointers should still be valid...)
--*/
{
	PRCA_PROTOCOL_CONTEXT	pProtocolContext = &GlobalContext;
	ULONG					HashIndex = HASH_VC((ULONG_PTR)VcContext);
	PRCA_VC					pRcaVc;

	RCADEBUGP(RCA_INFO, ("RCARefVcFromHashTable: enter\n" ));

	ACQUIRE_SPIN_LOCK(&pProtocolContext->SpinLock);

	RCADEBUGP(RCA_LOUD, ("RCARefVcFromHashTable: Acquired global protocol context lock\n"));

	for (pRcaVc = pProtocolContext->VcHashTable[HashIndex];
		 pRcaVc != NULL;
		 pRcaVc = pRcaVc->NextVcOnHash)
	{
		PRCA_ADAPTER	pAdapter;

		if (pRcaVc == VcContext)
		{
	        pAdapter = pRcaVc->pAdapter;

			DPR_ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);

			if (pRcaVc->Flags & VC_CLOSING)
			{
				pRcaVc = NULL;
			}
			else
			{
				pRcaVc->RefCount++;
			}
			
			DPR_RELEASE_SPIN_LOCK(&pAdapter->SpinLock);
			
			break;
		}
	}

	RELEASE_SPIN_LOCK(&pProtocolContext->SpinLock);

    RCADEBUGP(RCA_LOUD, ("RCARefVcFromHashTable: Released global protocol context lock\n"));

	RCADEBUGP(RCA_INFO, ("RCARefVcFromHashTable: Exit - Returning VC %x\n", pRcaVc));

	return(pRcaVc);
}



NDIS_STATUS
RCACoNdisGetVcContext(
					  IN	UNICODE_STRING	VcHandle, 
					  IN	PVOID			ClientContext,
					  IN	BOOL			bRefForReceive,
					  OUT	PVOID			*VcContext
					  )
{
	NDIS_STATUS	Status = NDIS_STATUS_SUCCESS;
	PRCA_VC		pRcaVc; 

	RCADEBUGP(RCA_INFO, ("RCACoNdisGetVcContext: Enter\n"));

	do {
		//
		// Convert the unicode string to a pointer (this is 
		// equivalent to turning it into an NDIS_HANDLE).
		//
		Status = NdisClGetProtocolVcContextFromTapiCallId(VcHandle, (PNDIS_HANDLE)&pRcaVc); 

		if (Status != STATUS_SUCCESS) {
			RCADEBUGP(RCA_ERROR, ("RCACoNdisGetVcContext: "
								  "Failed to get vc context from string, Status == 0x%x \n", Status));
			break;
		}

		//
		// Validate the VC by looking for it in our hash table. This increments the ref count on the VC.
		// 
		pRcaVc = RCARefVcFromHashTable(pRcaVc);

		if (pRcaVc == NULL) {
			RCADEBUGP(RCA_ERROR, ("RCACoNdisGetVcContext: Could not find VC in hash table\n"));
			Status = STATUS_NOT_FOUND;
			break;
		}

		//
		// Store away the client context, and give back the VC structure address as the
		// VcContext to the client. 
		//
		ACQUIRE_SPIN_LOCK(&pRcaVc->SpinLock);

		if (bRefForReceive) 
			pRcaVc->ClientReceiveContext = ClientContext;
		else
			pRcaVc->ClientSendContext = ClientContext;

		RELEASE_SPIN_LOCK(&pRcaVc->SpinLock);
		
		*VcContext = pRcaVc;

	} while (FALSE);


	RCADEBUGP(RCA_INFO, ("RCACoNdisGetVcContext: Exit - Returning Status 0x%x\n", Status));

	return Status; 
}


NDIS_STATUS
RCACoNdisGetVcContextForReceive(
								IN	UNICODE_STRING	VcHandle, 
								IN	PVOID			ClientReceiveContext,
								OUT	PVOID			*VcContext
								)
/*++
Routine Description:
	Retrieves VC context for a VC handle that will be used to receive packets.
	
Arguments:
	VcHandle				- The Unicode string representation of the VC Handle.
	ClientReceiveContext	- Caller-supplied context to be passed to the receive handler 
							  when packets are received on this VC 
	VcContext				- Address of a pointer in which the Co-NDIS VC Context will be
							  returned.						  							  

Return value:
	NDIS_STATUS_SUCCESS in the case of success, STATUS_NOT_FOUND in the case of an invalid
	VC handle, or some other relevant error code otherwise. 
--*/

{
	return RCACoNdisGetVcContext(VcHandle, ClientReceiveContext, TRUE, VcContext);
}


NDIS_STATUS
RCACoNdisGetVcContextForSend(
							 IN		UNICODE_STRING	VcHandle, 
							 IN		PVOID			ClientSendContext,
							 OUT 	PVOID			*VcContext
							 )
/*++
Routine Description:
	Retrieves VC context for a VC handle that will be used to send packets.
	
Arguments:
	VcHandle				- The Unicode string representation of the VC Handle.
	ClientSendContext		- Caller-supplied context to be passed to the send complete handler 
							  when packets sends are completed on this VC 
	VcContext				- Address of a pointer in which the Co-NDIS VC Context will be
							  returned.						  							  

Return value:
	NDIS_STATUS_SUCCESS in the case of success, STATUS_NOT_FOUND in the case of an invalid
	VC handle, or some other relevant error code otherwise. 
--*/

{
	return RCACoNdisGetVcContext(VcHandle, ClientSendContext, FALSE, VcContext);
}



NDIS_STATUS
RCACoNdisReleaseSendVcContext(
							  IN	PVOID	VcContext
							  )
/*++
Routine Description:
	This routine should be called when a client has finished using a VC Context
	returned by RCACoNdisGetVcContextForSend().
	
	Failure to do so will prevent the resources used by the VC from being freed. 
	
Arguments:
	VcContext				- The VC Context (returned by RCACoNdisGetVcContextForSend()).						  							  

Return value:
	NDIS_STATUS_SUCCESS 
--*/
{
	PRCA_VC 	pRcaVc = (PRCA_VC) VcContext;

	RCADEBUGP(RCA_INFO, ("RCACoNdisReleaseSendVcContext: Enter\n"));

	ACQUIRE_SPIN_LOCK(&pRcaVc->SpinLock);

	pRcaVc->ClientSendContext = NULL;

	RELEASE_SPIN_LOCK(&pRcaVc->SpinLock);

	RCADereferenceVc(pRcaVc); 

	RCADEBUGP(RCA_INFO, ("RCACoNdisReleaseSendVcContext: Exit, Returning NDIS_STATUS_SUCCESS\n"));

	return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
RCACoNdisReleaseReceiveVcContext(
								 IN	PVOID	VcContext
								 )
/*++
Routine Description:
	This routine should be called when a client has finished using a VC Context
	returned by RCACoNdisGetVcContextForReceive().
	
	Failure to do so will prevent the resources used by the VC from being freed. 
	
Arguments:
	VcContext				- The VC Context (returned by RCACoNdisGetVcContextForReceive()).						  							  

Return value:
	NDIS_STATUS_SUCCESS 
--*/
{
	PRCA_VC 	pRcaVc = (PRCA_VC) VcContext;

	RCADEBUGP(RCA_INFO, ("RCACoNdisReleaseReceiveVcContext: Enter\n"));

	ACQUIRE_SPIN_LOCK(&pRcaVc->SpinLock);
	
	pRcaVc->ClientReceiveContext = NULL;

	RELEASE_SPIN_LOCK(&pRcaVc->SpinLock);

	RCADereferenceVc(pRcaVc); 

	RCADEBUGP(RCA_INFO, ("RCACoNdisReleaseReceiveVcContext: Exit, Returning NDIS_STATUS_SUCCESS\n"));

	return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
RCACoNdisCloseCallOnVc(
					   IN	PVOID	VcContext
					   )
/*++
Routine Description:
	Closes the call (if any) that is active on a particular VC
	
Arguments:
	VcContext				- The VC Context (returned by RCACoNdisGetVcContextForXXXX()).						  							  

Return value:
	NDIS_STATUS_SUCCESS for a successful close, NDIS_STATUS_PENDING for a close that is still 
	proceeding, or a relevant error code otherwise. 
--*/

{
	NDIS_STATUS		Status = NDIS_STATUS_SUCCESS;
	PRCA_VC			pRcaVc = (PRCA_VC)VcContext;
	PRCA_ADAPTER	pAdapter = pRcaVc->pAdapter;
	BOOL			bNeedToClose = FALSE;
	
	RCADEBUGP(RCA_INFO, ("RCACoNdisCloseCallOnVc: Enter\n"));
		  
	RCAInitBlockStruc(&pRcaVc->CloseBlock);

	ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);

	pRcaVc->Flags &= ~VC_ACTIVE;
	pRcaVc->Flags |= VC_CLOSING;

	if (!(pRcaVc->ClosingState & CLOSING_INCOMING_CLOSE)) {
		pRcaVc->ClosingState |= CLOSING_INCOMING_CLOSE;
		bNeedToClose = TRUE;
	}

	RELEASE_SPIN_LOCK(&pAdapter->SpinLock);

	if (bNeedToClose) {
		Status = NdisClCloseCall(pRcaVc->NdisVcHandle, NULL, NULL, 0);
		
		if (Status != NDIS_STATUS_PENDING) {
			RCADEBUGP(RCA_LOUD, ("RCACoNdisCloseCallOnVc: "
								 "NdisClClose call returned status 0x%x, manually calling RCACloseCallComplete\n",
								 Status));
			RCACloseCallComplete(Status, (NDIS_HANDLE)pRcaVc, NULL);
		} else {
			RCABlock(&pRcaVc->CloseBlock, &Status);
		}

	}

    RCADEBUGP(RCA_INFO, ("RCACoNdisCloseCallOnVc: Exit - Returning Status 0x%x\n", Status));
	
	return Status;
}


NDIS_STATUS
RCACoNdisCloseCallOnVcNoWait(
							 IN	PVOID	VcContext
							 )
/*++
Routine Description:
	Closes the call (if any) that is active on a particular VC without waiting for the close
	call operation to complete. 
	
Arguments:
	VcContext				- The VC Context (returned by RCACoNdisGetVcContextForXXXX()).						  							  

Return value:
	NDIS_STATUS_SUCCESS for a successful close, NDIS_STATUS_PENDING for a close that is still 
	proceeding, or a relevant error code otherwise. 
--*/

{
	NDIS_STATUS		Status = NDIS_STATUS_SUCCESS;
	PRCA_VC			pRcaVc = (PRCA_VC)VcContext;
	PRCA_ADAPTER	pAdapter = pRcaVc->pAdapter;
	BOOL			bNeedToClose = FALSE;
	
	RCADEBUGP(RCA_INFO, ("RCACoNdisCloseCallOnVc: Enter\n"));
		  
	//
	// Though we aren't going to block, I have to init this here
	// because the completion routine will signal it whether we're 
	// blocking or not. 
	//
	RCAInitBlockStruc(&pRcaVc->CloseBlock); 

	ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);

	pRcaVc->Flags &= ~VC_ACTIVE;
	pRcaVc->Flags |= VC_CLOSING;

	if (!(pRcaVc->ClosingState & CLOSING_INCOMING_CLOSE)) {
		pRcaVc->ClosingState |= CLOSING_INCOMING_CLOSE;
		bNeedToClose = TRUE;
	}

	RELEASE_SPIN_LOCK(&pAdapter->SpinLock);

	if (bNeedToClose) {
		Status = NdisClCloseCall(pRcaVc->NdisVcHandle, NULL, NULL, 0);
		
		if (Status != NDIS_STATUS_PENDING) {
			RCADEBUGP(RCA_LOUD, ("RCACoNdisCloseCallOnVc: "
								 "NdisClClose call returned status 0x%x, manually calling RCACloseCallComplete\n",
								 Status));
			RCACloseCallComplete(Status, (NDIS_HANDLE)pRcaVc, NULL);
		}
	}

    RCADEBUGP(RCA_INFO, ("RCACoNdisCloseCallOnVc: Exit - Returning Status 0x%x\n", Status));
	
	return Status;
}


NDIS_STATUS
RCACoNdisSendFrame(
				   IN	PVOID	VcContext,
				   IN	PMDL	pMdl,
				   IN	PVOID	PacketContext
				   )
/*++
Routine Description:
	Sends a frame of data out on a VC.
	
Arguments:
	VcContext		- The VC Context (returned by RCACoNdisGetVcContextForXXXX()).						  							
	pMdl			- Pointer to the MDL containing the data to send
	PacketContext	- Caller-supplied context for this packet that will be passed 
					  to the send complete handler when this packet has been sent. 	  

Return value:
	NDIS_STATUS_PENDING if the packet has been sent and is waiting to be completed, 
	or an error code otherwise.  
--*/
{
	NDIS_STATUS		Status = NDIS_STATUS_SUCCESS;
	PRCA_VC			pRcaVc = (PRCA_VC)VcContext;
	PRCA_ADAPTER	pAdapter; 
	PNDIS_PACKET	pPacket; 

	RCADEBUGP(RCA_INFO, ("RCACoNdisSendFrame: Enter\n"));

	do {
		BOOL	bVcIsClosing = FALSE;

		if (pRcaVc == NULL) {
			RCADEBUGP(RCA_ERROR, 
					  ("RCACoNdisSendFrame: VcContext was null, returing NDIS_STATUS_FAILURE\n"));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		pAdapter = pRcaVc->pAdapter;  

		//
		// Check if the VC is closing. If it is, we
		// won't try to send a packet.
		//
		ACQUIRE_SPIN_LOCK(&pAdapter->SpinLock);
		
		if (pRcaVc->ClosingState & CLOSING_INCOMING_CLOSE) {
			bVcIsClosing = TRUE;
		}

		RELEASE_SPIN_LOCK(&pAdapter->SpinLock);
		
		if (bVcIsClosing) {
			RCADEBUGP(RCA_ERROR, ("RCACoNdisSendFrame: Can't send frame, VC is closing\n"));
			Status = STATUS_PORT_DISCONNECTED;
			break;
		}
		

		//
		// Allocate a packet from our sending pool.
		//

#if PACKET_POOL_OPTIMIZATION    				
		// SendPPOpt - Start
			
		NdisAcquireSpinLock(&g_SendPPOptLock);
		
		g_alSendPPOptBuckets[g_lSendPPOptOutstanding]++;

		g_lSendPPOptOutstanding++;

		NdisReleaseSpinLock(&g_SendPPOptLock);

        // SendPPOpt - End
#endif		
		NdisAllocatePacket(&Status, &pPacket, pAdapter->SendPacketPool);
		
		if (Status != NDIS_STATUS_SUCCESS) {
			RCADEBUGP(RCA_ERROR, ("RCACoNdisSendFrame: "
								  "Failed to allocate packet, Status == 0x%x\n", Status));
			break;
		}


        //
		// Initialize the packet and put the buffer into it. 
		//

		NdisReinitializePacket(pPacket);

		NdisChainBufferAtFront(pPacket, (PNDIS_BUFFER)pMdl);
		
		//
		// Put the packet context in the protocol reserved field. 
		//
		PKT_RSVD_FROM_PKT(pPacket)->PacketContext = PacketContext;

		//
		// Send it on it's way!
		//
		InterlockedIncrement(&pRcaVc->PendingSends);
		NdisCoSendPackets(pRcaVc->NdisVcHandle, &pPacket, 1);

		Status = NDIS_STATUS_PENDING;

	} while (FALSE);

	RCADEBUGP(RCA_INFO, ("RCACoNdisSendFrame: Exit - Returning Status == 0x%x\n", Status));

	return Status;


}


NDIS_STATUS
RCACoNdisGetMdlFromPacket(
						  IN	PNDIS_PACKET	pPacket,
						  OUT	PMDL			*ppMdl
						  )
/*++
Routine Description:
	Utility function that retrieves the data MDL from an NDIS packet.
	
Arguments:
	pPacket	- Pointer to an NDIS packet
	ppMdl	- Address of an MDL pointer in which the address of the MDL will be returned.  

Return value:
	NDIS_STATUS_SUCCESS
--*/

{
	RCADEBUGP(RCA_INFO, ("RCACoNdisGetMdlFromPacket: Enter\n"));

	*ppMdl = (PMDL) pPacket->Private.Head;

	RCADEBUGP(RCA_INFO, ("RCACoNdisGetMdlFromPacket: Exit - Returning NDIS_STATUS_SUCCESS\n"));

	return NDIS_STATUS_SUCCESS;
}



VOID
RCACoNdisReturnPacket(
					  IN	PNDIS_PACKET	pPacket
					  )
/*++
Routine Description:
	This routine should be called to return a packet to NDIS. Failure 
	to call this routine when finished with a packet will cause a resource
	leak that will result in packets being dropped on the network.
	
Arguments:
	pPacket	- Pointer to the NDIS packet to return 

Return value:
	(None)
--*/

{
	RCADEBUGP(RCA_INFO, ("RCACoNdisReturnPacket: Enter\n"));


	if (WORK_ITEM_FROM_PKT(pPacket)->bFreeThisPacket) {
		//
		// This is our packet - free it. 
		// 
        RCADEBUGP(RCA_LOUD, ("RCACoNdisReturnPacket: Freeing locally allocated packet\n"));

#if PACKET_POOL_OPTIMIZATION    		
		// RecvPPOpt - Start
			
		NdisAcquireSpinLock(&g_RecvPPOptLock);
		    
		g_lRecvPPOptOutstanding--;

		NdisReleaseSpinLock(&g_RecvPPOptLock);

		// RecvPPOpt - End
#endif
		RCAFreeCopyPacket(pPacket);
		
	} else {
		//
		// This is the miniport's packet - return it. 
		//

		RCADEBUGP(RCA_LOUD, ("RCACoNdisReturnPacket: Returning packet to the miniport\n"));

		NdisReturnPackets(&pPacket, 1);
	
	}

	RCADEBUGP(RCA_INFO, ("RCACoNdisReturnPacket: Exit\n"));
}



NDIS_STATUS
RCACoNdisGetMaxSduSizes(
						IN	PVOID	VcContext,
						OUT	ULONG	*RxMaxSduSize,
						OUT	ULONG	*TxMaxSduSize
						)
/*++
Routine Description:
	Utility function that retrieves the largest SDU sizes that a VC
	can support. 
	  
Arguments:
	VcContext		- The VC Context (returned by RCACoNdisGetVcContextForXXXX()).						  							
	RxMaxSduSize	- Pointer to ULONG variable in which to place the max receive 
					  SDU size.
	TxMaxSduSize	- Pointer to ULONG variable in which to place the max transmit 
					  SDU size.
					  

Return value:
	(None)
--*/

{
	NDIS_STATUS	Status = NDIS_STATUS_SUCCESS;

	RCADEBUGP(RCA_INFO, ("RCACoNdisGetMaxSduSizes: Enter\n"));

	do {
		PRCA_VC	pRcaVc = (PRCA_VC)VcContext;

		if (RxMaxSduSize) {
			*RxMaxSduSize = pRcaVc->CallParameters.CallMgrParameters->Receive.MaxSduSize;
		}

		if (TxMaxSduSize) {
			*TxMaxSduSize = pRcaVc->CallParameters.CallMgrParameters->Transmit.MaxSduSize;
		}

	} while (FALSE);

	RCADEBUGP(RCA_INFO, ("RCACoNdisGetMaxSduSizes: Exit - Returning Status 0x%x\n", Status));

	return Status; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rca\rcantini.c ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

	rcantini.c

Abstract:

	The module contains the NT-specific init code for the NDIS RCA.

Author:

	Richard Machin (RMachin)

Revision History:

	Who         When          What
	--------	--------      ----------------------------------------------
	RMachin     2-18-97       created
	JameelH     4-18-98       Cleaned up

Notes:

--*/

#include <precomp.h>

#define MODULE_NUMBER MODULE_NTINIT
#define _FILENUMBER 'NITN'

RCA_GLOBAL	RcaGlobal = {0};

//
// Local funcion prototypes
//
NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT DriverObject,
	IN	PUNICODE_STRING RegistryPath
	);

//
// All of the init code can be discarded.
//
#ifdef ALLOC_PRAGMA
 #pragma alloc_text(INIT, DriverEntry)
#endif // ALLOC_PRAGMA

NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT	DriverObject,
	IN	PUNICODE_STRING	RegistryPath
	)
/*++

Routine Description:

	Sets up the driver object to handle the KS interface and PnP Add Device
	request. Does not set up a handler for PnP Irp's, as they are all dealt
	with directly by the PDO.

Arguments:

	DriverObject -
		Driver object for this instance.

	RegistryPathName -
		Contains the registry path which was used to load this instance.

Return Values:

	Returns STATUS_SUCCESS.

--*/
{
	RCADEBUGP(0, ("RCA DriverEntry: Built %s, %s\n", __DATE__, __TIME__));
	
	DriverObject->MajorFunction[IRP_MJ_PNP] = KsDefaultDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = KsDefaultDispatchPower;	
    DriverObject->DriverExtension->AddDevice = PnpAddDevice;
	DriverObject->DriverUnload = RCAUnload;

	KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
	KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
	KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);

	RCAInitLock(&(RcaGlobal.SpinLock));
	
	//
	// Initialize our stream header pool.
	//

	RCASHPoolInit();	

#if PACKET_POOL_OPTIMIZATION    		
	// SendPPOpt - Start
			
	NdisZeroMemory(g_alSendPPOptBuckets, SENDPPOPT_NUM_BUCKETS * sizeof(g_alSendPPOptBuckets[0]));
	g_lSendPPOptOutstanding = 0;

	NdisAllocateSpinLock(&g_SendPPOptLock);
	// SendPPOpt - End
	

	// RecvPPOpt - Start
		
	NdisZeroMemory(g_alRecvPPOptBuckets, RECVPPOPT_NUM_BUCKETS * sizeof(g_alRecvPPOptBuckets[0]));
	g_lRecvPPOptOutstanding = 0;

	NdisAllocateSpinLock(&g_RecvPPOptLock);
	// RecvPPOpt - End
#endif
	
	return STATUS_SUCCESS;
}


VOID
RCAUnload(
	IN	PDRIVER_OBJECT	DriverObject
	)
/*++

Routine Description:

	Free all the allocated resources, etc.

Arguments:

	DriverObject - pointer to a driver object

Return Value:


--*/
{
	NDIS_STATUS			Status;
	PRCA_ADAPTER		pAdapter;
#if DBG
	KIRQL	 			EntryIrq;
#endif

	RCA_GET_ENTRY_IRQL(EntryIrq);

	RCADEBUGP (RCA_LOUD, ( "RCAUnload: enter\n"));

	if (RcaGlobal.bProtocolInitialized) {
		RCACoNdisUninitialize();
		RcaGlobal.bProtocolInitialized = FALSE;
	}

	RCAFreeLock(&(RcaGlobal.SpinLock));

#if PACKET_POOL_OPTIMIZATION    		
	// SendPPOpt - Start
		
	NdisAcquireSpinLock(&g_SendPPOptLock);
		
	{
		LONG SendPPOptLoopCtr;

		DbgPrint("Send Packet Pool Stats:\n");
		for (SendPPOptLoopCtr = 0; SendPPOptLoopCtr < SENDPPOPT_NUM_BUCKETS; SendPPOptLoopCtr++) {
			DbgPrint("%d\t%d\n", SendPPOptLoopCtr, g_alSendPPOptBuckets[SendPPOptLoopCtr]);
		}
		DbgPrint("-----------------------\n");
	}

	NdisReleaseSpinLock(&g_SendPPOptLock);
		
	// SendPPOpt - End

	// RecvPPOpt - Start
		
	NdisAcquireSpinLock(&g_RecvPPOptLock);
			
	{
		LONG RecvPPOptLoopCtr;

		DbgPrint("Receive Packet Pool Stats:\n");
		for (RecvPPOptLoopCtr = 0; RecvPPOptLoopCtr < RECVPPOPT_NUM_BUCKETS; RecvPPOptLoopCtr++) {
			DbgPrint("%d\t%d\n", RecvPPOptLoopCtr, g_alRecvPPOptBuckets[RecvPPOptLoopCtr]);
		}
		DbgPrint("--------------------------\n");
	}

	NdisReleaseSpinLock(&g_RecvPPOptLock);

	// RecvPPOpt - End
#endif

	RCASHPoolFree();

	RCADEBUGP (RCA_LOUD, ("RCAUnload: exit\n"));

	RCA_CHECK_EXIT_IRQL(EntryIrq);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rca\rcautils.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	rcautils.c

Abstract:

	Utility routines called by entry point functions. Split out into
	a separate file to keep the "entry point" files clean.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	rmachin     2-18-97     Created (from pxutils)
	DChen       3-16-98     Bug fixing and cleanup
	JameelH     4-18-98     Cleanup
    
Notes:

--*/

#include "precomp.h"
#include "atm.h"
#include "stdio.h"

#define MODULE_NUMBER	MODULE_UTIL
#define _FILENUMBER		'LITU'


NTSTATUS
RCAIoComplete(
	      IN PDEVICE_OBJECT		DeviceObject,
	      IN PIRP			Irp,
	      IN PVOID			Context
	     )
/*++

Routine Description:
	Callback function for KsStreamIo() - invoked when stream write is complete. 
	Here we just free any packets we allocated, return any NDIS packets back to NDIS,
	and return the stream header to the global pool.
	
Arguments:
	DeviceObject - Our Device Object
	Irp	     - The IRP that completed
	Context	     - A pointer to the stream header
	
Return Value:
	STATUS_SUCCESS	
	   
--*/
{
	PRCA_STREAM_HEADER	StreamHeader;
	PNDIS_BUFFER		pNdisBuffer = 0;

	RCADEBUGP(RCA_INFO, ("RCAIoComplete(): enter, context == %x\n", Context));

	StreamHeader = (PRCA_STREAM_HEADER)Context;

	RCACoNdisReturnPacket(StreamHeader->NdisPacket);

	RCASHPoolReturn(StreamHeader);	

	RCADEBUGP(RCA_INFO, ("RCAIoComplete(): exit"));

	return STATUS_SUCCESS;
}

VOID 
CopyStreamHeaderToIrp(
		      IN PRCA_STREAM_HEADER	NetRCAStreamHeader,
		      IN PIRP			Irp
		      ) 
{
	PIO_STACK_LOCATION		IrpStack;
	ULONG				NetBufferLength, BufferLength;
	PBYTE				NetBuffer, Buffer;
	PKSSTREAM_HEADER		NetStreamHdr, StreamHdr;
	PMDL				NetMdl, Mdl;
	ULONG				BytesLeft;
	ULONG				BytesFree;
	ULONG				BytesToCopy;
	ULONG				BytesRead = 0;

	NetStreamHdr = &NetRCAStreamHeader->Header;
	NetBuffer = NetStreamHdr->Data;
	BytesLeft = NetStreamHdr->DataUsed;

	RCADEBUGP(RCA_INFO, ("CopyStreamHeaderToIrp(): Going to copy %lu bytes\n", BytesLeft));
	// read IRP
	IrpStack = IoGetCurrentIrpStackLocation(Irp);

	BufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
	StreamHdr = (PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer;
	StreamHdr->DataUsed = 0;
	//StreamHdr->PresentationTime.Time = StreamHdr->PresentationTime.Time;

	Mdl = Irp->MdlAddress;
	Buffer = MmGetSystemAddressForMdl(Mdl);
	Mdl = Mdl->Next;
    
	//
	// Enumerate the stream headers, filling in each one.
	// Assume the net IRP has one stream header
	//
	while (BytesLeft) 
	{
		BytesFree = StreamHdr->FrameExtent - StreamHdr->DataUsed;
		if(BytesFree)
		{
			BytesToCopy = BytesFree < BytesLeft ? BytesFree : BytesLeft;
			BytesLeft -= BytesToCopy;

			RtlCopyMemory(Buffer+StreamHdr->DataUsed,
				      NetBuffer,
				      BytesToCopy);

			BytesRead += BytesToCopy;
			StreamHdr->DataUsed += BytesToCopy;
			BytesFree = StreamHdr->FrameExtent - StreamHdr->DataUsed;
			
			NetBuffer += BytesToCopy;
		}

		// read stream full?
		if (!BytesFree)
		{
			//StreamHdr->PresentationTime.Numerator = 1;
			//StreamHdr->PresentationTime.Denominator = 1;
			//StreamHdr->Duration = StreamHdr->DataUsed; 
			//StreamHdr->OptionsFlags = KSSTREAM_HEADER_OPTIONSF_TIMEVALID | KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;

			// get the next stream header
			BufferLength -= sizeof(KSSTREAM_HEADER);
			if (BufferLength)
			{
				StreamHdr++;
				StreamHdr->DataUsed = 0;
				//StreamHdr->PresentationTime.Time = StreamHdr->PresentationTime.Time + BytesRead;

				if(StreamHdr->FrameExtent)
				{
					if(Mdl)
					{
						Buffer = (PUCHAR) MmGetSystemAddressForMdl(Mdl);
						RCAAssert(Buffer);
						Mdl = Mdl->Next;
					}
					else
					{
						break;
					}
				}
			} 
			else
			{
				break;
			}
		}
	}

#if DBG
	if(BytesLeft)
	{
		RCADEBUGP(RCA_ERROR,("CopyIrpData: OOPS - There are bytes left over: BytesLeft = %d BytesRead = %d \n", 
			BytesLeft, BytesRead));
		//RCAAssert(FALSE);
	}
#endif

	// free the IRP's
	RCAIoComplete(NULL, NULL, (PVOID)NetRCAStreamHeader);

	Irp->IoStatus.Information = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
	Irp->IoStatus.Status = STATUS_SUCCESS;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);

}

VOID
RCAIoWorker(
	    IN PNDIS_WORK_ITEM pNdisWorkItem,
	    IN PVOID	Context
	   )
/*++

Routine Description:
	This is the work item for the capture filter bridge pins. It
	streams the data in the work queue associated with a pin
	instance to the next connected filter.
	
Arguments:
	 PVOID Context - pointer to bridge pin instance.
	 
Return:
	 Nothing.

Comments:
	 Not pageable, uses SpinLocks.

--*/
{
	NTSTATUS				Status;
	PLIST_ENTRY				pList;
	PWORK_ITEM				pWorkItem;   
	PPIN_INSTANCE_BRIDGE	PinInstance = (PPIN_INSTANCE_BRIDGE)Context;
	PRCA_STREAM_HEADER		StreamHeader;

#if AUDIO_SINK_FLAG
	PIRP				Irp;
	PPIN_INSTANCE_DEVIO		DevIoPin;
#endif

	RCADEBUGP(RCA_INFO, ("RCAIoWorker(): enter\n"));

	RCA_ACQUIRE_BRIDGE_PIN_LOCK(PinInstance);

	while(!IsListEmpty(&PinInstance->WorkQueue))
	{
		RcaGlobal.QueueSize--;
		RCADEBUGP(RCA_LOUD,("RCAIoWorker: Queue-- is %d\n", RcaGlobal.QueueSize));

		pList = RemoveHeadList(&PinInstance->WorkQueue);

		pWorkItem = CONTAINING_RECORD(pList, WORK_ITEM, ListEntry);

		RCA_RELEASE_BRIDGE_PIN_LOCK(PinInstance);
	       
		StreamHeader = pWorkItem->StreamHeader;

#if AUDIO_SINK_FLAG
		DevIoPin = PinInstance->FilterInstance->DevIoPin;
		
		//
		// The DevIo pin could have gone away between when we queued this packet and now. 
		//

		if (DevIoPin == NULL) {
			RCAIoComplete(NULL, NULL, (PVOID)StreamHeader);
			
			//
			// Have to continue instead of breaking because we have to IoComplete everything
			// in the queue.
			//
			RCA_ACQUIRE_BRIDGE_PIN_LOCK(PinInstance);
			continue; 
		}	

		if (DevIoPin->ConnectedAsSink) {
		
			if (IsListEmpty(&DevIoPin->ActiveQueue)) {
				//
				// No IRP waiting for data, so just dump it. 
				//

				RCAIoComplete(NULL, NULL, (PVOID)StreamHeader);
				RCA_ACQUIRE_BRIDGE_PIN_LOCK(PinInstance);
				continue;
			}

			Irp = KsRemoveIrpFromCancelableQueue(&DevIoPin->ActiveQueue,
							     &DevIoPin->QueueLock,
							     KsListEntryHead,
							     KsAcquireAndRemove);
			if (Irp == NULL) {	
				//
				// No IRP waiting for data, so just dump it. 
				//

				RCAIoComplete(NULL, NULL, (PVOID)StreamHeader);
				RCA_ACQUIRE_BRIDGE_PIN_LOCK(PinInstance);
				continue;
			}	

			CopyStreamHeaderToIrp(StreamHeader, Irp);
			Status = NDIS_STATUS_SUCCESS;
		} else {
#endif
			
			if (PinInstance->FilterInstance->NextFileObject == (PFILE_OBJECT)NULL) {
				RCADEBUGP(RCA_WARNING, ("RCAIoWorker(): NextFileObject is NULL\n")); 
				// FIXME: Calling RCAIoComplete() with two null args is OK for now since we don't use
				//        those args anyway. But this is bad coding because it will break if we ever 
				//        change RCAIoComplete() to use them. Fix by abstracting out the functionality
				//        we want from RCAIoComplete into another function (which we can then call from
				//        RCAIoComplete).
				RCAIoComplete(NULL, NULL, (PVOID)StreamHeader);

				//
				// FIXME: Leak: nothing ever completes the IRP here.
				//

				RCA_ACQUIRE_BRIDGE_PIN_LOCK(PinInstance);
				continue;
			}
		
			ASSERT(PinInstance->FilterInstance->NextFileObject);
			  
			Status = KsStreamIo(PinInstance->FilterInstance->NextFileObject,
					    NULL,
					    NULL,
					    RCAIoComplete,
					    (PVOID)StreamHeader,
					    KsInvokeOnSuccess | KsInvokeOnError | KsInvokeOnCancel,
					    &RcaGlobal.SHPool.IoStatus,
					    (PVOID)&StreamHeader->Header,
					    StreamHeader->Header.Size,
					    KSSTREAM_WRITE,
					    KernelMode);

			if (!((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING))) {				
				RCADEBUGP(RCA_ERROR, ("KsStreamIo failed with Status == %x\n", Status));
			}


	

#if AUDIO_SINK_FLAG
		}
#endif

		RCA_ACQUIRE_BRIDGE_PIN_LOCK(PinInstance);
	
	}

	// Ok to schedule another work item now.
	PinInstance->bWorkItemQueued = FALSE;

	if (PinInstance->SignalMe) {
		RCADEBUGP(RCA_INFO, ("RCAIoWorker(): Unblocking PinDispatchClose()\n"));
		RCASignal(&PinInstance->Block, Status);
	}

	RCA_RELEASE_BRIDGE_PIN_LOCK(PinInstance);

	RCADEBUGP(RCA_INFO, ("RCAIoWorker(): exit\n"));

}


VOID
RCASHPoolInit(
	       VOID
	      )
/*++

Routine Description:
	Initializes the global stream header pool from which all RCA filters will obtain stream
	headers.
	      
Arguments:
	(None)

Return Value:
	(None)

--*/

{
	RCADEBUGP(RCA_INFO, ("RCASHPoolInit(): enter\n"));

	ExInitializeNPagedLookasideList(&RcaGlobal.SHPool.LookAsideList,
					NULL,
					NULL,
					0,
					sizeof(RCA_STREAM_HEADER),
                                        RCA_TAG, 
					(PAGE_SIZE / sizeof(RCA_STREAM_HEADER)));
	RcaGlobal.SHPool.FailCount = 0;

	RCADEBUGP(RCA_INFO, ("RCASHPoolInit(): exit\n"));
}



PRCA_STREAM_HEADER
RCASHPoolGet(
	      VOID
	     )
/*++                  
		      
Routine Description:  
	Obtains an stream header from the global pool. 
		      
Arguments:            
	(None)	      		      		      
		      
Return Value:         
	A pointer to the stream header, or NULL if no stream header could be obtained. 
		      
		      
--*/           
{
	PRCA_STREAM_HEADER	StreamHeader;

    RCADEBUGP(RCA_INFO, ("RCASHPoolGet(): enter\n"));
		
	StreamHeader = (PRCA_STREAM_HEADER)(ExAllocateFromNPagedLookasideList(&RcaGlobal.SHPool.LookAsideList));
	
	if (StreamHeader == NULL) {
		InterlockedIncrement(&RcaGlobal.SHPool.FailCount);
	}

        RCADEBUGP(RCA_INFO, ("RCASHPoolGet(): exit\n"));
	
	return StreamHeader;
}


VOID                      
RCASHPoolReturn(
		 IN PRCA_STREAM_HEADER StreamHeader
		)
/*++                 
		     
Routine Description: 
	Returns a stream header to the global pool. The stream header will be recycled for use later.
			     
Arguments:            	     
	StreamHeader - Pointer to the stream header being returned
		     
Return Value:        
	(None)	     
		     
--*/                 

{
    RCADEBUGP(RCA_INFO, ("RCASHPoolReturn(): enter\n"));


	ExFreeToNPagedLookasideList(&RcaGlobal.SHPool.LookAsideList,
				    (PVOID)StreamHeader);

	RCADEBUGP(RCA_INFO, ("RCASHPoolReturn(): exit\n"));
}


VOID            
RCASHPoolFree(
	       VOID
	      )
/*++
Routine Description:
	Frees any stream headers in the global IRP pool.
	
Arguments:
	(None)
	
Return Value:
	(None)
--*/
{               
    RCADEBUGP(RCA_INFO, ("RCASHPoolFree(): enter\n"));

	ExDeleteNPagedLookasideList(&RcaGlobal.SHPool.LookAsideList);
	
    RCADEBUGP(RCA_INFO, ("RCASHPoolFree(): exit\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rca\rcastrm.c ===
/*++

Copyright (c) 1997 Microsoft Corporation.

Module Name:

	rcastrm.c

Abstract:

	RCA Streaming routines.

Author:

	Richard Machin (RMachin)

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	RMachin     2-25-97     stolen/adapted from msfsread and mswaveio
	DChen       3-12-98     Bug fixing and cleanup
	JameelH     4-18-98     Cleanup
	SPATHER		5-20-99		Cleanup. Re-orged to separate KS / NDIS parts.

Notes:

--*/

#include <precomp.h>

#define MODULE_NUMBER MODULE_STRM
#define _FILENUMBER 'MRTS'



VOID
RCAReceiveCallback(
				   IN	PVOID			RcaVcContext,
				   IN 	PVOID			ClientReceiveContext,
				   IN	PNDIS_PACKET	pPacket
				   )
{

	NDIS_STATUS				Status = NDIS_STATUS_SUCCESS;
	PPIN_INSTANCE_DEVIO		pDevioPin;
	PPIN_INSTANCE_BRIDGE 	pBridgePin;
	PRCA_STREAM_HEADER		StreamHdr; 
	PMDL					pMdl;
	ULONG					ulBufferLength;
	PWORK_ITEM				pWorkItem;

	RCADEBUGP(RCA_INFO, ("RCAReceiveCallback: Enter\n"));

	do {
		//
		// Check that all our pins exist. 
		//
		pBridgePin = (PPIN_INSTANCE_BRIDGE) ClientReceiveContext;

		if (pBridgePin == NULL) {
			RCADEBUGP(RCA_WARNING, ("RCAReceiveCallback: Bridge pin was null, dumping\n"));			
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		pDevioPin = pBridgePin->FilterInstance->DevIoPin;

		if (pDevioPin == NULL) {
			RCADEBUGP(RCA_WARNING, ("RCAReceiveCallback: Devio pin was null, dumping\n"));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		// Check that the device is in the running state.
		// 

		if (pDevioPin->DeviceState != KSSTATE_RUN) {
			RCADEBUGP(RCA_WARNING, ("RCAReceiveCallback: Device is not running, dumping\n"));
			Status = NDIS_STATUS_FAILURE;
            break;
		}

		//
		// If we're connected as an IRP source, check that there is someone to send IRPs to.
		//

		if (!(pDevioPin->ConnectedAsSink)) {
			if (pDevioPin->FilterInstance->NextFileObject == NULL) {
				RCADEBUGP(RCA_ERROR, ("RCAReceiveCallback: No device to stream to, dumping\n"));
				Status = NDIS_STATUS_FAILURE;
				break;
			}	
		}

		//
		// Get a stream header and fill it out. 
		//
		
		StreamHdr = RCASHPoolGet();

		if (StreamHdr == NULL) {
			RCADEBUGP(RCA_ERROR, ("RCAReceiveCallback: Could not get a stream header\n"));
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		Status = RCACoNdisGetMdlFromPacket(pPacket, &pMdl);
		
		if (Status != NDIS_STATUS_SUCCESS) {
			RCADEBUGP(RCA_ERROR, ("RCAReceiveCallback: Could not get MDL from packet\n"));
			break;
		}

		ulBufferLength = MmGetMdlByteCount(pMdl);

        StreamHdr->Header.Size = sizeof (KSSTREAM_HEADER);
		StreamHdr->Header.TypeSpecificFlags = 0;
		StreamHdr->Header.PresentationTime.Time = 0; // FIXME: Fix this.		
		StreamHdr->Header.PresentationTime.Numerator = 1;
		StreamHdr->Header.PresentationTime.Denominator = 1;
		StreamHdr->Header.DataUsed = ulBufferLength;
		StreamHdr->Header.FrameExtent = ulBufferLength;
		StreamHdr->Header.OptionsFlags = KSSTREAM_HEADER_OPTIONSF_TIMEVALID | KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;
		
		StreamHdr->Header.Data = MmGetSystemAddressForMdl (pMdl);		// data is in MDL address
		StreamHdr->Header.Duration = StreamHdr->Header.DataUsed;  // just use all the data in the buffer

		StreamHdr->NdisPacket = pPacket;

		//
		// Make a worker thread stream the data.
		//
		pWorkItem = WORK_ITEM_FROM_PKT(pPacket);
		pWorkItem->StreamHeader = StreamHdr;

		RCA_ACQUIRE_BRIDGE_PIN_LOCK(pBridgePin);

		RcaGlobal.QueueSize++;

		InsertTailList(&pBridgePin->WorkQueue, &pWorkItem->ListEntry);

		if (!pBridgePin->bWorkItemQueued) {
			//
			// There is no work item pending, so we'll schedule one.
			//
			NdisInitializeWorkItem(&pBridgePin->WorkItem, RCAIoWorker, (PVOID)pBridgePin);
			NdisScheduleWorkItem(&pBridgePin->WorkItem); 			
			pBridgePin->bWorkItemQueued = TRUE;
		}

		RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePin);
		
	} while (FALSE);

	//
	// If something got botched, return the packet immediately. 
	//
	if (Status != NDIS_STATUS_SUCCESS) {
		RCACoNdisReturnPacket(pPacket);
	}

	RCADEBUGP(RCA_INFO, ("RCAReceiveCallback: Exit\n"));
}


VOID
RCASendCompleteCallback(
						IN	PVOID		RcaVcContext, 
						IN	PVOID		ClientSendContext,
						IN	PVOID		PacketContext,
						IN	PMDL		pSentMdl,
						IN	NDIS_STATUS	Status
						)
{
	PIRP					pIrp = (PIRP) PacketContext;
	PIO_STACK_LOCATION		pIrpSp;
	PPIN_INSTANCE_BRIDGE 	pBridgePin = (PPIN_INSTANCE_BRIDGE) ClientSendContext;

	RCADEBUGP(RCA_INFO, ("RCASendCompleteCallback: Enter\n"));
		
	//
	// Complete the IRP.
	//
	pIrp->IoStatus.Status = Status;

	if (!NT_SUCCESS(Status)) {
		RCADEBUGP(RCA_ERROR, ("RCASendCompleteCallback: "
							  "Send failed with status 0x%x\n", Status));
	}

	pIrp->IoStatus.Information = 0;

	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	if (pBridgePin) {
		RCA_ACQUIRE_BRIDGE_PIN_LOCK(pBridgePin);
	
		pBridgePin->PendingSendsCount--;

		if ((pBridgePin->PendingSendsCount == 0) && pBridgePin->SignalWhenSendsComplete) {
			RCASignal(&pBridgePin->PendingSendsBlock, Status);
		}

		RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePin);
	}

	//
	// Free the MDL.
	//

	IoFreeMdl(pSentMdl);

	RCADEBUGP(RCA_INFO, ("RCASendCompleteCallback: Exit\n"));
}


VOID 
RCAVcCloseCallback(
				   IN	PVOID	RcaVcContext, 
				   IN	PVOID	ClientReceiveContext,
				   IN	PVOID	ClientSendContext
				   )
{
	PPIN_INSTANCE_BRIDGE pBridgePin;
	PVOID				 VcContextToRelease;

	if (ClientReceiveContext) {
		pBridgePin = (PPIN_INSTANCE_BRIDGE) ClientReceiveContext;

        RCA_ACQUIRE_BRIDGE_PIN_LOCK(pBridgePin);

		ASSERT(RcaVcContext == pBridgePin->VcContext);

		VcContextToRelease = pBridgePin->VcContext;

		pBridgePin->VcContext = NULL; 
		if (pBridgePin->FilterInstance->DevIoPin)
			pBridgePin->FilterInstance->DevIoPin->VcContext = NULL;

		RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePin);

		RCACoNdisReleaseReceiveVcContext(VcContextToRelease);				
	} 

	if (ClientSendContext) {
		pBridgePin = (PPIN_INSTANCE_BRIDGE) ClientSendContext;

        RCA_ACQUIRE_BRIDGE_PIN_LOCK(pBridgePin);

        ASSERT(RcaVcContext == pBridgePin->VcContext);
					
		VcContextToRelease = pBridgePin->VcContext;
			    		
		pBridgePin->VcContext = NULL; 
		if (pBridgePin->FilterInstance->DevIoPin)
			pBridgePin->FilterInstance->DevIoPin->VcContext = NULL;

        RCA_RELEASE_BRIDGE_PIN_LOCK(pBridgePin);
	
		RCACoNdisReleaseSendVcContext(VcContextToRelease);
	}	

}




NTSTATUS
ReadStream(
	IN	PIRP				Irp,
	IN	PPIN_INSTANCE_DEVIO	PinInstance
	)
/*++

Routine Description:

	Handles IOCTL_KS_READ_STREAM by reading data from the open VC.

Arguments:

	Irp - Streaming Irp.

Return Values:

	Returns STATUS_SUCCESS if the request was fulfilled.
	Else returns STATUS_PORT_DISCONNECTED if the VC has been closed (no FILE PIN in this
	context).
	some read error, or some parameter validation error.

--*/
{
	NTSTATUS		 Status = STATUS_UNSUCCESSFUL;
	PFILTER_INSTANCE FilterInstance = PinInstance->FilterInstance;

	RCADEBUGP(RCA_LOUD, ("ReadStream: enter\n"));	

	if (FilterInstance->FilterType == FilterTypeCapture) 
	{
		if ((PinInstance->DeviceState == KSSTATE_RUN) || 
			(PinInstance->DeviceState == KSSTATE_PAUSE)) 
		{
			PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp); // Can be removed when the following debug print is removed

			RCADEBUGP(RCA_LOUD, ("ReadStream: Irp's output buffer length is: 0x%x\n",
			      irpSp->Parameters.DeviceIoControl.OutputBufferLength));

			Status = KsProbeStreamIrp(Irp,
						  KSPROBE_STREAMREAD |  (KSPROBE_ALLOCATEMDL | KSPROBE_PROBEANDLOCK),
						  sizeof(KSSTREAM_HEADER));

			if (NT_SUCCESS(Status)) 
			{
#if AUDIO_SINK_FLAG
				KsAddIrpToCancelableQueue(&PinInstance->ActiveQueue,
										  &PinInstance->QueueLock,
										  Irp,
										  KsListEntryTail,
										  NULL);
#endif				
				Status = STATUS_PENDING;
			} 
			else 
			{
				RCADEBUGP(RCA_ERROR, ("ReadStream: "
						      "KsProbeStreamIrp failed with Status == 0x%x\n",
						      Status));
			}
		} 
	} 

	return(Status);
}

NTSTATUS
WriteStream(
	IN	PIRP				Irp,
	IN	PPIN_INSTANCE_DEVIO	pDevIoPin
	)
/*++

Routine Description:

	Handles IOCTL_KS_WRITE_STREAM by writing data to the open VC.

Arguments:

	Irp -
		Streaming Irp.

Return Values:

	Returns STATUS_SUCCESS if the request was fulfilled (in which case the irp is pended
	until we complete it in our cosendcompletehandler.)
	
	Else returns an error, and the irp is completed back to the caller.
--*/
{
	NTSTATUS			Status = 0;
	PVOID				VcContext;
	PNDIS_PACKET		pNdisPacket;
	ULONG				BufferLength;
	PUCHAR				SystemBuffer;
	PMDL				pMdl;
	PVOID				pMdlVirtualAddress;
	UINT				bLength = 0;

	RCADEBUGP(RCA_LOUD, ("WriteStream: enter\n"));

	RCAAssert( KeGetCurrentIrql() == PASSIVE_LEVEL );

	RCA_ACQUIRE_BRIDGE_PIN_LOCK(pDevIoPin->FilterInstance->BridgePin);

	VcContext = pDevIoPin->VcContext;

    RCA_RELEASE_BRIDGE_PIN_LOCK(pDevIoPin->FilterInstance->BridgePin);

	//
	// FIXME: Now that we've released the lock, the VC could go away and
	//        we'd be in trouble. Don't know how big this timing window 
	//		  is.  
	//

	do
	{
		ULONG BytesToCopy;

		if (VcContext == NULL)
		{
			RCADEBUGP(RCA_LOUD, ("WriteStream: no associated VC\n"));
			//
			// Bad sts will cause irp to be completed with sts in iostatus buffer
			//
			Status = STATUS_PORT_DISCONNECTED;
			break;
		}

		if (pDevIoPin->DeviceState != KSSTATE_RUN) {
			//
			// Device isn't "runnning". 
			//

			Status = NDIS_STATUS_FAILURE;
			break;
		}
		//
		//	Get the data in an MDL if it's not already. From the KsProbeStreamIrp code:
		//
		//	Makes the specified modifications to the given IRP's input and output
		//	buffers based on the specific streaming IOCTL in the current stack
		//	location, and validates the stream header. The Irp end up in essentially
		//	the METHOD_OUT_DIRECT or
		//	METHOD_IN_DIRECT format, with the exception that the access to the data
		//	buffer may be IoModifyAccess depending on the flags passed to this
		//	function or in the stream header. If the stream buffers MDL's have been
		//	allocated, they are available through the PIRP->MdlAddress. If extra data
		//	has been requested, the copied list of headers with extra data area is
		//	available in PIRP->Tail.Overlay.AuxiliaryBuffer.
		//
		Status = KsProbeStreamIrp(Irp,
								  KSPROBE_STREAMWRITE | KSPROBE_ALLOCATEMDL | KSPROBE_PROBEANDLOCK,
								  sizeof(KSSTREAM_HEADER));

		if (Status != STATUS_SUCCESS)
		{
			RCADEBUGP(RCA_WARNING,("WriteStream: KsProbeStreamIrp failed sts %x\n", Status));
			break;
		}

		if (!((PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer)->DataUsed)
		{
			//
			// This IRP has no data, complete it immediately.
			//
			RCADEBUGP(RCA_WARNING, ("Irp %x has no data\n", Irp) );
			Status = STATUS_UNSUCCESSFUL;
			break;
		}

		//
		// Build a partial MDL containing only the dataused portion of this MDL
		//
		RCADEBUGP(RCA_INFO,("WriteStream: allocating MDL\n"));

		pMdlVirtualAddress = MmGetMdlVirtualAddress (Irp->MdlAddress);
		
		RCADEBUGP(RCA_INFO,("WriteStream: going to alloc an mdl of length %lu\n",
				    ((PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer)->DataUsed));

		pMdl = IoAllocateMdl(pMdlVirtualAddress,
							 ((PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer)->DataUsed,
							 FALSE,
							 FALSE,
							 NULL);
		if (pMdl == NULL) {  
			RCADEBUGP(RCA_WARNING,("WriteStream: STATUS_INSUFFICIENT_RESOURCES for MDL\n"));
			return(STATUS_INSUFFICIENT_RESOURCES);
		}

		RCADEBUGP(RCA_INFO,("WriteStream: building partial MDL\n"));
		
		BytesToCopy = ((PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer)->DataUsed;

		//
		// For debugging only.
		//
		if (g_ulBufferSize > 0) {
			BytesToCopy = g_ulBufferSize;
		}

		IoBuildPartialMdl(Irp->MdlAddress,
						  pMdl,
						  pMdlVirtualAddress,
						  BytesToCopy);

		//
		// TBS: wait for CSA soltion for passing header info across transform filters.
		// Now we're sure the header is in the system buffer. We also need to ship the header, since
		// we need the dataused number and (in future) CSA will specify timing and other info in there
		// that we need to get end-to-end. Allocate the MDL and put it on the end of the list
		//

		IoMarkIrpPending( Irp );

        RCA_ACQUIRE_BRIDGE_PIN_LOCK(pDevIoPin->FilterInstance->BridgePin);

		pDevIoPin->FilterInstance->BridgePin->PendingSendsCount++;

        RCA_RELEASE_BRIDGE_PIN_LOCK(pDevIoPin->FilterInstance->BridgePin);
		
		Status = RCACoNdisSendFrame(VcContext,
									pMdl,
									(PVOID)Irp);
		
		if (Status != NDIS_STATUS_PENDING) {
			RCADEBUGP(RCA_ERROR, ("WriteStream: RCACoNdisSendFrame returned status 0x%x, "
								  "manually calling send complete handler\n", Status));
			
			RCASendCompleteCallback(VcContext,
									(PVOID) pDevIoPin->FilterInstance->BridgePin,
									(PVOID)	Irp,
									pMdl,
									Status);
		}

		//
		// If status returned from RCACoNdisSendFrame was not STATUS_PENDING, then we 
		// completed the IRP with that status. We need to set the status back to PENDING
		// here so that PinDispatchIoControl will not try to complete the IRP again. 
		//
		Status = NDIS_STATUS_PENDING;
	} while (FALSE);

	return(Status);
}

NTSTATUS
GetInterface(
	IN	PIRP				Irp,
	IN	PKSPROPERTY			Property,
	OUT	PKSPIN_INTERFACE	Interface
	)
/*++

Routine Description:

	Handles the KSPROPERTY_STREAM_INTERFACE property Get in the Stream property set.
	Returns the interface on the Dev I/O Pin so that positional translations can be
	performed.

Arguments:

	Irp -
		Device control Irp.

	Property -
		Specific property request.

	Interface -
		The place in which to put the Interface.

Return Values:

	Returns STATUS_SUCCESS.

--*/
{
	RCADEBUGP(RCA_INFO, ("GetInterface: Enter\n"));
	
	Interface->Set = KSINTERFACESETID_Standard;
	//  Interface->Id = KSINTERFACE_STANDARD_POSITION;
	Irp->IoStatus.Information = sizeof(KSPIN_INTERFACE);

	RCADEBUGP(RCA_INFO, ("GetInterface: Exit - Returning STATUS_NOT_IMPLEMENTED\n"));

	DbgBreakPoint();
	return(STATUS_NOT_IMPLEMENTED);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\ctlreshm.h ===
extern WCHAR   g_szDllContextHelpFileName[];

// help ids

#define IDH_DIALOG_SERVICE_PROVIDERS_BUTTON_DELETE                          100

#define IDH_LOGON_EDIT_USERNAME                                             200
#define IDH_LOGON_EDIT_PASSWORD                                             201
#define IDH_LOGON_CHECK_SAVEPASSWORD                                        202

#define IDH_DIALOG_CALL_FROM_NUMBERS_BUTTON_ADD                             301
#define IDH_DIALOG_CALL_FROM_NUMBERS_BUTTON_MODIFY                          302
#define IDH_DIALOG_CALL_FROM_NUMBERS_BUTTON_REMOVE                          303
#define IDH_DIALOG_CALL_FROM_NUMBERS_LIST_NUMBERS                           304

#define IDH_DIALOG_DIAL_BY_PHONE_NUMBER_LIST_COUNTRY                        400
#define IDH_DIALOG_DIAL_BY_PHONE_NUMBER_EDIT_CITY                           401
#define IDH_DIALOG_DIAL_BY_PHONE_NUMBER_EDIT_LOCALNUMBER                    402
#define IDH_DIALOG_DIAL_BY_PHONE_NUMBER_EDIT_COMPLETENUMBER                 403
 
#define IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_EDIT_LABEL                    500
#define IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_LIST_COUNTRY                  501 
#define IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_EDIT_CITY                     502 
#define IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_EDIT_LOCALNUMBER              503
#define IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_EDIT_COMPLETENUMBER           504

#define IDH_DIALOG_DIAL_BY_NAME_EDIT_ADDRESS                                600

#define IDH_DIALOG_NEED_CALL_INFO_EDIT_ADDRESS                              700
#define IDH_DIALOG_NEED_CALL_INFO_LIST_ITSP                                 701
#define IDH_DIALOG_NEED_CALL_INFO_BUTTON_EDITSP                             702
#define IDH_DIALOG_NEED_CALL_INFO_RADIO_COMPUTER                            703
#define IDH_DIALOG_NEED_CALL_INFO_RADIO_PHONE                               704
#define IDH_DIALOG_NEED_CALL_INFO_LIST_PHONES                               705
#define IDH_DIALOG_NEED_CALL_INFO_BUTTON_EDITPHONE                          706
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\dial.h ===
//
// Dial.h
//

#ifndef __DIAL_H_
#define __DIAL_H_

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// External functions
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowDialNeedCallInfoDialog(
    IN   HWND           hwndParent,
    IN   IRTCClient   * pClient,
    IN   long           lSessionMask,
    IN   BOOL           bEnumerateProfiles,
    IN   BOOL           bProfileEditable,
    IN   IRTCProfile  * pOneShotProfile,
    IN   BSTR	        pDestAddress,
    IN   BSTR           pInstructions,
    OUT  IRTCProfile ** ppProfileChosen,
    OUT  BSTR         * ppFromAddressChosen
    );

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowDialByPhoneNumberDialog(
    IN  HWND         hwndParent,
    IN  BOOL         bAddParticipant,
    IN  BSTR         pDestPhoneNr,
    OUT BSTR       * ppDestPhoneNrChosen
    );

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowDialByAddressDialog(
    IN   HWND           hwndParent,
    IN   BSTR	        pDestAddress,
    OUT  BSTR         * ppDestAddressChosen
    );

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowMessageByAddressDialog(
    IN   HWND           hwndParent,
    IN   BSTR	        pDestAddress,
    OUT  BSTR         * ppDestAddressChosen
    );

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowEditServiceProviderListDialog(
    IN   HWND         hwndParent,
    IN   IRTCClient * pClient
    );

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowEditCallFromListDialog(
    IN   HWND         hwndParent
    );

#endif // __DIAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\ctlres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rtcctl.rc
//
#define IDS_APPNAME                     20
#define IDS_PROJNAME                    100
#define IDS_RTCCLIENT_DESC              101
#define IDS_RTCCTL_DESC                 101
#define IDI_SECURITY                    104
#define IDC_DONOT_PROMPT_IN_THE_FUTURE  107
#define IDS_RTC_SEC_PROMPT              108
#define IDS_PARTICIPANT_NAME_HEADER     109
#define IDS_PARTICIPANT_STATUS_HEADER   110
#define IDC_TOOLBAR                     110
#define IDS_SESSION_STATE_INCOMING      111
#define IDS_PART_STATE_PENDING          111
#define IDS_SESSION_STATE_CONNECTING    112
#define IDS_PART_STATE_CONNECTING       112
#define IDR_RTCCTL                      113
#define IDS_SESSION_STATE_CONNECTED     113
#define IDC_BUTTON_RECV_VIDEO_ENABLED   113
#define IDS_PART_STATE_CONNECTED        113
#define IDD_RTCCTL                      114
#define IDS_SESSION_STATE_DISCONNECTED  114
#define IDC_BUTTON_SEND_VIDEO_ENABLED   114
#define IDS_PART_STATE_DISCONNECTED     114
#define IDS_GENERIC_UNKNOWN             115
#define IDS_PART_STATE_REJECTED         116
#define IDS_PART_REJECTED_BUSY          117
#define IDS_PART_REJECTED_NO_ANSWER     118
#define IDS_PART_REJECTED_PL_FAILED     119
#define IDS_PART_REJECTED_SW_FAILED     120
#define IDS_PART_REJECTED_CANCELLED     121
#define IDS_PART_REJECTED_OTHER         122
#define IDS_PART_STATE_ERROR            123
#define IDS_PART_REJECTED_ALL_BUSY      124
#define IDS_PART_STATE_DISCONNECTING    125
#define IDS_PART_REJECTED_BADNUMBER     126
#define IDR_RTCProvStore                127
#define IDD_RTC_SECURITY_DIALOG         128
#define ID_YES                          129
#define ID_NO                           130
#define ID_YES_DONT_ASK_AGAIN           131
#define IDC_SECURITY_WARNING_ICON       132
#define IDC_SECURITY_WARNING_TEXT       133
#define IDS_TIPS_CALL                   200
#define IDC_BUTTON_CALL                 201
#define IDD_DIALOG_DIAL_BY_PHONE_NUMBER 201
#define IDS_TIPS_HANGUP                 201
#define IDB_RECEIVEWALLPAPER            202
#define IDC_BUTTON_HUP                  202
#define IDD_DIALOG_ADD_CALL_FROM_NUMBER 202
#define IDS_TIPS_KNOB_SPEAKER           202
#define IDC_BUTTON_MUTE_SPEAKER         203
#define IDB_PARTICIPANT_LIST            203
#define IDD_DIALOG_CALL_FROM_NUMBERS    203
#define IDS_TIPS_KNOB_MICRO             203
#define IDC_BUTTON_MUTE_MICRO           204
#define IDS_TIPS_RECV_VIDEO_ENABLED     204
#define IDS_TIPS_SEND_VIDEO_ENABLED     205
#define IDR_ACCELERATOR_DIALPAD         206
#define IDS_TIPS_MUTE_SPEAKER           206
#define IDR_TOOLBAR_MAIN                207
#define IDC_RECEIVELOGO                 207
#define IDD_DIALOG_DIAL_BY_NAME         207
#define IDS_TIPS_MUTE_MICRO             207
#define IDC_PREVIEWLOGO                 208
#define IDB_TOOLBAR_NORMAL              208
#define IDC_COMBO_SPEEDDIAL             209
#define IDC_STATUSBAR                   209
#define IDB_TOOLBAR_DISABLED            209
#define IDC_BUTTON_GO                   210
#define IDB_TOOLBAR_HOT                 210
#define IDC_LIST_CALL_FROM              211
#define IDC_KNOB_SPEAKER                211
#define IDC_LIST_COUNTRIES              212
#define IDC_KNOB_MICRO                  212
#define IDC_EDIT_AREA_CODE              214
#define IDC_LIST_PARTICIPANTS           215
#define IDC_EDIT_LOCAL_NUMBER           215
#define IDC_LIST_SERVICE_PROVIDERS      216
#define IDC_STATIC_COUNTRY              217
#define IDC_STATIC_INSTRUCTIONS         218
#define IDC_STATIC_CALLTO_GROUP         219
#define IDC_STATIC_LABEL                219
#define IDC_STATIC_COMPLETE_NUMBER      220
#define IDC_STATIC_AREA_CODE            221
#define IDC_STATIC_LOCAL_NUMBER         222
#define IDC_STATIC_SERVICE_PROVIDER     223
#define IDC_STATIC_CALL_FROM            224
#define IDC_STATIC_LABEL_GROUP          224
#define IDC_BUTTON_EDIT_CALL_FROM_LIST  225
#define IDC_BUTTON_EDIT_SERVICE_PROVIDER_LIST 226
#define IDC_COMBO_COUNTRY               227
#define IDC_COMBO_SERVICE_PROVIDER      228
#define IDC_EDIT_LABEL                  228
#define IDC_COMBO_CALL_FROM             229
#define IDC_STATIC_PHONE_NUMBER_GROUP   229
#define IDC_BUTTON_DELETE               232
#define IDC_BUTTON_ADD                  233
#define IDC_BUTTON_MODIFY               235
#define IDC_EDIT_COMPLETE               236
#define IDC_RADIO_FROM_COMPUTER         237
#define IDC_RADIO_FROM_PHONE            238
#define IDC_LIST_SERVICE_PROVIDER       241
#define IDR_ACCELERATOR_TOOLBAR         241
#define IDD_DIALOG_DIAL_NEED_CALL_INFO  242
#define IDD_DIALOG_SERVICE_PROVIDERS    243
#define IDC_STATIC_MSG_ICON             243
#define IDD_DIALOG_ERROR_MESSAGE_LITE   244
#define IDC_STATIC_MSG1                 244
#define IDC_EDIT_MSG3                   246
#define IDC_BUTTON_ADD_PART             247
#define IDC_EDIT_MSG2                   247
#define IDB_METAL                       248
#define IDC_BUTTON_REM_PART             248
#define IDC_EDIT_MSG1                   248
#define IDC_VOLHAND                     250
#define IDC_VOLVERT                     251
#define IDC_VOLHORZ                     252
#define IDC_VOLDPOS                     253
#define IDC_VOLDNEG                     254
#define IDB_KNOB                        254
#define IDB_SPKVOL                      254
#define IDB_KNOB_LIGHT                  255
#define IDB_KNOB_LIGHT_DIM              256
#define IDB_KNOB_LIGHT_MASK             257
#define IDB_KNOB_TABSTATE               258
#define IDB_SPKVOL_HOT                  258
#define IDB_KNOB_DISABLED               259
#define IDB_SPKVOL_DISABLED             259
#define IDB_KNOB_LIGHT_DISABLED         260
#define IDB_MICVOL                      262
#define IDB_MICVOL_DISABLED             263
#define IDB_MICVOL_HOT                  264
#define IDB_AV_DISABLED                 265
#define IDB_AV_ACTIVE_HOT               266
#define IDB_AV_ACTIVE_PUSH              267
#define IDB_AV_ACTIVE                   268
#define IDB_AV_INACTIVE_HOT             270
#define IDB_AV_INACTIVE_PUSH            271
#define IDB_AV_INACTIVE                 272
#define IDS_NONE                        273
#define IDS_ADD_PARTICIPANT             274
#define IDB_BUTTON_PRESS                275
#define IDB_BUTTON_HOT                  276
#define IDB_BUTTON_NORM                 277
#define IDB_BUTTON_DIS                  278
#define IDS_TIPS_ADD_PART               280
#define IDS_TIPS_REM_PART               281
#define IDS_SEND                        282
#define IDS_RECEIVE                     283
#define IDC_IM_MENU                     284
#define IDD_DIALOG_MESSAGE_BY_NAME      285
#define IDC_VIDEOTUNE                   286
#define IDS_TEXT_PROVIDER               300
#define IDS_TEXT_REALM                  301
#define IDS_BUTTON_CALL                 400
#define IDS_BUTTON_HANGUP               401
#define IDS_BUTTON_ADD_PART             402
#define IDS_BUTTON_REM_PART             403
#define IDS_TEXT_AUDIO                  450
#define IDS_TEXT_VIDEO                  451
#define IDC_DIAL_0                      500
#define IDC_DIAL_1                      501
#define IDC_DIAL_2                      502
#define IDC_DIAL_3                      503
#define IDC_DIAL_4                      504
#define IDC_DIAL_5                      505
#define IDC_DIAL_6                      506
#define IDC_DIAL_7                      507
#define IDC_DIAL_8                      508
#define IDC_DIAL_9                      509
#define IDC_DIAL_STAR                   510
#define IDC_DIAL_POUND                  511
#define IDS_SB_STATUS_NONE              600
#define IDS_SB_STATUS_ERROR             601
#define IDS_SB_STATUS_IDLE              602
#define IDS_SB_STATUS_UI_BUSY           603
#define IDS_SB_STATUS_DIALING           604
#define IDS_SB_STATUS_CONNECTING        605
#define IDS_SB_STATUS_ANSWERING         606
#define IDS_SB_STATUS_DISCONNECTING     607
#define IDS_SB_STATUS_ALERTING          608
#define IDS_SB_STATUS_CONNECTED         609
#define IDS_SB_STATUS_HOLD              610
#define IDS_SB_STATUS_IDLE_FAILED       620
#define IDS_SB_STATUS_CONNECTING_RINGING 621
#define IDS_SB_STATUS_CONNECTING_QUEUED 622
#define IDS_SB_STATUS_REDIRECTING       623
#define IDS_MB_DETAIL_SIP               650
#define IDS_MB_DETAIL_HR                651
#define IDS_MB_DETAIL_HR_UNKNOWN        652
#define IDS_IM_WINDOW_TITLE             667
#define IDS_IM_SEND                     668
#define IDS_IM_INCOMING_MESSAGE         669
#define IDS_IM_OUTGOING_MESSAGE         670
#define IDS_IM_SAYS                     671
#define IDS_IM_MESSAGE_RECEIVED         672
#define IDS_IM_MESSAGE_SENT             673
#define IDS_IM_AT                       674
#define IDS_IM_ON                       675
#define IDS_IM_DISCONNECTED             676
#define IDS_IM_FILE_FILTER              677
#define IDS_IM_TYPING                   678
#define IDM_IM_CALL_CLOSE               700
#define IDM_IM_TOOLS_SOUNDS             701
#define IDM_IM_TOOLS_LARGEST            702
#define IDM_IM_TOOLS_LARGER             703
#define IDM_IM_TOOLS_MEDIUM             704
#define IDM_IM_TOOLS_SMALLER            705
#define IDM_IM_TOOLS_SMALLEST           706
#define IDM_IM_CALL_SAVEAS              707
#define IDC_TEXT_CALLINFO_REDIRECT      800
#define IDS_TEXT_CALLINFO_REDIRECT      800
#define IDS_MESSAGE_DUPLICATE_PARTICIPANT 900
#define IDS_MESSAGE_CANNOT_ADD_PARTICIPANT 901
#define IDS_ERROR_INIT_GENERIC          1000
#define IDS_ERROR_INIT_CORE             1001
#define IDS_ERROR_INIT_INVPARAM_SCENARIO 1002
#define IDS_ERROR_INIT_INVPARAM_URL     1003
#define IDS_ERROR_INIT_INVPARAM_PROV    1004
#define IDS_ERROR_NO_PROVIDERS          1006
#define IDS_ERROR_INIT_INVPARAM_BOOLEAN 1007
#define IDS_CALLBACK                    1102
#define IDS_CAR                         1103
#define IDS_HOME                        1104
#define IDS_HOME2                       1105
#define IDS_MOBILE                      1106
#define IDS_OTHER                       1107
#define IDS_PAGER                       1108
#define IDS_PRIMARY                     1109
#define IDS_RADIO                       1110
#define IDS_TTYTDD                      1111
#define IDS_IPPHONE                     1112
#define IDS_EMAIL                       1113
#define IDS_WAB                         1200
#define IDS_MAPI                        1201
#define IDS_WAVEIN_MUTED                1301
#define IDS_MICROPHONE_MUTED            1302
#define IDS_MICROPHONE_NOT_SELECTED     1303
#define IDS_MB_HRERROR_NOTFOUND_1       2000
#define IDS_MB_HRERROR_NOTFOUND_2       2001
#define IDS_MB_HRERROR_CLIENT_NOTRUNNING_1 2002
#define IDS_MB_HRERROR_CLIENT_NOTRUNNING_2 2003
#define IDS_MB_HRERROR_SERVER_NOTRUNNING_1 2004
#define IDS_MB_HRERROR_SERVER_NOTRUNNING_2 2005
#define IDS_MB_HRERROR_INVALIDADDRESS_1 2006
#define IDS_MB_HRERROR_INVALIDADDRESS_2 2007
#define IDS_MB_HRERROR_CALLING_PRIMARY_LEG_1 2008
#define IDS_MB_HRERROR_CALLING_PRIMARY_LEG_2 2009
#define IDS_MB_HRERROR_SIP_TIMEOUT_OUT_1 2010
#define IDS_MB_HRERROR_SIP_TIMEOUT_OUT_2 2011
#define IDS_MB_HRERROR_APPS_DONT_MATCH_1 2012
#define IDS_MB_HRERROR_APPS_DONT_MATCH_OUT_2 2013
#define IDS_MB_HRERROR_APPS_DONT_MATCH_IN_2 2014
#define IDS_MB_HRERROR_SIP_TIMEOUT_IN_1 2015
#define IDS_MB_HRERROR_SIP_TIMEOUT_IN_2 2016
#define IDS_MB_HRERROR_GENERIC_OUT_1    2017
#define IDS_MB_HRERROR_GENERIC_OUT_2    2018
#define IDS_MB_HRERROR_GENERIC_IN_1     2019
#define IDS_MB_HRERROR_GENERIC_IN_2     2020
#define IDS_MB_SIPERROR_NOTFOUND_1      2021
#define IDS_MB_SIPERROR_NOTFOUND_2      2022
#define IDS_MB_SIPERROR_AUTH_FAILED_1   2023
#define IDS_MB_SIPERROR_AUTH_FAILED_2   2024
#define IDS_MB_SIPERROR_NOTANSWERING_1  2025
#define IDS_MB_SIPERROR_NOTANSWERING_2  2026
#define IDS_MB_SIPERROR_NOTAVAIL_1      2027
#define IDS_MB_SIPERROR_NOTAVAIL_2      2028
#define IDS_MB_SIPERROR_BUSY_1          2029
#define IDS_MB_SIPERROR_BUSY_2          2030
#define IDS_MB_SIPERROR_SERVER_PROBLEM_1 2031
#define IDS_MB_SIPERROR_SERVER_PROBLEM_2 2032
#define IDS_MB_SIPERROR_DECLINE_1       2033
#define IDS_MB_SIPERROR_DECLINE_2       2034
#define IDS_MB_SIPERROR_PINT_BUSY_1     2035
#define IDS_MB_SIPERROR_PINT_BUSY_2     2036
#define IDS_MB_SIPERROR_PINT_NOANSWER_1 2037
#define IDS_MB_SIPERROR_PINT_NOANSWER_2 2038
#define IDS_MB_SIPERROR_PINT_ALLBUSY_1  2039
#define IDS_MB_SIPERROR_PINT_ALLBUSY_2  2040
#define IDS_MB_SIPERROR_GENERIC_1       2041
#define IDS_MB_SIPERROR_GENERIC_2       2042
#define IDS_MB_HRERROR_LOCAL_MACHINE_1  2043
#define IDS_MB_HRERROR_LOCAL_MACHINE_2  2044
#define IDC_ONDESKTOP                   8000
#define IDC_ONQUICKLAUNCH               8001
#define IDS_STOPBUTTON_TEXT             17075
#define IDS_TESTBUTTON_TEXT             17076
#define ID_BUTTON32768                  32768

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        287
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         253
#define _APS_NEXT_SYMED_VALUE           115
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\dial.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Dial.cpp
//

#include "stdafx.h"
#include "dial.h"

#include <tapi.h>
#include <winsock2.h>

#ifdef ASSERT
#undef ASSERT
#endif


#define ASSERT _ASSERTE

//////////////////////////////////////////////////////////////////////////////
//
// Constants
//

#define DEFAULT_PHONE_NUMBER L"+1 (425) 555-1212"


//////////////////////////////////////////////////////////////////////////////
//
// Help arrays
//
DWORD   g_dwHelpArrayDialByName[] =
{
    IDC_EDIT_COMPLETE, IDH_DIALOG_DIAL_BY_NAME_EDIT_ADDRESS,
    0, 0
};

DWORD   g_dwHelpArrayDialByPhoneNumber[] =
{
    IDC_COMBO_COUNTRY,      IDH_DIALOG_DIAL_BY_PHONE_NUMBER_LIST_COUNTRY,
    IDC_EDIT_AREA_CODE,     IDH_DIALOG_DIAL_BY_PHONE_NUMBER_EDIT_CITY,
    IDC_EDIT_LOCAL_NUMBER,  IDH_DIALOG_DIAL_BY_PHONE_NUMBER_EDIT_LOCALNUMBER,
    IDC_EDIT_COMPLETE,      IDH_DIALOG_DIAL_BY_PHONE_NUMBER_EDIT_COMPLETENUMBER, 
    0, 0
};

DWORD   g_dwHelpArrayNeedCallInfo[] =
{
    IDC_EDIT_COMPLETE,                      IDH_DIALOG_NEED_CALL_INFO_EDIT_ADDRESS,    
    IDC_COMBO_SERVICE_PROVIDER,             IDH_DIALOG_NEED_CALL_INFO_LIST_ITSP,        
    IDC_BUTTON_EDIT_SERVICE_PROVIDER_LIST,  IDH_DIALOG_NEED_CALL_INFO_BUTTON_EDITSP,
    IDC_RADIO_FROM_COMPUTER,                IDH_DIALOG_NEED_CALL_INFO_RADIO_COMPUTER,
    IDC_RADIO_FROM_PHONE,                   IDH_DIALOG_NEED_CALL_INFO_RADIO_PHONE,
    IDC_COMBO_CALL_FROM,                    IDH_DIALOG_NEED_CALL_INFO_LIST_PHONES,
    IDC_BUTTON_EDIT_CALL_FROM_LIST,         IDH_DIALOG_NEED_CALL_INFO_BUTTON_EDITPHONE,
    0, 0      
}; 

DWORD   g_dwHelpArrayServiceProviders[] =
{
    IDC_LIST_SERVICE_PROVIDER, IDH_DIALOG_SERVICE_PROVIDERS_BUTTON_DELETE,    
    0, 0      
}; 


DWORD   g_dwHelpArrayCallFromNumbers[] =
{
    IDC_LIST_CALL_FROM,                     IDH_DIALOG_CALL_FROM_NUMBERS_LIST_NUMBERS,
    IDC_BUTTON_ADD,                         IDH_DIALOG_CALL_FROM_NUMBERS_BUTTON_ADD,   
    IDC_BUTTON_MODIFY,                      IDH_DIALOG_CALL_FROM_NUMBERS_BUTTON_MODIFY,
    IDC_BUTTON_DELETE,                      IDH_DIALOG_CALL_FROM_NUMBERS_BUTTON_REMOVE,
    0, 0      
}; 



DWORD   g_dwHelpArrayAddCallFrom[] =
{
    IDC_EDIT_LABEL,         IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_EDIT_LABEL,
    IDC_COMBO_COUNTRY,      IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_LIST_COUNTRY,
    IDC_EDIT_AREA_CODE,     IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_EDIT_CITY,      
    IDC_EDIT_LOCAL_NUMBER,  IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_EDIT_LOCALNUMBER,
    IDC_EDIT_COMPLETE,      IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_EDIT_COMPLETENUMBER,
    0, 0      
}; 




//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


HRESULT PopulatePhoneNumberEditBoxes(
    IN   HWND              hwndDlg,
    IN   IRTCPhoneNumber * pPhoneNumber
    );

//////////////////////////////////////////////////////////////////////////////
//
//

void CheckRadioButton(
    IN   HWND   hwndDlg,
    IN   int    nIDDlgItem,
    IN   BOOL   fCheck
    )
{
    LOG((RTC_TRACE, "CheckRadioButton - enter"));

    //
    // Retrieve a handle to the control.
    //

    HWND hwndControl;

    hwndControl = GetDlgItem(
        hwndDlg,
        nIDDlgItem
        );

    ASSERT( hwndControl != NULL );

    //
    // Send the check/uncheck message to the control.
    //

    SendMessage(
        hwndControl,
        BM_SETCHECK,
        (WPARAM) ( fCheck ? BST_CHECKED : BST_UNCHECKED),
        0
        );


    LOG((RTC_TRACE, "CheckRadioButton - exit S_OK"));    
}


//////////////////////////////////////////////////////////////////////////////
//
//

void EnableControl(
    IN   HWND   hwndDlg,
    IN   int    nIDDlgItem,
    IN   BOOL   fEnable
    )
{
    LOG((RTC_TRACE, "EnableControl - enter"));

    //
    // Retrieve a handle to the control.
    //

    HWND hwndControl;

    hwndControl = GetDlgItem(
        hwndDlg,
        nIDDlgItem
        );

    ASSERT( hwndControl != NULL );

    //
    // Enable or disable the control.
    //

    EnableWindow(
        hwndControl,
        fEnable
        );

    LOG((RTC_TRACE, "EnableControl - exit S_OK"));    
}


//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT UpdateCompleteNumberText(
    IN   HWND              hwndDlg,
    IN   IRTCPhoneNumber * pPhoneNumber
    )
{
    //LOG((RTC_TRACE, "UpdateCompleteNumberText - enter"));

    ASSERT( IsWindow( hwndDlg ) );
    ASSERT( ! IsBadReadPtr( pPhoneNumber, sizeof( IRTCPhoneNumber ) ) );

    //
    // Get the canonical string from the phone number object.
    //

    HRESULT hr;

    BSTR bstrCanonical;

    hr = pPhoneNumber->get_Canonical(
        &bstrCanonical
        );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "UpdateCompleteNumberText - failed to get canonical "
                        "string - exit 0x%08x", hr));

        return hr;
    }

    //
    // Get a handle to the edit box for the
    // complete number.
    //

    SetDlgItemText(
        hwndDlg,
        IDC_EDIT_COMPLETE,
        bstrCanonical
        );

    SysFreeString( bstrCanonical );
    bstrCanonical = NULL;

    //LOG((RTC_TRACE, "UpdateCompleteNumberText - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//

void HandleCountryChange(
    IN   HWND              hwndDlg,
    IN   HWND              hwndCountryCombo,
    IN   IRTCPhoneNumber * pPhoneNumber
    )
{
    //
    // Get the index of the country selection.
    //

    LRESULT lrIndex;

    lrIndex = SendMessage(
        hwndCountryCombo,
        CB_GETCURSEL,
        0,
        0
        );

    //
    // Use the index to get the item data for the new
    // country selection, which contains the country
    // code.
    //

    DWORD dwCountryCode;

    dwCountryCode = (DWORD) SendMessage(
        hwndCountryCombo,
        CB_GETITEMDATA,
        (WPARAM) lrIndex,
        0
        );

    //
    // Tell the phone number object about the new
    // country code. If it fails, we keep the old
    // country code.
    //

    pPhoneNumber->put_CountryCode(
        dwCountryCode
        );

    //
    // Update the UI with the new canonical number.
    //
        
    UpdateCompleteNumberText(
        hwndDlg,
        pPhoneNumber
        );
}
                        
//////////////////////////////////////////////////////////////////////////////
//
// OUT parameter allocated using RtcAlloc, must be freed using RtcFree
//

HRESULT GetStringFromEditBox(
    IN   HWND     hwndDlg,
    IN   int      nIDDlgItem,
    OUT  WCHAR ** pwszEditBoxString
    )
{
    //LOG((RTC_TRACE, "GetStringFromEditBox - enter"));

    //
    // Retrieve a handle to the control.
    //

    HWND hwndEdit;

    hwndEdit = GetDlgItem(
        hwndDlg,
        nIDDlgItem
        );

    ASSERT( hwndEdit != NULL );


    //
    // Get the length of the string from the edit box.
    //

    DWORD dwLength;

    dwLength = (DWORD) SendMessage(
        hwndEdit,
        WM_GETTEXTLENGTH,
        0,
        0
        );

    //
    // Allocate space to store the string.
    //

    ( *pwszEditBoxString ) =
        (WCHAR *) RtcAlloc( ( dwLength + 1 ) * sizeof( WCHAR ) );

    if ( ( *pwszEditBoxString ) == NULL )
    {
        LOG((RTC_ERROR, "GetStringFromEditBox - failed to allocate string "
                        "- exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    //
    // Get the string from the edit box.
    //

    SendMessage(
        hwndEdit,
        WM_GETTEXT,
        dwLength + 1,
        (LPARAM) ( *pwszEditBoxString )
        );

    //LOG((RTC_TRACE, "GetStringFromEditBox - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//

void HandleLabelChange(
    IN   HWND              hwndDlg,
    IN   int               nIDDlgItem,
    IN   IRTCPhoneNumber * pPhoneNumber
    )
{
    HRESULT hr;

    //
    // Get the string from the edit box.
    //

    WCHAR * wszEditBoxString;

    hr = GetStringFromEditBox(
        hwndDlg,
        nIDDlgItem,
        & wszEditBoxString
        );

    if ( FAILED(hr) )
    {
        return;
    }
        
    //
    // Tell the phone number object about the new
    // label.
    //

    hr = pPhoneNumber->put_Label(
        wszEditBoxString
        );

    RtcFree( wszEditBoxString );
}

//////////////////////////////////////////////////////////////////////////////
//
//

void HandleNumberChange(
    IN   HWND              hwndDlg,
    IN   int               nIDDlgItem,
    IN   BOOL              fAreaCode,
    IN   IRTCPhoneNumber * pPhoneNumber
    )
{
    HRESULT hr;

    //
    // Get the string from the edit box.
    //

    WCHAR * wszEditBoxString;

    hr = GetStringFromEditBox(
        hwndDlg,
        nIDDlgItem,
        & wszEditBoxString
        );

    if ( FAILED(hr) )
    {
        return;
    }
        
    //
    // Tell the phone number object about the new
    // area code or local number.
    //

    if ( fAreaCode )
    {
        pPhoneNumber->put_AreaCode(
            wszEditBoxString
            );
    }
    else
    {
        pPhoneNumber->put_Number(
            wszEditBoxString
            );
    }

    RtcFree( wszEditBoxString );

    //
    // Update the UI with the new canonical number.
    //
        
    UpdateCompleteNumberText(
        hwndDlg,
        pPhoneNumber
        );
}


//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT PopulateCountryList(
    IN  HWND        hwndDlg,
    IN  int         nIDDlgItem
    )
{
    LOG((RTC_TRACE, "PopulateCountryList - enter"));

    //
    // Retrieve a handle to the combo box.
    //

    HWND hwndControl;

    hwndControl = GetDlgItem(
        hwndDlg,
        nIDDlgItem
        );

    if ( hwndControl == NULL )
    {
        LOG((RTC_ERROR, "PopulateComboBox - failed to "
                        "get combo box handle - exit E_FAIL"));

        return E_FAIL;
    }

    //
    // Get the LineCountryList structure from TAPI, continually reallocating
    // memory until we give TAPI enough space.
    //

    LONG lResult;

    LPLINECOUNTRYLIST pLineCountryList;

    DWORD dwCurrSize = sizeof(LINECOUNTRYLIST);

    while ( TRUE )
    {
        pLineCountryList = ( LINECOUNTRYLIST * ) RtcAlloc( dwCurrSize );

        if ( pLineCountryList == NULL )
        {
            LOG((RTC_ERROR, "PopulateCountryList - out of memory for country list "
                            "structure - exit E_OUTOFMEMORY"));

            return E_OUTOFMEMORY;
        }

        ZeroMemory(
            pLineCountryList,
            dwCurrSize
            );

        pLineCountryList->dwTotalSize = dwCurrSize;

        lResult = lineGetCountry(
            0,               // we want all countries
            0x00010004,      // highest TAPI version supported by this application
            pLineCountryList // location of structure for output
            );

        //
        // If we don't have enough space, TAPI still sets the return code to
        // zero. Nonzero return code means we have an error we can't recover
        // from.
        //

        if ( lResult != 0 )
        {
            RtcFree( pLineCountryList );
        
            LOG((RTC_ERROR, "PopulateCountryList - lineGetCountry returned %d "
                            "- exit E_FAIL", lResult));

            return E_FAIL;
        }

        //
        // If the structure we allocated was big enough, then stop looping.
        //

        if ( pLineCountryList->dwTotalSize >= pLineCountryList->dwNeededSize )
        {
            break;
        }

        dwCurrSize = pLineCountryList->dwNeededSize;

        RtcFree( pLineCountryList );
    }


    LOG((RTC_TRACE, "PopulateCountryList - country list read successfully"));


    //
    // Loop through the country list and populate the combo box.
    // The string is the country name and the itemdata is the country code.
    //
    // To start off, we set pCurrCountryEntry to point to the first
    // LINECOUNTRYENTRY in pLineCountryList. 
    //

    DWORD dwNumCountries = pLineCountryList->dwNumCountries;

    DWORD dwCurrCountry = 0;

    BYTE * pbFirstCountryEntry =
        ( (BYTE *) pLineCountryList ) + pLineCountryList->dwCountryListOffset;

    LINECOUNTRYENTRY * pCurrCountryEntry =
        (LINECOUNTRYENTRY *) pbFirstCountryEntry;

    for ( dwCurrCountry = 0; dwCurrCountry < dwNumCountries; )
    {
        //
        // Obtain from the current country list entry the offset of the
        // string for the name of the current country. The offset is from
        // the beginning of the country list structure.
        //

        DWORD   dwNameOffset   = pCurrCountryEntry->dwCountryNameOffset;

        //
        // The offset is in bytes. Add the offset to the start of the line
        // country list structure to obtain the location of the string.
        //

        BYTE  * pbCurrCountryString = (BYTE *) pLineCountryList + dwNameOffset;

        //
        // Set the display string to the country name.
        //

        LRESULT lrIndex;

        lrIndex = SendMessage(
            hwndControl,
            CB_ADDSTRING,
            0,
            (LPARAM) pbCurrCountryString
            );

        //
        // Set the itemdata to the country code.
        //

        SendMessage(
            hwndControl,
            CB_SETITEMDATA,
            lrIndex,
            MAKELPARAM(pCurrCountryEntry->dwCountryCode, pCurrCountryEntry->dwCountryID)
            );

        //
        // Advance to the next country. Since pCurrCountryEntry points
        // to a LINECOUNTRYENTRY and LINECOUNTRYENTRY structures are
        // fixed-size, we just increment the pointer.
        //

        dwCurrCountry++;
        pCurrCountryEntry++;
    }

    //
    // Now we have our list of strings, so we don't need the country list
    // any more.
    //

    RtcFree( pLineCountryList );

    LOG((RTC_TRACE, "PopulateCountryList - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//

INT_PTR CALLBACK AddCallFromDialogProc(
    IN  HWND   hwndDlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
{
    //
    // Static local that stores the core's representation of the phone number
    // we are editing. This dialog creates the phone number object, so this
    // dialog is responsible for releasing it.
    //

    static IRTCPhoneNumber * s_pPhoneNumber = NULL;


    //
    // Handling for various window messages.
    //

    HRESULT hr;
    
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            //
            // Get the core client object pointer.
            //

            s_pPhoneNumber = (IRTCPhoneNumber *) lParam;    

            //
            // Populate country list.
            //

            hr = PopulateCountryList(
                hwndDlg,
                IDC_COMBO_COUNTRY
                );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "AddCallFromDialogProc - PopulateCountryList "
                                "failed - exit 0x%08x", hr));

                EndDialog( hwndDlg, (LPARAM) hr );
            }

            //
            // Populate phone number.
            //

            hr = PopulatePhoneNumberEditBoxes(
                hwndDlg, 
                s_pPhoneNumber
                );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "AddCallFromDialogProc - PopulatePhoneNumberEditBoxes "
                                "failed - exit 0x%08x", hr));

                EndDialog( hwndDlg, (LPARAM) hr );
            }

            //
            // Populate label
            //

            BSTR bstrLabel;

            hr = s_pPhoneNumber->get_Label( &bstrLabel );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "AddCallFromDialogProc - failed to "
                                "retrieve label from phone number object - "
                                "0x%08x - not populating label control", hr));
            }
            else
            {
                SetDlgItemText(
                    hwndDlg,
                    IDC_EDIT_LABEL,
                    bstrLabel
                    );
        
                SysFreeString( bstrLabel );
            }

            return TRUE;
        }

        case WM_COMMAND:

            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                {
                    //
                    // Clean up and end the dialog.
                    //

                    EndDialog( hwndDlg, (LPARAM) S_OK );

                    return TRUE;
                }
                
                case IDCANCEL:
                {
                    //
                    // Clean up and end the dialog.
                    //

                    EndDialog( hwndDlg, (LPARAM) E_ABORT );

                    return TRUE;
                }

                case IDC_COMBO_COUNTRY:
                {

                    switch ( HIWORD( wParam ) )
                    {
                        case CBN_SELCHANGE:
                        {
                            if ( s_pPhoneNumber != NULL )
                            {
                                HandleCountryChange(
                                    hwndDlg,
                                    (HWND) lParam,
                                    s_pPhoneNumber
                                    );
                            }
                        
                            return TRUE;
                        }
                        
                        default:
                            break;
                    }

                    break;
                }

                case IDC_EDIT_AREA_CODE:
                {
                    if ( s_pPhoneNumber != NULL )
                    {
                        HandleNumberChange(
                            hwndDlg,
                            LOWORD( wParam ),
                            TRUE,   // area code
                            s_pPhoneNumber
                            );
                    }
                
                    return TRUE;
                }

                case IDC_EDIT_LOCAL_NUMBER:
                {
                    if ( s_pPhoneNumber != NULL )
                    {
                        HandleNumberChange(
                            hwndDlg,
                            LOWORD( wParam ),
                            FALSE,  // not area code
                            s_pPhoneNumber
                            );
                    }
                
                    return TRUE;
                }

                case IDC_EDIT_LABEL:
                {
                    if ( s_pPhoneNumber != NULL )
                    {
                        HandleLabelChange(
                            hwndDlg,
                            LOWORD( wParam ),
                            s_pPhoneNumber
                            );
                    }

                    return TRUE;
                }

                default:
                    break;
            }    
        
        case WM_CONTEXTMENU:

            ::WinHelp(
                (HWND)wParam,
                g_szDllContextHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)g_dwHelpArrayAddCallFrom);

            return TRUE;

            break;

        case WM_HELP:


            ::WinHelp(
                (HWND)(((HELPINFO *)lParam)->hItemHandle),
                g_szDllContextHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)g_dwHelpArrayAddCallFrom);

            return TRUE;

            break;

        default:
            break;
    }    

    //
    // We fell through, so this procedure did not handle the message.
    //

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowAddCallFromDialog(
    IN   HWND         hwndParent,
    IN   IRTCPhoneNumber * pPhoneNumber
    )
{
    //
    // Call the dialog box procedure.
    //

    INT_PTR ipReturn;

    ipReturn = DialogBoxParam(
        _Module.GetResourceInstance(),
        (LPCTSTR) IDD_DIALOG_ADD_CALL_FROM_NUMBER,
        hwndParent,
        (DLGPROC) AddCallFromDialogProc,
        (LPARAM) pPhoneNumber // LPARAM == INT_PTR
        );

    return (HRESULT) ipReturn;
}              

//////////////////////////////////////////////////////////////////////////////
//
//

INT_PTR CALLBACK EditCallFromListDialogProc(
    IN  HWND   hwndDlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
{
    //
    // Handling for various window messages.
    //

    HRESULT hr;
    
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {

            //
            // Set up the call from list.
            //

            hr = PopulateCallFromList(
                hwndDlg,
                IDC_LIST_CALL_FROM,
                FALSE, // not a combo box
                NULL
                );


            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "EditCallFromListDialogProc - "
                                "PopulateCallFromList failed - exit 0x%08x",
                                hr));

                EndDialog( hwndDlg, (LPARAM) hr );
            }

            //
            // Select the first item if it exists
            //

            HWND hwndControl;
    
            hwndControl = GetDlgItem(
                hwndDlg,
                IDC_LIST_CALL_FROM
                );

            LRESULT lResult;

            lResult = SendMessage(
                        hwndControl,
                        LB_SETCURSEL,
                        0,
                        0
                        );

            EnableControl(
                        hwndDlg,
                        IDC_BUTTON_MODIFY,
                        (lResult !=  LB_ERR)
                        );

            EnableControl(
                        hwndDlg,
                        IDC_BUTTON_DELETE,
                        (lResult !=  LB_ERR)
                        );

            return TRUE;
        }

        case WM_DESTROY:
        {
            CleanupListOrComboBoxInterfaceReferences(
                    hwndDlg,
                    IDC_LIST_CALL_FROM,
                    FALSE // not a combo box
                    );
        }

        case WM_COMMAND:
        {
            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                {                   
                    EndDialog( hwndDlg, (LPARAM) S_OK );

                    return TRUE;
                }
                
                case IDCANCEL:
                {
                    EndDialog( hwndDlg, (LPARAM) E_ABORT );

                    return TRUE;
                }

                case IDC_BUTTON_ADD:
                {
                    IRTCPhoneNumber * pNumber;
                
                    hr = CreatePhoneNumber( & pNumber );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "EditCallFromListDialogProc - "
                            "CreatePhoneNumber failed 0x%lx", hr));
                    }
                    else                    
                    {
                        pNumber->put_CountryCode( 1 );
                        pNumber->put_AreaCode( L"" );
                        pNumber->put_Number( L"" );

                        hr = ShowAddCallFromDialog(
                            hwndDlg,
                            pNumber
                            );

                        if ( SUCCEEDED(hr) )
                        {
                            hr = StoreLocalPhoneNumber( pNumber, FALSE );

                            if ( FAILED(hr) )
                            {
                                LOG((RTC_ERROR, "EditCallFromListDialogProc - "
                                    "StoreLocalPhoneNumber failed 0x%lx", hr));
                            }
                            else
                            {
                                hr = PopulateCallFromList(
                                    hwndDlg,
                                    IDC_LIST_CALL_FROM,
                                    FALSE, // not a combo box
                                    NULL
                                    );

                                //
                                // We've just clobbered the
                                // last selection, so select the first item if
                                // it exists, otherwise gray out the buttons
                                // that require a selection.
                                //

                                HWND hwndControl;
    
                                hwndControl = GetDlgItem(
                                    hwndDlg,
                                    IDC_LIST_CALL_FROM
                                    );

                                LRESULT lResult;

                                lResult = SendMessage(
                                            hwndControl,
                                            LB_SETCURSEL,
                                            0,
                                            0
                                            );

                                EnableControl(
                                            hwndDlg,
                                            IDC_BUTTON_MODIFY,
                                            (lResult !=  LB_ERR)
                                            );

                                EnableControl(
                                            hwndDlg,
                                            IDC_BUTTON_DELETE,
                                            (lResult !=  LB_ERR)
                                            );
                            }
                        }

                        pNumber->Release();
                    }
                
                    return TRUE;
                }

                case IDC_BUTTON_DELETE:
                {
                    IRTCPhoneNumber * pNumber;
                
                    hr = GetCallFromListSelection(
                        hwndDlg,
                        IDC_LIST_CALL_FROM,
                        FALSE,    // use list box, not combo box
                        & pNumber // does not addref
                        );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "EditCallFromListDialogProc - "
                            "GetCallFromListSelection failed 0x%lx", hr));
                    }
                    else 
                    {
                        hr = DeleteLocalPhoneNumber( pNumber );
                    
                        if ( FAILED(hr) )
                        {
                            LOG((RTC_ERROR, "EditCallFromListDialogProc - "
                                "DeleteLocalPhoneNumber failed 0x%lx", hr));
                        }
                        else
                        {
                            hr = PopulateCallFromList(
                                hwndDlg,
                                IDC_LIST_CALL_FROM,
                                FALSE, // not a combo box
                                NULL
                                );                           

                            //
                            // We've just clobbered the
                            // last selection, so select the first item if
                            // it exists, otherwise gray out the buttons
                            // that require a selection.
                            //

                            HWND hwndControl;
    
                            hwndControl = GetDlgItem(
                                hwndDlg,
                                IDC_LIST_CALL_FROM
                                );

                            LRESULT lResult;

                            lResult = SendMessage(
                                        hwndControl,
                                        LB_SETCURSEL,
                                        0,
                                        0
                                        );

                            EnableControl(
                                        hwndDlg,
                                        IDC_BUTTON_MODIFY,
                                        (lResult !=  LB_ERR)
                                        );

                            EnableControl(
                                        hwndDlg,
                                        IDC_BUTTON_DELETE,
                                        (lResult !=  LB_ERR)
                                        );

                            SetFocus(hwndDlg);
                        }
                    }
                
                    return TRUE;
                }

                case IDC_BUTTON_MODIFY:
                {
                    IRTCPhoneNumber * pNumber;
                
                    hr = GetCallFromListSelection(
                        hwndDlg,
                        IDC_LIST_CALL_FROM,
                        FALSE,    // use list box, not combo box
                        & pNumber // does not addref
                        );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "EditCallFromListDialogProc - "
                            "GetCallFromListSelection failed 0x%lx", hr));
                    }
                    else                    
                    {     
                        BSTR bstrOriginalLabel = NULL;

                        hr = pNumber->get_Label( &bstrOriginalLabel );

                        if ( SUCCEEDED(hr) )
                        {
                            hr = ShowAddCallFromDialog(
                                hwndDlg,
                                pNumber
                                );

                            if ( SUCCEEDED(hr) )
                            {
                                BSTR bstrNewLabel = NULL;

                                hr = pNumber->get_Label( &bstrNewLabel );

                                if ( SUCCEEDED(hr) )
                                {
                                    if ( wcscmp(bstrOriginalLabel, bstrNewLabel) != 0 )
                                    {
                                        //
                                        // Entry was renamed, delete the old entry
                                        //

                                        IRTCPhoneNumber * pOriginalNumber = NULL;

                                        hr = CreatePhoneNumber( &pOriginalNumber );

                                        if ( SUCCEEDED(hr) )
                                        {
                                            hr = pOriginalNumber->put_Label( bstrOriginalLabel );

                                            if ( SUCCEEDED(hr) )
                                            {
                                                hr = DeleteLocalPhoneNumber( pOriginalNumber );

                                                if ( FAILED(hr) )
                                                {
                                                    LOG((RTC_ERROR, "EditCallFromListDialogProc - "
                                                        "DeleteLocalPhoneNumber failed 0x%lx", hr));
                                                }
                                            }

                                            pOriginalNumber->Release();
                                        }
                                    }

                                    SysFreeString( bstrNewLabel );
                                    bstrNewLabel = NULL;
                                }

                                hr = StoreLocalPhoneNumber( pNumber, TRUE );

                                if ( FAILED(hr) )
                                {
                                    LOG((RTC_ERROR, "EditCallFromListDialogProc - "
                                        "StoreLocalPhoneNumber failed 0x%lx", hr));
                                }
                                else
                                {
                                    hr = PopulateCallFromList(
                                        hwndDlg,
                                        IDC_LIST_CALL_FROM,
                                        FALSE, // not a combo box
                                        NULL
                                        );

                                    //
                                    // We've just clobbered the
                                    // last selection, so select the first item if
                                    // it exists, otherwise gray out the buttons
                                    // that require a selection.
                                    //

                                    HWND hwndControl;
    
                                    hwndControl = GetDlgItem(
                                        hwndDlg,
                                        IDC_LIST_CALL_FROM
                                        );

                                    LRESULT lResult;

                                    lResult = SendMessage(
                                                hwndControl,
                                                LB_SETCURSEL,
                                                0,
                                                0
                                                );

                                    EnableControl(
                                                hwndDlg,
                                                IDC_BUTTON_MODIFY,
                                                (lResult !=  LB_ERR)
                                                );

                                    EnableControl(
                                                hwndDlg,
                                                IDC_BUTTON_DELETE,
                                                (lResult !=  LB_ERR)
                                                );

                                    SetFocus(hwndDlg);
                                }
                            }

                            SysFreeString( bstrOriginalLabel );
                            bstrOriginalLabel = NULL;
                        }
                    }

                    return TRUE;
                }

                case IDC_LIST_CALL_FROM:
                {
                    switch ( HIWORD( wParam ) )
                    {
                        case CBN_SELCHANGE:
                        {
                            EnableControl(
                                hwndDlg,
                                IDC_BUTTON_MODIFY,
                                TRUE // enable
                                );

                            EnableControl(
                                hwndDlg,
                                IDC_BUTTON_DELETE,
                                TRUE // enable
                                );
                            
                            return TRUE;
                        }
                        
                        default:
                            break;
                    }

                    break;
                }

                default:
                    break;
                    
            } // switch ( LOWORD( wParam ) )    

        } // case WM_COMMAND:
        case WM_CONTEXTMENU:

            ::WinHelp(
                (HWND)wParam,
                g_szDllContextHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)g_dwHelpArrayCallFromNumbers);

            return TRUE;

            break;

        case WM_HELP:


            ::WinHelp(
                (HWND)(((HELPINFO *)lParam)->hItemHandle),
                g_szDllContextHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)g_dwHelpArrayCallFromNumbers);

            return TRUE;

            break;

        default:
            break;

    } // switch ( uMsg )

    //
    // We fell through, so this procedure did not handle the message.
    //

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowEditCallFromListDialog(
    IN   HWND         hwndParent
    )
{
    //
    // Call the dialog box procedure.
    //

    INT_PTR ipReturn;

    ipReturn = DialogBoxParam(
        _Module.GetResourceInstance(),
        (LPCTSTR) IDD_DIALOG_CALL_FROM_NUMBERS,
        hwndParent,
        (DLGPROC) EditCallFromListDialogProc,
        NULL
        );

    return (HRESULT) ipReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//

INT_PTR CALLBACK EditServiceProviderListDialogProc(
    IN  HWND   hwndDlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
{
    //
    // Static pointer to core client interface.
    //

    static IRTCClient * s_pClient = NULL;

    //
    // Handling for various window messages.
    //

    HRESULT hr;
    
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            //
            // Save a pointer to the core client interface.
            //

            s_pClient = (IRTCClient *) lParam;

            //
            // Set up the call from list.
            //

            hr = PopulateServiceProviderList(
                hwndDlg,
                s_pClient,
                IDC_LIST_SERVICE_PROVIDER,
                FALSE, // not a combo box
                NULL,
                NULL,
                0xF,
                0
                );


            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "EditProfilesListDialogProc - "
                                "PopulateProfilesList failed - exit 0x%08x",
                                hr));

                EndDialog( hwndDlg, (LPARAM) hr );
            }

            //
            // Select the first item if it exists
            //

            HWND hwndControl;
    
            hwndControl = GetDlgItem(
                hwndDlg,
                IDC_LIST_SERVICE_PROVIDER
                );

            LRESULT lResult;

            lResult = SendMessage(
                        hwndControl,
                        LB_SETCURSEL,
                        0,
                        0
                        );

            EnableControl(
                        hwndDlg,
                        IDC_BUTTON_DELETE,
                        (lResult !=  LB_ERR)
                        );

            return TRUE;
        }

        case WM_DESTROY:
        {
            CleanupListOrComboBoxInterfaceReferences(
                    hwndDlg,
                    IDC_LIST_SERVICE_PROVIDER,
                    FALSE // not a combo box
                    );
        }

        case WM_COMMAND:
        {
            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                {
                    EndDialog( hwndDlg, (LPARAM) S_OK );

                    return TRUE;
                }
                
                case IDCANCEL:
                {
                    EndDialog( hwndDlg, (LPARAM) E_ABORT );

                    return TRUE;
                }

                case IDC_BUTTON_DELETE:
                {
                    IRTCProfile * pProfile;
                
                    hr = GetServiceProviderListSelection(
                        hwndDlg,
                        IDC_LIST_SERVICE_PROVIDER,
                        FALSE,    // use list box, not combo box
                        & pProfile // does not addref
                        );

                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // Delete profile from the prov store
                        //

                        BSTR bstrKey;

                        hr = pProfile->get_Key( &bstrKey );

                        if ( SUCCEEDED(hr) )
                        {
                            IRTCProvStore * pProvStore;

                            hr = CoCreateInstance(
                              CLSID_RTCProvStore,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IRTCProvStore,
                              (LPVOID *)&pProvStore
                             );

                            if ( SUCCEEDED(hr) )
                            {
                                pProvStore->DeleteProvisioningProfile( bstrKey );

                                pProvStore->Release();
                            }

                            SysFreeString( bstrKey );
                        }

                        //
                        // Disable profile
                        //

                        IRTCClientProvisioning * pProv = NULL;

                        hr = s_pClient->QueryInterface(
                                           IID_IRTCClientProvisioning,
                                           (void **)&pProv
                                          );                      

                        if ( SUCCEEDED(hr) )
                        {
                            hr = pProv->DisableProfile( pProfile );

                            pProv->Release();                         

                            if ( SUCCEEDED(hr) )
                            {                              
                                // Delete the listbox entry

                                HWND hwndControl;

                                hwndControl = GetDlgItem(
                                    hwndDlg,
                                    IDC_LIST_SERVICE_PROVIDER
                                    );

                                LRESULT lrIndex;

                                lrIndex = SendMessage(
                                    hwndControl,
                                    LB_GETCURSEL,
                                    0,
                                    0
                                    );

                                if ( lrIndex !=  LB_ERR )
                                {
                                    SendMessage(
                                        hwndControl,
                                        LB_DELETESTRING,
                                        (WPARAM) lrIndex,
                                        0
                                        );
                                }

                                // Release the reference

                                pProfile->Release();

                                //
                                // We've just clobbered the
                                // last selection, so select the first item if
                                // it exists, otherwise gray out the buttons
                                // that require a selection.
                                //

                                LRESULT lResult;

                                lResult = SendMessage(
                                            hwndControl,
                                            LB_SETCURSEL,
                                            0,
                                            0
                                            );

                                EnableControl(
                                            hwndDlg,
                                            IDC_BUTTON_DELETE,
                                            (lResult !=  LB_ERR)
                                            );

                                SetFocus(hwndDlg);
                            }                         
                        }
                    }
                
                    return TRUE;
                }

                case IDC_LIST_SERVICE_PROVIDER:
                {
                    switch ( HIWORD( wParam ) )
                    {
                        case CBN_SELCHANGE:
                        {
                            EnableControl(
                                hwndDlg,
                                IDC_BUTTON_DELETE,
                                TRUE // enable
                                );
                            
                            return TRUE;
                        }
                        
                        default:
                            break;
                    }

                    break;
                }

                default:
                    break;
                    
            } // switch ( LOWORD( wParam ) )    

        } // case WM_COMMAND:
        
        case WM_CONTEXTMENU:

            ::WinHelp(
                (HWND)wParam,
                g_szDllContextHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)g_dwHelpArrayServiceProviders);

            return TRUE;

            break;

        case WM_HELP:


            ::WinHelp(
                (HWND)(((HELPINFO *)lParam)->hItemHandle),
                g_szDllContextHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)g_dwHelpArrayServiceProviders);

            return TRUE;

            break;


        default:
            break;

    } // switch ( uMsg )

    //
    // We fell through, so this procedure did not handle the message.
    //

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowEditServiceProviderListDialog(
    IN   HWND         hwndParent,
    IN   IRTCClient * pClient
    )
{
    //
    // Call the dialog box procedure.
    //

    INT_PTR ipReturn;

    ipReturn = DialogBoxParam(
        _Module.GetResourceInstance(),
        (LPCTSTR) IDD_DIALOG_SERVICE_PROVIDERS,
        hwndParent,
        (DLGPROC) EditServiceProviderListDialogProc,
        (LPARAM) pClient // LPARAM == INT_PTR
        );

    return (HRESULT) ipReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// PopulatePhoneNumberEditBoxes()
// helper function
//

HRESULT PopulatePhoneNumberEditBoxes(
    IN   HWND              hwndDlg,
    IN   IRTCPhoneNumber * pPhoneNumber
    )
{
    LOG((RTC_TRACE, "PopulatePhoneNumberEditBoxes - enter"));

    HRESULT hr;

    //
    // Populate selected country from default destination phone number.
    // Step 1: get country code value from default dest number
    //

    DWORD dwCountryCode;

    hr = pPhoneNumber->get_CountryCode( & dwCountryCode );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "PopulatePhoneNumberEditBoxes - failed to "
                        "retrieve country code from phone number object - "
                        "exit 0x%08x", hr));

        return hr;
    }

    //
    // Step 2: get handle to country list combo box
    //

    HWND hwndCountryList;

    hwndCountryList = GetDlgItem(
        hwndDlg,
        IDC_COMBO_COUNTRY
        );

    if ( hwndCountryList == NULL )
    {
        LOG((RTC_ERROR, "PopulatePhoneNumberEditBoxes - failed to "
                        "get combo box handle - exit E_FAIL"));

        return E_FAIL;
    }

    //
    // Step 3: Determine how many items are in the combo box
    //

    DWORD dwTotalItems;

    dwTotalItems = (DWORD) SendMessage(
        hwndCountryList,
        CB_GETCOUNT,
        0,
        0
        );

    //
    // Step 4: Loop over the combo box items
    // For each item, find out its associated data value
    // If the data matches the country code we're looking for
    // then set that item to be the selected country and stop the loop
    //

    DWORD dwIndex;

    for ( dwIndex = 0; dwIndex < dwTotalItems ; dwIndex++ )
    {
        LRESULT lrThisCode;

        lrThisCode = SendMessage(
            hwndCountryList,
            CB_GETITEMDATA,
            dwIndex,
            0
            );

        if ( HIWORD(dwCountryCode) == 0 )
        {
            //
            // No TAPI country ID, give it our best shot and
            // match on the country code itself.
            //

            if ( LOWORD(lrThisCode) == LOWORD(dwCountryCode) )
            {
                //
                // If country code is "1", choose the United States
                // which is TAPI country ID "1"
                //

                if ( (LOWORD(lrThisCode) == 1) && ( HIWORD(lrThisCode) != 1 ) )
                {
                    continue;
                }
        
                SendMessage(
                    hwndCountryList,
                    CB_SETCURSEL,
                    dwIndex,
                    0
                    );
            
                break;
            }
        }
        else
        {
            //
            // Match the TAPI country ID
            //

            if ( HIWORD(lrThisCode) == HIWORD(dwCountryCode) )
            {
                SendMessage(
                    hwndCountryList,
                    CB_SETCURSEL,
                    dwIndex,
                    0
                    );
            
                break;
            }
        }
    }

    //
    // Populate area code.
    //

    BSTR bstrAreaCode;

    hr = pPhoneNumber->get_AreaCode( &bstrAreaCode );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "PopulatePhoneNumberEditBoxes - failed to "
                        "retrieve area code from phone number object - "
                        "0x%08x - not populating area code control", hr));
    }
    else
    {
        SetDlgItemText(
            hwndDlg,
            IDC_EDIT_AREA_CODE,
            bstrAreaCode
            );
            
        SysFreeString( bstrAreaCode );
    }

    //
    // Populate local number.
    //

    BSTR bstrLocalNumber;

    hr = pPhoneNumber->get_Number( &bstrLocalNumber );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "PopulatePhoneNumberEditBoxes - failed to "
                        "retrieve local number from phone number object - "
                        "exit 0x%08x", hr));

        return hr;
    }
    
    SetDlgItemText(
        hwndDlg,
        IDC_EDIT_LOCAL_NUMBER,
        bstrLocalNumber
        );

    SysFreeString( bstrLocalNumber );

    //
    // Populate canonical phone number from default destination phone number.
    //

    UpdateCompleteNumberText(
        hwndDlg,
        pPhoneNumber
        );

    LOG((RTC_TRACE, "PopulatePhoneNumberEditBoxes - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// PopulateDialByPhoneNumberDialog()
// helper function
//

HRESULT PopulateDialByPhoneNumberDialog(
    IN   HWND              hwndDlg,
    IN   IRTCPhoneNumber * pDestPhoneNumber
    )
{
    LOG((RTC_TRACE, "PopulateDialByPhoneNumberDialog - enter"));

    HRESULT hr;

    //
    // Populate country list.
    //

    hr = PopulateCountryList(
        hwndDlg,
        IDC_COMBO_COUNTRY
        );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "PopulateDialByPhoneNumberDialog - "
                        "PopulateCountryList failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Populate phone number.
    //

    hr = PopulatePhoneNumberEditBoxes(
        hwndDlg, 
        pDestPhoneNumber
        );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "PopulateDialByPhoneNumberDialog - "
                        "PopulatePhoneNumberEditBoxes failed - exit 0x%08x", hr));

        return hr;
    }

    LOG((RTC_TRACE, "PopulateDialByPhoneNumberDialog - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// PopulateCallInfoDialog()
// helper function
//

HRESULT PopulateCallInfoDialog(
    IN   HWND              hwndDlg,
    IN   IRTCClient      * pClient,
    IN   BSTR              bstrDefaultProfileKey, 
    IN   long              lSessionMask,
    IN   BOOL              fEnumerateProfiles,
    IN   IRTCProfile     * pOneShotProfile,
    IN   BSTR              bstrDefaultCallFrom,
    IN   BOOL              fCallFromEditable
    )
{
    LOG((RTC_TRACE, "PopulateCallInfoDialog - enter"));

    HRESULT hr;

    if ( fEnumerateProfiles == TRUE )
    {
        //
        // Populate service provider list.
        //

        hr = PopulateServiceProviderList(
            hwndDlg,
            pClient,
            IDC_COMBO_SERVICE_PROVIDER,
            TRUE,
            pOneShotProfile,
            bstrDefaultProfileKey,
            fEnumerateProfiles ? lSessionMask : 0,
            fEnumerateProfiles && (lSessionMask & RTCSI_PC_TO_PC)
                               ? IDS_NONE : 0
            );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "PopulateCallInfoDialog - "
                            "PopulateServiceProviderList failed - exit 0x%08x",
                            hr));

            return hr;
        }

        //
        // Determine the number of items that ended up in the list.
        //

        DWORD dwNumItems;

        dwNumItems = (DWORD) SendMessage(
            GetDlgItem(hwndDlg, IDC_COMBO_SERVICE_PROVIDER),
            CB_GETCOUNT,
            0,
            0
            );

        //
        // Return an error if the list ended up empty, because it's
        // impossible to make this call without an ITSP.
        //

        if ( dwNumItems == 0 )
        {
            LOG((RTC_ERROR, "PopulateCallInfoDialog - failed to "
                            "get at least one profile - "
                            "showing message box - exit E_FAIL"));

            DisplayMessage(
                _Module.GetResourceInstance(),
                hwndDlg,
                IDS_ERROR_NO_PROVIDERS,
                IDS_APPNAME
                );

            return E_FAIL;
        }
    }

    if ( fCallFromEditable == TRUE )
    {
        //
        // Populate "call from" list.
        //

        hr = PopulateCallFromList(
            hwndDlg,
            IDC_COMBO_CALL_FROM,
            TRUE, // this is a combo box
            bstrDefaultCallFrom
            );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "PopulateCallInfoDialog - "
                            "PopulateCallFromList failed - exit 0x%08x", hr));

            return hr;
        }

        //
        // Enable/Disable various fields in Call From Group
        //    Select the Computer option first
        //

        if ( (bstrDefaultCallFrom == NULL) ||
             (*bstrDefaultCallFrom == L'\0') )
        {
            SendDlgItemMessage(
                hwndDlg,
                IDC_RADIO_FROM_COMPUTER,
                BM_SETCHECK,
                BST_CHECKED,
                0);
        }
        else
        {
            SendDlgItemMessage(
                hwndDlg,
                IDC_RADIO_FROM_PHONE,
                BM_SETCHECK,
                BST_CHECKED,
                0);
        }

        EnableDisableCallGroupElements(
            hwndDlg,
            pClient,
            lSessionMask,
            IDC_RADIO_FROM_COMPUTER,
            IDC_RADIO_FROM_PHONE,
            IDC_COMBO_CALL_FROM,
            IDC_COMBO_SERVICE_PROVIDER,
            NULL,
            NULL,
            NULL,
            NULL
            );    
    }

    LOG((RTC_TRACE, "PopulateCallInfoDialog - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// Returns S_OK if all the info to be returned is available.
// Returns an error if anything is unavailable.
//
// Each OUT parameter can be NULL, in which case that info is not returned.
//
//

HRESULT GetPhoneNumberDialogResult(
    IN   HWND           hwndDlg,
    OUT  IRTCProfile ** ppProfileChosen,
    OUT  BSTR         * ppDestPhoneNrChosen,
    OUT  BSTR         * ppFromAddressChosen
    )
{
    LOG((RTC_TRACE, "GetPhoneNumberDialogResult - enter"));

    ASSERT( IsWindow( hwndDlg ) );

    HRESULT hr; 

    //
    // Determine which profile was chosen.
    //

    if ( ppProfileChosen != NULL )
    {
        HWND hwndCombo;

        hwndCombo = GetDlgItem(
            hwndDlg,
            IDC_COMBO_SERVICE_PROVIDER
            );
    
        LRESULT lrIndex;

        lrIndex = SendMessage(
            hwndCombo,
            CB_GETCURSEL,
            0,
            0
            );

        if ( lrIndex >= 0 )
        {
            IRTCProfile * pProfile;

            pProfile = (IRTCProfile *) SendMessage(
                hwndCombo,
                CB_GETITEMDATA,
                (WPARAM) lrIndex,
                0
                );

            if (pProfile != NULL)
            {
                pProfile->AddRef();
            }

            (*ppProfileChosen) = pProfile;
        }
        else
        {
            (*ppProfileChosen) = NULL;
        }
    }

    //
    // Determine what destination address was chosen.
    //

    if ( ppDestPhoneNrChosen != NULL )
    {
        WCHAR * wszEditBoxString;

        hr = GetStringFromEditBox(
            hwndDlg,
            IDC_EDIT_COMPLETE,
            & wszEditBoxString
            );

        if ( FAILED(hr) )
        {
            LOG((RTC_INFO, "GetPhoneNumberDialogResult - "
                "cannot get dest addr string - exit 0x%08x", hr));

            if ( ppProfileChosen != NULL )
            {
                (*ppProfileChosen)->Release();
                (*ppProfileChosen) = NULL;
            }

            return hr;
        }

        (*ppDestPhoneNrChosen) = SysAllocString( wszEditBoxString );

        RtcFree( wszEditBoxString );
    }
 

    //
    // Determine what source address was chosen.
    //

    if ( ppFromAddressChosen != NULL )
    {
        HWND    hwndRbPhone = GetDlgItem(hwndDlg, IDC_RADIO_FROM_PHONE);

        if (SendMessage(
                hwndRbPhone,
                BM_GETCHECK,
                0,
                0) == BST_CHECKED)
        {
            //
            // The call from phone radio button was checked
            //

            IRTCPhoneNumber * pNumber;

            hr = GetCallFromListSelection(
                hwndDlg,
                IDC_COMBO_CALL_FROM,
                TRUE, // use combo box, not list box
                & pNumber
                );

            if ( FAILED(hr) )
            {
                LOG((RTC_INFO, "GetPhoneNumberDialogResult - "
                    "cannot get from addr selection - exit 0x%08x", hr));

                if ( ppProfileChosen != NULL )
                {
                    (*ppProfileChosen)->Release();
                    (*ppProfileChosen) = NULL;
                }

                if ( ppDestPhoneNrChosen != NULL )
                {
                    SysFreeString( (*ppDestPhoneNrChosen) );
                    (*ppDestPhoneNrChosen) = NULL;
                }

                return hr;
            }

            hr = pNumber->get_Canonical( ppFromAddressChosen );

            if ( FAILED( hr ) )
            {
                LOG((RTC_INFO, "GetPhoneNumberDialogResult - "
                    "cannot canonical from address - exit 0x%08x", hr));

                if ( ppProfileChosen != NULL )
                {
                    (*ppProfileChosen)->Release();
                    (*ppProfileChosen) = NULL;
                }

                if ( ppDestPhoneNrChosen != NULL )
                {
                    SysFreeString( (*ppDestPhoneNrChosen) );
                    (*ppDestPhoneNrChosen) = NULL;
                }

                return hr;
            }
        }
        else
        {
            //
            // The call from computer radio button was checked
            //

            (*ppFromAddressChosen) = NULL;
        }
    }

    LOG((RTC_TRACE, "GetPhoneNumberDialogResult - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// This structure is used to pass params when calling the Win32
// DialogBoxParam() function to create this dialog box.
//

typedef struct
{
    IN   IRTCClient   * pClient;
    IN   long           lSessionMask;
    IN   BOOL           bEnumerateProfiles;
    IN   BOOL           bProfileEditable;
    IN   IRTCProfile  * pOneShotProfile;
    IN   BSTR	        pDestAddress;
    IN   BSTR           pInstructions;
    OUT  IRTCProfile ** ppProfileChosen;
    OUT  BSTR         * ppFromAddressChosen;

} DialNeedCallInfoDialogProcParams;

//////////////////////////////////////////////////////////////////////////////
//
// DialNeedCallInfoDialogProc()
// helper function
//
// This is the dialog procedure for the phone number dialing dialog box.
//
// Parameters:
//    IN  hwndDlg -- the HWND of this dialog box
//    IN  uMsg    -- identifies the message being sent to this window
//    IN  wParam  -- first parameter
//    IN  lParam  -- second parameter
//

INT_PTR CALLBACK DialNeedCallInfoDialogProc(
    IN  HWND   hwndDlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
{
    //
    // Static locals for saving out parameters passed in on WM_INITDIALOG for
    // use when user presses OK.
    //

    static IRTCProfile ** s_ppProfileChosen     = NULL;
    static BSTR         * s_ppFromAddressChosen = NULL;

    //
    // Static local pointer to core client interface, used to update phone
    // numbers in call from list. This dialog does not addref the client
    // interface pointer, so it must not release it either.
    //

    static IRTCClient * s_pClient = NULL;

    static long         s_lSessionMask = 0;
    static BOOL         s_bEnumerateProfiles = FALSE;

    //
    // Handling for various window messages.
    //

    HRESULT hr;
    
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            //
            // Retrieve the params structure from the message.
            //
            
            DialNeedCallInfoDialogProcParams * pstParams;

            pstParams = (DialNeedCallInfoDialogProcParams *) lParam;

            //
            // Save the IRTCClient pointer for later updates to the
            // call from list.
            //

            s_pClient = pstParams->pClient;

            // the mask is both a vertical (filters the profiles)
            // and an horizontal one (filters the capabilities)

            s_lSessionMask = pstParams->lSessionMask;
            s_bEnumerateProfiles = pstParams->bEnumerateProfiles;

            //
            // Since the user cannot edit the dest address, just fill
            // in the edit box with the number passed in
            //
            SetDlgItemText(hwndDlg, IDC_EDIT_COMPLETE, pstParams->pDestAddress);

            //
            // Enable the button for editing the list and the list
            //

            EnableControl(hwndDlg, IDC_BUTTON_EDIT_SERVICE_PROVIDER_LIST, pstParams->bProfileEditable);                  
            EnableControl(hwndDlg, IDC_COMBO_SERVICE_PROVIDER, pstParams->bProfileEditable);
            
            // set the instructions
            if(pstParams->pInstructions)
            {
                SetDlgItemText(hwndDlg, IDC_STATIC_INSTRUCTIONS, pstParams->pInstructions);
            }
            
            //
            // Save the out params for use when the user presses OK.
            //

            s_ppProfileChosen     = pstParams->ppProfileChosen;
            s_ppFromAddressChosen = pstParams->ppFromAddressChosen;

            // Get the "last" call from used

            BSTR bstrLastCallFrom = NULL;

            get_SettingsString(
                                SS_LAST_CALL_FROM,
                                &bstrLastCallFrom );                

            //
            // Populate the dialog using the IN parameters and the
            // the window handle. Rather than passing in the
            // default destination phone number, we pass in a pointer
            // to the phone number object.
            //

            hr = PopulateCallInfoDialog(
                hwndDlg,
                pstParams->pClient,
                NULL, 
                pstParams->lSessionMask,
                pstParams->bEnumerateProfiles,
                pstParams->pOneShotProfile,
                bstrLastCallFrom,
                TRUE
                );

            if ( bstrLastCallFrom != NULL )
            {
                SysFreeString( bstrLastCallFrom );
                bstrLastCallFrom = NULL;
            }

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "DialNeedCallInfoDialogProc - "
                                "PopulateCallInfoDialog "
                                "returned 0x%08x - ending dialog", hr));

                EndDialog( hwndDlg, (LPARAM) hr );
            }
                   
            return TRUE;
        }

        case WM_DESTROY:
        {
            //
            // Release our references.
            //

            CleanupListOrComboBoxInterfaceReferences(
                hwndDlg,
                IDC_COMBO_SERVICE_PROVIDER,
                TRUE // this is a combo box
                );
        
            CleanupListOrComboBoxInterfaceReferences(
                hwndDlg,
                IDC_COMBO_CALL_FROM,
                TRUE // this is a combo box
                );
        }

        case WM_COMMAND:

            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                {
                    hr = GetPhoneNumberDialogResult(
                        hwndDlg,
                        s_ppProfileChosen,
                        NULL,
                        s_ppFromAddressChosen
                        );

                    //
                    // End the dialog.
                    //

                    EndDialog( hwndDlg, (LPARAM) hr );

                    return TRUE;
                }
                
                case IDCANCEL:
                {
                    //
                    // End the dialog.
                    //

                    EndDialog( hwndDlg, (LPARAM) E_ABORT );

                    return TRUE;
                }

                case IDC_BUTTON_EDIT_CALL_FROM_LIST:
                {
                    hr = ShowEditCallFromListDialog(
                        hwndDlg
                        );

                    if ( SUCCEEDED(hr) )
                    {
                        hr = PopulateCallFromList(
                            hwndDlg,
                            IDC_COMBO_CALL_FROM,
                            TRUE, // this is a combo box
                            NULL
                            );

                        EnableDisableCallGroupElements(
                            hwndDlg,
                            s_pClient,
                            s_lSessionMask,
                            IDC_RADIO_FROM_COMPUTER,
                            IDC_RADIO_FROM_PHONE,
                            IDC_COMBO_CALL_FROM,
                            IDC_COMBO_SERVICE_PROVIDER,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                            ); 
                    }
                    
                    return TRUE;
                }

                case IDC_BUTTON_EDIT_SERVICE_PROVIDER_LIST:
                {
                    hr = ShowEditServiceProviderListDialog(
                        hwndDlg,
                        s_pClient
                        );

                    if ( SUCCEEDED(hr) )
                    {
                        hr = PopulateServiceProviderList(
                            hwndDlg,
                            s_pClient,
                            IDC_COMBO_SERVICE_PROVIDER,
                            TRUE, // this is a combo box
                            NULL,
                            NULL,
                            s_bEnumerateProfiles ? s_lSessionMask : 0,
                            s_bEnumerateProfiles ? (s_lSessionMask & RTCSI_PC_TO_PC): 0 
                               ? IDS_NONE : 0
                            );

                        EnableDisableCallGroupElements(
                            hwndDlg,
                            s_pClient,
                            s_lSessionMask,
                            IDC_RADIO_FROM_COMPUTER,
                            IDC_RADIO_FROM_PHONE,
                            IDC_COMBO_CALL_FROM,
                            IDC_COMBO_SERVICE_PROVIDER,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                            ); 
                    }
                    
                    return TRUE;
                }
                
                case IDC_RADIO_FROM_COMPUTER:
                case IDC_RADIO_FROM_PHONE:
                {
                    switch ( HIWORD( wParam ) )
                    {
                    case BN_CLICKED:
                        {
                            if(LOWORD( wParam )==IDC_RADIO_FROM_PHONE)
                            {
                                // Verify if the Combo has at least one entry in it
                                DWORD dwNumItems = (DWORD) SendDlgItemMessage(
                                    hwndDlg,
                                    IDC_COMBO_CALL_FROM,
                                    CB_GETCOUNT,
                                    0,
                                    0
                                    );

                                if( dwNumItems == 0 )
                                {
                                    // Display the CallFrom options
                                    // simulate a button press
                                    BOOL    bHandled;

                                    SendMessage(
                                        hwndDlg,
                                        WM_COMMAND,
                                        MAKEWPARAM(IDC_BUTTON_EDIT_CALL_FROM_LIST, BN_CLICKED),
                                        0);
                                }
                            }

                            EnableDisableCallGroupElements(
                                hwndDlg,
                                s_pClient,
                                s_lSessionMask,
                                IDC_RADIO_FROM_COMPUTER,
                                IDC_RADIO_FROM_PHONE,
                                IDC_COMBO_CALL_FROM,
                                IDC_COMBO_SERVICE_PROVIDER,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );

                            break;
                        }
                    }
                    break;
                }

                case IDC_COMBO_SERVICE_PROVIDER:
                case IDC_COMBO_CALL_FROM:
                {
                    hr = GetPhoneNumberDialogResult(
                        hwndDlg,
                        NULL,
                        NULL,
                        NULL
                        );

                    EnableControl(
                        hwndDlg,
                        IDOK,
                        SUCCEEDED( hr ) // enable if succeeded
                        );

                    EnableDisableCallGroupElements(
                        hwndDlg,
                        s_pClient,
                        s_lSessionMask,
                        IDC_RADIO_FROM_COMPUTER,
                        IDC_RADIO_FROM_PHONE,
                        IDC_COMBO_CALL_FROM,
                        IDC_COMBO_SERVICE_PROVIDER,
                        NULL,
                        NULL,
                        NULL,
                        NULL
                        );                     
                    
                    return TRUE;
                }

                default:
                    break;
            }
        
        case WM_CONTEXTMENU:

            ::WinHelp(
                (HWND)wParam,
                g_szDllContextHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)g_dwHelpArrayNeedCallInfo);

            return TRUE;

            break;

        case WM_HELP:


            ::WinHelp(
                (HWND)(((HELPINFO *)lParam)->hItemHandle),
                g_szDllContextHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)g_dwHelpArrayNeedCallInfo);

            return TRUE;

            break;

        default:
            break;
    }

    //
    // We fell through, so this procedure did not handle the message.
    //

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////
//
// ShowDialNeedCallInfoDialog()
// externally-visible function
//
// Parameters:
//    IN  hwndParent -- the HWND of the parent window
//

HRESULT ShowDialNeedCallInfoDialog(
    IN   HWND           hwndParent,
    IN   IRTCClient   * pClient,
    IN   long           lSessionMask,
    IN   BOOL           bEnumerateProfiles,
    IN   BOOL           bProfileEditable,
    IN   IRTCProfile  * pOneShotProfile,
    IN   BSTR	        pDestAddress,
    IN   BSTR           pInstructions,
    OUT  IRTCProfile ** ppProfileChosen,
    OUT  BSTR         * ppFromAddressChosen
    )
{
    //
    // Fill out a structure encapsulating the parameters that
    // will be passed to the dialog box procedure.
    //

    DialNeedCallInfoDialogProcParams stParams;

    stParams.pClient              = pClient;
    stParams.lSessionMask         = lSessionMask;
    stParams.bEnumerateProfiles   = bEnumerateProfiles;
    stParams.bProfileEditable     = bProfileEditable;
    stParams.pOneShotProfile      = pOneShotProfile;
    stParams.pDestAddress         = pDestAddress;
    stParams.pInstructions        = pInstructions;
    stParams.ppProfileChosen      = ppProfileChosen;
    stParams.ppFromAddressChosen  = ppFromAddressChosen;

    //
    // Call the dialog box procedure.
    //

    INT_PTR ipReturn;

    ipReturn = DialogBoxParam(
        _Module.GetResourceInstance(),
        (LPCTSTR) IDD_DIALOG_DIAL_NEED_CALL_INFO,
        hwndParent,
        (DLGPROC) DialNeedCallInfoDialogProc,
        (LPARAM) & stParams // LPARAM == INT_PTR
        );

    //
    // In the success case, the dialog box procedure has written
    // the out parameters to the specified addresses.
    //

    return ipReturn != -1 ? (HRESULT)ipReturn : HRESULT_FROM_WIN32(GetLastError());
}

//////////////////////////////////////////////////////////////////////////////
//
// This structure is used to pass params when calling the Win32
// DialogBoxParam() function to create this dialog box.
//

typedef struct
{
    IN   BOOL           bAddParticipant;
    IN   BSTR	        pDestPhoneNr;
    OUT  BSTR         * ppDestPhoneNrChosen;

} DialByPhoneNumberDialogProcParams;

//////////////////////////////////////////////////////////////////////////////
//
// DialByPhoneNumberDialogProc()
// helper function
//
// This is the dialog procedure for the add participant dialog box.
//
// Parameters:
//    IN  hwndDlg -- the HWND of this dialog box
//    IN  uMsg    -- identifies the message being sent to this window
//    IN  wParam  -- first parameter
//    IN  lParam  -- second parameter
//

INT_PTR CALLBACK DialByPhoneNumberDialogProc(
    IN  HWND   hwndDlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
{
    //
    // Static locals for saving out parameters passed in on WM_INITDIALOG for
    // use when user presses OK.
    //

    static BSTR         * s_ppDestPhoneNrChosen = NULL;

    //
    // Static local that stores the core's representation of the phone number
    // we are editing. This dialog creates the phone number object, so this
    // dialog is responsible for releasing it.
    //

    static IRTCPhoneNumber * s_pPhoneNumber = NULL;

    //
    // Handling for various window messages.
    //

    HRESULT hr;
    
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            //
            // Retrieve the params structure from the message.
            //
            
            DialByPhoneNumberDialogProcParams * pstParams;

            pstParams = (DialByPhoneNumberDialogProcParams *) lParam;

            if ( pstParams->bAddParticipant )
            {
                //
                // Change the window title to add participant
                //

                TCHAR szString[256];

                if (LoadString(_Module.GetResourceInstance(), IDS_ADD_PARTICIPANT, szString, 256))
                {
                    SetWindowText(hwndDlg, szString);
                }
            }

            //
            // Create the phone number object that we will manipulate
            // to do translation to/from canonical form as the user edits
            // the number
            //

            hr = CreatePhoneNumber( & s_pPhoneNumber );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "DialByPhoneNumberDialogProc - "
                                "CreatePhoneNumber returned 0x%08x - "
                                "ending dialog", hr));

                EndDialog( hwndDlg, (LPARAM) hr );
            }

            if ( pstParams->pDestPhoneNr == NULL )
            {
                //
                // Set the phone number object so it contains the "last" 
                // phone number called
                //

                DWORD dwLastCountry;
                BSTR bstrLastAreaCode = NULL;
                BSTR bstrLastNumber = NULL;

                hr = get_SettingsDword( 
                    SD_LAST_COUNTRY_CODE,
                    &dwLastCountry );

                if ( SUCCEEDED(hr) )
                {
                    hr = get_SettingsString( 
                        SS_LAST_AREA_CODE,
                        &bstrLastAreaCode );

                    if ( SUCCEEDED(hr) )
                    {
                        hr = get_SettingsString( 
                            SS_LAST_NUMBER,
                            &bstrLastNumber );

                        if ( SUCCEEDED(hr) )
                        {                        
                            s_pPhoneNumber->put_CountryCode( dwLastCountry );
                            s_pPhoneNumber->put_AreaCode( bstrLastAreaCode );
                            s_pPhoneNumber->put_Number( bstrLastNumber );

                            SysFreeString( bstrLastNumber );
                        }

                        SysFreeString( bstrLastAreaCode );
                    }
                }

                if ( FAILED(hr) )
                {
                    //
                    // There is no "last" phone number called...
                    //
                    // Set the phone number object so it contains a default
                    // phone number
                    //

                    s_pPhoneNumber->put_Canonical( DEFAULT_PHONE_NUMBER );
                }
            }
            else
            {
                //
                // Set the phone number object so it contains the phone
                // number passed into this method
                //

                s_pPhoneNumber->put_Canonical( pstParams->pDestPhoneNr );
            }                   
            
            //
            // Save the out params for use when the user presses OK.
            //

            s_ppDestPhoneNrChosen = pstParams->ppDestPhoneNrChosen;

            //
            // Populate the dialog using the IN parameters and the
            // the window handle. Rather than passing in the
            // default destination phone number, we pass in a pointer
            // to the phone number object.
            //
        
            hr = PopulateDialByPhoneNumberDialog(
                hwndDlg,
                s_pPhoneNumber
                );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "DialByPhoneNumberDialogProc - "
                                "PopulateDialByPhoneNumberDialog "
                                "returned 0x%08x - ending dialog", hr));

                if ( s_pPhoneNumber != NULL )
                {
                    s_pPhoneNumber->Release();
                    s_pPhoneNumber = NULL;
                }

                EndDialog( hwndDlg, (LPARAM) hr );
            }
                   
            return TRUE;
        }

        case WM_DESTROY:
        {
            //
            // Release our references.
            //
        
            if ( s_pPhoneNumber != NULL )
            {
                s_pPhoneNumber->Release();
                s_pPhoneNumber = NULL;
            }
        }

        case WM_COMMAND:

            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                {
                    //
                    // Get the user's selections.
                    //
                    
                    hr = GetPhoneNumberDialogResult(
                        hwndDlg,
                        NULL,
                        s_ppDestPhoneNrChosen,
                        NULL
                        );

                    //
                    // Save this phone number to populate
                    // the dialog next time
                    //

                    if ( s_pPhoneNumber != NULL )
                    {
                        DWORD dwLastCountry;
                        BSTR bstrLastAreaCode = NULL;
                        BSTR bstrLastNumber = NULL;

                        hr = s_pPhoneNumber->get_CountryCode( &dwLastCountry );

                        if ( SUCCEEDED(hr) )
                        {
                            hr = s_pPhoneNumber->get_AreaCode( &bstrLastAreaCode );

                            if ( SUCCEEDED(hr) )
                            {
                                hr = s_pPhoneNumber->get_Number( &bstrLastNumber );

                                if ( SUCCEEDED(hr) )
                                {                        
                                    put_SettingsDword( 
                                        SD_LAST_COUNTRY_CODE,
                                        dwLastCountry );

                                    put_SettingsString( 
                                        SS_LAST_AREA_CODE,
                                        bstrLastAreaCode );

                                    put_SettingsString( 
                                        SS_LAST_NUMBER,
                                        bstrLastNumber );

                                    SysFreeString( bstrLastNumber );
                                }

                                SysFreeString( bstrLastAreaCode );
                            }
                        }
                    }             

                    //
                    // End the dialog.
                    //

                    EndDialog( hwndDlg, (LPARAM) hr );

                    return TRUE;
                }
                
                case IDCANCEL:
                {
                    //
                    // End the dialog.
                    //

                    EndDialog( hwndDlg, (LPARAM) E_ABORT );

                    return TRUE;
                }          

                case IDC_COMBO_COUNTRY:
                {

                    switch ( HIWORD( wParam ) )
                    {
                        case CBN_SELCHANGE:
                        {
                            if ( s_pPhoneNumber != NULL )
                            {
                                HandleCountryChange(
                                    hwndDlg,
                                    (HWND) lParam,
                                    s_pPhoneNumber
                                    );
                            }
                        
                            return TRUE;
                        }
                        
                        default:
                            break;
                    }

                    break;
                }

                case IDC_EDIT_AREA_CODE:
                {
                    HandleNumberChange(
                        hwndDlg,
                        LOWORD( wParam ),
                        TRUE,   // area code
                        s_pPhoneNumber
                        );
                
                    return TRUE;
                }

                case IDC_EDIT_LOCAL_NUMBER:
                {
                    HandleNumberChange(
                        hwndDlg,
                        LOWORD( wParam ),
                        FALSE,  // not area code
                        s_pPhoneNumber
                        );
                
                    return TRUE;
                }

                default:
                    break;
            }
        
        case WM_CONTEXTMENU:

            ::WinHelp(
                (HWND)wParam,
                g_szDllContextHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)g_dwHelpArrayDialByPhoneNumber);

            return TRUE;

            break;

        case WM_HELP:


            ::WinHelp(
                (HWND)(((HELPINFO *)lParam)->hItemHandle),
                g_szDllContextHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)g_dwHelpArrayDialByPhoneNumber);

            return TRUE;

            break;


        default:
            break;
    }

    //
    // We fell through, so this procedure did not handle the message.
    //

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
// dest phone nr is always editable
// otherwise the function is not called
//

HRESULT ShowDialByPhoneNumberDialog(
    IN  HWND         hwndParent,
    IN  BOOL         bAddParticipant,
    IN  BSTR         pDestPhoneNr,
    OUT BSTR       * ppDestPhoneNrChosen
    )
{ 
    ASSERT( ! IsBadWritePtr( ppDestAddressChosen, sizeof(BSTR) ) );

    //
    // Fill out a structure encapsulating the parameters that
    // will be passed to the dialog box procedure.
    //

    DialByPhoneNumberDialogProcParams stParams;

    stParams.bAddParticipant      = bAddParticipant;
    stParams.pDestPhoneNr         = pDestPhoneNr;
    stParams.ppDestPhoneNrChosen  = ppDestPhoneNrChosen;

    //
    // Call the dialog box procedure.
    //

    INT_PTR ipReturn;

    ipReturn = DialogBoxParam(
        _Module.GetResourceInstance(),
        (LPCTSTR) IDD_DIALOG_DIAL_BY_PHONE_NUMBER,
        hwndParent,
        (DLGPROC) DialByPhoneNumberDialogProc,
        (LPARAM) & stParams // LPARAM == INT_PTR
        );

    //
    // In the success case, the dialog box procedure has written
    // the out parameters to the specified addresses.
    //

    return ipReturn != -1 ? (HRESULT)ipReturn : HRESULT_FROM_WIN32(GetLastError());
}

//////////////////////////////////////////////////////////////////////////////
//
//

typedef struct
{
    IN   BSTR	        pDestAddress;
    OUT  BSTR         * ppDestAddressChosen;

} DialByMachineNameDialogProcParams;

//////////////////////////////////////////////////////////////////////////////
//
//

INT_PTR CALLBACK DialByMachineNameDialogProc(
    IN  HWND   hwndDlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
{
    //
    // Static local used to return result of dialog.
    //

    static BSTR * s_ppAddressToDial = NULL;

    //
    // Handling for various window messages.
    //

    HRESULT hr;
    
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            DialByMachineNameDialogProcParams * pParams;

            //
            // Save return string parameter
            //

            pParams = (DialByMachineNameDialogProcParams *) lParam;

            s_ppAddressToDial = pParams->ppDestAddressChosen;

            if (pParams->pDestAddress == NULL)
            {
                //
                // Get the last called address
                //

                BSTR bstrLastAddress = NULL;

                hr = get_SettingsString( SS_LAST_ADDRESS, &bstrLastAddress );

                if ( SUCCEEDED(hr) )
                {
                    //
                    // Populate the dialog with the last called address
                    //

                    ::SetWindowText( ::GetDlgItem( hwndDlg, IDC_EDIT_COMPLETE ), bstrLastAddress );

                    SysFreeString( bstrLastAddress );
                }
            }
            else
            {
                //
                // Populate the dialog with the address passed in
                //

                ::SetWindowText( ::GetDlgItem( hwndDlg, IDC_EDIT_COMPLETE ), pParams->pDestAddress );
            }

            return TRUE;
        }

        case WM_COMMAND:

            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                {
                    //
                    // Get the string from the edit box.
                    //

                    WCHAR * wszEditBoxString;

                    hr = GetStringFromEditBox(
                        hwndDlg,
                        IDC_EDIT_COMPLETE,
                        & wszEditBoxString
                        );

                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // Save the address for next time
                        //

                        put_SettingsString( SS_LAST_ADDRESS, wszEditBoxString );

                        //
                        // Return the address
                        //

                        (*s_ppAddressToDial) = SysAllocString( wszEditBoxString );                        

                        RtcFree( wszEditBoxString );

                        if ( (*s_ppAddressToDial) == NULL )
                        {
                            hr = E_OUTOFMEMORY;
                        }
                   
                    }

                    EndDialog( hwndDlg, (LPARAM) hr );

                    return TRUE;
                }
                
                case IDCANCEL:
                {
                    EndDialog( hwndDlg, (LPARAM) E_ABORT );

                    return TRUE;
                }

                default:
                    break;
            }    
        
        case WM_CONTEXTMENU:

            ::WinHelp(
                (HWND)wParam,
                g_szDllContextHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)g_dwHelpArrayDialByName);

            return TRUE;

            break;

        case WM_HELP:


            ::WinHelp(
                (HWND)(((HELPINFO *)lParam)->hItemHandle),
                g_szDllContextHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)g_dwHelpArrayDialByName);

            return TRUE;

            break;

        default:
            break;
    }    

    //
    // We fell through, so this procedure did not handle the message.
    //

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
// "Dial by address" = dial by name or IP address
//

HRESULT ShowDialByAddressDialog(
    IN   HWND           hwndParent,
    IN   BSTR	        pDestAddress,
    OUT  BSTR         * ppDestAddressChosen
    )
{
    ASSERT( ! IsBadWritePtr( ppDestAddressChosen, sizeof(BSTR) ) );

    //
    // Call the dialog box procedure.
    //

    DialByMachineNameDialogProcParams params;

    params.pDestAddress        = pDestAddress;
    params.ppDestAddressChosen = ppDestAddressChosen;

    INT_PTR ipReturn;

    ipReturn = DialogBoxParam(
        _Module.GetResourceInstance(),
        (LPCTSTR) IDD_DIALOG_DIAL_BY_NAME,
        hwndParent,
        (DLGPROC) DialByMachineNameDialogProc,
        (LPARAM) & params // LPARAM == INT_PTR
        );

    return ipReturn != -1 ? (HRESULT)ipReturn : HRESULT_FROM_WIN32(GetLastError());
}

//////////////////////////////////////////////////////////////////////////////
//
// "Message by address" = Send a Message by name or IP address
//

HRESULT ShowMessageByAddressDialog(
    IN   HWND           hwndParent,
    IN   BSTR	        pDestAddress,
    OUT  BSTR         * ppDestAddressChosen
    )
{
    ASSERT( ! IsBadWritePtr( ppDestAddressChosen, sizeof(BSTR) ) );

    //
    // Call the dialog box procedure.
    //

    DialByMachineNameDialogProcParams params;

    params.pDestAddress        = pDestAddress;
    params.ppDestAddressChosen = ppDestAddressChosen;

    INT_PTR ipReturn;

    ipReturn = DialogBoxParam(
        _Module.GetResourceInstance(),
        (LPCTSTR) IDD_DIALOG_MESSAGE_BY_NAME,
        hwndParent,
        (DLGPROC) DialByMachineNameDialogProc,
        (LPARAM) & params // LPARAM == INT_PTR
        );

    return ipReturn != -1 ? (HRESULT)ipReturn : HRESULT_FROM_WIN32(GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\im.h ===
// im.h : Declaration of the CIMWindow

#ifndef __IM_H_
#define __IM_H_

#include <richedit.h>

#define IDC_IM_EDIT 3000
#define IDC_IM_SEND 3001
#define IDC_IM_DISPLAY 3002

#define IM_WIDTH 400
#define IM_HEIGHT 400

class CIMWindow;

/////////////////////////////////////////////////////////////////////////////
// CIMWindowList
class CIMWindowList
{
    friend CIMWindow;

public:
    CIMWindowList( IRTCClient * pClient );

    ~CIMWindowList();

    HRESULT DeliverMessage( IRTCSession * pSession, IRTCParticipant * pParticipant, BSTR bstrMessage );

    HRESULT DeliverUserStatus( IRTCSession * pSession, IRTCParticipant * pParticipant, RTC_MESSAGING_USER_STATUS enStatus );

    HRESULT DeliverState( IRTCSession * pSession, RTC_SESSION_STATE SessionState );

    BOOL IsDialogMessage( LPMSG lpMsg );

private:    

    HRESULT AddWindow( CIMWindow * pWindow );

    HRESULT RemoveWindow( CIMWindow * pWindow );

    CIMWindow * NewWindow( IRTCSession * pSession );

    CIMWindow * FindWindow( IRTCSession * pSession );

    // interface to the client
    CComPtr<IRTCClient>     m_pClient;

    CIMWindow ** m_pWindowList;
    LONG         m_lNumWindows;
   
    HMODULE      m_hRichEditLib;
};

/////////////////////////////////////////////////////////////////////////////
// CIMWindow
class CIMWindow :
    public CWindowImpl<CIMWindow>
{
    friend CIMWindowList;

public:
    CIMWindow(CIMWindowList * pWindowList);

    ~CIMWindow();

    //static CWndClassInfo& GetWndClassInfo();

BEGIN_MSG_MAP(CIMWindow)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
    MESSAGE_HANDLER(WM_ACTIVATE, OnActivate)
    MESSAGE_HANDLER(DM_GETDEFID, OnGetDefID)
    MESSAGE_HANDLER(WM_NEXTDLGCTL, OnNextDlgCtl)
    NOTIFY_CODE_HANDLER(EN_LINK, OnLink)
    COMMAND_CODE_HANDLER(EN_CHANGE, OnChange)
    COMMAND_HANDLER(IDC_IM_SEND, BN_CLICKED, OnSend)
    COMMAND_ID_HANDLER(IDM_IM_CALL_SAVEAS, OnSaveAs)
    COMMAND_ID_HANDLER(IDM_IM_CALL_CLOSE, OnClose)
    COMMAND_ID_HANDLER(IDM_IM_TOOLS_SOUNDS, OnPlaySounds)
    COMMAND_ID_HANDLER(IDM_IM_TOOLS_LARGEST, OnTextSize)
    COMMAND_ID_HANDLER(IDM_IM_TOOLS_LARGER, OnTextSize)
    COMMAND_ID_HANDLER(IDM_IM_TOOLS_MEDIUM, OnTextSize)
    COMMAND_ID_HANDLER(IDM_IM_TOOLS_SMALLER, OnTextSize)
    COMMAND_ID_HANDLER(IDM_IM_TOOLS_SMALLEST, OnTextSize)
END_MSG_MAP()

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);  

    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);  

    LRESULT OnActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);  

    LRESULT OnGetDefID(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);  

    LRESULT OnNextDlgCtl(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled); 

    LRESULT OnLink(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnSend(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnSaveAs(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnClose(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnPlaySounds(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnTextSize(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    HRESULT DeliverMessage( IRTCParticipant * pParticipant, BSTR bstrMessage, BOOL bIncoming );

    HRESULT DeliverUserStatus( IRTCParticipant * pParticipant, RTC_MESSAGING_USER_STATUS enStatus );

    HRESULT DeliverState( RTC_SESSION_STATE SessionState );

private:

    void PositionWindows();

    static DWORD CALLBACK EditStreamCallback(
        DWORD_PTR dwCookie,
        LPBYTE    pbBuff,
        LONG      cb,
        LONG    * pcb);

    HRESULT GetFormattedNameFromParticipant( IRTCParticipant * pParticipant, BSTR * pbstrName );

    CIMWindowList          * m_pIMWindowList;

    // interface to the session
    CComPtr<IRTCSession>     m_pSession;

    // Window controls
    CWindow         m_hDisplay;
    CWindow         m_hEdit;
    CWindow         m_hSendButton;
    CWindow         m_hStatusBar;

    // Icon
    HICON       m_hIcon;

    // Brush
    HBRUSH      m_hBkBrush;

    // Status text
    TCHAR       m_szStatusText[256];

    // Menu
    HMENU       m_hMenu;

    // Active flag
    BOOL        m_bWindowActive;
    BOOL        m_bPlaySounds;
    BOOL        m_bNewWindow;

    // Our status
    RTC_MESSAGING_USER_STATUS m_enStatus;
};

#endif //__IM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\misc.cpp ===
// helper stuff
// header needed

#include "stdafx.h"
#include "misc.h"


/////////////////////////////////////////////////////////////////////////////
// CParticipant
//
struct CParticipantEntry
{
    LIST_ENTRY      ListEntry;

    IRTCParticipant *pParticipant;
    RTC_PARTICIPANT_STATE
                    nState;

    BOOL            bAutoDelete;
};


/////////////////////////////////////////////////////////////////////////////
// CParticipantList
//
//

// Constructor
//

CParticipantList::CParticipantList()
{
    InitializeListHead(&ListHead);
}

// Initialize
// Creates the columns

HRESULT  CParticipantList::Initialize(void)
{
    TCHAR       szBuffer[MAX_STRING_LEN];
    LVCOLUMN    lvColumn;
    RECT        Rect;
    HIMAGELIST  hImageList;
    HBITMAP     hBitmap;
    
    // Add columns
    GetWindowRect(&Rect);

    // Name column
    szBuffer[0] = _T('\0');
    LoadString( _Module.GetResourceInstance(), 
                IDS_PARTICIPANT_NAME_HEADER,
                szBuffer, 
                sizeof(szBuffer)/sizeof(TCHAR));
    
    ZeroMemory(&lvColumn, sizeof(lvColumn));

    lvColumn.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.cx = (Rect.right - Rect.left) / 2;
    lvColumn.pszText = szBuffer;
    
    ListView_InsertColumn(m_hWnd, 0, &lvColumn);

    // Status column
    szBuffer[0] = _T('\0');
    LoadString( _Module.GetResourceInstance(), 
                IDS_PARTICIPANT_STATUS_HEADER,
                szBuffer, 
                sizeof(szBuffer)/sizeof(TCHAR));
    
    ZeroMemory(&lvColumn, sizeof(lvColumn));

    lvColumn.mask = LVCF_TEXT | LVCF_WIDTH;
    lvColumn.cx = (Rect.right - Rect.left) / 2 - 5;
    lvColumn.pszText = szBuffer;
    
    ListView_InsertColumn(m_hWnd, 1, &lvColumn);

    // Create an imagelist for small icons and set it on the listview
    hImageList = ImageList_Create(16, 16, ILC_COLOR | ILC_MASK , 5, 5);
    if(hImageList)
    {
        // Open a bitmap
        hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_PARTICIPANT_LIST));
        if(hBitmap)
        {
            // Add the bitmap to the image list
            ImageList_AddMasked(hImageList, hBitmap, BMP_COLOR_MASK);
            // set the image list
            ListView_SetImageList(m_hWnd, hImageList, LVSIL_SMALL);

            DeleteObject(hBitmap);
        }
    }
    
    return S_OK;
}

// Change

//
//  Adds an entry to the list if there is no other with the same IRTCParticipant and
//  also Addrefs the interface
//
//  For the DISCONNECTED state   the interface is released and:
//    - if the previous state was DISCONNECTING, delete the entry
//    - else put (IRTCParticipant *)1 instead
//


HRESULT CParticipantList::Change(IRTCParticipant *pParticipant, RTC_PARTICIPANT_STATE nState, long StatusCode)
{
    // Search for the item first
    TCHAR       szBuffer[MAX_STRING_LEN];
    LVFINDINFO  lvf;
    int         iItem;
    int         iImage;
    CComBSTR    bstrName;
    HRESULT     hr;
    LVITEM      lv = {0};
    CParticipantEntry
               *pEntry;

    // search the participant in the list of participant entries
    pEntry = GetParticipantEntry(pParticipant);

    if(pEntry==NULL)
    {
        // not found, entry must be added
        // But don't bother for DISCONNECTED state
        if(nState == RTCPS_DISCONNECTED)
        {
            return S_OK;
        }
        
        // name
        hr = pParticipant->get_UserURI(&bstrName);
        if(FAILED(hr))
        {
            return hr;
        }

        // create entry
        pEntry = (CParticipantEntry *)RtcAlloc(sizeof(CParticipantEntry));
        if(!pEntry)
        {
            return E_OUTOFMEMORY;
        }

        InitializeListHead(&pEntry->ListEntry);
        pEntry->nState = nState;
        pEntry->pParticipant = pParticipant;
        pEntry->bAutoDelete = FALSE;

        pEntry->pParticipant->AddRef();
        
        // Add them to list box.
        lv.mask = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
        lv.iItem = 0x7FFFFFFF;
        lv.iSubItem = 0;
        lv.iImage = GetImage(nState);
        lv.lParam = reinterpret_cast<LPARAM>(pEntry);
        lv.pszText = bstrName ? bstrName : _T("");

        iItem = ListView_InsertItem(m_hWnd, &lv);

        // insert the entry in the list of participants
        InsertTailList(&ListHead, &pEntry->ListEntry);
    }
    else
    {
        // found in the list, try to find it in the list view
        lvf.flags = LVFI_PARAM;
        lvf.lParam = reinterpret_cast<LPARAM>(pEntry);

        iItem = ListView_FindItem(m_hWnd, -1, &lvf);
        if(iItem>=0)
        {
            // set the image
            lv.mask = LVIF_IMAGE;
            lv.iItem = iItem;
            lv.iSubItem = 0;
            lv.iImage = GetImage(nState);
        
            ListView_SetItem(m_hWnd, &lv);
        }
    }

   
    if(nState == RTCPS_DISCONNECTED && pEntry->bAutoDelete && StatusCode == 0)
    {
        // delete everything
        RemoveEntryList(&pEntry->ListEntry);

        if(pEntry->pParticipant)
        {
            pEntry->pParticipant->Release();
        }
        
        RtcFree(pEntry);

        if(iItem>=0)
        {
            ListView_DeleteItem(m_hWnd, iItem);
        }
    }
    else
    {
        // change the status

        pEntry->nState = nState;

        if(nState == RTCPS_DISCONNECTED)
        {
            if(pEntry->pParticipant)
            {
                pEntry->pParticipant->Release();
                pEntry->pParticipant = NULL;
            }
        }

        if(iItem>=0)
        {
            // Set the state
            GetStatusString(nState, HRESULT_CODE(StatusCode) , szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
            lv.mask = LVIF_TEXT;
            lv.iItem = iItem;
            lv.iSubItem = 1;
            lv.pszText = szBuffer;
       
            ListView_SetItem(m_hWnd, &lv);
        }
    }
    
    return S_OK;
}


void CParticipantList::RemoveAll(void)
{
    int         iItem;
    LVITEM      lv;
    LIST_ENTRY  *pListEntry;
    CParticipantEntry
                *pEntry;

    ListView_DeleteAllItems(m_hWnd);

    while(!IsListEmpty(&ListHead))
    {
        pListEntry = ListHead.Flink;

        RemoveEntryList(pListEntry);

        pEntry = CONTAINING_RECORD(pListEntry, CParticipantEntry, ListEntry);

        if(pEntry->pParticipant)
        {
            pEntry->pParticipant->Release();
        }

        RtcFree(pEntry);
    }
}

HRESULT CParticipantList::Remove(IRTCParticipant **ppParticipant)
{
    // find the current selection
    int         iItem;
    LVITEM      lv;
    CParticipantEntry
               *pEntry;

    iItem = ListView_GetNextItem(m_hWnd, -1, LVNI_SELECTED);
    if(iItem<0)
    {
        return E_FAIL;
    }

    lv.mask = LVIF_PARAM;
    lv.iItem = iItem;
    lv.iSubItem = 0;
    lv.lParam = NULL;
        
    ListView_GetItem(m_hWnd, &lv);
    
    pEntry = reinterpret_cast<CParticipantEntry *>(lv.lParam);

    if(!pEntry)
    {
        return E_UNEXPECTED;
    }

    if(!pEntry->pParticipant)
    {
        // delete it right now
        ListView_DeleteItem(m_hWnd, iItem);

        *ppParticipant = NULL;

        return S_OK;
    }

    // else deffer
    pEntry ->bAutoDelete = TRUE;

    *ppParticipant = pEntry->pParticipant;
    (*ppParticipant)->AddRef();

    return S_OK;
}

BOOL  CParticipantList::CanDeleteSelected(void)
{
    HRESULT         hr;
    CParticipantEntry   *pEntry;
    
    // find the current selection
    int         iItem;
    LVITEM      lv;

    iItem = ListView_GetNextItem(m_hWnd, -1, LVNI_SELECTED);
    if(iItem<0)
    {
        return FALSE;
    }

    lv.mask = LVIF_PARAM;
    lv.iItem = iItem;
    lv.iSubItem = 0;
    lv.lParam = NULL;
        
    ListView_GetItem(m_hWnd, &lv);
    
    pEntry = reinterpret_cast<CParticipantEntry *>(lv.lParam);
    VARIANT_BOOL    bRemovable = VARIANT_FALSE;
    
    if(!pEntry->pParticipant)
    {
        // this is already disconnected. Can be removed
        return TRUE;
    }

    hr = pEntry->pParticipant -> get_Removable(&bRemovable);

    if(FAILED(hr))
    {
        return FALSE;
    }
    
    return bRemovable ? TRUE : FALSE;
}


void  CParticipantList::GetStatusString(RTC_PARTICIPANT_STATE State, long lError, TCHAR *pszBuffer, int nSize)
{
    int nResId;

    switch(State)
    {
    case RTCPS_PENDING:
        nResId = IDS_PART_STATE_PENDING;
        break;

    case RTCPS_INPROGRESS:
        nResId = IDS_PART_STATE_CONNECTING;
        break;

    case RTCPS_CONNECTED:
        nResId = IDS_PART_STATE_CONNECTED;
        break;
    
    case RTCPS_DISCONNECTING:
        nResId = IDS_PART_STATE_DISCONNECTING;
        break;

    case RTCPS_DISCONNECTED:
        if(lError == 0)
        {
            nResId = IDS_PART_STATE_DISCONNECTED;
        }
        else 
        {
            switch(lError)
            {
            case 5:
                nResId = IDS_PART_REJECTED_BUSY;
                break;
        
            case 6:
                nResId = IDS_PART_REJECTED_NO_ANSWER;
                break;

            case 7:
                nResId = IDS_PART_REJECTED_ALL_BUSY;
                break;

            case 8:
                nResId = IDS_PART_REJECTED_PL_FAILED;
                break;

            case 9:
                nResId = IDS_PART_REJECTED_SW_FAILED;
                break;

            case 10:
                nResId = IDS_PART_REJECTED_CANCELLED;
                break;
        
            case 11:
            case 307:
                nResId = IDS_PART_REJECTED_BADNUMBER;
                break;

            default:
                nResId = IDS_PART_STATE_REJECTED;
                break;
            }
        }
        break;

    default:
        nResId = IDS_GENERIC_UNKNOWN;
        break;
    }

    *pszBuffer = _T('\0');
    LoadString(_Module.GetResourceInstance(), nResId, pszBuffer, nSize);
}


int  CParticipantList::GetImage(RTC_PARTICIPANT_STATE State)
{
    switch(State)
    {
    case RTCPS_PENDING:
        return ILI_PART_PENDING;
        break;
    
    case RTCPS_INPROGRESS:
        return ILI_PART_INPROGRESS;
        break;

    case RTCPS_CONNECTED:
        return ILI_PART_CONNECTED;
        break;
    }
    return ILI_PART_DISCONNECTED;
}


CParticipantEntry *CParticipantList::GetParticipantEntry(IRTCParticipant *pRTCParticipant)
{
    LIST_ENTRY  *pListEntry;

    CParticipantEntry *pEntry;
    
    // linear search
    for(pListEntry = ListHead.Flink; pListEntry!= &ListHead; pListEntry = pListEntry->Flink)
    {
        pEntry = CONTAINING_RECORD(pListEntry, CParticipantEntry, ListEntry);

        // compare the pointers
        if(pEntry->pParticipant == pRTCParticipant)
        {
            return pEntry;
        }
    }

    return NULL;
}



/////////////////////////////////////////////////////////////////////////////
// CErrorMessageLiteDlg


////////////////////////////////////////
//

CErrorMessageLiteDlg::CErrorMessageLiteDlg()
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::CErrorMessageLiteDlg"));
}


////////////////////////////////////////
//

CErrorMessageLiteDlg::~CErrorMessageLiteDlg()
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::~CErrorMessageLiteDlg"));
}


////////////////////////////////////////
//

LRESULT CErrorMessageLiteDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnInitDialog - enter"));

    // LPARAM contains a pointer to an RTCAX_ERROR_INFO stricture
    RTCAX_ERROR_INFO    *pInfo = (RTCAX_ERROR_INFO *)lParam;

    ATLASSERT(pInfo);

    SetDlgItemText(IDC_EDIT_MSG1, pInfo->Message1 ? pInfo->Message1 : _T(""));
    SetDlgItemText(IDC_EDIT_MSG2, pInfo->Message2 ? pInfo->Message2 : _T(""));
    SetDlgItemText(IDC_EDIT_MSG3, pInfo->Message3 ? pInfo->Message3 : _T(""));

    SendDlgItemMessage(IDC_STATIC_MSG_ICON,
                       STM_SETIMAGE,
                       IMAGE_ICON,
                       (LPARAM)pInfo->ResIcon);

    // Title
    TCHAR   szTitle[0x80];

    szTitle[0] = _T('\0');
    LoadString(
        _Module.GetResourceInstance(),
        IDS_APPNAME,
        szTitle,
        sizeof(szTitle)/sizeof(szTitle[0]));

    SetWindowText(szTitle);

    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnInitDialog - exit"));
    
    return 1;
}
    

////////////////////////////////////////
//

LRESULT CErrorMessageLiteDlg::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnDestroy - enter"));

    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnDestroy - exit"));
    
    return 0;
}
    

////////////////////////////////////////
//

LRESULT CErrorMessageLiteDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnCancel - enter"));
    
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnCancel - exiting"));
   
    EndDialog(wID);
    return 0;
}

////////////////////////////////////////
//

LRESULT CErrorMessageLiteDlg::OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnOk - enter"));
    
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnOk - exiting"));
    
    EndDialog(wID);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\im.cpp ===
//
// im.cpp : Implementation of CIMWindow
//

#include "stdafx.h"
#include <shellapi.h>
#include <Commdlg.h>

/*
const TCHAR * g_szIMWindowClassName = _T("PhoenixIMWnd");
*/

static CHARFORMAT cfDefault =
{
	sizeof(CHARFORMAT),
	CFM_EFFECTS | CFM_PROTECTED | CFM_SIZE | CFM_OFFSET | CFM_COLOR | CFM_CHARSET | CFM_FACE,
	CFE_AUTOCOLOR,		// effects
	200,				// height, 200 twips == 10 points
	0,					// offset
	0,					// color (not used since CFE_AUTOCOLOR is specified)
	DEFAULT_CHARSET,
	FF_SWISS,			// pitch and family
	_T("Microsoft Sans Serif") // face name
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CIMWindowList
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//

CIMWindowList::CIMWindowList( IRTCClient * pClient)
{
    LOG((RTC_TRACE, "CIMWindowList::CIMWindowList"));

    m_pClient = pClient;
    m_pWindowList = NULL;
    m_lNumWindows = 0;   
    m_hRichEditLib = NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
//

CIMWindowList::~CIMWindowList()
{
    LOG((RTC_TRACE, "CIMWindowList::~CIMWindowList"));

    if (m_pWindowList != NULL)
    {
        LONG lIndex;

        for (lIndex = 0; lIndex < m_lNumWindows; lIndex++)
        {
            m_pWindowList[lIndex]->DestroyWindow();

            delete m_pWindowList[lIndex];
            m_pWindowList[lIndex] = NULL;
        }

        RtcFree( m_pWindowList );
        m_pWindowList = NULL;
    }

    m_lNumWindows = 0;
    
    if (m_hRichEditLib != NULL)
    {
        FreeLibrary(m_hRichEditLib);
        m_hRichEditLib = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindowList::DeliverMessage( IRTCSession * pSession, IRTCParticipant * pParticipant, BSTR bstrMessage )
{
    LOG((RTC_TRACE, "CIMWindowList::DeliverMessage"));

    CIMWindow * pWindow = NULL;

    pWindow = FindWindow( pSession );

    if ( pWindow == NULL )
    {
        //
        // This is a new session
        //

        pWindow = NewWindow( pSession );

        if ( pWindow == NULL )
        {
            LOG((RTC_ERROR, "CIMWindowList::DeliverMessage - out of memory"));

            return E_OUTOFMEMORY;
        }
    }

    //
    // Deliver the message
    //

    pWindow->DeliverMessage( pParticipant, bstrMessage, TRUE );

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindowList::DeliverUserStatus( IRTCSession * pSession, IRTCParticipant * pParticipant, RTC_MESSAGING_USER_STATUS enStatus )
{
    LOG((RTC_TRACE, "CIMWindowList::DeliverUserStatus"));

    CIMWindow * pWindow = NULL;

    pWindow = FindWindow( pSession );

    if ( pWindow == NULL )
    {
        //
        // This is a new session
        //

        pWindow = NewWindow( pSession );

        if ( pWindow == NULL )
        {
            LOG((RTC_ERROR, "CIMWindowList::DeliverUserStatus - out of memory"));

            return E_OUTOFMEMORY;
        }
    }

    //
    // Deliver the user status
    //

    pWindow->DeliverUserStatus( pParticipant, enStatus );

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindowList::DeliverState( IRTCSession * pSession, RTC_SESSION_STATE SessionState )
{
    LOG((RTC_TRACE, "CIMWindowList::DeliverState"));

    CIMWindow * pWindow = NULL;

    pWindow = FindWindow( pSession );

    if ( pWindow == NULL )
    {
        //
        // This is a new session
        //

        pWindow = NewWindow( pSession );

        if ( pWindow == NULL )
        {
            LOG((RTC_ERROR, "CIMWindowList::DeliverState - out of memory"));

            return E_OUTOFMEMORY;
        }
    }

    //
    // Deliver the state
    //

    pWindow->DeliverState( SessionState );

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindowList::AddWindow( CIMWindow * pWindow )
{
    LOG((RTC_TRACE, "CIMWindowList::AddWindow"));

    CIMWindow ** pNewWindowList = NULL;

    //
    // Allocate a new array
    //

    pNewWindowList = (CIMWindow **)RtcAlloc( (m_lNumWindows + 1) * sizeof(CIMWindow *) );

    if ( pNewWindowList == NULL )
    {
        LOG((RTC_ERROR, "CIMWindowList::AddWindow - out of memory"));

        return E_OUTOFMEMORY;
    }

    if (m_pWindowList != NULL)
    {
        //
        // Copy old array contents
        //

        CopyMemory( pNewWindowList, m_pWindowList, m_lNumWindows * sizeof(CIMWindow *) );
    
        RtcFree( m_pWindowList );
    }

    pNewWindowList[m_lNumWindows] = pWindow;

    m_pWindowList = pNewWindowList;
    m_lNumWindows ++;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindowList::RemoveWindow( CIMWindow * pWindow )
{
    LOG((RTC_TRACE, "CIMWindowList::RemoveWindow"));

    LONG lIndex;

    if (m_pWindowList != NULL)
    {
        for (lIndex = 0; lIndex < m_lNumWindows; lIndex++)
        {
            if (m_pWindowList[lIndex] == pWindow)
            {
                //
                // Found window to remove. No need to reallocate the array,
                // just shift the old contents down.
                //

                if ((lIndex + 1) < m_lNumWindows)
                {
                    CopyMemory( &m_pWindowList[lIndex],
                                &m_pWindowList[lIndex+1],
                                (m_lNumWindows - lIndex - 1) * sizeof(CIMWindow *) );                    
                }

                m_lNumWindows--;
                m_pWindowList[m_lNumWindows] = NULL;

                return S_OK;
            }
        }
    }

    return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
//
//

CIMWindow * CIMWindowList::NewWindow( IRTCSession * pSession )
{
    LOG((RTC_TRACE, "CIMWindowList::NewWindow"));

    if (m_hRichEditLib == NULL)
    {
        //
        // Load the rich edit library if it hasn't been loaded yet
        //

        m_hRichEditLib = LoadLibrary(_T("riched20.dll"));

        if (m_hRichEditLib == NULL)
        {
            LOG((RTC_ERROR, "CIMWindowList::NewWindow - LoadLibrary failed 0x%x", HRESULT_FROM_WIN32(GetLastError())));

            return NULL;
        }
    }

    CIMWindow * pWindow = NULL;
    RECT rc;
    LONG lOffset;

    //
    // Cascade window start positions a bit
    //

    lOffset = (m_lNumWindows % 10) * 20;

    rc.top = 50 + lOffset;
    rc.left = 50 + lOffset;
    rc.right = 50 + lOffset + IM_WIDTH;
    rc.bottom = 50 + lOffset + IM_HEIGHT;

    // Get the monitor that has the largest area of intersecion with the
    // window rectangle. If the window rectangle intersects with no monitors
    // then we will use the nearest monitor.

    HMONITOR hMonitor = NULL;
    RECT rectWorkArea;
    BOOL fResult;
    int diffCord;

    hMonitor = MonitorFromRect( &rc, MONITOR_DEFAULTTONEAREST );

    LOG((RTC_INFO, "CIMWindowList::NewWindow - hMonitor [%p]", hMonitor));

    // Get the visible work area on the monitor

    if ( (hMonitor != NULL) && (hMonitor != INVALID_HANDLE_VALUE) )
    {      
        MONITORINFO monitorInfo;
        monitorInfo.cbSize = sizeof(MONITORINFO);

        fResult = GetMonitorInfo( hMonitor, &monitorInfo );

        rectWorkArea = monitorInfo.rcWork;

        DeleteObject( hMonitor );

        if (!fResult)
        {
            LOG((RTC_ERROR, "CIMWindowList::NewWindow - Failed GetMonitorInfo(%d)", 
                        GetLastError() ));
        }
    }
    else
    {
        // we can always fall back to non-multimon APIs if
        // MonitorFromRect failed.

        fResult = SystemParametersInfo(SPI_GETWORKAREA, 0, &rectWorkArea, 0);

        if (!fResult)
        {
            LOG((RTC_ERROR, "CIMWindowList::NewWindow - Failed SystemParametersInfo(%d)", 
                        GetLastError() ));
        }
    }   
      
    if (fResult)
    {
        LOG((RTC_INFO, "CIMWindowList::NewWindow - monitor work area is "
                    "%d, %d %d %d ",
                    rectWorkArea.left, rectWorkArea.top, 
                    rectWorkArea.right, rectWorkArea.bottom));

        // update x and y coordinates.

        // if top left is not visible, move it to the edge of the visible
        // area

        if (rc.left < rectWorkArea.left) 
        {
            rc.left = rectWorkArea.left;
        }

        if (rc.top < rectWorkArea.top)
        {
            rc.top = rectWorkArea.top;
        }

        // if bottom right corner is outside work area, we move the 
        // top left cornet back so that it becomes visible. Here the 
        // assumption is that the actual size is smaller than the 
        // visible work area.

        diffCord = rc.left + IM_WIDTH - rectWorkArea.right;

        if (diffCord > 0) 
        {
            rc.left -= diffCord;
        }

        diffCord = rc.top + IM_HEIGHT - rectWorkArea.bottom;

        if (diffCord > 0) 
        {
            rc.top -= diffCord;
        }

        rc.right = rc.left + IM_WIDTH;
        rc.bottom = rc.top + IM_HEIGHT;

        LOG((RTC_INFO, "CIMWindowList::NewWindow - new coords are "
                        "%d, %d %d %d ",
                        rc.left, rc.top, 
                        rc.right, rc.bottom));
    } 

    //
    // Create the window
    //

    pWindow = new CIMWindow(this);

    if (pWindow != NULL)
    {
        HRESULT hr;

        hr = AddWindow( pWindow );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CIMWindowList::NewWindow - AddWindow failed 0x%x", hr));

            delete pWindow;

            return NULL;
        }

        TCHAR   szString[0x40];

        szString[0] = _T('\0');

        LoadString(
            _Module.GetModuleInstance(),
            IDS_IM_WINDOW_TITLE,
            szString,
            sizeof(szString)/sizeof(szString[0]));

        pWindow->Create(NULL, rc, szString, WS_VISIBLE | WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN);

        pWindow->m_pSession = pSession;
    }

    return pWindow;
}

/////////////////////////////////////////////////////////////////////////////
//
//

CIMWindow * CIMWindowList::FindWindow( IRTCSession * pSession )
{
    LOG((RTC_TRACE, "CIMWindowList::FindWindow"));

    LONG lIndex;

    if (m_pWindowList != NULL)
    {
        for (lIndex = 0; lIndex < m_lNumWindows; lIndex++)
        {
            if (m_pWindowList[lIndex] != NULL)
            {
                if (m_pWindowList[lIndex]->m_pSession == pSession)
                {
                    return m_pWindowList[lIndex];
                }
            }
        }
    }

    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
//

BOOL CIMWindowList::IsDialogMessage( LPMSG lpMsg )
{
    //LOG((RTC_TRACE, "CIMWindowList::IsDialogMessage"));

    LONG lIndex;

    if (m_pWindowList != NULL)
    {
        for (lIndex = 0; lIndex < m_lNumWindows; lIndex++)
        {
            if (m_pWindowList[lIndex]->IsDialogMessage( lpMsg ))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CIMWindow
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//

CIMWindow::CIMWindow(CIMWindowList * pWindowList)
{
    LOG((RTC_TRACE, "CIMWindow::CIMWindow"));

    m_pIMWindowList = pWindowList;
    m_pSession = NULL;

    m_hIcon = NULL;
    m_hBkBrush = NULL;
    m_hMenu = NULL;

    m_bWindowActive = FALSE;
    m_bPlaySounds = TRUE;
    m_bNewWindow = TRUE;

    m_enStatus = RTCMUS_IDLE;

    m_szStatusText[0] = _T('\0');
}

/////////////////////////////////////////////////////////////////////////////
//
//

CIMWindow::~CIMWindow()
{
    LOG((RTC_TRACE, "CIMWindow::~CIMWindow"));
}


/////////////////////////////////////////////////////////////////////////////
//
//
/*
CWndClassInfo& CIMWindow::GetWndClassInfo() 
{ 
    LOG((RTC_TRACE, "CIMWindow::GetWndClassInfo"));

    static CWndClassInfo wc = 
    { 
        { sizeof(WNDCLASSEX), 0, StartWindowProc, 
          0, 0, NULL, NULL, NULL, NULL, NULL, g_szIMWindowClassName, NULL }, 
        NULL, NULL, IDC_ARROW, TRUE, 0, _T("") 
    }; 
    return wc;
}
*/

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT   hr;
    RECT      rcDummy;
    
    LOG((RTC_TRACE, "CIMWindow::OnCreate - enter"));

    ZeroMemory( &rcDummy, sizeof(RECT) );

    //
    // Load and set icons (both small and big)
    //
/*
    m_hIcon = LoadIcon(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(IDI_APPICON)
        );

    SetIcon(m_hIcon, FALSE);
    SetIcon(m_hIcon, TRUE);
*/
    //
    // Create brush
    //

    m_hBkBrush = GetSysColorBrush( COLOR_3DFACE );

    //
    // Create the display control
    //

    m_hDisplay.Create(RICHEDIT_CLASS, m_hWnd, rcDummy, NULL,
        WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_READONLY,
        WS_EX_CLIENTEDGE, IDC_IM_DISPLAY);

    m_hDisplay.SendMessage(EM_AUTOURLDETECT, TRUE, 0);
    m_hDisplay.SendMessage(EM_SETEVENTMASK, 0, ENM_LINK);
    m_hDisplay.SendMessage(EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cfDefault);  

    //
    // Create the edit control
    //

    m_hEdit.Create(RICHEDIT_CLASS, m_hWnd, rcDummy, NULL,
        WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_MULTILINE | ES_AUTOVSCROLL,
        WS_EX_CLIENTEDGE, IDC_IM_EDIT);  

    m_hEdit.SendMessage(EM_AUTOURLDETECT, TRUE, 0);
    m_hEdit.SendMessage(EM_SETEVENTMASK, 0, ENM_LINK | ENM_CHANGE);
    m_hEdit.SendMessage(EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cfDefault);

    //
    // Create the send button
    //

    TCHAR   szString[0x40];

    szString[0] = _T('\0');

    LoadString(
        _Module.GetModuleInstance(),
        IDS_IM_SEND,
        szString,
        sizeof(szString)/sizeof(szString[0]));

    m_hSendButton.Create(_T("BUTTON"), m_hWnd, rcDummy, szString,
        WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON | BS_DEFPUSHBUTTON,
        0, IDC_IM_SEND);

    //
    // Create a status control
    //

    HWND hStatusBar = CreateStatusWindow(
            WS_CHILD | WS_VISIBLE,
            NULL,
            m_hWnd,
            IDC_STATUSBAR);

    m_hStatusBar.Attach(hStatusBar);

    //
    // Create the menu
    //

    m_hMenu = LoadMenu( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDC_IM_MENU) );

    if ( m_hMenu )
    {
        SetMenu( m_hMenu );

        CheckMenuRadioItem( m_hMenu,
                            IDM_IM_TOOLS_LARGEST,
                            IDM_IM_TOOLS_SMALLEST,
                            IDM_IM_TOOLS_SMALLER,
                            MF_BYCOMMAND );

        CheckMenuItem( m_hMenu, IDM_IM_TOOLS_SOUNDS, MF_CHECKED );
    }

    //
    // pozition the controls/set the tab order
    //

    PositionWindows();

    LOG((RTC_TRACE, "CIMWindow::OnCreate - exit"));
    
    return 0; 
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIMWindow::OnDestroy - enter"));

    // Destroy windows objects

    if ( m_hIcon != NULL )
    {
        DeleteObject( m_hIcon );
        m_hIcon = NULL;
    }

    if ( m_hBkBrush != NULL )
    {
        DeleteObject( m_hBkBrush );
        m_hBkBrush = NULL;
    }

    if ( m_hMenu != NULL )
    {
        DestroyMenu( m_hMenu );
        m_hMenu = NULL;
    }

    // Terminate the session

    if ( m_pSession != NULL )
    {
        m_pSession->Terminate(RTCTR_NORMAL);
        m_pSession = NULL;
    }

    LOG((RTC_TRACE, "CIMWindow::OnDestroy - exiting"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIMWindow::OnSize - enter"));

    PositionWindows();

    LOG((RTC_TRACE, "CIMWindow::OnSize - exiting"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnSend(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIMWindow::OnSend - enter"));

    USES_CONVERSION;

    LONG lNumChars;

    //
    // Get the edit box length
    //

    lNumChars = m_hEdit.SendMessage( WM_GETTEXTLENGTH, 0, 0 );  

    if ( lNumChars < 1 )
    {
        LOG((RTC_TRACE, "CIMWindow::OnSend - nothing to send"));
    }
    else
    {
        LPTSTR szEditString = NULL;        

        szEditString = (LPTSTR)RtcAlloc( (lNumChars + 1) * sizeof(TCHAR) );

        if ( szEditString == NULL )
        {
            LOG((RTC_ERROR, "CIMWindow::OnSend - out of memory"));

            return 0;
        }

        //
        // Read the edit box
        //

        m_hEdit.SendMessage( WM_GETTEXT, (WPARAM)(lNumChars + 1), (LPARAM)szEditString );

        //
        // Empty the edit box
        //

        m_hEdit.SendMessage( WM_SETTEXT, 0, 0 );

        //
        // Display the outgoing message
        //

        BSTR bstr = NULL;        

        bstr = T2BSTR( szEditString );

        RtcFree( szEditString );
        szEditString = NULL;

        if ( bstr == NULL )
        {
            LOG((RTC_ERROR, "CIMWindow::OnSend - out of memory"));

            return 0;
        }

        DeliverMessage( NULL, bstr, FALSE );

        //
        // Send the message
        //

        HRESULT hr;        
        LONG lCookie = 0;
    
        hr = m_pSession->SendMessage( NULL, bstr, lCookie );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CIMWindow::OnSend - SendMessage failed 0x%x", hr));
        }
    
        SysFreeString( bstr );
        bstr = NULL;
    }

    //
    // Set focus back to the edit control
    //

    ::SetFocus( m_hEdit );

    LOG((RTC_TRACE, "CIMWindow::OnSend - exiting"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HDC hdc = (HDC)wParam;
    RECT rc;

    //
    // Fill the background
    //

    GetClientRect( &rc );

    FillRect( hdc, &rc, m_hBkBrush );

    return 1;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    //
    // If activating the window, set focus to the edit control and stop any flashing
    //

    if (LOWORD(wParam) != WA_INACTIVE)
    {
        ::SetFocus( m_hEdit );

        FLASHWINFO flashinfo;

        flashinfo.cbSize = sizeof( FLASHWINFO );
        flashinfo.hwnd = m_hWnd;
        flashinfo.dwFlags = FLASHW_STOP;
        flashinfo.uCount = 0;
        flashinfo.dwTimeout = 0;

        FlashWindowEx( &flashinfo );
    }

    m_bWindowActive = (LOWORD(wParam) != WA_INACTIVE);

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnGetDefID(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{   
    //
    // Return the default pushbutton
    //

    return MAKELRESULT(IDC_IM_SEND, DC_HASDEFID);
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnNextDlgCtl(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{   
    //
    // Set focus to the next control
    //

    if ( LOWORD(lParam) )
    {
        ::SetFocus( (HWND)wParam );
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnLink(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    //LOG((RTC_TRACE, "CIMWindow::OnLink - enter"));

    ENLINK * enlink;

    enlink = (ENLINK*)pnmh;

    if (enlink->msg == WM_LBUTTONDBLCLK)
    {
        LOG((RTC_TRACE, "CIMWindow::OnLink - WM_LBUTTONDBLCLK"));

        TEXTRANGE textrange;

        textrange.chrg = enlink->chrg;
        textrange.lpstrText = (LPTSTR)RtcAlloc( (enlink->chrg.cpMax - enlink->chrg.cpMin + 1) * sizeof(TCHAR) );

        if (textrange.lpstrText == NULL)
        {
            LOG((RTC_ERROR, "CIMWindow::OnLink - out of memory"));

            return 0;
        }
    
        if ( ::SendMessage( GetDlgItem( idCtrl ), EM_GETTEXTRANGE, 0, (LPARAM)&textrange ) )
        {
            LOG((RTC_INFO, "CIMWindow::OnLink - [%ws]", textrange.lpstrText));
        }   

        ShellExecute( NULL, NULL, textrange.lpstrText, NULL, NULL, SW_SHOWNORMAL);

        RtcFree( (LPVOID)textrange.lpstrText );

        return 1;
    }

    //LOG((RTC_TRACE, "CIMWindow::OnLink - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    //LOG((RTC_TRACE, "CIMWindow::OnChange - enter"));

    BOOL bSendStatus = FALSE;

    if ( m_hEdit.SendMessage( WM_GETTEXTLENGTH, 0, 0 ) )
    {
        if ( m_enStatus != RTCMUS_TYPING )
        {
            //
            // Set status to typing
            //

            LOG((RTC_INFO, "CIMWindow::OnChange - RTCMUS_TYPING"));

            m_enStatus = RTCMUS_TYPING;
            bSendStatus = TRUE;
        }
    }
    else
    {
        if ( m_enStatus != RTCMUS_IDLE )
        {
            //
            // Set status to idle
            //

            LOG((RTC_INFO, "CIMWindow::OnChange - RTCMUS_IDLE"));

            m_enStatus = RTCMUS_IDLE;
            bSendStatus = TRUE;
        }
    }

    if ( bSendStatus )
    {
        HRESULT hr;        
        LONG lCookie = 0;
    
        hr = m_pSession->SendMessageStatus( m_enStatus, lCookie );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CIMWindow::OnChange - SendMessageStatus failed 0x%x", hr));
        }
    }

    //LOG((RTC_TRACE, "CIMWindow::OnChange - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

DWORD CALLBACK CIMWindow::EditStreamCallback(
        DWORD_PTR dwCookie,
        LPBYTE    pbBuff,
        LONG      cb,
        LONG    * pcb)
{
    LOG((RTC_TRACE, "CIMWindow::EditStreamCallback - enter"));

    LOG((RTC_INFO, "CIMWindow::EditStreamCallback - dwCookie [%x]", dwCookie));
    LOG((RTC_INFO, "CIMWindow::EditStreamCallback - pbBuff [%x]", pbBuff));
    LOG((RTC_INFO, "CIMWindow::EditStreamCallback - cb [%d]", cb));

    HANDLE hFile = (HANDLE)dwCookie;
    DWORD dwBytesWritten;

    if (!WriteFile( hFile, pbBuff, cb, &dwBytesWritten, NULL ))
    {
        LOG((RTC_ERROR, "CIMWindow::EditStreamCallback - WriteFile failed %d", GetLastError()));

        *pcb = 0;

        return 0;
    }

    *pcb = dwBytesWritten;

    LOG((RTC_TRACE, "CIMWindow::EditStreamCallback - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnSaveAs(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIMWindow::OnSaveAs - enter"));

    TCHAR szFile[MAX_PATH];
    szFile[0] = _T('\0');

    TCHAR szFilter[256];
    ZeroMemory( szFilter, 256*sizeof(TCHAR) );

    if (!LoadString( _Module.GetResourceInstance(), IDS_IM_FILE_FILTER, szFilter, 256 ))
    {
        LOG((RTC_ERROR, "CIMWindow::OnSaveAs - LoadString failed %d", GetLastError()));

        return 0;
    }

    OPENFILENAME ofn;
    ZeroMemory( &ofn, sizeof(OPENFILENAME) );

    ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
    ofn.hwndOwner = m_hWnd;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH;

    WPARAM flags;

    if (GetSaveFileName( &ofn ))
    {
        LOG((RTC_TRACE, "CIMWindow::OnSaveAs - [%ws]", szFile));

        switch (ofn.nFilterIndex)
        {
        case 1:
            LOG((RTC_TRACE, "CIMWindow::OnSaveAs - Rich Text Format (RTF)"));

            flags = SF_RTF;
            break;

        case 2:
            LOG((RTC_TRACE, "CIMWindow::OnSaveAs - Text Document"));

            flags = SF_TEXT;
            break;

        case 3:
            LOG((RTC_TRACE, "CIMWindow::OnSaveAs - Unicode Text Document"));

            flags = SF_TEXT | SF_UNICODE;
            break;

        default:
            LOG((RTC_ERROR, "CIMWindow::OnSaveAs - unknown document type"));

            return 0;
        }
    }

    HANDLE hFile;
    
    hFile = CreateFile( szFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        LOG((RTC_ERROR, "CIMWindow::OnSaveAs - CreateFile failed %d", GetLastError()));

        return 0;
    }

    EDITSTREAM es;
    ZeroMemory( &es, sizeof(EDITSTREAM) );
    
    es.dwCookie = (DWORD_PTR)hFile;
    es.pfnCallback = CIMWindow::EditStreamCallback;

    m_hDisplay.SendMessage( EM_STREAMOUT, flags, (LPARAM)&es );

    CloseHandle( hFile );

    LOG((RTC_TRACE, "CIMWindow::OnSaveAs - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnClose(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIMWindow::OnClose - enter"));

    DestroyWindow();

    LOG((RTC_TRACE, "CIMWindow::OnClose - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnPlaySounds(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIMWindow::OnPlaySounds - enter"));

    m_bPlaySounds = !m_bPlaySounds;

    CheckMenuItem( m_hMenu, IDM_IM_TOOLS_SOUNDS, m_bPlaySounds ? MF_CHECKED : MF_UNCHECKED );

    LOG((RTC_TRACE, "CIMWindow::OnPlaySounds - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnTextSize(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIMWindow::OnTextSize - enter"));

    CHARFORMAT cf;

    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_SIZE;    

    switch ( wID )
    {
    case IDM_IM_TOOLS_LARGEST:
        CheckMenuRadioItem( m_hMenu,
                            IDM_IM_TOOLS_LARGEST,
                            IDM_IM_TOOLS_SMALLEST,
                            IDM_IM_TOOLS_LARGEST,
                            MF_BYCOMMAND );

        cf.yHeight = 320;
        break;

    case IDM_IM_TOOLS_LARGER:
        CheckMenuRadioItem( m_hMenu,
                            IDM_IM_TOOLS_LARGEST,
                            IDM_IM_TOOLS_SMALLEST,
                            IDM_IM_TOOLS_LARGER,
                            MF_BYCOMMAND );

        cf.yHeight = 280;
        break;

    case IDM_IM_TOOLS_MEDIUM:
        CheckMenuRadioItem( m_hMenu,
                            IDM_IM_TOOLS_LARGEST,
                            IDM_IM_TOOLS_SMALLEST,
                            IDM_IM_TOOLS_MEDIUM,
                            MF_BYCOMMAND );

        cf.yHeight = 240;
        break;

    case IDM_IM_TOOLS_SMALLER:
        CheckMenuRadioItem( m_hMenu,
                            IDM_IM_TOOLS_LARGEST,
                            IDM_IM_TOOLS_SMALLEST,
                            IDM_IM_TOOLS_SMALLER,
                            MF_BYCOMMAND );

        cf.yHeight = 200;
        break;

    case IDM_IM_TOOLS_SMALLEST:
        CheckMenuRadioItem( m_hMenu,
                            IDM_IM_TOOLS_LARGEST,
                            IDM_IM_TOOLS_SMALLEST,
                            IDM_IM_TOOLS_SMALLEST,
                            MF_BYCOMMAND );

        cf.yHeight = 160;
        break;

    default:
        LOG((RTC_ERROR, "CIMWindow::OnTextSize - invalid text size"));

        return 0;
    }

    m_hDisplay.SendMessage(EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
    m_hEdit.SendMessage(EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);

    LOG((RTC_TRACE, "CIMWindow::OnTextSize - exit"));

    return 0;
}

///////////////////////////////////////////////////////////////////////////////
// PositionWindows
//      Positions and sizes all the controls to their "initial" position
//  This function also establishes the right tab order

void CIMWindow::PositionWindows()
{
    RECT rcClient;
    RECT rcWnd;

    #define EDGE_SPACING  10
    #define BUTTON_HEIGHT 60
    #define BUTTON_WIDTH  60
    #define STATUS_HEIGHT 20

    GetClientRect( &rcClient );

    rcClient.top += EDGE_SPACING;
    rcClient.bottom -= EDGE_SPACING + STATUS_HEIGHT;
    rcClient.left += EDGE_SPACING;
    rcClient.right -= EDGE_SPACING;

    //
    // Display control
    //

    rcWnd = rcClient;

    rcWnd.bottom -= EDGE_SPACING + BUTTON_HEIGHT;

    m_hDisplay.SetWindowPos( HWND_TOP,
        rcWnd.left, rcWnd.top,
        rcWnd.right - rcWnd.left,
        rcWnd.bottom - rcWnd.top,
        0
        );

    //
    // Edit control
    //

    rcWnd = rcClient;

    rcWnd.top = rcWnd.bottom - BUTTON_HEIGHT;
    rcWnd.right -= BUTTON_WIDTH + EDGE_SPACING;

    m_hEdit.SetWindowPos( m_hDisplay,
        rcWnd.left, rcWnd.top,
        rcWnd.right - rcWnd.left,
        rcWnd.bottom - rcWnd.top,
        0
        );

    //
    // Send button control
    //

    rcWnd = rcClient;

    rcWnd.top = rcWnd.bottom - BUTTON_HEIGHT;
    rcWnd.left = rcWnd.right - BUTTON_WIDTH;

    m_hSendButton.SetWindowPos( m_hEdit,
        rcWnd.left, rcWnd.top,
        rcWnd.right - rcWnd.left,
        rcWnd.bottom - rcWnd.top,
        0
        );

    //
    // Status bar
    //

    m_hStatusBar.SetWindowPos( m_hSendButton,
        0, 0, 0, 0,
        0
        );
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindow::GetFormattedNameFromParticipant( IRTCParticipant * pParticipant, BSTR * pbstrName )
{
    LOG((RTC_TRACE, "CIMWindow::GetFormattedNameFromParticipant - enter"));

    HRESULT hr = S_OK;

    // get the user name

    hr = pParticipant->get_Name( pbstrName );

    if ( SUCCEEDED(hr) )
    {
        if ( wcscmp( *pbstrName, L"")==0 )
        {
            // the user name is blank

            SysFreeString( *pbstrName );
            *pbstrName = NULL;

            hr = E_FAIL;
        }
    }

    if ( FAILED(hr) )
    {
        // if the user name is no good, get the user URI

        BSTR bstrURI = NULL;

        hr = pParticipant->get_UserURI( &bstrURI );

        if ( SUCCEEDED(hr) )
        {
            if ( wcscmp(bstrURI, L"")==0 )
            {
                // the user URI is blank

                *pbstrName = NULL;

                hr = E_FAIL;
            }
            else
            {
                // good user URI, encapsulate it in <> to make it look better

                *pbstrName = SysAllocStringLen( L"<", wcslen( bstrURI ) + 2 );

                if ( *pbstrName != NULL )
                {
                    wcscat( *pbstrName, bstrURI );
                    wcscat( *pbstrName, L">" );
                }
                else
                {
                    *pbstrName = NULL;

                    hr = E_FAIL;
                }                    
            }

            SysFreeString( bstrURI );
            bstrURI = NULL;
        }
    }
    
    LOG((RTC_TRACE, "CIMWindow::GetFormattedNameFromParticipant - exit"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindow::DeliverMessage( IRTCParticipant * pParticipant, BSTR bstrMessage, BOOL bIncoming )
{
    LOG((RTC_TRACE, "CIMWindow::DeliverMessage"));

    USES_CONVERSION;

    //
    // Set selection to end of the display box
    //

    int nLastChar =  (int)m_hDisplay.SendMessage( WM_GETTEXTLENGTH, 0, 0 );

    CHARRANGE charRange = {0};
    charRange.cpMin = charRange.cpMax = nLastChar + 1;

    m_hDisplay.SendMessage( EM_EXSETSEL, 0, (LPARAM)&charRange );

    //
    // Set format for the "from text"
    //

    CHARFORMAT cf;
    PARAFORMAT pf;

    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_COLOR;
    cf.dwEffects = 0;
    cf.crTextColor = RGB(0,128,128);

    m_hDisplay.SendMessage(EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);

    pf.cbSize = sizeof(PARAFORMAT);
    pf.dwMask = PFM_STARTINDENT;
    pf.dxStartIndent = 50;

    m_hDisplay.SendMessage(EM_SETPARAFORMAT, 0, (LPARAM)&pf);

    //
    // Add the "from text"
    //

    BSTR bstrName = NULL;
    HRESULT hr = E_FAIL;
    TCHAR   szString[0x40];

    if ( pParticipant != NULL )
    {   
        hr = GetFormattedNameFromParticipant( pParticipant, &bstrName );
    }

    if ( FAILED(hr) && (!bIncoming) )
    {
        // get to local user name

        hr = get_SettingsString( SS_USER_DISPLAY_NAME, &bstrName );

        if ( SUCCEEDED(hr) )
        {
            if ( wcscmp(bstrName, L"")==0 )
            {
                // the display name is blank

                SysFreeString( bstrName );
                bstrName = NULL;

                hr = E_FAIL;
            }                                    
        }
    }

    if ( SUCCEEDED(hr) )
    {
        // got a good name       

        m_hDisplay.SendMessage( EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)W2T(bstrName) );            

        SysFreeString( bstrName );
        bstrName = NULL;
    }
    else
    {
        // didn't get a good name, use something generic
        szString[0] = _T('\0');

        LoadString(
                _Module.GetModuleInstance(),
                bIncoming ? IDS_IM_INCOMING_MESSAGE : IDS_IM_OUTGOING_MESSAGE,
                szString,
                sizeof(szString)/sizeof(szString[0]));    
        
        m_hDisplay.SendMessage( EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)szString );
    }       

    szString[0] = _T('\0');

    LoadString(
            _Module.GetModuleInstance(),
            IDS_IM_SAYS,
            szString,
            sizeof(szString)/sizeof(szString[0]));    
    
    m_hDisplay.SendMessage( EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)szString );

    //
    // Set format for the "message text"
    //

    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_COLOR;
    cf.dwEffects = CFE_AUTOCOLOR;
    cf.crTextColor = 0;

    m_hDisplay.SendMessage(EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);

    pf.cbSize = sizeof(PARAFORMAT);
    pf.dwMask = PFM_STARTINDENT;
    pf.dxStartIndent = 200;

    m_hDisplay.SendMessage(EM_SETPARAFORMAT, 0, (LPARAM)&pf);

    //
    // Add the "message text"
    //

    m_hDisplay.SendMessage( EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)W2T(bstrMessage) );

    //
    // Add line break
    //

    m_hDisplay.SendMessage( EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)_T("\n") );

    //
    // Scroll the display to the bottom
    //

    m_hDisplay.SendMessage( WM_VSCROLL, SB_BOTTOM, 0 );

    //
    // Set status text
    //

    TCHAR szTime[64];
    TCHAR szDate[64];
    TCHAR szAt[64];
    TCHAR szOn[64];
    TCHAR szStatus[64];

    szStatus[0] = _T('\0');

    LoadString(
            _Module.GetModuleInstance(),
            bIncoming ? IDS_IM_MESSAGE_RECEIVED : IDS_IM_MESSAGE_SENT,
            szStatus,
            sizeof(szStatus)/sizeof(szStatus[0])); 

    szAt[0] = _T('\0');

    LoadString(
            _Module.GetModuleInstance(),
            IDS_IM_AT,
            szAt,
            sizeof(szAt)/sizeof(szAt[0])); 

    szOn[0] = _T('\0');

    LoadString(
            _Module.GetModuleInstance(),
            IDS_IM_ON,
            szOn,
            sizeof(szOn)/sizeof(szOn[0])); 
    
    if ( GetTimeFormat(
            LOCALE_USER_DEFAULT, // locale
            TIME_NOSECONDS,     // options
            NULL,               // time
            NULL,               // time format string
            szTime,             // formatted string buffer
            64
            ) )
    {
        if ( GetDateFormat(
                LOCALE_USER_DEFAULT,    // locale
                DATE_SHORTDATE,         // options
                NULL,                   // date
                NULL,                   // date format
                szDate,                 // formatted string buffer
                64
                ) )
        {
            _sntprintf( m_szStatusText, 256, _T("%s %s %s %s %s."),
                    szStatus, szAt, szTime, szOn, szDate );
        }
        else
        {
            _sntprintf( m_szStatusText, 256, _T("%s %s %s."),
                    szStatus, szAt, szTime );
        }
    }
    else
    {
        _sntprintf( m_szStatusText, 256, _T("%s."),
                    szStatus );
    }

    m_hStatusBar.SendMessage(WM_SETTEXT, 0, (LPARAM)m_szStatusText);

    if ( bIncoming )
    {
        //
        // Play a sound
        //

        if ( m_bPlaySounds && (m_bNewWindow || !m_bWindowActive) )
        {
            hr = m_pIMWindowList->m_pClient->PlayRing( RTCRT_MESSAGE, TRUE );
        }

        //
        // If the window isn't active, flash it
        //

        if ( !m_bWindowActive )
        {
            FLASHWINFO flashinfo;

            flashinfo.cbSize = sizeof( FLASHWINFO );
            flashinfo.hwnd = m_hWnd;
            flashinfo.dwFlags = FLASHW_TIMER | FLASHW_ALL;
            flashinfo.uCount = 0;
            flashinfo.dwTimeout = 0;

            FlashWindowEx( &flashinfo );
        }
    }

    m_bNewWindow = FALSE;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindow::DeliverUserStatus( IRTCParticipant * pParticipant, RTC_MESSAGING_USER_STATUS enStatus )
{
    LOG((RTC_TRACE, "CIMWindow::DeliverUserStatus"));
    
    HRESULT hr;   
    
    switch ( enStatus )
    {
    case RTCMUS_IDLE:
        // restore the old status text
        m_hStatusBar.SendMessage(WM_SETTEXT, 0, (LPARAM)m_szStatusText);

        break;

    case RTCMUS_TYPING:
        {
            BSTR bstrName = NULL;  
            
            hr = GetFormattedNameFromParticipant( pParticipant, &bstrName );

            if ( SUCCEEDED(hr) )
            {
                TCHAR   szString[0x40];

                szString[0] = _T('\0');

                LoadString(
                    _Module.GetModuleInstance(),
                    IDS_IM_TYPING,
                    szString,
                    sizeof(szString)/sizeof(szString[0]));

                LPTSTR szStatusText = NULL;

                szStatusText = (LPTSTR)RtcAlloc( 
                    (_tcslen(szString) + wcslen(bstrName) + 1) * sizeof(TCHAR)
                    );                    

                if ( szStatusText != NULL )
                {
                    _tcscpy( szStatusText, W2T(bstrName) );
                    _tcscat( szStatusText, szString );

                    m_hStatusBar.SendMessage(WM_SETTEXT, 0, (LPARAM)szStatusText);

                    RtcFree( szStatusText );
                } 
                
                SysFreeString( bstrName );
                bstrName = NULL;
            }
        }

        break;

    default:
        LOG((RTC_ERROR, "CIMWindow::DeliverUserStatus - "
            "invalid user status"));
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindow::DeliverState( RTC_SESSION_STATE SessionState )
{
    LOG((RTC_TRACE, "CIMWindow::DeliverState"));

    //
    // Update participants
    //

    HRESULT hr;
    IRTCEnumParticipants * pEnumPart = NULL;
    IRTCParticipant      * pPart = NULL;

    TCHAR   szString[0x40];

    szString[0] = _T('\0');

    LoadString(
        _Module.GetModuleInstance(),
        IDS_IM_WINDOW_TITLE,
        szString,
        sizeof(szString)/sizeof(szString[0]));

    if ( m_pSession != NULL )
    {
        hr = m_pSession->EnumerateParticipants( &pEnumPart );

        if ( SUCCEEDED(hr) )
        {
            while ( S_OK == pEnumPart->Next( 1, &pPart, NULL ) )
            {
                BSTR bstrName = NULL;

                hr = GetFormattedNameFromParticipant( pPart, &bstrName );

                pPart->Release();
                pPart = NULL; 

                if ( SUCCEEDED(hr) )
                {
                    LPTSTR szWindowTitle = NULL;

                    szWindowTitle = (LPTSTR)RtcAlloc( 
                        (_tcslen(szString) + _tcslen(_T(" - ")) + wcslen(bstrName) + 1) * sizeof(TCHAR)
                        );                    

                    if ( szWindowTitle != NULL )
                    {
                        _tcscpy( szWindowTitle, W2T(bstrName) );
                        _tcscat( szWindowTitle, _T(" - ") );
                        _tcscat( szWindowTitle, szString );

                        SetWindowText( szWindowTitle );

                        RtcFree( szWindowTitle );
                    }

                    SysFreeString( bstrName );
                    bstrName = NULL;

                    break; // just get one for now
                }                                            
            }

            pEnumPart->Release();
            pEnumPart = NULL;
        }
    }

    if ( SessionState == RTCSS_DISCONNECTED )
    {
        //
        // Set status text
        //

        m_szStatusText[0] = _T('\0');

        LoadString(
            _Module.GetModuleInstance(),
            IDS_IM_DISCONNECTED,
            m_szStatusText,
            sizeof(m_szStatusText)/sizeof(m_szStatusText[0]));

        m_hStatusBar.SendMessage(WM_SETTEXT, 0, (LPARAM)m_szStatusText);

        //
        // Disable the edit box and send button
        //

        m_hEdit.EnableWindow(FALSE);
        m_hSendButton.EnableWindow(FALSE);

        //
        // Empty the edit box
        //

        m_hEdit.SendMessage( WM_SETTEXT, 0, 0 );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\knob.h ===
// knob.h : Declaration of CKnobCtl
//  Inspired from CDPlayer code written by dstewart

#pragma once

#include "stdafx.h"

#define WC_KNOB     L"RTC_Knob"

typedef CWinTraitsOR<WS_TABSTOP, 0, CControlWinTraits> CKnobTraits;

/////////////////////////////////////////////////////////////////////////////
// CKnobCtl

class CKnobCtl : 
    public CWindowImpl<CKnobCtl, CWindow, CKnobTraits>
{

public:
    CKnobCtl(
        UINT    nResRest,
        UINT    nResHot,
        UINT    nResDis,
        UINT    nResLightBright,
        UINT    nResLightDim,
        UINT    nResLightDis,
        UINT    nResLightMask);

    ~CKnobCtl();

    enum {
        TID_TRACK = 1,
        TID_FLASH
    };

    DECLARE_WND_CLASS(WC_KNOB)

BEGIN_MSG_MAP(CKnobCtl)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    MESSAGE_HANDLER(WM_GETDLGCODE, OnGetDlgCode)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
    MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
    MESSAGE_HANDLER(WM_RBUTTONDOWN, OnRightButtonDown)
    MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLeftButtonDown)
    MESSAGE_HANDLER(WM_RBUTTONUP, OnButtonUp)
    MESSAGE_HANDLER(WM_LBUTTONUP, OnButtonUp)
    MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)
    MESSAGE_HANDLER(WM_ENABLE, OnEnable)
    MESSAGE_HANDLER(TBM_SETPOS, OnSetPos);
    MESSAGE_HANDLER(TBM_GETPOS, OnGetPos);
END_MSG_MAP()

    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnKillFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnGetDlgCode(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnEraseBackground(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnRightButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnLeftButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnEnable(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnSetPos(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnGetPos(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

public:

    void  LoadAllResources(        
        UINT    nResRest,
        UINT    nResHot,
        UINT    nResDis,
        UINT    nResLightBright,
        UINT    nResLightDim,
        UINT    nResLightDis,
        UINT    nResLightMask);

    HWND  Create(
        HWND    hParent,
        int     x,
        int     y,
        UINT    nID
        );

    void SetRange(DWORD dwRange) {m_dwRange = dwRange;}
    void SetPosition(DWORD dwPosition, BOOL fNotify);
    
    DWORD GetRange() {return m_dwRange;}
    DWORD GetPosition() {return m_dwCurPosition;}

    void SetPalette(HPALETTE hPalette) {m_hPalette = hPalette;}
    void SetBackgroundPalette(BOOL bBackgroundPalette) {m_bBackgroundPalette = bBackgroundPalette;}

    void  OnButtonDown(int x, int y);

    void  OnTrackTimer();
    void  OnFlashTimer();

    BOOL  ComputeCursor(int deltaX, int deltaY, int maxdist);

    void  DrawArc(HDC hdc, RECT rect, double start, double end);
    void  SetAudioLevel(double level);

    void  Draw(HDC hdc);
    void  KMaskBlt(HDC hdcDest, int x, int y, int width, int height, 
                   HDC hdcSource, int xs, int ys, 
                   HBITMAP hMask, int xm, int ym, DWORD dwDummy);

private:

    int         m_nID;
    
    int         m_nLightX;
    int         m_nLightY;
    
    DWORD       m_dwRange;
    DWORD       m_dwPosition;
    DWORD       m_dwCurPosition;
    
    double      m_trackdegree;

    double      m_AudioLevel;
    
    BOOL        m_fDim;
    BOOL        m_fFastKnob;

    BOOL        m_fEnabled;

    int         m_nLightWidth;
    int         m_nLightHeight;
    int         m_nKnobWidth;
    int         m_nKnobHeight;

    HANDLE      m_hKnob;
    HANDLE      m_hKnobTab;
    HANDLE      m_hKnobDisabled;
    HANDLE      m_hLight;
    HANDLE      m_hLightDisabled;
    HANDLE      m_hLightBright;
    HANDLE      m_hLightMask;

    HPALETTE    m_hPalette;
    BOOL        m_bBackgroundPalette;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\knob.cpp ===
// knob.cpp : Implementation of CKnobCtl
//  Inspired from CDPlayer code written by dstewart


#include "stdafx.h"
#include "knob.h"

#define LIGHT_OFFSET 13
#define RADIAN_45DEG  0.785398163397448309615
#define RADIAN_90DEG  1.57079632679489661923
#define RADIAN_135DEG 2.356194490192344899999999999925
#define DEGREE_CONVERTER 57.295779513082320876846364344191
#define RADIAN_CONVERTER 0.017453292519943295769222222222222

#define TRACK_TICK 5
#define FAST_TRACK_TICK 1
#define TRACK_DEGREES_PER_TICK 10

#define FLASH_TICK      150
#define KEYBOARD_STEP   3000
    


// Constructor
// 

CKnobCtl::CKnobCtl(
        UINT    nResRest,
        UINT    nResHot,
        UINT    nResDis,
        UINT    nResLightBright,
        UINT    nResLightDim,
        UINT    nResLightDis,
        UINT    nResLightMask)
{
    m_nID = 0;
    m_nLightX = 0;
    m_nLightY = 0;
    m_dwRange = 0xFFFF;
    m_dwPosition = 0;
    m_dwCurPosition = 0;
    m_fDim = TRUE;
    m_fEnabled = TRUE;

    m_nLightWidth = 0;
    m_nLightHeight = 0;
    m_nKnobWidth = 0;
    m_nKnobHeight = 0;

    m_hKnob = NULL;
    m_hKnobTab = NULL;
    m_hKnobDisabled = NULL;
    m_hLight = NULL;
    m_hLightBright = NULL;
    m_hLightDisabled = NULL;
    m_hLightMask = NULL;

    m_hPalette = NULL;
    m_bBackgroundPalette = FALSE;

    m_AudioLevel = 0.0;
    
    // tweak some fields of the WNDCLASSEX structure
    //
    CWndClassInfo&  wci = GetWndClassInfo();

    // if the wc hasn't already been registered, update it
    if(!wci.m_atom)
    {
        // brush (doesn't really matter, I think
        wci.m_wc.hbrBackground = (HBRUSH)(CTLCOLOR_DLG + 1);

        // cursor (treated differently, ATL "feature")
        wci.m_bSystemCursor = FALSE;
        wci.m_lpszCursorID = MAKEINTRESOURCE(IDC_VOLHAND);
    }

    // Load bitmaps
    LoadAllResources(
        nResRest,
        nResHot,
        nResDis,
        nResLightBright,
        nResLightDim,
        nResLightDis,
        nResLightMask);
}


// Destructor
// 

CKnobCtl::~CKnobCtl()
{
    if(m_hLight)
    {
        GlobalFree(m_hLight);
    }
    if(m_hLightBright)
    {
        GlobalFree(m_hLightBright);
    }
    if(m_hLightDisabled)
    {
        GlobalFree(m_hLightDisabled);
    }
    if(m_hKnob)
    {
        GlobalFree(m_hKnob);
    }
    if(m_hKnobTab)
    {
        GlobalFree(m_hKnobTab);
    }
    if(m_hKnobDisabled)
    {
        GlobalFree(m_hKnobDisabled);
    }
    if(m_hLightMask)
    {
        DeleteObject(m_hLightMask);
    }
}


// LoadAllResources
// 

void CKnobCtl::LoadAllResources(        
        UINT    nResRest,
        UINT    nResHot,
        UINT    nResDis,
        UINT    nResLightBright,
        UINT    nResLightDim,
        UINT    nResLightDis,
        UINT    nResLightMask)
{
    HBITMAP hbmpTemp;

    //
    // Load all bitmaps and convert them to DIBs
    //
    hbmpTemp = (HBITMAP)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(nResRest),
        IMAGE_BITMAP,
        0,
        0,
        LR_CREATEDIBSECTION);
    
    if(hbmpTemp)
    {
        m_hKnob = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
        
        BITMAP bm;
        
        GetObject(hbmpTemp,sizeof(bm),&bm);
        
        m_nKnobWidth = bm.bmWidth;
        m_nKnobHeight = bm.bmHeight;

        DeleteObject(hbmpTemp);
    }

    hbmpTemp = (HBITMAP)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(nResHot),
        IMAGE_BITMAP,
        0,
        0,
        LR_CREATEDIBSECTION);

    if(hbmpTemp)
    {
        m_hKnobTab = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);

        DeleteObject(hbmpTemp);
    }
    
    hbmpTemp = (HBITMAP)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(nResDis),
        IMAGE_BITMAP,
        0,
        0,
        LR_CREATEDIBSECTION);

    if(hbmpTemp)
    {
        m_hKnobDisabled = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);

        DeleteObject(hbmpTemp);
    }

    hbmpTemp = (HBITMAP)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(nResLightDim),
        IMAGE_BITMAP,
        0,
        0,
        LR_CREATEDIBSECTION);
    
    if(hbmpTemp)
    {
        m_hLight = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
        
        BITMAP bm;
        
        GetObject(hbmpTemp,sizeof(bm),&bm);
        
        m_nLightWidth = bm.bmWidth;
        m_nLightHeight = bm.bmHeight;
        
        DeleteObject(hbmpTemp);
    }

    hbmpTemp = (HBITMAP)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(nResLightBright),
        IMAGE_BITMAP,
        0,
        0,
        LR_CREATEDIBSECTION);
    
    if(hbmpTemp)
    {
        m_hLightBright = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);

        DeleteObject(hbmpTemp);
    }

    hbmpTemp = (HBITMAP)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(nResLightDis),
        IMAGE_BITMAP,
        0,
        0,
        LR_CREATEDIBSECTION);
    
    if(hbmpTemp)
    {
        m_hLightDisabled = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);

        DeleteObject(hbmpTemp);
    }

    CKnobCtl::m_hLightMask = (HBITMAP)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(nResLightMask),
        IMAGE_BITMAP,
        0,
        0,
        LR_MONOCHROME);

}


HWND CKnobCtl::Create(
    HWND    hParent,
    int     x,
    int     y,
    UINT    nID
    )
{
    RECT    rectPos;

    rectPos.left = x;
    rectPos.top = y;

    rectPos.right = rectPos.left + m_nKnobWidth;
    rectPos.bottom = rectPos.top + m_nKnobHeight;
    
    return CWindowImpl<CKnobCtl, CWindow, CKnobTraits>::Create(
            hParent,
            rectPos,
            NULL,
            0,
            0,
            nID);
}


// OnCreate
// 

LRESULT CKnobCtl::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // init the ID
    m_nID = GetDlgCtrlID();

//    HRGN    hRegion = CreateEllipticRgn(
//        0, 
//        0, 
//        m_nKnobWidth+1,
//        m_nKnobHeight+1
//        );

//    SetWindowRgn(hRegion, FALSE);

    return 0;
}


// OnSetFocus
// 

LRESULT CKnobCtl::OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ::SendMessage(GetParent(),DM_SETDEFID,m_nID,0);

    m_fDim = FALSE;
    
    InvalidateRect(NULL,FALSE);
    UpdateWindow();

    SetTimer(TID_FLASH, FLASH_TICK);

    return 0;
}

// OnKillFocus
// 

LRESULT CKnobCtl::OnKillFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    KillTimer(TID_FLASH);
    
    m_fDim = TRUE;
    
    InvalidateRect(NULL,FALSE);
    UpdateWindow();

    return 0;
}

// OnGetDlgCode
// 

LRESULT CKnobCtl::OnGetDlgCode(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // yes, we need arrows
    return (DLGC_WANTARROWS);
}

// OnEraseBackground
// 

LRESULT CKnobCtl::OnEraseBackground(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // do nothing
    return 1;
}

// OnPaint
// 

LRESULT CKnobCtl::OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HDC hdc;
    PAINTSTRUCT ps;

    hdc = BeginPaint( &ps );

    Draw(hdc);

    EndPaint(&ps);
    
    return 0;
}


// OnKeyDown
// 

LRESULT CKnobCtl::OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

    int nVirtKey = (int)wParam;

    DWORD dwCurrent = GetPosition();

    switch (nVirtKey)
    {
    case VK_LEFT :
    case VK_DOWN :
        {
            if (dwCurrent - KEYBOARD_STEP > 65535)
            {
                dwCurrent = KEYBOARD_STEP;
            }
            SetPosition(dwCurrent - KEYBOARD_STEP,TRUE);

            NMHDR nmhdr;
            nmhdr.hwndFrom = m_hWnd;
            nmhdr.idFrom = m_nID;
            nmhdr.code = TRUE;

            ::SendMessage(GetParent(),WM_NOTIFY,(WPARAM)m_nID,(LPARAM)&nmhdr);
        }
        break;
    
    case VK_RIGHT :
    case VK_UP :
        {
            if (dwCurrent + KEYBOARD_STEP > 65535)
            {
                dwCurrent = 65535 - KEYBOARD_STEP;
            }
            SetPosition(dwCurrent + KEYBOARD_STEP,TRUE);

            NMHDR nmhdr;
            nmhdr.hwndFrom = m_hWnd;
            nmhdr.idFrom = m_nID;
            nmhdr.code = TRUE;

            ::SendMessage(GetParent(),WM_NOTIFY,(WPARAM)m_nID,(LPARAM)&nmhdr);
         }
         break;

    default:
        {
            //not a key we want ... tell our parent about it
            ::SendMessage(GetParent(),WM_KEYDOWN,wParam,lParam);
        }
        break;
    } //end switch

    return 0;
}


// OnRightButtonDown
// 

LRESULT CKnobCtl::OnRightButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_fFastKnob = TRUE;

    OnButtonDown(LOWORD(lParam),HIWORD(lParam));
    OnMouseMove(0, 0, lParam,bHandled);
    
    return 0;
}


// OnLeftButtonDown
// 

LRESULT CKnobCtl::OnLeftButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_fFastKnob = FALSE;

    OnButtonDown(LOWORD(lParam),HIWORD(lParam));
    OnMouseMove(0, 0, lParam,bHandled);
    
    return 0;
}


// OnButtonUp
// 

LRESULT CKnobCtl::OnButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    KillTimer(TID_FLASH);
    KillTimer(TID_TRACK);

    //we want to be sure the light is dim when we're done
    if (!m_fDim)
    {
        m_fDim = TRUE;
        InvalidateRect(NULL,FALSE);
        UpdateWindow();
    }

    ReleaseCapture();
    
    return 0;
}

// OnButtonDown
// 

void CKnobCtl::OnButtonDown(int x, int y)
{
    SetCapture();

    m_fDim = FALSE;

    InvalidateRect(NULL,FALSE);
    UpdateWindow();

    SetTimer(TID_FLASH,FLASH_TICK);
}



// OnMouseMove
// 

LRESULT CKnobCtl::OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    int x = LOWORD(lParam);
    int y = HIWORD(lParam);

    if (GetCapture()==m_hWnd)
    {
        //do the calculations as if 0,0 were the center of the control,
        //then translate to gdi coordinates later (0,0 = top left of control in gdi)
        
        RECT rect;
        GetClientRect(&rect);
            
        int nWidth = rect.right - rect.left;
        int nHeight = rect.bottom - rect.top;

        int maxdist = (nWidth / 2) + 3;
        int radius = (nWidth / 2) - LIGHT_OFFSET;

        //convert to short to force negative numbers for coordinates
        short sx = (short)x;
        short sy = (short)y;

        int deltaX = sx - (nWidth / 2);
        int deltaY = sy - (nHeight / 2);

        ComputeCursor(deltaX, deltaY, maxdist);

        double angle = atan2(deltaY,deltaX);
        double degrees = angle * DEGREE_CONVERTER;

        degrees = degrees + 225;

        if (degrees < 0) 
        {
            degrees = 0;
        }

        if (degrees >= 360)
        {
            degrees = degrees - 360;
        }

        double percentage = degrees / 270;

        m_dwPosition = (DWORD)(m_dwRange * percentage);

        //special-case the "dead zone"
        if ((degrees >= 270) && (degrees <= 315))
        {
            m_dwPosition = m_dwRange;
        }

        if (degrees > 315)
        {
            m_dwPosition = 0;
        }

        if (m_fFastKnob)
        {
            SetTimer(TID_TRACK,FAST_TRACK_TICK);
        }
        else
        {
            SetTimer(TID_TRACK,TRACK_TICK);
        }
    }

    return 0;
}


// OnTimer
// 

LRESULT CKnobCtl::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    switch(wParam)
    {
    case TID_FLASH:
        
        OnFlashTimer();
    
        break;
    
    case TID_TRACK:

        OnTrackTimer();

        break;
    }

    return 0;
}

// OnEnable
// 

LRESULT CKnobCtl::OnEnable(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    BOOL bNeedUpdate;

    bNeedUpdate = (m_fEnabled && !wParam) 
                ||(!m_fEnabled && wParam);
    
    m_fEnabled = (BOOL)wParam;

    if(bNeedUpdate)
    {
        InvalidateRect(NULL,FALSE);
        UpdateWindow();
    }

    return 0;
}


// OnSetPos
// 

LRESULT CKnobCtl::OnSetPos(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SetPosition((DWORD)lParam, FALSE);

    return 0;
}

// OnGetPos
// 

LRESULT CKnobCtl::OnGetPos(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    return (LRESULT)GetPosition();
}

// OnFlashTimer
// 

void CKnobCtl::OnFlashTimer()
{
    m_fDim = !m_fDim;
        
    InvalidateRect(NULL,FALSE);
    UpdateWindow();
}


// OnTrackTimer
// 

void CKnobCtl::OnTrackTimer()
{
    RECT rect;

    GetClientRect(&rect);
    
    int nWidth = rect.right - rect.left;
    int radius = (nWidth / 2) - LIGHT_OFFSET;

    double degree = ((double)m_dwPosition / m_dwRange) * 270;
    degree = degree + 135;

    if (abs((int)m_trackdegree-(int)degree) < TRACK_DEGREES_PER_TICK)
    {
        m_trackdegree = degree;

        KillTimer(TID_TRACK);
    }
    else
    {
        if (m_trackdegree > degree)
        {
            m_trackdegree -= TRACK_DEGREES_PER_TICK;
        }
        else
        {
            m_trackdegree += TRACK_DEGREES_PER_TICK;
        }
    }

    double angle = m_trackdegree * RADIAN_CONVERTER;

    double fLightX = radius * cos(angle);
    double fLightY = radius * sin(angle);

    //convert to proper gdi coordinates
    m_nLightX = ((int)fLightX) - (m_nLightWidth / 2) + (nWidth / 2);
    m_nLightY = ((int)fLightY) - (m_nLightHeight / 2) + (nWidth / 2);

    InvalidateRect(NULL,FALSE);
    UpdateWindow();

    degree = m_trackdegree - 135;
    
    if (degree < 0) degree = degree + 360;
    
    double percentage = degree / 270;
    
    m_dwCurPosition = (DWORD)(m_dwRange * percentage);

    NMHDR nmhdr;
    nmhdr.hwndFrom = m_hWnd;
    nmhdr.idFrom = m_nID;
    nmhdr.code = TRUE;

    ::SendMessage(GetParent(),WM_NOTIFY,(WPARAM)m_nID,(LPARAM)&nmhdr);
}

// ComputeCursor
//

BOOL CKnobCtl::ComputeCursor(int deltaX, int deltaY, int maxdist)
{
    double  distance = sqrt(double((deltaX * deltaX) + (deltaY * deltaY)));
    double  degrees =  -((atan2(deltaX,deltaY) * DEGREE_CONVERTER) - double(180.0));

    BOOL    fDeadZone = FALSE;

    if (distance < double(4))
    {
        fDeadZone = TRUE;
    }

    if (distance <= maxdist)
    {
        SetCursor(LoadCursor(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDC_VOLHAND)));
    }
    else
    {
        int volcur;

        if ((degrees < double( 22.5) || degrees > double(337.5)) ||
            (degrees > double(157.5) && degrees < double(202.5)))
        {
            volcur = IDC_VOLHORZ;
        }
        else if ((degrees > double( 22.5) && degrees < double( 67.5)) ||
                 (degrees > double(202.5) && degrees < double(247.5)))
        {
            volcur = IDC_VOLDNEG;
        }
        else if ((degrees > double( 67.5) && degrees < double(112.5)) ||
                 (degrees > double(247.5) && degrees < double(292.5)))
        {
            volcur = IDC_VOLVERT;
        }
        else
        {
            volcur = IDC_VOLDPOS;
        }

        SetCursor(LoadCursor(_Module.GetResourceInstance(), MAKEINTRESOURCE(volcur)));
    }

    return fDeadZone;
}

// SetPosition
// 

void CKnobCtl::SetPosition(DWORD dwPosition, BOOL fNotify)
{
    if (GetCapture()==m_hWnd)
    {
        //we're in a feedback loop, return immediately
        return;
    }

    m_dwPosition = dwPosition;
    m_dwCurPosition = dwPosition;

    RECT rect;
    GetClientRect(&rect);

    int nWidth = rect.right - rect.left;
    int radius = (nWidth / 2) - LIGHT_OFFSET;

    double degree = ((double)m_dwPosition / m_dwRange) * 270;
    degree = degree + 135;

    m_trackdegree = degree; //instantly track when position is set programatically

    double angle = degree * RADIAN_CONVERTER;

    double fLightX = radius * cos(angle);
    double fLightY = radius * sin(angle);

    //convert to proper gdi coordinates
    m_nLightX = ((int)fLightX) - (m_nLightWidth / 2) + (nWidth / 2);
    m_nLightY = ((int)fLightY) - (m_nLightHeight / 2) + (nWidth / 2);

    InvalidateRect(NULL,FALSE);
    UpdateWindow();

    if (fNotify)
    {
        NMHDR nmhdr;
        nmhdr.hwndFrom = m_hWnd;
        nmhdr.idFrom = m_nID;
        nmhdr.code = FALSE;

        ::SendMessage(GetParent(),WM_NOTIFY,(WPARAM)m_nID,(LPARAM)&nmhdr);
    }
}

// SetAudioLevel
//
void CKnobCtl::SetAudioLevel(double level)
{
    m_AudioLevel = level;

    // invalidate rectangle so the knob gets redrawn
    InvalidateRect(NULL, FALSE);
    UpdateWindow();
}

// DrawArc
//
void CKnobCtl::DrawArc(HDC hdc, RECT rect, double start, double end)
{
    int nWidth = rect.right - rect.left;
    int nHeight = rect.bottom - rect.top;

    double startRad = RADIAN_CONVERTER * (135 + start*270);
    double endRad = RADIAN_CONVERTER * (135 + end*270);

    Arc( hdc, rect.left, rect.top, rect.right, rect.bottom,
        (int)((nWidth/2)*(1+cos(startRad))), (int)((nHeight/2)*(1+sin(startRad))),
        (int)((nWidth/2)*(1+cos(endRad))), (int)((nHeight/2)*(1+sin(endRad))) );
}

// Draw
//
void CKnobCtl::Draw(HDC hdc)
{
    RECT rect;

    GetClientRect(&rect);

    int nWidth = rect.right - rect.left;
    int nHeight = rect.bottom - rect.top;

    if (m_hPalette)
    {
        SelectPalette(hdc, m_hPalette, m_bBackgroundPalette);
        RealizePalette(hdc);
    }

    HDC memDC = CreateCompatibleDC(hdc);
    if(memDC==NULL)
    {
        // error, exit
        return;
    }

    if (m_hPalette)
    {
        SelectPalette(memDC, m_hPalette, m_bBackgroundPalette);
        RealizePalette(memDC);
    }

    HBITMAP hbmp = CreateCompatibleBitmap(hdc,nWidth,nHeight);
    HBITMAP hbmpOld = (HBITMAP)SelectObject(memDC,hbmp);

    HDC maskmemDC = CreateCompatibleDC(hdc);
    HBITMAP hmaskbmp = CreateCompatibleBitmap(hdc,nWidth,nHeight);
    HBITMAP hmaskbmpOld = (HBITMAP)SelectObject(maskmemDC,hmaskbmp);

    if(hbmp && maskmemDC && hmaskbmp)
    {
        //
        // Build the knob bitmap
        //

        DibBlt(memDC, 0, 0, -1, -1, 
            m_fEnabled ? ( GetFocus()==m_hWnd ? m_hKnobTab : m_hKnob) : m_hKnobDisabled,
            0, 0, SRCCOPY, 0);

        DibBlt(maskmemDC, 0, 0, -1, -1, 
            m_fEnabled ? (m_fDim ? m_hLight : m_hLightBright) : m_hLightDisabled,
               0, 0, SRCCOPY, 0);

        KMaskBlt(memDC,
                m_nLightX,
                m_nLightY,
                m_nLightWidth,
                m_nLightHeight,
                maskmemDC,
                0,
                0,
                (HBITMAP)m_hLightMask,
                0,
                0,
                MAKEROP4(SRCAND,SRCCOPY));
    }

    //
    // Draw the VU Meter
    //

    COLORREF RedColor = RGB(255,0,0);
    COLORREF YellowColor = RGB(255,255,0);
    COLORREF GreenColor = RGB(0,255,0);

    HPEN hRedPen = CreatePen(PS_SOLID, 2, RedColor) ; 
    HPEN hYellowPen = CreatePen(PS_SOLID, 2, YellowColor);
    HPEN hGreenPen = CreatePen(PS_SOLID, 2, GreenColor);

    if(hRedPen && hYellowPen && hGreenPen)
    {
        HPEN hOldPen = (HPEN) SelectObject(memDC, hGreenPen);

        SetArcDirection( memDC, AD_CLOCKWISE );

        for (double d=0.0; d < m_AudioLevel; d += 0.05)
        {
            if ( d >= 0.75 )
            {
                SelectObject(memDC, hRedPen);
            }
            else if ( d >= 0.5 )
            {
                SelectObject(memDC, hYellowPen);
            }

            DrawArc( memDC, rect, d+0.01, d+0.04 );
        }

        SelectObject(memDC, hOldPen);
    }

    if(hRedPen)
        DeleteObject(hRedPen);

    if(hYellowPen)
        DeleteObject(hYellowPen);

    if(hGreenPen)
        DeleteObject(hGreenPen);

    //
    // Copy the bitmap to the screen
    //

    BitBlt(hdc,0,0,nWidth,nHeight,memDC,0,0,SRCCOPY);

    SelectObject(memDC,hbmpOld);

    if(hbmp)
        DeleteObject(hbmp);

    if(memDC)
        DeleteDC(memDC);

    SelectObject(maskmemDC, hmaskbmpOld);

    if(hmaskbmp)
        DeleteObject(hmaskbmp);

    if(maskmemDC)
        DeleteDC(maskmemDC);
}


//kmaskblt -- cuz MaskBlt doesn't work on all platforms.  This is all it does anyway.
//            uses same params as MaskBlt, ignoring the flags part as dwDummy
void CKnobCtl::KMaskBlt(HDC hdcDest, int x, int y, int width, int height, 
                        HDC hdcSource, int xs, int ys, 
                        HBITMAP hMask, int xm, int ym, DWORD dwDummy)
{
    HDC hdcMask = CreateCompatibleDC(hdcDest);

    if(hdcMask)
    {
        HBITMAP holdbmp = (HBITMAP)SelectObject(hdcMask,hMask);

        BitBlt(hdcDest, x, y, width, height, hdcSource, xs, ys, SRCINVERT);
        BitBlt(hdcDest, x, y, width, height, hdcMask, xm, ym, SRCAND);
        BitBlt(hdcDest, x, y, width, height, hdcSource, xs, ys, SRCINVERT);

        SelectObject(hdcMask,holdbmp);
        DeleteDC(hdcMask);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\misc.h ===
// helper stuff

#pragma once

#include "stdafx.h"

#define BMP_COLOR_MASK RGB(255,0,255) // pink


// Structure with error info
struct RTCAX_ERROR_INFO
{
	LPWSTR		Message1;
	LPWSTR		Message2;
	LPWSTR		Message3;

	HICON		ResIcon;

};



/////////////////////////////////////////////////////////////////////////////
// CErrorMessageLiteDlg

class CErrorMessageLiteDlg : 
    public CAxDialogImpl<CErrorMessageLiteDlg>
{

public:
    CErrorMessageLiteDlg();

    ~CErrorMessageLiteDlg();
    
    enum { IDD = IDD_DIALOG_ERROR_MESSAGE_LITE };

BEGIN_MSG_MAP(CErrorMessageLiteDlg)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
    COMMAND_ID_HANDLER(IDOK, OnOk)
END_MSG_MAP()


    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\objectsafeimpl.h ===
#ifndef _OBJECT_SAFE_IMPL_H_
#define _OBJECT_SAFE_IMPL_H_

#include <atlcom.h>
#include <atlwin.h>
#include <atlctl.h>


/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ObjectSafeImpl.h

Abstract:

  base class for object safety. basic implementation for IObjectSafety

  derive your control from this class if the control is safe for scripting 
  on all the interfaces it exposes

  if you want to delegate IObjectSafety requests to the IObjectSafety
  interface of the aggrefate that supports the interface requested, 
  have your derived class implement QIOnAggregate() 

--*/


class __declspec(novtable) CObjectSafeImpl : public IObjectSafety
{

public:
    
    CObjectSafeImpl()
        :m_dwSafety(0)
    {}


    //
    // we support INTERFACESAFE_FOR_UNTRUSTED_CALLER and INTERFACESAFE_FOR_UNTRUSTED_DATA
    //

    enum { SUPPORTED_SAFETY_OPTIONS = 
        INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA };


    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
    {

       
        IUnknown *pNonDelegatingUnknown = NULL;

        //
        // any options requested that we do not support?
        //
        
        if ( (~SUPPORTED_SAFETY_OPTIONS & dwOptionSetMask) != 0 )
        {
            return E_FAIL;
        }

        
        //
        //  Is the interface exposed by one of the aggregated objects?
        //
                
        HRESULT hr = QIOnAggregates(riid, &pNonDelegatingUnknown);

        if (SUCCEEDED(hr))
        {

            //
            // get IObjectSafety on non delegating unknown of the aggregated object
            //

            IObjectSafety *pAggrObjectSafety = NULL;

            hr = pNonDelegatingUnknown->QueryInterface(IID_IObjectSafety, (void**)&pAggrObjectSafety);

            pNonDelegatingUnknown->Release();
            pNonDelegatingUnknown = NULL;
            
            if (SUCCEEDED(hr))
            {

                // 
                // the aggregate exposes IObjectSafety. use it to set the new 
                // safety options
                //

                hr = pAggrObjectSafety->SetInterfaceSafetyOptions(riid,
                                                                  dwOptionSetMask,
                                                                  dwEnabledOptions);

                pAggrObjectSafety->Release();
                pAggrObjectSafety = NULL;

            }

        }
        else 
        {
            //
            // the interface requested is not requested by the object's 
            // aggregates. see if the interface is supported at all
            //

            hr = InterfaceSupported(riid);

            if (SUCCEEDED(hr))
            {

                //
                // the object supports the interface. Set safety options.
                // 

                s_CritSection.Lock();

                //
                // set the bits specified by the mask to the values specified by the values
                //

                m_dwSafety = (dwEnabledOptions & dwOptionSetMask) |
                             (m_dwSafety & ~dwOptionSetMask);

                s_CritSection.Unlock();

            }

        }

        return hr;
    }





    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
    {
        
        //
        // check caller's pointers
        //

        if ( IsBadWritePtr(pdwSupportedOptions, sizeof(DWORD)) ||
             IsBadWritePtr(pdwEnabledOptions, sizeof(DWORD)) )
        {
             return E_POINTER;
        }

        //
        //  if we fail, at least return something meaningful.
        //

        *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;


        IUnknown *pNonDelegatingUnknown = NULL;
       
        //
        //  Is the interface exposed by one of the aggregated objects?
        //
        
        HRESULT hr = QIOnAggregates(riid, &pNonDelegatingUnknown);

        if (SUCCEEDED(hr))
        {

            //
            // get IObjectSafety on non delegating unknown of the aggregated object
            //

            IObjectSafety *pAggrObjectSafety = NULL;

            hr = pNonDelegatingUnknown->QueryInterface(IID_IObjectSafety, (void**)&pAggrObjectSafety);

            pNonDelegatingUnknown->Release();
            pNonDelegatingUnknown = NULL;
            
            if (SUCCEEDED(hr))
            {

                // 
                // the aggregate exposes IObjectSafety. use it to get the new 
                // safety options
                //

                hr = pAggrObjectSafety->GetInterfaceSafetyOptions(riid,
                                                                  pdwSupportedOptions,
                                                                  pdwEnabledOptions);

                pAggrObjectSafety->Release();
                pAggrObjectSafety = NULL;

            }

        }
        else 
        {
            //
            // the interface requested is not requested by the object's 
            // aggregates. see if the interface is supported at all
            //

            hr = InterfaceSupported(riid);

            if (SUCCEEDED(hr))
            {

                //
                // the object supports the interface. get options
                // 

                *pdwSupportedOptions = SUPPORTED_SAFETY_OPTIONS;

                s_CritSection.Lock();

                *pdwEnabledOptions = m_dwSafety;

                s_CritSection.Unlock();

            }

        }

        return hr;
    }


private:

    DWORD m_dwSafety;

    // 
    // thread safety
    //
    // this interface is not likely to be a performance bottleneck, 
    // at the same time, having one critical section per object
    // is wasteful. so have a static critical section
    //

    static CComAutoCriticalSection s_CritSection;


protected:

    //
    // return S_OK if the interface requested is exposed 
    // by the object
    //
    
    HRESULT InterfaceSupported(REFIID riid)
    {

        void *pVoid = NULL;

    
        HRESULT hr = E_FAIL;
     
        // 
        // does the object support requested interface
        //

        hr = QueryInterface(riid, &pVoid);


        if (SUCCEEDED(hr))
        {

            //
            // don't need the interface itself, just wanted to see if
            // it is supported
            //

            ((IUnknown*)pVoid)->Release();

        }
        

        return hr;
    }


    //
    // Implement in the derived class if you have any aggregates
    //
    // returns the non delegating IUnknown of the first (in the order of COMMAP)
    // aggregate that supports the iid requested
    //
    
    virtual HRESULT QIOnAggregates(REFIID riid, IUnknown **ppNonDelegatingUnknown)
    {
        return E_NOINTERFACE;
    }

};

#endif // _OBJECT_SAFE_IMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\promptedobjectsafety.h ===
#ifndef _PROMPTED_OBJECT_SAFETY_H_
#define _PROMPTED_OBJECT_SAFETY_H_

/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    PromptedObjectSafety.h

Abstract:

  abstract base class for secure object safety mechanism

  calls the derived class's Ask() method to determine 
  whether safe for scripting request should be rejected

--*/


#include "ObjectSafeImpl.h"


class __declspec(novtable) CPromptedObjectSafety : public CObjectSafeImpl
{

public:
   
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD dwOptionSetMask, 
                                         DWORD dwEnabledOptions)
    {
        if ( SUCCEEDED(InterfaceSupported(riid)) && Ask() )
        {
            return CObjectSafeImpl::SetInterfaceSafetyOptions(riid, 
                                                        dwOptionSetMask,
                                                        dwEnabledOptions);
        }
        else
        {
            return E_FAIL;
        }
    }


    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD *pdwSupportedOptions,
                                         DWORD *pdwEnabledOptions)
    {
        if (SUCCEEDED(InterfaceSupported(riid)) && Ask())
        {
            return CObjectSafeImpl::GetInterfaceSafetyOptions(riid, 
                                                          pdwSupportedOptions,
                                                          pdwEnabledOptions);
        }
        else
        {
            return E_FAIL;
        }
    }

    //
    // implement Ask() in the derived class. Should contain the logic to make 
    // the decision on whether the control should be allowed to run
    //
    // return FALSE if you want to mark your control as not safe for scripting
    // return TRUE otherwise
    //

    virtual BOOL Ask() = 0;

};

#endif // _PROMPTED_OBJECT_SAFETY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\provstore.cpp ===
/*********************************************************************************
*
*   Copyright (c) 2001  Microsoft Corporation
*
*   Module Name:
*
*    provstore.cpp
*
*   Abstract:
*
*    Implementation of all of the methods in CProfileStore class.
*
*
**********************************************************************************/

#include "stdafx.h"
#include "provstore.h"

CComAutoCriticalSection CObjectSafeImpl::s_CritSection;
CComAutoCriticalSection CObjectWithSite::s_ObjectWithSiteCritSection;
CObjectWithSite::EnValidation CObjectWithSite::s_enValidation = CObjectWithSite::UNVALIDATED;

HKEY g_hRegistryHive = HKEY_CURRENT_USER;
const WCHAR * g_szProvisioningKeyName = L"Software\\Microsoft\\Phoenix\\ProvisioningInfo";
const WCHAR * g_szProvisioningSchemaKeyName = L"schema";
const WCHAR *    g_szProfileInfo =L"provision";
const WCHAR *    g_szKey = L"key";

//////////////////////////////////////////////////////////////////////////////////
//EnableProfiles
// query for IRTCClientProvisioning
//
// for each profile stored in the registry:
//  1) CreateProfile(BSTR XML, IRTCProfile ** ppProfile)
//  2) EnableProfile(IRTCProfile * pProfile, VARIANT_TRUE)

HRESULT EnableProfiles( IRTCClient * pClient )
{
    long dwResult = 0;
    long dwProfileCount = 0, i; 
    WCHAR *szSubKeyName;
    WCHAR *szProfileXML;
    unsigned long dwSubKeySize = 0, dwLargestSubKeySize = 0;
    HRESULT hr = 0;
    HKEY hProvisioningKey;
    CComPtr<IRTCClientProvisioning> spClientProv;
    
    LOG((RTC_TRACE, "EnableProfiles: enter :%x.",pClient));
    if( IsBadWritePtr(pClient, sizeof(IRTCClient) ) )
    {
        LOG((RTC_ERROR, "EnableProfiles: invalid arg:%x.",pClient));
        return E_POINTER;
    }
    
    hr = pClient->QueryInterface(IID_IRTCClientProvisioning,(void**)&(spClientProv.p));
    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "EnableProfiles: QI failed:%x.",pClient));
        return E_FAIL;
    }
    
    // Get a handle to the provisioninginfo key, we need read/write access
    hr = MyOpenProvisioningKey(&hProvisioningKey, FALSE);
    if ( FAILED (hr) )
    {
        LOG((RTC_ERROR, "EnableProfiles: Failed to open provisioning key."));
        return hr;
    }
    
    // Get the size of the largest subkey string for the provisioningInfo key.
    dwResult = RegQueryInfoKey(
        hProvisioningKey,    // handle to key
        NULL,                // class buffer
        NULL,                // size of class buffer
        NULL,                // reserved
        (unsigned long *)(&dwProfileCount),    // number of subkeys
        &dwSubKeySize,    // longest subkey name
        NULL,                // longest class string
        NULL,                // number of value entries
        NULL,                // longest value name
        NULL,                // longest value data
        NULL,                // descriptor length
        NULL				   // last write time
        );
    
    if (dwResult != ERROR_SUCCESS)
    {
        RegCloseKey(hProvisioningKey);
        return HRESULT_FROM_WIN32(dwResult);
    }
    
    
    // We allocate a string to receive the name of the subkey when we enumerate. 
    // Since we have the size of the longest subkey, we can allocate. We add one since
    // the size doesn't include null on Win 2K.
    
    dwSubKeySize ++;
    dwLargestSubKeySize = dwSubKeySize;
    
    LOG((RTC_INFO, "EnableProfiles: Size of largest key (after increasing by 1): %d", dwSubKeySize));
    
    szSubKeyName = (PWCHAR)RtcAlloc( sizeof( WCHAR ) * dwSubKeySize);
    
    if (szSubKeyName == 0)
    {
        // Not enough memory
        RegCloseKey(hProvisioningKey);
        return E_OUTOFMEMORY;
    }
    
    
    // Iternate through the cached profiles 
    for (i = 0; i < dwProfileCount; i ++)
    {
        //reset the size of subkey name buffer
        dwSubKeySize = dwLargestSubKeySize;
        
        dwResult = RegEnumKey(
            hProvisioningKey,     // handle to key to query
            i, // index of subkey to query
            szSubKeyName, // buffer for subkey name
            dwSubKeySize   // size of subkey name buffer
            );
        
        if (dwResult != ERROR_SUCCESS)
        {
            // Clean up
            
            LOG((RTC_ERROR, "EnableProfiles: Enum failed! (result = %d)", dwResult));
            LOG((RTC_ERROR, "EnableProfiles: key=%s,Size of key: %d, of the largest key:%d", 
                szSubKeyName, dwSubKeySize,dwLargestSubKeySize));
            
            RtcFree((LPVOID)szSubKeyName );
            RegCloseKey(hProvisioningKey);
            return HRESULT_FROM_WIN32(dwResult);
        }
        
        // We have to read the registry, create a profile for it, and enable it
        
        hr = MyGetProfileFromKey(hProvisioningKey, szSubKeyName, &szProfileXML);
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "EnableProfiles: Failed in getting from Registry(status = 0x%x)!", hr));
                        
            RtcFree((LPVOID)szSubKeyName );
            RegCloseKey(hProvisioningKey);
            
            return hr;
        }
        
        LOG((RTC_INFO, "EnableProfiles: Getting the profile %d, key={%s}",i,szSubKeyName));
        
        IRTCProfile *pProfile;
        hr = spClientProv->CreateProfile( CComBSTR( szProfileXML ), &pProfile);

        RtcFree((LPVOID)szProfileXML );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "EnableProfiles: Failed in CreateProfile, hr=0x%x", hr));           
        }
        else
        {        
            hr = spClientProv->EnableProfile( pProfile, RTCRF_REGISTER_ALL );       
        
            //We don't need pProfile no matter it success or not
            pProfile->Release();
        
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "EnableProfiles: Failed in EnableProfile(status = 0x%x)!", hr));
            }
        }
    }//for i

    RtcFree((LPVOID)szSubKeyName );
    RegCloseKey(hProvisioningKey);
    
    LOG((RTC_TRACE, "EnableProfiles: exit ok :%x.",pClient));
    return S_OK;
}
//
///////////////////////////////////////////////////////////////////////////////
//    Helper function for opening the provisioning key in the registry and get 
//    the correct handle. The function creates the ProvisioningInfo key if it 
//    doesn't exist. If it exists, it will also open it and return the handle. 
///////////////////////////////////////////////////////////////////////////////
//
HRESULT MyOpenProvisioningKey( HKEY * phProvisioningKey, BOOL fReadOnly)
{
    
    long result;
    DWORD dwDisposition = 0;
    HKEY hProvisioningKey;
    REGSAM samDesired;
    
    
    LOG((RTC_TRACE, "CProfileStore::OpenProvisioningKey: Entered"));
    
    _ASSERTE(phProvisioningKey != NULL);
    
    if (fReadOnly)
    {
        samDesired = KEY_READ;
    }
    else
    {
        samDesired = KEY_ALL_ACCESS;
    }
    
    result = RegCreateKeyEx(
        g_hRegistryHive,        // handle to open key
        g_szProvisioningKeyName,                // subkey name
        0,                                // reserved
        NULL,                            // class string
        0,                                // special options
        samDesired,                    // desired security access
        NULL,                            // inheritance
        &hProvisioningKey,                    // key handle 
        &dwDisposition
        );
    
    
    if (result != ERROR_SUCCESS)
    {
        LOG((RTC_ERROR, "MyOpenProvisioningKey: Unable to open the Provisioning Key"));
        return HRESULT_FROM_WIN32(result);
    }
    
    
    *phProvisioningKey = hProvisioningKey;
    
    
    LOG((RTC_TRACE, "MyOpenProvisioningKey: Exited"));
    
    return S_OK;
}


HRESULT CRTCProvStore::FinalConstruct()
{
  
    LOG((RTC_TRACE, "CRTCProvStore::FinalConstruct - enter"));

    LOG((RTC_TRACE, "CRTCProvStore::FinalConstruct - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProvStore::FinalRelease
//
// This gets called when the object is destroyed.
//
/////////////////////////////////////////////////////////////////////////////

void CRTCProvStore::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCProvStore::FinalRelease - enter"));

    LOG((RTC_TRACE, "CRTCProvStore::FinalRelease - exit S_OK"));

}


//
///////////////////////////////////////////////////////////////////////////////////
// Sets the provisioning Profile.
///////////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP CRTCProvStore::SetProvisioningProfile(BSTR bstrProfileXML)
{
    HRESULT hr = 0;
    BSTR bstrKey;
    HKEY hProvisioningKey, hProfileKey;
    long result;
    DWORD dwDisposition;
    DWORD dwProfileSize;

    if (IsBadStringPtr(bstrProfileXML, -1))
    {
        Error(L"Bad XML profile string", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCClientProvisioning::SetProvisioningProfile, invalid arg"));
        return E_POINTER;
    }

    hr= GetKeyFromProfile(  bstrProfileXML,  &bstrKey );
    if(FAILED(hr))
	{
        Error(L"No valid URL in XML profile string", IID_IRTCProvStore);
		LOG((RTC_ERROR,"CRTCProvStore::SetProvisioningProfile -"
			" Cannot get uri from profile %s, hr=%x. ", bstrProfileXML,hr));
		return E_FAIL;
	}

    
    // Get a handle to the provisioninginfo key, we need read/write access
    
    hr = MyOpenProvisioningKey(&hProvisioningKey, FALSE);
    if ( FAILED (hr) )
    {
        Error(L"Unable to open ProvisioningKey", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCProvStore::SetProvisioningProfile -"
			" Failed to open provisioning key,hr=%x",hr));
        SysFreeString( bstrKey );
        return hr;
    }
    
    //  Open/Create the registry key for this profile
    result = RegCreateKeyEx(
        hProvisioningKey,                // handle to open key
        bstrKey,                        // subkey name
        0,                                // reserved
        NULL,                            // class string
        0,                                // special options
        KEY_ALL_ACCESS,                    // desired security access
        NULL,                            // inheritance
        &hProfileKey,                    // key handle 
        &dwDisposition
        );
    
    // Close the provisioning key
    RegCloseKey(hProvisioningKey);

    //we don't need bstrKey
    SysFreeString( bstrKey );
    bstrKey = NULL;

    if (result != ERROR_SUCCESS)
    {
        Error(L"Unable to create Profile Key", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCProvStore::SetProvisioningProfile -"
			"Unable to create/open the Profile Key"));        
        return HRESULT_FROM_WIN32(result);
    }
    
    // Now that the key is created, we add the schema value and data 
    
    // size of value data, since it is a widechar, 
    // 1 is for the null that we want to store too. 
	    
    dwProfileSize = sizeof(WCHAR) * (wcslen(bstrProfileXML) + 1);
    
    result = RegSetValueEx(
        hProfileKey,        // handle to key
        g_szProvisioningSchemaKeyName,        // value name
        0,                    // reserved
        REG_BINARY,            // value type
        (const unsigned char *)bstrProfileXML,            // value data
        dwProfileSize        //size of the profile
        );
    
    RegCloseKey(hProfileKey);
    
    if (result != ERROR_SUCCESS)
    {
        Error(L"Unable to set ProvisioningKey", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCProvStore::SetProvisioningProfile -"
			"Failed to add the schema XML!"));
        
        return HRESULT_FROM_WIN32(result);
    }
    
    
    LOG((RTC_TRACE, "CRTCProvStore::SetProvisioningProfile - Exited"));
    
    return S_OK;
}

//
///////////////////////////////////////////////////////////////////////////////////
// Implementation of ISupportErrorInfo::InterfaceSupportsErrorInfo method
///////////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CRTCProvStore::InterfaceSupportsErrorInfo(REFIID riid)
{
    DWORD i = 0;
    DWORD dwLength = 0;
    static const IID * iidArray[] = 
    {
        &IID_IRTCProvStore
    };


    dwLength = (sizeof(iidArray))/(sizeof(iidArray[0]));

    for (i = 0; i < dwLength; i ++)
    {
        if (InlineIsEqualGUID(*iidArray[i], riid))
            return S_OK;
    }
    return S_FALSE;
}

//
///////////////////////////////////////////////////////////////////////////////////
// GetKeyFromProfile
//
///////////////////////////////////////////////////////////////////////////////////
//
HRESULT GetKeyFromProfile( BSTR bstrProfileXML, BSTR * pbstrKey )
{
    IXMLDOMDocument * pXMLDoc = NULL;
    HRESULT hr;
    
    hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
        IID_IXMLDOMDocument, (void**)&pXMLDoc );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "CoCreateInstance failed 0x%lx", hr));
        
        return hr;
    }
    
    
    VARIANT_BOOL bSuccess;
    
    hr = pXMLDoc->loadXML( bstrProfileXML, &bSuccess );
    
    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "loadXML failed 0x%lx", hr));
        
        if ( S_FALSE == hr )
        {
            hr = E_FAIL;
        }
        
        pXMLDoc->Release();
        return hr;
    }
    
    IXMLDOMNode * pDocument = NULL;
    
    hr = pXMLDoc->QueryInterface( IID_IXMLDOMNode, (void**)&pDocument);
    pXMLDoc->Release();
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "QueryInterface failed 0x%lx", hr));
        return hr;
    }
    
    IXMLDOMNode * pNode = NULL;
    hr = pDocument->selectSingleNode( CComBSTR(g_szProfileInfo), &pNode );
    pDocument->Release();
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "selectSingleNode failed 0x%lx", hr));
        return hr;
    }

    if ( hr != S_OK )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "no matching node"));
        return E_FAIL;
    }
    
    IXMLDOMElement * pElement = NULL;
    hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );
    pNode->Release();
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "QueryInterface failed 0x%lx", hr));
        return hr;
    }
    CComVariant var;
    hr = pElement->getAttribute( CComBSTR(g_szKey), &var );
    if ( hr != S_OK )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "getAttribute failed 0x%lx", hr));
        return hr;
    }
    pElement->Release();
    if ( var.vt != VT_BSTR )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "not a string"));
        return E_FAIL;
    }
    *pbstrKey = SysAllocString( var.bstrVal );
    if ( *pbstrKey == NULL )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "out of memory"));
        return E_OUTOFMEMORY;
    }
    return S_OK;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Gets the profile given the key and subkey from registry. 
//
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT MyGetProfileFromKey(
                                         HKEY hProvisioningKey, 
                                         WCHAR *szSubKeyName, 
                                         WCHAR **pszProfileXML
                                         )
{
    long result;
    HKEY hProfileKey;
    WCHAR *szProfileXML;
    DWORD dwMemoryReqd;
    DWORD type;


    LOG((RTC_TRACE, "MyGetProfileFromKey: Entered"));
 
    *pszProfileXML = 0;

    result = RegOpenKeyEx(
                hProvisioningKey,        // handle to open key
                szSubKeyName,            // subkey name
                0,                        // reserved
                KEY_READ,                // security access mask
                &hProfileKey            // handle to open key
                );


    if (result != ERROR_SUCCESS)
    {
        LOG((RTC_ERROR,"MyGetProfileFromKey: RegOpenKeyEx fail, subkey=%s.",szSubKeyName));
        return HRESULT_FROM_WIN32(result);
    }

    // Find out how much space is required for the profile

    result = RegQueryValueEx(
                hProfileKey,            // handle to key
                g_szProvisioningSchemaKeyName,            // value name
                NULL,                    // reserved
                &type,                    // type buffer
                NULL,                    // data buffer
                &dwMemoryReqd            // size of data buffer
                );

    if (result != ERROR_SUCCESS)
    {
        RegCloseKey(hProfileKey);
        LOG((RTC_ERROR,"MyGetProfileFromKey: RegQueryValueEx fail, subkey=%s.",szSubKeyName));
        return HRESULT_FROM_WIN32(result);
    }

    // We have got the size, let us do the memory allocation now

    szProfileXML = (PWCHAR)RtcAlloc( sizeof( WCHAR ) * dwMemoryReqd); 

    if (szProfileXML == 0)
    {
        return E_OUTOFMEMORY;
    }

    // We have the memory too, go ahead and read in the profile

    result = RegQueryValueEx(
                hProfileKey,            // handle to key
                g_szProvisioningSchemaKeyName,            // value name
                NULL,                    // reserved
                &type,                    // type buffer
                                        // data buffer
                (unsigned char *)(szProfileXML),
                &dwMemoryReqd            // size of data buffer
                );

    // We have to close this key irrespective of the result, so we do it here.
    RegCloseKey(hProfileKey);
    
    if (result != ERROR_SUCCESS)
    {
        RtcFree( szProfileXML );
        return HRESULT_FROM_WIN32(result);
    }

    *pszProfileXML = szProfileXML;

    LOG((RTC_TRACE, "MyGetProfileFromKey: Exited"));
 
    return S_OK;
}


STDMETHODIMP CRTCProvStore::get_ProvisioningProfile(BSTR bstrKey, BSTR * pbstrProfileXML)
{
    HRESULT hr;
    HKEY hProvisioningKey;
    WCHAR * szProfile;

    LOG((RTC_TRACE, "CRTCProvStore::get_ProvisioningProfile: Entered"));


    if (IsBadStringPtr(bstrKey, -1))
    {
        Error(L"Bad Key Argument", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCProvStore::get_ProvisioningProfile:", 
            "invalid key string"));
        return E_POINTER;
    }

    if (IsBadWritePtr(pbstrProfileXML, sizeof(BSTR)))
    {
        Error(L"Bad argument for profile string", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCProvStore::get_ProvisioningProfile:", 
            "invalid profilestr pointer"));
        return E_POINTER;
    }


   // We only need a read access here, so we pass true (READONLY).

    hr = MyOpenProvisioningKey(&hProvisioningKey, TRUE);
    if ( FAILED (hr) )
    {
        Error(L"Unable to open ProvisioningKey", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCProvStore::get_ProvisioningProfile -"
                " Failed to open provisioning key,hr=%x",hr));
        return hr;
    }

    hr = MyGetProfileFromKey(hProvisioningKey, bstrKey, &szProfile);

    // Close the provisioning key
    RegCloseKey(hProvisioningKey);

    if ( FAILED( hr ))
    {
        Error(L"Unable to read ProvisioningKey", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCProvStore::get_ProvisioningProfile: GetProfileFromKey Failed."));
        return hr;
    }
        
    // So everything is file. Ready to return success.

    *pbstrProfileXML = SysAllocString(szProfile);
    RtcFree(szProfile);

    if( !*pbstrProfileXML )
    {
        LOG((RTC_ERROR, "CRTCProvStore::get_ProvisioningProfile -"
            "out of memory, or szProfile is null"));
        return E_FAIL;
    }

    LOG((RTC_TRACE, "CRTCProvStore::get_ProvisioningProfile: Exited"));

    return S_OK;
}


//
///////////////////////////////////////////////////////////////////////////////////
// Deletes the provisioning Profile by Key
///////////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CRTCProvStore::DeleteProvisioningProfile(BSTR bstrKey)
{

    HRESULT hr = 0;
    HKEY hProvisioningKey;
    long result;

    LOG((RTC_TRACE, "CRTCProvStore::DeleteProvisioningProfile: Entered"));

    // Get a handle to the provisioninginfo key, we need write access.
    hr = MyOpenProvisioningKey(&hProvisioningKey, FALSE);
    if ( FAILED (hr) )
    {
        Error(L"Unable to open ProvisioningKey", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCProvStore::DeleteProvisioningProfile -"
            "Failed to open provisioning key."));
        return hr;
    }

    // Go ahead and delete this schema from the registry. 
    result = RegDeleteKey(hProvisioningKey,bstrKey);
    RegCloseKey(hProvisioningKey);

    if (result != ERROR_SUCCESS)
    {
            TCHAR szBuffer[]=L"Failed to delete the key";
            Error(szBuffer, IID_IRTCProvStore);
            LOG((RTC_ERROR, "CRTCProvStore::DeleteProvisioningProfile -"
                "Failed to delete the profile. key=%s", bstrKey));
            return HRESULT_FROM_WIN32(result);
    }

    LOG((RTC_TRACE, "CRTCProvStore::DeleteProvisioningProfile: Exited"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\objectwithsite.h ===
#ifndef _OBJECT_WITH_SITE_H_
#define _OBJECT_WITH_SITE_H_


/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ObjectWithSite.h

Abstract:

    The implementation of IObjectWithSite interface that allows 
    for per-page persistent data to be stored in registry or as
    a cookie.

--*/


#include <Mshtml.h>
#include <Wininet.h>


//
// this url is used to construct the URL for cookies -- a security measure 
// so a script applet cannot drop a cookie with the same name and data
// and fool us into thinking it is our cookie
//

#define RTC_HARDCODED_URL _T("http://www.microsoft.com/")

//
// the expiration date is needed to make the cookie persistent
//

#define RTC_COOKIE_DATA _T("6; expires = Sat, 12-Sep-2099 00:00:00 GMT")



//
// dummy suffix to be appended to the url string
//

#define RTC_URL_SUFFIX  _T("/url")

class __declspec(novtable) CObjectWithSite : public  IObjectWithSite
{

public:

    //
    // current validation level. used to determine whether the page is safe, 
    // unsafe, or whether information from the user is needed
    //
    
    enum EnValidation { VALIDATED_SAFE, VALIDATED_SAFE_PERMANENT, VALIDATED_UNSAFE, UNVALIDATED };


public:

    
    //
    // store type
    // 

    enum EnMechanism { COOKIES, REGISTRY };


    CObjectWithSite(TCHAR const *pszStorageName)
        :m_pszURL(NULL),
        m_dwSecurityZone(URLZONE_UNTRUSTED),
        m_pUnkSite(NULL),
        m_pszStorageName(NULL)
    {
        SetStorageName(pszStorageName);
    }


    ~CObjectWithSite()
    {
    
        if (m_pszURL)
        {
            delete m_pszURL;
        
            m_pszURL = NULL;
        }

        
        if (m_pUnkSite)
        {
            m_pUnkSite->Release();

            m_pUnkSite = NULL;
        }


        if (m_pszStorageName)
        {

            delete m_pszStorageName;

            m_pszStorageName = NULL;

        }
    }

    ////////////////////////////
    //
   	// IObjectWithSite methods


    STDMETHOD(SetSite)(IUnknown *pUnkSite)
    {


        if ((NULL != pUnkSite) && IsBadCodePtr((FARPROC)pUnkSite))
        {
            return E_POINTER;
        }


        s_ObjectWithSiteCritSection.Lock();

        //
        // we are moving away from a page. this is the new page, as far as
        // validation logic is concerned, so invalidate the current page
        //

        if (NULL == pUnkSite)
        {
            Validate(UNVALIDATED);
        }

        // 
        // Get URL and zone information for this site
        //

        //
        // Note: we could delay this until we are actually asked for
        // zone or URL, but this should not be a performance bottlneck 
        // in our case, so do this now to keep the code simple.

        StoreURLAndZone(pUnkSite);


        //
        // replace the current site pointer with the new one
        //

        if (m_pUnkSite)
        {
            m_pUnkSite->Release();
        }


        m_pUnkSite = pUnkSite;

        if (m_pUnkSite)
        {
            m_pUnkSite->AddRef();
        }

        s_ObjectWithSiteCritSection.Unlock();

        return S_OK;
    }


    STDMETHOD(GetSite)(REFIID riid, void **ppSite)
    {

        HRESULT hr = E_POINTER;

        if (!IsBadWritePtr(ppSite, sizeof(void*)))
        {
    
            s_ObjectWithSiteCritSection.Lock();

            *ppSite = NULL;

            if (m_pUnkSite)
            {
                hr = m_pUnkSite->QueryInterface(riid, ppSite);
            }
            else
            {
                hr = E_FAIL;
            }

            s_ObjectWithSiteCritSection.Unlock();

        }

        return hr;
    }


    //
    // has this page been validated?
    //

    EnValidation GetValidation() 
    {

        //
        // if the page has not been validated, see if it is marked as safe
        //

        s_ObjectWithSiteCritSection.Lock();


        if (UNVALIDATED == s_enValidation)
        {
            if (IsPageSafe())
            {
                s_enValidation = VALIDATED_SAFE;
            }
        }

        EnValidation enValidation = s_enValidation;

        s_ObjectWithSiteCritSection.Unlock();

        return enValidation;
    }


    //
    // validate page as safe, unsafe, or reset validation
    //
    
    EnValidation Validate(EnValidation enNewValidation)
    {

        s_ObjectWithSiteCritSection.Lock();


        //
        // keep the validation before the change
        //
        
        EnValidation enOldValidation = s_enValidation;


        //
        // safe permanent is a special case:
        //

        if (VALIDATED_SAFE_PERMANENT == enNewValidation)
        {

            //
            // set persistent safety flag and 
            // validate page as safe
            //

            MarkPageAsSafe();
            enNewValidation = VALIDATED_SAFE;
        }


        //
        // change our validation level for this page
        //

        s_enValidation = enNewValidation;

        s_ObjectWithSiteCritSection.Unlock();

        return enOldValidation;
    }



    BOOL IsIntranet()
    {
        
        //
        //  if anything other that intranet assume internet -- a less secure zone
        //

        s_ObjectWithSiteCritSection.Lock();

        BOOL bIntranet = ( m_dwSecurityZone == URLZONE_INTRANET );

        s_ObjectWithSiteCritSection.Unlock();

        return bIntranet;

    }


    ////////////////////
    //
    // HaveSite()
    //
    // return true if we have a site pointer
    //

    BOOL HaveSite()
    {

        s_ObjectWithSiteCritSection.Lock();


        BOOL bHaveSite = FALSE;

        if (NULL != m_pUnkSite)
        {
            bHaveSite = TRUE;
        }


        s_ObjectWithSiteCritSection.Unlock();

        return bHaveSite;
    }



private:

    ////////////////////////////
    //
    //  store the current url in the "safe" list
    //
    //
    // not thread safe, called from inside a lock
    //

    HRESULT MarkPageAsSafe(EnMechanism enMechanism = COOKIES)
    {

        //
        // if storage is invalid, the object has not been properly initialized
        //

        if (IsBadStringPtr(m_pszStorageName, -1))
        {
            return E_UNEXPECTED;
        }


        //
        // is we don't have the url, can't do what we are asked
        //

        if (NULL == m_pszURL)
        {
            return S_FALSE;
        }


        //
        // if url is garbage, we have a problem
        //

        if ( IsBadStringPtr(m_pszURL, -1) )
        {
            return E_FAIL;
        }


        HRESULT hr = E_FAIL;

        switch (enMechanism)
        {

            case REGISTRY:

                hr = MarkPageSafeInRegistry(m_pszStorageName);
                break;

            case COOKIES:

                hr = MarkPageSafeCookie(m_pszStorageName);
                break;

            default:

                break;

        }

        return hr;
    }


    //
    //  Returns TRUE if the current page is in the safe list
    //

    //
    // not thread safe, called from inside a lock
    //

    BOOL IsPageSafe( EnMechanism enMechanism = COOKIES )
    {

        //
        // if we cannot get safety marking for whatever reason,
        // return false
        //
        
        _ASSERTE(NULL != m_pszStorageName);

        if ( IsBadStringPtr(m_pszURL, -1) || 
             IsBadStringPtr(m_pszStorageName, -1))
        {
            return FALSE;
        }

        BOOL bSafe = FALSE;

        switch (enMechanism)
        {

        case REGISTRY:
 
            bSafe = IsPageSafeRegistry(m_pszStorageName);
            break;

        case COOKIES:
 
            bSafe = IsPageSafeCookie(m_pszStorageName);
            break;

        default:
 
            break;
        }

        return bSafe;
    }



private:

    //
    // this method is only called from the constructor. not thread safe.
    //

    HRESULT SetStorageName(TCHAR const *pszStorageName)
    {
        //
        // calling this method invalidates the old storage name
        // so deallocate it before doing anything else
        //

        if (NULL != m_pszStorageName) 
        {
            delete m_pszStorageName;
            m_pszStorageName = NULL;
        }

        //
        // argument must be valid
        //

        if (IsBadStringPtr(pszStorageName, -1))
        {
            return E_POINTER;
        }

        // 
        // allocate buffer for the new storage name
        // 

        size_t nSize = _tcsclen(pszStorageName) + 1;

        m_pszStorageName = new TCHAR[nSize];

        if (NULL == m_pszStorageName)
        {
            return E_OUTOFMEMORY;
        }

        _tcscpy(m_pszStorageName, pszStorageName);

        return S_OK;
    }



    //
    // cache the url string and security zone id
    // not thread safe must be called from inside a lock
    //
    
    HRESULT StoreURLAndZone(IUnknown *pUnkSite)
    {

        //
        // reset zone and deallocate URL, if it exists
        //

        m_dwSecurityZone = URLZONE_UNTRUSTED;

        if (m_pszURL)
        {
            delete m_pszURL;
            m_pszURL = NULL;
        }
		    
        if (pUnkSite == NULL)
        {
            return S_OK;
        }

        // 
        // use pUnkSite to get to IHTMLDocument2, which will give us the URL
        // 

        //
        // these interfaces need to be released on exit.
        // smart pointers will do exactly what we need
        //

        HRESULT hr = E_FAIL;
                
        CComPtr<IOleClientSite> pSite;

	    if (FAILED(hr = pUnkSite->QueryInterface(IID_IOleClientSite, (LPVOID *) &pSite)))
        {
		    return hr;
        }

        
        CComPtr<IOleContainer>  pOleCtr;

	    if (FAILED(hr = pSite->GetContainer(&pOleCtr)))
        {
		    return hr;
        }


        CComPtr<IHTMLDocument2> pDoc;

        if (FAILED(hr = pOleCtr->QueryInterface(IID_IHTMLDocument2, (LPVOID *) &pDoc)))
        {
		    return hr;
        }

    
        // 
        //  get and keep the url
        //

        BSTR bstrURL;
        
        if (FAILED(hr = pDoc->get_URL(&bstrURL)))
        {
		    return hr;
        }

        UINT nURLLength = SysStringLen(bstrURL) + 1;

        _ASSERTE(NULL == m_pszURL);

        m_pszURL = new TCHAR[nURLLength];

        if (NULL == m_pszURL)
        {
            SysFreeString(bstrURL);
            return E_OUTOFMEMORY;
        }



#ifdef _UNICODE

        _tcscpy(m_pszURL, bstrURL);

#else
        int r = WideCharToMultiByte(
                                  CP_ACP,
                                  0,
                                  bstrURL,
                                  nURLLength,
                                  m_pszURL,
                                  nURLLength,
                                  NULL,
                                  NULL );

        if (0 == r)
        {
            SysFreeString(bstrURL);

            delete m_pszURL;
            m_pszURL = NULL;
            
            return E_FAIL;
        }


#endif

        //
        // whatever follows '#' and '?' is "extra info" and is not considered 
        // to be a part of the actual URL by Internet(Set/Get)Coookie. Extra 
        // Info has no value for us -- so throw it out
        //
        
        TCHAR *psDelimiter = _tcsstr(m_pszURL, _T("#"));
        
        if (NULL != psDelimiter)
        {
            *psDelimiter = _T('\0');
        }


        psDelimiter = _tcsstr(m_pszURL, _T("?"));

        if (NULL != psDelimiter)
        {
            *psDelimiter = _T('\0');
        }


        //
        // at this point we cached the URL
        // now attempt to get the security zone. if we fail getting zone
        // information still keep the url.
        //

        //
        //  Get security zone
        //
        
        CComPtr<IInternetSecurityManager> pSecMgr;
	           

        hr = CoCreateInstance(CLSID_InternetSecurityManager,
		                 NULL,
		                 CLSCTX_INPROC_SERVER,
		                 IID_IInternetSecurityManager,
		                 (LPVOID *) &pSecMgr);

	    if (pSecMgr == NULL)
        {
            SysFreeString(bstrURL);
		    return hr;
        }

	    hr = pSecMgr->MapUrlToZone(bstrURL, &m_dwSecurityZone, 0);
        
        
        //
        // if failed, reset url to untrusted, just in case
        //

        if ( FAILED(hr) )
        {
            m_dwSecurityZone = URLZONE_UNTRUSTED;
        }


        SysFreeString(bstrURL);

        //
        // we should have at least the URL at this point
        //

        return S_OK;
    }

    
    // 
    //  drop a cookie for this page as an indicator that this page is safe
    //

    HRESULT MarkPageSafeCookie(TCHAR const *pszCookieName)
    {

        TCHAR *pszURL = NULL;

        //
        // generate the url for the cookie
        // remember to delete the returned string
        //

        GenerateURLString(&pszURL);

        if (NULL == pszURL)
            return E_OUTOFMEMORY;

        BOOL bReturn = InternetSetCookie(pszURL, pszCookieName, RTC_COOKIE_DATA);

        delete pszURL;

        return (bReturn)?S_OK:E_FAIL;
    }



    //
    //  presence of a cookie for this page is an indicator that it's safe
    //  returns TRUE if the cookie exists. FALSE otherwise
    // 
    
    BOOL IsPageSafeCookie(TCHAR const *pszCookieName)
    {
        
        //
        // m_pszURL was checked by the calling function and the object
        // is protected. m_pszURL should never be null here.
        //
        
        _ASSERTE(m_pszURL);

        // 
        // same goes for pszCookieName
        //

        _ASSERTE(pszCookieName);


        BOOL bReturn = FALSE;

        BOOL bFinalReturn = FALSE;


        TCHAR *pszURL = NULL;

        // remember to delete the returned string

        GenerateURLString(&pszURL);

        if (NULL == pszURL)
        {
            return FALSE;
        }
        
        //
        // see how much data the cookie contains
        //
        
        DWORD dwCookieDataSize = 0;
        
        // 
        // assuming the return code is TRUE if the method succeeds in getting
        // get the buffer size. the current documentation is not 100% clear
        //

        bReturn = InternetGetCookie(pszURL, pszCookieName, NULL, &dwCookieDataSize);


        //
        // dwCookieDataSize has the length of cookie data
        //
        
        if ( bReturn && dwCookieDataSize )
        {

            // 
            //  allocate the buffer for cookie data
            //

            TCHAR *pCookieDataBuffer = new TCHAR[dwCookieDataSize];

            if (NULL != pCookieDataBuffer)
            {
                //
                // all cookies for this page are returned in cookie data,
                // the name argument is ignored
                //
            
                bReturn = InternetGetCookie(pszURL,
                                            pszCookieName,
                                            pCookieDataBuffer,
                                            &dwCookieDataSize);
            

                // 
                // is succeeded, parse cookie data buffer to see if the 
                // cookie we are looking for is there
                //
                                
                if ( bReturn && ( NULL != _tcsstr(pCookieDataBuffer, pszCookieName) ) )
                {

                    bFinalReturn = TRUE;
                }


                delete pCookieDataBuffer;
                pCookieDataBuffer = NULL;
            }
        }


        delete pszURL;
        pszURL = NULL;

        return bFinalReturn;
    }

    

    //
    // add a registry entry for this page as an indicator that the page is safe
    // returns TRUE if the registry entry exists
    //

    HRESULT MarkPageSafeInRegistry(TCHAR const *szRegistryKeyName)
    {
       
        _ASSERTE(m_pszURL);

        //
        // open the registry key. create if not there
        //

        DWORD dwDisposition = 0;
        HKEY hKey = 0;

        LONG rc = RegCreateKeyEx(HKEY_CURRENT_USER,
                            szRegistryKeyName,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            &dwDisposition);

        if ( rc == ERROR_SUCCESS )
        {
            DWORD dwData = 0;

            //
            //  add the current URL to the registry
            //

            rc = RegSetValueEx(hKey,
                               m_pszURL,
                               0,
                               REG_DWORD,
                               (BYTE*)&dwData, 
                               sizeof(DWORD));
 
        }

        if (hKey)
        {
            RegCloseKey(hKey);
        }

        hKey = NULL;

        if (rc == ERROR_SUCCESS )
        {
            return S_OK;
        }
        else 
        {
            return E_FAIL;
        }
    }


    // 
    // presence of a registry entry for this page indicates that the 
    // page is safe
    //
    
    BOOL IsPageSafeRegistry(TCHAR const *szRegistryKeyName)
    {
        
        DWORD dwDisposition = 0;
        HKEY hKey = 0;

        //
        // the default is not safe
        //

        if (NULL == m_pszURL)
        {
            return FALSE;
        }

        //
        // open the registry key where the page information is kept.
        // create if not there
        //

        LONG rc = RegCreateKeyEx(HKEY_CURRENT_USER,
                            szRegistryKeyName, 
                            0, 
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_CREATE_SUB_KEY | KEY_READ,
                            NULL,
                            &hKey,
                            &dwDisposition);

        if ( rc == ERROR_SUCCESS )
        {


            DWORD dwDataType = 0;
            DWORD dwDataSize = 0;
            
            // 
            // read the setting for the current page.
            // Note: we don't need the actual data, we just
            // want to see if the value exists
            // 

            rc = RegQueryValueEx(hKey,
                            m_pszURL,
                            0,
                            &dwDataType,
                            NULL,
                            &dwDataSize
                           );
        }
        
        if (hKey)
        {
            RegCloseKey(hKey);
        }

        hKey = NULL;

        return (rc == ERROR_SUCCESS);
    }


    // 
    // build the URL string based on the hardcoded URL and 
    // the actual URL for this page.
    // we are hoping that the striing will be unique (per page) and no
    // mischevious scripting app can drop a cookie corresponding to 
    // this URL
    // 
    // Note: if the implementation of of Internet(Set/Get)Cookie changes
    // to have stricter validation for the URL string, this technique will
    // not work
    // 

    void GenerateURLString(TCHAR **ppszURL)
    {
        
        //
        // the precondition is that m_pszURL exists
        //

        _ASSERT(NULL != m_pszURL);

        *ppszURL = NULL;

        //
        // alias the char pointer pointer to by *pszURL.
        // so it is easier to refer to.
        //

        TCHAR* &pszURL = *ppszURL;
        
        //
        // allocate memory for concatenated string
        //

        pszURL = new TCHAR[_tcslen(RTC_HARDCODED_URL) + 
                           _tcslen(m_pszURL) + 
                           _tcslen(RTC_URL_SUFFIX) + 1];

        // concatenate 

        if (pszURL)
        {
            *pszURL = _T('\0');
        
            _tcscat(pszURL, RTC_HARDCODED_URL);
            _tcscat(pszURL, m_pszURL);
            _tcscat(pszURL, RTC_URL_SUFFIX);
        }

    }



private:
    
    //
    // cached URL string
    //

    TCHAR *m_pszURL;


    //
    // cached security zone
    //
    
    DWORD m_dwSecurityZone;


    //
    // site for IObjectWithSite
    //

    IUnknown *m_pUnkSite;

    // 
    // thread safety
    //

    static CComAutoCriticalSection s_ObjectWithSiteCritSection;

    //
    // the status of the current page
    //

    static EnValidation s_enValidation;

    //
    // name of the persistent cookie or registry key
    //
    
    TCHAR *m_pszStorageName;

};

#endif // _OBJECT_WITH_SITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\rtcaxctl.cpp ===
// RTCCtl.cpp : Implementation of CRTCCtl

#include "stdafx.h"
#include "misc.h"
#include "dial.h"
#include "knob.h"
#include "provstore.h"

#define OATRUE -1
#define OAFALSE 0

LONG    g_lObjects = 0;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CRTCCtl
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

// static members - layouts
// all the values are in pixels

// Zone group sizes
#define ZONE_GROUP_TOOLBAR_HEIGHT       41
#define ZONE_GROUP_MAIN_HEIGHT          186
#define ZONE_GROUP_SECONDARY_HEIGHT     61
#define ZONE_GROUP_PARTLIST_HEIGHT      88
#define ZONE_GROUP_STATUS_HEIGHT        31
#define ZONE_STANDALONE_OFFSET          0

#define ZONE_PARTLIST_STANDALONE        10

// 
#define CTLSIZE_Y                      240

#define QCIF_CX_SIZE                   176
#define QCIF_CY_SIZE                   144

#define QQCIF_CX_SIZE   (QCIF_CX_SIZE/2)
#define QQCIF_CY_SIZE   (QCIF_CY_SIZE/2)

// Initial coordinates for controls
// All values are in pixels

// this takes into account the window has 2pixel thin borders
// the window adjustes itself in order to accomodate the QCIF size,
// but it doesn't center itself..

#define     CTLPOS_X_RECEIVEWIN     29
#define     CTLPOS_Y_RECEIVEWIN     0

#define     CTLPOS_X_DIALPAD        56
#define     CTLPOS_Y_DIALPAD        3

#define     CTLPOS_DX_DIALPAD       5
#define     CTLPOS_DY_DIALPAD       3

#define     CTLPOS_X_MICVOL         120
#define     CTLPOS_Y_MICVOL         -5

#define     CTLPOS_X_SPKVOL         50
#define     CTLPOS_Y_SPKVOL         -5

#define     CTLPOS_X_SEND_AUDIO_MUTE    189
#define     CTLPOS_Y_SEND_AUDIO_MUTE    5

#define     CTLPOS_X_SEND_AUDIO_MUTE_TEXT    194
#define     CTLPOS_Y_SEND_AUDIO_MUTE_TEXT    21

#define     CTLPOS_X_RECV_AUDIO_MUTE    11
#define     CTLPOS_Y_RECV_AUDIO_MUTE    5

#define     CTLPOS_X_RECV_AUDIO_MUTE_TEXT    16
#define     CTLPOS_Y_RECV_AUDIO_MUTE_TEXT    21

#define     CTLPOS_X_SEND_VIDEO         189
#define     CTLPOS_Y_SEND_VIDEO         157

#define     CTLPOS_X_SEND_VIDEO_TEXT    194
#define     CTLPOS_Y_SEND_VIDEO_TEXT    173

#define     CTLPOS_X_RECV_VIDEO         11
#define     CTLPOS_Y_RECV_VIDEO         157

#define     CTLPOS_X_RECV_VIDEO_TEXT    15
#define     CTLPOS_Y_RECV_VIDEO_TEXT    173

#define     CTLPOS_X_RECV_TEXT          0
#define     CTLPOS_Y_RECV_TEXT          45

#define     CTLPOS_X_SEND_TEXT          185
#define     CTLPOS_Y_SEND_TEXT          45

#define     CTLPOS_X_PARTLIST       5
#define     CTLPOS_Y_PARTLIST       0

#define     CTLPOS_X_ADDPART        5
#define     CTLPOS_Y_ADDPART        160

#define     CTLPOS_X_REMPART        123
#define     CTLPOS_Y_REMPART        160

// size of some controls, in pixels
#define     CX_CHECKBOX_BUTTON      37
#define     CY_CHECKBOX_BUTTON      15

#define     CX_DIALPAD_BUTTON       40
#define     CY_DIALPAD_BUTTON       32

#define     CX_PARTLIST             230
#define     CY_PARTLIST_WEBCRM       74
#define     CY_PARTLIST_STANDALONE  150

#define     CX_PARTICIPANT_BUTTON   112
#define     CY_PARTICIPANT_BUTTON   23

#define     CX_GENERIC_TEXT         40
#define     CY_GENERIC_TEXT         16

#define     CX_SENDRECV_TEXT        54
#define     CY_SENDRECV_TEXT        16

// initial placement of rectangles
CZoneStateArray  CRTCCtl::s_InitialZoneStateArray = {
    0,                              TRUE,
    0,                              TRUE,
    0,                              TRUE,
    0,                              TRUE,
    0,                              TRUE,
    0,                              TRUE 
};

// nothing displayed
CZoneStateArray  CRTCCtl::s_EmptyZoneLayout = {
    0,                              FALSE,
    0,                              FALSE,
    0,                              FALSE,
    0,                              FALSE,
    0,                              FALSE,
    0,                              TRUE   // status with error
};

// WebCrm pc to pc
CZoneStateArray  CRTCCtl::s_WebCrmPCToPCZoneLayout = {
    0,                              TRUE,   // toolbar
    ZONE_GROUP_TOOLBAR_HEIGHT,      TRUE,   // logo/video
    ZONE_GROUP_TOOLBAR_HEIGHT,      FALSE,  // no dialpad
    ZONE_GROUP_TOOLBAR_HEIGHT +
    ZONE_GROUP_MAIN_HEIGHT,         TRUE,   // audio controls
    ZONE_GROUP_TOOLBAR_HEIGHT +
    ZONE_GROUP_MAIN_HEIGHT,         FALSE,  // no participants
    ZONE_GROUP_TOOLBAR_HEIGHT +
    ZONE_GROUP_MAIN_HEIGHT +
    ZONE_GROUP_SECONDARY_HEIGHT,    TRUE    // status
};

// WebCrm pc to phone, with dialpad
CZoneStateArray  CRTCCtl::s_WebCrmPCToPhoneWithDialpadZoneLayout = {
    0,                              TRUE,   // toolbar
    ZONE_GROUP_TOOLBAR_HEIGHT,      FALSE,  // no logo/video
    ZONE_GROUP_TOOLBAR_HEIGHT,      TRUE,   // dialpad
    ZONE_GROUP_TOOLBAR_HEIGHT +
    ZONE_GROUP_MAIN_HEIGHT,         TRUE,   // audio controls
    ZONE_GROUP_TOOLBAR_HEIGHT +
    ZONE_GROUP_MAIN_HEIGHT,         FALSE,  // no participants
    ZONE_GROUP_TOOLBAR_HEIGHT +
    ZONE_GROUP_MAIN_HEIGHT +
    ZONE_GROUP_SECONDARY_HEIGHT,    TRUE    // status
};

// WebCrm pc to phone, no dialpad
CZoneStateArray  CRTCCtl::s_WebCrmPCToPhoneZoneLayout = {
    0,                              TRUE,   // toolbar
    ZONE_GROUP_TOOLBAR_HEIGHT,      FALSE,  // no logo/video
    ZONE_GROUP_TOOLBAR_HEIGHT,      FALSE,  // no dialpad
    ZONE_GROUP_TOOLBAR_HEIGHT,      TRUE,   // audio controls
    ZONE_GROUP_TOOLBAR_HEIGHT,      FALSE,  // no participants
    ZONE_GROUP_TOOLBAR_HEIGHT +
    ZONE_GROUP_SECONDARY_HEIGHT,    TRUE    // status
};

// WebCrm phone to phone
CZoneStateArray  CRTCCtl::s_WebCrmPhoneToPhoneZoneLayout = {
    0,                              TRUE,   // toolbar
    ZONE_GROUP_TOOLBAR_HEIGHT,      FALSE,  // no logo/video
    ZONE_GROUP_TOOLBAR_HEIGHT,      FALSE,  // no dialpad
    ZONE_GROUP_TOOLBAR_HEIGHT,      FALSE,  // no audio controls
    ZONE_GROUP_TOOLBAR_HEIGHT,      TRUE,   // participants
    ZONE_GROUP_TOOLBAR_HEIGHT +
    ZONE_GROUP_PARTLIST_HEIGHT,     TRUE    // status
};

// PC to PC, idle or incoming calls
CZoneStateArray  CRTCCtl::s_DefaultZoneLayout = {
    0,                              FALSE,  // no toolbar
    
    ZONE_STANDALONE_OFFSET,         TRUE,   // logo/video
    
    ZONE_STANDALONE_OFFSET,         FALSE,  // no dialpad
    
    ZONE_STANDALONE_OFFSET + 
    ZONE_GROUP_MAIN_HEIGHT,         TRUE,   // audio controls
    
    ZONE_STANDALONE_OFFSET +
    ZONE_GROUP_MAIN_HEIGHT,         FALSE,  // no participants
    
    ZONE_STANDALONE_OFFSET +
    ZONE_GROUP_MAIN_HEIGHT +
    ZONE_GROUP_SECONDARY_HEIGHT,    FALSE   // no status
};

// PC to Phone (same as PC to PC for now)
CZoneStateArray  CRTCCtl::s_PCToPhoneZoneLayout = {
    0,                              FALSE,  // no toolbar

    ZONE_STANDALONE_OFFSET,         TRUE,   // logo/video (should disable video ?)

    ZONE_STANDALONE_OFFSET,         FALSE,  // no dialpad (using the frame one)

    ZONE_STANDALONE_OFFSET +
    ZONE_GROUP_MAIN_HEIGHT,         TRUE,   // audio controls
    
    ZONE_STANDALONE_OFFSET +
    ZONE_GROUP_MAIN_HEIGHT,         FALSE,  // no participants
    
    ZONE_STANDALONE_OFFSET +
    ZONE_GROUP_MAIN_HEIGHT +
    ZONE_GROUP_SECONDARY_HEIGHT,    FALSE   // no status
};

// Phone to Phone
CZoneStateArray  CRTCCtl::s_PhoneToPhoneZoneLayout = {
    0,                              FALSE,  // no toolbar
    
    ZONE_STANDALONE_OFFSET,         FALSE,   // logo/video

    ZONE_STANDALONE_OFFSET,         FALSE,  // no dialpad

    ZONE_STANDALONE_OFFSET +
    ZONE_GROUP_MAIN_HEIGHT,         FALSE,  // no audio controls

    ZONE_STANDALONE_OFFSET +
    ZONE_PARTLIST_STANDALONE,       TRUE,   // participants

    ZONE_STANDALONE_OFFSET +
    ZONE_PARTLIST_STANDALONE  +
    ZONE_GROUP_SECONDARY_HEIGHT,    FALSE   // no status
};


// Constructor
//
CRTCCtl::CRTCCtl()
{
    // This one won't make it into steelhead tracing, it is not initialized yet
    LOG((RTC_TRACE, "[%p] CRTCCtl::CRTCCtl", this));
        
    InitCommonControls();

    m_bWindowOnly = TRUE;

    m_nControlState = RTCAX_STATE_NONE;
    m_bRedirecting = FALSE;
    m_bOutgoingCall = FALSE;
    m_enListen = RTCLM_NONE;
    m_nCtlMode = CTL_MODE_UNKNOWN;

    m_bAddPartDlgIsActive = FALSE;

    m_lMediaCapabilities = 0;
    m_lMediaPreferences = 0;

    m_hAcceleratorDialpad = NULL;
    m_hAcceleratorToolbar = NULL;
    m_hNormalImageList = NULL;
    m_hHotImageList = NULL;
    m_hDisabledImageList = NULL;

    m_hBckBrush = NULL;
    m_hVideoBrush = NULL;

    m_hbmBackground = NULL;

    m_bReadOnlyProp = FALSE;
    m_bBoolPropError = FALSE;

    m_nPropCallScenario = RTC_CALL_SCENARIO_PCTOPC;
    m_bPropAutoPlaceCall = FALSE;
    m_bPropShowDialpad = FALSE;
    m_bPropDisableVideoReception = FALSE;
    m_bPropDisableVideoTransmission = FALSE;
    m_bPropDisableVideoPreview = FALSE;

    m_bReceiveWindowActive = FALSE;
    m_bPreviewWindowActive = FALSE;
    m_bPreviewWindowIsPreferred = TRUE;

    m_nCachedCallScenario = RTC_CALL_SCENARIO_PCTOPC;

    CopyMemory(m_ZoneStateArray, s_InitialZoneStateArray, sizeof(m_ZoneStateArray));
    
    m_pWebCrmLayout = NULL;

    m_hPalette = NULL;
    m_bBackgroundPalette = FALSE;

    m_pSpeakerKnob = NULL;
    m_pMicroKnob = NULL;

    m_pIMWindows = NULL;

    m_pCP = NULL;
    m_ulAdvise = 0;

    CalcExtent(m_sizeExtent);
}

// Destructor
//
CRTCCtl::~CRTCCtl()
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::~CRTCCtl", this));
    
    if (m_pSpeakerKnob)
    {
        delete m_pSpeakerKnob;
        m_pSpeakerKnob = NULL;
    }

    if (m_pMicroKnob)
    {
        delete m_pMicroKnob;
        m_pMicroKnob = NULL;
    }
}

// FinalConstruct (initialize)
//
HRESULT CRTCCtl::FinalConstruct(void)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::FinalConstruct - enter", this));
    
    if ( InterlockedIncrement(&g_lObjects) == 1 )
    {
        //
        // This is the first object
        //

        //
        // Register for steelhead tracing
        //

        LOGREGISTERTRACING(_T("RTCCTL"));
    }

    // Initialize the common controls library
    INITCOMMONCONTROLSEX  InitStruct;

    InitStruct.dwSize = sizeof(InitStruct);
    InitStruct.dwICC = ICC_BAR_CLASSES | ICC_LISTVIEW_CLASSES ;

    InitCommonControlsEx(&InitStruct);

    LOG((RTC_TRACE, "[%p] CRTCCtl::FinalConstruct - exit", this));

    return S_OK;
}

// FinalRelease (uninitialize)
//
void  CRTCCtl::FinalRelease(void)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::FinalRelease - enter", this));
    
    if ( InterlockedDecrement(&g_lObjects) == 0)
    {
        //
        // This was the last object
        //             
      
        //
        // Deregister for steelhead tracing
        //
        
        LOGDEREGISTERTRACING();   
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::FinalRelease - exit", this));
}

// 
// IRTCCtl methods.
//      Methods called when the object is initialized
//      m_bReadOnlyProp == TRUE freezes all the properties
//  

STDMETHODIMP CRTCCtl::get_DestinationUrl(BSTR *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DestinationUrl - enter", this));

    *pVal = m_bstrPropDestinationUrl.Copy();
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DestinationUrl - exit", this));
    
    return S_OK;
}

STDMETHODIMP CRTCCtl::put_DestinationUrl(BSTR newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DestinationUrl <%S> - enter", this, newVal ? newVal : L"null"));
   
    if(!m_bReadOnlyProp)
    {
        // just save the value. Don't do anything else
        m_bstrPropDestinationUrl = newVal;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DestinationUrl - exit", this));
    return S_OK;
}

STDMETHODIMP CRTCCtl::get_DestinationName(BSTR *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DestinationName - enter", this));

    *pVal = m_bstrPropDestinationName.Copy();
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DestinationName - exit", this));
    
    return S_OK;
}

STDMETHODIMP CRTCCtl::put_DestinationName(BSTR newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DestinationName <%S> - enter", this, newVal ? newVal : L"null"));
    
    if(!m_bReadOnlyProp)
    {
        // just save the value. Don't do anything else
        m_bstrPropDestinationName = newVal;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DestinationName - exit", this));
    return S_OK;
}


STDMETHODIMP CRTCCtl::get_AutoPlaceCall(BOOL *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_AutoPlaceCall - enter", this));

    *pVal = m_bPropAutoPlaceCall;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_AutoPlaceCall - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::put_AutoPlaceCall(BOOL newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_AutoPlaceCall <%d> - enter", this, newVal));
    
    // is it a valid boolean value
    if(newVal!=0 && newVal!=1)
    {
        LOG((RTC_TRACE, "[%p] CRTCCtl::put_AutoPlaceCall: invalid boolean value - exit", this));

        m_bBoolPropError = TRUE;

        return E_INVALIDARG;
    }
    
    if(!m_bReadOnlyProp)
    {
        // just save the value. Don't do anything else
        m_bPropAutoPlaceCall = newVal;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_AutoPlaceCall - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::get_ProvisioningProfile(BSTR *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_ProvisioningProfile - enter", this));

    *pVal = m_bstrPropProvisioningProfile.Copy();
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_ProvisioningProfile - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::put_ProvisioningProfile(BSTR newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_ProvisioningProfile <hmm, do you want to see it here ?> - enter", this));

    if(!m_bReadOnlyProp)
    {
        // just save the value. Don't do anything else
        m_bstrPropProvisioningProfile = newVal;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_ProvisioningProfile - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::get_ShowDialpad(BOOL *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_ShowDialpad - enter", this));

    *pVal = m_bPropShowDialpad;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_ShowDialpad - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::put_ShowDialpad(BOOL newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_ShowDialpad <%d> - enter", this, newVal));
    
    // is it a valid boolean value
    if(newVal!=0 && newVal!=1)
    {
        LOG((RTC_TRACE, "[%p] CRTCCtl::put_ShowDialpad: invalid boolean value - exit", this));

        m_bBoolPropError = TRUE;

        return E_INVALIDARG;
    }
 
    if(!m_bReadOnlyProp)
    {
        m_bPropShowDialpad = newVal;
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_ShowDialpad - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::get_CallScenario(RTC_CALL_SCENARIO *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_CallScenario - enter", this));

    *pVal = m_nPropCallScenario;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_CallScenario - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::put_CallScenario(RTC_CALL_SCENARIO newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_CallScenario <%d> - enter", this, newVal));

    if(!m_bReadOnlyProp)
    {
        m_nPropCallScenario = newVal;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_CallScenario - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::get_DisableVideoReception(BOOL *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DisableVideoReception - enter"));

    *pVal = m_bPropDisableVideoReception;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DisableVideoReception - exit"));

    return S_OK;
}

STDMETHODIMP CRTCCtl::put_DisableVideoReception(BOOL newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoReception <%d> - enter", newVal));
    
    // is it a valid boolean value
    if(newVal!=0 && newVal!=1)
    {
        LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoReception: invalid boolean value - exit", this));

        m_bBoolPropError = TRUE;

        return E_INVALIDARG;
    }

    if(!m_bReadOnlyProp)
    {
        m_bPropDisableVideoReception = newVal;

    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoReception - exit"));

    return S_OK;
}

STDMETHODIMP CRTCCtl::get_DisableVideoTransmission(BOOL *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DisableVideoTransmission - enter"));

    *pVal = m_bPropDisableVideoTransmission;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DisableVideoTransmission - exit"));

    return S_OK;
}

STDMETHODIMP CRTCCtl::put_DisableVideoTransmission(BOOL newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoTransmission <%d> - enter", newVal));
    
    // is it a valid boolean value
    if(newVal!=0 && newVal!=1)
    {
        LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoTransmission: invalid boolean value - exit", this));

        m_bBoolPropError = TRUE;

        return E_INVALIDARG;
    }

    if(!m_bReadOnlyProp)
    {
        m_bPropDisableVideoTransmission = newVal;
       
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoTransmission - exit"));

    return S_OK;
}

STDMETHODIMP CRTCCtl::get_DisableVideoPreview(BOOL *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DisableVideoPreview - enter"));

    *pVal = m_bPropDisableVideoPreview;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DisableVideoPreview - exit"));

    return S_OK;
}

STDMETHODIMP CRTCCtl::put_DisableVideoPreview(BOOL newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoPreview <%d> - enter", newVal));
    
    // is it a valid boolean value
    if(newVal!=0 && newVal!=1)
    {
        LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoPreview: invalid boolean value - exit", this));

        m_bBoolPropError = TRUE;

        return E_INVALIDARG;
    }


    if(!m_bReadOnlyProp)
    {
        m_bPropDisableVideoPreview = newVal;
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoPreview - exit"));

    return S_OK;
}

// 
// Fire events to the outside world (IRTCCtlNotify)
//  

// Fire_OnControlStateChange
// 
HRESULT    CRTCCtl::Fire_OnControlStateChange(
    /*[in]*/ RTCAX_STATE State,
    /*[in]*/ UINT StatusBarResID)
{
    HRESULT     hr = S_OK;
    // Maximum one connection
    CComPtr<IUnknown> p = IConnectionPointImpl<CRTCCtl, &IID_IRTCCtlNotify, CComUnkOneEntryArray>::m_vec.GetUnknown(1);
    if(p)
    {
        IRTCCtlNotify *pn = reinterpret_cast<IRTCCtlNotify *>(p.p);

        hr = pn->OnControlStateChange(State, StatusBarResID);
    }

    return hr;
};

// 
// IOleControl methods.
//      
//  

// OnAmbientPropertyChange
// removed

// 
// ISupportsErrorInfo methods.
//      
//  

// InterfaceSupportsErrorInfo
// 
STDMETHODIMP CRTCCtl::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IRTCCtl,
    };
    for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i], riid))
        {
            return S_OK;
        }
    }
    return S_FALSE;
}

// IPersistStream(Init)

STDMETHODIMP CRTCCtl::Load(LPSTREAM pStm)
{
    HRESULT     hr;
    
    LOG((RTC_INFO, "[%p] CRTCCtl::Load (IPersistStream) - enter", this));
    
    //
    // Calls the original method
    //

    hr = IPersistStreamInitImpl<CRTCCtl>::Load(pStm);

    //
    // If successful, compute the new size of 
    // the control and notify the container
    //

    if(SUCCEEDED(hr))
    {
        CalcSizeAndNotifyContainer();
    }
    
    //
    // This in a webcrm scenario
    //
    m_nCtlMode = CTL_MODE_HOSTED;
    
    LOG((RTC_INFO, "[%p] CRTCCtl::Load (IPersistStream) - exit", this));

    return hr;
}

// IPersistPropertyBag
STDMETHODIMP CRTCCtl::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    HRESULT     hr;
    
    LOG((RTC_INFO, "[%p] CRTCCtl::Load (IPersistPropertyBag) - enter", this));
    
    //
    // Calls the original method
    //

    hr = IPersistPropertyBagImpl<CRTCCtl>::Load(pPropBag, pErrorLog);

    //
    // If successful, compute the new size of 
    // the control and notify the container
    //

    if(SUCCEEDED(hr))
    {
        CalcSizeAndNotifyContainer();
    }
  
    //
    // This in a webcrm scenario
    //
    m_nCtlMode = CTL_MODE_HOSTED;

    LOG((RTC_INFO, "[%p] CRTCCtl::Load (IPersistPropertyBag) - exit", this));

    return hr;
}



// 
// IRTCEventNotification methods.
//      
//  

// Event
//  Dispatches the event to the appropriate specialized method 
//
STDMETHODIMP CRTCCtl::Event(RTC_EVENT enEvent,IDispatch * pEvent)
{
    HRESULT     hr = S_OK;
    
    CComQIPtr<IRTCSessionStateChangeEvent, &IID_IRTCSessionStateChangeEvent>
            pRTCSessionStateChangeEvent;
    CComQIPtr<IRTCParticipantStateChangeEvent, &IID_IRTCParticipantStateChangeEvent>
            pRTCParticipantStateChangeEvent;
    CComQIPtr<IRTCClientEvent, &IID_IRTCClientEvent>
            pRTCRTCClientEvent;
    CComQIPtr<IRTCMediaEvent, &IID_IRTCMediaEvent>
            pRTCRTCMediaEvent;
    CComQIPtr<IRTCIntensityEvent, &IID_IRTCIntensityEvent>
            pRTCRTCIntensityEvent;
    CComQIPtr<IRTCMessagingEvent, &IID_IRTCMessagingEvent>
            pRTCRTCMessagingEvent;

    //LOG((RTC_INFO, "[%p] CRTCCtl::Event %d - enter", this, enEvent));

    switch(enEvent)
    {
    case RTCE_SESSION_STATE_CHANGE:
        pRTCSessionStateChangeEvent = pEvent;
        hr = OnSessionStateChangeEvent(pRTCSessionStateChangeEvent);
        break;

    case RTCE_PARTICIPANT_STATE_CHANGE:
        pRTCParticipantStateChangeEvent = pEvent;
        hr = OnParticipantStateChangeEvent(pRTCParticipantStateChangeEvent);
        break;

    case RTCE_CLIENT:
        pRTCRTCClientEvent = pEvent;
        hr = OnClientEvent(pRTCRTCClientEvent);
        break;

    case RTCE_MEDIA:
        pRTCRTCMediaEvent = pEvent;
        hr = OnMediaEvent(pRTCRTCMediaEvent);
        break;

    case RTCE_INTENSITY:
        pRTCRTCIntensityEvent = pEvent;
        hr = OnIntensityEvent(pRTCRTCIntensityEvent);
        break;

    case RTCE_MESSAGING:
        pRTCRTCMessagingEvent = pEvent;
        hr = OnMessageEvent(pRTCRTCMessagingEvent);
        break;
    }

    //LOG((RTC_INFO, "[%p] CRTCCtl::Event %d - exit", this, enEvent));

    return hr;
}

// 
// IRTCCtlFrameSupport methods.
//  Private interface called by the standalone Phoenix frame     
//  
// 

// GetClient
//  Gets an IRTCClient interface pointer
STDMETHODIMP CRTCCtl::GetClient(/*[out]*/ IRTCClient **ppClient)
{
    HRESULT hr;
    
    LOG((RTC_INFO, "[%p] CRTCCtl::GetClient - enter", this));
    
    if(m_pRTCClient == NULL)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::GetClient cannot return a non-NULL interface pointer, exit", this));
        return E_FAIL;
    }

    hr = m_pRTCClient.CopyTo(ppClient);

    LOG((RTC_INFO, "[%p] CRTCCtl::GetClient - exit", this));

    return hr;
}

// GetActiveSession
//  Gets the active IRTCSession interface pointer
STDMETHODIMP CRTCCtl::GetActiveSession(/*[out]*/ IRTCSession **ppSession)
{
    HRESULT hr;
    
    LOG((RTC_INFO, "[%p] CRTCCtl::GetActiveSession - enter", this));
    
    hr = m_pRTCActiveSession.CopyTo(ppSession);

    LOG((RTC_INFO, "[%p] CRTCCtl::GetActiveSession - exit", this));

    return hr;
}

// Message
//   Invokes the right appropriate dialog box (if necessary) and
//   then starts an instant message session
// 
STDMETHODIMP CRTCCtl::Message(
                    /*[in]*/ BSTR          pDestName,
                    /*[in]*/ BSTR          pDestAddress,
                    /*[in]*/ BOOL          bDestAddressEditable,
                    /*[out]*/ BSTR       * ppDestAddressChosen
                    )
{
    HRESULT     hr = S_OK;
    CComBSTR    bstrDestAddressChosen;
    CComPtr<IRTCProfile> pProfileChosen = NULL;

    LOG((RTC_INFO, "[%p] CRTCCtl::Message - enter", this));

    // Query for the destination address if required
    //
    
    if(bDestAddressEditable)
    {
        //
        // We need to get the destination address.
        //

        LOG((RTC_TRACE, "[%p] CRTCCtl::Message: bring up ShowDialByAddressDialog", this));

        hr = ShowMessageByAddressDialog(m_hWnd,
                                        pDestAddress,
                                        &bstrDestAddressChosen);
        
        if ( SUCCEEDED(hr) )
        {
            ;  // nothing
        }
        else if (hr==E_ABORT)
        {
            LOG((RTC_TRACE, "[%p] CRTCCtl::Message: ShowMessageByAddressDialog dismissed, do nothing", this));
        }
        else
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::Message: error (%x) returned ShowMessageByAddressDialog", this, hr));
        }
    }
    else
    {
        bstrDestAddressChosen = SysAllocString( pDestAddress );
    }

    BOOL    bIsPhoneAddress = FALSE;
    BOOL    bIsSIPAddress = FALSE;
    BOOL    bIsTELAddress = FALSE;
    BOOL    bHasMaddrOrTsp = FALSE;
    BOOL    bIsEmailLike = FALSE;
  
    if(SUCCEEDED(hr))
    {

        //
        // Determine the type of the address
        //


        hr = GetAddressType(
            bstrDestAddressChosen,
            &bIsPhoneAddress,
            &bIsSIPAddress,
            &bIsTELAddress,
            &bIsEmailLike,
            &bHasMaddrOrTsp);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::Message: "
                "GetAddressType failed 0x%lx", this, hr));
        
        }
    }

    if(SUCCEEDED(hr))
    {
        // Reject it if it is a phone address
        if (bIsPhoneAddress)
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::Message: "
                "phone address not supported for messenging", this));

            return E_INVALIDARG;
        }
    
        // select a profile if appropriate
        if (!bHasMaddrOrTsp && bIsEmailLike)
        {
            // choose an appropriate profile
            IRTCEnumProfiles * pEnumProfiles = NULL;   
            IRTCProfile      * pProfile = NULL;
            IRTCClientProvisioning * pProv = NULL;

            hr = m_pRTCClient->QueryInterface(
                               IID_IRTCClientProvisioning,
                               (void **)&pProv
                              );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::Message - "
                                    "QI failed 0x%lx", this, hr));
        
                return hr;
            }

            hr = pProv->EnumerateProfiles( &pEnumProfiles );

            pProv->Release();

            if ( SUCCEEDED(hr) )
            {
                while ( S_OK == pEnumProfiles->Next( 1, &pProfile, NULL ) )
                {
                    //
                    // Get the supported session types of the provider
                    //
        
                    long lSupportedSessions;

                    hr = pProfile->get_SessionCapabilities( &lSupportedSessions );

                    if ( FAILED( hr ) )
                    {
                        LOG((RTC_ERROR, "CRTCCtl::Message - failed to "
                                        "get session info - 0x%08x - skipping", hr));

                        pProfile->Release();
                        pProfile = NULL;

                        continue;
                    }

                    if ( lSupportedSessions & RTCSI_PC_TO_PC )
                    {
                        pProfileChosen = pProfile;
                    }
                    
                    pProfile->Release();
                    pProfile = NULL;

                    if ( pProfileChosen != NULL )
                    {
                        break;
                    }
                }

                pEnumProfiles->Release();
                pEnumProfiles = NULL;
            }
        }
 
        // Do the work
        
        IRTCSession * pSession;

        hr = m_pRTCClient->CreateSession(
                    RTCST_IM,
                    NULL,
                    pProfileChosen,
                    RTCCS_FORCE_PROFILE,
                    &pSession
                    );

        if (SUCCEEDED(hr))
        {
            hr = pSession->AddParticipant(
                            bstrDestAddressChosen,
                            pDestName ? pDestName : L"",                            
                            NULL
                            );

            pSession->Release();

            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::Message: error (%x) returned by AddParticipant(...)", this, hr));
            }
        }
        else
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::Message: error (%x) returned by CreateSession(...)", this, hr));
        }
    }

    if ( ppDestAddressChosen != NULL )
    {
        *ppDestAddressChosen = SysAllocString(bstrDestAddressChosen);
    }

    LOG((RTC_INFO, "[%p] CRTCCtl::Message - exit", this));

    return hr;
}

// Call
//   Invokes the right appropriate dialog box (if necessary) and
//   then places the call using the internal method DoCall
// 
STDMETHODIMP CRTCCtl::Call(
                    /*[in]*/ BOOL          bCallPhone,
                    /*[in]*/ BSTR          pDestName,
                    /*[in]*/ BSTR          pDestAddress,
                    /*[in]*/ BOOL          bDestAddressEditable,
                    /*[in]*/ BSTR          pLocalPhoneAddress,
                    /*[in]*/ BOOL          bProfileSelected,
                    /*[in]*/ IRTCProfile * pProfile,
                    /*[out]*/ BSTR       * ppDestAddressChosen
                    )
{
    HRESULT     hr;
    CComBSTR    bstrDestAddressChosen;
    CComBSTR    bstrFromAddressChosen;
    CComPtr<IRTCProfile> pProfileChosen;
    RTC_CALL_SCENARIO   nCallScenario;

    LOG((RTC_INFO, "[%p] CRTCCtl::Call - enter", this));
    
    ATLASSERT(m_nControState == RTCAX_STATE_IDLE);

    // From the user's point of view, the "phone" is busy when dialing
    // (it cannot answer calls)
    SetControlState(RTCAX_STATE_DIALING);

    hr = S_OK;

    // When a call is first started, set the T120 data stream based on any
    // currently running T120 applets 
    VARIANT_BOOL fWhiteboard = VARIANT_FALSE;
    VARIANT_BOOL fAppSharing = VARIANT_FALSE;

    m_pRTCClient->get_IsT120AppletRunning(RTCTA_WHITEBOARD, &fWhiteboard);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::Call: get_IsT120AppletRunning error (%x)", this, hr));
    }

    m_pRTCClient->get_IsT120AppletRunning(RTCTA_APPSHARING, &fAppSharing);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::Call: get_IsT120AppletRunning error (%x)", this, hr));
    }

    if ( fWhiteboard || fAppSharing  )
    {
        m_lMediaPreferences |= RTCMT_T120_SENDRECV;
    }
    else
    {
        m_lMediaPreferences &= (~RTCMT_T120_SENDRECV);
    }

    // Set volatile preferences
    hr = m_pRTCClient->SetPreferredMediaTypes( m_lMediaPreferences, FALSE );
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::Call; cannot set preferred media types, error %x", this, hr));
    }
    
    // Query for the destination address if required
    //
    
    if(bDestAddressEditable)
    {
        //
        // We need to get the destination address.
        //

        if(bCallPhone)
        {
            LOG((RTC_TRACE, "[%p] CRTCCtl::Call: bring up ShowDialByPhoneNumberDialog", this));

            hr = ShowDialByPhoneNumberDialog(m_hWnd,
                                            FALSE,
                                            pDestAddress,
                                            &bstrDestAddressChosen);

        }
        else
        {
            LOG((RTC_TRACE, "[%p] CRTCCtl::Call: bring up ShowDialByAddressDialog", this));

            hr = ShowDialByAddressDialog(   m_hWnd,
                                            pDestAddress,
                                            &bstrDestAddressChosen);
        }

        
        if ( SUCCEEDED(hr) )
        {
            ;  // nothing
        }
        else if (hr==E_ABORT)
        {
            LOG((RTC_TRACE, "[%p] CRTCCtl::Call: ShowDialByXXXDialog dismissed, do nothing", this));
        }
        else
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::Call: error (%x) returned ShowDialByXXXDialog", this, hr));
        }
    }
    else
    {
        bstrDestAddressChosen = pDestAddress;
    }
    
    
    BOOL    bIsPhoneAddress = FALSE;
    BOOL    bIsSIPAddress = FALSE;
    BOOL    bIsTELAddress = FALSE;
    BOOL    bHasMaddrOrTsp = FALSE;
    BOOL    bIsEmailLike = FALSE;
  
    if(SUCCEEDED(hr))
    {

        //
        // Determine the type of the address
        //


        hr = GetAddressType(
            bstrDestAddressChosen,
            &bIsPhoneAddress,
            &bIsSIPAddress,
            &bIsTELAddress,
            &bIsEmailLike,
            &bHasMaddrOrTsp);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::Call: "
                "GetAddressType failed 0x%lx", this, hr));
        
        }
    }
    
    BOOL bNeedDialog = FALSE;
    BOOL bAllowEditProfile = TRUE;
    BOOL bEnumerateLocalProfiles = TRUE;
    LONG lSessionMask = 0;

    if(SUCCEEDED(hr))
    {
        //
        //  We may need the dialog box for choosing provider and from
        //


        //
        // Special cases
        //      The Address is a TEL URL that has a TSP parameter
        //  or           it is a SIP URL of type PC with a MADDR parameter
        //  or           it is a SIP URL of type Phone   
        //
        //          The profile is ignored, and the user is forced to 
        //      switch to PCTOPHONE if the selected From device is a local phone
        //
        //
        //      The address is a SIP URL of type PC, not looking like an email address
        //
        //          The profile is ignored, the user is forced to switch to PCTOPC
        //      if the selected From Device is a local phone

        if(bHasMaddrOrTsp || (bIsPhoneAddress && bIsSIPAddress) )
        {
            pProfile = NULL;

            bAllowEditProfile = FALSE;
            bEnumerateLocalProfiles = FALSE;

            if(pLocalPhoneAddress && *pLocalPhoneAddress)
            {
				//
				// The user chose "call from phone". This will not work
				// for this address type. We must enfore "call from pc".
				//
#ifdef MULTI_PROVIDER
                bNeedDialog = TRUE;
                lSessionMask = RTCSI_PC_TO_PHONE;   
#else
				pLocalPhoneAddress = NULL;
#endif MULTI_PROVIDER
            }

        }
        else if (!bIsPhoneAddress && !bIsEmailLike)
        {
            pProfile = NULL;

            bAllowEditProfile = FALSE;
            bEnumerateLocalProfiles = FALSE;

            if(pLocalPhoneAddress && *pLocalPhoneAddress)
            {
				//
				// The user chose "call from phone". This will not work
				// for this address type. We must enfore "call from pc".
				//
#ifdef MULTI_PROVIDER
                bNeedDialog = TRUE;
                lSessionMask = RTCSI_PC_TO_PC; 
#else
				pLocalPhoneAddress = NULL;
#endif MULTI_PROVIDER
            }
        }
        else
        {
            long lSupportedSessions = RTCSI_PC_TO_PC;

            if ( pProfile != NULL )
            {
                //
                // We were given a profile
                //

                hr = pProfile->get_SessionCapabilities( &lSupportedSessions );
            
                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "[%p] CRTCCtl::Call: "
                        "get_SessionCapabilities failed 0x%lx", this, hr));
                }
            }
            else if(!bProfileSelected)
            {
                // force the UI to show up (when called from command line)
                lSupportedSessions = 0;
            }
#ifndef MULTI_PROVIDER
            else
            {
                // find supported sessions for all profiles
                IRTCEnumProfiles * pEnumProfiles = NULL;  
                IRTCClientProvisioning * pProv = NULL;

                hr = m_pRTCClient->QueryInterface(
                                   IID_IRTCClientProvisioning,
                                   (void **)&pProv
                                  );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "[%p] CRTCCtl::Call - "
                                        "QI failed 0x%lx", this, hr));
        
                    return hr;
                }

                hr = pProv->EnumerateProfiles( &pEnumProfiles );

                pProv->Release();

                if ( SUCCEEDED(hr) )
                {
                    while ( S_OK == pEnumProfiles->Next( 1, &pProfile, NULL ) )
                    {
                        //
                        // Get the supported session types of the provider
                        //
        
                        long lSupportedSessionsForThisProfile;

                        hr = pProfile->get_SessionCapabilities( &lSupportedSessionsForThisProfile );

                        if ( FAILED( hr ) )
                        {
                            LOG((RTC_ERROR, "CRTCCtl::Call - failed to "
                                            "get session info - 0x%08x - skipping", hr));

                            pProfile->Release();
                            pProfile = NULL;

                            continue;
                        }

                        lSupportedSessions |= lSupportedSessionsForThisProfile;  
                        
                        pProfile->Release();
                        pProfile = NULL;
                    }

                    pEnumProfiles->Release();
                    pEnumProfiles = NULL;
                }
            }
#endif MULTI_PROVIDER

            if(SUCCEEDED(hr))
            {
                //
                // Check the validity of our call from, profile, and dest address combination
                //

                if ( bIsPhoneAddress )
                {
                    if ( pLocalPhoneAddress == NULL )
                    {
                        bNeedDialog = !(lSupportedSessions & RTCSI_PC_TO_PHONE);
                    }
                    else
                    {
                        bNeedDialog = !(lSupportedSessions & RTCSI_PHONE_TO_PHONE);
                    }

                    lSessionMask = RTCSI_PC_TO_PHONE | RTCSI_PHONE_TO_PHONE;
                }
                else
                {
                    bNeedDialog = !(lSupportedSessions & RTCSI_PC_TO_PC);
                    
                    lSessionMask = RTCSI_PC_TO_PC;
                }
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        if ( bNeedDialog )
        {
            //
            // We need a dialog to get correct call from and profile info
            //

            hr = ShowDialNeedCallInfoDialog(
                                        m_hWnd,
                                        m_pRTCClient,
                                        lSessionMask,
#ifdef MULTI_PROVIDER
                                        bEnumerateLocalProfiles,
                                        bAllowEditProfile,
#else
                                        FALSE,
                                        FALSE,
#endif MULTI_PROVIDER
                                        NULL,
                                        bstrDestAddressChosen,
                                        NULL,   // no special instructions here
                                        &pProfileChosen,
                                        &bstrFromAddressChosen
                                        );
        }
        else
        {
            //
            // Use the call from and profile passed in
            //

            pProfileChosen = pProfile;
            bstrFromAddressChosen = pLocalPhoneAddress;

            hr = S_OK;

        }
    }

    if(SUCCEEDED(hr))
    {        
        // convert from phone/pc & from address to call scenario
        if(bIsPhoneAddress & !bIsSIPAddress)
        {
            nCallScenario = (BSTR)bstrFromAddressChosen==NULL ?
                RTC_CALL_SCENARIO_PCTOPHONE : RTC_CALL_SCENARIO_PHONETOPHONE;
        }
        else
        {
            nCallScenario = RTC_CALL_SCENARIO_PCTOPC;
        }

#ifndef MULTI_PROVIDER
        if ( bAllowEditProfile )
        {
            // choose an appropriate profile
            IRTCEnumProfiles * pEnumProfiles = NULL; 
            IRTCClientProvisioning * pProv = NULL;

            hr = m_pRTCClient->QueryInterface(
                               IID_IRTCClientProvisioning,
                               (void **)&pProv
                              );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::Call - "
                                    "QI failed 0x%lx", this, hr));
    
                return hr;
            }

            hr = pProv->EnumerateProfiles( &pEnumProfiles );

            pProv->Release();

            if ( SUCCEEDED(hr) )
            {
                while ( S_OK == pEnumProfiles->Next( 1, &pProfile, NULL ) )
                {
                    //
                    // Get the supported session types of the provider
                    //
        
                    long lSupportedSessions;

                    hr = pProfile->get_SessionCapabilities( &lSupportedSessions );

                    if ( FAILED( hr ) )
                    {
                        LOG((RTC_ERROR, "CRTCCtl::Call - failed to "
                                        "get session info - 0x%08x - skipping", hr));

                        pProfile->Release();
                        pProfile = NULL;

                        continue;
                    }

                    switch ( nCallScenario )
                    {
                    case RTC_CALL_SCENARIO_PCTOPC:
                        if ( lSupportedSessions & RTCSI_PC_TO_PC )
                        {
                            pProfileChosen = pProfile;
                        }
                        break;

                    case RTC_CALL_SCENARIO_PCTOPHONE:
                        if ( lSupportedSessions & RTCSI_PC_TO_PHONE )
                        {
                            pProfileChosen = pProfile;
                        }
                        break;

                    case RTC_CALL_SCENARIO_PHONETOPHONE:
                        if ( lSupportedSessions & RTCSI_PHONE_TO_PHONE )
                        {
                            pProfileChosen = pProfile;
                        }
                        break;
                    }
                    
                    pProfile->Release();
                    pProfile = NULL;

                    if ( pProfileChosen != NULL )
                    {
                        break;
                    }
                }

                pEnumProfiles->Release();
                pEnumProfiles = NULL;
            }
        }
#endif MULTI_PROVIDER

        // Do the work
        hr = DoCall(pProfileChosen,
                    nCallScenario,
                    ( nCallScenario == RTC_CALL_SCENARIO_PHONETOPHONE) ? bstrFromAddressChosen : NULL,
                    pDestName,
                    bstrDestAddressChosen);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::Call: error (%x) returned by DoCall(...)", this, hr));
        }
    }

    // common point of processing errors
    if(FAILED(hr))
    {
        if (hr==E_ABORT)
        {
            LOG((RTC_TRACE, "[%p] CRTCCtl::Call: ShowXXXDialog dismissed, do nothing", this));

            SetControlState(RTCAX_STATE_IDLE);

        }
        else
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::Call: error (%x)", this, hr));

            SetControlState(RTCAX_STATE_IDLE, hr);
        }
    }

    if ( ppDestAddressChosen != NULL )
    {
        *ppDestAddressChosen = SysAllocString(bstrDestAddressChosen);
    }
    
    LOG((RTC_INFO, "[%p] CRTCCtl::Call - exit", this));

    return hr;
}

// HangUp
//  Terminates and releases the current session (if any)
// 
STDMETHODIMP CRTCCtl::HangUp(void)
{
    HRESULT hr = S_OK;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::HangUp - enter", this));
    
    ATLASSERT(m_nControState == RTCAX_STATE_CONNECTED);

    if(m_pRTCActiveSession)
    {
        // enter in DISCONNECTING state
        SetControlState(RTCAX_STATE_DISCONNECTING);
        
        // Terminates the session
        hr = m_pRTCActiveSession->Terminate(RTCTR_NORMAL);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::HangUp: Terminate returned error <%x> - exit", this, hr));

            LOG((RTC_INFO, "[%p] CRTCCtl::HangUp: releasing active session", this));

            m_pRTCActiveSession = NULL;

            SetControlState(RTCAX_STATE_IDLE);

            return hr;
        }

        // the DISCONNECTED event will push the control state to IDLE
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::HangUp - exit", this));

    return hr;
}

// ReleaseSession
//  Releases the current session (if any)
// 
STDMETHODIMP CRTCCtl::ReleaseSession(void)
{
    HRESULT hr = S_OK;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::ReleaseSession - enter", this));
    
    ATLASSERT(m_nControState == RTCAX_STATE_CONNECTED);

    if (m_pRTCActiveSession)
    {      
        LOG((RTC_INFO, "[%p] CRTCCtl::ReleaseSession: releasing active session", this));

        m_pRTCActiveSession = NULL;

        SetControlState(RTCAX_STATE_IDLE);
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::ReleaseSession - exit", this));

    return hr;
}

// AddParticipant
//  Adds a new participant in a PhoneToPhone scenario
//
STDMETHODIMP CRTCCtl::AddParticipant(
    /*[in]*/ LPOLESTR pDestName,
    /*[in]*/ LPOLESTR pDestAddress,
    /*[in]*/ BOOL     bAddressEditable)
{
    HRESULT     hr;
    CComBSTR    bstrDestAddressChosen;

    LOG((RTC_INFO, "[%p] CRTCCtl::AddParticipant - enter", this));
    
    ATLASSERT(m_nControState == RTCAX_STATE_CONNECTED);

    // if there's no number specified, display the dialog box
    // 
    if(pDestAddress == NULL || *pDestAddress == L'\0')
    {
        m_bAddPartDlgIsActive = TRUE;
          
        hr = ShowDialByPhoneNumberDialog(m_hWnd,
                                        TRUE, // bAddParticipant
                                        pDestAddress,
                                        &bstrDestAddressChosen);

        m_bAddPartDlgIsActive = FALSE;
    }
    else
    {
        bstrDestAddressChosen = pDestAddress;

        hr = S_OK;
    }

    if(SUCCEEDED(hr))
    {
        // verify we are still in a CONNECTED state...
        if(m_nControlState == RTCAX_STATE_CONNECTED)
        {
            // Create the participant (callee)
            // This will fire events
            hr = m_pRTCActiveSession->AddParticipant(
                bstrDestAddressChosen,
                pDestName ? pDestName : L"",
                NULL);

            if(hr == HRESULT_FROM_WIN32(ERROR_USER_EXISTS))
            {
                DisplayMessage(
                        _Module.GetResourceInstance(),
                        m_hWnd,
                        IDS_MESSAGE_DUPLICATE_PARTICIPANT,
                        IDS_APPNAME,
                        MB_OK | MB_ICONEXCLAMATION);
            }
            else if (FAILED(hr))
            {
                DisplayMessage(
                        _Module.GetResourceInstance(),
                        m_hWnd,
                        IDS_MESSAGE_CANNOT_ADD_PARTICIPANT,
                        IDS_APPNAME,
                        MB_OK | MB_ICONSTOP);
            }
        }
        else
        {
            // switch back to IDLE if it is busy 
            // 
            if(m_nControlState == RTCAX_STATE_UI_BUSY)
            {
                SetControlState(RTCAX_STATE_IDLE);
            }

            hr = S_OK;
        }


        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::AddParticipant - error <%x> when calling AddParticipant", this, hr));

        }
    }
    else if (hr==E_ABORT)
    {
        LOG((RTC_TRACE, "[%p] CRTCCtl::AddParticipant: ShowXXXDialog dismissed, do nothing", this));

    }
    else
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::AddParticipant: error (%x) returned ShowXXXDialog", this, hr));

        SetControlState(RTCAX_STATE_IDLE);
    }

    LOG((RTC_INFO, "[%p] CRTCCtl::AddParticipant - exit", this));

    return hr;
}

// get_CanAddParticipant
//  
//
STDMETHODIMP CRTCCtl::get_CanAddParticipant(BOOL *pfCan)
{
    *pfCan = ConfButtonsActive();

    return S_OK;
}

// get_CurrentCallScenario
//
//
STDMETHODIMP CRTCCtl::get_CurrentCallScenario(RTC_CALL_SCENARIO *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_CurrentCallScenario - enter", this));

    *pVal = m_nCachedCallScenario;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_CurrentCallScenario - exit", this));

    return S_OK;
}

// PreProcessMessage
//  Gives the control a chance to process accelerators.
//
STDMETHODIMP CRTCCtl::PreProcessMessage(/*[in]*/ LPMSG lpMsg)
{
    if (m_pIMWindows)
    {
        if (m_pIMWindows->IsDialogMessage(lpMsg))
        {
            return S_OK;
        }
    }

    // directly call TranslateAccelerator of IOleInPlaceActiveObjectImpl for now
    return TranslateAccelerator(lpMsg);
}

// LoadStringResource
//  Load a string resource
//
STDMETHODIMP CRTCCtl::LoadStringResource(
				/*[in]*/ UINT nID,
				/*[in]*/ int nBufferMax,
				/*[out]*/ LPWSTR pszText)
{
    int nChars;

    nChars = LoadString(
        _Module.GetResourceInstance(),
        nID,
        pszText,
        nBufferMax);

    return nChars ? S_OK : HRESULT_FROM_WIN32(GetLastError());
}

// get_ControlState
//  Gets the control state
//
STDMETHODIMP CRTCCtl::get_ControlState( RTCAX_STATE *pVal)
{
    *pVal = m_nControlState;

    return S_OK;
}


// put_ControlState
//  Sets the control state
//
STDMETHODIMP CRTCCtl::put_ControlState( RTCAX_STATE pVal)
{
    SetControlState(pVal);

    return S_OK;
}


// put_Standalone
//  Sets the standalone mode
//
STDMETHODIMP CRTCCtl::put_Standalone(/*[in]*/ BOOL pVal)
{
    m_nCtlMode = pVal ? CTL_MODE_STANDALONE : CTL_MODE_HOSTED;

    if(pVal)
    {
        // this is the first moment the control becomes aware of its 
        // running within frame status 
        // Set the default visual layout for this case
        SetZoneLayout(&s_DefaultZoneLayout, TRUE);
     
    }
    return S_OK;
}

// put_Palette
//  Sets the palette
//
STDMETHODIMP CRTCCtl::put_Palette(/*[in]*/ HPALETTE hPalette)
{
    m_hPalette = hPalette;

    if (m_pSpeakerKnob != NULL)
    {
        m_pSpeakerKnob->SetPalette(m_hPalette);
    }

    if (m_pMicroKnob != NULL)
    {
        m_pMicroKnob->SetPalette(m_hPalette);
    }

    return S_OK;
}

// put_BackgroundPalette
//  Sets the background palette flag
//
STDMETHODIMP CRTCCtl::put_BackgroundPalette(/*[in]*/ BOOL bBackgroundPalette)
{
    m_bBackgroundPalette = bBackgroundPalette;

    if (m_pSpeakerKnob != NULL)
    {
        m_pSpeakerKnob->SetBackgroundPalette(m_bBackgroundPalette);
    }

    if (m_pMicroKnob != NULL)
    {
        m_pMicroKnob->SetBackgroundPalette(m_bBackgroundPalette);
    }

    return S_OK;
}

// put_ListenForIncomingSessions
//  Wrapper for the similar core function
//
STDMETHODIMP CRTCCtl::put_ListenForIncomingSessions(
    /*[in]*/ RTC_LISTEN_MODE enListen)
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_ListenForIncomingSessions(%x) - enter", this, enListen));

    // forward to the core
    ATLASSERT(m_pRTCClient != NULL);

    m_enListen = enListen;

    hr = m_pRTCClient->put_ListenForIncomingSessions(enListen);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::put_ListenForIncomingSessions: error (%x) when calling core, exit", this, hr));
        return hr;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_ListenForIncomingSessions(%x) - exit", this, enListen));

    return S_OK;
}

// get_ListenForIncomingSessions
//  Wrapper for the similar core function
//
STDMETHODIMP CRTCCtl::get_ListenForIncomingSessions(
    /*[out, retval]*/ RTC_LISTEN_MODE * penListen)
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_ListenForIncomingSessions - enter", this));

    // forward to the core
    ATLASSERT(m_pRTCClient != NULL);

    *penListen = m_enListen;

    LOG((RTC_TRACE, "[%p] CRTCCtl::get_ListenForIncomingSessions - enter", this));

    return S_OK;

}


// get_MediaCapabilities
//
STDMETHODIMP CRTCCtl::get_MediaCapabilities(/*[out, retval]*/ long *pVal)
{
    *pVal = m_lMediaCapabilities;

    return S_OK;
}

// get_MediaPreferences
//
STDMETHODIMP CRTCCtl::get_MediaPreferences(/*[out, retval]*/ long *pVal)
{
    // read the cached value
    *pVal = m_lMediaPreferences;

    return S_OK;
}

// put_MediaPreferences
//
STDMETHODIMP CRTCCtl::put_MediaPreferences(/*[in]*/ long pVal)
{
    HRESULT     hr;

    BOOL    bVideoSendEnabled;
    BOOL    bVideoSendDisabled;
    BOOL    bVideoRecvEnabled;
    BOOL    bVideoRecvDisabled;
    BOOL    bAudioSendEnabled;
    BOOL    bAudioSendDisabled;
    BOOL    bAudioRecvEnabled;
    BOOL    bAudioRecvDisabled;
    BOOL    bT120Enabled;
    BOOL    bT120Disabled;
   
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_MediaPreferences(%x) - enter", this, pVal));

    // Call the core
    ATLASSERT(m_pRTCClient != NULL);

    hr = m_pRTCClient->SetPreferredMediaTypes(pVal, m_nCtlMode == CTL_MODE_STANDALONE);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::put_MediaPreferences: error (%x) when calling core, exit", this, hr));
        return hr;
    }

    // Need this because Start/StopStream allows calling with
    // one media at a time
    bVideoSendEnabled = 
        !(m_lMediaPreferences & RTCMT_VIDEO_SEND) && (pVal & RTCMT_VIDEO_SEND);
    bVideoSendDisabled = 
        (m_lMediaPreferences & RTCMT_VIDEO_SEND) && !(pVal & RTCMT_VIDEO_SEND);
    bVideoRecvEnabled = 
        !(m_lMediaPreferences & RTCMT_VIDEO_RECEIVE) && (pVal & RTCMT_VIDEO_RECEIVE);
    bVideoRecvDisabled = 
        (m_lMediaPreferences & RTCMT_VIDEO_RECEIVE) && !(pVal & RTCMT_VIDEO_RECEIVE);
    bAudioSendEnabled = 
        !(m_lMediaPreferences & RTCMT_AUDIO_SEND) && (pVal & RTCMT_AUDIO_SEND);
    bAudioSendDisabled = 
        (m_lMediaPreferences & RTCMT_AUDIO_SEND) && !(pVal & RTCMT_AUDIO_SEND);
    bAudioRecvEnabled = 
        !(m_lMediaPreferences & RTCMT_AUDIO_RECEIVE) && (pVal & RTCMT_AUDIO_RECEIVE);
    bAudioRecvDisabled = 
        (m_lMediaPreferences & RTCMT_AUDIO_RECEIVE) && !(pVal & RTCMT_AUDIO_RECEIVE);
    bT120Enabled = 
        !(m_lMediaPreferences & RTCMT_T120_SENDRECV) && (pVal & RTCMT_T120_SENDRECV);
    bT120Disabled = 
        (m_lMediaPreferences & RTCMT_T120_SENDRECV) && !(pVal & RTCMT_T120_SENDRECV);

    // Set the internal member
    m_lMediaPreferences = pVal;

    // Refresh the buttons
    long lState;
        
    lState = (long)m_hReceivePreferredButton.SendMessage(BM_GETCHECK, 0, 0);
    if(lState == BST_CHECKED)
    {
        if(!(m_lMediaPreferences & RTCMT_VIDEO_RECEIVE))
        {
            m_hReceivePreferredButton.SendMessage(BM_SETCHECK, BST_UNCHECKED, 0);
        }
    }
    else
    {
        if(m_lMediaPreferences & RTCMT_VIDEO_RECEIVE)
        {
            m_hReceivePreferredButton.SendMessage(BM_SETCHECK, BST_CHECKED, 0);
        }
    }
    
    lState = (long)m_hSendPreferredButton.SendMessage(BM_GETCHECK, 0, 0);
    if(lState == BST_CHECKED)
    {
        if(!(m_lMediaPreferences & RTCMT_VIDEO_SEND))
        {
            m_hSendPreferredButton.SendMessage(BM_SETCHECK, BST_UNCHECKED, 0);
        }
    }
    else
    {
        if(m_lMediaPreferences & RTCMT_VIDEO_SEND)
        {
            m_hSendPreferredButton.SendMessage(BM_SETCHECK, BST_CHECKED, 0);
        }
    }

    // try to synchronize any current session
    // I check the state at each call, I don't what could happen
    // underneath the Core API
    // XXX strange things can happen during ANSWERING or CONNECTING states..
    //

    long lCookie = 0;

#define     SYNC_STREAM(b,op,m,c)                       \
    if(m_pRTCActiveSession &&                           \
        (m_nControlState == RTCAX_STATE_CONNECTED ||    \
         m_nControlState == RTCAX_STATE_CONNECTING ||   \
         m_nControlState == RTCAX_STATE_ANSWERING))     \
    {                                                   \
        if(b)                                           \
        {                                               \
            m_pRTCActiveSession -> op(m, c);            \
        }                                               \
    }

    SYNC_STREAM(bVideoSendDisabled, RemoveStream, RTCMT_VIDEO_SEND, lCookie)
    SYNC_STREAM(bVideoRecvDisabled, RemoveStream, RTCMT_VIDEO_RECEIVE, lCookie)
    SYNC_STREAM(bAudioSendDisabled, RemoveStream, RTCMT_AUDIO_SEND, lCookie)
    SYNC_STREAM(bAudioRecvDisabled, RemoveStream, RTCMT_AUDIO_RECEIVE, lCookie)
    SYNC_STREAM(bT120Disabled, RemoveStream, RTCMT_T120_SENDRECV, lCookie)
    
    SYNC_STREAM(bVideoSendEnabled, AddStream, RTCMT_VIDEO_SEND, lCookie)
    SYNC_STREAM(bVideoRecvEnabled, AddStream, RTCMT_VIDEO_RECEIVE, lCookie)
    SYNC_STREAM(bAudioSendEnabled, AddStream, RTCMT_AUDIO_SEND, lCookie)
    SYNC_STREAM(bAudioRecvEnabled, AddStream, RTCMT_AUDIO_RECEIVE, lCookie)
    SYNC_STREAM(bT120Enabled, AddStream, RTCMT_T120_SENDRECV, lCookie)

#undef      SYNC_STREAM    


    LOG((RTC_TRACE, "[%p] CRTCCtl::put_MediaPreferences - exit", this));

    return S_OK;
}

// get_AudioMuted
//
STDMETHODIMP CRTCCtl::get_AudioMuted(
    /*[in]*/ RTC_AUDIO_DEVICE enDevice,
    /*[out, retval]*/ BOOL *fpMuted)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::get_AudioMuted(%x) - enter", this, enDevice));

    // Call the core
    ATLASSERT(m_pRTCClient != NULL);

    VARIANT_BOOL fMuted;

    hr = m_pRTCClient->get_AudioMuted(enDevice, &fMuted);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::get_AudioMuted: error (%x) when calling core, exit", this, hr));
        return hr;
    }

    *fpMuted = fMuted ? TRUE : FALSE;

    LOG((RTC_TRACE, "[%p] CRTCCtl::get_AudioMuted - exit", this));

    return S_OK;
}


// put_AudioMuted
//
STDMETHODIMP CRTCCtl::put_AudioMuted(
    /*[in]*/ RTC_AUDIO_DEVICE enDevice,
    /*[in]*/ BOOL pVal)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_AudioMuted(%x,%x) - enter", this, enDevice, pVal));

    // Call the core
    ATLASSERT(m_pRTCClient != NULL);

    hr = m_pRTCClient->put_AudioMuted(enDevice, pVal ? VARIANT_TRUE : VARIANT_FALSE);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::put_AudioMuted: error (%x) when calling core, exit", this, hr));
        return hr;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_AudioMuted - exit", this));

    return S_OK;
}

// put_VideoPreview
//
STDMETHODIMP CRTCCtl::put_VideoPreview(
    /*[in]*/ BOOL pVal)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_VideoPreview(%s) - enter", this, pVal ? "true" : "false"));

    m_bPreviewWindowIsPreferred = pVal;
    
    // Apply changes to the existing video window, if necessary
    //
    ShowHidePreviewWindow(
        m_ZoneStateArray[AXCTL_ZONE_LOGOVIDEO].bShown
     && m_bPreviewWindowActive 
     && m_bPreviewWindowIsPreferred);

    // XXX Update the m_hPreviewPreferredButton button here
    //

    // save the setting

    hr = put_SettingsDword(SD_VIDEO_PREVIEW, m_bPreviewWindowIsPreferred);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::put_VideoPreview: error (%x) when calling core", this, hr));

        // not a big deal (at least for this setting)
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_VideoPreview(%s) - enter", this, pVal ? "true" : "false"));

    return hr;
}

// get_VideoPreview
//
STDMETHODIMP CRTCCtl::get_VideoPreview(/*[out, retval]*/ BOOL *pVal)
{
    *pVal = m_bPreviewWindowIsPreferred;

    return S_OK;
}



// ShowCallFromOptions
//
STDMETHODIMP CRTCCtl::ShowCallFromOptions()
{
    HRESULT     hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::ShowCallFromOptions - enter", this));

    ATLASSERT(m_pRTCClient != NULL);

    hr = ShowEditCallFromListDialog( m_hWnd );

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::ShowCallFromOptions: error (%x) returned by ShowEditCallFromListDialog, exit", this, hr));
        return hr;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::ShowCallFromOptions - exit", this));

    return S_OK;
}

// ShowServiceProviderOptions
//
STDMETHODIMP CRTCCtl::ShowServiceProviderOptions()
{
    HRESULT     hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::ShowServiceProviderOptions - enter", this));

    ATLASSERT(m_pRTCClient != NULL);

    hr = ShowEditServiceProviderListDialog( m_hWnd, m_pRTCClient );

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::ShowServiceProviderOptions: error (%x) returned by ShowEditCallFromListDialog, exit", this, hr));
        return hr;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::ShowServiceProviderOptions - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::StartT120Applet (RTC_T120_APPLET enApplet)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::StartT120Applet(%d) - enter", this, enApplet));

    // Call the core
    ATLASSERT(m_pRTCClient != NULL);

    hr = m_pRTCClient->StartT120Applet(enApplet);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::StartT120Applet: error (%x) when calling core, exit", this, hr));
        return hr;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::StartT120Applet - exit", this));

    return S_OK;
}

// SetZoneLayout
//
STDMETHODIMP CRTCCtl::SetZoneLayout(
    /* [in] */ CZoneStateArray *pArray,
    /* [in] */ BOOL bRefreshControls)
{
    int i;
    
    // Place each rectangle
    for(i=AXCTL_ZONE_TOOLBAR; i<AXCTL_ZONE_NR; i++)
    {
        PlaceAndEnableDisableZone(i, (*pArray) + i);
    }

    if(bRefreshControls)
    {
        // force the enable/disable of the windows controls
        // based on the new layout
        SetControlState(m_nControlState);
    }

    return S_OK;
}

//
// Message/command handlers
//


// OnInitDialog
//  Processes WM_INITDIALOG
//      CoCreates a CLSID_RTCClient object
//      Registers for notifications
//      Sets the UI items
//      
// 

LRESULT CRTCCtl::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr;
    BOOL    bInitError;
    UINT    nID = 0;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnInitDialog - enter", this));

    bInitError = FALSE;

    // Initialize the core
    hr = CoreInitialize();

    if(SUCCEEDED(hr))
    {
        ;   // nothing here
    }
    else
    {
        // a disabled UI will be displayed..
        bInitError = TRUE;
        nID = IDS_ERROR_INIT_CORE;
    }

    // Instant Messaging Window List
    //

    m_pIMWindows = new CIMWindowList( m_pRTCClient );

    if(m_pIMWindows == NULL)
    {
        LOG((RTC_ERROR, "CRTCCtl::OnInitDialog - failed to create IMWindowList"));

        bInitError = TRUE;
        nID = nID ? nID : IDS_ERROR_INIT_GENERIC;
    }

    // Tooltip window
    //
    CreateTooltips();

    //
    // Adjust initial vertical size as specified in sizeExtent
    //  
    // 

    RECT    rectAdjSize;
    SIZE    sizePixel;

    // get current size
    GetClientRect(&rectAdjSize);

    // Get size as known by the container
    AtlHiMetricToPixel(&m_sizeExtent, &sizePixel);

    // adjust the height
    rectAdjSize.bottom = rectAdjSize.top + sizePixel.cy;

    // resize the window
    MoveWindow(
        rectAdjSize.left,
        rectAdjSize.top,
        rectAdjSize.right - rectAdjSize.left,
        rectAdjSize.bottom - rectAdjSize.top,
        FALSE
        );
    
    //
    // Initialize and Attach all controls to their window wrappers
    //

    // hosts for video windows

    m_hReceiveWindow.Attach(GetDlgItem(IDC_RECEIVELOGO));
    m_hPreviewWindow.Attach(GetDlgItem(IDC_PREVIEWLOGO));
    
    // dtmf buttons

    CWindow *pDtmfCrt = m_hDtmfButtons;
    CWindow *pDtmfEnd = m_hDtmfButtons + NR_DTMF_BUTTONS;

    for (int id = IDC_DIAL_0; pDtmfCrt<pDtmfEnd; pDtmfCrt++, id++)
    {
        pDtmfCrt->Attach(GetDlgItem(id));
    }

    // Create the toolbar control
    hr = CreateToolbarControl(&m_hCtlToolbar);
    if(FAILED(hr))
    {
        bInitError = TRUE;
        nID = nID ? nID : IDS_ERROR_INIT_GENERIC;
    }

    // create a status control
    HWND hStatusBar = CreateStatusWindow(
            WS_CHILD | WS_VISIBLE,
            NULL,
            m_hWnd,
            IDC_STATUSBAR);

    if(hStatusBar==NULL)
    {
        LOG((RTC_ERROR, "CRTCCtl::OnInitDialog - failed to create status bar - 0x%08x",
                        GetLastError()));
        bInitError = TRUE;
        nID = nID ? nID : IDS_ERROR_INIT_GENERIC;
    }
    
    m_hStatusBar.Attach(hStatusBar);

    // Divides the status bar in parts
    RECT  rectStatus;
    INT  aWidths[SBP_NR_PARTS];

    rectStatus.left = 0;
    rectStatus.right = 0;

    m_hStatusBar.GetClientRect(&rectStatus);
        
    // divide fairly
    aWidths[SBP_STATUS] = rectStatus.right *4 / 5;
    aWidths[SBP_ICON] = -1;

    // set parts
    m_hStatusBar.SendMessage(SB_SETPARTS, (WPARAM)SBP_NR_PARTS, (LPARAM)aWidths);
    
    // Create buttons
    //

#define CREATE_BUTTON(m,id,ttid)                                    \
    {                                                               \
        RECT    rcButton;                                           \
                                                                    \
        rcButton.left = 0;                                          \
        rcButton.right = 0;                                         \
        rcButton.top = 0;                                           \
        rcButton.bottom = 0;                                        \
                                                                    \
        m.Create(                                                   \
            m_hWnd,                                                 \
            rcButton,                                               \
            _T(""),                                                 \
            WS_TABSTOP,                                             \
            MAKEINTRESOURCE(IDB_AV_INACTIVE),                       \
            MAKEINTRESOURCE(IDB_AV_INACTIVE_PUSH),                  \
            MAKEINTRESOURCE(IDB_AV_DISABLED),                       \
            MAKEINTRESOURCE(IDB_AV_INACTIVE_HOT),                   \
            MAKEINTRESOURCE(IDB_AV_ACTIVE),                         \
            MAKEINTRESOURCE(IDB_AV_ACTIVE_PUSH),                    \
            MAKEINTRESOURCE(IDB_AV_DISABLED),                       \
            MAKEINTRESOURCE(IDB_AV_ACTIVE_HOT),                     \
            NULL,                                                   \
            id);                                                    \
                                                                    \
        TOOLINFO    ti;                                             \
                                                                    \
        ti.cbSize = TTTOOLINFO_V1_SIZE;                             \
        ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;                    \
        ti.hwnd = m_hWnd;                                           \
        ti.uId = (UINT_PTR)(HWND)m;                                 \
        ti.hinst = _Module.GetResourceInstance();                   \
        ti.lpszText = MAKEINTRESOURCE(ttid);                        \
                                                                    \
        m_hTooltip.SendMessage(TTM_ADDTOOL, 0,                      \
                (LPARAM)(LPTOOLINFO)&ti);                           \
    }

    CREATE_BUTTON(m_hReceivePreferredButton, IDC_BUTTON_RECV_VIDEO_ENABLED, IDS_TIPS_RECV_VIDEO_ENABLED);
    
    CREATE_BUTTON(m_hSendPreferredButton, IDC_BUTTON_SEND_VIDEO_ENABLED, IDS_TIPS_SEND_VIDEO_ENABLED);

    CREATE_BUTTON(m_hSpeakerMuteButton, IDC_BUTTON_MUTE_SPEAKER, IDS_TIPS_MUTE_SPEAKER);

    CREATE_BUTTON(m_hMicroMuteButton, IDC_BUTTON_MUTE_MICRO, IDS_TIPS_MUTE_MICRO);

#undef CREATE_BUTTON

#define CREATE_BUTTON(m,id,sid,ttid)                                \
    {                                                               \
        RECT    rcButton;                                           \
        TCHAR   szText[0x100];                                      \
                                                                    \
        rcButton.left = 0;                                          \
        rcButton.right = 0;                                         \
        rcButton.top = 0;                                           \
        rcButton.bottom = 0;                                        \
                                                                    \
        szText[0] = _T('\0');                                       \
        ::LoadString(_Module.GetResourceInstance(),sid,             \
                szText, sizeof(szText)/sizeof(szText[0]));          \
                                                                    \
        m.Create(                                                   \
            m_hWnd,                                                 \
            rcButton,                                               \
            szText,                                                 \
            WS_TABSTOP,                                             \
            MAKEINTRESOURCE(IDB_BUTTON_NORM),                       \
            MAKEINTRESOURCE(IDB_BUTTON_PRESS),                      \
            MAKEINTRESOURCE(IDB_BUTTON_DIS),                        \
            MAKEINTRESOURCE(IDB_BUTTON_HOT),                        \
            NULL,                                                   \
            id);                                                    \
                                                                    \
        TOOLINFO    ti;                                             \
                                                                    \
        ti.cbSize = TTTOOLINFO_V1_SIZE;                             \
        ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;                    \
        ti.hwnd = m_hWnd;                                           \
        ti.uId = (UINT_PTR)(HWND)m;                                 \
        ti.hinst = _Module.GetResourceInstance();                   \
        ti.lpszText = MAKEINTRESOURCE(ttid);                        \
                                                                    \
        m_hTooltip.SendMessage(TTM_ADDTOOL, 0,                      \
                (LPARAM)(LPTOOLINFO)&ti);                           \
    }

    CREATE_BUTTON(m_hAddParticipant, IDC_BUTTON_ADD_PART, IDS_BUTTON_ADD_PART, IDS_TIPS_ADD_PART);
    
    CREATE_BUTTON(m_hRemParticipant, IDC_BUTTON_REM_PART, IDS_BUTTON_REM_PART, IDS_TIPS_REM_PART);

#undef CREATE_BUTTON
    //
    // setup knob controls
    //
    //
    
    // create speaker knob
    m_pSpeakerKnob = new CKnobCtl(
                                    IDB_SPKVOL,
                                    IDB_SPKVOL_HOT,
                                    IDB_SPKVOL_DISABLED,
                                    IDB_KNOB_LIGHT,
                                    IDB_KNOB_LIGHT_DIM,
                                    IDB_KNOB_LIGHT_DISABLED,
                                    IDB_KNOB_LIGHT_MASK);

    HWND        hWndSpeaker = NULL;

    if(m_pSpeakerKnob)
    {
        // Create the window
        hWndSpeaker = m_pSpeakerKnob->Create(
            m_hWnd,
            0,
            0,
            IDC_KNOB_SPEAKER);

        m_hSpeakerKnob.Attach(hWndSpeaker);
        m_hSpeakerKnob.SendMessage(TBM_SETPOS, (WPARAM)TRUE, 0);

        // add the tool to the tooltip window
        //
        TOOLINFO    ti;

        ti.cbSize = TTTOOLINFO_V1_SIZE; 
        ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
        ti.hwnd = m_hWnd;
        ti.uId = (UINT_PTR)hWndSpeaker;
        ti.hinst = _Module.GetResourceInstance();
        ti.lpszText = MAKEINTRESOURCE(IDS_TIPS_KNOB_SPEAKER);

        m_hTooltip.SendMessage(TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
    }
     
    // create microphone knob
    
    m_pMicroKnob = new CKnobCtl(
                                    IDB_MICVOL,
                                    IDB_MICVOL_HOT,
                                    IDB_MICVOL_DISABLED,
                                    IDB_KNOB_LIGHT,
                                    IDB_KNOB_LIGHT_DIM,
                                    IDB_KNOB_LIGHT_DISABLED,
                                    IDB_KNOB_LIGHT_MASK);

    HWND        hWndMicro = NULL;

    if(m_pMicroKnob)
    {
        // Create the window
        hWndMicro = m_pMicroKnob->Create(
            m_hWnd,
            0,
            0,
            IDC_KNOB_MICRO);

        m_hMicroKnob.Attach(hWndMicro);
        m_hMicroKnob.SendMessage(TBM_SETPOS, (WPARAM)TRUE, 0);

        // add the tool to the tooltip window
        //
        TOOLINFO    ti;

        ti.cbSize = TTTOOLINFO_V1_SIZE;
        ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
        ti.hwnd = m_hWnd;
        ti.uId = (UINT_PTR)hWndMicro;
        ti.hinst = _Module.GetResourceInstance();
        ti.lpszText = MAKEINTRESOURCE(IDS_TIPS_KNOB_MICRO);

        m_hTooltip.SendMessage(TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
    }
    

    // Participant list
    //
    m_hParticipantList.Attach(GetDlgItem(IDC_LIST_PARTICIPANTS));
    
    hr = m_hParticipantList.Initialize();
    if(FAILED(hr))
    {
        bInitError = TRUE;
        nID = nID ? nID : IDS_ERROR_INIT_GENERIC;
    }
    
    // some static text controls
    RECT    rectDummy;
    TCHAR   szText[0x100];

    rectDummy.bottom =0;
    rectDummy.left = 0;
    rectDummy.right = 0;
    rectDummy.top = 0;

    szText[0] = _T('\0');

    LoadString(_Module.GetResourceInstance(), IDS_TEXT_VIDEO, 
        szText, sizeof(szText)/sizeof(szText[0]));

    m_hReceivePreferredText.Create(m_hWnd, rectDummy, szText, WS_CHILD | WS_VISIBLE, WS_EX_TRANSPARENT);
    m_hSendPreferredText.Create(m_hWnd, rectDummy, szText, WS_CHILD | WS_VISIBLE, WS_EX_TRANSPARENT);
    
    szText[0] = _T('\0');

    LoadString(_Module.GetResourceInstance(), IDS_TEXT_AUDIO, 
        szText, sizeof(szText)/sizeof(szText[0]));

    m_hSpeakerMuteText.Create(m_hWnd, rectDummy, szText, WS_CHILD | WS_VISIBLE, WS_EX_TRANSPARENT);
    m_hMicroMuteText.Create(m_hWnd, rectDummy, szText, WS_CHILD | WS_VISIBLE, WS_EX_TRANSPARENT);

    szText[0] = _T('\0');

    LoadString(_Module.GetResourceInstance(), IDS_SEND, 
        szText, sizeof(szText)/sizeof(szText[0]));

    m_hSendText.Create(m_hWnd, rectDummy, szText, WS_CHILD | WS_VISIBLE, WS_EX_TRANSPARENT);
    m_hSendText.put_CenterHorizontal(TRUE);

    szText[0] = _T('\0');

    LoadString(_Module.GetResourceInstance(), IDS_RECEIVE, 
        szText, sizeof(szText)/sizeof(szText[0]));

    m_hReceiveText.Create(m_hWnd, rectDummy, szText, WS_CHILD | WS_VISIBLE, WS_EX_TRANSPARENT);
    m_hReceiveText.put_CenterHorizontal(TRUE);

    // place all controls at their initial position and set the tab order
    PlaceWindowsAtTheirInitialPosition();

    // make sure the sizes for the logo windows are corect
    // Their client area must exactly match QCIF and QCIF/4
    // This function must be called AFTER the video windows have
    // been placed at their initial position

    AdjustVideoFrames();

    // Load the accelerator for dialpad
    m_hAcceleratorDialpad = LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_ACCELERATOR_DIALPAD));
    if(!m_hAcceleratorDialpad)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnInitDialog - couldn't load the accelerator table for dialpad", this));
    }
    
    // Load the accelerator for toolbar
    m_hAcceleratorToolbar = LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_ACCELERATOR_TOOLBAR));
    if(!m_hAcceleratorToolbar)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnInitDialog - couldn't load the accelerator table for toolbar", this));
    }

    // Set the initial visual aspect
    // for Web hosted, use the properties in order to choose a predefined layout
    // for Frame based, the control is driven through IRTCCtlFrameSupport
    
    CZoneStateArray *pLayout;
        
    pLayout = &s_EmptyZoneLayout;

    // if standalone mode, m_nCtlMode is still set to unknown (it will be set
    // later by the main app through the IRTCCtlFrameSupport interf

    if(m_nCtlMode != CTL_MODE_HOSTED
        || (BSTR)m_bstrPropDestinationUrl == NULL
        || m_bstrPropDestinationUrl.Length()==0 ) 
    {
        // 
        nID =  nID ? nID : IDS_ERROR_INIT_INVPARAM_URL;
    }
    else
    {
        if(!bInitError)
        {
            // Create a one shot profile, this also validates the XML provisioning profile
            if(m_bstrPropProvisioningProfile!=NULL && *m_bstrPropProvisioningProfile!=L'\0')
            { 
                IRTCClientProvisioning * pProv = NULL;

                hr = m_pRTCClient->QueryInterface(
                            IID_IRTCClientProvisioning,
                            (void **) &pProv
                           );

                if (FAILED(hr))
                {
                    LOG((RTC_ERROR, "[%p] CRTCCtl::OnInitDialog; cannot QI for one shot provisioning, error %x", this, hr));

                    bInitError = TRUE;
                    nID =  nID ? nID : IDS_ERROR_INIT_INVPARAM_PROV;
                }
                else
                {
                    hr = pProv->CreateProfile(m_bstrPropProvisioningProfile, &m_pRTCOneShotProfile);

                    pProv->Release();
                    pProv = NULL;

                    if (FAILED(hr))
                    {
                        LOG((RTC_ERROR, "[%p] CRTCCtl::OnInitDialog; cannot create one shot profile, error %x", this, hr));

                        bInitError = TRUE;
                        nID =  nID ? nID : IDS_ERROR_INIT_INVPARAM_PROV;
                    }
                }
            }
            else
            {
                // it's not fatal for PC to PC
                if(m_nPropCallScenario != RTC_CALL_SCENARIO_PCTOPC)
                {
                    LOG((RTC_ERROR, "[%p] CRTCCtl::OnInitDialog; provisioning profile not present", this));
                    bInitError = TRUE;
                    nID =  nID ? nID : IDS_ERROR_INIT_INVPARAM_PROV;
                }
            }
        }
        if(!bInitError)
        {
            if(m_bBoolPropError)
            {
                bInitError = TRUE;
                nID =  nID ? nID : IDS_ERROR_INIT_INVPARAM_BOOLEAN;
            }
        }
        if(!bInitError)
        {
            if(m_pWebCrmLayout)
            {
                pLayout = m_pWebCrmLayout;
            }
            else
            {
                bInitError = TRUE;
                nID =  nID ? nID : IDS_ERROR_INIT_INVPARAM_SCENARIO;
            }
        }
    }
    
    // Load the background bitmap
    //
    m_hbmBackground = (HBITMAP)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(IDB_METAL),
        IMAGE_BITMAP,
        0,
        0,
        LR_CREATEDIBSECTION);

    // Set the control visual layout
    //

    SetZoneLayout(pLayout, FALSE);

    //
    // Brush for background
    //  using a cached one

    //m_hBckBrush = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
    m_hBckBrush = (HBRUSH)GetSysColorBrush(COLOR_3DFACE);
    m_hVideoBrush = (HBRUSH)GetStockObject(BLACK_BRUSH);

    // Refresh the audio controls
    RefreshAudioControls();

    // Refresh the video controls
    RefreshVideoControls();

    // activates the controls
    SetControlState((bInitError ? RTCAX_STATE_ERROR : RTCAX_STATE_IDLE), S_OK, nID);
     
    // freeze the properties
    m_bReadOnlyProp = TRUE;

    // post PlaceCall if AutoPlaceCall is TRUE && state is IDLE
    //  Currently all the initialization is done synchronously, so
    //  the ctl state must be IDLE if there has been no error.
    
    if(m_nControlState == RTCAX_STATE_IDLE
        && m_bPropAutoPlaceCall)
    {
        // post

        PostMessage(
            WM_COMMAND,
            MAKEWPARAM(IDC_BUTTON_CALL, 1), // Accelerator like
            NULL);
    }

    //
    // register for terminal services notifications
    //

    m_hWtsLib = LoadLibrary( _T("wtsapi32.dll") );

    if (m_hWtsLib)
    {
        WTSREGISTERSESSIONNOTIFICATION   fnWtsRegisterSessionNotification;
        
        fnWtsRegisterSessionNotification = 
            (WTSREGISTERSESSIONNOTIFICATION)GetProcAddress( m_hWtsLib, "WTSRegisterSessionNotification" );

        if (fnWtsRegisterSessionNotification)
        {
            fnWtsRegisterSessionNotification( m_hWnd, NOTIFY_FOR_THIS_SESSION );
        }
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnInitDialog - exit", this));

    bHandled = FALSE;

    // os sets focus
    return 1;
}

// OnDestroy
// Processes WM_DESTROY
//      Aborts any call
//      Unregister the event sink
//      Releases all references to the core
//      
// 

LRESULT CRTCCtl::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnDestroy - enter", this));

    //
    // unregister for terminal services notifications
    //

    if (m_hWtsLib)
    {
        WTSUNREGISTERSESSIONNOTIFICATION fnWtsUnRegisterSessionNotification;

        fnWtsUnRegisterSessionNotification = 
            (WTSUNREGISTERSESSIONNOTIFICATION)GetProcAddress( m_hWtsLib, "WTSUnRegisterSessionNotification" );

        if (fnWtsUnRegisterSessionNotification)
        {
            fnWtsUnRegisterSessionNotification( m_hWnd );
        }

        FreeLibrary( m_hWtsLib );
        m_hWtsLib = NULL;
    }

    // destroy the IM windows
    if (m_pIMWindows)
    {
        delete m_pIMWindows;
        m_pIMWindows = NULL;
    }

    // uninitialize the core
    CoreUninitialize();

    // Destroy the toolbar control
    DestroyToolbarControl(&m_hCtlToolbar);

    // Destroy GDI resources
    if(m_hbmBackground)
    {
        DeleteObject(m_hbmBackground);
        m_hbmBackground = NULL;
    }

    PostQuitMessage(0);

    bHandled = FALSE;   
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnDestroy - exit", this));
    return 0;
}

// OnWtsSessionChange
//
LRESULT CRTCCtl::OnWtsSessionChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnWtsSessionChange - enter", this));
    HRESULT hr;


    switch( wParam )
    {
    case WTS_CONSOLE_CONNECT:
        LOG((RTC_INFO, "[%p] CRTCCtl::OnWtsSessionChange - WTS_CONSOLE_CONNECT (%d)",
            this, lParam));

        if ( m_enListen != RTCLM_NONE)
        {
            LOG((RTC_INFO, "[%p] CRTCCtl::OnWtsSessionChange - enabling listen", this));

            ATLASSERT(m_pRTCClient != NULL);

            hr = m_pRTCClient->put_ListenForIncomingSessions( m_enListen );

            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::OnWtsSessionChange - "
                        "error <%x> when calling put_ListenForIncomingSessions", this, hr));
            }
        }
        break;

    case WTS_CONSOLE_DISCONNECT:
        LOG((RTC_INFO, "[%p] CRTCCtl::OnWtsSessionChange - WTS_CONSOLE_DISCONNECT (%d)",
            this, lParam));

        // if a call is active
        if(m_nControlState == RTCAX_STATE_CONNECTING ||
           m_nControlState == RTCAX_STATE_CONNECTED ||
           m_nControlState == RTCAX_STATE_ANSWERING)
        {
            LOG((RTC_INFO, "[%p] CRTCCtl::OnWtsSessionChange - dropping active call", this));

            if (m_nCachedCallScenario == RTC_CALL_SCENARIO_PHONETOPHONE)
            {
                ReleaseSession();
            }
            else
            {
                HangUp();
            }
        }

        if ( m_enListen != RTCLM_NONE )
        {
            LOG((RTC_INFO, "[%p] CRTCCtl::OnWtsSessionChange - disabling listen", this));

            ATLASSERT(m_pRTCClient != NULL);

            hr = m_pRTCClient->put_ListenForIncomingSessions( RTCLM_NONE );

            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::OnWtsSessionChange - "
                        "error <%x> when calling put_ListenForIncomingSessions", this, hr));
            }
        }

        break;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnWtsSessionChange - exit", this));
    return 0;
}

// OnKnobNotify
// Processes WM_NOTIFY from Volume knobs
LRESULT CRTCCtl::OnKnobNotify(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnKnobNotify - enter", this));

    HRESULT hr;

    CWindow *pKnob = idCtrl == IDC_KNOB_SPEAKER ?
        &m_hSpeakerKnob : &m_hMicroKnob;
    
    long lPos = (long)pKnob->SendMessage(TBM_GETPOS, 0, 0);

    hr = m_pRTCClient->put_Volume( 
        idCtrl == IDC_KNOB_SPEAKER ? RTCAD_SPEAKER : RTCAD_MICROPHONE, 
        lPos );
       
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnKnobNotify - error <%x> when calling put_Volume", this, hr));
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnKnobNotify - exit", this));

    return 0;
}

// OnKnobNotify
// Processes WM_NOTIFY from Volume knobs
LRESULT CRTCCtl::OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnItemChanged - exit", this));

    NMLISTVIEW  *pnmlv = (NMLISTVIEW *)pnmh;

    if((pnmlv->uChanged & LVIF_STATE) && (pnmlv->uNewState & LVIS_SELECTED))
    {
        // update the delete button
        UpdateRemovePartButton();
    }

    return 0;
}

// OnButtonCall
// Processes BN_CLICK

LRESULT CRTCCtl::OnButtonCall(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonCall - enter", this));

    // Must be in RTCAX_STATE_IDLE state
    if(m_nControlState != RTCAX_STATE_IDLE)
    {
        //ATLASSERT(
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnButtonCall - invalid control state (%d), exit", this, m_nControlState));
        
        return 0;
    }
    
    //
    // Proceed with the call.
    //

    CallOneShot();

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonCall - exit", this));

    return 0;
}

// OnButtonHangUp
// Processes BN_CLICK

LRESULT CRTCCtl::OnButtonHangUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonHangUp - enter", this));

    // Must be in RTCAX_STATE_CONNECTING or ..CONNECTED state
    if(m_nControlState != RTCAX_STATE_CONNECTING &&
       m_nControlState != RTCAX_STATE_CONNECTED &&
       m_nControlState != RTCAX_STATE_ANSWERING)
    {
        //ATLASSERT(
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnButtonHangUp - invalid control state (%d), exit", this, m_nControlState));
        
        return 0;
    }
    
    //
    // Proceed with hang up
    //
    HangUp();

    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonHangUp - exit", this));

    return 0;
}


// OnToolbarAccel
// Processes toolbar accelerators

LRESULT CRTCCtl::OnToolbarAccel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnToolbarAccel - enter", this));
    
    // 
    //  Is the button enabled ?
    // 
    LRESULT lState;

    lState = m_hCtlToolbar.SendMessage(TB_GETSTATE, (WPARAM)wID);

    if(lState != -1 && (lState & TBSTATE_ENABLED) 
        && (wID == IDC_BUTTON_CALL || wID == IDC_BUTTON_HUP))
    {
        //
        //  Visual feedback - press the button
        //
        
        m_hCtlToolbar.SendMessage(TB_SETSTATE, (WPARAM)wID, (LPARAM)(lState | TBSTATE_PRESSED));

        // 
        // Set a timer for depressing the key
        //  Using the button ID as a timer id.  
        //

        if (0 == SetTimer(wID, 150))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::OnToolbarAccel - failed to create a timer", this));

            // revert the button if SetTimer has failed
            m_hCtlToolbar.SendMessage(TB_SETSTATE, (WPARAM)wID, (LPARAM)lState);
            
            //
            // Call recursively, don't have visual effect
            //
    
            SendMessage(
                WM_COMMAND,
                MAKEWPARAM(wID, BN_CLICKED),
                (LPARAM)hWndCtl);
        }

        //
        // If a timer has been fired, the call of the relevant method
        //  will happen during WM_TIMER
        //
            
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnToolbarAccel - exit", this));

    return 0;
}

// OnButtonAddPart
// Processes BN_CLICK

LRESULT CRTCCtl::OnButtonAddPart(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    return AddParticipant(NULL, NULL, TRUE);
}

// OnButtonRemPart
// Processes BN_CLICK

LRESULT CRTCCtl::OnButtonRemPart(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    IRTCParticipant *pParticipant = NULL;
    HRESULT hr;

    // prepare the deletion from the list view
    hr = m_hParticipantList.Remove(&pParticipant);
    if(SUCCEEDED(hr) && pParticipant)
    {
        if(m_pRTCActiveSession)
        {
            hr = m_pRTCActiveSession->RemoveParticipant(pParticipant);
        }
        else
        {
            hr = E_UNEXPECTED;
        }

        pParticipant -> Release();
    }
    
    // refresh the Remove Participant button
    UpdateRemovePartButton();

    return hr;
 
}


// OnButtonMuteSpeaker
// Processes BN_CLICK

LRESULT CRTCCtl::OnButtonMuteSpeaker(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{  
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonMuteSpeaker - enter", this));

    HRESULT hr;

    long lState = (long)m_hSpeakerMuteButton.SendMessage(BM_GETCHECK, 0, 0);

    // the button is actually the opposite of "mute"
    // so set the opposite of the opposite
    hr = m_pRTCClient->put_AudioMuted( RTCAD_SPEAKER, (!(lState == BST_UNCHECKED)) ? VARIANT_TRUE : VARIANT_FALSE );
       
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnButtonMuteSpeaker - error <%x> when calling put_AudioMuted", this, hr));
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonMuteSpeaker - exit", this));

    return 0;
}

// OnButtonMuteMicro
// Processes BN_CLICK

LRESULT CRTCCtl::OnButtonMuteMicro(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{  
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonMuteMicro - enter", this));

    HRESULT hr;

    long lState = (long)m_hMicroMuteButton.SendMessage(BM_GETCHECK, 0, 0);

    // the button is actually the opposite of "mute"
    // so set the opposite of the opposite
    hr = m_pRTCClient->put_AudioMuted( RTCAD_MICROPHONE, (!(lState == BST_UNCHECKED)) ? VARIANT_TRUE : VARIANT_FALSE );
       
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnButtonMuteMicro - error <%x> when calling put_AudioMuted", this, hr));
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonMuteMicro - exit", this));

    return 0;
}

// OnButtonRecvVideo
// Processes BN_CLICK

LRESULT CRTCCtl::OnButtonRecvVideo(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{  
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonRecvVideo - enter", this));

    HRESULT hr;

    long lState = (long)m_hReceivePreferredButton.SendMessage(BM_GETCHECK, 0, 0);

    // calculate the new preference
    long    lNewMediaPreferences = m_lMediaPreferences;    

    lNewMediaPreferences &= ~RTCMT_VIDEO_RECEIVE;
    // the opposite
    lNewMediaPreferences |= (lState == BST_UNCHECKED ? RTCMT_VIDEO_RECEIVE : 0);

    // call the internal function, which also updates the button
    // the change is persistent or volatle depending on 
    // the model (standalone or webcrm)
    hr = put_MediaPreferences( lNewMediaPreferences );
       
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnButtonRecvVideo - error <%x> when calling put_MediaPreference", this, hr));
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonRecvVideo - exit", this));

    return 0;
}

// OnButtonSendVideo
// Processes BN_CLICK

LRESULT CRTCCtl::OnButtonSendVideo(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{  
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonSendVideo - enter", this));

    HRESULT hr;

    long lState = (long)m_hSendPreferredButton.SendMessage(BM_GETCHECK, 0, 0);

    // calculate the new preference
    long    lNewMediaPreferences = m_lMediaPreferences;    

    lNewMediaPreferences &= ~RTCMT_VIDEO_SEND;
    // the opposite
    lNewMediaPreferences |= (lState == BST_UNCHECKED ? RTCMT_VIDEO_SEND : 0);

    // call the internal function, which also updates the button
    // the change is persistent or volatle depending on 
    // the model (standalone or webcrm)
    hr = put_MediaPreferences( lNewMediaPreferences );
       
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnButtonSendVideo - error <%x> when calling put_MediaPreference", this, hr));
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonSendVideo - exit", this));

    return 0;
}




// OnDialButton
//  Processes dialpad buttons
//

LRESULT CRTCCtl::OnDialButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnDialButton - enter", this));

    // What a hack... When using accelerators, TranslateAccelerator puts 1
    // in the hiword of wParam, which is the notify code. Just like that.
    // Wonder what would happen if BN_PAINT (==1) was sent
    if(wNotifyCode==BN_CLICKED || wNotifyCode == 1)
    {
        ATLASSERT(m_pRRTCClient.p);

        WORD wButton = wID - IDC_DIAL_0;

        if(wButton < NR_DTMF_BUTTONS)
        {

            if(wNotifyCode == 1)
            {
                // Do visual feedback
                m_hDtmfButtons[wButton].SendMessage(BM_SETSTATE, (WPARAM)TRUE);
                
                // Set a timer for depressing the key
                // 
                if (0 == SetTimer(wButton + 1, 150))
                {
                    LOG((RTC_ERROR, "[%p] CRTCCtl::OnDialButton - failed to create a timer", this));

                    // revert the button if SetTimer has failed
                    m_hDtmfButtons[wButton].SendMessage(BM_SETSTATE, (WPARAM)FALSE);
                }
            }
            
            // Call in the core
            //
            hr = m_pRTCClient->SendDTMF((RTC_DTMF)wButton);
            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::OnDialButton - error <%x> when calling SendDTMF", this, hr));
            }
        }
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnDialButton - exit", this));

    return 0;
}

// OnDialogColor
//  Returns the brush to be used for background

LRESULT CRTCCtl::OnDialogColor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HDC         dc = (HDC) wParam;
    LOGBRUSH    lb;

    HBRUSH  hBrush;

    // the video windows have a different brush
    if((HWND)lParam == (HWND)m_hReceiveWindow ||
       (HWND)lParam == (HWND)m_hPreviewWindow)
    {
        hBrush = m_hVideoBrush;
    }
    else
    {
        hBrush = m_hBckBrush;
    }


    ::GetObject(hBrush, sizeof(lb), (void*)&lb);
    ::SetBkColor(dc, lb.lbColor);
    //::SetBkMode(dc, TRANSPARENT);
    
    return (LRESULT)hBrush;
}

// OnDrawItem
//  

LRESULT CRTCCtl::OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT)lParam;

    if (wParam != 0)
    {
        //
        // This was sent by a control
        // 

        if (lpdis->CtlType == ODT_BUTTON)
        {
            CButton::OnDrawItem(lpdis, m_hPalette, m_bBackgroundPalette);
        }
    }

    return 0;
}

// OnEraseBackground
//  Paints the background

LRESULT CRTCCtl::OnEraseBackground(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HDC         dc = (HDC) wParam;

    HBITMAP     hbmOldBitmap = NULL;
    HDC         hdcCompatible = NULL;

    if (!m_hbmBackground)
    {
        // hmm, no bitmap... Fallback

        bHandled = FALSE;

        return 0;
    }

    if (m_hPalette)
    {
        SelectPalette(dc, m_hPalette, m_bBackgroundPalette);
        RealizePalette(dc);
    }

    // create a compatible DC
    //
    hdcCompatible = CreateCompatibleDC(dc);
    if (!hdcCompatible)
    {
        // hmm, cannot create DC... Fallback

        bHandled = FALSE;

        return 0;
    }

    // select the bitmap in the context
    //
    hbmOldBitmap = (HBITMAP)SelectObject(
        hdcCompatible,
        m_hbmBackground);


    // copy the bits..
    //
    RECT    destRect;

    GetClientRect(&destRect);

    BitBlt(
        dc,
        destRect.left,
        destRect.top,
        destRect.right,
        destRect.bottom,
        hdcCompatible,
        0,
        0,
        SRCCOPY);

    // Cleanup
    //
    if (hbmOldBitmap)
    {
        SelectObject(hdcCompatible, hbmOldBitmap);
    }

    DeleteDC(hdcCompatible);

    return 1;
}


// OnTimer
//  Depresses a dialpad or toolbar button

LRESULT CRTCCtl::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(wParam > 0  && wParam <= NR_DTMF_BUTTONS)
    {
        // depress the button
        m_hDtmfButtons[wParam-1].SendMessage(BM_SETSTATE, (WPARAM)FALSE);
        
    }
    else if (wParam == IDC_BUTTON_CALL ||  wParam == IDC_BUTTON_HUP)
    {
        LRESULT     lState;

        //
        // Get current state of the tool button
        //  The button id is equal to the timer id

        lState = m_hCtlToolbar.SendMessage(TB_GETSTATE, wParam);

        if(lState != -1)
        {
            // Mask the "pressed" attribute
            // I hope I don't interfere with any action the user might take

            m_hCtlToolbar.SendMessage(TB_SETSTATE, wParam, (LPARAM)(lState & ~TBSTATE_PRESSED));

            if(lState & TBSTATE_ENABLED)
            {
                //
                // Call recursively
                //
    
                SendMessage(
                    WM_COMMAND,
                    MAKEWPARAM(wParam, BN_CLICKED),
                    NULL);
            }
            
        }
    }
    
    // kill the timer...
    KillTimer((UINT)wParam);

    return 0;
}

// OnGetDispInfo
//  Retrieves text for tooltips
//
LRESULT CRTCCtl::OnGetDispInfo(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LPTOOLTIPTEXT   lpttt; 
    UINT            idButton;
 
    lpttt = (LPTOOLTIPTEXT) pnmh; 
    
    // module instance for resources
    lpttt->hinst = _Module.GetResourceInstance(); 
 
    if( lpttt->uFlags & TTF_IDISHWND )
    {
        // idFrom is actually the HWND of the tool
        idButton = ::GetDlgCtrlID((HWND)lpttt->hdr.idFrom);
    }
    else
    {
        // idFrom is the id of the button
        idButton = (UINT)(lpttt->hdr.idFrom); 
    }

    // string resource for the given button
    switch (idButton) 
    { 
    case IDC_BUTTON_CALL: 
        lpttt->lpszText = MAKEINTRESOURCE(IDS_TIPS_CALL); 
        break; 
    
    case IDC_BUTTON_HUP: 
        lpttt->lpszText = MAKEINTRESOURCE(IDS_TIPS_HANGUP); 
        break;
   }
    
    // we don't want to be asked again..
    lpttt->uFlags |= TTF_DI_SETITEM;

    return 0;
}


//
// Internal functions
//

// PreTranslateAccelerator
//      Translates the accelerators
//      This overrides the implementation from CComCompositeControl in order to
//  enable dialpad acces through the numeric keys
//
BOOL CRTCCtl::PreTranslateAccelerator(LPMSG pMsg, HRESULT& hRet)
{
    // is the dialpad visible and enabled ?
    if(m_ZoneStateArray[AXCTL_ZONE_DIALPAD].bShown && 
       m_nControlState == RTCAX_STATE_CONNECTED &&
       m_hAcceleratorDialpad)
    {
        if(::TranslateAccelerator(m_hWnd, m_hAcceleratorDialpad, pMsg))
        {
            // translated, return
            hRet = S_OK;
            return TRUE;
        }
    }

    // is the toolbar is enabled..
    if(m_ZoneStateArray[AXCTL_ZONE_TOOLBAR].bShown && 
       m_hAcceleratorToolbar)
    {
        if(::TranslateAccelerator(m_hWnd, m_hAcceleratorToolbar, pMsg))
        {
            // translated, return
            hRet = S_OK;
            return TRUE;
        }
    }


    // Pass it down in the chain
    return CComCompositeControl<CRTCCtl>::PreTranslateAccelerator(pMsg, hRet);
}


// CreateToolbarControl
//      Creates the toolbar control
// 

#define     RTCCTL_BITMAP_CX    19
#define     RTCCTL_BITMAP_CY    19

HRESULT CRTCCtl::CreateToolbarControl(CWindow *phToolbar)
{
    HRESULT     hr;
    HWND        hToolbar;
    HBITMAP     hBitmap = NULL;
    TBBUTTON    tbb[2];
    int         iCall, iHup;
    TCHAR       szBuf[MAX_STRING_LEN];


    // Create the "normal" image list
    m_hNormalImageList = ImageList_Create(RTCCTL_BITMAP_CX, RTCCTL_BITMAP_CY, ILC_COLOR | ILC_MASK , 5, 5);
    if(m_hNormalImageList)
    {
        // Open a bitmap
        hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOLBAR_NORMAL));
        if(hBitmap)
        {
            // Add the bitmap to the image list
            ImageList_AddMasked(m_hNormalImageList, hBitmap, BMP_COLOR_MASK);

            DeleteObject(hBitmap);
            hBitmap = NULL;
        }
    }
    
    // Create the "disabled" image list
    m_hDisabledImageList = ImageList_Create(RTCCTL_BITMAP_CX, RTCCTL_BITMAP_CY, ILC_COLOR | ILC_MASK , 5, 5);
    if(m_hDisabledImageList)
    {
        // Open a bitmap
        hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOLBAR_DISABLED));
        if(hBitmap)
        {
            // Add the bitmap to the image list
            ImageList_AddMasked(m_hDisabledImageList, hBitmap, BMP_COLOR_MASK);

            DeleteObject(hBitmap);
            hBitmap = NULL;
        }
    }
    
    // Create the "hot" image list
    m_hHotImageList = ImageList_Create(RTCCTL_BITMAP_CX, RTCCTL_BITMAP_CY, ILC_COLOR | ILC_MASK , 5, 5);
    if(m_hHotImageList)
    {
        // Open a bitmap
        hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOLBAR_HOT));
        if(hBitmap)
        {
            // Add the bitmap to the image list
            ImageList_AddMasked(m_hHotImageList, hBitmap, BMP_COLOR_MASK);

            DeleteObject(hBitmap);
            hBitmap = NULL;
        }
    }

    // Create the toolbar
    hToolbar = CreateWindowEx(
        0, 
        TOOLBARCLASSNAME, 
        (LPTSTR) NULL,
        WS_CHILD | WS_VISIBLE | TBSTYLE_LIST | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS, 
        3, 
        0, 
        0, 
        0, 
        m_hWnd, 
        (HMENU) IDC_TOOLBAR, 
        _Module.GetResourceInstance(), 
        NULL); 

    if(hToolbar!=NULL)
    {
        // backward compatibility
        SendMessage(hToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM) sizeof(TBBUTTON), 0);
        
        // Set the image lists
        SendMessage(hToolbar, TB_SETIMAGELIST, 0, (LPARAM)m_hNormalImageList); 
        SendMessage(hToolbar, TB_SETHOTIMAGELIST, 0, (LPARAM)m_hHotImageList); 
        SendMessage(hToolbar, TB_SETDISABLEDIMAGELIST, 0, (LPARAM)m_hDisabledImageList); 

        // Load text strings for buttons
        // Call button
        szBuf[0] = _T('\0');
        LoadString(_Module.GetResourceInstance(), IDS_BUTTON_CALL, szBuf, MAX_STRING_LEN-1); 
        // Save room for second null terminator.
        szBuf[ocslen(szBuf) + 1] = 0;  //Double-null terminate. 
        // add the string to the toolbar
        iCall = (UINT)SendMessage(hToolbar, TB_ADDSTRING, 0, (LPARAM) szBuf);
        
        // HangUp button
        szBuf[0] = _T('\0');
        LoadString(_Module.GetResourceInstance(), IDS_BUTTON_HANGUP, szBuf, MAX_STRING_LEN-1); 
        // Save room for second null terminator.
        szBuf[ocslen(szBuf) + 1] = 0;  //Double-null terminate. 
        // add the string to the toolbar
        iHup = (UINT)SendMessage(hToolbar, TB_ADDSTRING, 0, (LPARAM) szBuf);

        // Prepare the button structs
        tbb[0].iBitmap = m_nPropCallScenario == RTC_CALL_SCENARIO_PCTOPC ?
            ILI_TB_CALLPC :  ILI_TB_CALLPHONE;
        tbb[0].iString = iCall;
        tbb[0].dwData = 0;
        tbb[0].fsStyle = BTNS_BUTTON;
        tbb[0].fsState = 0;
        tbb[0].idCommand = IDC_BUTTON_CALL;

        tbb[1].iBitmap = ILI_TB_HANGUP;
        tbb[1].iString = iHup;
        tbb[1].dwData = 0;
        tbb[1].fsStyle = BTNS_BUTTON;
        tbb[1].fsState = 0;
        tbb[1].idCommand = IDC_BUTTON_HUP;

        // Add the buttons to the toolbar
        SendMessage(hToolbar, TB_ADDBUTTONS, sizeof(tbb)/sizeof(tbb[0]), 
            (LPARAM) (LPTBBUTTON) &tbb); 
 
        // Autosize the generated toolbar
        SendMessage(hToolbar, TB_AUTOSIZE, 0, 0); 

        // Attach to the wrapper
        phToolbar->Attach(hToolbar);

        hr = S_OK;
    }
    else
    {
        LOG((RTC_ERROR, "CRTCCtl::CreateToolbarControl - error (%x) when trying to create the toolbar", GetLastError()));

        if(m_hNormalImageList)
        {
            ImageList_Destroy(m_hNormalImageList);
            m_hNormalImageList = NULL;
        }
        if(m_hHotImageList)
        {
            ImageList_Destroy(m_hHotImageList);
            m_hHotImageList = NULL;
        }
        if(m_hDisabledImageList)
        {
            ImageList_Destroy(m_hDisabledImageList);
            m_hDisabledImageList = NULL;
        }

        hr = E_FAIL;
    }

    return hr;
}

// DestroyToolbarControl
//      Destroys the toolbar control and the associated image lists.
// 

void CRTCCtl::DestroyToolbarControl(CWindow *phToolbar)
{
    
    HWND    hToolbar = phToolbar->Detach();

    if(hToolbar)
    {
        ::DestroyWindow(hToolbar);
    }
    
    if(m_hNormalImageList)
    {
        ImageList_Destroy(m_hNormalImageList);
        m_hNormalImageList = NULL;
    }
    
    if(m_hHotImageList)
    {
        ImageList_Destroy(m_hHotImageList);
        m_hHotImageList = NULL;
    }

    if(m_hDisabledImageList)
    {
        ImageList_Destroy(m_hDisabledImageList);
        m_hDisabledImageList = NULL;
    }
}

// CreateTooltips
//      Creates the tooltip window
// 


BOOL CRTCCtl::CreateTooltips()
{
    HWND hwndTT = CreateWindowEx(0, TOOLTIPS_CLASS, (LPTSTR) NULL,
        0, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        CW_USEDEFAULT, m_hWnd, (HMENU) NULL, _Module.GetModuleInstance(), NULL);

    if (hwndTT == NULL)
        return FALSE;

    m_hTooltip.Attach(hwndTT);

    return TRUE;
}


// PlaceWindowsAtTheirInitialPosition
//      Positions and sizes all the controls to their "initial" position
//   It's needed because all further moving is done relatively. 
//  This function also establishes the right tab order

void CRTCCtl::PlaceWindowsAtTheirInitialPosition()
{
    HWND   hPrevious = NULL;

#define POSITION_WINDOW(m,x,y,cx,cy,f)                  \
    m.SetWindowPos(                                     \
        hPrevious,                                      \
        x,                                              \
        y,                                              \
        cx,                                             \
        cy,                                             \
        SWP_NOACTIVATE | f );                           \
    hPrevious = (HWND)m;       

    // toolbar control (no size/move)
    POSITION_WINDOW(m_hCtlToolbar, 
        CTLPOS_X_RECEIVEWIN, CTLPOS_Y_RECEIVEWIN, 
        0, 0,
        SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER);


    // this window resizes itself in AdjustVideoWindows
    POSITION_WINDOW(m_hReceiveWindow, 
        CTLPOS_X_RECEIVEWIN, CTLPOS_Y_RECEIVEWIN, 
        0, 0,
        SWP_NOSIZE);

    // This window is moved and resized in AdjustVideoWindows
    POSITION_WINDOW(m_hPreviewWindow, 
        0, 0, 
        0, 0,
        SWP_NOSIZE | SWP_NOMOVE);

    // dtmf buttons
    CWindow *pDtmfCrt = m_hDtmfButtons;
    CWindow *pDtmfEnd = m_hDtmfButtons + NR_DTMF_BUTTONS;

    for (int id = IDC_DIAL_0; pDtmfCrt<pDtmfEnd; pDtmfCrt++, id++)
    {
        POSITION_WINDOW((*pDtmfCrt), 
            CTLPOS_X_DIALPAD + ((id - IDC_DIAL_0) % 3) * (CX_DIALPAD_BUTTON + CTLPOS_DX_DIALPAD),
            CTLPOS_Y_DIALPAD + ((id - IDC_DIAL_0) / 3) * (CY_DIALPAD_BUTTON + CTLPOS_DY_DIALPAD), 
            CX_DIALPAD_BUTTON, CY_DIALPAD_BUTTON,
            0);
    }


    POSITION_WINDOW(m_hReceivePreferredButton, 
        CTLPOS_X_RECV_VIDEO, CTLPOS_Y_RECV_VIDEO, 
        CX_CHECKBOX_BUTTON, CY_CHECKBOX_BUTTON,
        0);
    
    POSITION_WINDOW(m_hSendPreferredButton, 
        CTLPOS_X_SEND_VIDEO, CTLPOS_Y_SEND_VIDEO, 
        CX_CHECKBOX_BUTTON, CY_CHECKBOX_BUTTON,
        0);

    POSITION_WINDOW(m_hSpeakerMuteButton, 
        CTLPOS_X_RECV_AUDIO_MUTE, CTLPOS_Y_RECV_AUDIO_MUTE, 
        CX_CHECKBOX_BUTTON, CY_CHECKBOX_BUTTON,
        0);
    
    POSITION_WINDOW(m_hMicroMuteButton, 
        CTLPOS_X_SEND_AUDIO_MUTE, CTLPOS_Y_SEND_AUDIO_MUTE, 
        CX_CHECKBOX_BUTTON, CY_CHECKBOX_BUTTON,
        0);
    
    // all the static texts (doesn't really matter)

    POSITION_WINDOW(m_hReceivePreferredText, 
        CTLPOS_X_RECV_VIDEO_TEXT, CTLPOS_Y_RECV_VIDEO_TEXT, 
        CX_GENERIC_TEXT, CY_GENERIC_TEXT,
        0);
    
    POSITION_WINDOW(m_hSendPreferredText, 
        CTLPOS_X_SEND_VIDEO_TEXT, CTLPOS_Y_SEND_VIDEO_TEXT, 
        CX_GENERIC_TEXT, CY_GENERIC_TEXT,
        0);
    
    POSITION_WINDOW(m_hSpeakerMuteText, 
        CTLPOS_X_RECV_AUDIO_MUTE_TEXT, CTLPOS_Y_RECV_AUDIO_MUTE_TEXT, 
        CX_GENERIC_TEXT, CY_GENERIC_TEXT,
        0);
    
    POSITION_WINDOW(m_hMicroMuteText, 
        CTLPOS_X_SEND_AUDIO_MUTE_TEXT, CTLPOS_Y_SEND_AUDIO_MUTE_TEXT, 
        CX_GENERIC_TEXT, CY_GENERIC_TEXT,
        0);

    POSITION_WINDOW(m_hReceiveText, 
        CTLPOS_X_RECV_TEXT, CTLPOS_Y_RECV_TEXT, 
        CX_SENDRECV_TEXT, CY_SENDRECV_TEXT,
        0);

    POSITION_WINDOW(m_hSendText, 
        CTLPOS_X_SEND_TEXT, CTLPOS_Y_SEND_TEXT, 
        CX_SENDRECV_TEXT, CY_SENDRECV_TEXT,
        0);

    // The volume knobs resize themselves
    //
    POSITION_WINDOW(m_hSpeakerKnob, 
        CTLPOS_X_SPKVOL, CTLPOS_Y_SPKVOL, 
        0, 0,
        SWP_NOSIZE);

    POSITION_WINDOW(m_hMicroKnob, 
        CTLPOS_X_MICVOL, CTLPOS_Y_MICVOL, 
        0, 0,
        SWP_NOSIZE);
    
    // Participant list
    POSITION_WINDOW(m_hParticipantList, 
        CTLPOS_X_PARTLIST, CTLPOS_Y_PARTLIST, 
        CX_PARTLIST, 
        m_nCtlMode == CTL_MODE_HOSTED ? CY_PARTLIST_WEBCRM : CY_PARTLIST_STANDALONE,
        0);
    
    // Add/remove participant buttons
    POSITION_WINDOW(m_hAddParticipant, 
        CTLPOS_X_ADDPART, CTLPOS_Y_ADDPART, 
        CX_PARTICIPANT_BUTTON, CY_PARTICIPANT_BUTTON,
        0);
    
    POSITION_WINDOW(m_hRemParticipant, 
        CTLPOS_X_REMPART, CTLPOS_Y_REMPART, 
        CX_PARTICIPANT_BUTTON, CY_PARTICIPANT_BUTTON,
        0);

    // status bar, no size/move
    POSITION_WINDOW(m_hStatusBar, 
        CTLPOS_X_MICVOL, CTLPOS_Y_MICVOL, 
        0, 0,
        SWP_NOSIZE | SWP_NOMOVE);

#undef POSITION_WINDOW

}


// MoveWindowVertically
//      moves one control
// 
void CRTCCtl::MoveWindowVertically(CWindow *pWindow, LONG Offset)
{
    RECT     Rect;

    pWindow->GetWindowRect(&Rect);

    ::MapWindowPoints( NULL, m_hWnd, (LPPOINT)&Rect, 2 );

    pWindow->MoveWindow(Rect.left, Rect.top + Offset, Rect.right - Rect.left, Rect.bottom - Rect.top,  TRUE);
}

// PlaceAndEnableDisableZone
//      moves and enables/disables a zone according to the layout
//  specified in *pNewState 
//
void CRTCCtl::PlaceAndEnableDisableZone(int iZone, CZoneState *pNewState)
{
    LONG    lOffset;
    BOOL    bVisibilityChanged;
    BOOL    bShown;
    
    CWindow *pDtmfCrt;
    CWindow *pDtmfEnd;
    int     id;
    
    // try to minimize the flickering by
    // updating only the controls that change state

    bShown = pNewState->bShown;



    lOffset = (LONG)(pNewState->iBase - m_ZoneStateArray[iZone].iBase);

    bVisibilityChanged = (m_ZoneStateArray[iZone].bShown && !bShown) ||
                         (!m_ZoneStateArray[iZone].bShown && bShown);

    if(lOffset!=0)
    {
        switch(iZone)
        {
        case AXCTL_ZONE_TOOLBAR:
            MoveWindowVertically(&m_hCtlToolbar, lOffset);
            break; 

        case AXCTL_ZONE_LOGOVIDEO:
            MoveWindowVertically(&m_hReceiveWindow, lOffset);
            MoveWindowVertically(&m_hPreviewWindow, lOffset);
            MoveWindowVertically(&m_hReceivePreferredButton, lOffset);
            MoveWindowVertically(&m_hSendPreferredButton, lOffset);
            //MoveWindowVertically(&m_hPreviewPreferredButton, lOffset);
            MoveWindowVertically(&m_hReceivePreferredText, lOffset);
            MoveWindowVertically(&m_hSendPreferredText, lOffset);
            //MoveWindowVertically(&m_hPreviewPreferredText, lOffset);        
            break;

        case AXCTL_ZONE_DIALPAD:
            pDtmfCrt = m_hDtmfButtons;
            pDtmfEnd = m_hDtmfButtons + NR_DTMF_BUTTONS;

            for (id = IDC_DIAL_0; pDtmfCrt<pDtmfEnd; pDtmfCrt++, id++)
                MoveWindowVertically(pDtmfCrt, lOffset);

            break;

        case AXCTL_ZONE_AUDIO:
            MoveWindowVertically(&m_hSpeakerKnob, lOffset);
            MoveWindowVertically(&m_hSpeakerMuteButton, lOffset);
            MoveWindowVertically(&m_hSpeakerMuteText, lOffset);
    
            MoveWindowVertically(&m_hMicroKnob, lOffset);
            MoveWindowVertically(&m_hMicroMuteButton, lOffset);
            MoveWindowVertically(&m_hMicroMuteText, lOffset);

            MoveWindowVertically(&m_hReceiveText, lOffset);
            MoveWindowVertically(&m_hSendText, lOffset);
            break;

        case AXCTL_ZONE_PARTICIPANTS:
            MoveWindowVertically(&m_hParticipantList, lOffset);
            MoveWindowVertically(&m_hAddParticipant, lOffset);
            MoveWindowVertically(&m_hRemParticipant, lOffset);
            break;

        case AXCTL_ZONE_STATUS:
            // The status bar moves automatically
            break;
        }
    }
    if(bVisibilityChanged)
    {
        int iShow = bShown ? SW_SHOW : SW_HIDE;

        switch(iZone)
        {
        case AXCTL_ZONE_TOOLBAR:
            m_hCtlToolbar.ShowWindow(iShow);
            break; 

        case AXCTL_ZONE_LOGOVIDEO:
            m_hReceiveWindow.ShowWindow(iShow);
            
            // preview window is processed by ShowHidePreviewWindow
            
            // so the window is displayed when
            //      the logovideo zone is displayed
            //  and the video sending is active
            //  and the preview preference is set
 
            ShowHidePreviewWindow(
                bShown 
             && m_bPreviewWindowActive 
             && m_bPreviewWindowIsPreferred);

            m_hReceivePreferredButton.ShowWindow(iShow);
            m_hSendPreferredButton.ShowWindow(iShow);
            //m_hPreviewPreferredButton.ShowWindow(iShow);

            m_hReceivePreferredText.ShowWindow(iShow);
            m_hSendPreferredText.ShowWindow(iShow);
            //m_hPreviewPreferredText.ShowWindow(iShow);

            break;

        case AXCTL_ZONE_DIALPAD:
            pDtmfCrt = m_hDtmfButtons;
            pDtmfEnd = m_hDtmfButtons + NR_DTMF_BUTTONS;

            for (id = IDC_DIAL_0; pDtmfCrt<pDtmfEnd; pDtmfCrt++, id++)
                pDtmfCrt->ShowWindow(iShow);

            break;

        case AXCTL_ZONE_AUDIO:
            m_hSpeakerKnob.ShowWindow(iShow);
            m_hSpeakerMuteButton.ShowWindow(iShow);
            m_hSpeakerMuteText.ShowWindow(iShow);

            m_hMicroKnob.ShowWindow(iShow);
            m_hMicroMuteButton.ShowWindow(iShow);
            m_hMicroMuteText.ShowWindow(iShow);

            m_hReceiveText.ShowWindow(iShow);
            m_hSendText.ShowWindow(iShow);

            break;

        case AXCTL_ZONE_PARTICIPANTS:
            m_hParticipantList.ShowWindow(iShow);
            m_hParticipantList.EnableWindow(bShown);

            // don't enable/disable these here
            m_hAddParticipant.ShowWindow(iShow);
            m_hRemParticipant.ShowWindow(iShow);

            break;

        case AXCTL_ZONE_STATUS:
            m_hStatusBar.ShowWindow(iShow);
            break;
        }
    }
    
    // Save the new state
    m_ZoneStateArray[iZone] = *pNewState;
}

// AdjustVideoFrames
//  For the receive window, keep the top left position fixed, adjust the size
//  of the client area to match a QCIF video size
//  Similar for the preview window, with the difference that the size is
//  QQCIF and the window is aligned with the receive window
//

void  CRTCCtl::AdjustVideoFrames()
{
    // adjust the client rect size of the receive window
    AdjustVideoFrame(&m_hReceiveWindow, QCIF_CX_SIZE, QCIF_CY_SIZE);

    // adjust the client rect size of the preview window
    AdjustVideoFrame(&m_hPreviewWindow, QQCIF_CX_SIZE, QQCIF_CY_SIZE);

    // Align the preview window
    // The entire preview window (client and non client) must be in the client 
    // area of the receive window
    //
    RECT    rectRecvClnt;
    RECT    rectPrev;
    
    // Client area of the receive window
    m_hReceiveWindow.GetClientRect(&rectRecvClnt);

    // get the current position of the preview window
    m_hPreviewWindow.GetWindowRect(&rectPrev);
    ::MapWindowPoints( NULL, m_hWnd, (LPPOINT)&rectPrev, 2 );
    
    // Map the window in the client area of the receive window
    // XXX Mirroring ?
    POINT   pt;

    pt.x = rectRecvClnt.right - (rectPrev.right - rectPrev.left);
    pt.y = rectRecvClnt.bottom - (rectPrev.bottom - rectPrev.top);

    // convert to dlg client the top left corner
    m_hReceiveWindow.MapWindowPoints(m_hWnd, &pt, 1);
    
    // size is unchanged
    rectPrev.right = rectPrev.right - rectPrev.left;
    rectPrev.bottom = rectPrev.bottom - rectPrev.top;

    // top left corner is moved
    rectPrev.left = pt.x;
    rectPrev.top = pt.y;


    // move the window
    m_hPreviewWindow.MoveWindow(
        rectPrev.left,
        rectPrev.top,
        rectPrev.right,
        rectPrev.bottom,
        TRUE);
}

// AdjustVideoFrame
//
void  CRTCCtl::AdjustVideoFrame(CWindow *pWindow, int iCx, int iCy)
{
    WINDOWINFO  wi;
    
    // 
    wi.cbSize = sizeof(WINDOWINFO);

    // get window info
    GetWindowInfo(*pWindow, &wi);

    // don't use the cxyborders members
    // use diff between client area and window area

    int iDiffX;
    int iDiffY;
    
    iDiffX = iCx - (wi.rcClient.right - wi.rcClient.left);
    iDiffY = iCy - (wi.rcClient.bottom - wi.rcClient.top);

    // the window rect is in screen coords, convert in client
    ::MapWindowPoints( NULL, m_hWnd, (LPPOINT)&wi.rcWindow, 2 );

    // compute the bottom/right
    wi.rcWindow.bottom += iDiffY;
    wi.rcWindow.right += iDiffX;

    // adjust the size
    pWindow->MoveWindow(&wi.rcWindow, TRUE);
}


     
// SetControlState
//  Sets a new UI state
//  
//      NewState    -   control UI state
//      Status code -   SIP status code, may be taken into account 
//      Result      -   API error code, may be taken into account
//      nID         -   Resource ID for a string, overrides the previous params
//


void CRTCCtl::SetControlState(
    RTCAX_STATE NewState, 
    HRESULT StatusCode,
    UINT nID)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::SetControlState <%d> - enter", this, NewState));
    
    /////////////////////
    //
    //  Processing redirects
    //  If m_bRedirecting is TRUE, set the state recursively to DIALING and places the next call
    //
    ///////////////////
    
    if(m_bRedirecting)
    {
        HRESULT hr, hrCall;

        LOG((RTC_INFO, "[%p] CRTCCtl::SetControlState: redirecting...", this));

        switch(NewState)
        {
        case RTCAX_STATE_IDLE:
            // set recursively the state to Dialing
            SetControlState(RTCAX_STATE_DIALING);

            // try to place a new call
            hrCall = S_OK;

            hr = RedirectedCall(&hrCall);

            if (hr == S_OK)
            {
                // call placed successfully, return
                LOG((RTC_TRACE, "[%p] CRTCCtl::SetControlState <%d> - shortcut exit", this, NewState));

                return;
            }
            else if (hr == S_FALSE)
            {
                // this is end of the list
                // if hrCall != success, use it for the error message box 
                // that will be displayed
                // else, use the params
                if ( FAILED(hrCall) )
                {
                    StatusCode = hrCall;
                }
            }
            else if (hr == E_ABORT)
            {
                // clear any params, the user aborted the call
                hr = S_OK;
                StatusCode = 0;
            }
            else
            {
                // other unrecoverable error
                StatusCode = hr;
            }

            m_bRedirecting = FALSE;
            
            break;
        
        case RTCAX_STATE_DIALING:   // do nothing, it's our recursive call
        case RTCAX_STATE_CONNECTING:    // do nothing, these are provisional responses

            break;

        case RTCAX_STATE_DISCONNECTING:  // the user hung up , so we have to stop..
        case RTCAX_STATE_CONNECTED:     // or the call succeeded

            m_bRedirecting = FALSE;

            break;
        
        default:        // errors
            
            LOG((RTC_ERROR, "[%p] CRTCCtl::SetControlState - "
                "invalid state (%d) during redirection", this, NewState));

            m_bRedirecting = FALSE;

            break;
        }

    }

    
    //////////////////////
    //  
    //  Adjust the state to UI_BUSY if a dialog box must be displayed
    //  Calls itself recursively 
    //
    //////////////////////

    if(NewState == RTCAX_STATE_IDLE
        && FAILED(StatusCode) )
    {

        // prepare the error strings
        HRESULT     hr;
        RTCAX_ERROR_INFO    ErrorInfo;

        ZeroMemory(&ErrorInfo, sizeof(ErrorInfo));

        hr = PrepareErrorStrings(
            m_bOutgoingCall,
            StatusCode,
            (LPWSTR)m_bstrOutAddress,
            &ErrorInfo);
       
        if(SUCCEEDED(hr))
        {

            //
            // Create the dialog box
            //
            CErrorMessageLiteDlg *pErrorDlgLite =
                new CErrorMessageLiteDlg;

            if(pErrorDlgLite)
            {

                // Set the state to UI_BUSY using a recursive call
                //

                SetControlState(
                    RTCAX_STATE_UI_BUSY,
                    StatusCode,
                    nID);

                //
                //  Call the modal dialog box
                //
                
                pErrorDlgLite->DoModal(m_hWnd, (LPARAM)&ErrorInfo);

                delete pErrorDlgLite;
            }
            else
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::SetControlState; OOM", this));
            }
        }
        
        FreeErrorStrings(&ErrorInfo);

        // Continue 
    }

    /////
    // We cannot set the state to idle when AddParticipant dialog box is active
    //
    if(NewState == RTCAX_STATE_IDLE && m_bAddPartDlgIsActive)
    {
        // set to busy. The state will be set back to idle when
        // the AddPart dialog box is dismissed
        NewState = RTCAX_STATE_UI_BUSY;
    }

    //////////////////////
    //  
    //  Set the new state
    //
    //////////////////////
    
    BOOL    bStateChanged = (m_nControlState != NewState);

    // This is the new current state
    m_nControlState = NewState;

    // This is needed when displaying error messages
    if(m_nControlState == RTCAX_STATE_DIALING)
    {
        m_bOutgoingCall = TRUE;
    }
    else if (m_nControlState == RTCAX_STATE_IDLE)
    {
        m_bOutgoingCall = FALSE;
    }

    //////////////////////
    //  
    //  Change layout
    //
    //
    //////////////////////

    if(bStateChanged)
    {
        // Change the visuals (in standalone mode)
        if(m_nCtlMode == CTL_MODE_STANDALONE)
        {
            if(m_nControlState == RTCAX_STATE_CONNECTING)
            {
                // display the right layout
                switch(m_nCachedCallScenario)
                {
                case RTC_CALL_SCENARIO_PCTOPC:
                    SetZoneLayout(&s_DefaultZoneLayout, FALSE);
                    break;

                case RTC_CALL_SCENARIO_PCTOPHONE:
                    SetZoneLayout(&s_PCToPhoneZoneLayout, FALSE);
                    break;

                case RTC_CALL_SCENARIO_PHONETOPHONE:
                    SetZoneLayout(&s_PhoneToPhoneZoneLayout, FALSE);
                    break;
                }
            }
            else if(m_nControlState == RTCAX_STATE_IDLE)
            {
                SetZoneLayout(&s_DefaultZoneLayout, FALSE);
            }
        }
    }

    //////////////////////
    //  
    //  Determine the text in the status bar
    //
    //
    //////////////////////
    
    //  nID overrides everything
    //
    if(nID == 0)
    {
        // for IDLE or UI_BUSY state, any Result != S_OK
        // or StatusCode != 0 must set the status bar to error
        // 
        // 

        if(m_nControlState == RTCAX_STATE_IDLE ||
           m_nControlState == RTCAX_STATE_UI_BUSY )
        {
            if( FAILED(StatusCode) )
            {
                nID = IDS_SB_STATUS_IDLE_FAILED;
            }
        }
        
        // for CONNECTING process some of the provisional responses
        //

        else if ( (m_nControlState == RTCAX_STATE_CONNECTING) &&
                  (HRESULT_FACILITY(StatusCode) == FACILITY_SIP_STATUS_CODE) )
        {
            switch( HRESULT_CODE(StatusCode) )
            {
            case 180:
                nID = IDS_SB_STATUS_CONNECTING_RINGING;
                break;

            case 182:
                nID = IDS_SB_STATUS_CONNECTING_QUEUED;
                break;
            }
        }

        // if the status is CONNECTING or DIALING, we are in
        //  redirecting mode and no ID has been assigned, use a special text
        if(nID==0 &&
           m_bRedirecting && 
           (m_nControlState == RTCAX_STATE_CONNECTING 
           || m_nControlState == RTCAX_STATE_DIALING))
        {
            nID = IDS_SB_STATUS_REDIRECTING;
        }

        // nothing special, so use the defaults
        //

        if(nID == 0)
        {
            ATLASSERT(m_nControlState <= RTCAX_STATE_CONNECTING);
    
            nID = m_nControlState + IDS_SB_STATUS_NONE;
        }
    }

    // 
    // Set the status bar text (if active)
    
    if(m_ZoneStateArray[AXCTL_ZONE_STATUS].bShown)
    {
        TCHAR   szText[0x80];

        szText[0] = _T('\0');
        LoadString(
            _Module.GetResourceInstance(), 
            nID, 
            szText, 
            sizeof(szText)/sizeof(TCHAR));

        m_hStatusBar.SendMessage(SB_SETTEXT, SBP_STATUS, (LPARAM)szText);
    }

    //////////////////////
    //  
    //  Enable/disable the controls
    //
    //
    //////////////////////

    BOOL    bToolbarActive = m_ZoneStateArray[AXCTL_ZONE_TOOLBAR].bShown;

    if (m_nControlState == RTCAX_STATE_IDLE)
    {
        CWindow *pDtmfCrt = m_hDtmfButtons;
        CWindow *pDtmfEnd = m_hDtmfButtons + NR_DTMF_BUTTONS;

        for (int id = IDC_DIAL_0; pDtmfCrt<pDtmfEnd; pDtmfCrt++, id++)
             pDtmfCrt->EnableWindow(FALSE);
    }

    // enable/disable the toolbar buttons
    //
    BOOL bCallEnabled = bToolbarActive && m_nControlState == RTCAX_STATE_IDLE;
    BOOL bHupEnabled = bToolbarActive && 
                             (m_nControlState == RTCAX_STATE_CONNECTED ||
                              m_nControlState == RTCAX_STATE_CONNECTING ||
                              m_nControlState == RTCAX_STATE_ANSWERING);
    
    m_hCtlToolbar.SendMessage(TB_SETSTATE, IDC_BUTTON_CALL, 
            MAKELONG(bCallEnabled ? TBSTATE_ENABLED : TBSTATE_INDETERMINATE, 0L));
    m_hCtlToolbar.SendMessage(TB_SETSTATE, IDC_BUTTON_HUP, 
            MAKELONG(bHupEnabled ? TBSTATE_ENABLED : TBSTATE_INDETERMINATE, 0L));

    // Participant list buttons
    //
    // Add/Rem Participant are active in CONNECTED mode, standalone 
    // model, when PL is visible

    m_hAddParticipant.EnableWindow(ConfButtonsActive());
    UpdateRemovePartButton();
    
    // Disable everything if error
    if(m_nControlState == RTCAX_STATE_ERROR)
    {
        EnableWindow(FALSE);
    }

    //////////////////////
    //  
    //  Advertise to the frame 
    //
    //
    //////////////////////

    Fire_OnControlStateChange(m_nControlState, nID);

    LOG((RTC_TRACE, "[%p] CRTCCtl::SetControlState <%d> - exit", this, NewState));
}

// ConfButtonsActive
//  

BOOL CRTCCtl::ConfButtonsActive(void)
{
    return
        m_nControlState == RTCAX_STATE_CONNECTED &&
        m_nCtlMode == CTL_MODE_STANDALONE &&
        m_ZoneStateArray[AXCTL_ZONE_PARTICIPANTS].bShown;
}

// UpdateRemovePartButton
//  

void CRTCCtl::UpdateRemovePartButton(void)
{
    // refresh the Delete button state
    m_hRemParticipant.EnableWindow(ConfButtonsActive() && m_hParticipantList.CanDeleteSelected());
}

// RefreshAudioControls
//  Read current volume/mute settings and sets the window controls
//
HRESULT CRTCCtl::RefreshAudioControls(void)
{
    HRESULT         hr;
    VARIANT_BOOL    bMuted;
    long            lVolume;

    if(m_pRTCClient!=NULL)
    {
    
        // Speaker mute
        hr = m_pRTCClient -> get_AudioMuted(RTCAD_SPEAKER, &bMuted);

        if(SUCCEEDED(hr))
        {
            // the button is actually the opposite of "mute"
            m_hSpeakerMuteButton.SendMessage(BM_SETCHECK, bMuted ? BST_UNCHECKED : BST_CHECKED, 0);
        
            m_hSpeakerMuteButton.EnableWindow( TRUE );
        }
        else
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::RefreshAudioControls - error <%x> when calling get_AudioMuted", this, hr));

            m_hSpeakerMuteButton.EnableWindow( FALSE );
        }

        // Speaker volume
        hr = m_pRTCClient -> get_Volume(RTCAD_SPEAKER, &lVolume);
        if(SUCCEEDED(hr))
        {
            m_hSpeakerKnob.SendMessage(TBM_SETPOS, (WPARAM)TRUE, (LPARAM)lVolume);

            m_hSpeakerKnob.EnableWindow( TRUE );
        }
        else
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::RefreshAudioControls - error <%x> when calling get_Volume", this, hr));

            m_hSpeakerKnob.EnableWindow( FALSE );
        }


        // Microphone mute
        hr = m_pRTCClient -> get_AudioMuted(RTCAD_MICROPHONE, &bMuted);
        if(SUCCEEDED(hr))
        {
            // the button is actually the opposite of "mute"
            m_hMicroMuteButton.SendMessage(BM_SETCHECK, bMuted ? BST_UNCHECKED : BST_CHECKED, 0);
        
            m_hMicroMuteButton.EnableWindow( TRUE );
        }
        else
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::RefreshAudioControls - error <%x> when calling get_AudioMuted", this, hr));

            m_hMicroMuteButton.EnableWindow( FALSE );
        }

        // Microphone volume
        hr = m_pRTCClient -> get_Volume(RTCAD_MICROPHONE, &lVolume);
        if(SUCCEEDED(hr))
        {
            m_hMicroKnob.SendMessage(TBM_SETPOS, (WPARAM)TRUE, (LPARAM)lVolume);

            m_hMicroKnob.EnableWindow( TRUE );
        }
        else
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::RefreshAudioControls - error <%x> when calling get_Volume", this, hr));

            m_hMicroKnob.EnableWindow( FALSE );
        }
    }
    else
    {
        // disable everything
        m_hSpeakerKnob.EnableWindow( FALSE );
        m_hSpeakerMuteButton.EnableWindow( FALSE );

        m_hMicroKnob.EnableWindow( FALSE );
        m_hMicroMuteButton.EnableWindow( FALSE );
    }

    return S_OK;
}

// RefreshVideoControls
//  Read current video enable/disable controls
//
HRESULT CRTCCtl::RefreshVideoControls(void)
{
    HRESULT         hr;
    long            lVolume;

    if(m_pRTCClient!=NULL)
    {
    
        // read capabilities from core
        //
        hr = m_pRTCClient -> get_MediaCapabilities(&m_lMediaCapabilities);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::RefreshVideoControls - "
                "error (%x) returned by get_MediaCapabilities, exit",this,  hr));
        
            m_hReceivePreferredButton.EnableWindow(FALSE);
            m_hSendPreferredButton.EnableWindow(FALSE);
        
            return 0;
        }
        
        // Get media preferences
        hr = m_pRTCClient->get_PreferredMediaTypes( &m_lMediaPreferences);
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::RefreshVideoControls - "
                "error (%x) returned by get_PreferredMediaTypes, exit",this,  hr));

            m_hReceivePreferredButton.EnableWindow(FALSE);
            m_hSendPreferredButton.EnableWindow(FALSE);
            return 0;
        }

        m_hReceivePreferredButton.EnableWindow(
            m_lMediaCapabilities & RTCMT_VIDEO_RECEIVE);
        m_hSendPreferredButton.EnableWindow(
            m_lMediaCapabilities & RTCMT_VIDEO_SEND);

        m_hReceivePreferredButton.SendMessage(
            BM_SETCHECK, 
            (m_lMediaPreferences & RTCMT_VIDEO_RECEIVE) ? BST_CHECKED : BST_UNCHECKED,
            0);
        
        m_hSendPreferredButton.SendMessage(
            BM_SETCHECK, 
            (m_lMediaPreferences & RTCMT_VIDEO_SEND) ? BST_CHECKED : BST_UNCHECKED,
            0);

        // Get the video preview preference
        DWORD   dwValue = (DWORD)TRUE;

        hr = get_SettingsDword(SD_VIDEO_PREVIEW, &dwValue);
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::RefreshVideoControls - "
                "error (%x) returned by get_SettingsDword(SD_VIDEO_PREVIEW)",this,  hr));
        }

        m_bPreviewWindowIsPreferred = !!dwValue;

        // XXX add here the initialization of m_hPreviewPreferredButton
    }

    return S_OK;
}




// CalcSizeAndNotifyContainer
//      Calculates the vertical size based on properties
//    and notifies the container.  
//
//  WARNING !!!! Must be called prior to creating
//  the window for the control 
// 
//

void CRTCCtl::CalcSizeAndNotifyContainer(void)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::CalcSizeAndNotifyContainer - enter", this));

    // find the appropriate layout
    // also keep it for later (OnInitDialog)

    switch(m_nPropCallScenario)
    {
    case RTC_CALL_SCENARIO_PCTOPC:
        // logo/video
        m_pWebCrmLayout = m_bPropShowDialpad ? 
            NULL : &s_WebCrmPCToPCZoneLayout;
        break;

    case RTC_CALL_SCENARIO_PCTOPHONE:
       // dialpad or nothing
        m_pWebCrmLayout = m_bPropShowDialpad ? 
            &s_WebCrmPCToPhoneWithDialpadZoneLayout : &s_WebCrmPCToPhoneZoneLayout;
        break;
    
    case RTC_CALL_SCENARIO_PHONETOPHONE:
        // the caller may want a dialpad. So what ? We are not a computer game.
        m_pWebCrmLayout =  m_bPropShowDialpad ? 
            NULL : &s_WebCrmPhoneToPhoneZoneLayout;
        break;

    default:
        // uhh, this is not a correct parameter.
        LOG((RTC_WARN, "[%p] CRTCCtl::CalcSizeAndNotifyContainer - incorrect CallScenario property (%d)", this, m_nPropCallScenario));
        break;
    }

    if(m_pWebCrmLayout)
    {
        LONG    lSize = 0;
        
        //
        // Computes the size in pixels
        //
        //  !!! Hardcoded, it's based on knowledge regarding 
        //  group placements
        //
        if((*m_pWebCrmLayout)[AXCTL_ZONE_TOOLBAR].bShown)
        {
            lSize += ZONE_GROUP_TOOLBAR_HEIGHT;
        }
        
        if((*m_pWebCrmLayout)[AXCTL_ZONE_LOGOVIDEO].bShown
         ||(*m_pWebCrmLayout)[AXCTL_ZONE_DIALPAD].bShown)
        {
            lSize += ZONE_GROUP_MAIN_HEIGHT;
        }

        if((*m_pWebCrmLayout)[AXCTL_ZONE_AUDIO].bShown)
        {
            lSize += ZONE_GROUP_SECONDARY_HEIGHT;
        }

        if((*m_pWebCrmLayout)[AXCTL_ZONE_PARTICIPANTS].bShown)
        {
            lSize += ZONE_GROUP_PARTLIST_HEIGHT;
        }
        
        if((*m_pWebCrmLayout)[AXCTL_ZONE_STATUS].bShown)
        {
            lSize += ZONE_GROUP_STATUS_HEIGHT;
        }

        //
        // Convert to HiMetric
        //

        SIZE size;
        size.cx = CTLSIZE_Y; // fixed size !! (whatever the aspect ratio is)
        size.cy = lSize;

        AtlPixelToHiMetric(&size, &size);

        //
        // Set the new size
        //
        m_sizeExtent.cy = size.cy;
        m_sizeExtent.cx = size.cx;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::CalcSizeAndNotifyContainer - exit", this));
}


// OnVideoMediaEvent
//      Processes the events related to video streaming

/*
    There are four parameters that drive the aspect of the video zone

    - AXCTL Layout - logovideo zone     (VZONE)
    - Send video streaming status       (SVID) 
    - Receive video streaming status    (RVID)
    - Preview window preference         (PREV)

    The receive window can display a black brush or a DX video window. It also
    can be clipped in order to accommodate a preview window

    VZONE   RVID   SVID    PREV         Big Window                      Small Window
    
    Hidden   X      X       X           Black brush, not clipped       hidden
    Active   No     No      No          Black brush, not clipped       hidden 
    Active   No     No      Yes         Black brush, not clipped       hidden 
    Active   No     Yes     No          Black brush, not clipped       hidden
    Active   No     Yes     Yes         Black brush, clipped           preview video
    Active   Yes    No      No          Rec Video, not clipped         hidden 
    Active   Yes    No      Yes         Rec Video, not clipped         hidden 
    Active   Yes    Yes     No          Rec Video, not clipped         hidden
    Active   Yes    Yes     Yes         Rec Video, clipped             preview video
   
*/


HRESULT CRTCCtl::OnVideoMediaEvent(
        BOOL    bReceiveWindow,
        BOOL    bActivated)
{
    BOOL        *pWindowActive;
    HRESULT     hr = S_OK;

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnVideoMediaEvent - enter", this));

    pWindowActive = bReceiveWindow ? &m_bReceiveWindowActive : &m_bPreviewWindowActive;

    //
    // Is the event redundant ?
    //

    if((bActivated && *pWindowActive) ||
       (!bActivated && !*pWindowActive))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnVideoMediaEvent - redundant event, exit", this));

        return E_UNEXPECTED;
    }
    
    //
    // Get the IVideoWindow interface
    //
    IVideoWindow    *pVideoWindow = NULL;

    ATLASSERT(m_pRTCClient.p);

    hr = m_pRTCClient -> get_IVideoWindow(
        bReceiveWindow ? RTCVD_RECEIVE : RTCVD_PREVIEW,
        &pVideoWindow);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnVideoMediaEvent - cannot get the IVideoWindow interface, exit", this));

        return hr;
    }

    //
    // Do the work
    //
    RTC_VIDEO_DEVICE nVideoDevice;
    CWindow         *pFrameWindow;

    nVideoDevice = bReceiveWindow ? RTCVD_RECEIVE : RTCVD_PREVIEW;
    pFrameWindow = bReceiveWindow ? &m_hReceiveWindow : &m_hPreviewWindow;

    ATLASSERT(pVideoWindow);

    if(bActivated)
    {
        // set the window style
        //

        hr = pVideoWindow -> put_WindowStyle(WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS);
        
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::OnVideoMediaEvent - "
                        "error (%x) returned by put_WindowStyle, exit", this, hr));

            return hr;
        }
        
        // set the window owner
        //
        hr = pVideoWindow -> put_Owner((OAHWND)HWND(*pFrameWindow));
        
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::OnVideoMediaEvent - "
                        "error (%x) returned by put_Owner, exit", this, hr));

            return hr;
        }

        // The geometry.. The entire client area of the bitmap control is used by the
        //  video window
        //
        RECT    rectPos;

        pFrameWindow ->GetClientRect(&rectPos);

        hr = pVideoWindow -> SetWindowPosition(
            rectPos.left,
            rectPos.top,
            rectPos.right,
            rectPos.bottom
            );
        
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::OnVideoMediaEvent - "
                        "error (%x) returned by SetWindowPosition, exit", this, hr));

            return hr;
        }
        
        // Show the window
        //
         
        hr = pVideoWindow -> put_Visible(OATRUE);
        
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::OnVideoMediaEvent - "
                        "error (%x) returned by put_Visible(OATRUE), exit", this, hr));
        
            return hr;
        }

        // 
        // Mark the window as shown
        //

        *pWindowActive = TRUE;

        //
        // Adjust some clipping regions, if necessary
        //

        if(!bReceiveWindow)
        {
            ShowHidePreviewWindow(
                m_ZoneStateArray[AXCTL_ZONE_LOGOVIDEO].bShown &&
                *pWindowActive &&
                m_bPreviewWindowIsPreferred);
        }
    }
    else
    {
        // 
        // Mark the window as hidden, whatever the result of the method will be
        //

        *pWindowActive = FALSE;
        
        
        //
        // Adjust some clipping regions, if necessary
        //

        if(!bReceiveWindow)
        {
            ShowHidePreviewWindow(
                m_ZoneStateArray[AXCTL_ZONE_LOGOVIDEO].bShown &&
                *pWindowActive &&
                m_bPreviewWindowIsPreferred);
        }
        
        // hide the window
        
        hr = pVideoWindow -> put_Visible(OAFALSE);
        
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::OnVideoMediaEvent - "
                        "error (%x) returned by put_Visible(OAFALSE), exit", this, hr));
            
            return hr;
        }

        // set the window owner to NULL
        //
        hr = pVideoWindow -> put_Owner(NULL);
        
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::OnVideoMediaEvent - "
                        "error (%x) returned by put_Owner, exit", this, hr));

            return hr;
        }

    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnVideoMediaEvent - exit", this));

    return hr;
}


// ShowHidePreviewWindow
//      Hides or displays the preview window.
//      It also adjust the receive window region

void CRTCCtl::ShowHidePreviewWindow(BOOL bShow)
{
    RECT rectRecv;
    long lEdgeX, lEdgeY;

    // Get the window region for the receive window
    m_hReceiveWindow.GetWindowRect(&rectRecv);   
    
    // map to the window coordinates of the receive window
    //  this is ugly, we don't have a way to directly do this..
    //
    ::MapWindowPoints(NULL, m_hReceiveWindow, (LPPOINT)&rectRecv, 2);

    // adjust for the window edge
    lEdgeX = rectRecv.left;
    lEdgeY = rectRecv.top;
  
    rectRecv.right -= lEdgeX;
    rectRecv.bottom -= lEdgeY; 
    rectRecv.left = 0;
    rectRecv.top = 0;
    
    // create a region
    HRGN    hRegion1 = CreateRectRgn(
        rectRecv.left,
        rectRecv.top,
        rectRecv.right,
        rectRecv.bottom
        );
 
    if(bShow)
    {
        RECT    rectPrev;

        m_hPreviewWindow.GetWindowRect(&rectPrev);      

        ::MapWindowPoints(NULL, m_hReceiveWindow, (LPPOINT)&rectPrev, 2);
 
        // adjust for the window edge
        rectPrev.right -= lEdgeX;
        rectPrev.bottom -= lEdgeY; 
        rectPrev.left -= lEdgeX;
        rectPrev.top -= lEdgeY;  

        HRGN    hRegion2 = CreateRectRgn(
            rectPrev.left,  
            rectPrev.top,  
            rectPrev.right,
            rectPrev.bottom
            );

        CombineRgn(hRegion1, hRegion1, hRegion2, RGN_DIFF);

        DeleteObject(hRegion2);
    }
    
    // show/hide the preview window
    m_hPreviewWindow.ShowWindow(bShow ? SW_SHOW : SW_HIDE);
    
    // set the new region
    m_hReceiveWindow.SetWindowRgn(hRegion1, TRUE);
}


// PrepareErrorStrings
//      Prepare error strings for an error message box

HRESULT CRTCCtl::PrepareErrorStrings(
        BOOL    bOutgoingCall,
        HRESULT StatusCode,
        LPWSTR  pAddress,
        RTCAX_ERROR_INFO
               *pErrorInfo)
{

    UINT    nID1 = 0;
    UINT    nID2 = 0;
    BOOL    bInsertAddress = FALSE;
    WORD    wIcon;
    PWSTR   pString = NULL;
    PWSTR   pFormat = NULL;
    DWORD   dwLength;


    LOG((RTC_TRACE, "[%p] CRTCCtl::PrepareErrorStrings; "
        "outgoing: %s, StatusCode=%x, Address %S - enter", 
        this,
        bOutgoingCall ? "true" : "false",
        StatusCode,
        pAddress ? pAddress : L"(null)"));

    // Error by default
    //
    wIcon = OIC_HAND;

    if ( FAILED(StatusCode) )
    {
        if ( (HRESULT_FACILITY(StatusCode) == FACILITY_SIP_STATUS_CODE) ||
             (HRESULT_FACILITY(StatusCode) == FACILITY_PINT_STATUS_CODE) )
        {
            // by default we use a generic message
            // we blame the network
            //
            nID1 = IDS_MB_SIPERROR_GENERIC_1;
            nID2 = IDS_MB_SIPERROR_GENERIC_2;

            // the default is a warning for this class
            wIcon = OIC_WARNING;

            switch( HRESULT_CODE(StatusCode) )
            {
            case 405:   // method not allowed
            case 406:   // not acceptable
            case 488:   // not acceptable here
            case 606:   // not acceptable

                // reusing the "apps don't match" error
                // 
			    nID1 = IDS_MB_HRERROR_APPS_DONT_MATCH_1;
			    nID2 = IDS_MB_HRERROR_APPS_DONT_MATCH_OUT_2;
            
                break;

            case 404:   // not found
            case 410:   // gone
            case 604:   // does not exist anywhere
            case 700:   // ours, no client is running on the callee
            
                // not found
                // 
                nID1 = IDS_MB_SIPERROR_NOTFOUND_1;
                nID2 = IDS_MB_SIPERROR_NOTFOUND_2;
                // bInsertAddress = TRUE;
            
                // information
                wIcon = OIC_INFORMATION;

                break;

            case 401:
            case 407:

                // auth failed
                // 
                nID1 = IDS_MB_SIPERROR_AUTH_FAILED_1;
                nID2 = IDS_MB_SIPERROR_AUTH_FAILED_2;
            
                break;

            case 408:   // timeout
            
                // timeout. this also cover the case when
                //  the callee is lazy and doesn't answer the call
                //
                // if we are in the connecting state, we may assume
                // that the other end is not answering the phone.
                // It's not perfect, but I don't have any choice

                if (m_nControlState == RTCAX_STATE_CONNECTING)
                {
                    nID1 = IDS_MB_SIPERROR_NOTANSWERING_1;
                    nID2 = IDS_MB_SIPERROR_NOTANSWERING_2;

                    // information
                    wIcon = OIC_INFORMATION;
                }

                break;            

            case 480:   // not available
            
                // callee has not made him/herself available..
                // 
                nID1 = IDS_MB_SIPERROR_NOTAVAIL_1;
                nID2 = IDS_MB_SIPERROR_NOTAVAIL_2;
            
                // information
                wIcon = OIC_INFORMATION;
            
                break;
        
            case 486:   // busy here
            case 600:   // busy everywhere
            
                // callee has not made him/herself available..
                // 
                nID1 = IDS_MB_SIPERROR_BUSY_1;
                nID2 = IDS_MB_SIPERROR_BUSY_2;
            
                // information
                wIcon = OIC_INFORMATION;
            
                break;

            case 500:   // server internal error
            case 503:   // service unavailable
            case 504:   // server timeout
            
                //  blame the server
                //
                nID1 = IDS_MB_SIPERROR_SERVER_PROBLEM_1;
                nID2 = IDS_MB_SIPERROR_SERVER_PROBLEM_2;
            
                break;

            case 603:   // decline

                nID1 = IDS_MB_SIPERROR_DECLINE_1;
                nID2 = IDS_MB_SIPERROR_DECLINE_2;
            
                // information
                wIcon = OIC_INFORMATION;

                break;
            }
        
            //
            // some Pint errors, they are actually for the primary leg
            //

            if(m_nCachedCallScenario == RTC_CALL_SCENARIO_PHONETOPHONE)
            {
                // keep the "warning" icon, because there's a problem with the primary leg

                switch( HRESULT_CODE(StatusCode) )
                {
                case 5:

                    nID1 = IDS_MB_SIPERROR_PINT_BUSY_1;
                    nID2 = IDS_MB_SIPERROR_PINT_BUSY_2;
                    break;

                case 6:

                    nID1 = IDS_MB_SIPERROR_PINT_NOANSWER_1;
                    nID2 = IDS_MB_SIPERROR_PINT_NOANSWER_2;
                    break;

                case 7:

                    nID1 = IDS_MB_SIPERROR_PINT_ALLBUSY_1;
                    nID2 = IDS_MB_SIPERROR_PINT_ALLBUSY_2;
                    break;
              
                }
            }


            //
            //  The third string displays the SIP code
            //

            PWSTR pFormat = RtcAllocString(
                _Module.GetResourceInstance(),
                IDS_MB_DETAIL_SIP);

            if(pFormat)
            {
                // find the length
                dwLength = 
                    ocslen(pFormat) // format length
                 -  2               // length of %d
                 +  0x10;           // enough for a number...

                pString = (PWSTR)RtcAlloc((dwLength + 1)*sizeof(WCHAR));
            
                if(pString)
                {
                    _snwprintf(pString, dwLength + 1, pFormat, HRESULT_CODE(StatusCode) );
                }

                RtcFree(pFormat);
                pFormat = NULL;
            
                pErrorInfo->Message3 = pString;
                pString = NULL;
            }
        }
        else
        {
            // Two cases - incoming and outgoing calls
            if(bOutgoingCall)
            {
                if(StatusCode == HRESULT_FROM_WIN32(WSAHOST_NOT_FOUND) )
                {
                    // Use the generic message in this case
                    //
                    nID1 = IDS_MB_HRERROR_NOTFOUND_1;
                    nID2 = IDS_MB_HRERROR_NOTFOUND_2;
            
                    // it's not malfunction
                    wIcon = OIC_INFORMATION;

                }
                else if (StatusCode == HRESULT_FROM_WIN32(WSAECONNRESET))
                {
                    // Even thoough it can be caused by any hard reset of the 
                    // remote end, in most of the cases it is caused when the 
                    // other end doesn't have SIP client running.

                    // different messages based on whether it uses a profile or not.
                    // XXXX
                    // It assumes the profile is not changed by the core
                    // This is currently true, but if we move the redirection stuff into
                    // the core, it won't be true any more.
                
                    if (m_pCachedProfile)
                    {
                        nID1 = IDS_MB_HRERROR_SERVER_NOTRUNNING_1;
                        nID2 = IDS_MB_HRERROR_SERVER_NOTRUNNING_2;
                    }
                    else
                    {
                        nID1 = IDS_MB_HRERROR_CLIENT_NOTRUNNING_1;
                        nID2 = IDS_MB_HRERROR_CLIENT_NOTRUNNING_2;
                    }
    
                    wIcon = OIC_INFORMATION;
            
                }
			    else if (StatusCode == RTC_E_INVALID_SIP_URL ||
                         StatusCode == RTC_E_DESTINATION_ADDRESS_MULTICAST)
			    {
				    nID1 = IDS_MB_HRERROR_INVALIDADDRESS_1;
				    nID2 = IDS_MB_HRERROR_INVALIDADDRESS_2;
                
                    wIcon = OIC_HAND;
			    }
			    else if (StatusCode == RTC_E_DESTINATION_ADDRESS_LOCAL)
			    {
				    nID1 = IDS_MB_HRERROR_LOCAL_MACHINE_1;
				    nID2 = IDS_MB_HRERROR_LOCAL_MACHINE_2;
                
                    wIcon = OIC_HAND;
			    }
                else if (StatusCode == HRESULT_FROM_WIN32(ERROR_USER_EXISTS) &&
                    m_nCachedCallScenario == RTC_CALL_SCENARIO_PHONETOPHONE)
                {
                    nID1 = IDS_MB_HRERROR_CALLING_PRIMARY_LEG_1;
                    nID2 = IDS_MB_HRERROR_CALLING_PRIMARY_LEG_2;

                    wIcon = OIC_INFORMATION;
                }
			    else if (StatusCode == RTC_E_SIP_TIMEOUT)
			    {
				    nID1 = IDS_MB_HRERROR_SIP_TIMEOUT_OUT_1;
				    nID2 = IDS_MB_HRERROR_SIP_TIMEOUT_OUT_2;
                
                    wIcon = OIC_HAND;
			    }
			    else if (StatusCode == RTC_E_SIP_CODECS_DO_NOT_MATCH || 
                         StatusCode == RTC_E_SIP_PARSE_FAILED)
			    {
				    nID1 = IDS_MB_HRERROR_APPS_DONT_MATCH_1;
				    nID2 = IDS_MB_HRERROR_APPS_DONT_MATCH_OUT_2;
                
                    wIcon = OIC_INFORMATION;
			    }
                else
                {
                    nID1 = IDS_MB_HRERROR_GENERIC_OUT_1;
                    nID2 = IDS_MB_HRERROR_GENERIC_OUT_2;
                
                    wIcon = OIC_HAND;
                }
            }
            else
            {
                // incoming call
			    if (StatusCode == RTC_E_SIP_TIMEOUT)
			    {
				    nID1 = IDS_MB_HRERROR_SIP_TIMEOUT_IN_1;
				    nID2 = IDS_MB_HRERROR_SIP_TIMEOUT_IN_2;
                
                    wIcon = OIC_HAND;
			    }
			    else if (StatusCode == RTC_E_SIP_CODECS_DO_NOT_MATCH || 
                         StatusCode == RTC_E_SIP_PARSE_FAILED)
			    {
				    nID1 = IDS_MB_HRERROR_APPS_DONT_MATCH_1;
				    nID2 = IDS_MB_HRERROR_APPS_DONT_MATCH_IN_2;
                
                    wIcon = OIC_INFORMATION;
			    }
                else
                {
                    nID1 = IDS_MB_HRERROR_GENERIC_IN_1;
                    nID2 = IDS_MB_HRERROR_GENERIC_IN_2;

                    wIcon = OIC_HAND;
                }
            }
        
            //
            //  The third string displays the error code and text
            //

        
            PWSTR   pErrorText = NULL;

            dwLength = 0;
        
            // retrieve the error text
            if ( HRESULT_FACILITY(StatusCode) == FACILITY_RTC_INTERFACE )
            {
                // I hope it's the core 
                HANDLE  hRTCModule = GetModuleHandle(_T("RTCDLL.DLL"));
                dwLength = ::FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_HMODULE |
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    hRTCModule,
                    StatusCode,
                    0,
                    (LPTSTR)&pErrorText, // that's ugly
                    0,
                    NULL);
            }

        
            if (dwLength == 0)
            {
                // is it a QUARTZ error ?

                HANDLE  hQtzModule = GetModuleHandle(_T("QUARTZ.DLL"));
                dwLength = ::FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_HMODULE |
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    hQtzModule,
                    StatusCode,
                    0,
                    (LPTSTR)&pErrorText, // that's ugly
                    0,
                    NULL);
            }

            if(dwLength == 0)
            {
                // normal system errors
                dwLength = ::FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    StatusCode,
                    0,
                    (LPTSTR)&pErrorText, // that's ugly
                    0,
                    NULL);
            }

            // load the format
            // load a simpler one if the associated
            // text for Result could not be found
        
            pFormat = RtcAllocString(
                _Module.GetResourceInstance(),
                dwLength > 0 ? 
                IDS_MB_DETAIL_HR : IDS_MB_DETAIL_HR_UNKNOWN);
       
            if(pFormat)
            {
                LPCTSTR szInserts[] = {
                    (LPCTSTR)UlongToPtr(StatusCode), // ugly
                    pErrorText
                };

                PWSTR   pErrorTextCombined = NULL;
                
                // format the error message
                dwLength = ::FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    pFormat,
                    0,
                    0,
                    (LPTSTR)&pErrorTextCombined,
                    0,
                    (va_list *)szInserts);

                if(dwLength > 0)
                {
                    // set the error info
                    // this additional operation is needed
                    //  because we need RtcAlloc allocated memory

                    pErrorInfo->Message3 = RtcAllocString(pErrorTextCombined);
                }

                if(pErrorTextCombined)
                {
                    LocalFree(pErrorTextCombined);
                }

                RtcFree(pFormat);
                pFormat = NULL;
            
            }
    
            if(pErrorText)
            {
                LocalFree(pErrorText);
            }
        }
    }

    //
    // Prepare the first string.
    //

    pString = RtcAllocString(
                        _Module.GetResourceInstance(),
                        nID1);

    if(pString)
    {
        // do we have to insert the address ?
        if(bInsertAddress)
        {
            pFormat = pString;

            pString = NULL;

            // find the length
            dwLength = 
                ocslen(pFormat) // format length
             -  2               // length of %s
             +  (pAddress ? ocslen(pAddress) : 0);   // address

            pString = (PWSTR)RtcAlloc((dwLength + 1)*sizeof(WCHAR));
            
            if(pString)
            {
                _snwprintf(pString, dwLength + 1, pFormat, pAddress ? pAddress : L"");
            }

            RtcFree(pFormat);
            pFormat = NULL;
        }
    }

    pErrorInfo->Message1 = pString;

    pErrorInfo->Message2 = RtcAllocString(
                        _Module.GetResourceInstance(),
                        nID2);

    pErrorInfo->ResIcon = (HICON)LoadImage(
        0,
        MAKEINTRESOURCE(wIcon),
        IMAGE_ICON,
        0,
        0,
        LR_SHARED);
        
    LOG((RTC_TRACE, "[%p] CRTCCtl::PrepareErrorStrings - exit", this));

    return S_OK;
}


// FreeErrorStrings
//      Free error strings

void CRTCCtl::FreeErrorStrings(
        RTCAX_ERROR_INFO
               *pErrorInfo)
{
    if(pErrorInfo->Message1)
    {
        RtcFree(pErrorInfo->Message1);
        pErrorInfo->Message1 = NULL;
    }
    if(pErrorInfo->Message2)
    {
        RtcFree(pErrorInfo->Message2);
        pErrorInfo->Message2 = NULL;
    }
    if(pErrorInfo->Message3)
    {
        RtcFree(pErrorInfo->Message3);
        pErrorInfo->Message3 = NULL;
    }
}


// CoreInitialize
//      CoCreates and Initialize a CLSID_RTCClient object
//      Registers for notifications
//      
// 

HRESULT CRTCCtl::CoreInitialize()
{
    HRESULT hr;
    
    // This one won't make it into steelhead tracing, it is not initialized yet
    LOG((RTC_TRACE, "[%p] CRTCCtl::CoreInitialize - enter", this));

    // Create the main instance of the Core
    hr = m_pRTCClient.CoCreateInstance(CLSID_RTCClient);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot cocreate RTCClient, error %x", this, hr));
        return hr;
    }

    // Initialize the client
    hr = m_pRTCClient->Initialize();
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot Initialize RTCClient, error %x", this, hr));
        // releases explicitly the interface
        m_pRTCClient.Release();
        return hr;
    }

    if(m_nCtlMode == CTL_MODE_HOSTED)
    {
        // prepare a "one time" media preference
        
        m_lMediaPreferences = RTCMT_AUDIO_SEND | RTCMT_AUDIO_RECEIVE;

        if(!m_bPropDisableVideoReception && m_nPropCallScenario == RTC_CALL_SCENARIO_PCTOPC)
        {
            m_lMediaPreferences |= RTCMT_VIDEO_RECEIVE;
        }
        
        if(!m_bPropDisableVideoTransmission && m_nPropCallScenario == RTC_CALL_SCENARIO_PCTOPC)
        {
            m_lMediaPreferences |= RTCMT_VIDEO_SEND;
        }

        // Set volatile preferences
        hr = m_pRTCClient->SetPreferredMediaTypes( m_lMediaPreferences, FALSE );
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot set preferred media types, error %x", this, hr));

            m_pRTCClient->Shutdown();
            // releases explicitly the interface
            m_pRTCClient.Release();
            return hr;
        }

        // video preview preference as specified in the param
        m_bPreviewWindowIsPreferred = m_bPropDisableVideoPreview;
    }

    // Set the event filter

    hr = m_pRTCClient->put_EventFilter( RTCEF_CLIENT |
                                        RTCEF_SESSION_STATE_CHANGE |
                                        RTCEF_PARTICIPANT_STATE_CHANGE |
                                        RTCEF_MEDIA |
                                        RTCEF_INTENSITY	|
                                        RTCEF_MESSAGING );

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot set event filter, error %x", this, hr));

        m_pRTCClient->Shutdown();
        // releases explicitly the interface
        m_pRTCClient.Release();
        return hr;
    }

    // Find the connection point

    IConnectionPointContainer     * pCPC;
    IUnknown         * pUnk;

    hr = m_pRTCClient->QueryInterface(
                           IID_IConnectionPointContainer,
                           (void **) &pCPC
                          );

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot QI for connection point container, error %x", this, hr));

        m_pRTCClient->Shutdown();
        // releases explicitly the interface
        m_pRTCClient.Release();
        return hr;
    }

    hr = pCPC->FindConnectionPoint(
                              IID_IRTCEventNotification,
                              &m_pCP
                             );

    pCPC->Release();

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot find connection point, error %x", this, hr));

        m_pRTCClient->Shutdown();
        // releases explicitly the interface
        m_pRTCClient.Release();
        return hr;
    }    

    // Get IUnknown for ourselves

    hr = QueryInterface(
                   IID_IUnknown,
                   (void **)&pUnk
                  );

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot QI for IUnknown, error %x", this, hr));

        m_pCP->Release();
        m_pCP = NULL;

        m_pRTCClient->Shutdown();
        // releases explicitly the interface
        m_pRTCClient.Release();
        return hr;
    }

    // Register for notifications

    hr = m_pCP->Advise(
                 pUnk,
                 (ULONG *)&m_ulAdvise
                );

    pUnk->Release();

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot advise connection point, error %x", this, hr));
        
        m_pCP->Release();
        m_pCP = NULL;

        m_pRTCClient->Shutdown();
        // releases explicitly the interface
        m_pRTCClient.Release();
        return hr;
    }

    m_hCoreShutdownEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    if ( m_hCoreShutdownEvent == NULL )
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot create shutdown event", this));

        m_pCP->Unadvise(m_ulAdvise);
        m_pCP->Release();
        m_pCP = NULL;

        m_pRTCClient->Shutdown();
        // releases explicitly the interface
        m_pRTCClient.Release();
        return E_OUTOFMEMORY;
    }

    // Set local user name and uri

    BSTR bstrDisplayName = NULL;
    BSTR bstrUserURI = NULL;

    hr = get_SettingsString( SS_USER_DISPLAY_NAME, &bstrDisplayName );

    if ( SUCCEEDED(hr) )
    {
        hr = m_pRTCClient->put_LocalUserName( bstrDisplayName );

        SysFreeString( bstrDisplayName );
        bstrDisplayName = NULL;

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot set local user name, error %x", this, hr));
        }
    }

    hr = get_SettingsString( SS_USER_URI, &bstrUserURI );

    if ( SUCCEEDED(hr) )
    {
        hr = m_pRTCClient->put_LocalUserURI( bstrUserURI );

        SysFreeString( bstrUserURI );
        bstrUserURI = NULL;

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot set local user URI, error %x", this, hr));
        }
    }

    hr = EnableProfiles( m_pRTCClient );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; EnableProfiles failed, error %x", this, hr));
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::CoreInitialize - exit S_OK", this));
    return S_OK;
}

// CoreUninitialize
//      Unregisters the event sink
//      Shuts down and releases the RTCClient
// 

void CRTCCtl::CoreUninitialize()
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::CoreUninitialize - enter", this));

    // Shuts down the client
    if(m_pRTCClient!=NULL)
    {
        m_pRTCClient->put_EventFilter( RTCEF_CLIENT );

        // Forcibly terminates any call
        // Don't rely on any notification to change the state (we've just filtered)
        // so remove manually all the references
        if(m_pRTCActiveSession != NULL)
        {
            LOG((RTC_TRACE, "[%p] CRTCCtl::CoreUninitialize; Terminating the pending call...", this));

            m_pRTCActiveSession->Terminate(RTCTR_SHUTDOWN);

            LOG((RTC_INFO, "[%p] CRTCCtl::CoreUninitialize: releasing active session", this));

            m_pRTCActiveSession = NULL;
            
        }
        
        // Frees the participants from the list
        m_hParticipantList.RemoveAll();

        // Release any one shot profile we may have
        m_pRTCOneShotProfile.Release();

        // Release any cached profile
        m_pCachedProfile.Release();
        m_pRedirectProfile.Release();

        // Prepare for shutdown
        hr = m_pRTCClient->PrepareForShutdown();
        if(FAILED(hr))
        {
            // Hmm
            LOG((RTC_ERROR, "[%p] CRTCCtl::CoreUninitialize; cannot PrepareForShutdown RTCClient, error %x", this, hr));
        }
        else
        {
            MSG msg;

            while (MsgWaitForMultipleObjects (
                1,                  // nCount
                &m_hCoreShutdownEvent, // pHandles
                FALSE,              // fWaitAll
                INFINITE,           // dwMilliseconds
                QS_ALLINPUT         // dwWakeMask
                ) != WAIT_OBJECT_0)
            {
                while (PeekMessage (
                    &msg,           // lpMsg
                    NULL,           // hWnd
                    0,              // wMsgFilterMin
                    0,              // wMsgFilterMax
                    PM_REMOVE       // wRemoveMsg
                    ))
                {
                    TranslateMessage (&msg);
                    DispatchMessage (&msg);
                }
            }
        }

        CloseHandle( m_hCoreShutdownEvent );
        m_hCoreShutdownEvent = NULL;

        // unregister our event sink
        hr = m_pCP->Unadvise( m_ulAdvise );

        m_pCP->Release();
        m_pCP = NULL;

        if(FAILED(hr))
        {
            // Hmm
            LOG((RTC_ERROR, "[%p] CRTCCtl::CoreUninitialize; cannot unregister event sink(???), error %x", this, hr));
        }        

        hr = m_pRTCClient->Shutdown();
        if(FAILED(hr))
        {
            // Hmm
            LOG((RTC_ERROR, "[%p] CRTCCtl::CoreUninitialize; cannot Shutdown RTCClient, error %x", this, hr));
        }
        
        // releases explicitly the interface
        m_pRTCClient.Release();
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::CoreUninitialize - exit", this));
}

// CallOneShot
// 
//      Creates an IRTCProfile based on the provisioning profile 
//   set as a parameter , asks for the user to enter "from" address 
//   and calls DoCall(intf, props).
// 
  
HRESULT CRTCCtl::CallOneShot(void)
{
    HRESULT hr;

    CComBSTR                bstrFromAddressChosen;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::CallOneShot - enter", this));
    
    ATLASSERT(m_nControState == RTCAX_STATE_IDLE);
        
    SetControlState(RTCAX_STATE_DIALING);

    // Invoke a dialog box if necessary
    // For PCTOPC and PCtoPhone we have all the info (there's no From address involved)
    if(m_nPropCallScenario == RTC_CALL_SCENARIO_PHONETOPHONE)
    {

        ATLASSERT(m_pRTCOneShotProfile.p);

        LOG((RTC_TRACE, "[%p] CRTCCtl::CallOneShot: bring up ShowDialByPhoneNumberDialog", this));

        hr = ShowDialNeedCallInfoDialog(
                                        m_hWnd,
                                        m_pRTCClient,
                                        RTCSI_PHONE_TO_PHONE,
                                        FALSE,
                                        FALSE,
                                        m_pRTCOneShotProfile,
                                        m_bstrPropDestinationUrl,
                                        NULL,
                                        NULL, // we don't care about profile chosen
                                        &bstrFromAddressChosen
                                        );
    }
    else
    {
        hr = S_OK;
    }
    
    if(SUCCEEDED(hr))
    {
        // Do the work
        hr = DoCall(m_pRTCOneShotProfile,
                    m_nPropCallScenario,
                    bstrFromAddressChosen,
                    m_bstrPropDestinationName,
                    m_bstrPropDestinationUrl);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::CallOneShot: error (%x) returned by DoCall(...)", this, hr));
            
            SetControlState(RTCAX_STATE_IDLE, 0, hr);
        }
    }
    else if (hr==E_ABORT)
    {
        LOG((RTC_TRACE, "[%p] CRTCCtl::CallOneShot: ShowXXXDialog dismissed, do nothing", this));

        SetControlState(RTCAX_STATE_IDLE);
    }
    else
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CallOneShot: error (%x) returned ShowXXXDialog", this, hr));
        
        SetControlState(RTCAX_STATE_IDLE);
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::CallOneShot - exit", this));

    return hr;
}




// RedirectedCall
// Places a call to the next contact in the redirection context
//  Returns S_OK when a call has been placed successfully
//          S_FALSE when there are no more addresses
//          E_ABORT if the user chose not to continue in a callinfo dlgbox
//          E_other for any unrecoverable error
//  The outcome of the last call that failed in DoCall is returned as an Out parameter.

HRESULT CRTCCtl::RedirectedCall(HRESULT *phCallResult)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::RedirectedCall - enter", this));

    HRESULT     hr;

    *phCallResult = S_OK;

    do
    {
        // advance in the list of contacts
        // if it returns false, we are at the end of the list
        hr = m_pRTCActiveSession->NextRedirectedUser();

        if(hr == S_FALSE)
        {
            // end of addresses
            LOG((RTC_TRACE, "[%p] CRTCCtl::RedirectedCall - end of list has been reached, exit", this));

            return S_FALSE;
        }
        else if (hr != S_OK)
        {
            // cannot continue
            LOG((RTC_ERROR, "[%p] CRTCCtl::RedirectedCall - error (%x) returned by Advance, exit", this, hr));

            return hr;
        }

        // Get the names
        //
        CComBSTR    bstrName;
        CComBSTR    bstrAddress;

        hr = m_pRTCActiveSession->get_RedirectedUserURI(
            &bstrAddress);

        if(FAILED(hr))
        {
            // cannot continue
            LOG((RTC_ERROR, "[%p] CRTCCtl::RedirectedCall - error (%x) returned by get_UserURI, exit", this, hr));

            return hr;
        }
        
        hr = m_pRTCActiveSession->get_RedirectedUserName(
            &bstrName);

        if(FAILED(hr))
        {
            // cannot continue
            LOG((RTC_ERROR, "[%p] CRTCCtl::RedirectedCall - error (%x) returned by get_UserName, exit", this, hr));

            return hr;
        }

        // decide on whether to display the UI or not
        BOOL    bIsPhone;
        BOOL    bIsSIP;
        BOOL    bIsTEL;
        BOOL    bHasMaddrOrTsp;
        BOOL    bIsEmailLike;

        hr = GetAddressType(
            bstrAddress,
            &bIsPhone,
            &bIsSIP,
            &bIsTEL,
            &bIsEmailLike,
            &bHasMaddrOrTsp);

        if(FAILED(hr))
        {
            *phCallResult = HRESULT_FROM_WIN32(ERROR_UNSUPPORTED_TYPE);

            continue;
        }

        // The UI is only shown in standalone mode
        //

        // UI for choosing provider/from is displayed for
        //      phone numbers
        //      tel urls with no tsp
    
        // UI is not displayed for (and a NULL profile is passed to core):
        //      pc addresses
        //      tel urls with tsp
        //      sip urls of type phone
        //      sip urls of type pc

        if(m_nCtlMode == CTL_MODE_STANDALONE &&
            ((bIsPhone && !bIsSIP && !bIsTEL)   //plain phone numbers
            || (bIsTEL && !bHasMaddrOrTsp) ) )   //tel urls with no tsp  
        {
            CComPtr<IRTCProfile> pProfileChosen;
            CComBSTR            bstrFromAddressChosen;
            CComBSTR            bstrInstructions;


            bstrInstructions.LoadString(IDS_TEXT_CALLINFO_REDIRECT);

            hr = ShowDialNeedCallInfoDialog(
                                            m_hWnd,
                                            m_pRTCClient,
                                            bIsPhone ? (RTCSI_PC_TO_PHONE | RTCSI_PHONE_TO_PHONE)
                                            : RTCSI_PC_TO_PC,
                                            TRUE,
                                            TRUE,
                                            NULL,
                                            bstrAddress,
                                            bstrInstructions,
                                            &pProfileChosen,
                                            &bstrFromAddressChosen
                                        );
            if(FAILED(hr))
            {
                // cannot continue with the redirection
                LOG((RTC_WARN, "[%p] CRTCCtl::RedirectedCall - error (%x) returned by "
                    "ShowDialNeedCallInfoDialog, exit", this, hr));

                return hr; // this includes E_ABORT
            }

            *phCallResult = DoRedirect(
                pProfileChosen,
                bstrFromAddressChosen && *bstrFromAddressChosen!=L'\0' 
                ? RTC_CALL_SCENARIO_PHONETOPHONE : RTC_CALL_SCENARIO_PCTOPHONE,
                bstrFromAddressChosen,
                bstrName,
                bstrAddress
                );
        }
        else
        {
            RTC_CALL_SCENARIO   nCallScenario;

            // For phone addresses, we set the scenario based on the original one
            //  
            //  m_nCachedCallScenario -> nCallScenario
            //
            //  PC_TO_PC                PC_TO_PHONE
            //  PC_TO_PHONE             PC_TO_PHONE
            //  PHONE_TO_PHONE          PHONE_TO_PHONE
            // 
            // For PC addresses
            // nCallScenario is PC_TO_PC whatever the original call scenario was
            //
            if(bIsPhone)
            {
                nCallScenario = m_nCachedCallScenario == RTC_CALL_SCENARIO_PCTOPC ?
                    RTC_CALL_SCENARIO_PCTOPHONE : m_nCachedCallScenario;
            }
            else
            {
                nCallScenario = RTC_CALL_SCENARIO_PCTOPC;
            }

            *phCallResult = DoRedirect(
                NULL, // use no profile !!!
                nCallScenario,
                m_bstrCachedLocalPhoneURI,
                bstrName,
                bstrAddress
                );
        }

    // exit if a DoCall returns S_OK, because an event will be posted eventually
    } while (FAILED(*phCallResult));


    LOG((RTC_TRACE, "[%p] CRTCCtl::RedirectedCall - exit", this));

    return S_OK;
}

// DoRedirect
//   Places the redirected call
//
HRESULT CRTCCtl::DoRedirect(/*[in]*/ IRTCProfile *pProfile,
                   /*[in]*/ RTC_CALL_SCENARIO CallScenario,
                   /*[in]*/ BSTR     pLocalPhoneAddress,
                   /*[in]*/ BSTR     pDestName,
                   /*[in]*/ BSTR     pDestAddress)

{
    HRESULT hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::DoRedirect - enter", this));
    
    ATLASSERT(m_nControState == RTCAX_STATE_DIALING);

    // cache some parameters, needed for redirects, for changing the visual layout, etc.
    m_nCachedCallScenario = CallScenario;
    m_pCachedProfile = pProfile;
    m_bstrCachedLocalPhoneURI = pLocalPhoneAddress;
    
    // Create session
    hr = m_pRTCActiveSession->Redirect(
        (RTC_SESSION_TYPE)CallScenario,
        pLocalPhoneAddress,
        pProfile,
        RTCCS_FORCE_PROFILE | RTCCS_FAIL_ON_REDIRECT
        );

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::DoRedirect - error <%x> when calling Redirect, exit", this, hr));

        // delete participants
        m_hParticipantList.RemoveAll();

        return hr;
    }

    //  Save the address for error messages
    //
    m_bstrOutAddress = pDestAddress;

    // Create the participant (callee)
    // This will fire events
    hr = m_pRTCActiveSession->AddParticipant(
        pDestAddress,
        pDestName ? pDestName : _T(""),
        NULL);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::DoRedirect - error <%x> when calling AddParticipant, exit", this, hr));
        
        m_pRTCActiveSession->Terminate(RTCTR_NORMAL);

        // delete participants
        m_hParticipantList.RemoveAll();

        return hr;
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::DoRedirect - exit S_OK", this));

    return S_OK;
}

// DoCall
//   Places the call to the core
//
HRESULT CRTCCtl::DoCall(/*[in]*/ IRTCProfile *pProfile,
                   /*[in]*/ RTC_CALL_SCENARIO CallScenario,
                   /*[in]*/ BSTR     pLocalPhoneAddress,
                   /*[in]*/ BSTR     pDestName,
                   /*[in]*/ BSTR     pDestAddress)

{
    CComPtr<IRTCSession> pSession;

    HRESULT hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::DoCall - enter", this));
    
    ATLASSERT(m_nControState == RTCAX_STATE_DIALING);

    // cache some parameters, needed for redirects, for changing the visual layout, etc.
    m_nCachedCallScenario = CallScenario;
    m_pCachedProfile = pProfile;
    m_bstrCachedLocalPhoneURI = pLocalPhoneAddress;
    
    // Create session
    hr = m_pRTCClient->CreateSession(
        (RTC_SESSION_TYPE)CallScenario,
        pLocalPhoneAddress,
        pProfile,
        RTCCS_FORCE_PROFILE | RTCCS_FAIL_ON_REDIRECT,
        &pSession);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::DoCall - error <%x> when calling CreateSession, exit", this, hr));

        // delete participants
        m_hParticipantList.RemoveAll();

        return hr;
    }

    //  Save the address for error messages
    //
    m_bstrOutAddress = pDestAddress;

    // Create the participant (callee)
    // This will fire events
    hr = pSession->AddParticipant(
        pDestAddress,
        pDestName ? pDestName : _T(""),
        NULL);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::DoCall - error <%x> when calling AddParticipant, exit", this, hr));
        
        pSession->Terminate(RTCTR_NORMAL);

        // delete participants
        m_hParticipantList.RemoveAll();

        return hr;
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::DoCall - exit S_OK", this));

    return S_OK;
}


// Accept
//      Accept the currently alerting session

HRESULT CRTCCtl::Accept(void)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::Accept - enter", this));

    if(m_pRTCActiveSession == NULL)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::Accept called, but there's no active session, exit", this));

        return E_FAIL;
    }
    
    ATLASSERT(m_nControState == RTCAX_STATE_ALERTING);

    // Set the Answering mode
    SetControlState(RTCAX_STATE_ANSWERING);
                
    // answer the call   
    hr = m_pRTCActiveSession -> Answer();
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::Accept, Answer returned error <%x>", this, hr));
                    
        // try a terminate..
        if(m_pRTCActiveSession != NULL)
        {
            HRESULT hr1;

            hr1 = m_pRTCActiveSession->Terminate(RTCTR_NORMAL);

            if(FAILED(hr1))
            {
                // release it, if it's still there

                LOG((RTC_INFO, "[%p] CRTCCtl::Accept: releasing active session", this));

                m_pRTCActiveSession = NULL;
            }
        }
        
        // set the idle state
        SetControlState(RTCAX_STATE_IDLE, hr);

        return hr;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::Accept - exit", this));

    return S_OK;
}

// Reject
//      Reject the currently alerting session

HRESULT CRTCCtl::Reject(RTC_TERMINATE_REASON Reason)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::Reject - enter", this));

    if(m_pRTCActiveSession == NULL)
    {
        // may happen
        // harmless

        LOG((RTC_TRACE, "[%p] CRTCCtl::Reject called, but there's no active session, exit", this));

        return S_FALSE;
    }
    
    ATLASSERT(m_nControState == RTCAX_STATE_ALERTING);

    // Set the Disconnecting mode
    SetControlState(RTCAX_STATE_DISCONNECTING);
                
    // reject the call   
    hr = m_pRTCActiveSession -> Terminate(Reason);
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::Reject, Terminate returned error <%x>", this, hr));
                    
        // release it, if it's still there
        LOG((RTC_INFO, "[%p] CRTCCtl::Reject: releasing active session", this));

        m_pRTCActiveSession = NULL;
        
        // set the idle state
        SetControlState(RTCAX_STATE_IDLE);
        
        return hr;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::Reject - exit", this));

    return S_OK;
}


// OnSessionStateChangeEvent
//      Processes session events

HRESULT CRTCCtl::OnSessionStateChangeEvent(IRTCSessionStateChangeEvent *pEvent)
{
    CComPtr<IRTCSession> pSession = NULL;
    RTC_SESSION_STATE   SessionState;
    RTC_SESSION_TYPE    SessionType;
    long                StatusCode;
    HRESULT     hr;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnSessionStateChangeEvent - enter", this));

    // Grab the relevant data from the event
    //
    if(!pEvent)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnSessionStateChangeEvent, no interface ! - exit", this));
        return E_UNEXPECTED;
    }
    
    hr = pEvent->get_Session(&pSession);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnSessionStateChangeEvent, error <%x> in get_Session - exit", this, hr));
        return hr;
    }
    
    if(pSession==NULL)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnSessionStateChangeEvent, no session interface ! - exit", this));
        return E_UNEXPECTED;
    }

    hr = pEvent->get_State(&SessionState);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnSessionStateChangeEvent, error <%x> in get_State - exit", this, hr));
        return hr;
    }
    
    hr = pEvent->get_StatusCode(&StatusCode);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnSessionStateChangeEvent, error <%x> in get_StatusCode - exit", this, hr));
        return hr;
    }

    hr = pSession->get_Type(&SessionType);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnSessionStateChangeEvent, error <%x> in get_Type - exit", this, hr));
        return hr;
    }

    hr = S_OK; // optimistic

    if (SessionType == RTCST_IM)
    {
        //
        // Instant message session
        //

        if (m_pIMWindows != NULL)
        {
            hr = m_pIMWindows->DeliverState( pSession, SessionState );
        }
    }
    else
    {
        BOOL    bExpected = FALSE;

        //
        //  The only acceptable event in IDLE state is an incoming call
        //

        if(m_nControlState == RTCAX_STATE_IDLE)
        {
            // In this state there must be no current session
            ATLASSERT(m_pRTCActiveSession == NULL);
        
            switch(SessionState)
            {
            case RTCSS_INCOMING:
            
                // this is a new session that has to be cached as the current session
                //
                m_pRTCActiveSession = pSession;

                // Alert the user, ring the bell
                LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent, Alerting...", this));
                
                SetControlState(RTCAX_STATE_ALERTING);

                bExpected = TRUE;

                break;
            }
        }
        else if (m_nControlState == RTCAX_STATE_CONNECTING ||
                 m_nControlState == RTCAX_STATE_ANSWERING ||
                 m_nControlState == RTCAX_STATE_DISCONNECTING ||
                 m_nControlState == RTCAX_STATE_CONNECTED ||
                 m_nControlState == RTCAX_STATE_ALERTING ||
                 m_nControlState == RTCAX_STATE_DIALING ||
                 m_nControlState == RTCAX_STATE_UI_BUSY)
        {
            // First verify the event is for the current session
            // 
            if(m_pRTCActiveSession == pSession)
            {
                // the session is the current session
                //
                switch(SessionState)
                {
                case RTCSS_CONNECTED:
                    if(m_nControlState == RTCAX_STATE_CONNECTING ||
                       m_nControlState == RTCAX_STATE_ANSWERING )
                    {
                        // Connected, life is good
                        //
                        LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent, Connected !", this));

                        // Change the control status
                        SetControlState(RTCAX_STATE_CONNECTED);
                    
                        bExpected = TRUE;
                    }
                    break;

                case RTCSS_DISCONNECTED:
                    // rejected or whatever
                    //
                    LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent, Disconnected", this));                                   
                
                    hr = S_OK;

                    // process the special case of redirects (Status code between 300 and 399)
                    if( (m_nControlState == RTCAX_STATE_CONNECTING) &&
                        (HRESULT_FACILITY(StatusCode) == FACILITY_SIP_STATUS_CODE) &&
                        (HRESULT_CODE(StatusCode) >= 300) &&
                        (HRESULT_CODE(StatusCode) <= 399) &&
                        (HRESULT_CODE(StatusCode) != 380) )                        
                    {
                        // yes, this is a redirect
                        LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent, Redirecting...", this));
                    
                        // mark the redirect mode (it's a substatus of CONNECTING...)
                        m_bRedirecting = TRUE;

                        // store the redirect profile
                        m_pRedirectProfile = m_pCachedProfile;
                    
                        // fall thru
                        // SetControlState will take care of posting a new call
                    }
                    else if ( !m_bRedirecting )
                    {
                        // release the current session
                        LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent: releasing active session", this));

                        m_pRTCActiveSession = NULL;
                    }
                
                    // delete participants
                    m_hParticipantList.RemoveAll();

                    // back to idle
                    SetControlState(RTCAX_STATE_IDLE, StatusCode);
                                
                    bExpected = TRUE;
                    break;

                case RTCSS_INPROGRESS:
                
                    // corresponds to provisional responses
                    //
                    LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent, new inprogress status", this));
                
                    // 
                    SetControlState(RTCAX_STATE_CONNECTING, StatusCode);
 
                    // change status for myself
                    // ChangeParticipantStateInList(NULL, ); 
                
                    bExpected = TRUE;
                    break;

                case RTCSS_ANSWERING:

                    if(m_nControlState == RTCAX_STATE_ANSWERING)
                    {
                        //
                        // Nothing to do here, the UI is already in the ANSWERING state
                        //

                        LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent, answering event, do nothing", this));

                        bExpected = TRUE;
                    }

                    break;
                }
            }
            else
            {
                // This is a session other than the current session
                //
                if(SessionState == RTCSS_INPROGRESS)
                {
                    if(m_nControlState == RTCAX_STATE_DIALING)
                    {
                        // this is the call we're placing

                        ATLASSERT(m_pRTCActiveSession == NULL);

                        // cache the session
                        // we assume the session is not bogus

                        LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent: setting active session [%p]", this, pSession));

                        m_pRTCActiveSession = pSession;
                
                        // Set the state to Connecting
                        SetControlState(RTCAX_STATE_CONNECTING, StatusCode);
            
                        bExpected = TRUE;
                    }
                }
                else if(SessionState == RTCSS_INCOMING)
                {
            
                    // This is an incoming call
                    // reject any incoming calls, we are busy !
                    //
                    LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent, we're busy, calling Terminate", this));

                    hr = pSession -> Terminate(RTCTR_BUSY);

                    if(FAILED(hr))
                    {
                        LOG((RTC_ERROR, "[%p] CRTCCtl::OnSessionStateChangeEvent, Terminate returned error <%x>", this, hr));
                    }

                    bExpected = TRUE;
                }
            }
        }

        if(!bExpected && SessionState == RTCSS_DISCONNECTED)
        {
            bExpected = TRUE;
        }

        if(!bExpected)
        {
            // not expected
            LOG((RTC_ERROR, "[%p] CRTCCtl::OnSessionStateChangeEvent, unexpected state <Session:%x, UI:%x>", 
                    this, SessionState, m_nControlState));
            hr = E_UNEXPECTED;
        }
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnSessionStateChangeEvent - exit", this));

    return hr;
}

// OnParticipantStateChangeEvent
//      Processes participant events
//
HRESULT CRTCCtl::OnParticipantStateChangeEvent(IRTCParticipantStateChangeEvent *pEvent)
{
    CComPtr<IRTCParticipant> pParticipant = NULL;
    RTC_PARTICIPANT_STATE   ParticipantState;
    long                StatusCode;
    HRESULT     hr;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnParticipantStateChangeEvent - enter", this));

    if(!pEvent)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnParticipantStateChangeEvent, no interface ! - exit", this));
        return E_UNEXPECTED;
    }
    
    hr = pEvent->get_Participant(&pParticipant);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnParticipantStateChangeEvent, error <%x> in get_Participant - exit", this, hr));
        return hr;
    }
    
    if(pParticipant==NULL)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnParticipantStateChangeEvent, no participant interface ! - exit", this));
        return E_UNEXPECTED;
    }

    hr = pEvent->get_State(&ParticipantState);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnParticipantStateChangeEvent, error <%x> in get_State - exit", this, hr));
        return hr;
    }
    
    hr = pEvent->get_StatusCode(&StatusCode);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnParticipantStateChangeEvent, error <%x> in get_StatusCode - exit", this, hr));
        return hr;
    }
    
    hr = m_hParticipantList.Change(pParticipant, ParticipantState, StatusCode);
    
    if(ParticipantState == RTCPS_DISCONNECTED)
    {
        // refresh the Remove Participant button
        UpdateRemovePartButton();
    }
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnParticipantStateChangeEvent, error <%x> "
            "in m_hParticipantList.Change - exit", this, hr));
        
        return hr;
    }
  
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnParticipantStateChangeEvent - exit", this));

    return hr;
}

// OnClientEvent
//      Processes streaming events
//
HRESULT CRTCCtl::OnClientEvent(IRTCClientEvent *pEvent)
{
    HRESULT     hr;
    RTC_CLIENT_EVENT_TYPE nEventType;          

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnClientEvent - enter", this));

    if(!pEvent)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnClientEvent, no interface ! - exit", this));
        return E_UNEXPECTED;
    }
 
    // grab the event components
    //
    hr = pEvent->get_EventType(&nEventType);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnClientEvent, error <%x> in get_EventType - exit", this, hr));
        return hr;
    }

    if (nEventType == RTCCET_VOLUME_CHANGE)
    {
        //
        // Refresh the audio controls
        //

        RefreshAudioControls();
    }
    else if (nEventType == RTCCET_DEVICE_CHANGE)
    {
        if(m_pRTCClient!=NULL)
        {
            LONG lOldMediaCapabilities = m_lMediaCapabilities;

            //
            // Read capabilities from core
            //
            hr = m_pRTCClient->get_MediaCapabilities( &m_lMediaCapabilities );

            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::OnClientEvent - "
                    "error (%x) returned by get_MediaCapabilities, exit",this,  hr));
            }
        
            //
            // Get media preferences
            //
            hr = m_pRTCClient->get_PreferredMediaTypes( &m_lMediaPreferences);
            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::OnClientEvent - "
                    "error (%x) returned by get_PreferredMediaTypes, exit",this,  hr));
            }

            LONG lChangedMediaCapabilities = lOldMediaCapabilities ^ m_lMediaCapabilities;
            LONG lAddedMediaCapabilities = m_lMediaCapabilities & lChangedMediaCapabilities;
            LONG lRemovedMediaCapabilities = lChangedMediaCapabilities ^ lAddedMediaCapabilities;

            //
            // Add/Remove media types
            //

            put_MediaPreferences( m_lMediaPreferences | lAddedMediaCapabilities & ~lRemovedMediaCapabilities );
        }

        //
        // Refersh video and audio controls
        //

        RefreshVideoControls();
        RefreshAudioControls();
    }
    else if (nEventType == RTCCET_ASYNC_CLEANUP_DONE)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnClientEvent, RTCCET_ASYNC_CLEANUP_DONE", this));

        SetEvent( m_hCoreShutdownEvent );
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnClientEvent - exit", this));

    return hr;
}

// OnMediaEvent
//      Processes streaming events
//
HRESULT CRTCCtl::OnMediaEvent(IRTCMediaEvent *pEvent)
{
    HRESULT     hr;
    RTC_MEDIA_EVENT_TYPE nEventType;
    RTC_MEDIA_EVENT_REASON nEventReason;
    LONG        lMediaType;           

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnMediaEvent - enter", this));

    if(!pEvent)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMediaEvent, no interface ! - exit", this));
        return E_UNEXPECTED;
    }
 
    // grab the event components
    //
    hr = pEvent->get_EventType(&nEventType);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMediaEvent, error <%x> in get_EventType - exit", this, hr));
        return hr;
    }

    hr = pEvent->get_EventReason(&nEventReason);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMediaEvent, error <%x> in get_EventReason - exit", this, hr));
        return hr;
    }

    hr = pEvent->get_MediaType(&lMediaType);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMediaEvent, error <%x> in get_MediaType - exit", this, hr));
        return hr;
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnMediaEvent - type %x, state %x", this, lMediaType, nEventType));

    hr = S_OK;

    if ((nEventType == RTCMET_STOPPED) &&
        (nEventReason == RTCMER_HOLD) )
    {
        SetControlState(m_nControlState, S_OK, IDS_SB_STATUS_HOLD);        
    }
    else
    {
        SetControlState(m_nControlState, S_OK);
    }

    //
    // Video event ?
    //
    if(lMediaType & (RTCMT_VIDEO_SEND | RTCMT_VIDEO_RECEIVE))
    {
        hr = S_OK;

        if(lMediaType & RTCMT_VIDEO_RECEIVE)
        {
            hr = OnVideoMediaEvent(TRUE, nEventType == RTCMET_STARTED);
        }

        if((lMediaType & RTCMT_VIDEO_SEND))
        {
            HRESULT hr1;

            hr1 = OnVideoMediaEvent(FALSE, nEventType == RTCMET_STARTED);

            if(FAILED(hr1) && SUCCEEDED(hr))
            {
                hr = hr1;
            }
        }
    }
    
    //
    // Audio event ?
    //

    if(lMediaType & (RTCMT_AUDIO_SEND | RTCMT_AUDIO_RECEIVE))
    {
        //
        // Muting might be automatically disabled, so keep the controls in sync
        //
        RefreshAudioControls();
    }

    //
    // Send Audio event (dialpad)
    //
    
    if(lMediaType & RTCMT_AUDIO_SEND)
    {
        hr = S_OK;                       

        if (nEventType == RTCMET_STARTED)
        {
            //
            // Enable the dialpad
            //

            CWindow *pDtmfCrt = m_hDtmfButtons;
            CWindow *pDtmfEnd = m_hDtmfButtons + NR_DTMF_BUTTONS;

            for (int id = IDC_DIAL_0; pDtmfCrt<pDtmfEnd; pDtmfCrt++, id++)
                 pDtmfCrt->EnableWindow(TRUE);

        }
        else if (nEventType == RTCMET_STOPPED)
        {
            //
            // Disable the dialpad
            //

            CWindow *pDtmfCrt = m_hDtmfButtons;
            CWindow *pDtmfEnd = m_hDtmfButtons + NR_DTMF_BUTTONS;

            for (int id = IDC_DIAL_0; pDtmfCrt<pDtmfEnd; pDtmfCrt++, id++)
                 pDtmfCrt->EnableWindow(FALSE);
        }
    }

    //
    // Are we streaming video?
    //

    if (m_pRTCClient != NULL)
    {
        long lMediaTypes = 0;

        hr = m_pRTCClient->get_ActiveMedia( &lMediaTypes );

        if ( SUCCEEDED(hr) )
        {
            m_bBackgroundPalette = 
                ( lMediaTypes & (RTCMT_VIDEO_SEND | RTCMT_VIDEO_RECEIVE) ) ? TRUE : FALSE;

            if (m_pSpeakerKnob != NULL)
            {
                m_pSpeakerKnob->SetBackgroundPalette(m_bBackgroundPalette);
            }

            if (m_pMicroKnob != NULL)
            {
                m_pMicroKnob->SetBackgroundPalette(m_bBackgroundPalette);
            }
        }
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnMediaEvent - exit", this));

    return hr;
}

// OnIntensityEvent
//      Processes Intensity monitor events
//
HRESULT CRTCCtl::OnIntensityEvent(IRTCIntensityEvent *pEvent)
{
    HRESULT     hr;

    LONG lMin, lMax, lLevel;
    RTC_AUDIO_DEVICE adDirection;

//    LOG((RTC_TRACE, "[%p] CRTCCtl::OnIntensityEvent - enter", this));

    if(!pEvent)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnIntensityEvent, no interface ! - exit", this));
        return E_UNEXPECTED;
    }
 
    //
    // Get the min, max, value and direction of the stream.
    //


    hr = pEvent->get_Direction(&adDirection);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnIntensityEvent, error <%x> in get_Direction - exit", this, hr));
        return hr;
    }
    
    hr = pEvent->get_Min(&lMin);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnIntensityEvent, error <%x> in get_Min - exit", this, hr));
        return hr;
    }

    hr = pEvent->get_Max(&lMax);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnIntensityEvent, error <%x> in get_Max - exit", this, hr));
        return hr;
    }


    hr = pEvent->get_Level(&lLevel);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnIntensityEvent, error <%x> in get_Level - exit", this, hr));
        return hr;
    }

    // Log the value.
    //LOG((RTC_INFO, "[%p] CRTCCtl::OnIntensityEvent - [%d] %d - %d, %d", this, adDirection, lMin, lMax, lLevel));

    // Display the level on the knob.

    if (adDirection == RTCAD_MICROPHONE)
    {
        DWORD dwIncrement = lMax - lMin;

        if (dwIncrement == 0)
        {
            // This will clear the display
            m_pMicroKnob->SetAudioLevel(0);
        }
        else
        {
            m_pMicroKnob->SetAudioLevel((double)lLevel/(double)dwIncrement);
        }
    }
    if (adDirection == RTCAD_SPEAKER)
    {
        DWORD dwIncrement = lMax - lMin;

        if (dwIncrement == 0)
        {
            // This will clear the display
            m_pSpeakerKnob->SetAudioLevel(0);
        }
        else
        {
            m_pSpeakerKnob->SetAudioLevel((double)lLevel/(double)dwIncrement);
        }
    }

//    LOG((RTC_TRACE, "[%p] CRTCCtl::OnIntensityEvent - exit", this));

    return hr;
}

// OnMessageEvent
//      Processes instant message events
//
HRESULT CRTCCtl::OnMessageEvent(IRTCMessagingEvent *pEvent)
{
    HRESULT     hr;

    CComPtr<IRTCSession>      pSession = NULL;
    CComPtr<IRTCParticipant>  pParticipant = NULL;
    RTC_MESSAGING_EVENT_TYPE  enType;    

//    LOG((RTC_TRACE, "[%p] CRTCCtl::OnMessageEvent - enter", this));

    if(!pEvent)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, no interface ! - exit", this));
        return E_UNEXPECTED;
    }
 
    hr = pEvent->get_Session(&pSession);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, error <%x> in get_Session - exit", this, hr));
        return hr;
    }
    
    if(pSession == NULL)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, no session interface ! - exit", this));
        return E_UNEXPECTED;
    }

    hr = pEvent->get_Participant(&pParticipant);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, error <%x> in get_Participant - exit", this, hr));
        return hr;
    }
    
    if(pParticipant == NULL)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, no participant interface ! - exit", this));
        return E_UNEXPECTED;
    }

    hr = pEvent->get_EventType(&enType);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, error <%x> in get_EventType - exit", this, hr));
        return hr;
    }

    switch ( enType )
    {
    case RTCMSET_MESSAGE:
        {
            BSTR                      bstrMessage = NULL;

            hr = pEvent->get_Message(&bstrMessage);
            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, error <%x> in get_Message - exit", this, hr));
                return hr;
            }

            if (bstrMessage == NULL)
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, no message ! - exit", this));
                return E_UNEXPECTED;
            }

            if (m_pIMWindows != NULL)
            {
                hr = m_pIMWindows->DeliverMessage( pSession, pParticipant, bstrMessage );
            }

            SysFreeString( bstrMessage );
        }
        break;

    case RTCMSET_STATUS:
        {
            RTC_MESSAGING_USER_STATUS enStatus;

            hr = pEvent->get_UserStatus(&enStatus);
            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, error <%x> in get_Message - exit", this, hr));
                return hr;
            }

            if (m_pIMWindows != NULL)
            {
                hr = m_pIMWindows->DeliverUserStatus( pSession, pParticipant, enStatus );
            }
        }
        break;

    default:
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent,invalid event type - exit", this));
        return E_FAIL;
    }

//    LOG((RTC_TRACE, "[%p] CRTCCtl::OnMessageEvent - exit", this));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\provstore.h ===
/**********************************************************************************
*
*   Copyright (c) 2000  Microsoft Corporation
*
*   Module Name:
*
*    provstore.h
*
*   Abstract:
*
*    Definition of the CProvStore class that implements all the internal support
*    functions. 
*
*    This is the include file for all the data structures and constants required for 
*    the provisioning module. The basic class CProvStore implements all the 
*    support functions which will be required to implement the APIs.
*
************************************************************************************/
#ifndef _PROVSTORE_H
#define _PROVSTORE_H

#include <objectsafeimpl.h>
#include "RTCObjectSafety.h"
#include "Rpcdce.h"
#include <Mshtmcid.h>
#include <Mshtml.h>
#include <string.h>


HRESULT EnableProfiles( IRTCClient * pClient );

HRESULT GetKeyFromProfile( BSTR bstrProfileXML, BSTR * pbstrKey );

HRESULT MyOpenProvisioningKey( HKEY * phProvisioningKey, BOOL fReadOnly);
HRESULT MyGetProfileFromKey(
                            HKEY hProvisioningKey, 
                            WCHAR *szSubKeyName, 
                            WCHAR **pszProfileXML
                            );


/////////////////////////////////////////////////////////////////////////////
// CRTCProvStore
class ATL_NO_VTABLE CRTCProvStore : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public ISupportErrorInfo,
    public CComCoClass<CRTCProvStore, &CLSID_RTCProvStore>,
    public IDispatchImpl<IRTCProvStore, &IID_IRTCProvStore, &LIBID_RTCCtlLib>,
    public CRTCObjectSafety
{
public:
    CRTCProvStore()
    {
    }

DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_REGISTRY_RESOURCEID(IDR_RTCProvStore)

BEGIN_COM_MAP(CRTCProvStore)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCProvStore)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)  
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

    HRESULT FinalConstruct();

    void FinalRelease();

// IRTCProvStore
public: 
    STDMETHOD(get_ProvisioningProfile)(BSTR bstrKey, BSTR * pbstrProfileXML);
    STDMETHOD(DeleteProvisioningProfile)(BSTR bstrKey);
    STDMETHOD(SetProvisioningProfile)(BSTR bstrProfileXML);
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
};

#endif //_PROVSTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\rtcobjectsafety.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCObjectSafety.h

Abstract:

    Implements IObjectSafety and IObjectWithSite

  Manages decision logic of whether RTC functionality should be allowed on 
  the current page. Checks persistent settings for this page and prompts with
  a dialog if necessary.

  Objects that need this protection (CRTCClient) derive from this
  class.

--*/

#ifndef __RTCOBJECTSAFETY__
#define __RTCOBJECTSAFETY__

#include "PromptedObjectSafety.h"
#include "ScrpScrtDlg.h"
#include "ObjectWithSite.h"

#define RTC_COOKIE_NAME _T("RTC")


class __declspec(novtable) CRTCObjectSafety : public CPromptedObjectSafety, public CObjectWithSite
{


public:
    
    //
    // call CObjectWithSite's constructor and pass in the cookie name
    //

    CRTCObjectSafety()
        :CObjectWithSite(RTC_COOKIE_NAME)
    {
    }


    //
    // implementing CPromptedObjectSafety's pure virtual method
    // if the page is not in the safe list, and this is the first 
    // time we are asking, prompt the user. act accordingly.
    // if the user chooses, mark the page safe for scripting (persistently)
    //
    
    virtual BOOL Ask()
    {

        //
        // if the object does not have a site pointer. we should not consider 
        // it to be safe. Do not prompt the user
        //

        if ( !HaveSite() )
        {

            return FALSE;
        }


        EnValidation enCurrentValidation = GetValidation();
        
        //
        // if the page has not been validated, try to validate it.
        //

        if (UNVALIDATED == enCurrentValidation)
        {

           CScriptSecurityDialog *pDialog = new CScriptSecurityDialog;
       
           //
           // if succeeded displaying the dialog
           // validate the page based on user's input
           //
           
           if ( NULL != pDialog )
           {

               switch (pDialog->DoModalWithText(IDS_RTC_SEC_PROMPT))
               {

                case ID_YES:

                    Validate(VALIDATED_SAFE);
                    break;

                case ID_NO:

                    Validate(VALIDATED_UNSAFE);
                    break;

                case ID_YES_DONT_ASK_AGAIN:

                    Validate(VALIDATED_SAFE_PERMANENT);
                    break;

                default:

                    break;

               }

               delete pDialog;

                // 
                // get the new validation.
                //

                enCurrentValidation = GetValidation();

           } // if (NULL != pDialog) 

        }

        //
        // by now we either got the validation data or validation did not change
        //
        // return true if the page is validated as safe
        //

        return (VALIDATED_SAFE == enCurrentValidation);
    }

};

#endif // __RTCOBJECTSAFETY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\rtcctl.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCCTL.cpp

Abstract:

    Implementation of DLL exports.

--*/

#include "stdafx.h"
#include "ctlres.h"
#include <initguid.h>

#include "RTCCtl_i.c"

//
// For the ntbuild environment we need to include this file to get the base
//  class implementations.

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
#include "provstore.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_RTCCtl, CRTCCtl)
OBJECT_ENTRY(CLSID_RTCProvStore, CRTCProvStore)
END_OBJECT_MAP()

WCHAR   g_szDllContextHelpFileName[] = L"RTCCTL.HLP";


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        LOGREGISTERDEBUGGER(_T("RTCCTL"));

        LOG((RTC_TRACE, "DllMain - DLL_PROCESS_ATTACH"));

        //
        // Create a heap for memory allocation
        //

        if ( RtcHeapCreate() == FALSE )
        {
            return FALSE;
        }
               
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);       
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        LOG((RTC_TRACE, "DllMain - DLL_PROCESS_DETACH"));
        
#if DBG
        //
        // Make sure we didn't leak anything
        //
             
        RtcDumpMemoryList();
#endif

        //
        // Destroy the heap
        //
        
        RtcHeapDestroy();        

        //
        // Unregister for debug tracing
        //
        
        LOGDEREGISTERDEBUGGER() ;

        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // There are two typelibraries...
    HRESULT hr;

    hr = _Module.RegisterServer(TRUE);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer(TRUE);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\scrpscrtdlg.h ===
// DlgAddr.h : Declaration of the CScriptSecurityDialog

#ifndef __SCRIPTSECURITYDIALOG_H_
#define __SCRIPTSECURITYDIALOG_H_

#include "ctlres.h"

/////////////////////////////////////////////////////////////////////////////
// CScriptSecurityDialog


//
// this class is not thread safe
//

class CScriptSecurityDialog : 
	public CDialogImpl<CScriptSecurityDialog>
{

public:

    CScriptSecurityDialog() : m_psMessageText(NULL)
    {}

    INT_PTR DoModalWithText(UINT uResourceID, HWND hWndParent = ::GetActiveWindow())
    {		
        //
        // this assertion could fail is if the class is used from 
        // a multithreaded app, and domodalX is called on two different threads
        // the class is not thread safe and this should be caught during 
        // testing.
        // another way this assert could fire is if the class itself is
        // broken. this, too, is a test-time error. 
        //
                
        _ASSERTE(NULL == m_psMessageText);

        //
        // load string from resource module
        //

        m_psMessageText = SafeLoadString(uResourceID);


        // 
        // if failed, bail out now
        //

        if (NULL == m_psMessageText)
        {
            return -1;
        }

        
        //
        // attempt to display the dialog box
        // the string is used in OnInitDialog to set the dialog's text
        //
        
        INT_PTR rc = _DoModal(hWndParent);

        //
        // deallocate string
        //

        delete m_psMessageText;
        m_psMessageText = NULL;

        return rc;
    }



    INT_PTR DoModalWithText(LPTSTR psMessageText, HWND hWndParent = ::GetActiveWindow())
    {    	
        //
        // this assertion could fail is if the class is used from 
        // a multithreaded app, and domodalX is called on two different threads
        // the class is not thread safe and this should be caught during 
        // testing.
        // another way this assert could fire is if the class itself is
        // broken. this, too, is a test-time error. 
        //

        _ASSERTE(NULL == m_psMessageText);

        //
        // the dialog is modal, so the lifetime of psMessageText is guaranteed 
        // to exceed the lifetime of the dialog.
        //

        m_psMessageText = psMessageText;

        
        //
        // attempt to display the dialog. the string will be used to set 
        // the message text in OnInitDialog
        // 

        INT_PTR rc = _DoModal(hWndParent);

        //
        // no longer need the string + the string cannot be assumed 
        // valid after we return
        //
        
        m_psMessageText = NULL;
		
        return rc;
    }

	enum { IDD = IDD_RTC_SECURITY_DIALOG };


public:

BEGIN_MSG_MAP(CScriptSecurityDialog)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(ID_YES, OnYes)
	COMMAND_ID_HANDLER(ID_NO, OnNo)
END_MSG_MAP()



//
// Attributes
//

private:

    //
    // the prompt text
    //

    LPTSTR m_psMessageText;
    

protected:

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {   
        //
        // m_psMessageText must be set before _DoModal is called
        // if m_psMessageText is null here, the error is in the class itself
        // and this should be detected during testing
        //

        _ASSERTE(NULL != m_psMessageText);


        //
        // display the text that was passed into DoModalWithText as a string 
        // or a resources
        //

        SetDlgItemText(IDC_SECURITY_WARNING_TEXT, m_psMessageText);

	    return TRUE;
    }

	LRESULT OnYes(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        //
        // see if do not ask in the future is set
        // 
        
        if (IsDlgButtonChecked(IDC_DONOT_PROMPT_IN_THE_FUTURE))
            wID = ID_YES_DONT_ASK_AGAIN;

        EndDialog(wID);
       
        return FALSE;
    }


    LRESULT OnNo(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        
        EndDialog(wID);
        
        return FALSE;
    }

	
private:

    INT_PTR _DoModal(HWND hWndParent)
    {
        
        //
        // otherwise, attempt to display the dialog box
        //

        _ASSERTE(m_hWnd == NULL);
        _Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBase*)this);
        INT_PTR nRet = ::DialogBoxParam(_Module.GetResourceInstance(),
                        MAKEINTRESOURCE(CScriptSecurityDialog::IDD),
                        hWndParent,
                        (DLGPROC)CScriptSecurityDialog::StartDialogProc,
                        NULL);

 
        m_hWnd = NULL;
        return nRet;
    }


private:

    //
    // Load string for this resource. Safe with respect to string size
    //
    
    TCHAR *SafeLoadString( UINT uResourceID )
    {

        TCHAR *pszTempString = NULL;

        int nCurrentSizeInChars = 128;
        
        int nCharsCopied = 0;
        
        do
        {

            if ( NULL != pszTempString )
            {
                delete  pszTempString;
                pszTempString = NULL;
            }

            nCurrentSizeInChars *= 2;

            pszTempString = new TCHAR[ nCurrentSizeInChars ];

            if (NULL == pszTempString)
            {
                return NULL;
            }

            nCharsCopied = ::LoadString( _Module.GetResourceInstance(),
                                         uResourceID,
                                         pszTempString,
                                         nCurrentSizeInChars
                                        );

            if ( 0 == nCharsCopied )
            {
                delete pszTempString;
                return NULL;
            }

            //
            // nCharsCopied does not include the null terminator
            // so compare it to the size of the buffer - 1
            // if the buffer was filled completely, retry with a bigger buffer
            //

        } while ( (nCharsCopied >= (nCurrentSizeInChars - 1) ) );

        return pszTempString;
    }


    //
    // private, not to be called. the dialog must be created with DoModalWithText
    //

    HWND Create(HWND hWndParent, LPCTSTR psMessageText = NULL)
    {
        // this dialog must be created as modal

        _ASSERTE(FALSE);

        return NULL;
    }

    //
    // private, not to be called. the dialog must be created with DoModalWithText
    //

    INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
    {
        _ASSERTE(FALSE);

        return -1;
    }


};

#endif //__SCRIPTSECURITYDIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\axctl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A29A9105_0AC9_4F8B_AF30_ACFE3CB5E7FF__INCLUDED_)
#define AFX_STDAFX_H__A29A9105_0AC9_4F8B_AF30_ACFE3CB5E7FF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#define ATL_TRACE_LEVEL     2 

#define OEMRESOURCE     // setting this gets OIC_ constants in windows.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <atlbase.h>

#include <commctrl.h>
#include <math.h>
#include <wtsapi32.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlhost.h>
#include <atlctl.h>

#include <rtclog.h>
#include <rtcmem.h>
#include <rtcdib.h>

#include <rtcctl.h>
#include <rtcaxctl.h>
#include <rtcerr.h>
#include <rtcutil.h>
#include <ui.h>
#include <rtcuri.h>
#include <im.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A29A9105_0AC9_4F8B_AF30_ACFE3CB5E7FF__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcbuddy.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCBuddy.h

Abstract:

    Definition of the CRTCBuddy class

--*/

#pragma once


/////////////////////////////////////////////////////////////////////////////
// CRTCBuddy

class ATL_NO_VTABLE CRTCBuddy :
#ifdef TEST_IDISPATCH
    public IDispatchImpl<IRTCBuddy, &IID_IRTCBuddy, &LIBID_RTCCORELib>, 
#else
    public IRTCBuddy,
#endif
    public ISipBuddyNotify,
	public CComObjectRoot
{

friend CRTCClient;

public:
    CRTCBuddy() : m_pCClient(NULL),
                  m_pSIPBuddyManager(NULL),
                  m_szPresentityURI(NULL),
                  m_szName(NULL),
                  m_szData(NULL),
                  m_bPersistent(FALSE),
                  m_pSIPBuddy(NULL),
                  m_enStatus(RTCXS_PRESENCE_OFFLINE),
                  m_hrStatusCode(S_OK),
                  m_szNotes(NULL),
                  m_bShutdown(FALSE),
                  m_pSipRedirectContext(NULL),
                  m_pProfile(NULL),
                  m_lFlags(0)
    {}

BEGIN_COM_MAP(CRTCBuddy)
#ifdef TEST_IDISPATCH
    COM_INTERFACE_ENTRY(IDispatch)
#endif
    COM_INTERFACE_ENTRY(IRTCBuddy)
    COM_INTERFACE_ENTRY(IRTCPresenceContact)
    COM_INTERFACE_ENTRY(ISipBuddyNotify)
END_COM_MAP()

    HRESULT FinalConstruct();

    void FinalRelease();

    STDMETHOD_(ULONG, InternalAddRef)();

    STDMETHOD_(ULONG, InternalRelease)(); 

    CRTCClient * GetClient();

    HRESULT Initialize(
                      CRTCClient        * pCClient,
                      ISIPBuddyManager  * pSIPBuddyManager,
                      PCWSTR              szPresentityURI,
                      PCWSTR              szName,
                      PCWSTR              szData,
                      BOOL                bPersistent,
                      IRTCProfile       * pProfile,
                      long                lFlags
                      );

    HRESULT CreateSIPBuddy();

    HRESULT RemoveSIPBuddy(BOOL bShutdown);

    HRESULT CreateXMLDOMNode( IXMLDOMDocument * pXMLDoc, IXMLDOMNode ** ppXDN );
    
    HRESULT CreateSIPBuddyHelper();

    HRESULT BuddyResub();
          
private:

    CRTCClient            * m_pCClient;
    ISIPBuddyManager      * m_pSIPBuddyManager;
    PWSTR                   m_szPresentityURI;
    PWSTR                   m_szName;
    ISIPBuddy             * m_pSIPBuddy;
    RTC_PRESENCE_STATUS     m_enStatus;
    HRESULT                 m_hrStatusCode;
    PWSTR                   m_szNotes;
    PWSTR                   m_szData;
    BOOL                    m_bPersistent;
    BOOL                    m_bShutdown;
    ISipRedirectContext   * m_pSipRedirectContext;
    IRTCProfile           * m_pProfile;
    long                    m_lFlags;
 
#if DBG
    PWSTR                   m_pDebug;
#endif

// IRTCBuddy
public:

    STDMETHOD(get_PresentityURI)(
            BSTR * pbstrPresentityURI
            );   

    STDMETHOD(put_PresentityURI)(
            BSTR bstrPresentityURI
            );  

    STDMETHOD(get_Name)(
            BSTR * pbstrName
            );

    STDMETHOD(put_Name)(
            BSTR bstrName
            );

    STDMETHOD(get_Data)(
            BSTR * pbstrData
            );

    STDMETHOD(put_Data)(
            BSTR bstrData
            );
	
    STDMETHOD(get_Persistent)(
            VARIANT_BOOL *pfPersistent
            );                 
	
    STDMETHOD(put_Persistent)(
            VARIANT_BOOL fPersistent
            );                 

    STDMETHOD(get_Status)(
            RTC_PRESENCE_STATUS * penStatus
            );

    STDMETHOD(get_Notes)(
            BSTR * pbstrNotes
            );                
    
    
// ISipBuddyNotify

    STDMETHOD(NotifyRedirect)(
        IN  ISipRedirectContext    *pRedirectContext,
        IN  SIP_CALL_STATUS        *pCallStatus
        );

    STDMETHOD(BuddyUnsubscribed)(void);
    
    STDMETHOD(BuddyInfoChange)(void);

    STDMETHOD(BuddyRejected)(
            HRESULT   StatusCode
            );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcbuddy.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCBuddy.cpp

Abstract:

    Definition of the CRTCBuddy class

--*/
#include "stdafx.h"


/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::FinalConstruct
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCBuddy::FinalConstruct()
{
    LOG((RTC_TRACE, "CRTCBuddy::FinalConstruct [%p] - enter", this));

#if DBG
    m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)m_pDebug) = this;
#endif

    LOG((RTC_TRACE, "CRTCBuddy::FinalConstruct [%p] - exit S_OK", this));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCBuddy::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCBuddy::FinalRelease [%p] - enter", this));

    RemoveSIPBuddy(FALSE);

    if ( m_pCClient != NULL )
    {
        m_pCClient->Release();
        m_pCClient = NULL;
    }

    if ( m_pSIPBuddyManager != NULL )
    {
        m_pSIPBuddyManager->Release();
        m_pSIPBuddyManager = NULL;
    }

    if ( m_pProfile != NULL )
    {
        m_pProfile->Release();
        m_pProfile = NULL;
    }

    if ( m_szName != NULL )
    {
        RtcFree(m_szName);
        m_szName = NULL;
    }
    
    if ( m_szData != NULL )
    {
        RtcFree(m_szData);
        m_szData = NULL;
    }

    if ( m_szPresentityURI != NULL )
    {
        RtcFree(m_szPresentityURI);
        m_szPresentityURI = NULL;
    }

    if ( m_szNotes != NULL )
    {
        RtcFree(m_szNotes);
        m_szNotes = NULL;
    }

    if ( m_pSipRedirectContext != NULL )
    {
        m_pSipRedirectContext->Release();
        m_pSipRedirectContext = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCBuddy::FinalRelease [%p] - exit", this));
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::InternalAddRef
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCBuddy::InternalAddRef()
{
    DWORD dwR;

    dwR = InterlockedIncrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCBuddy::InternalAddRef [%p] - dwR %d", this, dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::InternalRelease
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCBuddy::InternalRelease()
{
    DWORD               dwR;
    
    dwR = InterlockedDecrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCBuddy::InternalRelease [%p] - dwR %d", this, dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::Initialize
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCBuddy::Initialize(
                        CRTCClient       * pCClient,      
                        ISIPBuddyManager * pSIPBuddyManager,
                        PCWSTR             szPresentityURI,
                        PCWSTR             szName,
                        PCWSTR             szData,
                        BOOL               bPersistent,
                        IRTCProfile      * pProfile,
                        long               lFlags
                        )
{
    LOG((RTC_TRACE, "CRTCBuddy::Initialize - enter"));

    HRESULT hr;

    if ( IsBadReadPtr( pCClient, sizeof(CRTCClient) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::Initialize - "
                            "bad CRTCClient pointer"));

        return E_POINTER;
    }

    if ( IsBadReadPtr( pSIPBuddyManager, sizeof(ISIPBuddyManager) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::Initialize - "
                            "bad ISIPBuddyManager pointer"));

        return E_POINTER;
    }

    m_szPresentityURI = RtcAllocString(szPresentityURI);
    m_szName = RtcAllocString(szName);
    m_szData = RtcAllocString(szData);

    m_bPersistent = bPersistent;

    m_pCClient = pCClient;
    if ( m_pCClient )
    {
        m_pCClient->AddRef();
    }

    m_pSIPBuddyManager = pSIPBuddyManager;
    if ( m_pSIPBuddyManager )
    {
        m_pSIPBuddyManager->AddRef();
    }

    m_pProfile = pProfile;
    if ( m_pProfile )
    {
        m_pProfile->AddRef();
    }

    m_lFlags = lFlags;

    hr = CreateSIPBuddy();

    if ( FAILED(hr) )
    {
        LOG((RTC_WARN, "CRTCBuddy::Initialize - "
                        "CreateSIPBuddy failed 0x%lx", hr));
    }        

    LOG((RTC_TRACE, "CRTCBuddy::Initialize - exit S_OK"));

    return S_OK;
} 


/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::CreateSIPBuddy
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCBuddy::CreateSIPBuddy()
{
    LOG((RTC_TRACE, "CRTCBuddy::CreateSIPBuddy - enter"));

    HRESULT     hr;

    // reset the cached error
    m_hrStatusCode = S_OK;
    
    hr = CreateSIPBuddyHelper();

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCBuddy::CreateSIPBuddy - "
                            "CreateSIPBuddyHelper failed 0x%lx", hr));
        // we have an "event"...
        m_hrStatusCode = hr;

        CRTCBuddyEvent::FireEvent( m_pCClient, this );
    }
    
    LOG((RTC_TRACE, "CRTCBuddy::CreateSIPBuddy - exit"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::CreateSIPBuddyHelper
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCBuddy::CreateSIPBuddyHelper()
{
    LOG((RTC_TRACE, "CRTCBuddy::CreateSIPBuddyHelper - enter"));

    HRESULT hr;
    
    BSTR bstrLocalUserName = NULL;
    BSTR bstrLocalUserURI = NULL;   

    //
    // Choose the best profile if needed
    //

    if ( !(m_lFlags & RTCCS_FORCE_PROFILE) )
    {
        IRTCProfile * pProfile = NULL;
        RTC_SESSION_TYPE enType = RTCST_PC_TO_PC;

        hr = m_pCClient->GetBestProfile(
                &enType,
                m_szPresentityURI,
                (m_pSipRedirectContext != NULL),
                &pProfile
                );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSIPBuddyHelper - "
                                "GetBestProfile failed 0x%lx", hr));

            return hr;
        }

        if ( m_pProfile != NULL )
        {
            m_pProfile->Release();
            m_pProfile = NULL;
        }

        m_pProfile = pProfile;
    }

    LOG((RTC_INFO, "CRTCSession::CreateSIPBuddyHelper - "
                                "profile [%p]", m_pProfile));

    //
    // Get profile info
    //

    SIP_PROVIDER_ID ProviderID = GUID_NULL;
    SIP_SERVER_INFO Proxy;            
    CRTCProfile * pCProfile = NULL;

    if ( m_pProfile != NULL )
    {
        //
        // Get pointer to profile object
        //

        pCProfile = static_cast<CRTCProfile *>(m_pProfile);  

        //
        // Get the SIP provider ID from the profile. If the profile is NULL
        // then this call has no provider. In that case we just use GUID_NULL.
        //

        pCProfile->GetGuid( &ProviderID );
        
        //
        // Determine supported session types for this profile
        //

        long lSupportedSessions;

        hr = m_pProfile->get_SessionCapabilities( &lSupportedSessions );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCBuddy::CreateSIPBuddyHelper - "
                                "get_SessionCapabilities failed 0x%lx", hr));           

            return hr;
        }

        //
        // Validate session type
        //

        if ( !(RTCSI_PC_TO_PC & lSupportedSessions) )
        {
            LOG((RTC_ERROR, "CRTCBuddy::CreateSIPBuddyHelper - "
                                "session type is not supported by this profile"));

            return E_FAIL;
        }              
    }

    //
    // Get local user name
    // 
    
    if ( m_pProfile != NULL )
    { 
        hr = m_pProfile->get_UserName( &bstrLocalUserName );

        if ( FAILED(hr) )
        {
            LOG((RTC_WARN, "CRTCBuddy::CreateSIPBuddyHelper - "
                                "get_UserName failed 0x%lx", hr));
        }
    }

    if ( (m_pProfile == NULL) || FAILED(hr) ) 
    {
        hr = m_pCClient->get_LocalUserName( &bstrLocalUserName );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCBuddy::CreateSIPBuddyHelper - "
                                "get_LocalUserName failed 0x%lx", hr));

            return hr;
        }
    }

    //
    // Get local user URI
    //

    if ( m_pProfile != NULL )
    { 
        hr = m_pProfile->get_UserURI( &bstrLocalUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCBuddy::CreateSIPBuddyHelper - "
                                "get_UserURI failed 0x%lx", hr));
            
            SysFreeString( bstrLocalUserName );
            bstrLocalUserName = NULL;

            return hr;
        }
    }
    else
    {
        hr = m_pCClient->get_LocalUserURI( &bstrLocalUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCBuddy::CreateSIPBuddyHelper - "
                                "get_LocalUserURI failed 0x%lx", hr));
           
            SysFreeString( bstrLocalUserName );
            bstrLocalUserName = NULL;

            return hr;
        }
    }

    //
    // Get SIP proxy info
    //

    if ( pCProfile != NULL )
    {        
        hr = pCProfile->GetSipProxyServerInfo( RTCSI_PC_TO_PC, &Proxy );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "GetSipProxyServerInfo failed 0x%lx", hr));

            SysFreeString( bstrLocalUserName );
            bstrLocalUserName = NULL;

            SysFreeString( bstrLocalUserURI );
            bstrLocalUserURI = NULL;

            return hr;
        } 
    }

    //
    // Is this a redirect?
    //

    BSTR bstrRedirectURI = NULL;
    BSTR bstrRedirectName = NULL;

    if ( m_pSipRedirectContext != NULL )
    {
        LOG((RTC_INFO, "CRTCSession::CreateSipSession - "
                                "redirecting buddy"));

        hr = m_pSipRedirectContext->Advance();

        if ( hr != S_OK )
        {
            if ( hr == S_FALSE )
            {
                LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                    "redirect list empty"));
            }
            else
            {
                LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                    "Advance failed 0x%lx", hr));
            }

            SysFreeString( bstrLocalUserName );
            bstrLocalUserName = NULL;

            SysFreeString( bstrLocalUserURI );
            bstrLocalUserURI = NULL;

            return hr;
        } 

        hr = m_pSipRedirectContext->GetSipUrlAndDisplayName( &bstrRedirectURI, &bstrRedirectName );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "GetSipUrlAndDisplayName failed 0x%lx", hr));

            SysFreeString( bstrLocalUserName );
            bstrLocalUserName = NULL;

            SysFreeString( bstrLocalUserURI );
            bstrLocalUserURI = NULL;

            return hr;
        }
    }

    //
    // Create a SIP buddy
    //

    ISIPBuddy * pSIPBuddy = NULL;

    hr = m_pSIPBuddyManager->AddBuddy(
            bstrLocalUserName,
            bstrRedirectURI ? bstrRedirectURI : m_szPresentityURI,
            bstrLocalUserURI,
            &ProviderID,
            (pCProfile != NULL) ? &Proxy : NULL,
            m_pSipRedirectContext,
            &pSIPBuddy );

    SysFreeString( bstrRedirectURI );
    bstrRedirectURI = NULL;

    SysFreeString( bstrRedirectName );
    bstrRedirectName = NULL;

    SysFreeString( bstrLocalUserName );
    bstrLocalUserName = NULL;

    SysFreeString( bstrLocalUserURI );
    bstrLocalUserURI = NULL;

    if (pCProfile != NULL)
    {
        pCProfile->FreeSipServerInfo( &Proxy );
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::CreateSIPBuddyHelper - AddBuddy failed 0x%lx", hr));

        return hr;
    }

    //
    // Set the notify interface
    //

    hr = pSIPBuddy->SetNotifyInterface(this);

    if ( FAILED(hr) )
    {        
        LOG((RTC_ERROR, "CRTCBuddy::CreateSIPBuddyHelper - "
                        "SetNotifyInterface failed 0x%lx", hr));

        pSIPBuddy->Release();

        return hr;
    }    

    //
    // Free the old buddy if it exists
    //

    if ( m_pSIPBuddy != NULL )
    {
        RemoveSIPBuddy(FALSE);
    }

    //
    // Store the new buddy
    //

    m_pSIPBuddy = pSIPBuddy;
    m_enStatus = RTCXS_PRESENCE_OFFLINE;

    if ( m_szNotes != NULL )
    {
        RtcFree( m_szNotes );
        m_szNotes = NULL;
    }

    LOG((RTC_TRACE, "CRTCBuddy::CreateSIPBuddyHelper - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::RemoveSIPBuddy
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCBuddy::RemoveSIPBuddy(BOOL bShutdown)
{
    LOG((RTC_TRACE, "CRTCBuddy::RemoveSIPBuddy - enter"));

    HRESULT hr; 

    if ( m_pSIPBuddy != NULL )
    {       
        hr = m_pSIPBuddyManager->RemoveBuddy(
                m_pSIPBuddy,
                bShutdown ? APPLICATION_SHUTDOWN : BUDDY_REMOVED_BYUSER);

        if ( FAILED(hr) )
        {        
            LOG((RTC_ERROR, "CRTCBuddy::RemoveSIPBuddy - "
                            "RemoveBuddy failed 0x%lx", hr));
        }
        
        //
        // If this is not for shutdown, release the SIP buddy now
        //

        if (!bShutdown)
        {
            hr = m_pSIPBuddy->SetNotifyInterface(NULL);

            if ( FAILED(hr) )
            {        
                LOG((RTC_ERROR, "CRTCBuddy::RemoveSIPBuddy - "
                                "SetNotifyInterface failed 0x%lx", hr));
            }

            m_pSIPBuddy->Release();
            m_pSIPBuddy = NULL;
        }
    }

    m_bShutdown = bShutdown;

    LOG((RTC_TRACE, "CRTCBuddy::RemoveSIPBuddy - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::CreateXMLDOMNode
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCBuddy::CreateXMLDOMNode( IXMLDOMDocument * pXMLDoc, IXMLDOMNode ** ppXDN )
{
    IXMLDOMNode    * pBuddyInfo = NULL;
    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCBuddy::CreateXMLDOMNode - enter"));

    hr = pXMLDoc->createNode( CComVariant(NODE_ELEMENT), CComBSTR(_T("BuddyInfo")), NULL, &pBuddyInfo );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::CreateXMLDOMNode - "
                        "createNode failed 0x%lx", hr));

        return hr;
    }
    
    hr = pBuddyInfo->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::CreateXMLDOMNode - "
                        "QueryInterface failed 0x%lx", hr));

        pBuddyInfo->Release();

        return hr;
    }

    if (m_szPresentityURI != NULL)
    {
        hr = pElement->setAttribute( CComBSTR(_T("Presentity")), CComVariant( m_szPresentityURI ) );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCBuddy::CreateXMLDOMNode - "
                        "setAttribute(Presentity) failed 0x%lx", hr));

            pElement->Release();
            pBuddyInfo->Release();

            return hr;
        }
    }

    if (m_szName != NULL)
    {
        hr = pElement->setAttribute( CComBSTR(_T("Name")), CComVariant( m_szName ) );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCBuddy::CreateXMLDOMNode - "
                        "setAttribute(Name) failed 0x%lx", hr));

            pElement->Release();
            pBuddyInfo->Release();

            return hr;
        }
    }

    if (m_szData != NULL)
    {
        hr = pElement->setAttribute( CComBSTR(_T("Data")), CComVariant( m_szData ) );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCBuddy::CreateXMLDOMNode - "
                        "setAttribute(Data) failed 0x%lx", hr));

            pElement->Release();
            pBuddyInfo->Release();

            return hr;
        }
    }

    pElement->Release();

    *ppXDN = pBuddyInfo;

    LOG((RTC_TRACE, "CRTCBuddy::CreateXMLDOMNode - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::GetClient
//
/////////////////////////////////////////////////////////////////////////////

CRTCClient * 
CRTCBuddy::GetClient()
{
    LOG((RTC_TRACE, "CRTCBuddy::GetClient"));

    return m_pCClient;
} 


/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::get_PresentityURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::get_PresentityURI(
        BSTR * pbstrPresentityURI
        )
{
    LOG((RTC_TRACE, "CRTCBuddy::get_PresentityURI - enter"));

    if ( IsBadWritePtr( pbstrPresentityURI, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_PresentityURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szPresentityURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_PresentityURI - "
                            "buddy has no address"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrPresentityURI = SysAllocString(m_szPresentityURI);

    if ( *pbstrPresentityURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_PresentityURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCBuddy::get_PresentityURI - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::put_PresentityURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::put_PresentityURI(
        BSTR bstrPresentityURI
        )
{
    LOG((RTC_TRACE, "CRTCBuddy::put_PresentityURI - enter"));

    HRESULT hr;

    if ( IsBadStringPtrW( bstrPresentityURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::put_PresentityURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    //
    // Clean the presentity URI
    //

    PWSTR szCleanPresentityURI = NULL;

    AllocCleanSipString( bstrPresentityURI, &szCleanPresentityURI );

    if ( szCleanPresentityURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::put_PresentityURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    //
    // Is this different than the existing presentity URI?
    //

    if ( !IsEqualURI( m_szPresentityURI, szCleanPresentityURI ) )
    {
        //
        // Don't allow duplicates
        //

        IRTCBuddy *pBuddy = NULL;

        hr = m_pCClient->FindBuddyByURI(
            szCleanPresentityURI,
            &pBuddy);

        if (hr == S_OK)
        {
            RtcFree( szCleanPresentityURI );
            szCleanPresentityURI = NULL;

            pBuddy->Release();
            pBuddy = NULL;
        
            LOG((RTC_ERROR, "CRTCBuddy::put_PresentityURI - "
                                "duplicate buddy"));

            return E_FAIL;
        }

        //
        // Recreate the SIP buddy
        //

        PWSTR szOldPresentityURI = m_szPresentityURI;
      
        m_szPresentityURI = szCleanPresentityURI;    
        szCleanPresentityURI = NULL;
        
        hr = CreateSIPBuddy();

        if ( FAILED(hr) )
        {
            LOG((RTC_WARN, "CRTCBuddy::put_PresentityURI - CreateSIPBuddy failed 0x%lx", hr));
        }

        if ( szOldPresentityURI != NULL )
        {
            RtcFree( szOldPresentityURI );
            szOldPresentityURI = NULL;
        }

        //
        // Update storage
        //

        if ( m_bPersistent )
        {
            m_pCClient->UpdatePresenceStorage();
        }
    }
    else
    {
        RtcFree( szCleanPresentityURI );
        szCleanPresentityURI = NULL;
    }
    
    LOG((RTC_TRACE, "CRTCBuddy::put_PresentityURI - exit S_OK"));

    return S_OK;
}              

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::get_Name
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::get_Name(
        BSTR * pbstrName
        )
{
    LOG((RTC_TRACE, "CRTCBuddy::get_Name - enter"));

    if ( IsBadWritePtr( pbstrName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Name - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Name - "
                            "buddy has no name"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrName = SysAllocString(m_szName);

    if ( *pbstrName == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Name - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCBuddy::get_Name - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::put_Name
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::put_Name(
        BSTR bstrName
        )
{
    LOG((RTC_TRACE, "CRTCBuddy::put_Name - enter"));

    if ( IsBadStringPtrW( bstrName, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::put_Name - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szName != NULL )
    {
        RtcFree( m_szName );
        m_szName = NULL;
    }

    m_szName = RtcAllocString( bstrName );    

    if ( m_szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::put_Name - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    } 
    
    //
    // Update storage
    //

    if ( m_bPersistent )
    {
        m_pCClient->UpdatePresenceStorage();
    }
    
    LOG((RTC_TRACE, "CRTCBuddy::put_Name - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::get_Data
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::get_Data(
        BSTR * pbstrData
        )
{
    LOG((RTC_TRACE, "CRTCBuddy::get_Data - enter"));

    if ( IsBadWritePtr( pbstrData, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Data - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szData == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Data - "
                            "buddy has no guid string"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrData = SysAllocString(m_szData);

    if ( *pbstrData == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Data - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCBuddy::get_Data - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::put_Data
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::put_Data(
        BSTR bstrData
        )
{
    LOG((RTC_TRACE, "CRTCBuddy::put_Data - enter"));

    if ( IsBadStringPtrW( bstrData, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::put_Data - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szData != NULL )
    {
        RtcFree( m_szData );
        m_szData = NULL;
    }

    m_szData = RtcAllocString( bstrData );    

    if ( m_szData == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::put_Data - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }  
    
    //
    // Update storage
    //

    if ( m_bPersistent )
    {
        m_pCClient->UpdatePresenceStorage();
    }
    
    LOG((RTC_TRACE, "CRTCBuddy::put_Data - exit S_OK"));

    return S_OK;
}      

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::get_Persistent
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::get_Persistent(
            VARIANT_BOOL * pfPersistent
            )
{
    LOG((RTC_TRACE, "CRTCBuddy::get_Persistent - enter"));

    if ( IsBadWritePtr( pfPersistent, sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::pfPersistent - "
                            "bad pointer"));

        return E_POINTER;
    }

    *pfPersistent = m_bPersistent ? VARIANT_TRUE : VARIANT_FALSE;

    LOG((RTC_TRACE, "CRTCBuddy::get_Persistent - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::put_Persistent
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::put_Persistent(
            VARIANT_BOOL fPersistent
            )
{
    LOG((RTC_TRACE, "CRTCBuddy::put_Persistent - enter"));

    m_bPersistent = fPersistent ? TRUE : FALSE;

    //
    // Update storage
    //

    m_pCClient->UpdatePresenceStorage();

    LOG((RTC_TRACE, "CRTCBuddy::put_Persistent - exit"));

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::get_Status
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::get_Status(
            RTC_PRESENCE_STATUS * penStatus
            )
{
    LOG((RTC_TRACE, "CRTCBuddy::get_Status - enter"));

    if ( IsBadWritePtr( penStatus, sizeof(RTC_PRESENCE_STATUS) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Status - "
                            "bad pointer"));

        return E_POINTER;
    }

    // return error if presence info couldn't be found
    if(FAILED(m_hrStatusCode))
    {
        LOG((RTC_TRACE, "CRTCBuddy::get_Status - returning cached error code"));
        
        return m_hrStatusCode;
    }

    *penStatus = m_enStatus;

    LOG((RTC_TRACE, "CRTCBuddy::get_Status - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::get_Notes
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::get_Notes(
        BSTR * pbstrNotes
        )
{
    LOG((RTC_TRACE, "CRTCBuddy::get_Notes - enter"));

    if ( IsBadWritePtr( pbstrNotes, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Notes - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    // return error if presence info couldn't be found
    if(FAILED(m_hrStatusCode))
    {
        LOG((RTC_TRACE, "CRTCBuddy::get_Notes - returning cached error code"));
        
        return m_hrStatusCode;
    }

    if ( m_szNotes == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Notes - "
                            "buddy has no notes"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrNotes = SysAllocString(m_szNotes);

    if ( *pbstrNotes == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Notes - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCBuddy::get_Notes - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::NotifyRedirect
//
/////////////////////////////////////////////////////////////////////////////  
STDMETHODIMP
CRTCBuddy::NotifyRedirect(
        IN  ISipRedirectContext    *pRedirectContext,
        IN  SIP_CALL_STATUS        *pCallStatus
        )
{
    LOG((RTC_TRACE, "CRTCBuddy::NotifyRedirect - enter"));

    HRESULT hr;

    //
    // Save the redirect context
    //

    if ( m_pSipRedirectContext != NULL )
    {
        m_pSipRedirectContext->Release();
        m_pSipRedirectContext = NULL;
    }

    m_pSipRedirectContext = pRedirectContext;
    m_pSipRedirectContext->AddRef();

    //
    // Free the old buddy if it exists
    //

    if ( m_pSIPBuddy != NULL )
    {
        RemoveSIPBuddy(FALSE);
    }

    //
    // Recreate the SIP buddy
    //

    hr = CreateSIPBuddy();

    m_pSipRedirectContext->Release();
    m_pSipRedirectContext = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::NotifyRedirect - CreateSIPBuddy failed 0x%lx", hr));

        return hr;
    }
    
    LOG((RTC_TRACE, "CRTCBuddy::NotifyRedirect - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::BuddyUnsubscribed
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCBuddy::BuddyUnsubscribed(void)
{
    LOG((RTC_TRACE, "CRTCBuddy::BuddyUnsubscribed - enter"));

    HRESULT hr;

    m_enStatus = RTCXS_PRESENCE_OFFLINE;

    if ( m_szNotes != NULL )
    {
        RtcFree( m_szNotes );
        m_szNotes = NULL;
    }

    if ( m_bShutdown )
    {
        //
        // This is a SIP buddy the was recently removed for shutdown. We have
        // just been notified that the UNSUB was completed. Release the
        // SIP buddy now.
        //

        hr = m_pSIPBuddy->SetNotifyInterface(NULL);

        if ( FAILED(hr) )
        {        
            LOG((RTC_ERROR, "CRTCBuddy::BuddyUnsubscribed - "
                            "SetNotifyInterface failed 0x%lx", hr));
        }

        m_pSIPBuddy->Release();
        m_pSIPBuddy = NULL;
    }

    //
    // Notify the core
    //

    AddRef();

    PostMessage( m_pCClient->GetWindow(), WM_BUDDY_UNSUB, (WPARAM)this, (LPARAM)m_bShutdown );

    LOG((RTC_TRACE, "CRTCBuddy::BuddyUnsubscribed - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::BuddyResub
//
/////////////////////////////////////////////////////////////////////////////
HRESULT
CRTCBuddy::BuddyResub()
{
    LOG((RTC_TRACE, "CRTCBuddy::BuddyResub - enter"));

    //
    // The SIP watcher on the other side has sent us an UNSUB. We must
    // recreate our SIP buddy to send another SUB request.
    //

    m_enStatus = RTCXS_PRESENCE_OFFLINE;
    m_hrStatusCode = S_OK;

    CRTCBuddyEvent::FireEvent( m_pCClient, this );

    //
    // Free the old buddy if it exists
    //

    if ( m_pSIPBuddy != NULL )
    {
        RemoveSIPBuddy(FALSE);
    }

    //
    // Recreate the SIP buddy
    //

    HRESULT hr;

    hr = CreateSIPBuddy();

    if ( FAILED(hr) )
    {
        LOG((RTC_WARN, "CRTCBuddy::BuddyResub - CreateSIPBuddy failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCBuddy::BuddyResub - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::BuddyRejected
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCBuddy::BuddyRejected(
    HRESULT   StatusCode
    )
{
    LOG((RTC_TRACE, "CRTCBuddy::BuddyRejected - enter"));

    m_enStatus = RTCXS_PRESENCE_OFFLINE;
    m_hrStatusCode = StatusCode;

    if ( m_szNotes != NULL )
    {
        RtcFree( m_szNotes );
        m_szNotes = NULL;
    }

    CRTCBuddyEvent::FireEvent( m_pCClient, this );

    LOG((RTC_TRACE, "CRTCBuddy::BuddyRejected - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::BuddyInfoChange
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCBuddy::BuddyInfoChange(void)
{
    LOG((RTC_TRACE, "CRTCBuddy::BuddyInfoChange - enter"));

    if ( m_pSIPBuddy != NULL )
    {
        SIP_PRESENCE_INFO PresenceInfo;

        m_pSIPBuddy->GetPresenceInformation( &PresenceInfo );

        //
        // Get the status
        //

        if ( PresenceInfo.presenceStatus == BUDDY_ONLINE )
        {
            // try the MSN substatus frst
            if(PresenceInfo.activeMsnSubstatus != MSN_SUBSTATUS_UNKNOWN)
            {
                switch ( PresenceInfo.activeMsnSubstatus )
                {
                case MSN_SUBSTATUS_ONLINE:
                    m_enStatus = RTCXS_PRESENCE_ONLINE;
                    break;

                case MSN_SUBSTATUS_AWAY:
                    m_enStatus = RTCXS_PRESENCE_AWAY;
                    break;

                case MSN_SUBSTATUS_IDLE:
                    m_enStatus = RTCXS_PRESENCE_IDLE;
                    break;

                case MSN_SUBSTATUS_BUSY:
                    m_enStatus = RTCXS_PRESENCE_BUSY;
                    break;

                case MSN_SUBSTATUS_BE_RIGHT_BACK:
                    m_enStatus = RTCXS_PRESENCE_BE_RIGHT_BACK;
                    break;

                case MSN_SUBSTATUS_ON_THE_PHONE:
                    m_enStatus = RTCXS_PRESENCE_ON_THE_PHONE;
                    break;

                case MSN_SUBSTATUS_OUT_TO_LUNCH:
                    m_enStatus = RTCXS_PRESENCE_OUT_TO_LUNCH;
                    break;

                default:
                    m_enStatus = RTCXS_PRESENCE_ONLINE;
                    break;
                }
            }
            else
            {
                switch ( PresenceInfo.activeStatus )
                {
                case ACTIVE_STATUS_UNKNOWN:
                    m_enStatus = RTCXS_PRESENCE_ONLINE;
                    break;

                case DEVICE_ACTIVE:
                    m_enStatus = RTCXS_PRESENCE_ONLINE;
                    break;

                case DEVICE_INACTIVE:
                    m_enStatus = RTCXS_PRESENCE_AWAY;
                    break;

                case DEVICE_INUSE:
                    m_enStatus = RTCXS_PRESENCE_BUSY;
                    break;
                }
            }
        }
        else
        {
            m_enStatus = RTCXS_PRESENCE_OFFLINE;
        }

        //
        // Get the notes
        //

        if ( m_szNotes != NULL )
        {
            RtcFree( m_szNotes );
            m_szNotes = NULL;
        }

        if ( PresenceInfo.pstrSpecialNote[0] != 0 )
        {
            int iSize = MultiByteToWideChar(
                            CP_UTF8, 0, PresenceInfo.pstrSpecialNote, -1,
                            NULL, 0);

            if ( iSize > 0 )
            {
                m_szNotes = (LPWSTR)RtcAlloc(iSize * sizeof(WCHAR));

                if ( m_szNotes != NULL )
                {
                    iSize = MultiByteToWideChar(
                                CP_UTF8, 0, PresenceInfo.pstrSpecialNote, -1,
                                m_szNotes, iSize);

                    if ( iSize == 0 )
                    {
                        RtcFree( m_szNotes );
                        m_szNotes = NULL;
                    }
                }
            }
        }
    }
    
    m_hrStatusCode = S_OK;

    CRTCBuddyEvent::FireEvent( m_pCClient, this );

    LOG((RTC_TRACE, "CRTCBuddy::BuddyInfoChange - exit"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcevents.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCEvents.h

Abstract:

    Definition of the event classes

--*/

#ifndef __RTCEVENTS__
#define __RTCEVENTS__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "dllres.h"

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClientEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCClientEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCClientEvent, &IID_IRTCClientEvent, &LIBID_RTCCORELib>
{
public:
    CRTCClientEvent() {}
BEGIN_COM_MAP(CRTCClientEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCClientEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCClient * pCClient,                            
                             RTC_CLIENT_EVENT_TYPE enEventType
                            );

    void FinalRelease();

protected:

    RTC_CLIENT_EVENT_TYPE m_enEventType; 
    IRTCClient          * m_pClient;

#if DBG
    PWSTR               m_pDebug;
#endif

// IRTCClientEvent
public:

    STDMETHOD(get_EventType)(
                           RTC_CLIENT_EVENT_TYPE * penEventType
                          );

    STDMETHOD(get_Client)(
                           IRTCClient ** ppClient
                          );
};

/////////////////////////////////////////////////////////////////////////////
//
// CRTCRegistrationStateChangeEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCRegistrationStateChangeEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCRegistrationStateChangeEvent, &IID_IRTCRegistrationStateChangeEvent, &LIBID_RTCCORELib>
{
public:
    CRTCRegistrationStateChangeEvent() {}
BEGIN_COM_MAP(CRTCRegistrationStateChangeEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCRegistrationStateChangeEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCClient * pCClient,
                             CRTCProfile * pCProfile,
                             RTC_REGISTRATION_STATE enState,
                             long lStatusCode,
                             PCWSTR szStatusText
                            );

    void FinalRelease();

protected:

    IRTCProfile       * m_pProfile;
    RTC_REGISTRATION_STATE m_enState; 
    long                m_lStatusCode;
    PWSTR               m_szStatusText;

#if DBG
    PWSTR               m_pDebug;
#endif

// IRTCRegistrationStateChangeEvent
public:

    STDMETHOD(get_Profile)(
                           IRTCProfile ** ppProfile
                          );
        
    STDMETHOD(get_State)(
                         RTC_REGISTRATION_STATE * penState
                        );

    STDMETHOD(get_StatusCode)(
                              long * plStatusCode
                             );   
    
    STDMETHOD(get_StatusText)(
                              BSTR * pbstrStatusText
                             );  
};

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionStateChangeEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCSessionStateChangeEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCSessionStateChangeEvent, &IID_IRTCSessionStateChangeEvent, &LIBID_RTCCORELib>
{
public:
    CRTCSessionStateChangeEvent() {}
BEGIN_COM_MAP(CRTCSessionStateChangeEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCSessionStateChangeEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCSession * pCSession,
                             RTC_SESSION_STATE enState,
                             long lStatusCode,
                             PCWSTR szStatusText
                            );

    void FinalRelease();

protected:

    IRTCSession       * m_pSession;
    RTC_SESSION_STATE   m_enState; 
    long                m_lStatusCode;
    PWSTR               m_szStatusText;

#if DBG
    PWSTR               m_pDebug;
#endif

// IRTCSessionStateChangeEvent
public:

    STDMETHOD(get_Session)(
                           IRTCSession ** ppSession
                          );
        
    STDMETHOD(get_State)(
                         RTC_SESSION_STATE * penState
                        );

    STDMETHOD(get_StatusCode)(
                              long * plStatusCode
                             );   
    
    STDMETHOD(get_StatusText)(
                              BSTR * pbstrStatusText
                             );  
};

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionOperationCompleteEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCSessionOperationCompleteEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCSessionOperationCompleteEvent, &IID_IRTCSessionOperationCompleteEvent, &LIBID_RTCCORELib>
{
public:
    CRTCSessionOperationCompleteEvent() {}
BEGIN_COM_MAP(CRTCSessionOperationCompleteEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCSessionOperationCompleteEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCSession * pCSession,
                             long lCookie,
                             long lStatusCode,
                             PCWSTR szStatusText
                            );

    void FinalRelease();

protected:

    IRTCSession       * m_pSession;
    long                m_lCookie; 
    long                m_lStatusCode;
    PWSTR               m_szStatusText;

#if DBG
    PWSTR               m_pDebug;
#endif

// IRTCSessionOperationCompleteEvent
public:

    STDMETHOD(get_Session)(
                           IRTCSession ** ppSession
                          );
        
    STDMETHOD(get_Cookie)(
                         long * plCookie
                        );

    STDMETHOD(get_StatusCode)(
                              long * plStatusCode
                             );   
    
    STDMETHOD(get_StatusText)(
                              BSTR * pbstrStatusText
                             );  
};

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipantStateChangeEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCParticipantStateChangeEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCParticipantStateChangeEvent, &IID_IRTCParticipantStateChangeEvent, &LIBID_RTCCORELib>
{
public:
    CRTCParticipantStateChangeEvent() {}
BEGIN_COM_MAP(CRTCParticipantStateChangeEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCParticipantStateChangeEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCParticipant * pCParticipant,
                             RTC_PARTICIPANT_STATE enState,
                             long lStatusCode
                            );

    void FinalRelease();

protected:

    IRTCParticipant   * m_pParticipant;
    RTC_PARTICIPANT_STATE   m_enState; 
    long                m_lStatusCode;

#if DBG
    PWSTR               m_pDebug;
#endif

// IRTCParticipantStateChangeEvent
public:

    STDMETHOD(get_Participant)(
                               IRTCParticipant ** ppParticipant
                              );
        
    STDMETHOD(get_State)(
                         RTC_PARTICIPANT_STATE * penState
                        );

    STDMETHOD(get_StatusCode)(
                         long * plStatusCode
                        );                           
};

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMediaEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCMediaEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCMediaEvent, &IID_IRTCMediaEvent, &LIBID_RTCCORELib>
{
public:
    CRTCMediaEvent() {}
BEGIN_COM_MAP(CRTCMediaEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCMediaEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCClient * pCClient,
                             RTC_MEDIA_EVENT_TYPE enEventType,
                             RTC_MEDIA_EVENT_REASON enEventReason,
                             long lMediaType
                            );

    void FinalRelease();

protected:

    RTC_MEDIA_EVENT_TYPE	m_enEventType; 
    RTC_MEDIA_EVENT_REASON  m_enEventReason;
    long                    m_lMediaType;

#if DBG
    PWSTR               m_pDebug;
#endif

// IRTCMediaEvent
public:

    STDMETHOD(get_MediaType)(
                             long * plMediaType
                            );
  
    STDMETHOD(get_EventType)(
                             RTC_MEDIA_EVENT_TYPE * penEventType
                            );

    STDMETHOD(get_EventReason)(
                               RTC_MEDIA_EVENT_REASON * penEventReason
                              );
};


/////////////////////////////////////////////////////////////////////////////
//
// CRTCIntensityEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCIntensityEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCIntensityEvent, &IID_IRTCIntensityEvent, &LIBID_RTCCORELib>
{
public:
    CRTCIntensityEvent() {}
BEGIN_COM_MAP(CRTCIntensityEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCIntensityEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCClient * pCClient,
                             long lValue,
                             RTC_AUDIO_DEVICE direction,
                             long lMin,
                             long lMax
                            );

    void FinalRelease();

protected:
     long                   m_lLevel;
     RTC_AUDIO_DEVICE       m_Direction;
     long                   m_lMin;
     long                   m_lMax;



// IRTCIntensityEvent
public:
    STDMETHOD(get_Level)(
                             long * plLevel
                            );
  
    STDMETHOD(get_Min)(
                             long * plMin
                            );

    STDMETHOD(get_Max)(
                             long * plMax
                            );
    
    STDMETHOD(get_Direction)(
                             RTC_AUDIO_DEVICE * plDirection
                            );

};

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCMessagingEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCMessagingEvent, &IID_IRTCMessagingEvent, &LIBID_RTCCORELib>
{
public:
    CRTCMessagingEvent() {}
BEGIN_COM_MAP(CRTCMessagingEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCMessagingEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCSession * pCSession,
                             IRTCParticipant * pParticipant,                             
                             PCWSTR szMessage,
                             PCWSTR szMessageHeader,
                             RTC_MESSAGING_EVENT_TYPE enEventType,
                             RTC_MESSAGING_USER_STATUS enUserStatus
                            );

    void FinalRelease();

protected:

    IRTCSession       * m_pSession;
    IRTCParticipant   * m_pParticipant;
    PWSTR               m_szMessage;
    PWSTR               m_szMessageHeader;
    RTC_MESSAGING_EVENT_TYPE  m_enEventType;
    RTC_MESSAGING_USER_STATUS m_enUserStatus;

#if DBG
    PWSTR               m_pDebug;
#endif

// CRTCMessagingEvent
public:

    STDMETHOD(get_Session)(
                           IRTCSession ** ppSession
                          );

    STDMETHOD(get_Participant)(
                               IRTCParticipant ** ppParticipant
                              );
        
    STDMETHOD(get_EventType)(
                        RTC_MESSAGING_EVENT_TYPE * penEventType
                       );

    STDMETHOD(get_Message)(
                           BSTR * pbstrMessage
                          );

    STDMETHOD(get_MessageHeader)(
                           BSTR * pbstrMessageHeader
                          );

    STDMETHOD(get_UserStatus)(
                              RTC_MESSAGING_USER_STATUS * penUserStatus
                             );
};

    
/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddyEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCBuddyEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCBuddyEvent, &IID_IRTCBuddyEvent, &LIBID_RTCCORELib>
{
public:
    CRTCBuddyEvent() {}
BEGIN_COM_MAP(CRTCBuddyEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCBuddyEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCClient * pCClient,
                             IRTCBuddy * pBuddy
                            );

    void FinalRelease();

protected:

    IRTCBuddy         * m_pBuddy;

#if DBG
    PWSTR               m_pDebug;
#endif

// CRTCBuddyEvent
public:

    STDMETHOD(get_Buddy)(
                         IRTCBuddy ** ppBuddy
                        );
};

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcherEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCWatcherEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCWatcherEvent, &IID_IRTCWatcherEvent, &LIBID_RTCCORELib>
{
public:
    CRTCWatcherEvent() {}
BEGIN_COM_MAP(CRTCWatcherEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCWatcherEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCClient * pCClient,
                             IRTCWatcher * pWatcher
                            );

    void FinalRelease();

protected:

    IRTCWatcher       * m_pWatcher;

#if DBG
    PWSTR               m_pDebug;
#endif

// CRTCWatcherEvent
public:

    STDMETHOD(get_Watcher)(
                           IRTCWatcher ** ppWatcher
                          );
};


#endif //__RTCEVENTS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcclient.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCClient.cpp

Abstract:

    Implementation of the CRTCClient class

--*/

#include "stdafx.h"
#include <dbt.h>
#include <uuids.h>
#include "rtcmedia.h"
#include "sdkinternal.h" // for NM constants

#define OATRUE -1
#define OAFALSE 0

LONG    g_lObjects = 0;

const DWORD INTENSITY_POLL_INTERVAL = 100;
const DWORD VOLUME_CHANGE_DELAY = 100;
const DWORD PRESENCE_STORAGE_DELAY = 5000;
const SHUTDOWN_TIMEOUT_DELAY = 5000;

extern HKEY g_hRegistryHive;
extern const WCHAR * g_szProvisioningKeyName;

HRESULT 
RTCTuningWizard(
                IRTCClient * pRTCClient,
                HINSTANCE hInst, 
                HWND hwndParent,
                IRTCTerminalManage * pRTCTerminalManager,
                BOOL * pfAudioCapture,
                BOOL * pfAudioRender,
                BOOL * pfVideo
                );

#ifdef TEST_IDISPATCH

/////////////////////////////////////////////////////////////////////////////
// IDispatch implementation
//

typedef IDispatchImpl<IRTCClientVtbl<CRTCClient>,
                      &IID_IRTCClient,
                      &LIBID_RTCCORELib>
        ClientType;

typedef IDispatchImpl<IRTCClientPresenceVtbl<CRTCClient>, 
                      &IID_IRTCClientPresence,
                      &LIBID_RTCCORELib>
        ClientPresenceType;

typedef IDispatchImpl<IRTCClientProvisioningVtbl<CRTCClient>, 
                      &IID_IRTCClientProvisioning,
                      &LIBID_RTCCORELib>
        ClientProvisioningType;

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::GetIDsOfNames
//
// Overidden IDispatch method
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::GetIDsOfNames(REFIID riid, 
                          LPOLESTR* rgszNames, 
                          UINT cNames, 
                          LCID lcid, 
                          DISPID* rgdispid
                         ) 
{ 
    HRESULT hr = DISP_E_UNKNOWNNAME;

    // See if the requsted method belongs to the default interface
    hr = ClientType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((RTC_INFO, "CRTCClient::GetIDsOfNames - found %S on IRTCClient", *rgszNames));

        rgdispid[0] |= IDISPCLIENT;
        return hr;
    }

    // If not, then try the IRTCClientPresence interface
    hr = ClientPresenceType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((RTC_INFO, "CRTCClient::GetIDsOfNames - found %S on IRTCClientPresence", *rgszNames));
        rgdispid[0] |= IDISPCLIENTPRESENCE;
        return hr;
    }

    // If not, then try the IRTCClientProvisioning interface
    hr = ClientProvisioningType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((RTC_INFO, "CRTCClient::GetIDsOfNames - found %S on IRTCClientProvisioning", *rgszNames));
        rgdispid[0] |= IDISPCLIENTPROVISIONING;
        return hr;
    }

    LOG((RTC_INFO, "CRTCClient::GetIDsOfNames - Didn't find %S on our iterfaces", *rgszNames));

    return hr; 
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::Invoke
//
// Overidden IDispatch method
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::Invoke(DISPID dispidMember, 
                   REFIID riid, 
                   LCID lcid, 
                   WORD wFlags, 
                   DISPPARAMS* pdispparams, 
                   VARIANT* pvarResult, 
                   EXCEPINFO* pexcepinfo, 
                   UINT* puArgErr
                  )
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    DWORD   dwInterface = (dispidMember & INTERFACEMASK);
    
    LOG((RTC_INFO, "CRTCClient::Invoke - dispidMember %X", dispidMember));

    // Call invoke for the required interface
    switch (dwInterface)
    {
        case IDISPCLIENT:
        {
            hr = ClientType::Invoke(dispidMember, 
                                        riid, 
                                        lcid, 
                                        wFlags, 
                                        pdispparams,
                                        pvarResult, 
                                        pexcepinfo, 
                                        puArgErr
                                       );
            break;
        }
        case IDISPCLIENTPRESENCE:
        {
            hr = ClientPresenceType::Invoke(dispidMember, 
                                        riid, 
                                        lcid, 
                                        wFlags, 
                                        pdispparams,
                                        pvarResult, 
                                        pexcepinfo, 
                                        puArgErr
                                       );
            break;
        }
        case IDISPCLIENTPROVISIONING:
        {
            hr = ClientProvisioningType::Invoke(dispidMember, 
                                        riid, 
                                        lcid, 
                                        wFlags, 
                                        pdispparams,
                                        pvarResult, 
                                        pexcepinfo, 
                                        puArgErr
                                       );
            break;
        }

    } // end switch (dwInterface)

    LOG((RTC_INFO, "CRTCClient::Invoke - exit"));

    return hr;
}

#endif // TEST_IDISPATCH

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalAddRef
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCClient::InternalAddRef()
{
    DWORD dwR;

    dwR = InterlockedIncrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCClient::InternalAddRef [%p] - dwR %d", this, dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalRelease
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCClient::InternalRelease()
{
    DWORD               dwR;
    
    dwR = InterlockedDecrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCClient::InternalRelease [%p] - dwR %d", this, dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::FinalConstruct
//
// This gets called when the object is CoCreated. Returning an error
// code from this function will cause the object creation to fail.
//
// We enforce that this object must be a singleton by failing to create
// additional objects.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::FinalConstruct()
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::FinalConstruct [%p] - enter", this));

#if DBG
    m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)m_pDebug) = this;
#endif    

    if ( InterlockedIncrement(&g_lObjects) == 1 )
    {
        //
        // This is the first object
        //

        //
        // Register for steelhead tracing
        //

        LOGREGISTERTRACING(_T("RTCDLL"));
    }
    
    LOG((RTC_TRACE, "CRTCClient::FinalConstruct [%p] - exit S_OK", this));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::FinalRelease
//
// This gets called when the object is destroyed.
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCClient::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCClient::FinalRelease [%p] - enter", this));   

    //
    // Are we already shutdown?
    //

    if ( (m_enRtcState != RTC_STATE_NULL) &&
         (m_enRtcState != RTC_STATE_SHUTDOWN) )
    {
        LOG((RTC_ERROR, "CRTCClient::FinalRelease [%p] - shutdown was not called", this));   

        Shutdown();
    }

    //
    // Shutdown the media manager
    //

    if ( m_pMediaManage != NULL )
    {
        m_pMediaManage->Shutdown();

        m_pMediaManage->Release();
        m_pMediaManage = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    if ( InterlockedDecrement(&g_lObjects) == 0)
    {
        //
        // This was the last object
        //             
      
        //
        // Deregister for steelhead tracing
        //
        
        LOGDEREGISTERTRACING();   
    }
     
    LOG((RTC_TRACE, "CRTCClient::FinalRelease [%p] - exit", this));    
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::GetMediaManager
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::GetMediaManager(
        IRTCMediaManage ** ppMediaManager
        )
{
    if (m_pMediaManage == NULL)
    {
        return E_FAIL;
    }

    *ppMediaManager = m_pMediaManage;
    (*ppMediaManager)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::WndProc
//
// This is the client's window procedure
//
/////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK
CRTCClient::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{ 
    if (uMsg == WM_CREATE)
    {
        SetLastError(0);
        if ( !SetWindowLongPtr(hwnd,
                               GWLP_USERDATA,
                               (LONG_PTR)(((LPCREATESTRUCT)lParam)->lpCreateParams)
                              ) )
        {
            if (GetLastError())  // It isn't really an error unless get last error says so
            {
                LOG((RTC_ERROR, "CRTCClient::WndProc - "
                        "SetWindowLongPtr failed %ld", GetLastError()));

                return -1;
            }
        }
    }
    else
    {
        CRTCClient *me = (CRTCClient *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

        switch (uMsg) 
        { 
            case WM_STREAMING:
                LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "WM_STREAMING"));  
                
                me->OnStreamingEvent( (RTCMediaEventItem *)lParam );

                break;

            case MM_MIXM_LINE_CHANGE:
                LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "MM_MIXM_LINE_CHANGE"));  

                me->OnMixerChange();

                break;

            case MM_MIXM_CONTROL_CHANGE:
                LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "MM_MIXM_CONTROL_CHANGE"));  

                me->OnMixerChange();

                break;

            case WM_DEVICECHANGE: 
                switch(wParam)
                {
                case DBT_DEVICEARRIVAL:
                    LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "DBT_DEVICEARRIVAL"));

                    me->OnDeviceChange();

                    break;

                case DBT_DEVICEREMOVECOMPLETE:
                    LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "DBT_DEVICEREMOVECOMPLETE"));

                    me->OnDeviceChange();

                    break;
                }
                break;

            case WM_TIMER:                
                switch(wParam)
                {
                case TID_INTENSITY:                
                    me->OnIntensityTimer();

                    break;

                case TID_PRESENCE_STORAGE:
                    me->OnPresenceStorageTimer();

                    break;

                case TID_SHUTDOWN_TIMEOUT:
                    me->OnShutdownTimeout();

                    break;

                case TID_VOLUME_CHANGE:
                    me->OnVolumeChangeTimer();

                    break;

                case TID_DTMF_TIMER:
                    me->OnDTMFTimer();

                    break;
                }
                break;

            case WM_BUDDY_UNSUB:
                LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "WM_BUDDY_UNSUB"));

                me->OnBuddyUnsub((IRTCBuddy *)wParam, (BOOL)lParam);

                break;

            case WM_PROFILE_UNREG:
                LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "WM_PROFILE_UNREG"));

                me->OnProfileUnreg((IRTCProfile *)wParam);

                break;

            case WM_ASYNC_CLEANUP_DONE:
                LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "WM_ASYNC_CLEANUP_DONE"));

                me->OnAsyncCleanupDone();

                break;
 
            case WM_DESTROY: 
                LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "WM_DESTROY"));
                return 0; 
 
            default: 
                return DefWindowProc(hwnd, uMsg, wParam, lParam); 
        } 
    }
    return 0; 
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnMixerChange
//
/////////////////////////////////////////////////////////////////////////////
void
CRTCClient::OnMixerChange()
{
    //LOG((RTC_TRACE, "CRTCClient::OnMixerChange - enter"));

    //
    // Start the volume change timer
    //

    if ( !m_fVolumeChangeInProgress )
    {
        DWORD dwID = (DWORD)SetTimer(m_hWnd, TID_VOLUME_CHANGE, VOLUME_CHANGE_DELAY, NULL);
        if (dwID==0)
        {
            LOG((RTC_ERROR, "CRTCClient::OnMixerChange - "
                           "SetTimer failed %d", GetLastError()));

            return;
        }

        m_fVolumeChangeInProgress = TRUE;
    }

    //LOG((RTC_TRACE, "CRTCClient::OnMixerChange - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnVolumeChangeTimer
//
/////////////////////////////////////////////////////////////////////////////
void
CRTCClient::OnVolumeChangeTimer()
{
    //LOG((RTC_TRACE, "CRTCClient::OnVolumeChangeTimer - enter"));

    //
    // Kill the volume change timer
    //

    KillTimer(m_hWnd, TID_VOLUME_CHANGE);

    m_fVolumeChangeInProgress = FALSE;

    //
    // Fire the event
    //

    CRTCClientEvent::FireEvent(this, RTCCET_VOLUME_CHANGE);

    //LOG((RTC_TRACE, "CRTCClient::OnVolumeChangeTimer - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnBuddyUnsub
//
// This helper function handles buddy unsubscribes on shutdown
//
/////////////////////////////////////////////////////////////////////////////
void 
CRTCClient::OnBuddyUnsub(IRTCBuddy * pBuddy, BOOL bShutdown)
{
    LOG((RTC_TRACE, "CRTCClient::OnBuddyUnsub - enter"));

    if ( bShutdown )
    {
        //
        // Remove the buddy from our array
        //

        if ( pBuddy != NULL )
        {
            m_BuddyArray.Remove(pBuddy);
        }

        //
        // Check if all the buddies are unsubscribed
        //

        if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN )
        {
            if ( m_BuddyArray.GetSize() == 0 )
            {
                LOG((RTC_INFO, "CRTCClient::OnBuddyUnsub - all buddies are unsubscribed"));
        
                InternalPrepareForShutdown2(TRUE);
            }
            else
            {
                LOG((RTC_INFO, "CRTCClient::OnBuddyUnsub - %d remaining buddies", m_BuddyArray.GetSize()));
            }
        }
    }
    else
    {
        //
        // The SIP watcher on the other side has sent us an UNSUB. We must
        // recreate our SIP buddy to send another SUB request.
        //

        CRTCBuddy * pCBuddy;
        HRESULT hr;

        pCBuddy = static_cast<CRTCBuddy *>(pBuddy);

        hr = pCBuddy->BuddyResub();

        if ( FAILED(hr) )
        {        
            LOG((RTC_ERROR, "CRTCClient::OnBuddyUnsub - "
                            "BuddyResub failed 0x%lx", hr));
        }
    }

    if ( pBuddy != NULL )
    {
        pBuddy->Release();
    }

    LOG((RTC_TRACE, "CRTCClient::OnBuddyUnsub - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnProfileUnreg
//
// This helper function handles profile unregisters on shutdown
//
/////////////////////////////////////////////////////////////////////////////
void 
CRTCClient::OnProfileUnreg(IRTCProfile * pProfile)
{
    LOG((RTC_TRACE, "CRTCClient::OnProfileUnreg - enter"));

    //
    // Remove the profile from our array
    //

    if ( pProfile != NULL )
    {
        m_HiddenProfileArray.Remove(pProfile);
    }

    //
    // Check if all the profiles are unsubscribed
    //

    if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN2 )
    {
        if ( m_HiddenProfileArray.GetSize() == 0 )
        {
            LOG((RTC_INFO, "CRTCClient::OnProfileUnreg - all proflies are unregistered"));
        
            InternalPrepareForShutdown3(TRUE);
        }
        else
        {
            LOG((RTC_INFO, "CRTCClient::OnProfileUnreg - %d remaining profiles", m_HiddenProfileArray.GetSize()));
        }
    }

    LOG((RTC_TRACE, "CRTCClient::OnProfileUnreg - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnAsyncCleanupDone
//
// This helper function fires the RTCCET_ASYNC_CLEANUP_DONE event
//
/////////////////////////////////////////////////////////////////////////////
void 
CRTCClient::OnAsyncCleanupDone()
{
    LOG((RTC_TRACE, "CRTCClient::OnAsyncCleanupDone - enter"));

    CRTCClientEvent::FireEvent( this, RTCCET_ASYNC_CLEANUP_DONE );

    LOG((RTC_TRACE, "CRTCClient::OnAsyncCleanupDone - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnShutdownTimeout
//
/////////////////////////////////////////////////////////////////////////////

void CRTCClient::OnShutdownTimeout()
{
    LOG((RTC_TRACE, "CRTCClient::OnShutdownTimeout - enter"));

    // Kill the timer
    KillTimer(m_hWnd, TID_SHUTDOWN_TIMEOUT);

    LOG((RTC_INFO, "CRTCClient::OnShutdownTimeout - shutdown timed out"));
    
    if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN )
    {
        //
        // We must cleanup any remaining buddies that could not
        // be unsubscribed.
        //
        m_BuddyArray.Shutdown();

        //
        // Continue shutdown
        //
        InternalPrepareForShutdown2(TRUE);
    }
    else if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN2 )
    {
        //
        // We must cleanup any remaining profiles that could not
        // be unregistered
        //
        m_HiddenProfileArray.Shutdown();

        //
        // Continue shutdown
        //
        InternalPrepareForShutdown3(TRUE);
    }
    else if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN3 )
    {
        //
        // Continue shutdown
        //
        InternalReadyForShutdown();
    }

    LOG((RTC_TRACE, "CRTCClient::OnShutdownTimeout - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnStreamingEvent
//
// This helper function handles streaming events
//
/////////////////////////////////////////////////////////////////////////////
void
CRTCClient::OnStreamingEvent(
        RTCMediaEventItem * pEvent
        )
{
    LOG((RTC_TRACE, "CRTCClient::OnStreamingEvent - enter"));

    switch( pEvent->Event )
    {
    case RTC_ME_STREAM_CREATED:   // new stream created by media
        {            
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_STREAM_CREATED"));

            if ( pEvent->MediaType == RTC_MT_AUDIO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio send created"));                    
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio receive created"));
                }
            }
            else if ( pEvent->MediaType == RTC_MT_VIDEO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video send created"));
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio receive created"));
                }
            }
            else if ( pEvent->MediaType == RTC_MT_DATA )
            {
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "T120 stream created"));
            }
        }
        break;

    case RTC_ME_STREAM_REMOVED:   // stream removed by media
        {            
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_STREAM_REMOVED"));

            if ( pEvent->MediaType == RTC_MT_AUDIO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio send removed"));                    
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio receive removed"));
                }
            }
            else if ( pEvent->MediaType == RTC_MT_VIDEO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video send removed"));;
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video receive removed"));
                }
            }
            else if ( pEvent->MediaType == RTC_MT_DATA )
            {
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "T120 stream removed"));
            }
        }
        break;

    case RTC_ME_STREAM_ACTIVE:    // stream active
        {
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_STREAM_ACTIVE"));

            LONG lMediaType;

            if ( pEvent->MediaType == RTC_MT_AUDIO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio send started"));

                    lMediaType = RTCMT_AUDIO_SEND;

                    m_lActiveMedia |= RTCMT_AUDIO_SEND;

                    m_bCaptureDeviceMuted = FALSE;
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio receive started"));

                    lMediaType = RTCMT_AUDIO_RECEIVE;

                    m_lActiveMedia |= RTCMT_AUDIO_RECEIVE;
                }
            }
            else if ( pEvent->MediaType == RTC_MT_VIDEO )
            {               
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video send started"));

                    lMediaType = RTCMT_VIDEO_SEND;     
                    
                    m_lActiveMedia |= RTCMT_VIDEO_SEND;
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video receive started"));

                    lMediaType = RTCMT_VIDEO_RECEIVE;

                    m_lActiveMedia |= RTCMT_VIDEO_RECEIVE;
                }
            }
            else if ( pEvent->MediaType == RTC_MT_DATA )
            {
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "T120 stream started"));

                lMediaType = RTCMT_T120_SENDRECV;

                m_lActiveMedia |= RTCMT_T120_SENDRECV;
            }

            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "cause %d", pEvent->Cause));
            
            switch( pEvent->Cause )
            {
            case RTC_ME_CAUSE_REMOTE_HOLD:
                CRTCMediaEvent::FireEvent(this, RTCMET_STARTED, RTCMER_HOLD, lMediaType);
                break;

            case RTC_ME_CAUSE_TIMEOUT:
                CRTCMediaEvent::FireEvent(this, RTCMET_STARTED, RTCMER_TIMEOUT, lMediaType);
                break;

            default:
                CRTCMediaEvent::FireEvent(this, RTCMET_STARTED, RTCMER_NORMAL, lMediaType);
            } 

            // Also, we start the intensity monitor here.. 
            StartIntensityMonitor(lMediaType);

        }
        break;

    case RTC_ME_STREAM_INACTIVE:  // stream inactive
        {
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_STREAM_INACTIVE"));

            LONG lMediaType;

            if ( pEvent->MediaType == RTC_MT_AUDIO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio send stopped"));

                    lMediaType = RTCMT_AUDIO_SEND;

                    m_lActiveMedia &= ~RTCMT_AUDIO_SEND;
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio receive stopped"));

                    lMediaType = RTCMT_AUDIO_RECEIVE;

                    m_lActiveMedia &= ~RTCMT_AUDIO_RECEIVE;
                }
            }
            else if ( pEvent->MediaType == RTC_MT_VIDEO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video send stopped"));

                    lMediaType = RTCMT_VIDEO_SEND;

                    m_lActiveMedia &= ~RTCMT_VIDEO_SEND;
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video receive stopped"));

                    lMediaType = RTCMT_VIDEO_RECEIVE;

                    m_lActiveMedia &= ~RTCMT_VIDEO_RECEIVE;
                }
            }
            else if ( pEvent->MediaType == RTC_MT_DATA )
            {
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "T120 stream stopped"));

                lMediaType = RTCMT_T120_SENDRECV;

                m_lActiveMedia &= ~RTCMT_T120_SENDRECV;
            }

            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "cause %d", pEvent->Cause));

            switch( pEvent->Cause )
            {
            case RTC_ME_CAUSE_REMOTE_HOLD:
                CRTCMediaEvent::FireEvent(this, RTCMET_STOPPED, RTCMER_HOLD, lMediaType);
                break;

            case RTC_ME_CAUSE_TIMEOUT:
                CRTCMediaEvent::FireEvent(this, RTCMET_STOPPED, RTCMER_TIMEOUT, lMediaType);
                break;

            default:
                CRTCMediaEvent::FireEvent(this, RTCMET_STOPPED, RTCMER_NORMAL, lMediaType);
            }          

            // Also, we stop the intensity monitor here.. 
            StopIntensityMonitor(lMediaType);

        }
        break;

    case RTC_ME_STREAM_FAIL:      // stream failed due to some error
        {
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_STREAM_FAIL"));

            LONG lMediaType;

            if ( pEvent->MediaType == RTC_MT_AUDIO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio send failed"));

                    lMediaType = RTCMT_AUDIO_SEND;
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio receive failed"));

                    lMediaType = RTCMT_AUDIO_RECEIVE;
                }
            }
            else if ( pEvent->MediaType == RTC_MT_VIDEO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video send failed"));

                    lMediaType = RTCMT_VIDEO_SEND;
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video receive failed"));

                    lMediaType = RTCMT_VIDEO_RECEIVE;
                }
            }
            else if ( pEvent->MediaType == RTC_MT_DATA )
            {
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "T120 stream failed"));

                lMediaType = RTCMT_T120_SENDRECV;
            }

            switch( pEvent->Cause )
            {
            case RTC_ME_CAUSE_UNKNOWN:
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                        "cause RTC_ME_CAUSE_UNKNOWN"));

                CRTCMediaEvent::FireEvent(this, RTCMET_FAILED, RTCMER_NORMAL, lMediaType);
                break;

            case RTC_ME_CAUSE_BAD_DEVICE:
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                        "cause RTC_ME_CAUSE_BAD_DEVICE"));

                CRTCMediaEvent::FireEvent(this, RTCMET_FAILED, RTCMER_BAD_DEVICE, lMediaType);
                break;

            case RTC_ME_CAUSE_CRYPTO:
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                        "cause RTC_ME_CAUSE_CRYPTO"));

                CRTCMediaEvent::FireEvent(this, RTCMET_FAILED, RTCMER_NORMAL, lMediaType);
                break;

            default:
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                        "cause %d", pEvent->Cause ));                
            }
        }
        break;

    case RTC_ME_T120_FAIL:      // T120 failed due to some error
        {
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_T120_FAIL"));

            switch( pEvent->Cause )
            {
            case RTC_ME_CAUSE_T120_INITIALIZE:
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                        "cause RTC_ME_CAUSE_T120_INITIALIZE"));
                break;
            case RTC_ME_CAUSE_T120_OUTGOING_CALL:
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                        "cause RTC_ME_CAUSE_T120_OUTGOING_CALL"));
                break;
            case RTC_ME_CAUSE_T120_INCOMING_CALL:
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                        "cause RTC_ME_CAUSE_T120_INCOMING_CALL"));
                break;
            case RTC_ME_CAUSE_T120_START_APPLET:
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                        "cause RTC_ME_CAUSE_T120_START_APPLET"));
                break;
            }
        }
        break;

    case RTC_ME_TERMINAL_REMOVED: // usb device removed
        {
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_TERMINAL_REMOVED"));            
        }
        break;

    case RTC_ME_VOLUME_CHANGE:    // volume change
        {
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_VOLUME_CHANGE"));
        }
        break;

    case RTC_ME_REQUEST_RELEASE_WAVEBUF: // we need to close the wave device
        {
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_REQUEST_RELEASE_WAVEBUF"));

            if (m_pWavePlayerSystemDefault != NULL)
            {
                m_pWavePlayerSystemDefault->CloseWaveDevice();
            }

            if (m_pWavePlayerRenderTerminal != NULL)
            {
                m_pWavePlayerRenderTerminal->CloseWaveDevice();
            }
        }
        break;

    case RTC_ME_LOSSRATE: // forward the lossrate to media controller
        {
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_LOSSRATE"));

            if (m_pMediaManage != NULL)
            {
                m_pMediaManage->OnLossrate(
                                    pEvent->MediaType,
                                    pEvent->Direction,
                                    (DWORD)pEvent->hrError
                                    );
            }
        }
        break;

    case RTC_ME_BANDWIDTH:
        {
            if (m_pMediaManage != NULL)
            {
                m_pMediaManage->OnBandwidth(
                                    pEvent->MediaType,
                                    pEvent->Direction,
                                    (DWORD)pEvent->hrError
                                    );
            }
        }
        break;

    case RTC_ME_NETWORK_QUALITY:
        {

            //
            // Fire an RTC_CLIENT_EVENT (RTCCET_NETWORK_QUALITY_CHANGE)
            //
            // I don't care wether it's audio or video
            // the notification is only for SEND, unfortunately

            CRTCClientEvent::FireEvent(
                this,
                RTCCET_NETWORK_QUALITY_CHANGE);
        }
        break;

    default:
        LOG((RTC_ERROR, "CRTCClient::OnStreamingEvent - "
                "unknown event [0x%lx]", pEvent->Event));
    }

    //
    // Free the event structure
    //

    if (m_pMediaManage != NULL)
    {
        m_pMediaManage->FreeMediaEvent( pEvent );
    }

    LOG((RTC_TRACE, "CRTCClient::OnStreamingEvent - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnDeviceChange
//
// This helper function handles device change events
//
/////////////////////////////////////////////////////////////////////////////
void 
CRTCClient::OnDeviceChange()
{
    LOG((RTC_TRACE, "CRTCClient::OnDeviceChange - enter"));

    HRESULT hr;
    IRTCTerminalManage * pTerminalManage = NULL;

    //
    // Mark our cached media capabilities as invalid
    //

    m_fMediaCapsCached = FALSE;

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                            "QI failed 0x%lx", hr));
        
        return;
    }

    //
    // Get the old terminal list
    //

    IRTCTerminal ** ppOldTerminals = NULL;
    DWORD dwOldCount = 0;

    hr = GetTerminalList( pTerminalManage, &ppOldTerminals, &dwOldCount );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                            "GetTerminalList failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return;
    }

    //
    // Get the old selected terminals
    //

    IRTCTerminal * pAudioCapture = NULL;
    IRTCTerminal * pAudioRender = NULL;
    IRTCTerminal * pVideoCapture = NULL;

    hr = pTerminalManage->GetDefaultTerminal( RTC_MT_AUDIO, RTC_MD_CAPTURE, &pAudioCapture );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                            "GetDefaultTerminal(AudioCapture) failed 0x%lx", hr));
    }

    hr = pTerminalManage->GetDefaultTerminal( RTC_MT_AUDIO, RTC_MD_RENDER, &pAudioRender );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                            "GetDefaultTerminal(AudioRender) failed 0x%lx", hr));
    }

    hr = pTerminalManage->GetDefaultTerminal( RTC_MT_VIDEO, RTC_MD_CAPTURE, &pVideoCapture );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                            "GetDefaultTerminal(VideoCapture) failed 0x%lx", hr));
    }

    //
    // Get the terminal manager to renumerate the static terminals
    //
    
    hr = pTerminalManage->UpdateStaticTerminals();
   
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                            "UpdateStaticTerminals failed 0x%lx", hr));
    
        if ( pAudioCapture != NULL )
        {
            pAudioCapture->Release();
            pAudioCapture = NULL;
        }

        if ( pAudioRender != NULL )
        {
            pAudioRender->Release();
            pAudioRender = NULL;
        }

        if ( pVideoCapture != NULL )
        {
            pVideoCapture->Release();
            pVideoCapture = NULL;
        }

        pTerminalManage->Release();
        pTerminalManage = NULL;

        FreeTerminalList( ppOldTerminals, dwOldCount );
        ppOldTerminals = NULL;

        return;
    }

    //
    // Get the new terminal list
    //

    IRTCTerminal ** ppNewTerminals = NULL;
    DWORD dwNewCount = 0;

    hr = GetTerminalList( pTerminalManage, &ppNewTerminals, &dwNewCount );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                            "GetTerminalList failed 0x%lx", hr));

        if ( pAudioCapture != NULL )
        {
            pAudioCapture->Release();
            pAudioCapture = NULL;
        }

        if ( pAudioRender != NULL )
        {
            pAudioRender->Release();
            pAudioRender = NULL;
        }

        if ( pVideoCapture != NULL )
        {
            pVideoCapture->Release();
            pVideoCapture = NULL;
        }

        pTerminalManage->Release();
        pTerminalManage = NULL;

        FreeTerminalList( ppOldTerminals, dwOldCount );
        ppOldTerminals = NULL;

        return;
    }

    //
    // Compare terminal lists
    //

    DWORD dwOld, dwNew;

    for ( dwNew = 0; dwNew < dwNewCount; dwNew++ )
    {
        BOOL bIsAdded = TRUE;

        for ( dwOld = 0; dwOld < dwOldCount; dwOld++ )
        {
            if ( ppNewTerminals[dwNew] == ppOldTerminals[dwOld] )
            {
                bIsAdded = FALSE;
            }
        }

        if ( bIsAdded )
        {
            //
            // Added terminal found
            //

            RTC_MEDIA_TYPE mt;
            RTC_MEDIA_DIRECTION md;
            WCHAR * szDescription;
           
            //
            // Get terminal media type, direction, and description
            //

            ppNewTerminals[dwNew]->GetMediaType( &mt );
            ppNewTerminals[dwNew]->GetDirection( &md );

            hr = ppNewTerminals[dwNew]->GetDescription( &szDescription );       

            if ( SUCCEEDED(hr) )
            {
                LOG((RTC_INFO, "CRTCClient::OnDeviceChange - "
                            "added terminal: '%ws' mt: %d md: %d",
                            szDescription, mt, md));
            }

            ppNewTerminals[dwNew]->FreeDescription( szDescription ); 
            
            //
            // Is a terminal of this type currently selected?
            //

            BOOL bIsSelected = TRUE;

            if ( mt == RTC_MT_AUDIO )
            {
                if ( md == RTC_MD_CAPTURE )
                {
                    if ( pAudioCapture == NULL )
                    {
                        bIsSelected = FALSE;
                    }
                }
                else
                {
                    if ( pAudioRender == NULL )
                    {
                        bIsSelected = FALSE;
                    }
                }
            }
            else
            {
                if ( md == RTC_MD_CAPTURE )
                {
                    if ( pVideoCapture == NULL )
                    {
                        bIsSelected = FALSE;
                    }
                }
            }

            if ( !bIsSelected )
            {
                //
                // No, select the terminal
                //

                LOG((RTC_INFO, "CRTCClient::OnDeviceChange - "
                                "selecting a default terminal"));

                hr = pTerminalManage->SetDefaultStaticTerminal( mt, md, ppNewTerminals[dwNew] );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                                        "SetDefaultStaticTerminal failed 0x%lx", hr));
                }
            }
        }
    }

    for ( dwOld = 0; dwOld < dwOldCount; dwOld++ )
    {
        BOOL bIsRemoved = TRUE;

        for ( dwNew = 0; dwNew < dwNewCount; dwNew++ )
        {
            if ( ppNewTerminals[dwNew] == ppOldTerminals[dwOld] )
            {
                bIsRemoved = FALSE;
            }
        }

        if ( bIsRemoved )
        {
            //
            // Removed terminal found
            //

            RTC_MEDIA_TYPE mt;
            RTC_MEDIA_DIRECTION md;
            WCHAR * szDescription;
           
            //
            // Get terminal media type, direction, and description
            //

            ppOldTerminals[dwOld]->GetMediaType( &mt );
            ppOldTerminals[dwOld]->GetDirection( &md );

            hr = ppOldTerminals[dwOld]->GetDescription( &szDescription );       

            if ( SUCCEEDED(hr) )
            {
                LOG((RTC_INFO, "CRTCClient::OnDeviceChange - "
                            "removed terminal: '%ws' mt: %d md: %d",
                            szDescription, mt, md));
            }

            ppOldTerminals[dwOld]->FreeDescription( szDescription );  

            //
            // Is this the currently selected terminal?
            //

            BOOL bIsSelected = FALSE;

            if ( mt == RTC_MT_AUDIO )
            {
                if ( md == RTC_MD_CAPTURE )
                {
                    if ( pAudioCapture == ppOldTerminals[dwOld] )
                    {
                        bIsSelected = TRUE;
                    }
                }
                else
                {
                    if ( pAudioRender == ppOldTerminals[dwOld] )
                    {
                        bIsSelected = TRUE;
                    }
                }
            }
            else
            {
                if ( md == RTC_MD_CAPTURE )
                {
                    if ( pVideoCapture == ppOldTerminals[dwOld] )
                    {
                        bIsSelected = TRUE;
                    }
                }
            }

            if ( bIsSelected )
            {
                //
                // Yes, this terminal is selected
                //

                LOG((RTC_INFO, "CRTCClient::OnDeviceChange - "
                            "selected terminal removed"));

                //
                // Is there a terminal available to replace this one?
                //

                for ( dwNew = 0; dwNew < dwNewCount; dwNew++ )
                {
                    RTC_MEDIA_TYPE mtNew;
                    RTC_MEDIA_DIRECTION mdNew;

                    ppNewTerminals[dwNew]->GetMediaType( &mtNew );
                    ppNewTerminals[dwNew]->GetDirection( &mdNew );

                    if ( (mtNew == mt) && (mdNew == md) )
                    {
                        //
                        // Yes, we found an appropriate terminal
                        //

                        LOG((RTC_INFO, "CRTCClient::OnDeviceChange - "
                                "selecting a default terminal"));

                        hr = pTerminalManage->SetDefaultStaticTerminal( mt, md, ppNewTerminals[dwNew] );

                        if ( FAILED(hr) )
                        {
                            LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                                                "SetDefaultStaticTerminal failed 0x%lx", hr));
                        }

                        break;
                    }
                }
            }              
        }
    }

    if ( pAudioCapture != NULL )
    {
        pAudioCapture->Release();
        pAudioCapture = NULL;
    }

    if ( pAudioRender != NULL )
    {
        pAudioRender->Release();
        pAudioRender = NULL;
    }

    if ( pVideoCapture != NULL )
    {
        pVideoCapture->Release();
        pVideoCapture = NULL;
    }

    pTerminalManage->Release();
    pTerminalManage = NULL;

    FreeTerminalList( ppNewTerminals, dwNewCount );
    ppNewTerminals = NULL;

    FreeTerminalList( ppOldTerminals, dwOldCount );
    ppOldTerminals = NULL;

    //
    // Save the settings
    //

    hr = StoreDefaultTerminals();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                    "StoreDefaultTerminals failed 0x%lx", hr));
    }

    //
    // Send an event
    //

    CRTCClientEvent::FireEvent(this, RTCCET_DEVICE_CHANGE);

    LOG((RTC_TRACE, "CRTCClient::OnDeviceChange - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::Initialize
//
// This is an IRTCClient method that will initialize the object. It should
// be called before any other methods.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::Initialize()
{
    LOG((RTC_TRACE, "CRTCClient::Initialize - enter"));

    HRESULT hr;

    if ( m_enRtcState == RTC_STATE_SHUTDOWN )
    {
        LOG((RTC_WARN, "CRTCClient::Initialize - already shutdown"));

        return RTC_E_CLIENT_ALREADY_SHUT_DOWN;
    }
    else if ( m_enRtcState != RTC_STATE_NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                    "already initialized" ));

        return RTC_E_CLIENT_ALREADY_INITIALIZED;
    }

    //
    // Register a window class
    //

    WNDCLASS wc;
    ATOM atom;

    ZeroMemory(&wc, sizeof(wc));
    wc.lpfnWndProc = WndProc;
    wc.hInstance = _Module.GetModuleInstance();
    wc.lpszClassName = _T("CRTCClient");

    atom = RegisterClass(&wc);

    if ( !atom )
    {
        DWORD  dwError = GetLastError();

        if(dwError == ERROR_CLASS_ALREADY_EXISTS)
        {
            LOG((RTC_TRACE, "CRTCClient::Initialize - "
                    "RegisterClass failed; class already exists." ));

            // continue

        }
        else
        {
            LOG((RTC_ERROR, "CRTCClient::Initialize - "
                    "RegisterClass failed %d", dwError ));
        
            m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

            return HRESULT_FROM_WIN32(dwError);
        }
    }

    //
    // Create a window
    //

    m_hWnd = CreateWindow( _T("CRTCClient"), _T("CRTCClient"), 0,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            NULL, NULL, NULL, this);

    if ( m_hWnd == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                "CreateWindow failed %d", GetLastError() ));
        
        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Register to receive PNP device notifications
    //

    DEV_BROADCAST_DEVICEINTERFACE NotificationFilter;

    ZeroMemory( &NotificationFilter, sizeof(NotificationFilter) );
    NotificationFilter.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    NotificationFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    NotificationFilter.dbcc_classguid = AM_KSCATEGORY_VIDEO;

    m_hDevNotifyVideo = RegisterDeviceNotification( m_hWnd, 
        &NotificationFilter,
        DEVICE_NOTIFY_WINDOW_HANDLE
        );

    if ( m_hDevNotifyVideo == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                "RegisterDeviceNotification(Video) failed %d", GetLastError() ));
        
        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return HRESULT_FROM_WIN32(GetLastError());
    }

    NotificationFilter.dbcc_classguid = AM_KSCATEGORY_AUDIO;

    m_hDevNotifyAudio = RegisterDeviceNotification( m_hWnd, 
        &NotificationFilter,
        DEVICE_NOTIFY_WINDOW_HANDLE
        );

    if ( m_hDevNotifyAudio == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                "RegisterDeviceNotification(Audio) failed %d", GetLastError() ));
        
        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Initialize the wave player
    //

    m_pWavePlayerSystemDefault = new CWavePlayer;

    if ( m_pWavePlayerSystemDefault == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "wave player for ring not created"));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return E_OUTOFMEMORY;                        
    }

    m_pWavePlayerRenderTerminal = new CWavePlayer;

    if ( m_pWavePlayerRenderTerminal == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "wave player for dtmf not created"));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return E_OUTOFMEMORY;                        
    }

    hr = CWavePlayer::Initialize();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "wave player failed to initialize 0x%lx", hr ));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;                        
    }

    //
    // Create the media manager
    //

    hr = CreateMediaController( &m_pMediaManage );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "CreateMediaController failed 0x%lx", hr ));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;  
    }

    //
    // Initialize the media manager
    //

    hr = m_pMediaManage->Initialize( m_hWnd, WM_STREAMING );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "MediaManage Initialize failed 0x%lx", hr ));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;  
    }

    //
    // Create the SIP stack
    //

    hr = SipCreateStack( m_pMediaManage, &m_pSipStack );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "SipCreateStack failed 0x%lx", hr ));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;  
    }

    //
    // Get our SIP notification interface
    //

    ISipStackNotify * pNotify = NULL;

    hr = _InternalQueryInterface( IID_ISipStackNotify, (void **) &pNotify );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "failed to get SIP stack notify interface 0x%lx", hr ));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;  
    }

    //
    // Register for SIP stack notifications
    //

    hr = m_pSipStack->SetNotifyInterface( pNotify );

    pNotify->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "SetNotifyInterface failed 0x%lx", hr ));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;  
    }

    //
    // Create the video windows
    //

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTerminal       * pTerminal = NULL;
    IRTCVideoConfigure * pVideoCfg = NULL;

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    //
    // Get the video preview terminal
    //

    hr = pTerminalManage->GetVideoPreviewTerminal(                                         
                            &pTerminal
                            );    

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "GetVideoPreviewTerminal failed 0x%lx", hr));        

        pTerminalManage->Release();
        pTerminalManage = NULL;

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    if ( pTerminal == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "NULL terminal"));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return E_FAIL;
    }

    //
    // Get the IRTCVideoConfigure interface on the video preview terminal
    //

    hr = pTerminal->QueryInterface(
                   IID_IRTCVideoConfigure,
                   (void **)&pVideoCfg
                  );

    pTerminal->Release();
    pTerminal = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "QI(VideoConfigure) failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;
        
        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    //
    // Get the IVideoWindow from the video preview terminal
    //

    hr = pVideoCfg->GetIVideoWindow( (LONG_PTR **)&m_pVideoWindow[RTCVD_PREVIEW] );

    pVideoCfg->Release();
    pVideoCfg = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "GetIVideoWindow failed 0x%lx", hr));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    LOG((RTC_INFO, "CRTCClient::Initialize - "
                     "m_pVideoWindow[RTCVD_PREVIEW] = 0x%lx",
                     m_pVideoWindow[RTCVD_PREVIEW]));

    //
    // Get the video render terminal
    //

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_VIDEO,
                            RTC_MD_RENDER,                                            
                            &pTerminal
                            );        

    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "GetDefaultTerminal failed 0x%lx", hr));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    if ( pTerminal == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "NULL terminal"));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return E_FAIL;
    }

    //
    // Get the IRTCVideoConfigure interface on the video render terminal
    //

    hr = pTerminal->QueryInterface(
                   IID_IRTCVideoConfigure,
                   (void **)&pVideoCfg
                  );

    pTerminal->Release();
    pTerminal = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "QI(VideoConfigure) failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;
        
        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    //
    // Get the IVideoWindow from the video render terminal
    //

    hr = pVideoCfg->GetIVideoWindow( (LONG_PTR **)&m_pVideoWindow[RTCVD_RECEIVE] );

    pVideoCfg->Release();
    pVideoCfg = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "GetIVideoWindow failed 0x%lx", hr));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    LOG((RTC_INFO, "CRTCClient::Initialize - "
                     "m_pVideoWindow[RTCVD_RECEIVE] = 0x%lx",
                     m_pVideoWindow[RTCVD_RECEIVE]));

    //
    // Load default terminal settings from registry and
    // select the terminals
    //

    hr = LoadAndSelectDefaultTerminals();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "LoadAndSelectDefaultTerminals failed 0x%lx", hr));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    //
    // Auto select default terminals
    //

    hr = AutoSelectDefaultTerminals();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "AutoSelectDefaultTerminals failed 0x%lx", hr));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    //
    // Set preferred media types
    //

    DWORD dwMediaTypes;

    hr = get_RegistryDword( RTCRD_PREFERRED_MEDIA_TYPES, &dwMediaTypes );

    if ( SUCCEEDED(hr) )
    {
        //
        // We got media types from the registry
        //

        hr = m_pMediaManage->SetPreference( dwMediaTypes );
    }
    else
    {
        //
        // Default to all media types
        //

        put_RegistryDword( RTCRD_PREFERRED_MEDIA_TYPES, RTCMT_AUDIO_SEND | RTCMT_AUDIO_RECEIVE |
                                                        RTCMT_VIDEO_SEND | RTCMT_VIDEO_RECEIVE );

        hr = m_pMediaManage->SetPreference( RTCMT_AUDIO_SEND | RTCMT_AUDIO_RECEIVE |
                                            RTCMT_VIDEO_SEND | RTCMT_VIDEO_RECEIVE );

    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "SetPreference failed 0x%lx", hr));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }
    
    //
    // Get default local user info
    //
       
    m_szUserName = RtcGetUserName();

    if ( m_szUserName == NULL )
    {   
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "RtcGetUserName failed"));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return E_OUTOFMEMORY;
    }

    PWSTR szComputerName = NULL;

    szComputerName = RtcGetComputerName();

    if ( szComputerName == NULL )
    {   
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "RtcGetComputerName failed"));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return E_OUTOFMEMORY;
    }

    hr = AllocCleanSipString( szComputerName, &m_szUserURI );

    RtcFree( szComputerName );
    szComputerName = NULL;

    if ( FAILED(hr) )
    {   
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "AllocCleanSipString failed 0x%lx", hr));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    //
    // Have we been tuned yet?
    //

    DWORD dwTuned;

    hr = get_RegistryDword( RTCRD_TUNED, &dwTuned );

    if ( FAILED(hr) || ( dwTuned == 0 ) )
    {
        m_fTuned = FALSE;
    }
    else
    {
        m_fTuned = TRUE;
    }

    m_enRtcState = RTC_STATE_INITIALIZED;

    LOG((RTC_TRACE, "CRTCClient::Initialize - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::AutoSelectDefaultTerminals
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::AutoSelectDefaultTerminals()
{
    LOG((RTC_TRACE, "CRTCClient::AutoSelectDefaultTerminals - enter"));

    HRESULT hr;    

    //
    // Get the IRTCTerminalManage interface
    //

    IRTCTerminalManage * pTerminalManage = NULL;

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::AutoSelectDefaultTerminals - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminal list
    //

    IRTCTerminal ** ppTerminals = NULL;
    DWORD dwCount = 0;

    hr = GetTerminalList( pTerminalManage, &ppTerminals, &dwCount );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::AutoSelectDefaultTerminals - "
                            "GetTerminalList failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    RTC_MEDIA_TYPE mt;
    RTC_MEDIA_DIRECTION md;
    IRTCTerminal * pOldTerminal = NULL;

    for ( DWORD dw=0; dw < dwCount; dw++ )
    {
        //
        // Get terminal media type and direction
        //

        ppTerminals[dw]->GetMediaType( &mt );
        ppTerminals[dw]->GetDirection( &md );

        BOOL bIsDisabled = FALSE;

        if ( mt == RTC_MT_AUDIO )
        {
            if ( md == RTC_MD_CAPTURE )
            {
                bIsDisabled = m_fAudioCaptureDisabled;
            }
            else
            {
                bIsDisabled = m_fAudioRenderDisabled;
            }
        }
        else
        {
            if ( md == RTC_MD_CAPTURE )
            {
                bIsDisabled = m_fVideoCaptureDisabled;
            }
        }

        if ( !bIsDisabled )
        {
            //
            // Is there a terminal of this type already selected?
            //

            pTerminalManage->GetDefaultTerminal( mt, md, &pOldTerminal );

            if ( pOldTerminal != NULL )
            {
                //
                // Yes, do nothing
                //

                pOldTerminal->Release();
                pOldTerminal = NULL;
            }
            else
            {
                //
                // No, select the terminal
                //

                LOG((RTC_INFO, "CRTCClient::AutoSelectDefaultTerminals - "
                                "selecting a default terminal"));

                hr = pTerminalManage->SetDefaultStaticTerminal( mt, md, ppTerminals[dw] );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::AutoSelectDefaultTerminals - "
                                        "SetDefaultStaticTerminal failed 0x%lx", hr));
                }
            }
        }
    }

    FreeTerminalList( ppTerminals, dwCount );
    ppTerminals = NULL;

    pTerminalManage->Release();
    pTerminalManage = NULL;

    LOG((RTC_TRACE, "CRTCClient::AutoSelectDefaultTerminals - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::LoadAndSelectDefaultTerminals
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::LoadAndSelectDefaultTerminals()
{
    LOG((RTC_TRACE, "CRTCClient::LoadAndSelectDefaultTerminals - enter"));

    HRESULT hr;    

    //
    // Get the IRTCTerminalManage interface
    //

    IRTCTerminalManage * pTerminalManage = NULL;

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::LoadAndSelectDefaultTerminals - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminal list
    //

    IRTCTerminal ** ppTerminals = NULL;
    DWORD dwCount = 0;

    hr = GetTerminalList( pTerminalManage, &ppTerminals, &dwCount );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::LoadAndSelectDefaultTerminals - "
                            "GetTerminalList failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    BSTR szAudioCapture = NULL;
    BSTR szAudioRender = NULL;
    BSTR szVideoCapture = NULL;

    get_RegistryString( RTCRS_TERM_AUDIO_CAPTURE, &szAudioCapture );
    get_RegistryString( RTCRS_TERM_AUDIO_RENDER, &szAudioRender );
    get_RegistryString( RTCRS_TERM_VIDEO_CAPTURE, &szVideoCapture );

    if ( ( szAudioCapture != NULL) &&
         wcscmp( szAudioCapture, L"NULL" ) == 0 )
    {
        m_fAudioCaptureDisabled = TRUE;
    }

    if ( ( szAudioRender != NULL) &&
         wcscmp( szAudioRender, L"NULL" ) == 0 )
    {
        m_fAudioRenderDisabled = TRUE;
    }

    if ( ( szVideoCapture != NULL) &&
         wcscmp( szVideoCapture, L"NULL" ) == 0 )
    {
        m_fVideoCaptureDisabled = TRUE;
    }

    RTC_MEDIA_TYPE mt;
    RTC_MEDIA_DIRECTION md;
    WCHAR * szDescription;

    for ( DWORD dw=0; dw < dwCount; dw++ )
    {
        //
        // Get terminal media type, direction, and description
        //

        ppTerminals[dw]->GetMediaType( &mt );
        ppTerminals[dw]->GetDirection( &md );
        
        hr = ppTerminals[dw]->GetDescription( &szDescription );       

        if ( SUCCEEDED(hr) )
        {
            //
            // Is this terminal one which was stored in the registry?
            //

            BOOL fSelect = FALSE;

            if ( mt == RTC_MT_AUDIO )
            {
                if ( md == RTC_MD_CAPTURE )
                {
                    if ( ( szAudioCapture != NULL) &&
                         ( wcscmp( szAudioCapture, szDescription ) == 0 ) )
                    {
                        fSelect = TRUE;
                    }
                }
                else
                {
                    if ( ( szAudioRender != NULL) &&
                         ( wcscmp( szAudioRender, szDescription ) == 0 ) )
                    {
                        fSelect = TRUE;
                    }
                }
            }
            else
            {
                if ( md == RTC_MD_CAPTURE )
                {
                    if ( ( szVideoCapture != NULL) &&
                         ( wcscmp( szVideoCapture, szDescription ) == 0 ) )
                    {
                        fSelect = TRUE;
                    }
                }
            }

            //
            // Free the description
            //

            ppTerminals[dw]->FreeDescription( szDescription );    

            if ( fSelect == TRUE )
            {
                //
                // Select the terminal
                //

                LOG((RTC_INFO, "CRTCClient::LoadAndSelectDefaultTerminals - "
                                "selecting a default terminal"));

                hr = pTerminalManage->SetDefaultStaticTerminal( mt, md, ppTerminals[dw] );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::LoadAndSelectDefaultTerminals - "
                                        "SetDefaultStaticTerminal failed 0x%lx", hr));
                }
            }
        }
    }

    SysFreeString( szAudioCapture );
    SysFreeString( szAudioRender );
    SysFreeString( szVideoCapture );

    FreeTerminalList( ppTerminals, dwCount );
    ppTerminals = NULL;

    pTerminalManage->Release();
    pTerminalManage = NULL;       

    LOG((RTC_TRACE, "CRTCClient::LoadAndSelectDefaultTerminals - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::StoreDefaultTerminals
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::StoreDefaultTerminals()
{
    LOG((RTC_TRACE, "CRTCClient::StoreDefaultTerminals - enter"));

    HRESULT hr;

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTerminal       * pTerminal = NULL;
    WCHAR              * szDescription = NULL;

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Store audio capture
    //

    if ( m_fAudioCaptureDisabled )
    {
        hr = put_RegistryString( RTCRS_TERM_AUDIO_CAPTURE, L"NULL" );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                        "put_RegistryString failed 0x%lx", hr));
        }
    }
    else
    {
        hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );        

        if ( SUCCEEDED(hr) )
        {
            LOG((RTC_INFO, "CRTCClient::StoreDefaultTerminals - "
                                "audio capture"));

            if (pTerminal == NULL)
            {
                hr = DeleteRegistryString( RTCRS_TERM_AUDIO_CAPTURE );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                "DeleteRegistryString failed 0x%lx", hr));
                }
            }
            else
            {
                hr = pTerminal->GetDescription( &szDescription );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                    "GetDescription failed 0x%lx", hr));
                }
                else
                {
                    hr = put_RegistryString( RTCRS_TERM_AUDIO_CAPTURE, szDescription );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                    "put_RegistryString failed 0x%lx", hr));
                    }

                    pTerminal->FreeDescription( szDescription );
                    szDescription = NULL;
                }

                pTerminal->Release();
                pTerminal = NULL;
            }
        }
    }

    //
    // Store audio render
    //

    if ( m_fAudioRenderDisabled )
    {
        hr = put_RegistryString( RTCRS_TERM_AUDIO_RENDER, L"NULL" );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                        "put_RegistryString failed 0x%lx", hr));
        }
    }
    else
    {
        hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_RENDER,                                            
                            &pTerminal
                            );        

        if ( SUCCEEDED(hr) )
        {
            LOG((RTC_INFO, "CRTCClient::StoreDefaultTerminals - "
                                "audio render"));

            if (pTerminal == NULL)
            {
                hr = DeleteRegistryString( RTCRS_TERM_AUDIO_RENDER );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                "DeleteRegistryString failed 0x%lx", hr));
                }
            }
            else
            {
                hr = pTerminal->GetDescription( &szDescription );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                    "GetDescription failed 0x%lx", hr));
                }
                else
                {
                    hr = put_RegistryString( RTCRS_TERM_AUDIO_RENDER, szDescription );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                    "put_RegistryString failed 0x%lx", hr));
                    }

                    pTerminal->FreeDescription( szDescription );
                    szDescription = NULL;
                }

                pTerminal->Release();
                pTerminal = NULL;
            }
        }
    }

    //
    // Store video capture
    //

    if ( m_fVideoCaptureDisabled )
    {
        hr = put_RegistryString( RTCRS_TERM_VIDEO_CAPTURE, L"NULL" );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                        "put_RegistryString failed 0x%lx", hr));
        }
    }
    else
    {
        hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_VIDEO,
                            RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );        

        if ( SUCCEEDED(hr) )
        {
            LOG((RTC_INFO, "CRTCClient::StoreDefaultTerminals - "
                                "video capture"));

            if (pTerminal == NULL)
            {
                hr = DeleteRegistryString( RTCRS_TERM_VIDEO_CAPTURE );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                "DeleteRegistryString failed 0x%lx", hr));
                }
            }
            else
            {
                hr = pTerminal->GetDescription( &szDescription );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                    "GetDescription failed 0x%lx", hr));
                }
                else
                {
                    hr = put_RegistryString( RTCRS_TERM_VIDEO_CAPTURE, szDescription );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                    "put_RegistryString failed 0x%lx", hr));
                    }

                    pTerminal->FreeDescription( szDescription );
                    szDescription = NULL;
                }

                pTerminal->Release();
                pTerminal = NULL;
            }
        }
    }

    pTerminalManage->Release();
    pTerminalManage = NULL;

    LOG((RTC_TRACE, "CRTCClient::StoreDefaultTerminals - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::SetEncryptionKey
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCClient::SetEncryptionKey(
    long lMediaType,
    BSTR bstrEncryptionKey
    )
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CRTCClient::SetEncryptionKey - enter"));

    if(lMediaType & RTCMT_AUDIO_SEND)
    {
        hr = m_pMediaManage -> SetEncryptionKey(
            RTC_MT_AUDIO, RTC_MD_CAPTURE, bstrEncryptionKey);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::SetEncryptionKey - "
                                "MM->SetEncryptionKey failed 0x%lx", hr));

            return hr;
        }
    }
    if(lMediaType & RTCMT_AUDIO_RECEIVE)
    {
        hr = m_pMediaManage -> SetEncryptionKey(
            RTC_MT_AUDIO, RTC_MD_RENDER, bstrEncryptionKey);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::SetEncryptionKey - "
                                "MM->SetEncryptionKey failed 0x%lx", hr));

            return hr;
        }
    }
    if(lMediaType & RTCMT_VIDEO_SEND)
    {
        hr = m_pMediaManage -> SetEncryptionKey(
            RTC_MT_VIDEO, RTC_MD_CAPTURE, bstrEncryptionKey);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::SetEncryptionKey - "
                                "MM->SetEncryptionKey failed 0x%lx", hr));

            return hr;
        }
    }
    if(lMediaType & RTCMT_VIDEO_RECEIVE)
    {
        hr = m_pMediaManage -> SetEncryptionKey(
            RTC_MT_VIDEO, RTC_MD_RENDER, bstrEncryptionKey);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::SetEncryptionKey - "
                                "MM->SetEncryptionKey failed 0x%lx", hr));

            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCClient::SetEncryptionKey - exit"));
    
    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::Shutdown
//
// This is an IRTCClient method that will shutdown the object. It should
// be called before releasing the object.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::Shutdown()
{
    LOG((RTC_TRACE, "CRTCClient::Shutdown - enter"));

    DWORD dwResult;
    HRESULT hr;

    if ( m_enRtcState == RTC_STATE_NULL )
    {
        LOG((RTC_WARN, "CRTCClient::Shutdown - not initialized"));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }
    else if ( m_enRtcState == RTC_STATE_INITIALIZED )
    {
        LOG((RTC_WARN, "CRTCClient::Shutdown - not prepared for shutdown"));

        //
        // We are not prepared for shutdown. Do the necessary preparation and
        // continue with shutdown right away.
        //

        InternalPrepareForShutdown(FALSE);
        InternalPrepareForShutdown2(FALSE);
        InternalPrepareForShutdown3(FALSE);
    }
    else if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN )
    {
        LOG((RTC_WARN, "CRTCClient::Shutdown - "
                    "not finished preparing for shutdown (1)" ));

        //
        // We are not finished preparing for shutdown. Go ahead and
        // continue with shutdown right away.
        //

        InternalPrepareForShutdown2(FALSE);
        InternalPrepareForShutdown3(FALSE);
    }
    else if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN2 )
    {
        LOG((RTC_WARN, "CRTCClient::Shutdown - "
                    "not finished preparing for shutdown (2)" ));

        //
        // We are not finished preparing for shutdown. Go ahead and
        // continue with shutdown right away.
        //

        InternalPrepareForShutdown3(FALSE);
    }
    else if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN3 )
    {
        LOG((RTC_WARN, "CRTCClient::Shutdown - "
                    "not finished preparing for shutdown (3)" ));

        //
        // We are not finished preparing for shutdown. Go ahead and
        // continue with shutdown right away.
        //
    }
    else if ( m_enRtcState == RTC_STATE_SHUTDOWN )
    {
        LOG((RTC_WARN, "CRTCClient::Shutdown - already shutdown"));

        return RTC_E_CLIENT_ALREADY_SHUT_DOWN;
    }

    m_enRtcState = RTC_STATE_SHUTDOWN;

    //
    // Free local user info
    //

    if ( m_szUserURI != NULL )
    {
        RtcFree( m_szUserURI );
        m_szUserURI = NULL;
    }

    if ( m_szUserName != NULL )
    {
        RtcFree( m_szUserName );
        m_szUserName = NULL;
    }

    //
    // Release the video windows
    //

    if ( m_pVideoWindow[RTCVD_PREVIEW] != NULL )
    {
        m_pVideoWindow[RTCVD_PREVIEW]->Release();
        m_pVideoWindow[RTCVD_PREVIEW] = NULL;
    }

    if ( m_pVideoWindow[RTCVD_RECEIVE] != NULL )
    {
        m_pVideoWindow[RTCVD_RECEIVE]->Release();
        m_pVideoWindow[RTCVD_RECEIVE] = NULL;
    }

    //
    // Close the audio device
    //

    if ( m_pWavePlayerSystemDefault != NULL )
    {
        m_pWavePlayerSystemDefault->CloseWaveDevice();

        delete m_pWavePlayerSystemDefault;
        m_pWavePlayerSystemDefault = NULL;
    }

    if ( m_pWavePlayerRenderTerminal != NULL )
    {
        m_pWavePlayerRenderTerminal->CloseWaveDevice();

        delete m_pWavePlayerRenderTerminal;
        m_pWavePlayerRenderTerminal = NULL;
    }

    //
    // Release the profile arrays
    //

    m_ProfileArray.Shutdown();
    m_HiddenProfileArray.Shutdown();

    //
    // Disable presence
    //

    m_fPresenceEnabled = FALSE;

    //
    // Release the buddy manager
    //

    if ( m_pSipBuddyManager != NULL )
    { 
        m_pSipBuddyManager->Release();
        m_pSipBuddyManager = NULL;
    }

    //
    // Release the buddy array
    //

    m_BuddyArray.Shutdown();

    //
    // Release the watcher manager 
    //

    if ( m_pSipWatcherManager != NULL )
    { 
        m_pSipWatcherManager->Release();
        m_pSipWatcherManager = NULL;
    }

    //
    // Release the watcher arrays
    //

    m_WatcherArray.Shutdown();   
    m_HiddenWatcherArray.Shutdown();   

#ifdef DUMP_PRESENCE
    DumpWatchers("SHUTDOWN");
#endif

    //
    // Release the SIP stack
    //

    if ( m_pSipStack != NULL )
    {
        //
        // Unregister notifications
        //

        m_pSipStack->SetNotifyInterface( NULL );

        m_pSipStack->Shutdown();
        m_pSipStack->Release();
        m_pSipStack = NULL;
    }

    //
    // Unregister for PNP events
    //

    if ( NULL != m_hDevNotifyVideo )
    {
        UnregisterDeviceNotification(m_hDevNotifyVideo);
        m_hDevNotifyVideo = NULL;
    }

    if ( NULL != m_hDevNotifyAudio )
    {
        UnregisterDeviceNotification(m_hDevNotifyAudio);
        m_hDevNotifyAudio = NULL;
    }
    
    //
    // Destroy window
    //

    if ( NULL != m_hWnd )
    {
        DestroyWindow(m_hWnd);
        m_hWnd = NULL;
    }

    //
    // Unregister window class
    //

    // this fails if there's still a window open. It can happen when multiple instances
    // are running
    UnregisterClass( _T("CRTCClient"), _Module.GetModuleInstance() );

    LOG((RTC_TRACE, "CRTCClient::Shutdown - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::PrepareForShutdown
//
// This is an IRTCClient method that will prepare the object for shutdown.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::PrepareForShutdown()
{
    LOG((RTC_TRACE, "CRTCClient::PrepareForShutdown - enter"));

    HRESULT hr;

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::PrepareForShutdown - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    hr = InternalPrepareForShutdown(TRUE);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::PrepareForShutdown - "
                           "InternalPrepareForShutdown failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::PrepareForShutdown - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalPrepareForShutdown
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::InternalPrepareForShutdown(BOOL fAsync)
{
    LOG((RTC_TRACE, "CRTCClient::InternalPrepareForShutdown - enter"));

    HRESULT hr;

    m_enRtcState = RTC_STATE_PREPARING_SHUTDOWN;

    //
    // Store presence information
    //

    if ( m_fPresenceUseStorage )
    {
        //
        // Get watcher shutdown blob information
        //

        CRTCWatcher * pCWatcher = NULL;

        for (int n = 0; n < m_WatcherArray.GetSize(); n++)
        {
            pCWatcher = reinterpret_cast<CRTCWatcher *>(m_WatcherArray[n]);

            if ( pCWatcher )
            {
                pCWatcher->GetSIPWatcherShutdownBlob();
            }
        }

        //
        // Now, save the presence info
        //

        InternalExport( m_varPresenceStorage );

        m_fPresenceUseStorage = FALSE;
    }

    //
    // Unsubscribe the SIP buddies
    //

    if ( m_pSipBuddyManager != NULL )
    { 
        CRTCBuddy * pCBuddy = NULL;

        for (int n = 0; n < m_BuddyArray.GetSize(); n++)
        {
            pCBuddy = reinterpret_cast<CRTCBuddy *>(m_BuddyArray[n]);

            if ( pCBuddy )
            {
                if ( pCBuddy->m_pSIPBuddy == NULL )
                {
                    m_BuddyArray[n]->AddRef();

                    PostMessage( m_hWnd, WM_BUDDY_UNSUB, (WPARAM)m_BuddyArray[n], (LPARAM)TRUE );
                }
                else
                {
                    pCBuddy->RemoveSIPBuddy(TRUE);                   
                }
            }
        }
    }

    if ( fAsync )
    {
        PostMessage( m_hWnd, WM_BUDDY_UNSUB, 0, (LPARAM)TRUE );

        //
        // Start the timeout timer
        //

        DWORD dwID = (DWORD)SetTimer(m_hWnd, TID_SHUTDOWN_TIMEOUT, SHUTDOWN_TIMEOUT_DELAY, NULL);
        if (dwID==0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            LOG((RTC_ERROR, "CRTCClient::InternalPrepareForShutdown - "
                           "SetTimer failed 0x%lx", hr));

            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCClient::InternalPrepareForShutdown - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalPrepareForShutdown2
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::InternalPrepareForShutdown2(BOOL fAsync)
{
    LOG((RTC_TRACE, "CRTCClient::InternalPrepareForShutdown2 - enter"));

    HRESULT hr;

    m_enRtcState = RTC_STATE_PREPARING_SHUTDOWN2;

    //
    // Disable all provider profiles
    //

    for ( int n = 0; n < m_ProfileArray.GetSize(); n++ )
    {
        m_HiddenProfileArray.Add( m_ProfileArray[n] );
        
        CRTCProfile * pCProfile = NULL;

        pCProfile = static_cast<CRTCProfile *>(m_ProfileArray[n]);

        pCProfile->Disable();
    }

    m_ProfileArray.Shutdown();

    if ( fAsync )
    {
        PostMessage( m_hWnd, WM_PROFILE_UNREG, 0, 0 );

        //
        // Start the timeout timer
        //

        DWORD dwID = (DWORD)SetTimer(m_hWnd, TID_SHUTDOWN_TIMEOUT, SHUTDOWN_TIMEOUT_DELAY, NULL);
        if (dwID==0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            LOG((RTC_ERROR, "CRTCClient::InternalPrepareForShutdown2 - "
                           "SetTimer failed 0x%lx", hr));

            return hr;
        }    
    }

    LOG((RTC_TRACE, "CRTCClient::InternalPrepareForShutdown2 - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalPrepareForShutdown3
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::InternalPrepareForShutdown3(BOOL fAsync)
{
    LOG((RTC_TRACE, "CRTCClient::InternalPrepareForShutdown3 - enter"));

    HRESULT hr;

    m_enRtcState = RTC_STATE_PREPARING_SHUTDOWN3;

    //
    // Unsubscribe the SIP watchers
    //

    if ( m_pSipWatcherManager != NULL )
    { 
        CRTCWatcher * pCWatcher = NULL;

        for (int n = 0; n < m_WatcherArray.GetSize(); n++)
        {
            pCWatcher = reinterpret_cast<CRTCWatcher *>(m_WatcherArray[n]);

            if ( pCWatcher )
            {
                pCWatcher->RemoveSIPWatchers(TRUE);                   
            }
        }
        
        for (int n = 0; n < m_HiddenWatcherArray.GetSize(); n++)
        {
            pCWatcher = reinterpret_cast<CRTCWatcher *>(m_HiddenWatcherArray[n]);

            if ( pCWatcher )
            {
                pCWatcher->RemoveSIPWatchers(TRUE);                   
            }
        }
    }

    //
    // Prepare SIP stack for shutdown
    //

    hr = m_pSipStack->PrepareForShutdown();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalPrepareForShutdown3 - "
                           "PrepareForShutdown failed 0x%lx", hr));
    }
    else if ( hr == S_OK )
    {
        LOG((RTC_INFO, "CRTCClient::InternalPrepareForShutdown3 - "
                           "sip stack ready for shutdown"));

        InternalReadyForShutdown();
    }
    else if ( fAsync )
    {       
        //
        // Start the timeout timer
        //

        DWORD dwID = (DWORD)SetTimer(m_hWnd, TID_SHUTDOWN_TIMEOUT, SHUTDOWN_TIMEOUT_DELAY, NULL);
        if (dwID==0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            LOG((RTC_ERROR, "CRTCClient::InternalPrepareForShutdown3 - "
                           "SetTimer failed 0x%lx", hr));

            return hr;
        }    
    }

    LOG((RTC_TRACE, "CRTCClient::InternalPrepareForShutdown3 - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalReadyForShutdown()
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::InternalReadyForShutdown()
{
    LOG((RTC_TRACE, "CRTCClient::InternalReadyForShutdown - enter"));

    m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

    PostMessage(m_hWnd, WM_ASYNC_CLEANUP_DONE, 0, 0);    

    LOG((RTC_TRACE, "CRTCClient::InternalReadyForShutdown - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_EventFilter
//
// This is an IRTCClient method that will set the event filter.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_EventFilter(
        long lFilter
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_EventFilter - enter"));

    if ( lFilter & ~RTCEF_ALL )
    {
        LOG((RTC_ERROR, "CRTCClient::put_EventFilter - "
                            "invalid filter mask"));

        return E_INVALIDARG;
    }

    m_lEventFilter = lFilter;

    LOG((RTC_TRACE, "CRTCClient::put_EventFilter - exit S_OK"));

    return S_OK;
}
 
/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_EventFilter
//
// This is an IRTCClient method that will return the event filter.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_EventFilter(
        long * plFilter
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_EventFilter - enter"));

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( plFilter, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_EventFilter - "
                            "bad long pointer"));

        return E_POINTER;
    }
    
    *plFilter = m_lEventFilter;

    LOG((RTC_TRACE, "CRTCClient::get_EventFilter - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::SetPreferredMediaTypes
//
// This is an IRTCClient method that will set the preferred media types.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::SetPreferredMediaTypes(
        long lMediaTypes,
        VARIANT_BOOL fPersistent
        )
{
    LOG((RTC_TRACE, "CRTCClient::SetPreferredMediaTypes - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::SetPreferredMediaTypes - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( lMediaTypes & ~(RTCMT_AUDIO_SEND |
                         RTCMT_AUDIO_RECEIVE |
                         RTCMT_VIDEO_SEND |
                         RTCMT_VIDEO_RECEIVE |
                         RTCMT_T120_SENDRECV) )
    {
        LOG((RTC_ERROR, "CRTCClient::SetPreferredMediaTypes - "
                            "invalid meida types"));

        return E_INVALIDARG;
    }

    HRESULT hr;

    hr = m_pMediaManage->SetPreference( lMediaTypes );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::SetPreferredMediaTypes - "
                            "SetPreference failed 0x%lx", hr));

        return hr;
    }
    
    if ( fPersistent == VARIANT_TRUE )
    {
        lMediaTypes &= (~RTCMT_T120_SENDRECV); // Never persist settings about T120 stream

        hr = put_RegistryDword( RTCRD_PREFERRED_MEDIA_TYPES, (DWORD)lMediaTypes );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::SetPreferredMediaTypes - "
                                "put_RegistryDword failed 0x%lx", hr));

            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCClient::SetPreferredMediaTypes - exit S_OK"));

    return S_OK;
}
 
/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_PreferredMediaTypes
//
// This is an IRTCClient method that will return the preferred media types.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_PreferredMediaTypes(
        long * plMediaTypes
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_PreferredMediaTypes - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredMediaTypes - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( plMediaTypes, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredMediaTypes - "
                            "bad long pointer"));

        return E_POINTER;
    }

    HRESULT hr;

    DWORD dwMediaTypes;

    hr = m_pMediaManage->GetPreference( &dwMediaTypes );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredMediaTypes - "
                            "GetPreference failed 0x%lx", hr));

        return hr;
    } 

    *plMediaTypes = dwMediaTypes;

    LOG((RTC_TRACE, "CRTCClient::get_PreferredMediaTypes - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_MediaCapabilities
//
// This is an IRTCClient method that will return the media types for which
// terminals exist.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_MediaCapabilities(
        long * plMediaTypes
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_MediaCapabilities - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_MediaCapabilities - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( plMediaTypes, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_MediaCapabilities - "
                            "bad long pointer"));

        return E_POINTER;
    }

    //
    // Do we have media capabilities cached?
    //

    if ( m_fMediaCapsCached == FALSE )
    {
        HRESULT hr;

        IRTCTerminalManage * pTerminalManage = NULL;
        IRTCTerminal       * pTerminal = NULL;

        //
        // Get the IRTCTerminalManage interface
        //

        hr = m_pMediaManage->QueryInterface(
                               IID_IRTCTerminalManage,
                               (void **)&pTerminalManage
                              );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::get_MediaCapabilities - "
                                "QI(TerminalManage) failed 0x%lx", hr));

            return hr;
        }

        //
        // We always have video receive
        //

        m_lMediaCaps = RTCMT_VIDEO_RECEIVE | RTCMT_T120_SENDRECV;

        LOG((RTC_INFO, "CRTCClient::get_MediaCapabilities - "
                                "RTCMT_VIDEO_RECEIVE | RTCMT_T120_SENDRECV"));

        //
        // Check video send
        //

        hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_VIDEO,
                            RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );        

        if ( SUCCEEDED(hr) && (pTerminal != NULL) )
        {
            m_lMediaCaps |= RTCMT_VIDEO_SEND;

            LOG((RTC_INFO, "CRTCClient::get_MediaCapabilities - "
                                "RTCMT_VIDEO_SEND"));

            pTerminal->Release();
            pTerminal = NULL;
        }

        //
        // Check audio receive
        //

        hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_RENDER,                                            
                            &pTerminal
                            );        

        if ( SUCCEEDED(hr) && (pTerminal != NULL) )
        {
            m_lMediaCaps |= RTCMT_AUDIO_RECEIVE;

            LOG((RTC_INFO, "CRTCClient::get_MediaCapabilities - "
                                "RTCMT_AUDIO_RECEIVE"));

            pTerminal->Release();
            pTerminal = NULL;
        }

        //
        // Check audio send
        //

        hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );        

        if ( SUCCEEDED(hr) && (pTerminal != NULL) )
        {
            m_lMediaCaps |= RTCMT_AUDIO_SEND;

            LOG((RTC_INFO, "CRTCClient::get_MediaCapabilities - "
                                "RTCMT_AUDIO_SEND"));

            pTerminal->Release();
            pTerminal = NULL;
        }

        pTerminalManage->Release();
        pTerminalManage = NULL;

        m_fMediaCapsCached = TRUE;        
    }

    *plMediaTypes = m_lMediaCaps;

    LOG((RTC_TRACE, "CRTCClient::get_MediaCapabilities - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalCreateSession
//
// This is a private helper method to do the work of creating a new
// session object. It is meant to be called by the public API method
// CreateSession and when SIP notifies us of an incoming session.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCClient::InternalCreateSession(
        IRTCSession ** ppSession
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::InternalCreateSession - enter"));
    
    //
    // Create the session
    //

    CComObject<CRTCSession> * pCSession;
    hr = CComObject<CRTCSession>::CreateInstance( &pCSession );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateSession - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
            
        return hr;
    }

    //
    // Get the IRTCSession interface
    //

    IRTCSession * pSession = NULL;

    hr = pCSession->QueryInterface(
                           IID_IRTCSession,
                           (void **)&pSession
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateSession - "
                            "QI failed 0x%lx", hr));
        
        delete pCSession;
        
        return hr;
    }   

    *ppSession = pSession;

    LOG((RTC_TRACE, "CRTCClient::InternalCreateSession - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::CreateSession
//
// This is an IRTCClient method that creates a new outgoing session using
// the service provider specified by IRTCProfile. If the profile is NULL, the 
// default service provider is used.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::CreateSession(
        RTC_SESSION_TYPE enType,
        BSTR bstrLocalPhoneURI,
        IRTCProfile * pProfile,
        long lFlags,
        IRTCSession ** ppSession
        )
{
    HRESULT hr = S_OK;
    
    LOG((RTC_TRACE, "CRTCClient::CreateSession - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( ppSession, sizeof(IRTCSession *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                            "bad IRTCSession pointer"));

        return E_POINTER;
    }

    //
    // NULL is okay for profile, it means no provider
    //
    
    if ( (pProfile != NULL) && 
         IsBadReadPtr( pProfile, sizeof(IRTCProfile) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                            "bad IRTCProfile pointer"));

        return E_POINTER;
    }

    //
    // NULL is okay for local phone uri
    //

    if ( (bstrLocalPhoneURI != NULL) &&
         IsBadStringPtrW( bstrLocalPhoneURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                            "bad phone uri string pointer"));

        return E_POINTER;
    }     
    
    LOG((RTC_INFO, "CRTCClient::CreateSession - enType [%d]",
        enType));
    LOG((RTC_INFO, "CRTCClient::CreateSession - bstrLocalPhoneURI [%ws]",
        bstrLocalPhoneURI));
    LOG((RTC_INFO, "CRTCClient::CreateSession - pProfile [0x%p]",
        pProfile));
    LOG((RTC_INFO, "CRTCClient::CreateSession - lFlags [0x%lx]",
        lFlags));       

    //
    // Verify session type
    //

    switch (enType)
    {
        case RTCST_PC_TO_PC:
        {
            LOG((RTC_INFO, "CRTCClient::CreateSession - "
                    "RTCST_PC_TO_PC"));
            
            if ( (bstrLocalPhoneURI != NULL) &&
                 (*bstrLocalPhoneURI != L'\0') )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                    "RTCST_PC_TO_PC sessions shouldn't have a local phone URI"));
            
                return E_INVALIDARG;
            }

            if ( m_fTuning )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                        "tuning is active" ));

                return E_FAIL;
            }

            break;
        }

        case RTCST_PC_TO_PHONE:
        {
            LOG((RTC_INFO, "CRTCClient::CreateSession - "
                    "RTCST_PC_TO_PHONE"));

            if ( (bstrLocalPhoneURI != NULL) &&
                 (*bstrLocalPhoneURI != L'\0') )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                    "RTCST_PC_TO_PHONE sessions shouldn't have a local phone URI"));
            
                return E_INVALIDARG;
            }

            if ( m_fTuning )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                        "tuning is active" ));

                return E_FAIL;
            }

            break;
        }

        case RTCST_PHONE_TO_PHONE:
        {
            LOG((RTC_INFO, "CRTCClient::CreateSession - "
                    "RTCST_PHONE_TO_PHONE"));

            if ( (bstrLocalPhoneURI == NULL) ||
                 (*bstrLocalPhoneURI == L'\0') )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                    "PHONE_TO_PHONE sessions need a local phone URI"));
            
                return RTC_E_LOCAL_PHONE_NEEDED;
            }

            break;
        }

        case RTCST_IM:
        {
            LOG((RTC_INFO, "CRTCClient::CreateSession - "
                    "RTCST_IM"));
            
            if ( (bstrLocalPhoneURI != NULL) &&
                 (*bstrLocalPhoneURI != L'\0') )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                    "RTCST_IM sessions shouldn't have a local phone URI"));
            
                return E_INVALIDARG;
            }

            break;
        }

        default:
        {
            LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                            "invalid session type"));
        
            return E_INVALIDARG;
        }
    }   

    //
    // Create the session
    //

    IRTCSession * pSession = NULL;
    
    hr = InternalCreateSession( 
                               &pSession
                              );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                            "InternalCreateSession failed 0x%lx", hr));
   
        return hr;
    }   
    
    //
    // Initialize the session
    //

    CRTCSession * pCSession = NULL;

    pCSession = static_cast<CRTCSession *>(pSession);
    
    hr = pCSession->InitializeOutgoing(
                               this, 
                               pProfile,
                               m_pSipStack,
                               enType,
                               m_szUserName,
                               m_szUserURI,
                               bstrLocalPhoneURI,
                               lFlags
                              );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateSession - "
                            "Initialize failed 0x%lx", hr));
        
        pSession->Release();        
        
        return hr;
    }     

    *ppSession = pSession;

    LOG((RTC_TRACE, "CRTCClient::CreateSession - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_NetworkAddresse
//
// This is an IRTCClient method that will return the network
// addresses and ports being used by the client.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::get_NetworkAddresses(
        VARIANT_BOOL fTCP,
        VARIANT_BOOL fExternal,
        VARIANT * pvAddress
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::get_NetworkAddresses - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_NetworkAddresses - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( pvAddress, sizeof(VARIANT) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_NetworkAddresses - "
                            "bad VARIANT pointer"));

        return E_POINTER;
    }

    //
    // Get network addresses from SIP
    //

    LPOLESTR * NetworkAddressArray;
    ULONG      ulNetworkAddressCount;

    hr = m_pSipStack->GetNetworkAddresses(
                            fTCP ? TRUE : FALSE,
                            fExternal ? TRUE : FALSE,
                            &NetworkAddressArray,
                            &ulNetworkAddressCount
                            );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_NetworkAddresses - "
                            "GetNetworkAddresses failed 0x%lx"));

        return hr;
    }

    //
    // Create the SAFEARRAY
    //

    SAFEARRAY * pSafeArray;
    SAFEARRAYBOUND SafeArrayBound[1];

    SafeArrayBound[0].lLbound = 0;
    SafeArrayBound[0].cElements = ulNetworkAddressCount;

    pSafeArray = SafeArrayCreate(VT_BSTR, 1, SafeArrayBound);

    if ( pSafeArray == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_NetworkAddresses - "
                            "SafeArrayCreate out of memory"));

        m_pSipStack->FreeNetworkAddresses(
                            NetworkAddressArray,
                            ulNetworkAddressCount
                            );

        return E_OUTOFMEMORY;
    }

    //
    // Pack the SAFEARRAY
    //

    if ( ulNetworkAddressCount > 0 )
    {
        BSTR HUGEP *pbstr;

        hr = SafeArrayAccessData( pSafeArray, (void HUGEP**) &pbstr );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::SafeArrayAccessData - "
                            "SafeArrayCreate failed"));

            SafeArrayDestroy( pSafeArray );

            m_pSipStack->FreeNetworkAddresses(
                                NetworkAddressArray,
                                ulNetworkAddressCount
                                );

            return hr;
        }

        for (ULONG i=0; i < ulNetworkAddressCount; i++)
        {
            pbstr[i] = SysAllocString( NetworkAddressArray[i] );

            if ( pbstr[i] == NULL )
            {
                LOG((RTC_ERROR, "CRTCClient::SafeArrayAccessData - "
                            "SysAllocString out of memory"));

                SafeArrayUnaccessData( pSafeArray );

                SafeArrayDestroy( pSafeArray );

                m_pSipStack->FreeNetworkAddresses(
                                    NetworkAddressArray,
                                    ulNetworkAddressCount
                                    );

                return E_OUTOFMEMORY;
            }
        }

        SafeArrayUnaccessData( pSafeArray );
    }

    m_pSipStack->FreeNetworkAddresses(
                            NetworkAddressArray,
                            ulNetworkAddressCount
                            );

    //
    // Initialize the VARIANT
    //

    VariantInit(pvAddress);

    pvAddress->vt = VT_ARRAY | VT_BSTR;
    pvAddress->parray = pSafeArray;

    LOG((RTC_TRACE, "CRTCClient::get_NetworkAddresses - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalCreateProfile
//
// This is a private helper method to do the work of creating a new
// profile object. 
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCClient::InternalCreateProfile(
        IRTCProfile ** ppProfile
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::InternalCreateProfile - enter"));
    
    //
    // Create the session
    //

    CComObject<CRTCProfile> * pCProfile;
    hr = CComObject<CRTCProfile>::CreateInstance( &pCProfile );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateProfile - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
            
        return hr;
    }

    //
    // Get the IRTCProfile interface
    //

    IRTCProfile * pProfile = NULL;

    hr = pCProfile->QueryInterface(
                           IID_IRTCProfile,
                           (void **)&pProfile
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateProfile - "
                            "QI failed 0x%lx", hr));
        
        delete pCProfile;
        
        return hr;
    }
   
    *ppProfile = pProfile;

    LOG((RTC_TRACE, "CRTCClient::InternalCreateProfile - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::CreateProfile
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::CreateProfile(
        BSTR bstrProfileXML,
        IRTCProfile ** ppProfile
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::CreateProfile - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateProfile - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( ppProfile, sizeof(IRTCProfile *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateProfile - "
                            "bad IRTCProfile pointer"));

        return E_POINTER;
    }

    if ( IsBadStringPtrW( bstrProfileXML, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateProfile - "
                            "bad XML string pointer"));

        return E_POINTER;
    }
    
    //
    // Create the profile
    //

    IRTCProfile * pProfile = NULL;
    
    hr = InternalCreateProfile( 
                               &pProfile
                              );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateProfile - "
                            "InternalCreateProfile failed 0x%lx", hr));
        
        return hr;
    }

    //
    // Initialize the profile
    //

    CRTCProfile * pCProfile = NULL;

    pCProfile = static_cast<CRTCProfile *>(pProfile);
    
    hr = pCProfile->InitializeFromString( bstrProfileXML,
                                          this,
                                          m_pSipStack);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateProfile - "
                            "InitializeFromString failed 0x%lx", hr));

        pProfile->Release();
        
        return hr;
    } 

    *ppProfile = pProfile;

    LOG((RTC_TRACE, "CRTCClient::CreateProfile - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::EnableProfile
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::EnableProfile(
            IRTCProfile * pProfile,
            long lRegisterFlags
            )
{
    LOG((RTC_TRACE, "CRTCClient::EnableProfile - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadReadPtr( pProfile, sizeof( IRTCProfile * ) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                            "bad IRTCProfile pointer"));

        return E_POINTER;
    }

    if ( lRegisterFlags & ~RTCRF_REGISTER_ALL )
    {
        LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                            "invalid register flags"));

        return E_INVALIDARG;
    }

    HRESULT hr;

    //
    // Get the profile realm
    //

    BSTR bstrRealm = NULL;
    CRTCProfile * pCProfile = NULL;
    IRTCProfile * pProfileWithDuplicateRealm = NULL;

    pCProfile = static_cast<CRTCProfile *>(pProfile);

    hr = pCProfile->GetRealm( &bstrRealm );

    if ( SUCCEEDED(hr) )
    {
        //
        // Search the profile array and make sure we are not
        // trying to add a duplicate realm
        //

        for (int n = 0; n < m_ProfileArray.GetSize(); n++)
        {
            BSTR bstrSearchRealm = NULL;

            pCProfile = static_cast<CRTCProfile *>(m_ProfileArray[n]);

            hr = pCProfile->GetRealm( &bstrSearchRealm );

            if ( SUCCEEDED(hr) )
            {
                if ( _wcsicmp( bstrRealm, bstrSearchRealm ) == 0 )
                {
                    pProfileWithDuplicateRealm = m_ProfileArray[n];

                    SysFreeString( bstrSearchRealm );

                    break;
                }

                SysFreeString( bstrSearchRealm );
            }
        }

        SysFreeString( bstrRealm );
    }

    //
    // Get profile key
    //

    BSTR bstrKey = NULL;    

    hr = pProfile->get_Key( &bstrKey );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                            "get_Key failed 0x%lx", hr));

        return hr;
    }

    //
    // Search the profile array and make sure we are not
    // trying to add a duplicate key
    //

    BOOL fNeedToAdd = TRUE;

    for (int n = 0; n < m_ProfileArray.GetSize(); n++)
    {        
        if ( pProfile == m_ProfileArray[n] )
        {           
            //
            // This is the same profile as we already have
            // in the array.
            //
            // Enable the profile again.
            //

            fNeedToAdd = FALSE;
            
            // 
            // Since we don't add it, we don't have a duplicate realm
            //
            
            pProfileWithDuplicateRealm = NULL;

            break;
        }

        BSTR bstrSearchKey = NULL;

        hr = m_ProfileArray[n]->get_Key( &bstrSearchKey );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                                "get_Key failed 0x%lx", hr));

            SysFreeString( bstrKey );

            return hr;
        }

        if ( wcscmp( bstrKey, bstrSearchKey ) == 0 )
        {           
            //
            // This is a new version of a profile we already have
            // in the array.
            //
            // We must disable the old profile and enable the new
            // one.
            //

            if ( pProfileWithDuplicateRealm != NULL )
            {
                if ( pProfileWithDuplicateRealm == m_ProfileArray[n] )
                {
                    //
                    // The duplicate realm will be removed, so it is not
                    // a problem.
                    //

                    pProfileWithDuplicateRealm = NULL;
                }
                else
                {
                    //
                    // The duplicate realm is in another profile in the
                    // array besides the one being removed.
                    //

                    LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                                "duplicate realm"));

                    SysFreeString( bstrKey );
                    SysFreeString( bstrSearchKey );

                    return RTC_E_DUPLICATE_REALM;
                }
            }

            DisableProfile( m_ProfileArray[n] );

            SysFreeString( bstrSearchKey );

            break;
        }

        SysFreeString( bstrSearchKey );
    }

    SysFreeString( bstrKey );

    if ( pProfileWithDuplicateRealm != NULL )
    {
        //
        // There is another profile in the array with a duplicate
        // realm.
        //

        LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                    "duplicate realm"));

        return RTC_E_DUPLICATE_REALM;
    }

    //
    // Enable the profile
    //

    if ( fNeedToAdd )
    {
        BOOL fResult;

        fResult = m_ProfileArray.Add( pProfile );

        if ( !fResult )
        {
            LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                            "out of memory"));
       
            return E_OUTOFMEMORY;
        }
    }

    pCProfile = static_cast<CRTCProfile *>(pProfile);

    hr = pCProfile->Enable( lRegisterFlags );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                            "Enable failed 0x%lx", hr));
       
        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::EnableProfile - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::DisableProfile
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::DisableProfile(
            IRTCProfile * pProfile           
            )
{
    LOG((RTC_TRACE, "CRTCClient::DisableProfile - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::DisableProfile - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadReadPtr( pProfile, sizeof( IRTCProfile * ) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::DisableProfile - "
                            "bad IRTCProfile pointer"));

        return E_POINTER;
    }

    //
    // Make sure the profile is in the list
    //

    int n = m_ProfileArray.Find( pProfile );

    if ( n == -1 )
    {
        LOG((RTC_ERROR, "CRTCClient::DisableProfile - "
                            "profile not enabled"));

        return E_FAIL;
    }

    //
    // Disable the profile
    //

    BOOL fResult;
    HRESULT hr;

    fResult = m_HiddenProfileArray.Add( pProfile );

    if ( !fResult )
    {
        LOG((RTC_ERROR, "CRTCClient::DisableProfile - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    CRTCProfile * pCProfile = NULL;

    pCProfile = static_cast<CRTCProfile *>(pProfile);

    m_ProfileArray.RemoveAt(n);                        

    hr = pCProfile->Disable();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::DisableProfile - "
                            "Disable failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::DisableProfile - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::EnumerateProfiles
//
// This is an IRTCClient method that enumerates profiles on the client.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::EnumerateProfiles(
        IRTCEnumProfiles ** ppEnum
        )
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "CRTCClient::EnumerateProfiles enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateProfiles - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( ppEnum, sizeof( IRTCEnumProfiles * ) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateProfiles - "
                            "bad IRTCEnumProfiles pointer"));

        return E_POINTER;
    }
    
    //
    // Create the enumeration
    //
 
    CComObject< CRTCEnum< IRTCEnumProfiles,
                          IRTCProfile,
                          &IID_IRTCEnumProfiles > > * p;
                          
    hr = CComObject< CRTCEnum< IRTCEnumProfiles,
                               IRTCProfile,
                               &IID_IRTCEnumProfiles > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::InternalEnumerateProfiles - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the enumeration (adds a reference)
    //
    
    hr = p->Initialize( m_ProfileArray );

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalEnumerateProfiles - "
                            "could not initialize enumeration" ));
    
        delete p;
        return hr;
    }

    *ppEnum = p;

    LOG((RTC_TRACE, "CRTCClient::EnumerateProfiles - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_Profiles
//
// This is an IRTCClient method that enumerates profiles on the client.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::get_Profiles(
        IRTCCollection ** ppCollection
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::get_Profiles - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Profiles - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( ppCollection, sizeof(IRTCCollection *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Profiles - "
                            "bad IRTCCollection pointer"));

        return E_POINTER;
    }

    //
    // Create the collection
    //
 
    CComObject< CRTCCollection< IRTCProfile > > * p;
                          
    hr = CComObject< CRTCCollection< IRTCProfile > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::get_Profiles - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the collection (adds a reference)
    //
    
    hr = p->Initialize( m_ProfileArray );

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Profiles - "
                            "could not initialize enumeration" ));
    
        delete p;
        return hr;
    }

    // Set the collection to be returned to the caller. 

    *ppCollection = p;

    LOG((RTC_TRACE, "CRTCClient::get_Profiles - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::GetProfile
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCClient::GetProfile(
            BSTR bstrUserAccount,
            BSTR bstrUserPassword,
            BSTR bstrUserURI,
            BSTR bstrServer,
            long lTransport,
            long lCookie
            )
{
    LOG((RTC_TRACE, "CRTCClient::GetProfile - enter"));

    LOG((RTC_TRACE, "CRTCClient::GetProfile - exit E_NOTIMPL"));

    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_SessionCapabilities
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCClient::get_SessionCapabilities(
            long * plSupportedSessions
            )
{
    LOG((RTC_TRACE, "CRTCClient::get_SessionCapabilities - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_SessionCapabilities - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( plSupportedSessions, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_SessionCapabilities - "
                            "bad long pointer"));

        return E_POINTER;
    }

    HRESULT hr;

    *plSupportedSessions = RTCSI_PC_TO_PC | RTCSI_IM;

    for ( int n=0; n < m_ProfileArray.GetSize() ; n++ )
    {
        //
        // Get the supported session types of the provider
        //

        long lSupportedSessions;

        hr = m_ProfileArray[n]->get_SessionCapabilities( &lSupportedSessions );

        if ( FAILED( hr ) )
        {
            LOG((RTC_ERROR, "CRTCClient::get_SessionCapabilities - "
                            "get_SessionCapabilities failed 0x%lx - skipping", hr));

            continue;
        }

        *plSupportedSessions |= lSupportedSessions;
    }

    LOG((RTC_TRACE, "CRTCClient::get_SessionCapabilities - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::GetBestProfile
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCClient::GetBestProfile(
        RTC_SESSION_TYPE * penType,
        PCWSTR szDestUserURI,
        BOOL fIsRedirect,
        IRTCProfile ** ppProfile
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::GetBestProfile - enter"));

    //
    // Check the arguments
    //

    if ( IsBadReadPtr( penType, sizeof(RTC_SESSION_TYPE) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetBestProfile - "
                            "bad RTC_SESSION_TYPE pointer"));

        return E_POINTER;
    }
    
    if ( (szDestUserURI != NULL) &&
         IsBadStringPtrW( szDestUserURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetBestProfile - "
                            "bad string pointer"));

        return E_POINTER;
    }

    if ( IsBadWritePtr( ppProfile, sizeof(IRTCProfile *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetBestProfile - "
                            "bad IRTCProfile pointer"));

        return E_POINTER;
    }

    //
    // Determine the type of the address
    //

    BOOL    bUseProfile = TRUE;
  
    if( szDestUserURI != NULL )
    {
        BOOL    bIsPhoneAddress = FALSE;
        BOOL    bIsSIPAddress = FALSE;
        BOOL    bIsTELAddress = FALSE;
        BOOL    bHasMaddrOrTsp = FALSE;
        BOOL    bIsEmailLike = FALSE;

        hr = GetAddressType(
            szDestUserURI,
            &bIsPhoneAddress,
            &bIsSIPAddress,
            &bIsTELAddress,
            &bIsEmailLike,
            &bHasMaddrOrTsp);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::GetBestProfile - "
                "GetAddressType failed 0x%lx", hr)); 
            
            return hr;
        }

        if ( bHasMaddrOrTsp ||
             (bIsPhoneAddress && bIsSIPAddress) ||
             (!bIsPhoneAddress && !bIsEmailLike) )
        {
            //
            // This address has all the information we need. No need to
            // use a profile.
            //

            bUseProfile = FALSE;

            if (*penType == RTCST_PHONE_TO_PHONE)
            {
                //
                // This cannot be used for PINT calls
                //

                LOG((RTC_ERROR, "CRTCClient::GetBestProfile - "
                    "address will not work for RTCST_PHONE_TO_PHONE")); 

                return RTC_E_INVALID_SESSION_TYPE;
            }           
            else if (*penType == RTCST_PC_TO_PHONE)
            {
                *penType = RTCST_PC_TO_PC;
            }
        }
        else
        {
            if ( bIsPhoneAddress && (*penType == RTCST_PC_TO_PC) )
            {
                *penType = RTCST_PC_TO_PHONE;
            }
            else if ( !bIsPhoneAddress && (*penType == RTCST_PC_TO_PHONE) )
            {
                *penType = RTCST_PC_TO_PC;
            }
        }
    }

    if ( fIsRedirect &&
         ((*penType == RTCST_PC_TO_PC) || (*penType == RTCST_IM)) )
    {
        //
        // Always redirect PC_TO_PC calls with no profile
        //

        LOG((RTC_INFO, "CRTCClient::GetBestProfile - "
                    "choosing no profile for redirect")); 

        bUseProfile = FALSE;
    }

    if ( bUseProfile )
    {
        //
        // Choose an appropriate profile
        //

        IRTCProfile      * pProfile = NULL;
        BOOL               bFound = FALSE;

        for ( int n=0; n < m_ProfileArray.GetSize() ; n++ )
        {
            //
            // Get the supported session types of the provider
            //

            long lSupportedSessions;

            hr = m_ProfileArray[n]->get_SessionCapabilities( &lSupportedSessions );

            if ( FAILED( hr ) )
            {
                LOG((RTC_ERROR, "CRTCClient::GetBestProfile - "
                                "get_SessionCapabilities failed 0x%lx - skipping", hr));

                continue;
            }

            switch ( *penType )
            {
            case RTCST_PC_TO_PC:
                if ( lSupportedSessions & RTCSI_PC_TO_PC )
                {
                    bFound = TRUE;
                }
                break;

            case RTCST_PC_TO_PHONE:
                if ( lSupportedSessions & RTCSI_PC_TO_PHONE )
                {
                    bFound = TRUE;
                }
                break;

            case RTCST_PHONE_TO_PHONE:
                if ( lSupportedSessions & RTCSI_PHONE_TO_PHONE )
                {
                    bFound = TRUE;
                }
                break;
            
            case RTCST_IM:
                if ( lSupportedSessions & RTCSI_IM )
                {                   
                    bFound = TRUE;
                }
                break;
            }

            if ( bFound == TRUE )
            {
                *ppProfile = m_ProfileArray[n];
                (*ppProfile)->AddRef();

                break;
            }
        }

        if ( bFound == FALSE )
        {
            LOG((RTC_ERROR, "CRTCClient::GetBestProfile - "
                            "no profile found"));

            if ( (*penType == RTCST_PC_TO_PC) ||
                 (*penType == RTCST_IM) )
            {
                *ppProfile = NULL;
            }
            else
            {
                return RTC_E_NO_PROFILE;
            }
        }
    }
    else
    {
        *ppProfile = NULL;
    }

    LOG((RTC_INFO, "CRTCClient::GetBestProfile - profile [%p]", *ppProfile ));
       
    LOG((RTC_TRACE, "CRTCClient::GetBestProfile - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_ListenForIncomingSessions
//
// This is an IRTCClient method that sets the client to listen for 
// incoming sessions.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_ListenForIncomingSessions(
        RTC_LISTEN_MODE enListen
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_ListenForIncomingSessions - enter"));   

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_ListenForIncomingSessions - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    HRESULT hr;

    BOOL fEnableIncomingCalls;
    BOOL fEnableStaticPort;

    switch ( enListen )
    {
    case RTCLM_NONE:
        fEnableStaticPort = FALSE;
        fEnableIncomingCalls = FALSE;
        break;      

    case RTCLM_DYNAMIC:
        fEnableStaticPort = FALSE;
        fEnableIncomingCalls = TRUE;
        break;

    case RTCLM_BOTH:
        fEnableStaticPort = TRUE;
        fEnableIncomingCalls = TRUE;
        break;

    default:
        LOG((RTC_ERROR, "CRTCClient::put_ListenForIncomingSessions - "
                                     "invalid argument"));

        return E_INVALIDARG;
    }

    if ( fEnableStaticPort && !m_fEnableStaticPort )
    {
        hr = m_pSipStack->EnableStaticPort();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::put_ListenForIncomingSessions - "
                                     "EnableStaticPort failed 0x%lx"));

            return hr;
        }
    }
    else if ( !fEnableStaticPort && m_fEnableStaticPort )
    {        
        hr = m_pSipStack->DisableStaticPort();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::put_ListenForIncomingSessions - "
                                     "DisableStaticPort failed 0x%lx"));

            return hr;
        }
    }

    if ( fEnableIncomingCalls && !m_fEnableIncomingCalls )
    {
        hr = m_pSipStack->EnableIncomingCalls();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::put_ListenForIncomingSessions - "
                                     "EnableIncomingCalls failed 0x%lx"));

            return hr;
        }
    }
    else if ( !fEnableIncomingCalls && m_fEnableIncomingCalls )
    {
        hr = m_pSipStack->DisableIncomingCalls();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::put_ListenForIncomingSessions - "
                                     "DisableIncomingCalls failed 0x%lx"));

            return hr;
        }

        hr = m_pSipStack->DisableStaticPort();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::put_ListenForIncomingSessions - "
                                     "DisableStaticPort failed 0x%lx"));

            return hr;
        }
    }

    m_fEnableIncomingCalls = fEnableIncomingCalls;
    m_fEnableStaticPort = fEnableStaticPort;
    
    LOG((RTC_TRACE, "CRTCClient::put_ListenForIncomingSessions - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_ListenForIncomingSessions
//
// This is an IRTCClient method that determines if the client is 
// currently listening for incoming sessions.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_ListenForIncomingSessions(
        RTC_LISTEN_MODE * penListen
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_ListenForIncomingSessions - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_ListenForIncomingSessions - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr(penListen, sizeof( RTC_LISTEN_MODE ) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_ListenForIncomingSessions - "
                                 "bad pointer"));

        return E_POINTER;
    }

    if ( m_fEnableIncomingCalls )
    {
        if ( m_fEnableStaticPort )
        {
            *penListen = RTCLM_BOTH;
        }
        else
        {
            *penListen = RTCLM_DYNAMIC;
        }
    }
    else
    {
        *penListen = RTCLM_NONE;
    }

    LOG((RTC_TRACE, "CRTCClient::get_ListenForIncomingSessions - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InvokeTuningWizard
//
// This is an IRTCClient method that will invoke the tuning wizard UI
// for selection and tuning of audio and video devices.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::InvokeTuningWizard(
        OAHWND hwndParent
        )
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCClient::InvokeTuningWizard - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::InvokeTuningWizard - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Don't let the tuning wizard start if we already have
    // one running
    //

    if ( m_fTuning )
    {
        LOG((RTC_ERROR, "CRTCClient::InvokeTuningWizard - "
                    "tuning is active" ));

        return RTC_E_MEDIA_CONTROLLER_STATE;
    }

    //
    // Don't let the tuning wizard start if there is active media
    //

    if ( m_lActiveMedia )
    {
        LOG((RTC_ERROR, "CRTCClient::InvokeTuningWizard - "
                    "media is active" ));

        return RTC_E_MEDIA_CONTROLLER_STATE;
    }

    IRTCTerminalManage * pTerminalManage = NULL;   
    LONG lSoundCaps = 0;
    BOOL fAudioCapture = FALSE;
    BOOL fAudioRender = FALSE;
    BOOL fVideo = FALSE;

    //
    // Get the TerminalManage interface from MediaManage
    //

    hr = m_pMediaManage->QueryInterface(IID_IRTCTerminalManage, (void **)&pTerminalManage );

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CRTCClient::InvokeTuningWizard - "
                "QI(IRTCTerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Mark our cached media capabilities as invalid
    //

    m_fMediaCapsCached = FALSE;

    //
    // Add a reference to ourselves in case somebody tries to
    // release the client object while we are tuning.
    //

    AddRef();
        
    //
    // Call the tuning wizard function
    //

    m_fTuning = TRUE;

    hr = RTCTuningWizard(
                    this, 
                    _Module.GetResourceInstance(), 
                    (HWND)hwndParent, 
                    pTerminalManage,  
                    &fAudioCapture,
                    &fAudioRender,
                    &fVideo
                    );

    m_fTuning = FALSE;

    if ( hr != S_OK )
    {
        LOG((RTC_ERROR, "CRTCClient::InvokeTuningWizard - "
                "RTCTuningWizard failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        Release();

        return hr;
    }

    //
    // Check the terminals
    //

    IRTCTerminal * pTerminal = NULL;

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );        

    if ( SUCCEEDED(hr) )
    {
        m_fAudioCaptureDisabled = fAudioCapture && ( pTerminal == NULL);  
        
        if ( pTerminal != NULL )
        {
            pTerminal->Release();
            pTerminal = NULL;
        }
    }

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_RENDER,                                            
                            &pTerminal
                            );        

    if ( SUCCEEDED(hr) )
    {
        m_fAudioRenderDisabled = fAudioRender && ( pTerminal == NULL);     
        
        if ( pTerminal != NULL )
        {
            pTerminal->Release();
            pTerminal = NULL;
        }
    }

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_VIDEO,
                            RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );        

    if ( SUCCEEDED(hr) )
    {
        m_fVideoCaptureDisabled = fVideo && ( pTerminal == NULL);   
        
        if ( pTerminal != NULL )
        {
            pTerminal->Release();
            pTerminal = NULL;
        }
    }
    
    pTerminalManage->Release();
    pTerminalManage = NULL;

    //
    // Store new terminal settings
    //

    hr = StoreDefaultTerminals();

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CRTCClient::InvokeTuningWizard - "
                "StoreDefaultTerminals failed 0x%lx", hr));

        Release();

        return hr;
    }

    m_fTuned = TRUE;

    put_RegistryDword( RTCRD_TUNED, 1 );

    //
    // Send an event
    //

    CRTCClientEvent::FireEvent(this, RTCCET_DEVICE_CHANGE);

    Release();

    LOG((RTC_TRACE, "CRTCClient::InvokeTuningWizard - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_IsTuned
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_IsTuned(
    VARIANT_BOOL * pfTuned
    )
{
    LOG((RTC_TRACE, "CRTCClient::get_IsTuned - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_IsTuned - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( pfTuned, sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_IsTuned - "
                            "bad VARIANT_BOOL pointer"));

        return E_POINTER;
    }

    *pfTuned = m_fTuned ? VARIANT_TRUE : VARIANT_FALSE;

    LOG((RTC_TRACE, "CRTCClient::get_IsTuned - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_NetworkQuality
//
// Returns a measure of the network quality (a combination of packet loss, jitter, 
// and others)
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_NetworkQuality(
    long * plNetworkQuality
    )
{
    HRESULT   hr;
    
    LOG((RTC_TRACE, "CRTCClient::get_NetworkQuality - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_NetworkQuality - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( plNetworkQuality, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_NetworkQuality - "
                            "bad long pointer"));

        return E_POINTER;
    }

    DWORD   dwValue;

    hr = m_pMediaManage->GetNetworkQuality(&dwValue);
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCClient::get_NetworkQuality - "
            "GetNetworkQuality with error 0x%x", hr));

        return hr;
    }

    *plNetworkQuality = (long)dwValue;
    
    LOG((RTC_TRACE, "CRTCClient::get_NetworkQuality - exit"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::GetAudioCfg
//
// This is a helper method to retreive IRTCAudioConfigure
//
/////////////////////////////////////////////////////////////////////////////
HRESULT
CRTCClient::GetAudioCfg(
        RTC_AUDIO_DEVICE enDevice,
        IRTCAudioConfigure ** ppAudioCfg
        )
{
    //LOG((RTC_TRACE, "CRTCClient::GetAudioCfg - enter"));

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTerminal       * pTerminal = NULL;
    HRESULT              hr;

    //
    // Check the arguments
    //

    if( (enDevice != RTCAD_SPEAKER) && 
        (enDevice != RTCAD_MICROPHONE) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetAudioCfg - "
                            "invalid audio device"));

        return E_INVALIDARG;
    }

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetAudioCfg - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminal
    //

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            (enDevice == RTCAD_SPEAKER) ? 
                                RTC_MD_RENDER : RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );

    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetAudioCfg - "
                            "GetDefaultTerminal failed 0x%lx", hr));

        return hr;
    }

    if ( pTerminal == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::GetAudioCfg - "
                        "NULL terminal"));

        return E_FAIL;
    }

    //
    // Get the IRTCAudioConfigure interface
    //

    hr = pTerminal->QueryInterface(
                   IID_IRTCAudioConfigure,
                   (void **)ppAudioCfg
                  );

    pTerminal->Release();
    pTerminal = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetAudioCfg - "
                            "QI(AudioConfigure) failed 0x%lx", hr));     

        return hr;
    }

    //LOG((RTC_TRACE, "CRTCClient::GetAudioCfg - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_Volume
//
// This is an IRTCClient method that will set the volume level of the
// speaker or microphone.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_Volume(
        RTC_AUDIO_DEVICE enDevice,
        long lVolume
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_Volume - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_Volume - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    IRTCAudioConfigure * pAudioCfg = NULL;
    HRESULT              hr;

    //
    // Get the IRTCAudioConfigure interface
    //

    hr = GetAudioCfg(
                     enDevice,
                     &pAudioCfg
                    );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_Volume - "
                            "GetAudioCfg failed 0x%lx", hr));     

        return hr;
    }

    //
    // Set the volume
    //

    hr = pAudioCfg->SetVolume( lVolume );

    pAudioCfg->Release();
    pAudioCfg = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_Volume - "
                            "SetVolume failed 0x%lx", hr));

    }

    LOG((RTC_TRACE, "CRTCClient::put_Volume - exit S_OK"));

    return S_OK;
}
 
/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_Volume
//
// This is an IRTCClient method that will return the volume level of the
// speaker or microphone.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_Volume(
        RTC_AUDIO_DEVICE enDevice,
        long * plVolume
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_Volume - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Volume - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( plVolume, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Volume - "
                            "bad long pointer"));

        return E_POINTER;
    }

    IRTCAudioConfigure * pAudioCfg = NULL;
    HRESULT              hr;

    //
    // Get the IRTCAudioConfigure interface
    //

    hr = GetAudioCfg(
                     enDevice,
                     &pAudioCfg
                    );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Volume - "
                            "GetAudioCfg failed 0x%lx", hr));     

        return hr;
    }

    //
    // Get the volume
    //

    UINT uiVolume;

    hr = pAudioCfg->GetVolume( &uiVolume );

    pAudioCfg->Release();
    pAudioCfg = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Volume - "
                            "GetVolume failed 0x%lx", hr));

        return hr;
    }

    *plVolume = uiVolume;

    LOG((RTC_TRACE, "CRTCClient::get_Volume - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_AudioMuted
//
// This is an IRTCClient method that will set the mute of the
// speaker or microphone.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_AudioMuted(
        RTC_AUDIO_DEVICE enDevice,
        VARIANT_BOOL fMuted
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_AudioMuted - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_AudioMuted - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    IRTCAudioConfigure * pAudioCfg = NULL;
    HRESULT              hr;

    //
    // Get the IRTCAudioConfigure interface
    //

    hr = GetAudioCfg(
                     enDevice,
                     &pAudioCfg
                    );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_AudioMuted - "
                            "GetAudioCfg failed 0x%lx", hr));     

        return hr;
    }

    //
    // Set the mute
    //

    hr = pAudioCfg->SetMute( fMuted ? TRUE : FALSE);

    pAudioCfg->Release();
    pAudioCfg = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_AudioMuted - "
                            "SetMute failed 0x%lx", hr));

        return hr;
    }
    
    //
    // Cache the mute state for microphone
    //
    if(enDevice == RTCAD_MICROPHONE)
    {
        m_bCaptureDeviceMuted = fMuted ? TRUE : FALSE;
    }

    //
    // Fire a volume change event
    //

    CRTCClientEvent::FireEvent(this, RTCCET_VOLUME_CHANGE);

    LOG((RTC_TRACE, "CRTCClient::put_AudioMuted - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_AudioMuted
//
// This is an IRTCClient method that will return the mute of the
// speaker or microphone.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_AudioMuted(
        RTC_AUDIO_DEVICE enDevice,
        VARIANT_BOOL * pfMuted
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_AudioMuted - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_AudioMuted - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( pfMuted, sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_AudioMuted - "
                            "bad VARIANT_BOOL pointer"));

        return E_POINTER;
    }

    IRTCAudioConfigure * pAudioCfg = NULL;
    HRESULT              hr;
    BOOL                 fMuted;

    //
    // Get the IRTCAudioConfigure interface
    //

    hr = GetAudioCfg(
                     enDevice,
                     &pAudioCfg
                    );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_AudioMuted - "
                            "GetAudioCfg failed 0x%lx", hr));     

        return hr;
    }

    //
    // Get the mute
    //

    hr = pAudioCfg->GetMute( &fMuted );

    pAudioCfg->Release();
    pAudioCfg = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_AudioMuted - "
                            "GetMute failed 0x%lx", hr));

        return hr;
    }

    //
    // Cache the mute state for microphone
    //
    if(enDevice == RTCAD_MICROPHONE)
    {
        m_bCaptureDeviceMuted = fMuted;
    }

    *pfMuted = fMuted ? VARIANT_TRUE : VARIANT_FALSE;

    LOG((RTC_TRACE, "CRTCClient::get_AudioMuted - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_IVideoWindow
//
// This is an IRTCClient method that will return the IVideoWindow interface
// for the receive or preview video window.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_IVideoWindow(
        RTC_VIDEO_DEVICE enDevice,
        IVideoWindow ** ppIVideoWindow
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_IVideoWindow - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_IVideoWindow - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    HRESULT hr;

    if ( IsBadWritePtr( ppIVideoWindow, sizeof(IVideoWindow *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_IVideoWindow - "
                            "bad IVideoWindow pointer"));

        return E_POINTER;
    }

    if ( (enDevice != RTCVD_PREVIEW) && (enDevice != RTCVD_RECEIVE) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_IVideoWindow - "
                            "invalid device argument"));

        return E_INVALIDARG;
    }

    LOG((RTC_INFO, "CRTCClient::get_IVideoWindow - [%s]",
                        (enDevice == RTCVD_PREVIEW) ? "PREVIEW" : "RECEIVE"));

    if ( m_pVideoWindow[enDevice] == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_IVideoWindow - "
                            "video window does not exist"));

        return E_FAIL;
    }

    //
    // Get the IVideoWIndow
    //

    *ppIVideoWindow = m_pVideoWindow[enDevice];
    m_pVideoWindow[enDevice]->AddRef();

    LOG((RTC_TRACE, "CRTCClient::get_IVideoWindow - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::GetTerminalList
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::GetTerminalList(
        IRTCTerminalManage * pTerminalManage,
        IRTCTerminal *** pppTerminals,
        DWORD * pdwCount
        )
{
    LOG((RTC_TRACE, "CRTCClient::GetTerminalList - enter"));

    HRESULT hr;

    //
    // Count the terminals
    //

    DWORD dwCount = 0;

    hr = pTerminalManage->GetStaticTerminals( &dwCount, NULL );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetTerminalList - "
                            "GetStaticTerminals failed 0x%lx", hr));
        return hr;
    }

    LOG((RTC_INFO, "CRTCClient::GetTerminalList - "
                            "%d static terminals", dwCount));

    IRTCTerminal ** ppTerminals = NULL;

    ppTerminals = (IRTCTerminal **)RtcAlloc( dwCount * sizeof(IRTCTerminal*) );

    if ( ppTerminals == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::GetTerminalList - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }
    
    //
    // Get the static terminals
    //

    hr = pTerminalManage->GetStaticTerminals( &dwCount, ppTerminals );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetTerminalList - "
                            "GetStaticTerminals failed 0x%lx", hr));

        RtcFree( ppTerminals );

        return hr;
    }

    *pppTerminals = ppTerminals;
    *pdwCount = dwCount;

    LOG((RTC_TRACE, "CRTCClient::GetTerminalList - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::FreeTerminalList
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::FreeTerminalList(
        IRTCTerminal ** ppTerminals,
        DWORD dwCount
        )
{
    LOG((RTC_TRACE, "CRTCClient::FreeTerminalList - enter"));

    for ( DWORD dw = 0; dw < dwCount; dw++ )
    {
        ppTerminals[dw]->Release();
        ppTerminals[dw] = NULL;
    }

    RtcFree( ppTerminals );

    LOG((RTC_TRACE, "CRTCClient::FreeTerminalList - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_PreferredAudioDevice
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_PreferredAudioDevice(
        RTC_AUDIO_DEVICE enDevice,
        BSTR  bstrDeviceName
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_PreferredAudioDevice - enter"));

    HRESULT hr;    

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if( (enDevice != RTCAD_SPEAKER) && 
        (enDevice != RTCAD_MICROPHONE) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                            "invalid audio device"));

        return E_INVALIDARG;
    }

    if ( IsBadStringPtrW( bstrDeviceName, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                            "bad string pointer"));

        return E_POINTER;
    }

    //
    // Get the IRTCTerminalManage interface
    //

    IRTCTerminalManage * pTerminalManage = NULL;

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the old terminal
    //

    IRTCTerminal * pOldTerminal = NULL;

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            (enDevice == RTCAD_SPEAKER) ? 
                                RTC_MD_RENDER : RTC_MD_CAPTURE,                                            
                            &pOldTerminal
                            );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                            "GetDefaultTerminal failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    //
    // Get the terminal list
    //

    IRTCTerminal ** ppTerminals = NULL;
    DWORD dwCount = 0;

    hr = GetTerminalList( pTerminalManage, &ppTerminals, &dwCount );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                            "GetTerminalList failed 0x%lx", hr));

        if (pOldTerminal != NULL)
        {
            pOldTerminal->Release();
            pOldTerminal = NULL;
        }

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    RTC_MEDIA_TYPE mt;
    RTC_MEDIA_DIRECTION md;
    WCHAR * szDescription;
    BOOL bFound = FALSE;

    for ( DWORD dw=0; (dw < dwCount) && !bFound; dw++ )
    {
        //
        // Get terminal media type, direction, and description
        //

        ppTerminals[dw]->GetMediaType( &mt );
        ppTerminals[dw]->GetDirection( &md );
        
        hr = ppTerminals[dw]->GetDescription( &szDescription );       

        if ( SUCCEEDED(hr) )
        {
            //
            // Is this terminal one which we want to select?
            //

            BOOL fSelect = FALSE;

            if ( mt == RTC_MT_AUDIO )
            {
                if ( ((md == RTC_MD_CAPTURE) && (enDevice == RTCAD_MICROPHONE)) ||
                     ((md == RTC_MD_RENDER) && (enDevice == RTCAD_SPEAKER)) )
                {
                    if ( wcscmp( bstrDeviceName, szDescription ) == 0 )
                    {
                        if ( ppTerminals[dw] == pOldTerminal )
                        {
                            LOG((RTC_INFO, "CRTCClient::put_PreferredAudioDevice - "
                                    "terminal already selected"));
                        }
                        else
                        {
                            LOG((RTC_INFO, "CRTCClient::put_PreferredAudioDevice - "
                                    "selecting a terminal"));

                            hr = pTerminalManage->SetDefaultStaticTerminal( mt, md, ppTerminals[dw] );

                            if ( FAILED(hr) )
                            {
                                LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                                                    "SetDefaultStaticTerminal failed 0x%lx", hr));
                            }
                            else
                            {
                                //
                                // Mark our cached media capabilities as invalid
                                //

                                m_fMediaCapsCached = FALSE;

                                if (enDevice == RTCAD_MICROPHONE)
                                {
                                    m_fAudioCaptureDisabled = FALSE;
                                }
                                else
                                {
                                    m_fAudioRenderDisabled = FALSE;
                                }

                                //
                                // Save the settings
                                //

                                hr = StoreDefaultTerminals();

                                if ( FAILED(hr) )
                                {
                                    LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                                                "StoreDefaultTerminals failed 0x%lx", hr));
                                }

                                //
                                // Send an event
                                //

                                CRTCClientEvent::FireEvent(this, RTCCET_DEVICE_CHANGE);
                            }
                        }

                        bFound = TRUE;
                    }
                }
            }

            //
            // Free the description
            //

            ppTerminals[dw]->FreeDescription( szDescription );    
        }
    }

    FreeTerminalList( ppTerminals, dwCount );
    ppTerminals = NULL;

    if (pOldTerminal != NULL)
    {
        pOldTerminal->Release();
        pOldTerminal = NULL;
    }

    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( !bFound )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                "terminal was not found"));

        return E_INVALIDARG;
    }

    LOG((RTC_TRACE, "CRTCClient::put_PreferredAudioDevice - exit 0x%lx"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_PreferredAudioDevice
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_PreferredAudioDevice(
        RTC_AUDIO_DEVICE enDevice,
        BSTR * pbstrDeviceName
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_PreferredAudioDevice - enter"));

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTerminal       * pTerminal = NULL;
    HRESULT              hr;

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( pbstrDeviceName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if( (enDevice != RTCAD_SPEAKER) && 
        (enDevice != RTCAD_MICROPHONE) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                            "invalid audio device"));

        return E_INVALIDARG;
    }

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminal
    //

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            (enDevice == RTCAD_SPEAKER) ? 
                                RTC_MD_RENDER : RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );

    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                            "GetDefaultTerminal failed 0x%lx", hr));

        return hr;
    }

    if ( pTerminal == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                        "NULL terminal"));

        return RTC_E_NO_DEVICE;
    }

    //
    // Get the description
    //

    WCHAR * szDescription = NULL;

    hr = pTerminal->GetDescription(
                       &szDescription
                      );
   
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                            "GetDescription failed 0x%lx", hr));     

        pTerminal->Release();
        pTerminal = NULL;

        return hr;
    }

    *pbstrDeviceName = SysAllocString( szDescription );

    pTerminal->FreeDescription( szDescription );
    szDescription = NULL;

    pTerminal->Release();
    pTerminal = NULL;

    if ( *pbstrDeviceName == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                            "out of memory")); 
        
        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCClient::get_PreferredAudioDevice - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_PreferredVolume
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_PreferredVolume(
        RTC_AUDIO_DEVICE enDevice,
        long  lVolume
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_PreferredVolume - enter"));

    HRESULT hr;

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTuningManage   * pTuningManage = NULL;
    IRTCTerminal       * pCapture = NULL;
    IRTCTerminal       * pRender = NULL;

    //
    // Check the arguments
    //

    if( (enDevice != RTCAD_SPEAKER) && 
        (enDevice != RTCAD_MICROPHONE) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVolume - "
                            "invalid audio device"));

        return E_INVALIDARG;
    }

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVolume - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVolume - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminals
    //

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_RENDER,                                            
                            &pRender
                            );    

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVolume - "
                            "GetDefaultTerminal(Render) failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_CAPTURE,                                            
                            &pCapture
                            );
    
    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVolume - "
                            "GetDefaultTerminal(Capture) failed 0x%lx", hr));

        if (pRender != NULL)
        {
            pRender->Release();
            pRender = NULL;
        }

        return hr;
    }

    //
    // Get the IRTCTuningManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTuningManage,
                           (void **)&pTuningManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVolume - "
                            "QI(TuningManage) failed 0x%lx", hr));

        if (pRender != NULL)
        {
            pRender->Release();
            pRender = NULL;
        }

        if (pCapture != NULL)
        {
            pCapture->Release();
            pCapture = NULL;
        }

        return hr;
    }

    //
    // Initialize Tuning
    //

    hr = pTuningManage->InitializeTuning(
                                pCapture,
                                pRender,
                                FALSE);

    if (pRender != NULL)
    {
        pRender->Release();
        pRender = NULL;
    }

    if (pCapture != NULL)
    {
        pCapture->Release();
        pCapture = NULL;
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVolume - "
                            "InitializeTuning failed 0x%lx", hr));

        pTuningManage->Release();
        pTuningManage = NULL;

        return hr;
    }

    //
    // Get the volume
    //

    hr = pTuningManage->SetVolume(
                            (enDevice == RTCAD_SPEAKER) ? 
                                RTC_MD_RENDER : RTC_MD_CAPTURE, 
                            (UINT)lVolume
                            );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVolume - "
                            "SetVolume failed 0x%lx", hr));
    }

    //
    // Shutdown Tuning
    //

    pTuningManage->ShutdownTuning();

    pTuningManage->Release();
    pTuningManage = NULL;

    LOG((RTC_TRACE, "CRTCClient::put_PreferredVolume - exit 0x%lx"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_PreferredVolume
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_PreferredVolume(
        RTC_AUDIO_DEVICE enDevice,
        long * plVolume
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_PreferredVolume - enter"));

    HRESULT hr;

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTuningManage   * pTuningManage = NULL;
    IRTCTerminal       * pCapture = NULL;
    IRTCTerminal       * pRender = NULL;
    UINT                 uiVolume = 0;

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVolume - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( plVolume, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                            "bad long pointer"));

        return E_POINTER;
    }

    if( (enDevice != RTCAD_SPEAKER) && 
        (enDevice != RTCAD_MICROPHONE) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVolume - "
                            "invalid audio device"));

        return E_INVALIDARG;
    }
    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVolume - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminals
    //

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_RENDER,                                            
                            &pRender
                            );    

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVolume - "
                            "GetDefaultTerminal(Render) failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_CAPTURE,                                            
                            &pCapture
                            );
    
    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVolume - "
                            "GetDefaultTerminal(Capture) failed 0x%lx", hr));

        if (pRender != NULL)
        {
            pRender->Release();
            pRender = NULL;
        }

        return hr;
    }

    //
    // Get the IRTCTuningManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTuningManage,
                           (void **)&pTuningManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVolume - "
                            "QI(TuningManage) failed 0x%lx", hr));

        if (pRender != NULL)
        {
            pRender->Release();
            pRender = NULL;
        }

        if (pCapture != NULL)
        {
            pCapture->Release();
            pCapture = NULL;
        }

        return hr;
    }

    //
    // Initialize Tuning
    //

    hr = pTuningManage->InitializeTuning(
                                pCapture,
                                pRender,
                                FALSE);

    if (pRender != NULL)
    {
        pRender->Release();
        pRender = NULL;
    }

    if (pCapture != NULL)
    {
        pCapture->Release();
        pCapture = NULL;
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVolume - "
                            "InitializeTuning failed 0x%lx", hr));

        pTuningManage->Release();
        pTuningManage = NULL;

        return hr;
    }

    //
    // Get the volume
    //

    hr = pTuningManage->GetVolume(
                            (enDevice == RTCAD_SPEAKER) ? 
                                RTC_MD_RENDER : RTC_MD_CAPTURE, 
                            &uiVolume
                            );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVolume - "
                            "GetVolume failed 0x%lx", hr));
    }
    else
    {
        *plVolume = (long)uiVolume;
    }

    //
    // Shutdown Tuning
    //

    pTuningManage->ShutdownTuning();

    pTuningManage->Release();
    pTuningManage = NULL;

    LOG((RTC_TRACE, "CRTCClient::get_PreferredVolume - exit 0x%lx"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_PreferredAEC
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_PreferredAEC(
        VARIANT_BOOL  bEnable
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_PreferredAEC - enter"));

    HRESULT hr;

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTuningManage   * pTuningManage = NULL;
    IRTCTerminal       * pCapture = NULL;
    IRTCTerminal       * pRender = NULL;

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAEC - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAEC - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminals
    //

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_RENDER,                                            
                            &pRender
                            );    

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAEC - "
                            "GetDefaultTerminal(Render) failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_CAPTURE,                                            
                            &pCapture
                            );
    
    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAEC - "
                            "GetDefaultTerminal(Capture) failed 0x%lx", hr));

        if (pRender != NULL)
        {
            pRender->Release();
            pRender = NULL;
        }

        return hr;
    }

    //
    // Get the IRTCTuningManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTuningManage,
                           (void **)&pTuningManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAEC - "
                            "QI(TuningManage) failed 0x%lx", hr));

        if (pRender != NULL)
        {
            pRender->Release();
            pRender = NULL;
        }

        if (pCapture != NULL)
        {
            pCapture->Release();
            pCapture = NULL;
        }

        return hr;
    }

    //
    // Initialize Tuning
    //

    hr = pTuningManage->InitializeTuning(
                                pCapture,
                                pRender,
                                bEnable ? TRUE : FALSE);

    if (pRender != NULL)
    {
        pRender->Release();
        pRender = NULL;
    }

    if (pCapture != NULL)
    {
        pCapture->Release();
        pCapture = NULL;
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAEC - "
                            "InitializeTuning failed 0x%lx", hr));

        pTuningManage->Release();
        pTuningManage = NULL;

        return hr;
    }

    //
    // Save AEC setting
    //

    hr = pTuningManage->SaveAECSetting();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAEC - "
                            "SaveAECSetting failed 0x%lx", hr));

        pTuningManage->ShutdownTuning();

        pTuningManage->Release();
        pTuningManage = NULL;

        return hr;
    }

    //
    // Shutdown Tuning
    //

    pTuningManage->ShutdownTuning();

    pTuningManage->Release();
    pTuningManage = NULL;

    LOG((RTC_TRACE, "CRTCClient::put_PreferredAEC - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_PreferredAEC
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_PreferredAEC(
        VARIANT_BOOL * pbEnabled
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_PreferredAEC - enter"));

    HRESULT hr;

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTuningManage   * pTuningManage = NULL;
    IRTCTerminal       * pCapture = NULL;
    IRTCTerminal       * pRender = NULL;
    BOOL                 fCaptureAEC = FALSE;
    BOOL                 fRenderAEC = FALSE;

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAEC - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( pbEnabled, sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAEC - "
                            "bad VARIANT_BOOL pointer"));

        return E_POINTER;
    }

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAEC - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminals
    //

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_RENDER,                                            
                            &pRender
                            );    

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAEC - "
                            "GetDefaultTerminal(Render) failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_CAPTURE,                                            
                            &pCapture
                            );
    
    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAEC - "
                            "GetDefaultTerminal(Capture) failed 0x%lx", hr));

        if (pRender != NULL)
        {
            pRender->Release();
            pRender = NULL;
        }

        return hr;
    }

    //
    // Get the IRTCTuningManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTuningManage,
                           (void **)&pTuningManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAEC - "
                            "QI(TuningManage) failed 0x%lx", hr));

        if (pRender != NULL)
        {
            pRender->Release();
            pRender = NULL;
        }

        if (pCapture != NULL)
        {
            pCapture->Release();
            pCapture = NULL;
        }

        return hr;
    }

    // Is AEC enabled?
    //

    if (pCapture != NULL && pRender != NULL)
    {
        hr = pTuningManage->IsAECEnabled(pCapture, pRender, &fCaptureAEC);

        fRenderAEC = fCaptureAEC;
    }

    //
    // release interface ptr
    //

    if (pCapture != NULL)
    {
        pCapture->Release();
        pCapture = NULL;
    }

    if (pRender != NULL)
    {
        pRender->Release();
        pRender = NULL;
    }

    pTuningManage->Release();
    pTuningManage = NULL;

    //
    // check result
    //

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAEC - "
                            "IsAECEnabled failed 0x%lx", hr));

        return hr;
    }

    *pbEnabled = ( fRenderAEC && fCaptureAEC ) ? VARIANT_TRUE : VARIANT_FALSE;

    LOG((RTC_TRACE, "CRTCClient::get_PreferredAEC - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_PreferredVideoDevice
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_PreferredVideoDevice(
        BSTR  bstrDeviceName
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_PreferredVideoDevice - enter"));

    HRESULT hr;    

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVideoDevice - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadStringPtrW( bstrDeviceName, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVideoDevice - "
                            "bad string pointer"));

        return E_POINTER;
    }

    //
    // Get the IRTCTerminalManage interface
    //

    IRTCTerminalManage * pTerminalManage = NULL;

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVideoDevice - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the old terminal
    //

    IRTCTerminal * pOldTerminal = NULL;

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_VIDEO,
                            RTC_MD_CAPTURE,                                            
                            &pOldTerminal
                            );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVideoDevice - "
                            "GetDefaultTerminal failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    //
    // Get the terminal list
    //

    IRTCTerminal ** ppTerminals = NULL;
    DWORD dwCount = 0;

    hr = GetTerminalList( pTerminalManage, &ppTerminals, &dwCount );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVideoDevice - "
                            "GetTerminalList failed 0x%lx", hr));

        if (pOldTerminal != NULL)
        {
            pOldTerminal->Release();
            pOldTerminal = NULL;
        }

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    RTC_MEDIA_TYPE mt;
    RTC_MEDIA_DIRECTION md;
    WCHAR * szDescription;
    BOOL bFound = FALSE;

    for ( DWORD dw=0; (dw < dwCount) && !bFound; dw++ )
    {
        //
        // Get terminal media type, direction, and description
        //

        ppTerminals[dw]->GetMediaType( &mt );
        ppTerminals[dw]->GetDirection( &md );
        
        hr = ppTerminals[dw]->GetDescription( &szDescription );       

        if ( SUCCEEDED(hr) )
        {
            //
            // Is this terminal one which we want to select?
            //

            BOOL fSelect = FALSE;

            if ( mt == RTC_MT_VIDEO )
            {
                if ( md == RTC_MD_CAPTURE )
                {
                    if ( wcscmp( bstrDeviceName, szDescription ) == 0 )
                    {
                        if ( ppTerminals[dw] == pOldTerminal )
                        {
                            LOG((RTC_INFO, "CRTCClient::put_PreferredVideoDevice - "
                                    "terminal already selected"));
                        }
                        else
                        {
                            LOG((RTC_INFO, "CRTCClient::put_PreferredVideoDevice - "
                                    "selecting a terminal"));

                            hr = pTerminalManage->SetDefaultStaticTerminal( mt, md, ppTerminals[dw] );

                            if ( FAILED(hr) )
                            {
                                LOG((RTC_ERROR, "CRTCClient::put_PreferredVideoDevice - "
                                                    "SetDefaultStaticTerminal failed 0x%lx", hr));
                            }
                            else
                            {
                                //
                                // Mark our cached media capabilities as invalid
                                //

                                m_fMediaCapsCached = FALSE;

                                m_fVideoCaptureDisabled = FALSE;

                                //
                                // Save the settings
                                //

                                hr = StoreDefaultTerminals();

                                if ( FAILED(hr) )
                                {
                                    LOG((RTC_ERROR, "CRTCClient::put_PreferredVideoDevice - "
                                                "StoreDefaultTerminals failed 0x%lx", hr));
                                }

                                //
                                // Send an event
                                //

                                CRTCClientEvent::FireEvent(this, RTCCET_DEVICE_CHANGE);
                            }
                        }

                        bFound = TRUE;
                    }
                }
            }

            //
            // Free the description
            //

            ppTerminals[dw]->FreeDescription( szDescription );    
        }
    }

    FreeTerminalList( ppTerminals, dwCount );
    ppTerminals = NULL;

    if (pOldTerminal != NULL)
    {
        pOldTerminal->Release();
        pOldTerminal = NULL;
    }

    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( !bFound )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVideoDevice - "
                "terminal was not found"));

        return E_INVALIDARG;
    }

    LOG((RTC_TRACE, "CRTCClient::put_PreferredVideoDevice - exit 0x%lx"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_PreferredVideoDevice
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_PreferredVideoDevice(
        BSTR * pbstrDeviceName
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_PreferredVideoDevice - enter"));

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTerminal       * pTerminal = NULL;
    HRESULT              hr;

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVideoDevice - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( pbstrDeviceName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVideoDevice - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVideoDevice - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminal
    //

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_VIDEO,
                            RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );

    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVideoDevice - "
                            "GetDefaultTerminal failed 0x%lx", hr));

        return hr;
    }

    if ( pTerminal == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVideoDevice - "
                        "NULL terminal"));

        return RTC_E_NO_DEVICE;
    }

    //
    // Get the description
    //

    WCHAR * szDescription = NULL;

    hr = pTerminal->GetDescription(
                       &szDescription
                      );
   
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVideoDevice - "
                            "GetDescription failed 0x%lx", hr));     

        pTerminal->Release();
        pTerminal = NULL;

        return hr;
    }

    *pbstrDeviceName = SysAllocString( szDescription );

    pTerminal->FreeDescription( szDescription );
    szDescription = NULL;

    pTerminal->Release();
    pTerminal = NULL;

    if ( *pbstrDeviceName == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVideoDevice - "
                            "out of memory")); 
        
        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCClient::get_PreferredVideoDevice - exit S_OK"));

    return S_OK;
}

          
/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_ActiveMedia
//
// This is a method that will return the media types for which
// streams currently exist.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_ActiveMedia(
        long * plMediaTypes
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_ActiveMedia - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_ActiveMedia - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( plMediaTypes, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_ActiveMedia - "
                            "bad long pointer"));

        return E_POINTER;
    }

    *plMediaTypes = m_lActiveMedia;

    LOG((RTC_TRACE, "CRTCClient::get_ActiveMedia - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_MaxBitrate
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_MaxBitrate(
        long * plMaxBitrate
        )
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CRTCClient::get_MaxBitrate - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_MaxBitrate - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( plMaxBitrate, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_MaxBitrate - "
                            "bad long pointer"));

        return E_POINTER;
    }

    DWORD   dwMaxBitrate;

    hr = m_pMediaManage->GetMaxBitrate(&dwMaxBitrate);
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCClient::get_MaxBitrate - "
            "GetMaxBitrate with error 0x%x", hr));

        return hr;
    }

    *plMaxBitrate = (long)dwMaxBitrate;

    LOG((RTC_TRACE, "CRTCClient::get_MaxBitrate - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_MaxBitrate
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_MaxBitrate(
        long lMaxBitrate
        )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::put_MaxBitrate - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_MaxBitrate - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    // valid range 0-1000000
    if(lMaxBitrate<0 || lMaxBitrate>1000000)
    {
        LOG((RTC_ERROR, "CRTCClient::put_MaxBitrate - "
            "Value not in range"));

        return E_INVALIDARG;
    }

    hr = m_pMediaManage->SetMaxBitrate((DWORD)lMaxBitrate);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCClient::put_MaxBitrate - "
            "SetMaxBitrate with error 0x%x", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::put_MaxBitrate - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_TemporalSpatialTradeOff
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_TemporalSpatialTradeOff(
        long * plValue
        )
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CRTCClient::get_TemporalSpatialTradeOff - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_TemporalSpatialTradeOff - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( plValue, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_TemporalSpatialTradeOff - "
                            "bad long pointer"));

        return E_POINTER;
    }

    DWORD   dwValue;

    hr = m_pMediaManage->GetTemporalSpatialTradeOff(&dwValue);
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCClient::get_TemporalSpatialTradeOff - "
            "GetTemporalSpatialTradeOff with error 0x%x", hr));

        return hr;
    }

    *plValue = (long)dwValue;

    LOG((RTC_TRACE, "CRTCClient::get_TemporalSpatialTradeOff - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_TemporalSpatialTradeOff
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_TemporalSpatialTradeOff(
        long lValue
        )
{
    HRESULT    hr;
    
    LOG((RTC_TRACE, "CRTCClient::put_TemporalSpatialTradeOff - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_TemporalSpatialTradeOff - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    // valid range 0-255
    if(lValue<0 || lValue>255)
    {
        LOG((RTC_ERROR, "CRTCClient::put_TemporalSpatialTradeOff - "
            "Value not in range"));

        return E_INVALIDARG;
    }

    hr = m_pMediaManage->SetTemporalSpatialTradeOff((DWORD)lValue);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCClient::put_TemporalSpatialTradeOff - "
            "SetTemporalSpatialTradeOff with error 0x%x", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::put_TemporalSpatialTradeOff - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnDTMFTimer
//
/////////////////////////////////////////////////////////////////////////////
void
CRTCClient::OnDTMFTimer()
{
    LOG((RTC_TRACE, "CRTCClient::OnDTMFTimer - enter"));

    HRESULT hr;

    LOG((RTC_INFO, "CRTCClient::OnDTMFTimer - packets to send %d",
            m_lInprogressDTMFPacketsToSend));

    if ( m_lInprogressDTMFPacketsToSend > 1 )
    {        
        hr = m_pMediaManage->SendDTMFEvent(
                        m_dwDTMFToneID,
                        (DWORD) m_enInprogressDTMF,
                        10, // volume
                        20,
                        FALSE
                        );
       
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::OnDTMFTimer - "
                                "SendDTMFEvent failed 0x%lx", hr));
        }
    }
    else
    {
        //
        // Kill the timer
        //

        KillTimer(m_hWnd, TID_DTMF_TIMER);

        //
        // Send the final packet
        //

        for (int i=0; i<3; i++)
        {
            hr = m_pMediaManage->SendDTMFEvent(
                            m_dwDTMFToneID,
                            (DWORD) m_enInprogressDTMF,
                            10, // volume
                            20,
                            TRUE
                            );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::OnDTMFTimer - "
                                    "SendDTMFEvent failed 0x%lx", hr));
            }
        }
    } 
    
    m_lInprogressDTMFPacketsToSend--;

    LOG((RTC_TRACE, "CRTCClient::OnDTMFTimer - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::SendDTMF
//
// This is an IRTCClient method that will send a DTMF to the active session
// and play a feedback tone using the wave player.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::SendDTMF(
        RTC_DTMF enDTMF
        )
{
    LOG((RTC_TRACE, "CRTCClient::SendDTMF - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    HRESULT hr;

    if ( !((enDTMF >= RTC_DTMF_0) && (enDTMF <= RTC_DTMF_FLASH)) )
    {
        LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                            "invalid DTMF argument"));

        return E_INVALIDARG;
    }

    if ( m_pMediaManage != NULL )
    {
        hr = m_pMediaManage->IsOutOfBandDTMFEnabled();

        if ( hr == S_OK )
        {
            //
            // For out of band DTMF we need to send 10 DTMF packets of 20ms length
            //

            if ( m_lInprogressDTMFPacketsToSend != 0 )
            {
                //
                // We have an existing DTMF in progress. We must end it now.
                //

                KillTimer(m_hWnd, TID_DTMF_TIMER);

                m_lInprogressDTMFPacketsToSend = 0;

                for (int i=0; i<3; i++)
                {
                    hr = m_pMediaManage->SendDTMFEvent(
                            m_dwDTMFToneID,
                            (DWORD) m_enInprogressDTMF,
                            10, // volume
                            20,
                            TRUE
                            );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                                            "SendDTMFEvent failed 0x%lx", hr));

                        return hr;
                    }
                }
            }

            //
            // Start the DTMF timer
            //
           
            DWORD dwID = (DWORD)SetTimer(m_hWnd, TID_DTMF_TIMER, 20, NULL);
            if (dwID==0)
            {                
                hr = HRESULT_FROM_WIN32(GetLastError());

                LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                               "SetTimer failed 0x%lx", hr));

                return hr;
            } 

            //
            // Send the first DTMF packet
            //             
            m_dwDTMFToneID ++;

            hr = m_pMediaManage->SendDTMFEvent(
                        m_dwDTMFToneID,
                        (DWORD) enDTMF,
                        10, // volume
                        20,
                        FALSE
                        );

            if ( FAILED(hr) )
            {               
                LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                                    "SendDTMFEvent failed 0x%lx", hr));

                return hr;
            }

            m_lInprogressDTMFPacketsToSend = 9;
            m_enInprogressDTMF = enDTMF;
        }
        else if ( hr == S_FALSE )
        {
            hr = m_pMediaManage->SendDTMFEvent(
                        m_dwDTMFToneID,
                        (DWORD) enDTMF,
                        10, // volume
                        100,
                        TRUE
                        );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                                    "SendDTMFEvent failed 0x%lx", hr));

                return hr;
            }
        }
        else
        {
            LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                                "IsOutOfBandDTMFEnabled failed 0x%lx", hr));

            return hr;
        }        
    }

    if ( !m_bCaptureDeviceMuted &&
         (enDTMF >= RTC_DTMF_0) && (enDTMF <= RTC_DTMF_D) )
    {
        //
        // We can play a feedback tone
        //

        if (m_pWavePlayerRenderTerminal != NULL)
        {
            hr = S_OK;

            if ( !m_pWavePlayerRenderTerminal->IsWaveDeviceOpen() )
            {
                IRTCAudioConfigure * pAudioCfg;

                hr = GetAudioCfg(
                         RTCAD_SPEAKER,
                         &pAudioCfg
                        );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                                        "GetAudioCfg(Render) failed 0x%lx", hr));     
                }
                else
                {
                    UINT uiWaveID;

                    hr = pAudioCfg->GetWaveID( &uiWaveID );

                    pAudioCfg->Release();
                    pAudioCfg = NULL;

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                                            "GetWaveID failed 0x%lx", hr));     
                    }
                    else
                    {
                        hr = m_pWavePlayerRenderTerminal->OpenWaveDevice(uiWaveID);

                        if ( FAILED(hr) )
                        {
                            LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                                                    "OpenWaveDevice failed 0x%lx", hr));
                        }
                    }
                }
            }

            if ( SUCCEEDED(hr) )
            {
                hr = m_pWavePlayerRenderTerminal->PlayWave( WAVE_TONE );   

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                                        "PlayWave failed 0x%lx", hr));
                }
            }
        }
    }

    LOG((RTC_TRACE, "CRTCClient::SendDTMF - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::PlayRing
//
// This is an IRTCClient method that will play a ring using the wave player.
//
//  bPlay == VARIANT_TRUE   --> Plays a ring
//  bPlay == VARIANT_FALSE  --> Stops any playing
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::PlayRing(RTC_RING_TYPE enType, VARIANT_BOOL bPlay)
{
    LOG((RTC_TRACE, "CRTCClient::Ring - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::Ring - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    HRESULT hr;

    switch (enType)
    {
    case RTCRT_PHONE:
    case RTCRT_MESSAGE:
        if (m_pWavePlayerSystemDefault == NULL)
        {
            LOG((RTC_ERROR, "CRTCClient::Ring - "
                                "wave player not created"));

            return E_FAIL;
        }

        if (bPlay)
        {
            if ( !m_pWavePlayerSystemDefault->IsWaveDeviceOpen() )
            {
                hr = m_pWavePlayerSystemDefault->OpenWaveDevice(WAVE_MAPPER);

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::Ring - "
                                            "OpenWaveDevice failed 0x%lx", hr));

                    return hr;
                }
            } 
        }
        break;

    case RTCRT_RINGBACK:
        if (m_pWavePlayerRenderTerminal == NULL)
        {
            LOG((RTC_ERROR, "CRTCClient::Ring - "
                                "wave player not created"));

            return E_FAIL;
        }

        if (bPlay)
        {
            if ( !m_pWavePlayerRenderTerminal->IsWaveDeviceOpen() )
            {
                hr = m_pWavePlayerRenderTerminal->OpenWaveDevice(WAVE_MAPPER);

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::Ring - "
                                            "OpenWaveDevice failed 0x%lx", hr));

                    return hr;
                }
            } 
        }
        break;

    default:
        LOG((RTC_ERROR, "CRTCClient::Ring - "
                            "invalid ring type"));

        return E_INVALIDARG;
    }

    if (bPlay)
    {
        switch (enType)
        {
        case RTCRT_PHONE:            
            hr = m_pWavePlayerSystemDefault->PlayWave( WAVE_RING );   
            break;

        case RTCRT_MESSAGE:
            hr = m_pWavePlayerSystemDefault->PlayWave( WAVE_MESSAGE );
            break;

        case RTCRT_RINGBACK:           
            hr = m_pWavePlayerRenderTerminal->PlayWave( WAVE_RINGBACK );   
            break;
        }

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::Ring - "
                                "PlayWave failed 0x%lx", hr));

            return hr;
        }
    }
    else
    {
        switch (enType)
        {
        case RTCRT_PHONE:
        case RTCRT_MESSAGE:
            hr = m_pWavePlayerSystemDefault->StopWave();
            break;

        case RTCRT_RINGBACK:
            hr = m_pWavePlayerRenderTerminal->StopWave();
            break;
        }

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::Ring - "
                                "StopWave failed 0x%lx", hr));

            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCClient::Ring - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::FireEvent
//
// This is a public helper method the fire events.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::FireEvent(   
             RTC_EVENT   enEvent,
             IDispatch  * pDispatch
            )
{
    HRESULT                   hr;

    //LOG((RTC_TRACE, "CRTCClient::FireEvent - enter"));

    //
    // Filter events
    //

    switch ( enEvent )
    {
    case RTCE_CLIENT:
        if ( !(m_lEventFilter & RTCEF_CLIENT) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_REGISTRATION_STATE_CHANGE:
        if ( !(m_lEventFilter & RTCEF_REGISTRATION_STATE_CHANGE) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_SESSION_STATE_CHANGE:
        if ( !(m_lEventFilter & RTCEF_SESSION_STATE_CHANGE) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_SESSION_OPERATION_COMPLETE:
        if ( !(m_lEventFilter & RTCEF_SESSION_OPERATION_COMPLETE) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_PARTICIPANT_STATE_CHANGE:
        if ( !(m_lEventFilter & RTCEF_PARTICIPANT_STATE_CHANGE) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_MEDIA:
        if ( !(m_lEventFilter & RTCEF_MEDIA) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_INTENSITY:
        if ( !(m_lEventFilter & RTCEF_INTENSITY) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_MESSAGING:
        if ( !(m_lEventFilter & RTCEF_MESSAGING) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_BUDDY:
        if ( !(m_lEventFilter & RTCEF_BUDDY) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_WATCHER:
        if ( !(m_lEventFilter & RTCEF_WATCHER) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_PROFILE:
        if ( !(m_lEventFilter & RTCEF_PROFILE) )
        {
            return S_FALSE;
        }
        break;

    default:
        return E_INVALIDARG;
    }

    //
    // Do the event callbacks
    //
    
    _FireEvent( enEvent, pDispatch );
    _FireDispatchEvent( enEvent, pDispatch );

    //LOG((RTC_TRACE, "CRTCClient::FireEvent - exit"));

    return S_OK;
}          

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::NotifyIPAddrChange
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::NotifyIPAddrChange()
{
    LOG((RTC_TRACE, "CRTCClient::NotifyIPAddrChange - enter"));

    RefreshPresenceSessions(TRUE);

#ifdef DUMP_PRESENCE
    DumpWatchers("CHANGE IP");
#endif

    LOG((RTC_TRACE, "CRTCClient::NotifyIPAddrChange - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::NotifyRegisterRedirect
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::NotifyRegisterRedirect( 
    SIP_PROVIDER_ID     *pSipProviderID,
    ISipRedirectContext *pRegisterContext,
    SIP_CALL_STATUS     *pRegisterStatus
    )
{
    LOG((RTC_TRACE, "CRTCClient::NotifyRegisterRedirect - enter"));

    //
    // Find the profile
    //

    HRESULT       hr;
    CRTCProfile * pCProfile = NULL;
    BOOL          fFound = FALSE;

    for ( int n=0; n < m_ProfileArray.GetSize(); n++ )
    {   
        GUID ProfileGuid; 

        pCProfile = static_cast<CRTCProfile *>(m_ProfileArray[n]);
                      
        pCProfile->GetGuid( &ProfileGuid );

        if ( IsEqualGUID( *pSipProviderID, ProfileGuid ) )
        {
            LOG((RTC_INFO, "CRTCClient::NotifyRegisterRedirect - "
                            "found profile [%p]", pCProfile));

            fFound = TRUE;

            break;
        }
    }

    if ( !fFound )
    {
        LOG((RTC_ERROR, "CRTCClient::NotifyRegisterRedirect - "
                                "profile not found"));

        return RTC_E_NO_PROFILE;
    }   

    hr = pCProfile->Redirect( pRegisterContext );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::NotifyRegisterRedirect - "
                            "Redirect failed 0x%lx", hr));

        return hr;
    }      

    LOG((RTC_TRACE, "CRTCClient::NotifyRegisterRedirect - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::NotifyProviderStatusChange
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::NotifyProviderStatusChange(
        SIP_PROVIDER_STATUS * ProviderStatus
        )
{
    LOG((RTC_TRACE, "CRTCClient::NotifyProviderStatusChange - enter"));      

    HRESULT       hr = S_OK;
    CRTCProfile * pCProfile = NULL;
    BOOL          fFound = FALSE;

    for ( int n=0; n < m_HiddenProfileArray.GetSize(); n++ )
    {        
        GUID ProfileGuid; 

        pCProfile = static_cast<CRTCProfile *>(m_HiddenProfileArray[n]);
                      
        pCProfile->GetGuid( &ProfileGuid );

        if ( IsEqualGUID( ProviderStatus->ProviderID, ProfileGuid ) )
        {
            LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                            "found hidden profile [%p]", pCProfile));

            fFound = TRUE;

            break;
        }
    }

    if ( !fFound )
    {
        for ( int n=0; n < m_ProfileArray.GetSize(); n++ )
        {        
            GUID ProfileGuid; 

            pCProfile = static_cast<CRTCProfile *>(m_ProfileArray[n]);
                      
            pCProfile->GetGuid( &ProfileGuid );

            if ( IsEqualGUID( ProviderStatus->ProviderID, ProfileGuid ) )
            {
                LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "found profile [%p]", pCProfile));

                fFound = TRUE;

                break;
            }
        }
    }

    if ( !fFound )
    {
        LOG((RTC_ERROR, "CRTCClient::NotifyProviderStatusChange - "
                                "profile not found"));

        return RTC_E_NO_PROFILE;
    }       

    pCProfile->AddRef();

    switch( ProviderStatus->RegisterState )
    {
    case REGISTER_STATE_NONE:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_NONE"));

        break;

    case REGISTER_STATE_REGISTERED:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_REGISTERED"));

        hr = pCProfile->SetState( RTCRS_REGISTERED,
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );

        break;

    case REGISTER_STATE_UNREGISTERING:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_UNREGISTERING"));       

        hr = pCProfile->SetState( RTCRS_UNREGISTERING,
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );

        break;

    case REGISTER_STATE_UNREGISTERED:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_UNREGISTERED"));

        hr = pCProfile->SetState( RTCRS_NOT_REGISTERED,
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );
        
        break;

    case REGISTER_STATE_REGISTERING:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_REGISTERING"));

        hr = pCProfile->SetState( RTCRS_REGISTERING, 
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );

        break;        

    case REGISTER_STATE_REJECTED:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_REJECTED"));

        hr = pCProfile->SetState( RTCRS_REJECTED, 
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );

        break;

    case REGISTER_STATE_ERROR:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_ERROR"));

        hr = pCProfile->SetState( RTCRS_ERROR, 
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );

        break;

    case REGISTER_STATE_DEREGISTERED:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_DEREGISTERED"));

        hr = pCProfile->SetState( RTCRS_LOGGED_OFF,
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );
        break;

    case REGISTER_STATE_DROPSUB:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_DROPSUB"));

        hr = pCProfile->SetState( RTCRS_LOCAL_PA_LOGGED_OFF,
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );

        break;

    case REGISTER_STATE_PALOGGEDOFF:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_PALOGGEDOFF"));

        hr = pCProfile->SetState( RTCRS_REMOTE_PA_LOGGED_OFF,
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );
        
        break;

    default:
        LOG((RTC_ERROR, "CRTCClient::NotifyProviderStatusChange - "
                    "invalid REGISTER_STATE"));
    
        pCProfile->Release();
        return E_FAIL;
    }
    
    pCProfile->Release();
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::NotifyProviderStatusChange - "
                            "SetState failed 0x%lx", hr));

        return hr;
    } 

    LOG((RTC_TRACE, "CRTCClient::NotifyProviderStatusChange - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OfferCall
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::OfferCall(
        ISipCall       * Call,
        SIP_PARTY_INFO * CallerInfo
        )
{
    LOG((RTC_TRACE, "CRTCClient::OfferCall - enter"));

    HRESULT hr;

    //
    // Verify whether the incoming call is authorized
    //
    if(!IsIncomingSessionAuthorized(CallerInfo->URI))
    {
        hr = Call->Reject( 480 );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::OfferCall - "
                "Reject failed 0x%lx", hr));
    
            return hr;
        }

        return S_OK;
    }

    //
    // Create the session
    //

    IRTCSession * pSession = NULL;
    
    hr = InternalCreateSession( 
                               &pSession
                              );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OfferCall - "
                            "InternalCreateSession failed 0x%lx", hr));
    
        return hr;
    }   
    
    //
    // Initialize the session
    //

    CRTCSession * pCSession = NULL;

    pCSession = static_cast<CRTCSession *>(pSession);
    
    hr = pCSession->InitializeIncoming(
                               this,                            
                               Call,                            
                               CallerInfo
                              );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OfferCall - "
                            "Initialize failed 0x%lx", hr));

        
        pSession->Release();        
        
        return hr;
    }  
   
    // Release the pointer, don't need it any more
    pSession -> Release();

    LOG((RTC_TRACE, "CRTCClient::OfferCall - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::NotifyIncomingSession
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::NotifyIncomingSession(
        IIMSession     * pIMSession,
        BSTR             msg,
        BSTR             ContentType,
        SIP_PARTY_INFO * CallerInfo
        )
{
    LOG((RTC_TRACE, "CRTCClient::NotifyIncomingSession - enter"));

    HRESULT hr;
    
    //
    // Create the session
    //

    IRTCSession * pSession = NULL;
    
    hr = InternalCreateSession( 
                               &pSession
                              );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::NotifyIncomingSession - "
                            "InternalCreateSession failed 0x%lx", hr));
    
        return hr;
    }   
    
    //
    // Initialize the session
    //

    CRTCSession * pCSession = NULL;

    pCSession = static_cast<CRTCSession *>(pSession);
    
    hr = pCSession->InitializeIncomingIM(
                               this,
                               m_pSipStack,
                               pIMSession,  
                               msg,
                               ContentType,
                               CallerInfo
                              );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::NotifyIncomingSession - "
                            "Initialize failed 0x%lx", hr));

        
        pSession->Release();        
        
        return hr;
    }  
   
    // Release the pointer, don't need it any more
    pSession -> Release();

    LOG((RTC_TRACE, "CRTCClient::NotifyIncomingSession - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::IsIMSessionAuthorized
//
// Called by SIP IM part before NotifyIncomingSession
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::IsIMSessionAuthorized(
    BSTR pszCallerURI,
    BOOL  * bAuthorized)
{
    LOG((RTC_TRACE, "CRTCClient::IsIMSessionAuthorized - enter"));

    *bAuthorized = IsIncomingSessionAuthorized(pszCallerURI);

    LOG((RTC_TRACE, "CRTCClient::IsIMSessionAuthorized - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::GetCredentialsFromUI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::GetCredentialsFromUI(
    IN  SIP_PROVIDER_ID        *pProviderID,
    IN  BSTR               Realm,
    IN OUT BSTR           *Username,
    OUT BSTR              *Password        
    )
{
    LOG((RTC_TRACE, "CRTCSession::GetCredentialsFromUI - not implemented.."));

    // equivalent to selecting Cancel
    return E_ABORT;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::GetCredentialsForRealm
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::GetCredentialsForRealm(
    IN  BSTR                 Realm,
    OUT BSTR                *Username,
    OUT BSTR                *Password,
    OUT SIP_AUTH_PROTOCOL   *pAuthProtocol
    )
{
    LOG((RTC_TRACE, "CRTCClient::GetCredentialsForRealm - Enter"));

    //
    // Find the profile
    //

    HRESULT       hr;
    CRTCProfile * pCProfile = NULL;
    BOOL          fFound = FALSE;

    for ( int n=0; n < m_ProfileArray.GetSize(); n++ )
    {   
        BSTR bstrRealm;

        pCProfile = static_cast<CRTCProfile *>(m_ProfileArray[n]);
                      
        hr = pCProfile->GetRealm( &bstrRealm );

        if ( SUCCEEDED(hr) )
        {
            if ( _wcsicmp( Realm, bstrRealm ) == 0 )
            {
                LOG((RTC_INFO, "CRTCClient::GetCredentialsForRealm - "
                            "found profile [%p]", pCProfile));

                SysFreeString( bstrRealm );
                fFound = TRUE;

                break;
            }

            SysFreeString( bstrRealm );
        }
    }

    if ( !fFound )
    {
        LOG((RTC_ERROR, "CRTCClient::GetCredentialsForRealm - "
                                "profile not found"));

        return RTC_E_NO_PROFILE;
    }      

    hr = pCProfile->GetCredentials( Username, Password, pAuthProtocol );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetCredentialsForRealm - "
                            "GetCredentials failed 0x%lx", hr));

        return hr;
    } 

    LOG((RTC_TRACE, "CRTCClient::GetCredentialsForRealm - Exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OfferWatcher
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::OfferWatcher(
        ISIPWatcher    * Watcher,
        SIP_PARTY_INFO * CallerInfo
        )
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CRTCClient::OfferWatcher - enter"));
   
    if(!m_pSipWatcherManager)
    {
        // watchers are not enabled.
        // simply ignore the notification...
        LOG((RTC_WARN, "CRTCClient::OfferWatcher - watchers not expected, exiting..."));

        // should I put an error here ?
        return S_OK;
    }

    //
    // Search for this watcher in the internal list
    // 

    IRTCWatcher * pWatcher = NULL;

    hr = FindWatcherByURI(
        CallerInfo->URI,
        FALSE,
        &pWatcher);


    // There are two cases:
    //
    //   A. A watcher object is not found 
    //      
    //      A new CRTCWatcher is created (or reused from the hidden list)
    //   and added to the array
    //     
    //      A.1 Prompt Mode == RTCOWM_OFFER_WATCHER_EVENT
    //            CRTCWatcher is set to RTCWS_OFFERING mode
    //            The offered SIP watcher is added to CRTCWatcher
    //            IRTCWatcherEvent event is fired
    //      
    //      A.2 Prompt Mode == RTCOWM_AUTOMATICALLY_ADD_WATCHER
    //            CRTCWatcher is set to RTCWS_ALLOWED mode
    //            Any other SIP watcher is set to WATCHER_UNBLOCKED (very important !)
    //            The offered SIP watcher is added to CRTCWatcher and approved
    //
    //   B. A watcher object is found
    //            
    //      B.1 CRTCWatcher state == RTCWS_OFFERING
    //            The offered SIP watcher is added to CRTCWatcher.
    //
    //      B.2 CRTCWatcher state == RTCWS_ALLOWED
    //            The offered SIP watcher is added to CRTCWatcher and approved
    //  
    //      B.3 CRTCWatcher state == RTCWS_BLOCKED
    //            The offered SIP watcher is added to CRTCWatcher and rejected
    //
    
    if(hr != S_OK)
    {
        //
        // Create a watcher object
        //  This helper function also knows how to reuse a watcher from the hidden list    
        //

        hr = InternalCreateWatcher(
            CallerInfo->URI,
            CallerInfo->DisplayName,
            NULL,
            NULL,
            TRUE,   // persistent by default
            &pWatcher);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::OfferWatcher - InternalCreateWatcher failed 0x%lx", hr));

            return hr;
        }
        
        //
        // Add it to the array
        //
        
        BOOL fResult;

        fResult = m_WatcherArray.Add(pWatcher);

        if ( fResult == FALSE )
        {
            LOG((RTC_ERROR, "CRTCClient::OfferWatcher - "
                                    "out of memory"));
    
            pWatcher->Release();
            return E_OUTOFMEMORY;
        }
 
        //
        // Set the SIP Watcher
        //
        CRTCWatcher *pCWatcher = static_cast<CRTCWatcher *>(pWatcher);

        pCWatcher->m_bPersistent = TRUE;

        hr = pCWatcher->SetSIPWatcher(Watcher );

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCWatcher::OfferWatcher: "
                    "SetSIPWatcher failed: x%x.", hr));

            // if there's no SIP watcher in *pCWatcher, delete the entry
            if(pCWatcher->m_SIPWatchers.GetSize()==0)
            {
                m_WatcherArray.Remove(pWatcher);
            }

            pWatcher->Release();
            return hr;
        }

    
        if(m_nOfferWatcherMode == RTCOWM_OFFER_WATCHER_EVENT)
        {
            //
            // Set the watcher to OFFERING mode
            //
            pCWatcher->m_nState = RTCWS_OFFERING;

#ifdef DUMP_PRESENCE
            DumpWatchers("OFFER WATCHER (BLOCKING)");
#endif

            LOG((RTC_TRACE, "CRTCClient::OfferWatcher - firing event - may block for some time"));        

            CRTCWatcherEvent::FireEvent(this, pWatcher);

            hr = S_OK;
        }
        else
        {
            //
            // Set the watcher to ALLOWED mode
            //

            pCWatcher->m_nState = RTCWS_ALLOWED;

            //
            // Approve the offered watcher
            //
        
            hr = Watcher->ApproveSubscription(0);

            if(SUCCEEDED(hr))
            {
                //
                // Change the SIP watchers to ALLOWED status
                //  This updates all SIP watchers corresponding to 
                // the current core watcher
                //
                pCWatcher->ChangeBlockedStatus(WATCHER_UNBLOCKED);

                // update the storage
                UpdatePresenceStorage();
            }
            else
            {
                LOG((RTC_ERROR, "CRTCClient::OfferWatcher: "
                     "ApproveSubscription failed: x%x.", hr));
                
                // if there's no SIP watcher in *pCWatcher, delete the entry
                if(pCWatcher->m_SIPWatchers.GetSize()==0)
                {
                    m_WatcherArray.Remove(pWatcher);
                }

                pWatcher->Release();
                return hr;
            }
        }

        pWatcher->Release();
        pWatcher = NULL;
    }
    else
    {
        // found an entry the internal list
        
        CRTCWatcher *pCWatcher = static_cast<CRTCWatcher *>(pWatcher);

        //
        // Add the ISIPWatcher pointer to our watcher object
        //

        hr = pCWatcher->SetSIPWatcher(Watcher);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCWatcher::OfferWatcher: "
                    "SetSIPWatcher failed: x%x.", hr));
        }

        pWatcher->Release();
        pWatcher = NULL;

        switch(pCWatcher->m_nState)
        {
        case RTCWS_OFFERING:
            // The UI is still displayed..
            //
            // We ignore this silently
        
            LOG((RTC_INFO, "CRTCClient::OfferWatcher - There's already an OFFERING watcher"));

            hr = S_OK;
            break;
        
        case RTCWS_BLOCKED:  
            
            LOG((RTC_INFO, "CRTCClient::OfferWatcher - automatically rejecting watcher"));
            
            hr = Watcher->RejectSubscription(REJECT_REASON_NONE);
             
            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "CRTCWatcher::OfferWatcher: "
                        "RejectSubscription failed: x%x.", hr));
            }
            break;

        case RTCWS_ALLOWED:

            LOG((RTC_INFO, "CRTCClient::OfferWatcher - automatically approving watcher"));
        
            hr = Watcher->ApproveSubscription(0);

            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "CRTCWatcher::put_State: "
                     "ApproveSubscription failed: x%x.", hr));
            }
            
            break;
        
        default:
            
            LOG((RTC_ERROR, "CRTCWatcher::OfferWatcher: "
                "Invalid watcher state, exiting"));

            hr = E_FAIL;
            break;
        }
    }

#ifdef DUMP_PRESENCE
    DumpWatchers("OFFER WATCHER");
#endif
    
    LOG((RTC_TRACE, "CRTCClient::OfferWatcher - exit S_OK"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::WatcherOffline
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::WatcherOffline(
    ISIPWatcher    *pSipWatcher,
    WCHAR* pwstrPresentityURI
    )
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CRTCClient::WatcherOffline - enter"));
    
    //
    // Search for this watcher in the internal list
    // 

    IRTCWatcher * pWatcher = NULL;

    hr = FindWatcherByURI(
        pwstrPresentityURI,
        FALSE,
        &pWatcher);

    if(hr == S_OK)
    {
        // found in the internal list
        
        CRTCWatcher *pCWatcher = static_cast<CRTCWatcher *>(pWatcher);

        pCWatcher->RemoveSIPWatcher(pSipWatcher, FALSE );

        pWatcher->Release();
        pWatcher = NULL;
    }
    else
    {
        // try the hidden list
        hr = FindWatcherByURI(
            pwstrPresentityURI,
            TRUE,
            &pWatcher);

        if(hr == S_OK)
        {

            CRTCWatcher *pCWatcher = static_cast<CRTCWatcher *>(pWatcher);

            pCWatcher->RemoveSIPWatcher(pSipWatcher, FALSE );
        
            //
            // Clean the hidden list of the entries without any SIP watcher
            //
            if(pCWatcher->m_SIPWatchers.GetSize() == 0)
            {
                m_HiddenWatcherArray.Remove(pWatcher);
            }

            pWatcher->Release();
            pWatcher = NULL;
        }
    }   

#ifdef DUMP_PRESENCE
    DumpWatchers("WATCHER OFFLINE");
#endif

    LOG((RTC_TRACE, "CRTCClient::WatcherOffline - exit"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::NotifyShutdownReady
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::NotifyShutdownReady()
{
    LOG((RTC_TRACE, "CRTCClient::NotifyShutdownReady - enter"));

    if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN3 )
    {
        InternalReadyForShutdown();
    }    

    LOG((RTC_TRACE, "CRTCClient::NotifyShutdownReady - exit"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalCreateWatcher
//
/////////////////////////////////////////////////////////////////////////////
HRESULT
CRTCClient::InternalCreateWatcher(
            PCWSTR  szPresentityURI,
            PCWSTR  szUserName,
            PCWSTR  szData,
            PCWSTR  szShutdownBlob,
            BOOL    bPersistent,
            IRTCWatcher ** ppWatcher
            )
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CRTCClient::InternalCreateWatcher - enter"));

    // try to reuse elements from the hidden list first hidden list
    IRTCWatcher * pWatcher = NULL;
    CComObject<CRTCWatcher> * pCWatcher;

    hr = FindWatcherByURI(
        szPresentityURI,
        TRUE,
        &pWatcher);

    if(hr == S_OK)
    {
        // reuse that entry
        pCWatcher = static_cast<CComObject<CRTCWatcher> *>(pWatcher);

        m_HiddenWatcherArray.Remove(pWatcher);
    }
    else
    {
        
        hr = CComObject<CRTCWatcher>::CreateInstance( &pCWatcher );

        if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
        {
            LOG((RTC_ERROR, "CRTCClient::InternalCreateWatcher - CreateInstance failed 0x%lx", hr));

            if ( hr == S_FALSE )
            {
                hr = E_FAIL;
            }
            return hr;
        }

        //
        // Get the IRTCWatcher interface
        //
 
        hr = pCWatcher->QueryInterface(
                               IID_IRTCWatcher,
                               (void **)&pWatcher
                              );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::InternalCreateWatcher - QI failed 0x%lx", hr));
        
            delete pCWatcher;
            return hr;
        }
    }

    //
    // Initialize the watcher
    //

    hr = pCWatcher->Initialize( 
        this,
        m_pSipWatcherManager,
        szPresentityURI,
        szUserName,
        szData,
        szShutdownBlob,
        bPersistent
        );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateWatcher - "
                                "Initialize failed 0x%lx", hr));

        pWatcher->Release();
        return hr;
    }

    *ppWatcher = pWatcher;

    LOG((RTC_TRACE, "CRTCClient::InternalCreateWatcher - enter"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalCreateBuddy
//
/////////////////////////////////////////////////////////////////////////////
HRESULT
CRTCClient::InternalCreateBuddy(
            PCWSTR  szPresentityURI,
            PCWSTR  szUserName,
            PCWSTR  szData,
            BOOL    bPersistent,
            IRTCProfile * pProfile,
            long lFlags,
            IRTCBuddy ** ppBuddy
            )
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CRTCClient::InternalCreateBuddy - enter"));

    CComObject<CRTCBuddy> * pCBuddy;
    hr = CComObject<CRTCBuddy>::CreateInstance( &pCBuddy );


    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateBuddy - CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        return hr;
    }

    //
    // Get the IRTCBuddy interface
    //

    IRTCBuddy * pBuddy = NULL;

    hr = pCBuddy->QueryInterface(
                           IID_IRTCBuddy,
                           (void **)&pBuddy
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateBuddy - QI failed 0x%lx", hr));
        
        delete pCBuddy;
        return hr;
    }

    //
    // Initialize the buddy
    //

    hr = pCBuddy->Initialize( 
        this,
        m_pSipBuddyManager,
        szPresentityURI,
        szUserName,
        szData,
        bPersistent,
        pProfile,
        lFlags
        );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateBuddy - "
                                "Initialize failed 0x%lx", hr));

        pBuddy->Release();
        return hr;
    }

    *ppBuddy = pBuddy;

    LOG((RTC_TRACE, "CRTCClient::InternalCreateBuddy - enter"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::FindWatcherByURI
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::FindWatcherByURI(
    IN  LPCWSTR                  lpwstrPresentityURI,
    IN  BOOL                    bHidden,
    OUT IRTCWatcher            **ppWatcher
    )
{
    INT             iIndex;
    IRTCWatcher    *pWatcher = NULL;
    
    if ( IsBadWritePtr( ppWatcher, sizeof(IRTCWatcher *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::FindWatcherByURI - "
                            "bad IRTCWatcher* pointer"));

        return E_POINTER;
    } 

    *ppWatcher = NULL;

    CRTCObjectArray<IRTCWatcher *> *pArray = bHidden ? &m_HiddenWatcherArray : &m_WatcherArray;
    
    for( iIndex=0; iIndex < pArray->GetSize(); iIndex++ )
    {
        pWatcher = (*pArray)[iIndex];
        
        if( pWatcher != NULL )
        {
            CRTCWatcher *pCWatcher = static_cast<CRTCWatcher *>(pWatcher);

            if(IsEqualURI( pCWatcher->m_szPresentityURI, lpwstrPresentityURI ) )
            {
                *ppWatcher =  pWatcher;
                (*ppWatcher)->AddRef();
                return S_OK;
            }
        }
    }

    return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::FindBuddyByURI
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::FindBuddyByURI(
    IN  LPWSTR                  lpwstrPresentityURI,
    OUT IRTCBuddy            ** ppBuddy
    )
{
    INT             iIndex;
    IRTCBuddy     * pBuddy = NULL;

    if ( IsBadWritePtr( ppBuddy, sizeof(IRTCBuddy*) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::FindBuddyByURI - "
                            "bad IRTCBuddy* pointer"));

        return E_POINTER;
    } 

    *ppBuddy = NULL;
    
    for( iIndex=0; iIndex < m_BuddyArray.GetSize(); iIndex++ )
    {
        pBuddy = m_BuddyArray[iIndex];
        
        if( pBuddy != NULL )
        {
            CRTCBuddy *pCBuddy = static_cast<CRTCBuddy *>(pBuddy);

            if( IsEqualURI( pCBuddy->m_szPresentityURI, lpwstrPresentityURI ) )
            {
                *ppBuddy =  pBuddy;
                (*ppBuddy)->AddRef();
                return S_OK;
            }
        }
    }

    return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::RefreshPresenceSessions
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCClient::RefreshPresenceSessions(
    BOOL bIncludingWatchers)
{
    LOG((RTC_TRACE, "CRTCClient::RefreshPresenceSessions - enter"));

    //
    // Unsubscribe the SIP watchers
    //

    if ( bIncludingWatchers && m_pSipWatcherManager != NULL )
    { 
        CRTCWatcher * pCWatcher = NULL;

        for (int n = 0; n < m_WatcherArray.GetSize(); n++)
        {
            pCWatcher = reinterpret_cast<CRTCWatcher *>(m_WatcherArray[n]);

            if ( pCWatcher )
            {
                pCWatcher->RemoveSIPWatchers(FALSE);                   
            }
        }
        for (int n = 0; n < m_HiddenWatcherArray.GetSize(); n++)
        {
            pCWatcher = reinterpret_cast<CRTCWatcher *>(m_HiddenWatcherArray[n]);

            if ( pCWatcher )
            {
                pCWatcher->RemoveSIPWatchers(FALSE);                   
            }
        }
    }

    //
    // Re-subscribe the SIP buddies
    //

    if ( m_pSipBuddyManager != NULL )
    { 
        CRTCBuddy * pCBuddy = NULL;

        for (int n = 0; n < m_BuddyArray.GetSize(); n++)
        {
            pCBuddy = reinterpret_cast<CRTCBuddy *>(m_BuddyArray[n]);

            if ( pCBuddy )
            {                
                pCBuddy->BuddyUnsubscribed();      
            }
        }
    }

    LOG((RTC_TRACE, "CRTCClient::RefreshPresenceSessions - exit"));
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_LocalUserURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_LocalUserURI(
        BSTR * pbstrUserURI
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_LocalUserURI - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_LocalUserURI - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( pbstrUserURI, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_LocalUserURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szUserURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_LocalUserURI - "
                            "no local user URI"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrUserURI = SysAllocString(m_szUserURI);

    if ( *pbstrUserURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_LocalUserURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCClient::get_LocalUserURI - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_LocalUserURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_LocalUserURI(
        BSTR bstrUserURI
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_LocalUserURI - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_LocalUserURI - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    HRESULT hr;

    if ( IsBadStringPtrW( bstrUserURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_LocalUserURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szUserURI != NULL )
    {
        RtcFree( m_szUserURI );
        m_szUserURI = NULL;
    }

    hr = AllocCleanSipString( bstrUserURI, &m_szUserURI );  

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_LocalUserURI - "
                            "AllocCleanSipString failed 0x%lx", hr));

        return hr;
    }    
    
    // this URI is used in presence only when a profile is not used
    // so we don't update any outgoing subscriptions here

    LOG((RTC_TRACE, "CRTCClient::put_LocalUserURI - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_LocalUserName
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_LocalUserName(
        BSTR * pbstrUserName
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_LocalUserName - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_LocalUserName - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( pbstrUserName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_LocalUserName - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szUserName == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_LocalUserName - "
                            "no local user URI"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrUserName = SysAllocString(m_szUserName);

    if ( *pbstrUserName == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_LocalUserName - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCClient::get_LocalUserName - exit S_OK"));

    return S_OK;
}   

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_LocalUserName
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_LocalUserName(
        BSTR bstrUserName
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_LocalUserName - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_LocalUserName - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadStringPtrW( bstrUserName, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_LocalUserName - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szUserName != NULL )
    {
        RtcFree( m_szUserName );
        m_szUserName = NULL;
    }

    m_szUserName = RtcAllocString( bstrUserName );    

    if ( m_szUserName == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::put_LocalUserName - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    

   // refresh the outgoing subscriptions
    RefreshPresenceSessions(FALSE);

    LOG((RTC_TRACE, "CRTCClient::put_LocalUserName - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::StartT120Applet
//
// Start Netmeeting T120 Applets
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::StartT120Applet(
        RTC_T120_APPLET enApplet
        )
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCClient::StartT120Applet - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::StartT120Applet - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    _ASSERT (m_pMediaManage != NULL);

    UINT uiAppletID;

    switch ( enApplet )
    {
    case RTCTA_WHITEBOARD:
        uiAppletID = NM_APPID_T126_WHITEBOARD;
        break;

    case RTCTA_APPSHARING:
        uiAppletID = NM_APPID_APPSHARING;
        break;

    default:
        LOG((RTC_ERROR, "CRTCClient::StartT120Applet - invalid argument"));

        return E_INVALIDARG;
    }

    if (hr = m_pMediaManage->StartT120Applet(uiAppletID))
    {
        LOG((RTC_ERROR, "CRTCClient::StartT120Applet - StartT120Applet failed 0x%lx", hr));
        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::StartT120Applet - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::StopT120Applets
//
// Stop Netmeeting T120 Applets
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::StopT120Applets()
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCClient::StopT120Applets - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::StopT120Applets - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    _ASSERT(m_pMediaManage != NULL);

    hr = m_pMediaManage->StopT120Applets();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::StopT120Applets - "
                    "StopT120Applets failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::StopT120Applets - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// FindWindowFromResource
//
/////////////////////////////////////////////////////////////////////////////

HWND FindWindowFromResource(HWND hwndParent, UINT uResID, BOOL fDialog)
{
    HWND        hwnd;
    LPCTSTR     szWindowName;
    const TCHAR szDialogClassName[] = TEXT("#32770");

    szWindowName = RtcAllocString(_Module.GetResourceInstance(), uResID);

    if ( szWindowName == NULL )
    {
        LOG((RTC_ERROR, "FindWindowFromResource - "
                    "out of memory"));

        return NULL;
    }

    hwnd = FindWindowEx (hwndParent, NULL, fDialog ? szDialogClassName : NULL, szWindowName);
    RtcFree ((LPVOID)szWindowName);

    return hwnd;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::IsT120AppletRunning
//
// Check if Netmeeting T120 Applet is running
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::get_IsT120AppletRunning(
            RTC_T120_APPLET   enApplet,
            VARIANT_BOOL * pfRunning
            )
{
    HRESULT hr;
    const TCHAR szNMWBClassName[] = TEXT("T126WBMainWindowClass");    

    LOG((RTC_TRACE, "CRTCClient::get_IsT120AppletRunning - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_IsT120AppletRunning - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( pfRunning, sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_IsT120AppletRunning - "
                            "bad VARIANT_BOOL pointer"));

        return E_POINTER;
    }

    *pfRunning = VARIANT_FALSE;

    switch ( enApplet )
    {
    case RTCTA_WHITEBOARD:
        {
            HWND hwnd;

            //
            // Search the NM whiteboard window by class name
            //

            hwnd = FindWindow(szNMWBClassName, NULL);

            if (hwnd && IsWindowVisible(hwnd))
            {
                LOG((RTC_INFO, "CRTCClient::get_IsT120AppletRunning - "
                                "got Whiteboard window hwnd=0x%lx", hwnd));

                *pfRunning = VARIANT_TRUE;
            }
        }
        break;

    case RTCTA_APPSHARING:
        {
            HWND    hwnd;

            //
            // Search the NM Application sharing window with with the title of
            // Sharing - Not in a call
            // The test is further refined by testing the existance of a
            // "Unshare All" button
            //

            hwnd = FindWindowFromResource( NULL, IDS_NMAS_TITLE, TRUE );

            if ( hwnd == NULL )
            {
                hwnd = FindWindowFromResource( NULL, IDS_NMAS_NOTHING, TRUE );
            }

            if ( hwnd == NULL )
            {
                hwnd = FindWindowFromResource( NULL, IDS_NMAS_PROGRAMS, TRUE );
            }

            if ( hwnd == NULL )
            {
                hwnd = FindWindowFromResource( NULL, IDS_NMAS_DESKTOP, TRUE );
            }

            if (hwnd && IsWindowVisible(hwnd))
            {
                LOG((RTC_INFO, "CRTCClient::get_IsT120AppletRunning - "
                            "got Sharing window hwnd=0x%lx", hwnd));

                hwnd = FindWindowFromResource( hwnd, IDS_NMAS_UNSHAREALL, FALSE );

                if (hwnd)
                {
                    LOG((RTC_INFO, "CRTCClient::get_IsT120AppletRunning - "
                            "got Unshare_All button hwnd=0x%lx", hwnd));

                    *pfRunning = VARIANT_TRUE;
                }                        
            }
        }
        break;

    default:
        LOG((RTC_ERROR, "CRTCClient::get_IsT120AppletRunning - invalid argument"));

        return E_INVALIDARG;
    }

    LOG((RTC_TRACE, "CRTCClient::get_IsT120AppletRunning - exit S_OK"));

    return S_OK;
}
    
/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::EnablePresence
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::EnablePresence(     
     VARIANT_BOOL fUseStorage,
     VARIANT varStorage
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::EnablePresence - enter"));
   
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::EnablePresence - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Load the watcher manager interface
    //

    if ( m_pSipWatcherManager == NULL )
    {
        hr = m_pSipStack->QueryInterface(
            IID_ISIPWatcherManager, (LPVOID *)&m_pSipWatcherManager);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::EnablePresence: cannot retrieve "
                "ISIPWatcherManager interface: x%x.", hr));

            return hr;
        }
    }

    //
    // Load the buddy manager interface
    //

    if ( m_pSipBuddyManager == NULL )
    {
        hr = m_pSipStack->QueryInterface(
            IID_ISIPBuddyManager, (LPVOID *)&m_pSipBuddyManager);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::EnablePresence: cannot retrieve "
                "ISIPBuddyManager interface: x%x.", hr));

            return hr;
        }
    }

    //
    // Get storage info
    //

    m_varPresenceStorage = varStorage;
    m_fPresenceUseStorage = fUseStorage ? TRUE : FALSE;

    //
    // It's official
    //

    m_fPresenceEnabled = TRUE;

    //
    // Load presence info
    //

    if ( m_fPresenceUseStorage )
    {
        hr = Import( m_varPresenceStorage, VARIANT_TRUE );
            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "CRTCClient::EnablePresence: - "
                                "Import failed 0x%lx", hr));
                return S_FALSE;
            }
    }

    LOG((RTC_TRACE, "CRTCClient::EnablePresence - exit"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::CreateXMLDOMNodeForBuddyList
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::CreateXMLDOMNodeForBuddyList(
     IXMLDOMDocument * pXMLDoc,
     IXMLDOMNode     ** ppBuddyList
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::CreateXMLDOMNodeForBuddyList - enter"));

    IXMLDOMNode * pBuddyList = NULL;
    IXMLDOMNode * pBuddyInfo = NULL;

    hr = pXMLDoc->createNode( CComVariant(NODE_ELEMENT), CComBSTR(_T("BuddyList")), NULL, &pBuddyList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForBuddyList - "
                            "createNode failed 0x%lx", hr));

        return hr;
    }

    CRTCBuddy * pCBuddy = NULL;

    for (int n = 0; n < m_BuddyArray.GetSize(); n++)
    {
        pCBuddy = reinterpret_cast<CRTCBuddy *>(m_BuddyArray[n]);

        if ( pCBuddy->m_bPersistent )
        {
            hr = pCBuddy->CreateXMLDOMNode( pXMLDoc, &pBuddyInfo );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForBuddyList - "
                                    "CreateXMLDOMNode failed 0x%lx", hr));

                pBuddyList->Release();

                return hr;
            }

            hr = pBuddyList->appendChild( pBuddyInfo, NULL );

            pBuddyInfo->Release();

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForBuddyList - "
                                    "appendChild failed 0x%lx", hr));
            
                pBuddyList->Release();

                return hr;
            }
        }
    }

    *ppBuddyList = pBuddyList;

    LOG((RTC_TRACE, "CRTCClient::CreateXMLDOMNodeForBuddyList - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::CreateXMLDOMNodeForWatcherList
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::CreateXMLDOMNodeForWatcherList(
     IXMLDOMDocument * pXMLDoc,
     IXMLDOMNode     ** ppWatcherList,
     IXMLDOMNode     ** ppBlockedList
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::CreateXMLDOMNodeForWatcherList - enter"));

    IXMLDOMNode * pWatcherList = NULL;
    IXMLDOMNode * pBlockedList = NULL;
    IXMLDOMNode * pWatcherInfo = NULL;

    hr = pXMLDoc->createNode( CComVariant(NODE_ELEMENT), CComBSTR(_T("WatcherList")), NULL, &pWatcherList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForWatcherList - "
                            "createNode(WatcherList) failed 0x%lx", hr));

        return hr;
    }

    hr = pXMLDoc->createNode( CComVariant(NODE_ELEMENT), CComBSTR(_T("BlockedList")), NULL, &pBlockedList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForWatcherList - "
                            "createNode(BlockedList) failed 0x%lx", hr));

        pWatcherList->Release();

        return hr;
    }

    CRTCWatcher * pCWatcher = NULL;

    for (int n = 0; n < m_WatcherArray.GetSize(); n++)
    {
        pCWatcher = reinterpret_cast<CRTCWatcher *>(m_WatcherArray[n]);

        if ( pCWatcher->m_bPersistent )
        {
            hr = pCWatcher->CreateXMLDOMNode( pXMLDoc, &pWatcherInfo );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForWatcherList - "
                                    "CreateXMLDOMNode failed 0x%lx", hr));

                pWatcherList->Release();
                pBlockedList->Release();

                return hr;
            }

            if ( pCWatcher->m_nState == RTCWS_ALLOWED )
            {
                hr = pWatcherList->appendChild( pWatcherInfo, NULL );
            }
            else if ( pCWatcher->m_nState == RTCWS_BLOCKED )
            {
                hr = pBlockedList->appendChild( pWatcherInfo, NULL );
            }        

            pWatcherInfo->Release();

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForWatcherList - "
                                    "appendChild failed 0x%lx", hr));
            
                pWatcherList->Release();
                pBlockedList->Release();

                return hr;
            }
        }
    }

    *ppWatcherList = pWatcherList;
    *ppBlockedList = pBlockedList;

    LOG((RTC_TRACE, "CRTCClient::CreateXMLDOMNodeForWatcherList - exit S_OK"));

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::CreateXMLDOMNodeForProperties
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::CreateXMLDOMNodeForProperties( IXMLDOMDocument * pXMLDoc, IXMLDOMNode ** ppXDN )
{
    IXMLDOMNode    * pProperties = NULL;
    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCClient::CreateXMLDOMNodeForProperties - enter"));

    hr = pXMLDoc->createNode( CComVariant(NODE_ELEMENT), CComBSTR(_T("Properties")), NULL, &pProperties );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForProperties - "
                        "createNode failed 0x%lx", hr));

        return hr;
    }
    
    hr = pProperties->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForProperties - "
                        "QueryInterface failed 0x%lx", hr));

        pProperties->Release();

        return hr;
    }

    hr = pElement->setAttribute( CComBSTR(_T("OfferWatcherMode")),
         CComVariant( 
             m_nOfferWatcherMode == RTCOWM_AUTOMATICALLY_ADD_WATCHER ? 
              _T("AutomaticallyAddWatcher") : _T("OfferWatcherEvent")
             ));

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForProperties - "
                    "setAttribute(OfferWatcherMode) failed 0x%lx", hr));

        pElement->Release();
        pProperties->Release();

        return hr;
    }
    
    hr = pElement->setAttribute( CComBSTR(_T("PrivacyMode")),
         CComVariant( 
             m_nPrivacyMode == RTCPM_ALLOW_LIST_ONLY ? 
             _T("AllowListOnly") : _T("BlockListExcluded")
             ));

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForProperties - "
                    "setAttribute(PrivacyMode) failed 0x%lx", hr));

        pElement->Release();
        pProperties->Release();

        return hr;
    }

    pElement->Release();

    *ppXDN = pProperties;

    LOG((RTC_TRACE, "CRTCClient::CreateXMLDOMNodeForProperties - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::CreateXMLDOMDocumentForPresence
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::CreateXMLDOMDocumentForPresence(
     IXMLDOMDocument ** ppXMLDoc
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::CreateXMLDOMDocumentForPresence - enter"));

    IXMLDOMDocument * pXMLDoc = NULL;
    IXMLDOMNode     * pDocument = NULL;
    IXMLDOMNode     * pPresence = NULL;

    //
    // Create the XML document
    //

    hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
            IID_IXMLDOMDocument, (void**)&pXMLDoc );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "CoCreateInstance failed 0x%lx", hr));

        return hr;
    }

    hr = pXMLDoc->QueryInterface( IID_IXMLDOMNode, (void**)&pDocument );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "QueryInterface failed 0x%lx", hr));

        pXMLDoc->Release();

        return hr;
    }

    //
    // Create the PresenceInfo node
    //
    
    hr = pXMLDoc->createNode( CComVariant(NODE_ELEMENT), CComBSTR(_T("PresenceInfo")), NULL, &pPresence );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "createNode failed 0x%lx", hr));

        pDocument->Release();
        pXMLDoc->Release();

        return hr;
    }

    hr = pDocument->appendChild( pPresence, NULL );

    pDocument->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "appendChild failed 0x%lx", hr));

        pPresence->Release();        
        pXMLDoc->Release();

        return hr;
    }

    //
    // Fill in the Properties
    //

    IXMLDOMNode * pProperties = NULL;

    hr = CreateXMLDOMNodeForProperties( pXMLDoc, &pProperties );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "CreateXMLDOMNodeForProperties failed 0x%lx", hr));

        pPresence->Release();        
        pXMLDoc->Release();

        return hr;
    }

    hr = pPresence->appendChild( pProperties, NULL );

    pProperties->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "appendChild(Properties) failed 0x%lx", hr));
    
        pPresence->Release();        
        pXMLDoc->Release();

        return hr;
    }

    //
    // Fill in the BuddyList
    //

    IXMLDOMNode * pBuddyList = NULL;

    hr = CreateXMLDOMNodeForBuddyList( pXMLDoc, &pBuddyList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "CreateXMLDOMNodeForBuddyList failed 0x%lx", hr));

        pPresence->Release();        
        pXMLDoc->Release();

        return hr;
    }

    hr = pPresence->appendChild( pBuddyList, NULL );

    pBuddyList->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "appendChild(BuddyList) failed 0x%lx", hr));
    
        pPresence->Release();        
        pXMLDoc->Release();

        return hr;
    }

    //
    // Fill in the WatcherList
    //

    IXMLDOMNode * pWatcherList = NULL;
    IXMLDOMNode * pBlockedList = NULL;

    hr = CreateXMLDOMNodeForWatcherList( pXMLDoc, &pWatcherList, &pBlockedList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "CreateXMLDOMNodeForWatcherList failed 0x%lx", hr));

        pPresence->Release();        
        pXMLDoc->Release();

        return hr;
    }

    hr = pPresence->appendChild( pWatcherList, NULL );

    pWatcherList->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "appendChild(WatcherList) failed 0x%lx", hr));
    
        pBlockedList->Release();
        pPresence->Release();        
        pXMLDoc->Release();

        return hr;
    }

    hr = pPresence->appendChild( pBlockedList, NULL );

    pBlockedList->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "appendChild(BlockedList) failed 0x%lx", hr));

        pPresence->Release();        
        pXMLDoc->Release();

        return hr;
    }

    pPresence->Release();

    *ppXMLDoc = pXMLDoc;

    LOG((RTC_TRACE, "CRTCClient::CreateXMLDOMDocumentForPresence - exit S_OK"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::ParseXMLDOMNodeForBuddyList
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::ParseXMLDOMNodeForBuddyList(
     IXMLDOMNode     * pBuddyList
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::ParseXMLDOMNodeForBuddyList - enter"));

    VARIANT_BOOL bHasChild;

    hr = pBuddyList->hasChildNodes( &bHasChild );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForBuddyList - "
                            "hasChildNodes failed 0x%lx", hr));

        return hr;
    }

    if ( bHasChild )
    {
        IXMLDOMNodeList * pNodeList = NULL;

        hr = pBuddyList->get_childNodes( &pNodeList );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForBuddyList - "
                                "get_childNodes failed 0x%lx", hr));

            return hr;
        }

        IXMLDOMNode * pNode = NULL;

        while ( pNodeList->nextNode( &pNode ) == S_OK )
        {
            IXMLDOMElement * pElement = NULL;

            hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

            pNode->Release();

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForBuddyList - "
                                    "QueryInterface failed 0x%lx", hr));

                pNodeList->Release();

                return hr;
            }

            CComVariant varPresentity;
            CComVariant varName;
            CComVariant varData;

            hr = pElement->getAttribute( CComBSTR(_T("Presentity")), &varPresentity );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForBuddyList - "
                                    "getAttribute(Presentity) failed 0x%lx", hr));

                pElement->Release();
                pNodeList->Release();

                return hr;
            }

            hr = pElement->getAttribute( CComBSTR(_T("Name")), &varName );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForBuddyList - "
                                    "getAttribute(Name) failed 0x%lx", hr));

                pElement->Release();
                pNodeList->Release();

                return hr;
            }

            hr = pElement->getAttribute( CComBSTR(_T("Data")), &varData );

            pElement->Release();

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForBuddyList - "
                                    "getAttribute(Data) failed 0x%lx", hr));

                pElement->Release();
                pNodeList->Release();

                return hr;
            }

            hr = AddBuddy( 
                    varPresentity.bstrVal,
                    varName.bstrVal,
                    varData.bstrVal,
                    VARIANT_TRUE,
                    NULL,
                    0,
                    NULL );

            if ( FAILED(hr) )
            {
                LOG((RTC_WARN, "CRTCClient::ParseXMLDOMNodeForBuddyList - "
                                    "AddBuddy failed 0x%lx", hr));
            }
        }

        pNodeList->Release();
    }  

    LOG((RTC_TRACE, "CRTCClient::ParseXMLDOMNodeForBuddyList - exit S_OK"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::ParseXMLDOMNodeForWatcherList
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::ParseXMLDOMNodeForWatcherList(
     IXMLDOMNode     * pWatcherList,
     VARIANT_BOOL      bBlocked
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::ParseXMLDOMNodeForWatcherList - enter"));

    VARIANT_BOOL bHasChild;

    hr = pWatcherList->hasChildNodes( &bHasChild );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForWatcherList - "
                            "hasChildNodes failed 0x%lx", hr));

        return hr;
    }

    if ( bHasChild )
    {
        IXMLDOMNodeList * pNodeList = NULL;

        hr = pWatcherList->get_childNodes( &pNodeList );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForWatcherList - "
                                "get_childNodes failed 0x%lx", hr));

            return hr;
        }

        IXMLDOMNode * pNode = NULL;

        while ( pNodeList->nextNode( &pNode ) == S_OK )
        {
            IXMLDOMElement * pElement = NULL;

            hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

            pNode->Release();

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForWatcherList - "
                                    "QueryInterface failed 0x%lx", hr));

                pNodeList->Release();

                return hr;
            }

            CComVariant varPresentity;
            CComVariant varName;
            CComVariant varData;
            CComVariant varShutdownBlob;

            hr = pElement->getAttribute( CComBSTR(_T("Presentity")), &varPresentity );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForWatcherList - "
                                    "getAttribute(Presentity) failed 0x%lx", hr));

                pElement->Release();
                pNodeList->Release();

                return hr;
            }

            hr = pElement->getAttribute( CComBSTR(_T("Name")), &varName );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForWatcherList - "
                                    "getAttribute(Name) failed 0x%lx", hr));

                pElement->Release();
                pNodeList->Release();

                return hr;
            }

            hr = pElement->getAttribute( CComBSTR(_T("Data")), &varData );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForWatcherList - "
                                    "getAttribute(Data) failed 0x%lx", hr));
                
                pNodeList->Release();

                return hr;
            }     
            
            hr = pElement->getAttribute( CComBSTR(_T("ShutdownBlob")), &varShutdownBlob );

            pElement->Release();

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForWatcherList - "
                                    "getAttribute(ShutdownBlob) failed 0x%lx", hr));
                
                pNodeList->Release();

                return hr;
            }   

            hr = InternalAddWatcher(
                    varPresentity.bstrVal,
                    varName.bstrVal,
                    varData.bstrVal,
                    varShutdownBlob.bstrVal,
                    bBlocked,
                    VARIANT_TRUE,
                    NULL );

            if ( FAILED(hr) )
            {
                LOG((RTC_WARN, "CRTCClient::ParseXMLDOMNodeForWatcherList - "
                                    "AddWatcher failed 0x%lx", hr));
            }
        }

        pNodeList->Release();
    }  

    LOG((RTC_TRACE, "CRTCClient::ParseXMLDOMNodeForWatcherList - exit S_OK"));
    
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::ParseXMLDOMNodeForProperties
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::ParseXMLDOMNodeForProperties(
     IXMLDOMNode     * pProperties,
     RTC_OFFER_WATCHER_MODE * pnOfferWatcherMode,
     RTC_PRIVACY_MODE       * pnPrivacyMode
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::ParseXMLDOMNodeForProperties - enter"));

    IXMLDOMElement * pElement = NULL;

    hr = pProperties->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForProperties - "
          "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    CComVariant varOfferWatcherMode;
    CComVariant varPrivacyMode;

    hr = pElement->getAttribute( CComBSTR(_T("OfferWatcherMode")), &varOfferWatcherMode );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForProperties - "
            "getAttribute(OfferWatcherMode) failed 0x%lx", hr));

        pElement->Release();
        return hr;
    }
    
    
    hr = pElement->getAttribute( CComBSTR(_T("PrivacyMode")), &varPrivacyMode );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForProperties - "
            "getAttribute(PrivacyMode) failed 0x%lx", hr));

        pElement->Release();
        return hr;
    }

    // Process the values
    //
    
    if(_wcsicmp(varOfferWatcherMode.bstrVal, L"OfferWatcherEvent") == 0)
    {
        *pnOfferWatcherMode = RTCOWM_OFFER_WATCHER_EVENT;
    }
    else if(_wcsicmp(varOfferWatcherMode.bstrVal, L"AutomaticallyAddWatcher") == 0)
    {
        *pnOfferWatcherMode = RTCOWM_AUTOMATICALLY_ADD_WATCHER;
    }
    
    if(_wcsicmp(varPrivacyMode.bstrVal, L"BlockListExcluded") == 0)
    {
        *pnPrivacyMode = RTCPM_BLOCK_LIST_EXCLUDED;
    }
    else if(_wcsicmp(varPrivacyMode.bstrVal, L"AllowListOnly") == 0)
    {
        *pnPrivacyMode = RTCPM_ALLOW_LIST_ONLY;
    }
      
    pElement->Release();

    LOG((RTC_TRACE, "CRTCClient::ParseXMLDOMNodeForProperties - exit S_OK"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::ParseXMLDOMDocumentForPresence
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::ParseXMLDOMDocumentForPresence(
     IXMLDOMDocument * pXMLDoc,
     RTC_OFFER_WATCHER_MODE * pnOfferWatcherMode,
     RTC_PRIVACY_MODE       * pnPrivacyMode
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::ParseXMLDOMDocumentForPresence - enter"));

    IXMLDOMNode * pDocument = NULL;

    hr = pXMLDoc->QueryInterface( IID_IXMLDOMNode, (void**)&pDocument);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // Parse the Properties
    //

    IXMLDOMNode * pProperties = NULL;

    hr = pDocument->selectSingleNode( CComBSTR(_T("PresenceInfo/Properties")), &pProperties );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "selectSingleNode(Properties) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        hr = ParseXMLDOMNodeForProperties( pProperties, pnOfferWatcherMode, pnPrivacyMode);

        pProperties->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                                "ParseXMLDOMNodeForProperties failed 0x%lx", hr));

            pDocument->Release();

            return hr;
        }
    }
    else
    {
        LOG((RTC_WARN, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "Properties not found"));

        // default values
        *pnOfferWatcherMode = RTCOWM_OFFER_WATCHER_EVENT;
        *pnPrivacyMode = RTCPM_BLOCK_LIST_EXCLUDED;
    }

    //
    // Parse the BuddyList
    //

    IXMLDOMNode * pBuddyList = NULL;

    hr = pDocument->selectSingleNode( CComBSTR(_T("PresenceInfo/BuddyList")), &pBuddyList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "selectSingleNode(BuddyList) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        hr = ParseXMLDOMNodeForBuddyList( pBuddyList );

        pBuddyList->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                                "ParseXMLDOMNodeForBuddyList failed 0x%lx", hr));

            pDocument->Release();

            return hr;
        }
    }
    else
    {
        LOG((RTC_WARN, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "BuddyList not found"));
    }

    //
    // Parse the WatcherList
    //

    IXMLDOMNode * pWatcherList = NULL;

    hr = pDocument->selectSingleNode( CComBSTR(_T("PresenceInfo/WatcherList")), &pWatcherList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "selectSingleNode(WatcherList) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        hr = ParseXMLDOMNodeForWatcherList( pWatcherList, VARIANT_FALSE );

        pWatcherList->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                                "ParseXMLDOMNodeForWatcherList(WatcherList) failed 0x%lx", hr));

            pDocument->Release();

            return hr;
        }
    }
    else
    {
        LOG((RTC_WARN, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "WatcherList not found"));
    }

    //
    // Parse the BlockedList
    //

    IXMLDOMNode * pBlockedList = NULL;

    hr = pDocument->selectSingleNode( CComBSTR(_T("PresenceInfo/BlockedList")), &pBlockedList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "selectSingleNode(BlockedList) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        hr = ParseXMLDOMNodeForWatcherList( pBlockedList, VARIANT_TRUE );

        pBlockedList->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                                "ParseXMLDOMNodeForWatcherList(BlockedList) failed 0x%lx", hr));

            pDocument->Release();

            return hr;
        }
    }
    else
    {
        LOG((RTC_WARN, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "BlockedList not found"));
    }

    pDocument->Release();

    LOG((RTC_TRACE, "CRTCClient::ParseXMLDOMDocumentForPresence - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::UpdatePresenceStorage
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::UpdatePresenceStorage()
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::UpdatePresenceStorage - enter"));

    if ( m_fPresenceUseStorage )
    {
        // Kill any existing timer
        KillTimer(m_hWnd, TID_PRESENCE_STORAGE);

        // Try to start the timer
        DWORD dwID = (DWORD)SetTimer(m_hWnd, TID_PRESENCE_STORAGE, PRESENCE_STORAGE_DELAY, NULL);
        if (dwID==0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            LOG((RTC_ERROR, "CRTCClient::UpdatePresenceStorage - "
                           "SetTimer failed 0x%lx", hr));

            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCClient::UpdatePresenceStorage - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnPresenceStorageTimer
//
/////////////////////////////////////////////////////////////////////////////

void CRTCClient::OnPresenceStorageTimer()
{
    LOG((RTC_TRACE, "CRTCClient::OnPresenceStorageTimer - enter"));

    // Kill the timer
    KillTimer(m_hWnd, TID_PRESENCE_STORAGE);

    // Store the presence information
    if ( m_fPresenceUseStorage )
    {
        InternalExport( m_varPresenceStorage );
    }  

    LOG((RTC_TRACE, "CRTCClient::OnPresenceStorageTimer - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::Export
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::Export(
     VARIANT varStorage
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::Export - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::Export - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    hr = InternalExport( varStorage );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Export - "
                            "InternalExport failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::Export - exit S_OK"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalExport
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCClient::InternalExport(
     VARIANT varStorage
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::InternalExport - enter"));

    IXMLDOMDocument * pXMLDoc = NULL;

    //
    // Create the XML document
    //

    hr = CreateXMLDOMDocumentForPresence( &pXMLDoc );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalExport - "
                            "CreateXMLDOMDocumentForPresence failed 0x%lx", hr));

        return hr;
    }

    //
    // Save the XML document
    //

    hr = pXMLDoc->save( varStorage );

    pXMLDoc->Release();

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalExport - "
                            "save failed 0x%lx", hr));

        if ( S_FALSE == hr )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::InternalExport - exit S_OK"));
    
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::Import
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::Import(
     VARIANT varStorage,
     VARIANT_BOOL fReplaceAll
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::Import - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::Import - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    IXMLDOMDocument * pXMLDoc = NULL;
    IXMLDOMNode     * pDocument = NULL;
    IXMLDOMNode     * pPresence = NULL;

    //
    // Release the existing buddies and watchers
    //
    
    if ( fReplaceAll )
    {
        if ( m_pSipBuddyManager != NULL )
        { 
            CRTCBuddy * pCBuddy = NULL;

            for (int n = 0; n < m_BuddyArray.GetSize(); n++)
            {
                pCBuddy = reinterpret_cast<CRTCBuddy *>(m_BuddyArray[n]);

                if (pCBuddy->m_pSIPBuddy)
                {
                    m_pSipBuddyManager->RemoveBuddy(
                        pCBuddy->m_pSIPBuddy,
                        BUDDY_REMOVED_BYUSER);
                }
            }
        }

        m_BuddyArray.Shutdown();  

        if ( m_pSipWatcherManager != NULL )
        { 
            CRTCWatcher * pCWatcher = NULL;

            for (int n = 0; n < m_WatcherArray.GetSize(); n++)
            {
                pCWatcher = reinterpret_cast<CRTCWatcher *>(m_WatcherArray[n]);

                pCWatcher->RemoveSIPWatchers(FALSE);
            }
            for (int n = 0; n < m_HiddenWatcherArray.GetSize(); n++)
            {
                pCWatcher = reinterpret_cast<CRTCWatcher *>(m_HiddenWatcherArray[n]);

                pCWatcher->RemoveSIPWatchers(FALSE);
            }
        }

        m_WatcherArray.Shutdown();
        m_HiddenWatcherArray.Shutdown();
    }

    //
    // Load the XML document
    //

    hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
            IID_IXMLDOMDocument, (void**)&pXMLDoc );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Import - "
                            "CoCreateInstance failed 0x%lx", hr));

        return hr;
    }

    VARIANT_BOOL bSuccess;

    hr = pXMLDoc->load( varStorage, &bSuccess );

    if ( S_OK != hr ) // load failed
    {
        LOG((RTC_ERROR, "CRTCClient::Import - "
                            "load failed 0x%lx", hr));

        if ( S_FALSE == hr )
        {
            hr = E_FAIL;
        }

        return hr;
    }
    
    //
    // Parse the XML document
    //
    RTC_OFFER_WATCHER_MODE      nOfferWatcherMode;
    RTC_PRIVACY_MODE            nPrivacyMode;
    
    hr = ParseXMLDOMDocumentForPresence( 
        pXMLDoc,
        &nOfferWatcherMode,
        &nPrivacyMode);

    pXMLDoc->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Import - "
                            "ParseXMLDOMDocumentForPresence failed 0x%lx", hr));
        
        return hr;
    }

    // replace the properties if fReplaceAll is TRUE
    if ( fReplaceAll )
    {
        m_nOfferWatcherMode = nOfferWatcherMode;
        m_nPrivacyMode = nPrivacyMode;
    }

#ifdef DUMP_PRESENCE
    DumpWatchers("IMPORT");
#endif

    LOG((RTC_TRACE, "CRTCClient::Import - exit S_OK"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::EnumerateBuddies
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::EnumerateBuddies(   
            IRTCEnumBuddies ** ppEnum
            )
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "CRTCClient::EnumerateBuddies enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateBuddies - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( ppEnum, sizeof( IRTCEnumBuddies * ) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateBuddies - "
                            "bad IRTCEnumBuddies pointer"));

        return E_POINTER;
    }

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateBuddies - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    //
    // Create the enumeration
    //
 
    CComObject< CRTCEnum< IRTCEnumBuddies,
                          IRTCBuddy,
                          &IID_IRTCEnumBuddies > > * p;
                          
    hr = CComObject< CRTCEnum< IRTCEnumBuddies,
                               IRTCBuddy,
                               &IID_IRTCEnumBuddies > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateBuddies - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the enumeration (adds a reference)
    //
    
    hr = p->Initialize(m_BuddyArray);

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateBuddies - "
                            "could not initialize enumeration" ));
    
        delete p;
        return hr;
    }

    *ppEnum = p;
    
    LOG((RTC_TRACE, "CRTCClient::EnumerateBuddies - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_Buddies
//
// This is an IRTCClientPresence method that enumerates buddies on
// the client.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::get_Buddies(
        IRTCCollection ** ppCollection
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::get_Buddies - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddies - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( ppCollection, sizeof(IRTCCollection *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddies - "
                            "bad IRTCCollection pointer"));

        return E_POINTER;
    }

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddies - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    //
    // Create the collection
    //
 
    CComObject< CRTCCollection< IRTCBuddy > > * p;
                          
    hr = CComObject< CRTCCollection< IRTCBuddy > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddies - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the collection (adds a reference)
    //
    
    hr = p->Initialize(m_BuddyArray);

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddies - "
                            "could not initialize collection" ));
    
        delete p;
        return hr;
    }

    *ppCollection = p;

    LOG((RTC_TRACE, "CRTCClient::get_Buddies - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_Buddy
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_Buddy(
            BSTR    bstrPresentityURI,
            IRTCBuddy   **ppBuddy
            )
{
    
    HRESULT         hr;
    
    LOG((RTC_TRACE, "CRTCClient::get_Buddy - enter"));
    
    if ( IsBadWritePtr( ppBuddy, sizeof(IRTCBuddy*) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddy - "
                            "bad IRTCBuddy* pointer"));

        return E_POINTER;
    } 

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddy - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadStringPtrW( bstrPresentityURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddy - "
                            "bad URI pointer"));

        return E_POINTER;
    } 

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddy - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    hr = FindBuddyByURI(
        bstrPresentityURI,
        ppBuddy);

    if(hr!=S_OK)
    {
        hr = E_FAIL;
    }

    LOG((RTC_TRACE, "CRTCClient::get_Buddy - exit"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::AddBuddy
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::AddBuddy(
            BSTR    bstrPresentityURI,
            BSTR    bstrUserName,
            BSTR    bstrData,
            VARIANT_BOOL bPersistent,
            IRTCProfile * pProfile,
            long lFlags,
            IRTCBuddy ** ppBuddy
            )
{
    
    HRESULT         hr;
    
    LOG((RTC_TRACE, "CRTCClient::AddBuddy - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // NULL is okay for ppBuddy
    //
    
    if ( (ppBuddy != NULL) &&
         IsBadWritePtr( ppBuddy, sizeof(IRTCBuddy *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - bad IRTCBuddy pointer"));

        return E_POINTER;
    }
    
    if ( IsBadStringPtrW( bstrPresentityURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - "
                            "bad URI pointer"));

        return E_POINTER;
    } 

    if ( IsBadStringPtrW( bstrUserName, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - "
                            "bad Name pointer"));

        return E_POINTER;
    } 
    
    if ( (bstrData != NULL) &&
        IsBadStringPtrW( bstrData, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - "
                            "bad Data pointer"));

        return E_POINTER;
    } 

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    //
    // Clean the presentity URI
    //

    PWSTR szCleanPresentityURI = NULL;

    AllocCleanSipString( bstrPresentityURI, &szCleanPresentityURI );

    if ( szCleanPresentityURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    //
    // Don't allow duplicates
    //

    IRTCBuddy *pBuddy = NULL;

    hr = FindBuddyByURI(
        szCleanPresentityURI,
        &pBuddy);

    if (hr == S_OK)
    {
        RtcFree( szCleanPresentityURI );
        szCleanPresentityURI = NULL;

        pBuddy->Release();
        
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - "
                            "duplicate buddy"));

        return E_FAIL;
    }

    pBuddy = NULL;

    //
    // Create a buddy
    //

    hr = InternalCreateBuddy(
         szCleanPresentityURI,        
         bstrUserName,
         bstrData,
         bPersistent ? TRUE : FALSE,
         pProfile,
         lFlags,
         &pBuddy);

    RtcFree( szCleanPresentityURI );
    szCleanPresentityURI = NULL;

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - InternalCreateBuddy failed 0x%lx", hr));      

        return hr;
    }

    //
    // Add the buddy to the array
    //

    BOOL fResult;

    fResult = m_BuddyArray.Add(pBuddy);

    if ( fResult == FALSE )
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - "
                                    "out of memory"));       

        pBuddy->Release();
        pBuddy = NULL;

        return E_OUTOFMEMORY;
    }

    //
    // Update storage
    //

    UpdatePresenceStorage();

    //
    // Should we return the buddy?
    //
    
    if ( ppBuddy != NULL )
    {
        *ppBuddy = pBuddy;
    }
    else
    {
        pBuddy->Release();
        pBuddy = NULL;
    }

    LOG((RTC_TRACE, "CRTCClient::AddBuddy - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::RemoveBuddy
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::RemoveBuddy(
            IRTCBuddy * pBuddy
            )
{
    
    HRESULT         hr;
    
    LOG((RTC_TRACE, "CRTCClient::RemoveBuddy - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::RemoveBuddy - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadReadPtr( pBuddy, sizeof(IRTCBuddy) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::RemoveBuddy - "
                            "bad IRTCBuddy pointer"));

        return E_POINTER;
    } 

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::RemoveBuddy - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }
   
    CRTCBuddy *pCBuddy   = reinterpret_cast<CRTCBuddy *>(pBuddy);

    if( pCBuddy )
    {
        hr = pCBuddy->RemoveSIPBuddy(FALSE);
          
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::RemoveBuddy - RemoveSIPBuddy failed 0x%lx", hr));
        }
    }

    //
    // Remove the buddy object from the array
    //

    m_BuddyArray.Remove(pBuddy);

    //
    // Update storage
    //

    UpdatePresenceStorage();

    LOG((RTC_TRACE, "CRTCClient::RemoveBuddy - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::EnumerateWatchers
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::EnumerateWatchers(   
            IRTCEnumWatchers ** ppEnum
            )
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "CRTCClient::EnumerateWatchers enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateWatchers - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( ppEnum, sizeof( IRTCEnumWatchers * ) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateWatchers - "
                            "bad IRTCEnumWatchers pointer"));

        return E_POINTER;
    }

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateWatchers - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    //
    // Create the enumeration
    //
 
    CComObject< CRTCEnum< IRTCEnumWatchers,
                          IRTCWatcher,
                          &IID_IRTCEnumWatchers > > * p;
                          
    hr = CComObject< CRTCEnum< IRTCEnumWatchers,
                               IRTCWatcher,
                               &IID_IRTCEnumWatchers > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateWatchers - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the enumeration (adds a reference)
    //
    
    hr = p->Initialize(m_WatcherArray);

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateWatchers - "
                            "could not initialize enumeration" ));
    
        delete p;
        return hr;
    }

    *ppEnum = p;
    
    LOG((RTC_TRACE, "CRTCClient::EnumerateWatchers exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_Watchers
//
// This is an IRTCClientPresence method that enumerates watchers on
// the client.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::get_Watchers(
        IRTCCollection ** ppCollection
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::get_Watchers - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watchers - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( ppCollection, sizeof(IRTCCollection *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watchers - "
                            "bad IRTCCollection pointer"));

        return E_POINTER;
    }

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watchers - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    //
    // Create the collection
    //
 
    CComObject< CRTCCollection< IRTCWatcher > > * p;
                          
    hr = CComObject< CRTCCollection< IRTCWatcher > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watchers - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the collection (adds a reference)
    //
    
    hr = p->Initialize(m_WatcherArray);

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watchers - "
                            "could not initialize collection" ));
    
        delete p;
        return hr;
    }

    *ppCollection = p;

    LOG((RTC_TRACE, "CRTCClient::get_Watchers - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_Watcher
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_Watcher(
            BSTR    bstrPresentityURI,
            IRTCWatcher **ppWatcher
            )
{
    
    HRESULT         hr;
    
    LOG((RTC_TRACE, "CRTCClient::get_Watcher - enter"));

    if ( IsBadWritePtr( ppWatcher, sizeof(IRTCWatcher *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watcher - "
                            "bad IRTCWatcher* pointer"));

        return E_POINTER;
    } 
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watcher - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadStringPtrW( bstrPresentityURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watcher - "
                            "bad URI pointer"));

        return E_POINTER;
    } 

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watcher - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    hr = FindWatcherByURI(
        bstrPresentityURI,
        FALSE,
        ppWatcher);

    if( hr != S_OK )
    {
        hr = E_FAIL;
    }

    LOG((RTC_TRACE, "CRTCClient::get_Watcher - exit"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::AddWatcher
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::InternalAddWatcher(   
            PCWSTR	  szPresentityURI,
            PCWSTR    szUserName,
            PCWSTR    szData,
            PCWSTR    szShutdownBlob,
            VARIANT_BOOL   fBlocked,
            VARIANT_BOOL   fPersistent,
            IRTCWatcher ** ppWatcher
            )
{
    HRESULT         hr;
    
    LOG((RTC_TRACE, "CRTCClient::InternalAddWatcher - enter"));

    //
    // Clean the presentity URI
    //

    PWSTR szCleanPresentityURI = NULL;

    AllocCleanSipString( szPresentityURI, &szCleanPresentityURI );

    if ( szCleanPresentityURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalAddWatcher - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    //
    // Don't allow duplicates
    //

    IRTCWatcher *pWatcher = NULL;

    hr = FindWatcherByURI(
        szCleanPresentityURI,
        FALSE,
        &pWatcher);

    if(hr == S_OK)
    {
        RtcFree( szCleanPresentityURI );
        szCleanPresentityURI = NULL;

        pWatcher->Release();
        
        LOG((RTC_ERROR, "CRTCClient::InternalAddWatcher - "
                            "duplicate watcher"));

        return E_FAIL;
    }

    pWatcher = NULL;

    //
    // Create a watcher
    //

    hr = InternalCreateWatcher(
         szCleanPresentityURI,        
         szUserName,
         szData,
         szShutdownBlob,
         fPersistent ? TRUE : FALSE,
         &pWatcher);

    RtcFree( szCleanPresentityURI );
    szCleanPresentityURI = NULL;

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCClient::InternalAddWatcher - "
                            "InternalCreateWatcher failed 0x%lx", hr));

        return hr;
    }

    //
    // Add the watcher to the array
    //

    BOOL fResult;

    fResult = m_WatcherArray.Add(pWatcher);

    if ( fResult == FALSE )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalAddWatcher - "
                                    "out of memory"));
        
        pWatcher->Release();
        return E_OUTOFMEMORY;
    }

    CRTCWatcher *pCWatcher = reinterpret_cast<CRTCWatcher *>(pWatcher);

    pCWatcher->m_nState = fBlocked ? RTCWS_BLOCKED : RTCWS_ALLOWED;

    //
    // Make sure any existing SIP watchers are updated
    //
    pCWatcher->ChangeBlockedStatus(fBlocked ? WATCHER_BLOCKED : WATCHER_UNBLOCKED);

    //
    // Update storage
    //

    UpdatePresenceStorage();

    //
    // Should we return the watcher?
    //
    
    if ( ppWatcher != NULL )
    {
        *ppWatcher = pWatcher;
    }
    else
    {
        pWatcher->Release();
        pWatcher = NULL;
    }

    LOG((RTC_TRACE, "CRTCClient::InternalAddWatcher - exit"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::AddWatcher
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::AddWatcher(   
            BSTR	bstrPresentityURI,
            BSTR    bstrUserName,
            BSTR    bstrData,
			VARIANT_BOOL   fBlocked,
            VARIANT_BOOL   fPersistent,
            IRTCWatcher ** ppWatcher
            )
{    
    HRESULT         hr;
    
    LOG((RTC_TRACE, "CRTCClient::AddWatcher - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::AddWatcher - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // NULL is okay for ppWatcher
    //
    
    if ( (ppWatcher != NULL) &&
         IsBadWritePtr( ppWatcher, sizeof(IRTCWatcher *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::AddWatcher - bad IRTCWatcher pointer"));

        return E_POINTER;
    }

    if ( IsBadStringPtrW( bstrPresentityURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::AddWatcher - "
                            "bad URI pointer"));

        return E_POINTER;
    } 

    if ( IsBadStringPtrW( bstrUserName, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::AddWatcher - "
                            "bad Name pointer"));

        return E_POINTER;
    } 

    if ( (bstrData != NULL) &&
         IsBadStringPtrW( bstrData, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::AddWatcher - "
                            "bad Data pointer"));

        return E_POINTER;
    } 

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::AddWatcher - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    hr = InternalAddWatcher(   
            bstrPresentityURI,
            bstrUserName,
            bstrData,
            NULL,
			fBlocked,
            fPersistent,
            ppWatcher
            );

#ifdef DUMP_PRESENCE
    DumpWatchers("ADD WATCHER");
#endif

    LOG((RTC_TRACE, "CRTCClient::AddWatcher - exit"));

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::RemoveWatcher
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::RemoveWatcher(   
            IRTCWatcher *pWatcher
            )
{
    HRESULT         hr;
    
    LOG((RTC_TRACE, "CRTCClient::RemoveWatcher - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::RemoveWatcher - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadReadPtr( pWatcher, sizeof( IRTCWatcher * ) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::RemoveWatcher - "
                            "bad IRTCWatcher pointer"));

        return E_POINTER;
    }

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::RemoveWatcher - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }
    
    CRTCWatcher *pCWatcher   = reinterpret_cast<CRTCWatcher *>(pWatcher);

    // Block the watchers

    if( pCWatcher )
    {
        hr = pCWatcher->ChangeBlockedStatus(WATCHER_BLOCKED);
          
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::RemoveWatcher - RemoveSIPWatcher failed 0x%lx", hr));
        }
    }
    
    // Remove from the watcher array
    // (it might have been removed as a side effect of ChangeBlockedStatus)
    
    m_WatcherArray.Remove(pWatcher);

    // If there's at least one remaining SIP watcher in *pCWatcher
    // add the object to the list of hidden watchers

    if(pCWatcher->m_SIPWatchers.GetSize()!=0)
    {
        BOOL fResult;

        fResult = m_HiddenWatcherArray.Add(pWatcher);

        if(!fResult)
        {
            // oom...
            // free everything.
            pCWatcher->RemoveSIPWatchers(FALSE);
        }
    }

    //
    // Update storage
    //

    UpdatePresenceStorage();

#ifdef DUMP_PRESENCE
    DumpWatchers("REMOVE WATCHER");
#endif

    LOG((RTC_TRACE, "CRTCClient::RemoveWatcher - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::SetLocalPresenceInfo
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::SetLocalPresenceInfo(   
            RTC_PRESENCE_STATUS enStatus,
            BSTR bstrNotes
            )
{
    HRESULT         hr;
    
    LOG((RTC_TRACE, "CRTCClient::SetLocalPresenceInfo - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::SetLocalPresenceInfo - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( (bstrNotes != NULL) &&
         IsBadStringPtrW( bstrNotes, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::SetLocalPresenceInfo - "
                            "bad string pointer"));

        return E_POINTER;
    }

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::SetLocalPresenceInfo - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    SIP_PRESENCE_INFO   SipInfo;
    
    ZeroMemory(&SipInfo, sizeof(SipInfo));

    switch(enStatus)
    {
    case RTCXS_PRESENCE_OFFLINE:

        SipInfo.presenceStatus = BUDDY_OFFLINE;
        SipInfo.activeStatus = ACTIVE_STATUS_UNKNOWN;
        SipInfo.activeMsnSubstatus = MSN_SUBSTATUS_UNKNOWN;

        break;
    
    case RTCXS_PRESENCE_ONLINE:

        SipInfo.presenceStatus = BUDDY_ONLINE;
        SipInfo.activeStatus = DEVICE_ACTIVE;
        SipInfo.activeMsnSubstatus = MSN_SUBSTATUS_ONLINE;

        break;

    case RTCXS_PRESENCE_AWAY:

        SipInfo.presenceStatus = BUDDY_ONLINE;
        SipInfo.activeStatus = DEVICE_INACTIVE;
        SipInfo.activeMsnSubstatus = MSN_SUBSTATUS_AWAY;

        break;

    case RTCXS_PRESENCE_BUSY:

        SipInfo.presenceStatus = BUDDY_ONLINE;
        SipInfo.activeStatus = DEVICE_INUSE;
        SipInfo.activeMsnSubstatus = MSN_SUBSTATUS_BUSY;
        
        break;
        
    case RTCXS_PRESENCE_IDLE:

        SipInfo.presenceStatus = BUDDY_ONLINE;
        SipInfo.activeStatus = DEVICE_INACTIVE;
        SipInfo.activeMsnSubstatus = MSN_SUBSTATUS_IDLE;
        
        break;
    
    case RTCXS_PRESENCE_BE_RIGHT_BACK:

        SipInfo.presenceStatus = BUDDY_ONLINE;
        SipInfo.activeStatus = DEVICE_INACTIVE;
        SipInfo.activeMsnSubstatus = MSN_SUBSTATUS_BE_RIGHT_BACK;
        
        break;

    case RTCXS_PRESENCE_OUT_TO_LUNCH:

        SipInfo.presenceStatus = BUDDY_ONLINE;
        SipInfo.activeStatus = DEVICE_INACTIVE;
        SipInfo.activeMsnSubstatus = MSN_SUBSTATUS_OUT_TO_LUNCH;
        
        break;

    case RTCXS_PRESENCE_ON_THE_PHONE:

        SipInfo.presenceStatus = BUDDY_ONLINE;
        SipInfo.activeStatus = DEVICE_INUSE;
        SipInfo.activeMsnSubstatus = MSN_SUBSTATUS_ON_THE_PHONE;
        
        break;
        
    default:

        LOG((RTC_ERROR, "CRTCClient::SetLocalPresenceInfo - "
                            "invalid status %x", enStatus));

        return E_INVALIDARG;
    }

    // any text ?
    if( (bstrNotes != NULL) && wcscmp( bstrNotes, L"" ) )
    {
        WideCharToMultiByte(
            CP_UTF8,
            0,
            bstrNotes,
            -1,
            SipInfo.pstrSpecialNote,
            sizeof(SipInfo.pstrSpecialNote),
            NULL,
            NULL);
    }

    hr = m_pSipWatcherManager->SetPresenceInformation(&SipInfo);

    // cache this for IsIncomingSessionAuthorized function
    m_nLocalPresenceStatus = enStatus;

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCClient::SetLocalPresenceInfo - "
                            "error %x returned by m_pSipWatcherManager", hr));
    }

    LOG((RTC_TRACE, "CRTCClient::SetLocalPresenceInfo - exit"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_OfferWatcherMode
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::get_OfferWatcherMode(   
            RTC_OFFER_WATCHER_MODE * penMode
            )
{
    LOG((RTC_TRACE, "CRTCClient::get_OfferWatcherMode - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_OfferWatcherMode - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( penMode, sizeof(RTC_OFFER_WATCHER_MODE) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_OfferWatcherMode - "
                            "bad pointer"));

        return E_POINTER;
    }

    *penMode = m_nOfferWatcherMode;
    
    LOG((RTC_TRACE, "CRTCClient::get_OfferWatcherMode - exit"));
    
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_OfferWatcherMode
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::put_OfferWatcherMode(   
            RTC_OFFER_WATCHER_MODE   enMode
            )
{
    LOG((RTC_TRACE, "CRTCClient::put_OfferWatcherMode - enter"));

    HRESULT hr;    

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_OfferWatcherMode - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( enMode != RTCOWM_OFFER_WATCHER_EVENT &&
         enMode != RTCOWM_AUTOMATICALLY_ADD_WATCHER )
    {
        LOG((RTC_ERROR, "CRTCClient::put_OfferWatcherMode - "
                            "bad argument"));

        return E_INVALIDARG;
    }

    // set the value
    m_nOfferWatcherMode = enMode;

    // save
    UpdatePresenceStorage();
    
    LOG((RTC_TRACE, "CRTCClient::put_OfferWatcherMode - exit"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_PrivacyMode
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::get_PrivacyMode(   
            RTC_PRIVACY_MODE * penMode
            )
{
    LOG((RTC_TRACE, "CRTCClient::get_PrivacyMode - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PrivacyMode - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( penMode, sizeof(RTC_PRIVACY_MODE) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PrivacyMode - "
                            "bad pointer"));

        return E_POINTER;
    }

    *penMode = m_nPrivacyMode;
    
    LOG((RTC_TRACE, "CRTCClient::get_PrivacyMode - exit"));
    
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_PrivacyMode
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::put_PrivacyMode(   
            RTC_PRIVACY_MODE   enMode
            )
{
    LOG((RTC_TRACE, "CRTCClient::put_PrivacyMode - enter"));
    
    HRESULT hr;    

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PrivacyMode - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if (   enMode != RTCPM_BLOCK_LIST_EXCLUDED 
        && enMode != RTCPM_ALLOW_LIST_ONLY)
    {
        LOG((RTC_ERROR, "CRTCClient::put_PrivacyMode - "
                            "bad argument"));

        return E_INVALIDARG;
    }

    // set the value
    m_nPrivacyMode = enMode;

    // save
    UpdatePresenceStorage();
    
    LOG((RTC_TRACE, "CRTCClient::put_PrivacyMode - exit"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::IsIncomingSessionAuthorized
//
// Authorizes the call if presence is enabled
//
/////////////////////////////////////////////////////////////////////////////

BOOL CRTCClient::IsIncomingSessionAuthorized(PCWSTR pszCallerURI)
{
    LOG((RTC_TRACE, "CRTCClient::IsIncomingSessionAuthorized - enter"));

    // 
    // If presence is disabled, the call is authorized
    if(!m_fPresenceEnabled)
    {
        LOG((RTC_TRACE, "CRTCClient::IsIncomingSessionAuthorized - "
            "presence disabled, so authorize the incoming session, exit"));
        
        return TRUE;
    }

    // Appear OFFLINE ?
    //
    if(m_nLocalPresenceStatus == RTCXS_PRESENCE_OFFLINE)
    {
        LOG((RTC_TRACE, "CRTCClient::IsIncomingSessionAuthorized - "
            "Client is offline, so reject the incoming session, exit"));
        
        return FALSE;
    }

    
    // search the caller in the list of watchers
    //
    IRTCWatcher *pWatcher = NULL;

    HRESULT     hr;

    hr = FindWatcherByURI(
        pszCallerURI,
        FALSE,
        &pWatcher);

    if(hr != S_OK)
    {
        // Watcher not found. Resolution is based on privacy mode
        if(m_nPrivacyMode == RTCPM_BLOCK_LIST_EXCLUDED)
        {
            LOG((RTC_TRACE, "CRTCClient::IsIncomingSessionAuthorized - "
                "Caller not in watcher list; authorize the incoming session, exit"));
        
            return TRUE;
        }
        else
        {
            LOG((RTC_TRACE, "CRTCClient::IsIncomingSessionAuthorized - "
                "Caller not in watcher list; reject the incoming session, exit"));
        
            return FALSE;
        }
    }

    // found the watcher. Ok, see if it is allowed.
    RTC_WATCHER_STATE  enState;

    hr = pWatcher->get_State(&enState);

    pWatcher->Release();
    pWatcher = NULL;

    if(hr != S_OK || enState != RTCWS_ALLOWED)
    {
        LOG((RTC_TRACE, "CRTCClient::IsIncomingSessionAuthorized - "
            "Watcher is not allowed; reject the incoming session, exit"));

        return FALSE;
    }

    LOG((RTC_TRACE, "CRTCClient::IsIncomingSessionAuthorized - "
            "Watcher not allowed; authorize the incoming session, exit"));

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::StartIntensityMonitor
//
// This is an IRTCClient method that starts the intensity monitoring.
// This should be called when the streaming has started.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::StartIntensityMonitor(LONG lMediaType)
{
    LOG((RTC_TRACE, "CRTCClient::StartIntensityMonitor - entered"));

    DWORD dwResult;
    HRESULT hr;

    if ( ( lMediaType != RTCMT_AUDIO_SEND ) && 
         ( lMediaType != RTCMT_AUDIO_RECEIVE )
       )
    {
        // We do not handle any other type

        LOG((RTC_INFO, "CRTCClient::StartIntensityMonitor - Can't handle "
                       "mediatype(%d).", lMediaType));
        return S_OK;
    }

    if(m_lActiveIntensity == 0)
    {
        // Try to start the timer
        DWORD dwID = (DWORD)SetTimer(m_hWnd, TID_INTENSITY, INTENSITY_POLL_INTERVAL, NULL);
        if(dwID==0)
        {
            dwResult = GetLastError();

            LOG((RTC_ERROR, "CRTCClient::StartIntensityMonitor - Failed "
                           "to start timer (%x).", dwResult));

            return HRESULT_FROM_WIN32(dwResult);
        }
    }

    if(lMediaType == RTCMT_AUDIO_SEND)
    {
        
        m_lActiveIntensity |= RTCMT_AUDIO_SEND;
        
        if(!m_pCaptureAudioCfg)
        {
            hr = GetAudioCfg(
                         RTCAD_MICROPHONE,
                         &m_pCaptureAudioCfg
                        );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::StartIntensityMonitor - "
                                    "GetAudioCfg(Capture) failed 0x%lx", hr));     

            }
        }

        m_uiMinCapture = 0;
        m_uiMaxCapture = 0;

        if(m_pCaptureAudioCfg)
        {
            m_pCaptureAudioCfg->GetAudioLevelRange(&m_uiMinCapture, &m_uiMaxCapture);
        }
    }
    
    else if(lMediaType == RTCMT_AUDIO_RECEIVE)
    {
        m_lActiveIntensity |= RTCMT_AUDIO_RECEIVE;

        if(!m_pRenderAudioCfg)
        {
            hr = GetAudioCfg(
                         RTCAD_SPEAKER,
                         &m_pRenderAudioCfg
                        );
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::StartIntensityMonitor - "
                                    "GetAudioCfg(Render) failed 0x%lx", hr));     

            }
        }

        m_uiMinRender = 0;
        m_uiMaxRender = 0;

        if(m_pRenderAudioCfg)
        {
            m_pRenderAudioCfg->GetAudioLevelRange(&m_uiMinRender, &m_uiMaxRender);
        }
    }
    
    LOG((RTC_TRACE, "CRTCClient::StartIntensityMonitor - exited"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::StopIntensityMonitor
//
// This is an IRTCClient method that stops the intensity monitoring
// This should be called when the streaming has ended.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::StopIntensityMonitor(LONG lMediaType)
{
    LOG((RTC_TRACE, "CRTCClient::StopIntensityMonitor - entered"));

    DWORD dwResult;

    if ( ( lMediaType != RTCMT_AUDIO_SEND ) && 
         ( lMediaType != RTCMT_AUDIO_RECEIVE )
       )
    {
        // We do not handle any other type

        LOG((RTC_INFO, "CRTCClient::StartIntensityMonitor - Can't handle "
                       "mediatype(%d).", lMediaType));
        return S_OK;
    }

    if(lMediaType == RTCMT_AUDIO_SEND)
    {
        m_lActiveIntensity &= ~RTCMT_AUDIO_SEND;

        if(m_pCaptureAudioCfg)
        {
            m_pCaptureAudioCfg->Release();
            m_pCaptureAudioCfg = NULL;
        }

        CRTCIntensityEvent::FireEvent(this, 0, RTCAD_MICROPHONE, 0, 0);
    }
    
    if(lMediaType == RTCMT_AUDIO_RECEIVE)
    {
        m_lActiveIntensity &= ~RTCMT_AUDIO_RECEIVE;

        if(m_pRenderAudioCfg)
        {
            m_pRenderAudioCfg->Release();
            m_pRenderAudioCfg = NULL;
        }

        CRTCIntensityEvent::FireEvent(this, 0, RTCAD_SPEAKER, 0, 0);
    }

    if(m_lActiveIntensity == 0)
    {
        // Kill timer
        KillTimer(m_hWnd, TID_INTENSITY);
    }

    LOG((RTC_TRACE, "CRTCClient::StopIntensityMonitor - exited"));

    return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnIntensityTimer
//
/////////////////////////////////////////////////////////////////////////////

void CRTCClient::OnIntensityTimer()
{

    UINT uiCaptureLevel, uiRenderLevel;

    if(m_lActiveIntensity & RTCMT_AUDIO_RECEIVE)
    {
        uiRenderLevel = 0;

        if(m_pRenderAudioCfg)
        {
            m_pRenderAudioCfg->GetAudioLevel(&uiRenderLevel);
        }

        CRTCIntensityEvent::FireEvent(this, uiRenderLevel, RTCAD_SPEAKER, m_uiMinRender, m_uiMaxRender);
    }
    
    if(m_lActiveIntensity & RTCMT_AUDIO_SEND)
    {
        uiCaptureLevel = 0;

        // If the capture device is muted, fake the volume to 0
        if(!m_bCaptureDeviceMuted && m_pCaptureAudioCfg)
        {
             m_pCaptureAudioCfg->GetAudioLevel(&uiCaptureLevel);
        }

        CRTCIntensityEvent::FireEvent(this, uiCaptureLevel, RTCAD_MICROPHONE, m_uiMinCapture, m_uiMaxCapture);

    }
}


#ifdef DUMP_PRESENCE

void CRTCClient::DumpWatchers(PCSTR szString)
{
    ULONG l;

    IRTCWatcher **pCrt;
    IRTCWatcher **pEnd;

    LOG((RTC_INFO, ""));
    LOG((RTC_INFO, " !!!!!! WATCHER LIST - %s  !!!!!", szString));
    LOG((RTC_INFO, "VISIBLE"));

    for(pCrt = &m_WatcherArray[0], pEnd = pCrt + m_WatcherArray.GetSize();
        pCrt < pEnd;
        pCrt++)
    {
        CRTCWatcher *pCWatcher = static_cast<CRTCWatcher *>(*pCrt);

        LOG((RTC_INFO, "    %s  %s  %S", 
            pCWatcher->m_bPersistent ? "PERS" : "VOL ",
            pCWatcher->m_nState == 0 ? "UNKNOWN " :
          ( pCWatcher->m_nState == 1 ? "OFFERING" :
          ( pCWatcher->m_nState == 2 ? "ALLOWED " : "BLOCKED ")),
            pCWatcher->m_szPresentityURI));


        ISIPWatcher ** pSipCrt;
        ISIPWatcher ** pSipEnd;

        for(pSipCrt = &pCWatcher->m_SIPWatchers[0], pSipEnd = pSipCrt + pCWatcher->m_SIPWatchers.GetSize();
            pSipCrt < pSipEnd;
            pSipCrt ++)
        {
            LOG((RTC_INFO, "        SIP  watcher %p", 
                (*pSipCrt) ));
        }
    }

    LOG((RTC_INFO, "HIDDEN"));

    for(pCrt = &m_HiddenWatcherArray[0], pEnd = pCrt + m_HiddenWatcherArray.GetSize();
        pCrt < pEnd;
        pCrt++)
    {
        CRTCWatcher *pCWatcher = static_cast<CRTCWatcher *>(*pCrt);

        LOG((RTC_INFO, "                    %S", 
            pCWatcher->m_szPresentityURI));

        ISIPWatcher ** pSipCrt;
        ISIPWatcher ** pSipEnd;

        for(pSipCrt = &pCWatcher->m_SIPWatchers[0], pSipEnd = pSipCrt + pCWatcher->m_SIPWatchers.GetSize();
            pSipCrt < pSipEnd;
            pSipCrt ++)
        {
            LOG((RTC_INFO, "        SIP  watcher %p", 
                (*pSipCrt) ));
        }
    }
    LOG((RTC_INFO, " END WATCHER LIST - %s ", szString));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcevents.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCEvents.cpp

Abstract:

    Implementation of the event classes

--*/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_CLIENT
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClientEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClientEvent::FireEvent(
                        CRTCClient * pCClient,                            
                        RTC_CLIENT_EVENT_TYPE enEventType
                       )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;

    LOG((RTC_TRACE, "CRTCClientEvent::FireEvent - enter" ));

    //
    // create event
    //

    CComObject<CRTCClientEvent> * p;
    hr = CComObject<CRTCClientEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClientEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClientEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //
    
    p->m_enEventType = enEventType;

    p->m_pClient = static_cast<IRTCClient *>(pCClient);
    p->m_pClient->AddRef();
        
#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_CLIENT,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCClientEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClientEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCClientEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCClientEvent::FinalRelease - enter"));

    if (m_pClient != NULL)
    {
        m_pClient->Release();
        m_pClient = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCClientEvent::FinalRelease - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClientEvent::get_EventType
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClientEvent::get_EventType(
        RTC_CLIENT_EVENT_TYPE * penEventType
        )
{
    if ( IsBadWritePtr(penEventType , sizeof(RTC_CLIENT_EVENT_TYPE) ) )
    {
        LOG((RTC_ERROR, "CRTCClientEvent::get_EventType - bad pointer"));

        return E_POINTER;
    }

    *penEventType = m_enEventType;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClientEvent::get_Client
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClientEvent::get_Client(
        IRTCClient ** ppClient
        )
{
    if ( IsBadWritePtr(ppClient , sizeof(IRTCClient *) ) )
    {
        LOG((RTC_ERROR, "CRTCClientEvent::get_Client - bad pointer"));

        return E_POINTER;
    }

    *ppClient = m_pClient;
    (*ppClient)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_REGISTRATION_STATE_CHANGE
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCRegistrationStateChangeEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCRegistrationStateChangeEvent::FireEvent(
                        CRTCClient * pCClient,
                        CRTCProfile * pCProfile,
                        RTC_REGISTRATION_STATE enState,
                        long lStatusCode,
                        PCWSTR szStatusText
                       )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;

    LOG((RTC_TRACE, "CRTCRegistrationStateChangeEvent::FireEvent - enter" ));

    //
    // create event
    //

    CComObject<CRTCRegistrationStateChangeEvent> * p;
    hr = CComObject<CRTCRegistrationStateChangeEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCRegistrationStateChangeEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCRegistrationStateChangeEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //

    p->m_pProfile = static_cast<IRTCProfile *>(pCProfile);
    p->m_pProfile->AddRef();
    
    p->m_enState = enState;
    p->m_lStatusCode = lStatusCode;
    p->m_szStatusText = RtcAllocString( szStatusText );
        
#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_REGISTRATION_STATE_CHANGE,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCRegistrationStateChangeEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCRegistrationStateChangeEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCRegistrationStateChangeEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCRegistrationStateChangeEvent::FinalRelease - enter"));

    if (m_pProfile != NULL)
    {
        m_pProfile->Release();
        m_pProfile = NULL;
    }

    if (m_szStatusText != NULL)
    {
        RtcFree(m_szStatusText);
        m_szStatusText = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCRegistrationStateChangeEvent::FinalRelease - exit"));
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCRegistrationStateChangeEvent::get_Profile
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCRegistrationStateChangeEvent::get_Profile(
        IRTCProfile ** ppProfile
        )
{
    if ( IsBadWritePtr(ppProfile , sizeof(IRTCProfile *) ) )
    {
        LOG((RTC_ERROR, "CRTCRegistrationStateChangeEvent::get_Profile - bad pointer"));

        return E_POINTER;
    }

    *ppProfile = m_pProfile;
    (*ppProfile)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCRegistrationStateChangeEvent::get_State
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCRegistrationStateChangeEvent::get_State(
        RTC_REGISTRATION_STATE * penState
        )
{
    if ( IsBadWritePtr(penState , sizeof(RTC_REGISTRATION_STATE) ) )
    {
        LOG((RTC_ERROR, "CRTCRegistrationStateChangeEvent::get_State - bad pointer"));

        return E_POINTER;
    }

    *penState = m_enState;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCRegistrationStateChangeEvent::get_StatusCode
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCRegistrationStateChangeEvent::get_StatusCode(
        long * plStatusCode
        )
{
    if ( IsBadWritePtr(plStatusCode , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCRegistrationStateChangeEvent::get_StatusCode - bad pointer"));

        return E_POINTER;
    }

    *plStatusCode = m_lStatusCode;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCRegistrationStateChangeEvent::get_StatusText
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCRegistrationStateChangeEvent::get_StatusText(
        BSTR * pbstrStatusText
        )
{
    if ( IsBadWritePtr(pbstrStatusText , sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCRegistrationStateChangeEvent::get_StatusText - bad pointer"));

        return E_POINTER;
    }

    *pbstrStatusText = NULL;

    if ( m_szStatusText == NULL )
    {
        LOG((RTC_ERROR, "CRTCRegistrationStateChangeEvent::get_StatusText - no value"));

        return E_FAIL;
    }

    *pbstrStatusText = SysAllocString(m_szStatusText);

    if ( *pbstrStatusText == NULL )
    {
        LOG((RTC_ERROR, "CRTCRegistrationStateChangeEvent::get_StatusText - out of memory"));

        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_SESSION_STATE_CHANGE
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionStateChangeEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSessionStateChangeEvent::FireEvent(
                       CRTCSession * pCSession,
                       RTC_SESSION_STATE enState,
                       long lStatusCode,
                       PCWSTR szStatusText
                      )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;
    CRTCClient                              * pCClient;

    LOG((RTC_TRACE, "CRTCSessionStateChangeEvent::FireEvent - enter" ));

    pCClient = pCSession->GetClient();

    if (pCClient == NULL)
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::FireEvent - GetClient failed"));
        
        return E_FAIL;
    }
    
    //
    // create event
    //

    CComObject<CRTCSessionStateChangeEvent> * p;
    hr = CComObject<CRTCSessionStateChangeEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //

    p->m_pSession = static_cast<IRTCSession *>(pCSession);
    p->m_pSession->AddRef();
    
    p->m_enState = enState;
    p->m_lStatusCode = lStatusCode;
    p->m_szStatusText = RtcAllocString( szStatusText );
        
#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_SESSION_STATE_CHANGE,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCSessionStateChangeEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionStateChangeEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCSessionStateChangeEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCSessionStateChangeEvent::FinalRelease - enter"));

    if (m_pSession != NULL)
    {
        m_pSession->Release();
        m_pSession = NULL;
    }

    if (m_szStatusText != NULL)
    {
        RtcFree(m_szStatusText);
        m_szStatusText = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCSessionStateChangeEvent::FinalRelease - exit"));
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionStateChangeEvent::get_Session
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSessionStateChangeEvent::get_Session(
        IRTCSession ** ppSession
        )
{
    if ( IsBadWritePtr(ppSession , sizeof(IRTCSession *) ) )
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::get_Session - bad pointer"));

        return E_POINTER;
    }

    *ppSession = m_pSession;
    (*ppSession)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionStateChangeEvent::get_State
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSessionStateChangeEvent::get_State(
        RTC_SESSION_STATE * penState
        )
{
    if ( IsBadWritePtr(penState , sizeof(RTC_SESSION_STATE) ) )
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::get_State - bad pointer"));

        return E_POINTER;
    }

    *penState = m_enState;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionStateChangeEvent::get_StatusCode
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSessionStateChangeEvent::get_StatusCode(
        long * plStatusCode
        )
{
    if ( IsBadWritePtr(plStatusCode , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::get_StatusCode - bad pointer"));

        return E_POINTER;
    }

    *plStatusCode = m_lStatusCode;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionStateChangeEvent::get_StatusText
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSessionStateChangeEvent::get_StatusText(
        BSTR * pbstrStatusText
        )
{
    if ( IsBadWritePtr(pbstrStatusText , sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::get_StatusText - bad pointer"));

        return E_POINTER;
    }

    *pbstrStatusText = NULL;

    if ( m_szStatusText == NULL )
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::get_StatusText - no value"));

        return E_FAIL;
    }

    *pbstrStatusText = SysAllocString(m_szStatusText);

    if ( *pbstrStatusText == NULL )
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::get_StatusText - out of memory"));

        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_SESSION_OPERATION_COMPLETE
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionOperationCompleteEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSessionOperationCompleteEvent::FireEvent(
                       CRTCSession * pCSession,
                       long lCookie,
                       long lStatusCode,
                       PCWSTR szStatusText
                      )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;
    CRTCClient                              * pCClient;

    LOG((RTC_TRACE, "CRTCSessionOperationCompleteEvent::FireEvent - enter" ));

    pCClient = pCSession->GetClient();

    if (pCClient == NULL)
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::FireEvent - GetClient failed"));
        
        return E_FAIL;
    }
    
    //
    // create event
    //

    CComObject<CRTCSessionOperationCompleteEvent> * p;
    hr = CComObject<CRTCSessionOperationCompleteEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //

    p->m_pSession = static_cast<IRTCSession *>(pCSession);
    p->m_pSession->AddRef();
    
    p->m_lCookie = lCookie;
    p->m_lStatusCode = lStatusCode;
    p->m_szStatusText = RtcAllocString( szStatusText );
        
#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_SESSION_OPERATION_COMPLETE,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCSessionOperationCompleteEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionOperationCompleteEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCSessionOperationCompleteEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCSessionOperationCompleteEvent::FinalRelease - enter"));

    if (m_pSession != NULL)
    {
        m_pSession->Release();
        m_pSession = NULL;
    }

    if (m_szStatusText != NULL)
    {
        RtcFree(m_szStatusText);
        m_szStatusText = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCSessionOperationCompleteEvent::FinalRelease - exit"));
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionOperationCompleteEvent::get_Session
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSessionOperationCompleteEvent::get_Session(
        IRTCSession ** ppSession
        )
{
    if ( IsBadWritePtr(ppSession , sizeof(IRTCSession *) ) )
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::get_Session - bad pointer"));

        return E_POINTER;
    }

    *ppSession = m_pSession;
    (*ppSession)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionOperationCompleteEvent::get_Cookie
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSessionOperationCompleteEvent::get_Cookie(
        long * plCookie
        )
{
    if ( IsBadWritePtr(plCookie , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::get_State - bad pointer"));

        return E_POINTER;
    }

    *plCookie = m_lCookie;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionOperationCompleteEvent::get_StatusCode
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSessionOperationCompleteEvent::get_StatusCode(
        long * plStatusCode
        )
{
    if ( IsBadWritePtr(plStatusCode , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::get_StatusCode - bad pointer"));

        return E_POINTER;
    }

    *plStatusCode = m_lStatusCode;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionOperationCompleteEvent::get_StatusText
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSessionOperationCompleteEvent::get_StatusText(
        BSTR * pbstrStatusText
        )
{
    if ( IsBadWritePtr(pbstrStatusText , sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::get_StatusText - bad pointer"));

        return E_POINTER;
    }

    *pbstrStatusText = NULL;

    if ( m_szStatusText == NULL )
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::get_StatusText - no value"));

        return E_FAIL;
    }

    *pbstrStatusText = SysAllocString(m_szStatusText);

    if ( *pbstrStatusText == NULL )
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::get_StatusText - out of memory"));

        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_PARTICIPANT_STATE_CHANGE
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipantStateChangeEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCParticipantStateChangeEvent::FireEvent(
                       CRTCParticipant * pCParticipant,
                       RTC_PARTICIPANT_STATE enState,
                       long lStatusCode
                      )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;
    CRTCClient                              * pCClient;

    LOG((RTC_TRACE, "CRTCParticipantStateChangeEvent::FireEvent - enter" ));

    pCClient = pCParticipant->GetClient();

    if (pCClient == NULL)
    {
        LOG((RTC_ERROR, "CRTCParticipantStateChangeEvent::FireEvent - GetClient failed"));
        
        return E_FAIL;
    }
    
    //
    // create event
    //

    CComObject<CRTCParticipantStateChangeEvent> * p;
    hr = CComObject<CRTCParticipantStateChangeEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCParticipantStateChangeEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCParticipantStateChangeEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //

    p->m_pParticipant = static_cast<IRTCParticipant *>(pCParticipant);
    p->m_pParticipant->AddRef();
    
    p->m_enState = enState;
    p->m_lStatusCode = lStatusCode;
        
#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_PARTICIPANT_STATE_CHANGE,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCParticipantStateChangeEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipantStateChangeEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCParticipantStateChangeEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCParticipantStateChangeEvent::FinalRelease - enter"));

    if (m_pParticipant != NULL)
    {
        m_pParticipant->Release();
        m_pParticipant = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCParticipantStateChangeEvent::FinalRelease - exit"));
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipantStateChangeEvent::get_Participant
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCParticipantStateChangeEvent::get_Participant(
        IRTCParticipant ** ppParticipant
        )
{
    if ( IsBadWritePtr(ppParticipant , sizeof(IRTCParticipant *) ) )
    {
        LOG((RTC_ERROR, "CRTCParticipantStateChangeEvent::get_Participant - bad pointer"));

        return E_POINTER;
    }

    *ppParticipant = m_pParticipant;
    (*ppParticipant)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipantStateChangeEvent::get_State
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCParticipantStateChangeEvent::get_State(
        RTC_PARTICIPANT_STATE * penState
        )
{
    if ( IsBadWritePtr(penState , sizeof(RTC_PARTICIPANT_STATE) ) )
    {
        LOG((RTC_ERROR, "CRTCParticipantStateChangeEvent::get_State - bad pointer"));

        return E_POINTER;
    }

    *penState = m_enState;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipantStateChangeEvent::get_StatusCode
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCParticipantStateChangeEvent::get_StatusCode(
        long * plStatusCode
        )
{
    if ( IsBadWritePtr(plStatusCode , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCParticipantStateChangeEvent::get_StatusCode - bad pointer"));

        return E_POINTER;
    }

    *plStatusCode = m_lStatusCode;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_MEDIA
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMediaEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCMediaEvent::FireEvent(
                       CRTCClient * pCClient,
                       RTC_MEDIA_EVENT_TYPE enEventType,
                       RTC_MEDIA_EVENT_REASON enEventReason,
                       long lMediaType
                      )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;

    LOG((RTC_TRACE, "CRTCMediaEvent::FireEvent - enter" ));
    
    //
    // create event
    //

    CComObject<CRTCMediaEvent> * p;
    hr = CComObject<CRTCMediaEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCMediaEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCMediaEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //
    
    p->m_enEventType = enEventType;
    p->m_enEventReason = enEventReason;
    p->m_lMediaType = lMediaType;
        
#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_MEDIA,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCMediaEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMediaEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCMediaEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCMediaEvent::FinalRelease - enter"));

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCMediaEvent::FinalRelease - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMediaEvent::get_EventType
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMediaEvent::get_EventType(
        RTC_MEDIA_EVENT_TYPE * penEventType
        )
{
    if ( IsBadWritePtr(penEventType , sizeof(RTC_MEDIA_EVENT_TYPE) ) )
    {
        LOG((RTC_ERROR, "CRTCMediaEvent::get_EventType - bad pointer"));

        return E_POINTER;
    }

    *penEventType = m_enEventType;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMediaEvent::get_EventReason
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMediaEvent::get_EventReason(
        RTC_MEDIA_EVENT_REASON * penEventReason
        )
{
    if ( IsBadWritePtr(penEventReason , sizeof(RTC_MEDIA_EVENT_REASON) ) )
    {
        LOG((RTC_ERROR, "CRTCMediaEvent::get_EventReason - bad pointer"));

        return E_POINTER;
    }

    *penEventReason = m_enEventReason;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMediaEvent::get_MediaType
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMediaEvent::get_MediaType(
        long * plMediaType
        )
{
    if ( IsBadWritePtr(plMediaType , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCMediaEvent::get_MediaType - bad pointer"));

        return E_POINTER;
    }

    *plMediaType = m_lMediaType;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_INTENSITY
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCIntensityEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCIntensityEvent::FireEvent(
                             CRTCClient * pCClient,
                             long lValue,
                             RTC_AUDIO_DEVICE direction,
                             long lMin,
                             long lMax
                      )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;

    //LOG((RTC_TRACE, "CRTCIntensityEvent::FireEvent - enter" ));
    
    //
    // create event
    //

    CComObject<CRTCIntensityEvent> * p;
    hr = CComObject<CRTCIntensityEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCIntensityEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCIntensityEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //
    
    p->m_lLevel = lValue;
    p->m_lMin = lMin;
    p->m_lMax = lMax;
    p->m_Direction = direction;
        

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_INTENSITY,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    //LOG((RTC_TRACE, "CRTCIntensityEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCIntensityEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCIntensityEvent::FinalRelease()
{
    //LOG((RTC_TRACE, "CRTCIntensityEvent::FinalRelease - enter"));

    //LOG((RTC_TRACE, "CRTCIntensityEvent::FinalRelease - exit"));
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCIntensityEvent::get_Level
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCIntensityEvent::get_Level(long * plLevel)
{
    //LOG((RTC_TRACE, "CRTCIntensityEvent::get_Level - enter"));

    if ( IsBadWritePtr(plLevel , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCIntensityEvent::get_Level - bad pointer"));

        return E_POINTER;
    }

    *plLevel = m_lLevel;

    //LOG((RTC_TRACE, "CRTCIntensityEvent::get_Level - exit"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCIntensityEvent::get_Min
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCIntensityEvent::get_Min(long * plMin)
{
    //LOG((RTC_TRACE, "CRTCIntensityEvent::get_Min - enter"));

    if ( IsBadWritePtr(plMin , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCIntensityEvent::get_Min - bad pointer"));

        return E_POINTER;
    }

    *plMin = m_lMin;

    //LOG((RTC_TRACE, "CRTCIntensityEvent::get_Min - exit"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCIntensityEvent::get_Max
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCIntensityEvent::get_Max(long * plMax)
{
    //LOG((RTC_TRACE, "CRTCIntensityEvent::get_Max - enter"));

    if ( IsBadWritePtr(plMax , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCIntensityEvent::get_Max - bad pointer"));

        return E_POINTER;
    }

    *plMax = m_lMax;

    //LOG((RTC_TRACE, "CRTCIntensityEvent::get_Max - exit"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCIntensityEvent::get_Direction
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCIntensityEvent::get_Direction(RTC_AUDIO_DEVICE * plDirection)
{
    //LOG((RTC_TRACE, "CRTCIntensityEvent::get_Direction - enter"));

    if ( IsBadWritePtr(plDirection , sizeof(RTC_AUDIO_DEVICE) ) )
    {
        LOG((RTC_ERROR, "CRTCIntensityEvent::get_Direction - bad pointer"));

        return E_POINTER;
    }

    *plDirection = m_Direction;

    //LOG((RTC_TRACE, "CRTCIntensityEvent::get_Direction - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_MESSAGE
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCMessagingEvent::FireEvent(
                       CRTCSession * pCSession,
                       IRTCParticipant * pParticipant,
                       PCWSTR szMessage,
                       PCWSTR szMessageHeader,
                       RTC_MESSAGING_EVENT_TYPE enEventType,
                       RTC_MESSAGING_USER_STATUS enUserStatus
                      )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;
    CRTCClient                              * pCClient;

    LOG((RTC_TRACE, "CRTCMessagingEvent::FireEvent - enter" ));

    pCClient = pCSession->GetClient();

    if (pCClient == NULL)
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::FireEvent - GetClient failed"));
        
        return E_FAIL;
    }
    
    //
    // create event
    //

    CComObject<CRTCMessagingEvent> * p;
    hr = CComObject<CRTCMessagingEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //

    p->m_pSession = static_cast<IRTCSession *>(pCSession);
    p->m_pSession->AddRef();

    p->m_pParticipant = pParticipant;
    p->m_pParticipant->AddRef();

    p->m_szMessage = RtcAllocString( szMessage );
    p->m_szMessageHeader = RtcAllocString( szMessageHeader );

    p->m_enEventType = enEventType;
    p->m_enUserStatus = enUserStatus;
        
#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_MESSAGING,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCMessagingEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCMessagingEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCMessagingEvent::FinalRelease - enter"));

    if (m_pSession != NULL)
    {
        m_pSession->Release();
        m_pSession = NULL;
    }

    if (m_pParticipant != NULL)
    {
        m_pParticipant->Release();
        m_pParticipant = NULL;
    }

    if (m_szMessage != NULL)
    {
        RtcFree(m_szMessage);
        m_szMessage = NULL;
    }

    if (m_szMessageHeader != NULL)
    {
        RtcFree(m_szMessageHeader);
        m_szMessageHeader = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCMessagingEvent::FinalRelease - exit"));
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent::get_Session
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMessagingEvent::get_Session(
        IRTCSession ** ppSession
        )
{
    if ( IsBadWritePtr(ppSession , sizeof(IRTCSession *) ) )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_Session - bad pointer"));

        return E_POINTER;
    }

    *ppSession = m_pSession;
    (*ppSession)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent::get_Participant
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMessagingEvent::get_Participant(
        IRTCParticipant ** ppParticipant
        )
{
    if ( IsBadWritePtr(ppParticipant , sizeof(IRTCParticipant *) ) )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_Participant - bad pointer"));

        return E_POINTER;
    }

    *ppParticipant = m_pParticipant;
    (*ppParticipant)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent::get_Message
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMessagingEvent::get_Message(
        BSTR * pbstrMessage
        )
{
    if ( IsBadWritePtr(pbstrMessage , sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_Message - bad pointer"));

        return E_POINTER;
    }

    *pbstrMessage = NULL;

    if ( m_szMessage == NULL )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_Message - no value"));

        return E_FAIL;
    }

    *pbstrMessage = SysAllocString(m_szMessage);

    if ( *pbstrMessage == NULL )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_Message - out of memory"));

        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent::get_MessageHeader
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMessagingEvent::get_MessageHeader(
        BSTR * pbstrMessageHeader
        )
{
    if ( IsBadWritePtr(pbstrMessageHeader , sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_MessageHeader - bad pointer"));

        return E_POINTER;
    }

    *pbstrMessageHeader = NULL;

    if ( m_szMessageHeader == NULL )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_MessageHeader - no value"));

        return E_FAIL;
    }

    *pbstrMessageHeader = SysAllocString(m_szMessageHeader);

    if ( *pbstrMessageHeader == NULL )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_MessageHeader - out of memory"));

        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent::get_EventType
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMessagingEvent::get_EventType(
        RTC_MESSAGING_EVENT_TYPE * penEventType
        )
{
    if ( IsBadWritePtr(penEventType , sizeof(RTC_MESSAGING_EVENT_TYPE) ) )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_EventType - bad pointer"));

        return E_POINTER;
    }

    *penEventType = m_enEventType;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent::get_UserStatus
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMessagingEvent::get_UserStatus(
        RTC_MESSAGING_USER_STATUS * penUserStatus
        )
{
    if ( IsBadWritePtr(penUserStatus , sizeof(RTC_MESSAGING_USER_STATUS) ) )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_UserStatus - bad pointer"));

        return E_POINTER;
    }

    *penUserStatus = m_enUserStatus;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_BUDDY
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddyEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCBuddyEvent::FireEvent(
                       CRTCClient * pCClient,
                       IRTCBuddy * pBuddy
                      )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;

    //
    // create event
    //

    CComObject<CRTCBuddyEvent> * p;
    hr = CComObject<CRTCBuddyEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCBuddyEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCBuddyEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //

    p->m_pBuddy = pBuddy;
    p->m_pBuddy->AddRef();

#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_BUDDY,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCBuddyEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddyEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCBuddyEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCBuddyEvent::FinalRelease - enter"));

    if (m_pBuddy != NULL)
    {
        m_pBuddy->Release();
        m_pBuddy = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCBuddyEvent::FinalRelease - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddyEvent::get_Buddy
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddyEvent::get_Buddy(
        IRTCBuddy **ppBuddy
        )
{
    if ( IsBadWritePtr(ppBuddy , sizeof( IRTCBuddy * ) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddyEvent::get_Buddy - bad pointer"));

        return E_POINTER;
    }

    *ppBuddy = m_pBuddy;

    if (*ppBuddy != NULL)
    {
        (*ppBuddy)->AddRef();
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_WATCHER
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcherEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCWatcherEvent::FireEvent(
                       CRTCClient * pCClient,
                       IRTCWatcher * pWatcher
                      )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;

    //
    // create event
    //

    CComObject<CRTCWatcherEvent> * p;
    hr = CComObject<CRTCWatcherEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCWatcherEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get iunknown interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWatcherEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //

    p->m_pWatcher = pWatcher;
    p->m_pWatcher->AddRef();

#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_WATCHER,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCWatcherEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcherEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCWatcherEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCWatcherEvent::FinalRelease - enter"));

    if (m_pWatcher != NULL)
    {
        m_pWatcher->Release();
        m_pWatcher = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCWatcherEvent::FinalRelease - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcherEvent::get_Watcher
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcherEvent::get_Watcher(
        IRTCWatcher **ppWatcher
        )
{
    if ( IsBadWritePtr(ppWatcher , sizeof( IRTCWatcher * ) ) )
    {
        LOG((RTC_ERROR, "CRTCWatcherEvent::get_Unknown - bad pointer"));

        return E_POINTER;
    }

    *ppWatcher = m_pWatcher;

    if (*ppWatcher != NULL)
    {
        (*ppWatcher)->AddRef();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtccoll.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCColl.h

Abstract:

    Template classes for collections

--*/

#ifndef __RTCCOLL__
#define __RTCCOLL__
////////////////////////////////////////////////////////////////////////
// CRtcCollection
//      Collection template
////////////////////////////////////////////////////////////////////////
template <class T> class ATL_NO_VTABLE CRTCCollection :
    public CComDualImpl<IRTCCollection, &IID_IRTCCollection, &LIBID_RTCCORELib>,
    public CComObjectRoot
{
public:
    typedef CRTCCollection<T> _CRTCCollectionBase;

BEGIN_COM_MAP(_CRTCCollectionBase)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCCollection)
END_COM_MAP()

private:

    int                 m_nSize;
    CComVariant *       m_Var;
    
public:

    CRTCCollection() : m_nSize(0),
                       m_Var(NULL)
                       {}


    // initialize
    HRESULT STDMETHODCALLTYPE Initialize(
                                         CRTCObjectArray<T *> array
                                        )
    {
        int                     i;
        HRESULT                 hr;

        LOG((RTC_TRACE, "Initialize - enter"));

        // create variant array
        m_nSize = array.GetSize();

        m_Var = new CComVariant[m_nSize];

        if (m_Var == NULL)
        {
            LOG((RTC_ERROR, "Initialize - out of memory"));
            return E_OUTOFMEMORY;
        }

        for (i = 0; i < array.GetSize(); i++)
        {
            // get IDispatch pointer
            IDispatch * pDisp = NULL;
            IUnknown *  pUnk = NULL;

            // try to get an IDispatch first
            hr = array[i]->QueryInterface(IID_IDispatch, (void**)&pDisp);

            if (S_OK != hr)
            {
                // Try an IUnknown
                hr = array[i]->QueryInterface(IID_IUnknown, (void**)&pUnk);
                
                if (S_OK != hr)
                {
                    // this would be interesting...          
                    return hr;
                }
            }

            // create a variant and add it to the collection
            CComVariant& var = m_Var[i];

            VariantInit(&var);
            
            if(pDisp)
            {
                var.vt = VT_DISPATCH;
                var.pdispVal = pDisp;
            }
            else
            {
                var.vt = VT_UNKNOWN;
                var.punkVal = pUnk;
            }
        }

        this->AddRef();

        LOG((RTC_TRACE, "Initialize - exit"));
        
        return S_OK;
    }

    // initialize
    HRESULT STDMETHODCALLTYPE Initialize(
                                         CRTCArray<T *> array
                                        )
    {
        int                     i;
        HRESULT                 hr;

        LOG((RTC_TRACE, "Initialize - enter"));

        // create variant array
        m_nSize = array.GetSize();

        m_Var = new CComVariant[m_nSize];

        if (m_Var == NULL)
        {
            LOG((RTC_ERROR, "Initialize - out of memory"));
            return E_OUTOFMEMORY;
        }

        for (i = 0; i < array.GetSize(); i++)
        {
            // get IDispatch pointer
            IDispatch * pDisp = NULL;

            hr = array[i]->QueryInterface(IID_IDispatch, (void**)&pDisp);

            if (S_OK != hr)
            {
                return hr;
            }

            // create a variant and add it to the collection
            CComVariant& var = m_Var[i];

            VariantInit(&var);
            
            var.vt = VT_DISPATCH;
            var.pdispVal = pDisp;
        }

        this->AddRef();

        LOG((RTC_TRACE, "Initialize - exit"));
        
        return S_OK;
    }

    void FinalRelease()
    {
        //
        // We "new"ed an array of objects -- delete the array and call
        // each object's destructor. Each destructor calls VariantClear,
        // which calls Release on each pointer.
        //

        if(m_Var != NULL)
        {
            delete [] m_Var;
        }
    }
    
    STDMETHOD(get_Count)(
                         long* retval
                        )
    {
        LOG((RTC_TRACE, "get_Count - enter"));

        if ( IsBadWritePtr( retval, sizeof(long) ) )
        {
            return E_POINTER;
        }
        
        *retval = m_nSize;

        LOG((RTC_TRACE, "get_Count - exit"));

        return S_OK;
    }

    STDMETHOD(get_Item)(
                        long Index, 
                        VARIANT* retval
                       )
    {
        LOG((RTC_TRACE, "get_Item - enter"));

        if ( IsBadWritePtr (retval, sizeof(VARIANT) ) )
        {
            return E_POINTER;
        }
        
        VariantInit(retval);

        retval->vt = VT_UNKNOWN;
        retval->punkVal = NULL;

        // use 1-based index, VB like
        if ((Index < 1) || (Index > m_nSize))
        {
            return E_INVALIDARG;
        }

        VariantCopy(retval, &m_Var[Index-1]);

        LOG((RTC_TRACE, "get_Item - exit"));
        
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE get__NewEnum(
                                           IUnknown** retval
                                          )
    
    {
        HRESULT         hr;

        LOG((RTC_TRACE, "new__Enum - enter"));
        
        if ( IsBadWritePtr( retval, sizeof( IUnknown * ) ) )
        {
            return E_POINTER;
        }

        *retval = NULL;

        typedef CComObject<CComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> > > enumvar;

        enumvar* p; // = new enumvar;
        enumvar::CreateInstance( &p );

        _ASSERTE(p);
        
        if (p == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {

            hr = p->Init(&m_Var[0], &m_Var[m_nSize], NULL, AtlFlagCopy);

            if (SUCCEEDED(hr))
            {
                hr = p->QueryInterface(IID_IEnumVARIANT, (void**)retval);
            }

            if (FAILED(hr))
            {
                delete p;
            }
        }

        LOG((RTC_TRACE, "new__Enum - exit"));
        
        return hr;

    }
};

#endif //__RTCCOLL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcparticipant.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCParticipant.h

Abstract:

    Definition of the CRTCParticipant class

--*/

#ifndef __RTCPARTICIPANT__
#define __RTCPARTICIPANT__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CRTCParticipant

class ATL_NO_VTABLE CRTCParticipant :
#ifdef TEST_IDISPATCH
    public IDispatchImpl<IRTCParticipant, &IID_IRTCParticipant, &LIBID_RTCCORELib>, 
#else
    public IRTCParticipant,
#endif
	public CComObjectRoot
{
public:
    CRTCParticipant() : m_pCClient(NULL), 
                        m_pSession(NULL),
                        m_enState(RTCPS_IDLE),
                        m_szUserURI(NULL),
                        m_szName(NULL),
                        m_bRemovable(FALSE)
                        
    {}
BEGIN_COM_MAP(CRTCParticipant)
#ifdef TEST_IDISPATCH
    COM_INTERFACE_ENTRY(IDispatch)
#endif
    COM_INTERFACE_ENTRY(IRTCParticipant)
END_COM_MAP()

    HRESULT FinalConstruct();

    void FinalRelease();

    STDMETHOD_(ULONG, InternalAddRef)();

    STDMETHOD_(ULONG, InternalRelease)(); 

    CRTCClient * GetClient();

    HRESULT Initialize(
                      CRTCClient * pCClient, 
                      IRTCSession * pSession,
                      PCWSTR szUserURI,
                      PCWSTR szName,
                      BOOL   bRemovable = FALSE
                      );

    HRESULT SetState(
                     RTC_PARTICIPANT_STATE enState,
                     long lStatusCode
                    );
            
private:

    CRTCClient            * m_pCClient;
    IRTCSession           * m_pSession;
    RTC_PARTICIPANT_STATE   m_enState;
    PWSTR                   m_szUserURI;
    PWSTR                   m_szName;
    BOOL                    m_bRemovable;
 
#if DBG
    PWSTR                   m_pDebug;
#endif

// IRTCParticipant
public:

    STDMETHOD(get_UserURI)(
            BSTR * pbstrUserURI
            );   

    STDMETHOD(get_Name)(
            BSTR * pbstrName
            );  

    STDMETHOD(get_Removable)(
            VARIANT_BOOL * pfRemovable
            );   

    STDMETHOD(get_State)(
            RTC_PARTICIPANT_STATE * penState
            );

    STDMETHOD(get_Session)(
            IRTCSession ** ppSession
            );
};

#endif //__RTCPARTICIPANT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcparticipant.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCParticipant.cpp

Abstract:

    Implementation of the CRTCParticipant class

--*/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::FinalConstruct
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCParticipant::FinalConstruct()
{
    LOG((RTC_TRACE, "CRTCParticipant::FinalConstruct [%p] - enter", this));

#if DBG
    m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)m_pDebug) = this;
#endif

    LOG((RTC_TRACE, "CRTCParticipant::FinalConstruct [%p] - exit S_OK", this));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCParticipant::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCParticipant::FinalRelease [%p] - enter", this));

    if ( m_pCClient != NULL )
    {
        m_pCClient->Release();
        m_pCClient = NULL;
    }

    if ( m_szName != NULL )
    {
        RtcFree(m_szName);
        m_szName = NULL;
    }

    if ( m_szUserURI != NULL )
    {
        RtcFree(m_szUserURI);
        m_szUserURI = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCParticipant::FinalRelease [%p] - exit", this));
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::InternalAddRef
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCParticipant::InternalAddRef()
{
    DWORD dwR;

    dwR = InterlockedIncrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCParticipant::InternalAddRef [%p] - dwR %d", this, dwR));

    if ( (dwR > 0) && m_pSession )
    {
        m_pSession->AddRef();
    }

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::InternalRelease
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCParticipant::InternalRelease()
{
    DWORD               dwR;
    
    dwR = InterlockedDecrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCParticipant::InternalRelease [%p] - dwR %d", this, dwR));

    if ( (dwR > 0) && m_pSession )
    {
        m_pSession->Release();
    }

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::Initialize
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCParticipant::Initialize(
                            CRTCClient  * pCClient,   
                            IRTCSession * pSession,
                            PCWSTR        szUserURI,
                            PCWSTR        szName,
                            BOOL          bRemovable
                           )
{
    LOG((RTC_TRACE, "CRTCParticipant::Initialize - enter"));

    m_szUserURI = RtcAllocString(szUserURI);
    m_szName = RtcAllocString(szName);
    m_bRemovable = bRemovable;

    m_pCClient = pCClient;
    if (m_pCClient != NULL)
    {
        m_pCClient->AddRef();
    }

    m_pSession = pSession; // don't addref

    LOG((RTC_TRACE, "CRTCParticipant::Initialize - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::GetClient
//
/////////////////////////////////////////////////////////////////////////////

CRTCClient * 
CRTCParticipant::GetClient()
{
    LOG((RTC_TRACE, "CRTCParticipant::GetClient"));

    return m_pCClient;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::SetState
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCParticipant::SetState(
                          RTC_PARTICIPANT_STATE enState,
                          long lStatusCode
                         )
{
    LOG((RTC_TRACE, "CRTCParticipant::SetState - enter"));

    //
    // We only need to do something if this is a new state
    //
    
    if (m_enState != enState)
    {
        LOG((RTC_INFO, "CRTCParticipant::SetState - new state"));
        
        m_enState = enState;
    }

    LOG((RTC_INFO, "CRTCParticipant::SetState - "
            "state [%d] status [%d]", enState, lStatusCode));

    //
    // Fire a state change event
    //
    
    CRTCParticipantStateChangeEvent::FireEvent(this, m_enState, lStatusCode);

    LOG((RTC_TRACE, "CRTCParticipant::SetState - exit S_OK"));

    return S_OK;
}    

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::get_UserURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCParticipant::get_UserURI(
        BSTR * pbstrUserURI
        )
{
    LOG((RTC_TRACE, "CRTCParticipant::get_UserURI - enter"));

    if ( IsBadWritePtr( pbstrUserURI, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_UserURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szUserURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_UserURI - "
                            "pariticpant has no address"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrUserURI = SysAllocString(m_szUserURI);

    if ( *pbstrUserURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_UserURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCParticipant::get_UserURI - exit S_OK"));

    return S_OK;
}              

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::get_Name
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCParticipant::get_Name(
        BSTR * pbstrName
        )
{
    LOG((RTC_TRACE, "CRTCParticipant::get_Name - enter"));

    if ( IsBadWritePtr( pbstrName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_Name - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_Name - "
                            "pariticpant has no name"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrName = SysAllocString(m_szName);

    if ( *pbstrName == NULL )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_Name - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCParticipant::get_Name - exit S_OK"));

    return S_OK;
}        

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::get_Removable
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCParticipant::get_Removable(
        VARIANT_BOOL * pfRemovable
        )
{
    LOG((RTC_TRACE, "CRTCParticipant::get_Removable - enter"));

    if ( IsBadWritePtr(pfRemovable , sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_Removable - bad pointer"));

        return E_POINTER;
    }

    //
    // Cannot be removed if in Disconnecting mode.
    //

    *pfRemovable = (m_bRemovable && 
        m_enState != RTCPS_DISCONNECTING) ? VARIANT_TRUE : VARIANT_FALSE;

    LOG((RTC_TRACE, "CRTCParticipant::get_Removable - exit S_OK"));

    return S_OK;
}        

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::get_State
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCParticipant::get_State(
        RTC_PARTICIPANT_STATE * penState
        )
{
    LOG((RTC_TRACE, "CRTCParticipant::get_State - enter"));

    if ( IsBadWritePtr(penState , sizeof(RTC_PARTICIPANT_STATE) ) )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_State - bad pointer"));

        return E_POINTER;
    }

    *penState = m_enState;
   
    LOG((RTC_TRACE, "CRTCParticipant::get_State - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::get_Session
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCParticipant::get_Session(
            IRTCSession ** ppSession
            )
{
    LOG((RTC_TRACE, "CRTCParticipant::get_Session - enter"));

    if ( IsBadWritePtr(ppSession , sizeof(IRTCSession *) ) )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_Session - bad pointer"));

        return E_POINTER;
    }

    *ppSession = m_pSession;
    if (m_pSession) m_pSession->AddRef();
   
    LOG((RTC_TRACE, "CRTCParticipant::get_Session - exit S_OK"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcprofile.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCProfile.h

Abstract:

    Definition of the CRTCProfile class

--*/

#ifndef __RTCPROFILE__
#define __RTCPROFILE__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

struct PROF_PROVISION
{
    PWSTR szKey;
    PWSTR szName;
    PWSTR szExpires;
};

struct PROF_PROVIDER
{
    PWSTR szName;
    PWSTR szHomepage;
    PWSTR szHelpdesk;
    PWSTR szPersonal;
    PWSTR szCallDisplay;
    PWSTR szIdleDisplay;
    PWSTR szData;
};

struct PROF_CLIENT
{
    PWSTR szName;
    BOOL fBanner;
    PWSTR szMinVer;
    PWSTR szCurVer;
    PWSTR szUpdateUri;
    PWSTR szData;
};

struct PROF_USER
{
    PWSTR szAccount;
    PWSTR szName;
    PWSTR szUri;
    PWSTR szPassword;
    PWSTR szRealm;
};

struct PROF_SERVER
{
    PWSTR szAddr;
    SIP_TRANSPORT enProtocol;
    SIP_AUTH_PROTOCOL enAuth;    
    long lSessions;
    BOOL fRegistrar;
};

/*
struct PROF_ACCESSCONTROL
{
    PWSTR szDomain;
    PWSTR szSig;
};
*/

/////////////////////////////////////////////////////////////////////////////
// CRTCProfile

class ATL_NO_VTABLE CRTCProfile :
#ifdef TEST_IDISPATCH
    public IDispatchImpl<IRTCProfile, &IID_IRTCProfile, &LIBID_RTCCORELib>,
#else
    public IRTCProfile,
#endif
    public CComObjectRoot
{
public:
    CRTCProfile() : m_pCClient(NULL),
                    m_szProfileXML(NULL),
                    m_ProfileGuid(GUID_NULL),
                    m_enState(RTCRS_NOT_REGISTERED),
                    m_fValid(FALSE),
                    m_fEnabled(FALSE),
                    m_lRegisterFlags(0),
                    m_pSipStack(NULL)
    {}
    
BEGIN_COM_MAP(CRTCProfile)
#ifdef TEST_IDISPATCH
    COM_INTERFACE_ENTRY(IDispatch)
#endif
    COM_INTERFACE_ENTRY(IRTCProfile)
END_COM_MAP()

    HRESULT FinalConstruct();

    void FinalRelease();   

    STDMETHOD_(ULONG, InternalAddRef)();

    STDMETHOD_(ULONG, InternalRelease)(); 
                      
    HRESULT InitializeFromString(
                                 BSTR bstrProfileXML,
                                 CRTCClient * pCClient,
                                 ISipStack * pSipStack
                                );

    HRESULT GetSipProviderProfile(
                                  SIP_PROVIDER_PROFILE * pProfile,
                                  long lRegisterFlags
                                 );

    HRESULT FreeSipProviderProfile(
                                   SIP_PROVIDER_PROFILE * pProfile
                                  );

    HRESULT GetSipProxyServerInfo(
                                  long lSessionType,
                                  SIP_SERVER_INFO * pProxy
                                 );

    HRESULT FreeSipServerInfo(
                              SIP_SERVER_INFO * pServerInfo
                             );

    HRESULT GetRealm(
                     BSTR * pbstrRealm
                    );

    HRESULT GetCredentials(
                     BSTR * pbstrUserAccount,
                     BSTR * pbstrUserPassword,
                     SIP_AUTH_PROTOCOL *pAuth
                     );

    //
    // XML Parsing
    //

    HRESULT ParseXMLDOMElementForAttribute(
                            IXMLDOMElement * pElement,
                            PCWSTR szAttrib,
                            BOOL fRequired,
                            PWSTR * szValue
                            );

    HRESULT ParseXMLDOMNodeForData(
                            IXMLDOMNode * pNode,
                            PWSTR * szValue
                            );

    HRESULT ParseXMLDOMNodeForProvision(
                            IXMLDOMNode * pNode,
                            PROF_PROVISION * pStruct
                            );

    HRESULT ParseXMLDOMNodeForProvider(
                            IXMLDOMNode * pNode,
                            PROF_PROVIDER * pStruct
                            );

    HRESULT ParseXMLDOMNodeForClient(
                            IXMLDOMNode * pNode,
                            PROF_CLIENT * pStruct
                            );

    HRESULT ParseXMLDOMNodeForUser(
                            IXMLDOMNode * pNode,
                            PROF_USER * pStruct
                            );

    HRESULT ParseXMLDOMNodeForServer(
                            IXMLDOMNode * pNode,
                            PROF_SERVER * pStruct
                            );

    HRESULT ParseXMLDOMNodeForSession(
                            IXMLDOMNode * pNode,
                            long * plSession
                            );

/*
    HRESULT ParseXMLDOMNodeForAccessControl(
                            IXMLDOMNode * pNode,
                            PROF_ACCESSCONTROL * pStruct
                            );
*/

    HRESULT ParseXMLDOMDocument(
                            IXMLDOMDocument * pXMLDoc
                            );

    void FreeProvision(PROF_PROVISION * pStruct);
    void FreeProvider(PROF_PROVIDER * pStruct);
    void FreeClient(PROF_CLIENT * pStruct);
    void FreeUser(PROF_USER * pStruct);
    void FreeServer(PROF_SERVER * pStruct);

/*
    void FreeAccessControl(PROF_ACCESSCONTROL * pStruct);

    HRESULT ValidateAccessControl();

    BOOL IsMatchingAddress(WCHAR *pszAddress, WCHAR *pszPattern);
*/

    HRESULT SetState(
            RTC_REGISTRATION_STATE enState,
            long lStatusCode,
            PCWSTR szStatusText
            );

    HRESULT Enable(long lRegisterFlags);

    HRESULT Disable();

    HRESULT Redirect(ISipRedirectContext * pSipRedirectContext);

    void GetGuid(GUID * pGUID);

private:

    CRTCClient            * m_pCClient;
    PWSTR                   m_szProfileXML;
    GUID                    m_ProfileGuid;
    RTC_REGISTRATION_STATE  m_enState;
    BOOL                    m_fValid;
    BOOL                    m_fEnabled;
    long                    m_lRegisterFlags;
    ISipStack             * m_pSipStack;

    PROF_PROVISION          m_Provision;
    PROF_PROVIDER           m_Provider;
    PROF_CLIENT             m_Client;
    PROF_USER               m_User;
    CRTCArray<PROF_SERVER>  m_ServerArray;
/*
    CRTCArray<PROF_ACCESSCONTROL> m_AccessControlArray;
*/

#if DBG
    PWSTR                   m_pDebug;
#endif
    
// IRTCProfile
public:
    STDMETHOD(get_Key)(
            BSTR * pbstrKey
            );

    STDMETHOD(get_Name)(
            BSTR * pbstrName
            );

    STDMETHOD(get_XML)(
            BSTR * pbstrXML
            );

    // Provider

    STDMETHOD(get_ProviderName)(
            BSTR * pbstrName
            ); 

    STDMETHOD(get_ProviderURI)(
            RTC_PROVIDER_URI enURI,
            BSTR * pbstrURI
            ); 

    STDMETHOD(get_ProviderData)(
            BSTR * pbstrData
            );

    // Client

    STDMETHOD(get_ClientName)(
            BSTR * pbstrName
            ); 

    STDMETHOD(get_ClientBanner)(
            VARIANT_BOOL * pfBanner
            ); 

    STDMETHOD(get_ClientMinVer)(
            BSTR * pbstrMinVer
            ); 

    STDMETHOD(get_ClientCurVer)(
            BSTR * pbstrCurVer
            ); 

    STDMETHOD(get_ClientUpdateURI)(
            BSTR * pbstrUpdateURI
            ); 

    STDMETHOD(get_ClientData)(
            BSTR * pbstrData
            ); 

    // User

    STDMETHOD(get_UserURI)(
            BSTR * pbstrUserURI
            );

    STDMETHOD(get_UserName)(
            BSTR * pbstrUserName
            );
    
    STDMETHOD(get_UserAccount)(
            BSTR * pbstrUserAccount
            );

    STDMETHOD(SetCredentials)(
            BSTR    bstrUserURI,
            BSTR    bstrUserAccount,
            BSTR    bstrPassword
            );

    // Server
        
    STDMETHOD(get_SessionCapabilities)(
            long * plSupportedSessions
            );

    // Registration

    STDMETHOD(get_State)(
            RTC_REGISTRATION_STATE * penState
            );
};

#endif //__RTCPROFILE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcprofile.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCProfile.cpp

Abstract:

    Implementation of the CRTCProfile class

--*/

#include "stdafx.h"
/*
#include <wincrypt.h>
*/

#define RTCFREE(x) if(x){RtcFree(x);x=NULL;}

/*
const WCHAR  *      g_szMasterKeyWithColon = L"Microsoft Real-Time Communications authorized domain:";
const WCHAR  *      g_szKeyContainer = L"Microsoft.RTCContainer";

const BYTE          g_PublicKeyBlob[] = 
{
0x06, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x52, 0x53, 0x41, 0x31, 0x00, 0x02, 0x00, 0x00, // .....$..RSA1....
0x01, 0x00, 0x01, 0x00, 0x4b, 0x5e, 0xb9, 0x9a, 0xff, 0x4b, 0x25, 0xf4, 0x17, 0x4f, 0xde, 0x9d, // ....K^...K%..O..
0xb2, 0x49, 0x68, 0x85, 0x64, 0xb6, 0x6a, 0xe7, 0x9c, 0x40, 0x97, 0x40, 0x62, 0x05, 0x4a, 0x9d, // .Ih.d.j..@.@b.J.
0xff, 0xe5, 0x4a, 0x97, 0x10, 0x7b, 0x59, 0x8a, 0xb8, 0x51, 0x9e, 0xd5, 0xe1, 0x51, 0x7a, 0x2b, // ..J..{Y..Q...Qz+
0x4e, 0x50, 0xb4, 0x2e, 0x57, 0x81, 0x70, 0x15, 0x2b, 0xf1, 0xbf, 0xed, 0x40, 0xe8, 0xb7, 0x6d, // NP..W.p.+...@..m
0xe9, 0x4c, 0x8b, 0xb6                                                                          // .L..
};
*/

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FinalConstruct
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::FinalConstruct()
{
    LOG((RTC_TRACE, "CRTCProfile::FinalConstruct - enter"));

#if DBG
    m_pDebug = (PWSTR) RtcAlloc( 1 );
#endif

    ZeroMemory(&m_Provision, sizeof(PROF_PROVISION));
    ZeroMemory(&m_Provider, sizeof(PROF_PROVIDER));
    ZeroMemory(&m_Client, sizeof(PROF_CLIENT));
    ZeroMemory(&m_User, sizeof(PROF_USER));

    LOG((RTC_TRACE, "CRTCProfile::FinalConstruct - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCProfile::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCProfile::FinalRelease - enter"));

    FreeProvision(&m_Provision);
    FreeProvider(&m_Provider);
    FreeClient(&m_Client);
    FreeUser(&m_User);

    for (int n=0; n < m_ServerArray.GetSize(); n++)
    {
        FreeServer(&m_ServerArray[n]);
    }

    m_ServerArray.Shutdown();

/*
    for (int n=0; n < m_AccessControlArray.GetSize(); n++)
    {
        FreeAccessControl(&m_AccessControlArray[n]);
    }

    m_AccessControlArray.Shutdown();
*/

    RTCFREE(m_szProfileXML);

    if ( m_pSipStack != NULL )
    {
        m_pSipStack->Release();
        m_pSipStack = NULL;
    }

    if ( m_pCClient != NULL )
    {
        m_pCClient->Release();
        m_pCClient = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCProfile::FinalRelease - exit"));
}   

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::InternalAddRef
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCProfile::InternalAddRef()
{
    DWORD dwR;

    dwR = InterlockedIncrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCProfile::InternalAddRef - dwR %d", dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::InternalRelease
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCProfile::InternalRelease()
{
    DWORD               dwR;
    
    dwR = InterlockedDecrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCProfile::InternalRelease - dwR %d", dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::InitializeFromString
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCProfile::InitializeFromString(
                                  BSTR bstrProfileXML,
                                  CRTCClient * pCClient,
                                  ISipStack * pSipStack
                                 )
{
    LOG((RTC_TRACE, "CRTCProfile::InitializeFromString - enter"));

    HRESULT hr;

    //
    // Parse the XML
    // 

    IXMLDOMDocument * pXMLDoc = NULL;

    hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
            IID_IXMLDOMDocument, (void**)&pXMLDoc );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::InitializeFromString - "
                            "CoCreateInstance failed 0x%lx", hr));

        return hr;
    }

    VARIANT_BOOL bSuccess;

    hr = pXMLDoc->loadXML( bstrProfileXML, &bSuccess );

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCProfile::InitializeFromString - "
                            "loadXML failed 0x%lx", hr));

        if ( S_FALSE == hr )
        {
            hr = E_FAIL;
        }

        pXMLDoc->Release();

        return hr;
    }

    hr = ParseXMLDOMDocument( pXMLDoc );

    pXMLDoc->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::InitializeFromString - "
                            "ParseXMLDOMDocument failed 0x%lx", hr));

        return hr;
    }

    //
    // Store the XML
    //

    m_szProfileXML = (PWSTR)RtcAlloc( sizeof(WCHAR) * (lstrlenW(bstrProfileXML) + 1) );

    if ( m_szProfileXML == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::InitializeFromString - "
                            "out of memory"));
                            
        return E_OUTOFMEMORY;
    }

    lstrcpyW( m_szProfileXML, bstrProfileXML ); 

    //
    // Create the GUID
    //

    hr = CoCreateGuid( &m_ProfileGuid );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::InitializeFromString - "
                            "CoCreateGuid failed 0x%lx", hr));

        return hr;
    }

    //
    // Addref the SIP stack and client
    //

    m_pSipStack = pSipStack;
    if (m_pSipStack)
    {
        m_pSipStack->AddRef();
    }

    m_pCClient = pCClient;
    if (m_pCClient)
    {
        m_pCClient->AddRef();
    }

    m_fValid = TRUE;
            
    LOG((RTC_TRACE, "CRTCProfile::InitializeFromString - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::GetSipProviderProfile
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::GetSipProviderProfile(
                                   SIP_PROVIDER_PROFILE * pProfile,
                                   long lRegisterFlags
                                  )
{
    LOG((RTC_TRACE, "CRTCProfile::GetSipProviderProfile - enter"));

    //
    // First zero the memory
    //

    ZeroMemory( pProfile, sizeof(SIP_PROVIDER_PROFILE) );

    //
    // Fill in the GUID
    //

    CopyMemory( &(pProfile->ProviderID), &m_ProfileGuid, sizeof(GUID) );

    //
    // Default this flag to zero
    //

    pProfile->lRegisterAccept = 0;

    if ( lRegisterFlags )
    {
        //
        // For each server structure gather the needed info
        //

        for (int n=0; n < m_ServerArray.GetSize(); n++)
        {
            if ( m_ServerArray[n].fRegistrar == TRUE )
            {
                //
                // Found a registrar server
                //

                //
                // Fill in the server info
                //

                pProfile->Registrar.ServerAddress = 
                    RtcAllocString( m_ServerArray[n].szAddr );

                if ( pProfile->Registrar.ServerAddress == NULL )
                {
                    LOG((RTC_ERROR, "CRTCProfile::GetSipProviderProfile - "
                        "out of memory"));

                    return E_OUTOFMEMORY;
                }

                pProfile->Registrar.TransportProtocol = 
                    m_ServerArray[n].enProtocol;

                pProfile->Registrar.AuthProtocol =
                    m_ServerArray[n].enAuth;

                LOG((RTC_INFO, "CRTCProfile::GetSipProviderProfile - "
                                "Got a REGISTRAR server"));

                if ( lRegisterFlags & RTCRF_REGISTER_INVITE_SESSIONS )
                {
                    pProfile->lRegisterAccept |= 
                        SIP_REGISTER_ACCEPT_INVITE |
                        SIP_REGISTER_ACCEPT_OPTIONS |
                        SIP_REGISTER_ACCEPT_BYE |
                        SIP_REGISTER_ACCEPT_CANCEL| 
                        SIP_REGISTER_ACCEPT_ACK;
                }

                if ( lRegisterFlags & RTCRF_REGISTER_MESSAGE_SESSIONS )
                {
                    pProfile->lRegisterAccept |= 
                        SIP_REGISTER_ACCEPT_MESSAGE |
                        SIP_REGISTER_ACCEPT_INFO |
                        SIP_REGISTER_ACCEPT_OPTIONS |
                        SIP_REGISTER_ACCEPT_BYE |
                        SIP_REGISTER_ACCEPT_CANCEL;
                }

                if ( lRegisterFlags & RTCRF_REGISTER_PRESENCE )
                {
                    pProfile->lRegisterAccept |= 
                        SIP_REGISTER_ACCEPT_SUBSCRIBE |
                        SIP_REGISTER_ACCEPT_OPTIONS |
                        SIP_REGISTER_ACCEPT_NOTIFY;
                }

                break;
            }
        }
    }

    //
    // Get the user strings
    //

    if ( m_User.szAccount )
    {
        pProfile->UserCredentials.Username =
            RtcAllocString( m_User.szAccount );

        if ( pProfile->UserCredentials.Username == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::GetSipProviderProfile - "
                "out of memory"));

            return E_OUTOFMEMORY;
        }
    }

    if ( m_User.szPassword )
    {
        pProfile->UserCredentials.Password =
            RtcAllocString( m_User.szPassword );

        if ( pProfile->UserCredentials.Password == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::GetSipProviderProfile - "
                "out of memory"));

            return E_OUTOFMEMORY;
        }
    }

    if ( m_User.szUri )
    {
        pProfile->UserURI =
            RtcAllocString( m_User.szUri );

        if ( pProfile->UserURI == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::GetSipProviderProfile - "
                "out of memory"));

            return E_OUTOFMEMORY;
        }
    }

    if ( m_User.szRealm )
    {
        pProfile->Realm =
            RtcAllocString( m_User.szRealm );

        if ( pProfile->Realm == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::GetSipProviderProfile - "
                "out of memory"));

            return E_OUTOFMEMORY;
        }
    }
    
    LOG((RTC_TRACE, "CRTCProfile::GetSipProviderProfile - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FreeSipProviderProfile
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::FreeSipProviderProfile(
                                    SIP_PROVIDER_PROFILE * pProfile
                                   )
{
    LOG((RTC_TRACE, "CRTCProfile::FreeSipProviderProfile[%p]", pProfile));

    //
    // Free server info
    //

    FreeSipServerInfo( &(pProfile->Registrar) );

    //
    // Free all the strings
    //

    RTCFREE( pProfile->UserCredentials.Username );
    RTCFREE( pProfile->UserCredentials.Password );
    RTCFREE( pProfile->UserURI );
    RTCFREE( pProfile->Realm );

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::GetSipProxyServerInfo
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::GetSipProxyServerInfo(
                                   long lSessionType,
                                   SIP_SERVER_INFO * pProxy
                                  )
{
    LOG((RTC_TRACE, "CRTCProfile::GetSipProxyServerInfo - enter"));

    //
    // First zero the memory
    //

    ZeroMemory( pProxy, sizeof(SIP_SERVER_INFO) );

    //
    // For each server structure gather the needed info
    //

    for (int n=0; n < m_ServerArray.GetSize(); n++)
    {
        if ( m_ServerArray[n].fRegistrar == FALSE )
        {
            //
            // Found a proxy server
            //

            if ( m_ServerArray[n].lSessions & lSessionType )
            {
                //
                // This proxy server supports the desired session type
                //

                //
                // Fill in the server info
                //

                pProxy->ServerAddress = 
                    RtcAllocString( m_ServerArray[n].szAddr );

                if ( pProxy->ServerAddress == NULL )
                {
                    LOG((RTC_ERROR, "CRTCProfile::GetSipProxyServerInfo - "
                        "out of memory"));

                    return E_OUTOFMEMORY;
                }

                pProxy->IsServerAddressSIPURI = FALSE;

                pProxy->TransportProtocol = 
                    m_ServerArray[n].enProtocol;

                pProxy->AuthProtocol =
                    m_ServerArray[n].enAuth;

                LOG((RTC_INFO, "CRTCProfile::GetSipProxyServerInfo - "
                                "Got a PROXY server"));

                return S_OK;
            }
        }
    }

    LOG((RTC_TRACE, "CRTCProfile::GetSipProxyServerInfo - "
                    "no proxy found for that session type"));

    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FreeSipServerInfo
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::FreeSipServerInfo(
                               SIP_SERVER_INFO * pServerInfo
                              )
{
    LOG((RTC_TRACE, "CRTCProfile::FreeSipServerInfo[%p]", pServerInfo));

    //
    // Free all the strings
    //

    RTCFREE( pServerInfo->ServerAddress );

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::GetRealm
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCProfile::GetRealm(
        BSTR * pbstrRealm
        )
{
    LOG((RTC_TRACE, "CRTCProfile::GetRealm - enter"));

    if ( IsBadWritePtr( pbstrRealm, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::GetRealm - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::GetRealm - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_User.szRealm == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::GetRealm - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrRealm = SysAllocString( m_User.szRealm );
    
    if ( *pbstrRealm == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::GetRealm - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::GetRealm - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::GetCredentials
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::GetCredentials(
                     BSTR * pbstrUserAccount,
                     BSTR * pbstrUserPassword,
                     SIP_AUTH_PROTOCOL *pAuth
                     )
{
    LOG((RTC_TRACE, "CRTCProfile::GetCredentials - enter"));

    if ( IsBadWritePtr( pbstrUserAccount, sizeof(BSTR) ) ||
         IsBadWritePtr( pbstrUserPassword, sizeof(BSTR) ) ||
         IsBadWritePtr( pAuth, sizeof(SIP_AUTH_PROTOCOL) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::GetCredentials - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::GetCredentials - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    //
    // Get the account
    //

    if ( m_User.szAccount == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::GetCredentials - "
                            "no account value"));

        return E_FAIL;
    }

    if ( m_User.szAccount != NULL )
    {
        *pbstrUserAccount = SysAllocString( m_User.szAccount );

        if ( *pbstrUserAccount == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::GetCredentials - "
                                "out of memory"));

            return E_OUTOFMEMORY;
        }
    }

    //
    // Get the password
    //

    if ( m_User.szPassword == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::GetCredentials - "
                            "no password value"));

        SysFreeString( *pbstrUserAccount );
        *pbstrUserAccount = NULL;

        return E_FAIL;
    }

    if ( m_User.szPassword != NULL )
    {
        *pbstrUserPassword = SysAllocString( m_User.szPassword );

        if ( *pbstrUserPassword == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::GetCredentials - "
                                "out of memory"));

            SysFreeString( *pbstrUserAccount );
            *pbstrUserAccount = NULL;

            return E_OUTOFMEMORY;
        }
    }

    //
    // Get the auth protocol, try proxies first
    //

    for (int n=0; n < m_ServerArray.GetSize(); n++)
    {
        if ( m_ServerArray[n].fRegistrar == FALSE )
        {
            //
            // Found a proxy server
            //

            if ( m_ServerArray[n].lSessions & RTCSI_PC_TO_PC )
            {
                //
                // This proxy server supports the desired session type
                //

                *pAuth = m_ServerArray[n].enAuth;

                LOG((RTC_INFO, "CRTCProfile::GetCredentials - "
                                "Got a PROXY server"));

                return S_OK;
            }
        }
    }

    //
    // Get the auth protocol, try registrars next
    //

    for (int n=0; n < m_ServerArray.GetSize(); n++)
    {
        if ( m_ServerArray[n].fRegistrar == TRUE )
        {
            //
            // Found a registar server
            //

            *pAuth = m_ServerArray[n].enAuth;

            LOG((RTC_INFO, "CRTCProfile::GetCredentials - "
                            "Got a REGISTRAR server"));

            return S_OK;
        }
    }

    LOG((RTC_TRACE, "CRTCProfile::GetCredentials - "
                        "auth protocol not found"));

    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMElementForAttribute
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::ParseXMLDOMElementForAttribute(
                        IXMLDOMElement * pElement,
                        PCWSTR szAttrib,
                        BOOL fRequired,
                        PWSTR * szValue
                        )
{
    HRESULT hr;
    CComVariant var;

    hr = pElement->getAttribute( CComBSTR(szAttrib), &var );

    if ( hr == S_FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMElementForAttribute - "
                            "%ws=NULL", szAttrib));

        if ( fRequired )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMElementForAttribute - "
                            "required attribute missing"));

            hr = E_FAIL;
        }

        return hr;
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMElementForAttribute - "
                            "getAttribute failed 0x%lx", hr));

        return hr;
    }

    if ( var.vt != VT_BSTR )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMElementForAttribute - "
                            "not a string"));

        return E_FAIL;
    }

    *szValue = RtcAllocString( var.bstrVal );

    if ( *szValue == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMElementForAttribute - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMElementForAttribute - "
                        "%ws=\"%ws\"", szAttrib, *szValue));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMNodeForData
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::ParseXMLDOMNodeForData(
                            IXMLDOMNode * pNode,
                            PWSTR * szValue
                            )
{
    IXMLDOMNode * pData = NULL;
    HRESULT hr;

    hr = pNode->selectSingleNode( CComBSTR(_T("data")), &pData );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForData - "
                            "selectSingleNode(data) failed 0x%lx", hr));

        return hr;
    }

    if ( hr == S_FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForData - "
                            "data=NULL"));

        return hr;
    }

    BSTR bstrData;

    hr = pData->get_xml( &bstrData );

    pData->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForData - "
                        "get_xml failed 0x%lx", hr));

        return hr;
    }

    *szValue = RtcAllocString( bstrData );

    SysFreeString( bstrData );

    if ( *szValue == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForData - "
                        "out of memory"));       

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForData - "
                        "data=\"%ws\"", *szValue));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMNodeForProvision
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCProfile::ParseXMLDOMNodeForProvision(
                        IXMLDOMNode * pNode,
                        PROF_PROVISION * pStruct
                        )
{
    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForProvision - enter"));

    ZeroMemory( pStruct, sizeof(PROF_PROVISION) );

    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvision - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // uri
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"key", TRUE, &pStruct->szKey );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvision - "
                            "ParseXMLDOMElementForAttribute(key) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_NO_KEY;
    }

    //
    // name
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"name", TRUE, &pStruct->szName );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvision - "
                            "ParseXMLDOMElementForAttribute(name) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_NO_NAME;
    }

    //
    // expires
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"expires", FALSE, &pStruct->szExpires );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvision - "
                            "ParseXMLDOMElementForAttribute(expires) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    pElement->Release();

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForProvision - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMNodeForProvider
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCProfile::ParseXMLDOMNodeForProvider(
                        IXMLDOMNode * pNode,
                        PROF_PROVIDER * pStruct
                        )
{
    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForProvider - enter"));

    ZeroMemory( pStruct, sizeof(PROF_PROVIDER) );

    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvider - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // name
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"name", FALSE, &pStruct->szName );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvider - "
                            "ParseXMLDOMElementForAttribute(name) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // homepage
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"homepage", FALSE, &pStruct->szHomepage );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvider - "
                            "ParseXMLDOMElementForAttribute(homepage) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // helpdesk
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"helpdesk", FALSE, &pStruct->szHelpdesk );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvider - "
                            "ParseXMLDOMElementForAttribute(helpdesk) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // personal
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"personal", FALSE, &pStruct->szPersonal );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvider - "
                            "ParseXMLDOMElementForAttribute(personal) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // calldisplay
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"calldisplay", FALSE, &pStruct->szCallDisplay );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvider - "
                            "ParseXMLDOMElementForAttribute(calldisplay) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // idledisplay
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"idledisplay", FALSE, &pStruct->szIdleDisplay );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvider - "
                            "ParseXMLDOMElementForAttribute(idledisplay) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    pElement->Release();

    //
    // data
    //

    hr = ParseXMLDOMNodeForData( pNode, &pStruct->szData );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvider - "
                            "ParseXMLDOMNodeForData failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForProvider - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMNodeForClient
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCProfile::ParseXMLDOMNodeForClient(
                        IXMLDOMNode * pNode,
                        PROF_CLIENT * pStruct
                        )
{
    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForClient - enter"));

    ZeroMemory( pStruct, sizeof(PROF_CLIENT) );

    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForClient - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // name
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"name", TRUE, &pStruct->szName );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForClient - "
                            "ParseXMLDOMElementForAttribute(name) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // banner
    //

    PWSTR szBanner;

    hr = ParseXMLDOMElementForAttribute( pElement, L"banner", FALSE, &szBanner );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForClient - "
                            "ParseXMLDOMElementForAttribute(banner) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        if ( _wcsicmp( szBanner, L"true" ) == 0 )
        {
            pStruct->fBanner = TRUE;
        }
        else if ( _wcsicmp( szBanner, L"false" ) == 0 )
        {
            pStruct->fBanner = FALSE;
        }
        else
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForClient - "
                            "unknown banner"));

            RTCFREE(szBanner);
            pElement->Release();

            return E_FAIL;
        }

        RTCFREE(szBanner);
    }

    //
    // minver
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"minver", FALSE, &pStruct->szMinVer );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForClient - "
                            "ParseXMLDOMElementForAttribute(minver) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // curver
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"curver", FALSE, &pStruct->szCurVer );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForClient - "
                            "ParseXMLDOMElementForAttribute(curver) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // updateuri
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"updateuri", FALSE, &pStruct->szUpdateUri );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForClient - "
                            "ParseXMLDOMElementForAttribute(updateuri) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    pElement->Release();

    //
    // data
    //

    hr = ParseXMLDOMNodeForData( pNode, &pStruct->szData );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForClient - "
                            "ParseXMLDOMNodeForData failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForClient - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMNodeForUser
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCProfile::ParseXMLDOMNodeForUser(
                        IXMLDOMNode * pNode,
                        PROF_USER * pStruct
                        )
{
    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForUser - enter"));

    ZeroMemory( pStruct, sizeof(PROF_USER) );

    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForUser - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // account
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"account", FALSE, &pStruct->szAccount );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForUser - "
                            "ParseXMLDOMElementForAttribute(account) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // name
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"name", FALSE, &pStruct->szName );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForUser - "
                            "ParseXMLDOMElementForAttribute(name) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // uri
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"uri", TRUE, &pStruct->szUri );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForUser - "
                            "ParseXMLDOMElementForAttribute(uri) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_NO_USER_URI;
    }

    //
    // password
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"password", FALSE, &pStruct->szPassword );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForUser - "
                            "ParseXMLDOMElementForAttribute(password) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // realm
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"realm", FALSE, &pStruct->szRealm );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForUser - "
                            "ParseXMLDOMElementForAttribute(realm) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    pElement->Release();

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForUser - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMNodeForServer
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::ParseXMLDOMNodeForServer(
                        IXMLDOMNode * pNode,
                        PROF_SERVER * pStruct
                        )
{
    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForServer - enter"));

    ZeroMemory( pStruct, sizeof(PROF_SERVER) );

    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // addr
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"addr", TRUE, &pStruct->szAddr );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "ParseXMLDOMElementForAttribute(addr) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_NO_SERVER_ADDRESS;
    }

/*
    BOOL fMatch = FALSE;

    for ( int n=0; n < m_AccessControlArray.GetSize(); n++ )
    {
        if ( IsMatchingAddress( pStruct->szAddr, m_AccessControlArray[n].szDomain ) )
        {
            fMatch = TRUE;

            break;
        }
    }

    if ( !fMatch )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "server address does not match an authorized domain"));

        pElement->Release();

        return RTC_E_PROFILE_SERVER_UNAUTHORIZED;
    }
*/

    //
    // protocol
    //

    PWSTR szProtocol;

    hr = ParseXMLDOMElementForAttribute( pElement, L"protocol", TRUE, &szProtocol );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "ParseXMLDOMElementForAttribute(protocol) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_NO_SERVER_PROTOCOL;
    }

    if ( _wcsicmp( szProtocol, L"udp" ) == 0 )
    {
        pStruct->enProtocol = SIP_TRANSPORT_UDP;
    }
    else if ( _wcsicmp( szProtocol, L"tcp" ) == 0 )
    {
        pStruct->enProtocol = SIP_TRANSPORT_TCP;
    }
    else if ( _wcsicmp( szProtocol, L"tls" ) == 0 )
    {
        pStruct->enProtocol = SIP_TRANSPORT_SSL;
    }
    else
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                        "unknown protocol"));

        RTCFREE(szProtocol);
        pElement->Release();

        return RTC_E_PROFILE_INVALID_SERVER_PROTOCOL;
    }

    RTCFREE(szProtocol);

    //
    // auth
    //

    PWSTR szAuth;

    hr = ParseXMLDOMElementForAttribute( pElement, L"auth", FALSE, &szAuth );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "ParseXMLDOMElementForAttribute(auth) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        if ( _wcsicmp( szAuth, L"basic" ) == 0 )
        {
            if ( pStruct->enProtocol != SIP_TRANSPORT_SSL )
            {
                LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "cannot use basic auth without TLS"));

                RTCFREE(szAuth);
                pElement->Release();

                return RTC_E_PROFILE_INVALID_SERVER_AUTHMETHOD;
            }

            pStruct->enAuth = SIP_AUTH_PROTOCOL_BASIC;
        }
        else if ( _wcsicmp( szAuth, L"digest" ) == 0 )
        {
            pStruct->enAuth = SIP_AUTH_PROTOCOL_MD5DIGEST;
        }
        /*
        else if ( _wcsicmp( szAuth, L"ntlm" ) == 0 )
        {
            pStruct->enAuth = SIP_AUTH_PROTOCOL_NTLM;
        }
        else if ( _wcsicmp( szAuth, L"kerberos" ) == 0 )
        {
            pStruct->enAuth = SIP_AUTH_PROTOCOL_KERBEROS;
        }
        else if ( _wcsicmp( szAuth, L"cert" ) == 0 )
        {
            pStruct->enAuth = SIP_AUTH_PROTOCOL_CERT;
        }
        */
        else
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "unknown auth"));

            RTCFREE(szAuth);
            pElement->Release();

            return RTC_E_PROFILE_INVALID_SERVER_AUTHMETHOD;
        }

        RTCFREE(szAuth);
    }
    else
    {
        pStruct->enAuth = SIP_AUTH_PROTOCOL_NONE;
    }

    //
    // role
    //

    PWSTR szRole;

    hr = ParseXMLDOMElementForAttribute( pElement, L"role", TRUE, &szRole );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "ParseXMLDOMElementForAttribute(role) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_INVALID_SERVER_ROLE;
    }

    if ( _wcsicmp( szRole, L"proxy" ) == 0 )
    {
        pStruct->fRegistrar = FALSE;
    }
    else if ( _wcsicmp( szRole, L"registrar" ) == 0 )
    {
        pStruct->fRegistrar = TRUE;
    }        
    else
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                        "unknown role"));

        RTCFREE(szRole);
        pElement->Release();

        return RTC_E_PROFILE_INVALID_SERVER_ROLE;
    }

    RTCFREE(szRole);

    pElement->Release();

    //
    // session
    //

    IXMLDOMNodeList * pNodeList;
    IXMLDOMNode * pSession;
    long lSession;

    pStruct->lSessions = 0;

    hr = pNode->selectNodes( CComBSTR(_T("session")), &pNodeList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "selectNodes(session) failed 0x%lx", hr));

        return hr;
    }
    
    while ( pNodeList->nextNode( &pSession ) == S_OK )
    {
        hr = ParseXMLDOMNodeForSession( pSession, &lSession );

        pSession->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "ParseXMLDOMNodeForSession failed 0x%lx", hr));

            pNodeList->Release();

            return hr;
        }

        pStruct->lSessions |= lSession;
    }

    pNodeList->Release();

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForServer - exit"));

    return S_OK;
}

/*
/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMNodeForAccessControl
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::ParseXMLDOMNodeForAccessControl(
                        IXMLDOMNode * pNode,
                        PROF_ACCESSCONTROL * pStruct
                        )
{
    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForAccessControl - enter"));

    ZeroMemory( pStruct, sizeof(PROF_ACCESSCONTROL) );

    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForAccessControl - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // domain
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"domain", TRUE, &pStruct->szDomain );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForAccessControl - "
                            "ParseXMLDOMElementForAttribute(domain) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_NO_ACCESSCONTROL_DOMAIN;
    }

    //
    // sig
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"sig", TRUE, &pStruct->szSig );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForAccessControl - "
                            "ParseXMLDOMElementForAttribute(sig) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_NO_ACCESSCONTROL_SIGNATURE;
    }

    pElement->Release();

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForAccessControl - exit"));

    return S_OK;
}
*/

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMNodeForSession
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::ParseXMLDOMNodeForSession(
                        IXMLDOMNode * pNode,
                        long * plSession
                        )
{
    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForSession - enter"));

    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // party
    //

    BOOL fFirstParty;
    PWSTR szParty;

    hr = ParseXMLDOMElementForAttribute( pElement, L"party", TRUE, &szParty );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "ParseXMLDOMElementForAttribute(party) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_INVALID_SESSION_PARTY;
    }

    if ( hr == S_OK )
    {
        if ( _wcsicmp( szParty, L"first" ) == 0 )
        {
            fFirstParty = TRUE;
        }
        else if ( _wcsicmp( szParty, L"third" ) == 0 )
        {
            fFirstParty = FALSE;
        }        
        else
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "unknown party"));

            RTCFREE(szParty);
            pElement->Release();

            return RTC_E_PROFILE_INVALID_SESSION_PARTY;
        }

        RTCFREE(szParty);
    }

    //
    // type
    //

    PWSTR szType;

    hr = ParseXMLDOMElementForAttribute( pElement, L"type", TRUE, &szType );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "ParseXMLDOMElementForAttribute(type) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_INVALID_SESSION_TYPE;
    }

    if ( hr == S_OK )
    {
        if ( _wcsicmp( szType, L"pc2pc" ) == 0 )
        {
            if ( fFirstParty )
            {
                *plSession = RTCSI_PC_TO_PC;
            }
            else
            {
                LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "third party pc2pc not supported"));

                RTCFREE(szType);
                pElement->Release();

                return RTC_E_PROFILE_INVALID_SESSION;
            }
        }
        else if ( _wcsicmp( szType, L"pc2ph" ) == 0 )
        {
            if ( fFirstParty )
            {
                *plSession = RTCSI_PC_TO_PHONE;
            }
            else
            {
                LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "third party pc2ph not supported"));

                RTCFREE(szType);
                pElement->Release();

                return RTC_E_PROFILE_INVALID_SESSION;
            }
        } 
        else if ( _wcsicmp( szType, L"ph2ph" ) == 0 )
        {
            if ( fFirstParty )
            {
                LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "first party ph2ph not supported"));

                RTCFREE(szType);
                pElement->Release();

                return RTC_E_PROFILE_INVALID_SESSION;
            }
            else
            {
                *plSession = RTCSI_PHONE_TO_PHONE;
            }
        }
        else if ( _wcsicmp( szType, L"im" ) == 0 )
        {
            if ( fFirstParty )
            {
                *plSession = RTCSI_IM;
            }
            else
            {
                LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "third party im not supported"));

                RTCFREE(szType);
                pElement->Release();

                return RTC_E_PROFILE_INVALID_SESSION;
            }
        }
        else
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "unknown type"));

            RTCFREE(szType);
            pElement->Release();

            return RTC_E_PROFILE_INVALID_SESSION_TYPE;
        }

        RTCFREE(szType);
    }

    pElement->Release();

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForSession - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMDocument
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::ParseXMLDOMDocument(
                        IXMLDOMDocument * pXMLDoc
                        )
{
    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMDocument - enter"));

    IXMLDOMNode * pDocument = NULL;
    IXMLDOMNode * pNode = NULL;
    HRESULT hr;

    hr = pXMLDoc->QueryInterface( IID_IXMLDOMNode, (void**)&pDocument);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // provision
    //

    hr = pDocument->selectSingleNode( CComBSTR(_T("provision")), &pNode );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "selectSingleNode(provision) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        hr = ParseXMLDOMNodeForProvision( pNode, &m_Provision );

        pNode->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument "
                                "ParseXMLDOMNodeForProvision failed 0x%lx", hr));

            pDocument->Release();

            return hr;
        }
    }
    else
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "provision not found"));

        pDocument->Release();

        return RTC_E_PROFILE_NO_PROVISION;
    }

    //
    // provider
    //

    hr = pDocument->selectSingleNode( CComBSTR(_T("provision/provider")), &pNode );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "selectSingleNode(provision/provider) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        hr = ParseXMLDOMNodeForProvider( pNode, &m_Provider );

        pNode->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument "
                                "ParseXMLDOMNodeForProvider failed 0x%lx", hr));

            pDocument->Release();

            return hr;
        }
    }
    else
    {
        LOG((RTC_WARN, "CRTCProfile::ParseXMLDOMDocument - "
                            "provider not found"));
    }

    //
    // client
    //

    hr = pDocument->selectSingleNode( CComBSTR(_T("provision/client")), &pNode );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "selectSingleNode(provision/client) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        hr = ParseXMLDOMNodeForClient( pNode, &m_Client );

        pNode->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument "
                                "ParseXMLDOMNodeForClient failed 0x%lx", hr));

            pDocument->Release();

            return hr;
        }
    }
    else
    {
        LOG((RTC_WARN, "CRTCProfile::ParseXMLDOMDocument - "
                            "client not found"));
    }

    //
    // user
    //

    hr = pDocument->selectSingleNode( CComBSTR(_T("provision/user")), &pNode );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "selectSingleNode(provision/user) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        hr = ParseXMLDOMNodeForUser( pNode, &m_User );

        pNode->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument "
                                "ParseXMLDOMNodeForUser failed 0x%lx", hr));

            pDocument->Release();

            return hr;
        }
    }
    else
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "user not found"));

        pDocument->Release();

        return RTC_E_PROFILE_NO_USER;
    }    

/*
    //
    // accesscontrol
    //
*/
    IXMLDOMNodeList * pNodeList;
/*
    PROF_ACCESSCONTROL AccessControl;

    hr = pDocument->selectNodes( CComBSTR(_T("provision/accesscontrol")), &pNodeList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "selectNodes(provision/accesscontrol) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }
    
    while ( pNodeList->nextNode( &pNode ) == S_OK )
    {
        hr = ParseXMLDOMNodeForAccessControl( pNode, &AccessControl );

        pNode->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "ParseXMLDOMNodeForServer failed 0x%lx", hr));

            pNodeList->Release();
            FreeAccessControl( &AccessControl );
            pDocument->Release();

            return hr;
        }

        BOOL fResult;
        
        fResult = m_AccessControlArray.Add( AccessControl );

        if ( !fResult )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "out of memory"));

            pNodeList->Release();
            FreeAccessControl( &AccessControl );
            pDocument->Release();

            return E_OUTOFMEMORY;
        }
    }

    pNodeList->Release();

    if ( m_AccessControlArray.GetSize() == 0 )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "accesscontrol not found"));

        pDocument->Release();

        return RTC_E_PROFILE_NO_ACCESSCONTROL;
    } 

    hr = ValidateAccessControl();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                        "ValidateAccessControl failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }
*/

    //
    // server
    //

    PROF_SERVER Server;

    hr = pDocument->selectNodes( CComBSTR(_T("provision/sipsrv")), &pNodeList );

    pDocument->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "selectNodes(provision/sipsrv) failed 0x%lx", hr));

        return hr;
    }
    
    while ( pNodeList->nextNode( &pNode ) == S_OK )
    {
        hr = ParseXMLDOMNodeForServer( pNode, &Server );

        pNode->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "ParseXMLDOMNodeForServer failed 0x%lx", hr));

            pNodeList->Release();
            FreeServer( &Server );

            return hr;
        }

        BOOL fResult;
        
        fResult = m_ServerArray.Add( Server );

        if ( !fResult )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "out of memory"));

            pNodeList->Release();
            FreeServer( &Server );

            return E_OUTOFMEMORY;
        }
    }

    pNodeList->Release();

    if ( m_ServerArray.GetSize() == 0 )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "sipsrv not found"));

        return RTC_E_PROFILE_NO_SERVER;
    }

    int nNumRegistrar = 0;

    for ( int n = 0; n < m_ServerArray.GetSize(); n++ )
    {
        if ( m_ServerArray[n].fRegistrar == TRUE )
        {
            nNumRegistrar++;
        }
    }

    if ( nNumRegistrar > 1 )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "multiple registrar servers"));

        return RTC_E_PROFILE_MULTIPLE_REGISTRARS;
    }

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMDocument - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FreeProvision
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCProfile::FreeProvision(PROF_PROVISION * pStruct)
{
    LOG((RTC_TRACE, "CRTCProfile::FreeProvision[%p]", pStruct));

    RTCFREE(pStruct->szKey);
    RTCFREE(pStruct->szName);
    RTCFREE(pStruct->szExpires);
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FreeProvider
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCProfile::FreeProvider(PROF_PROVIDER * pStruct)
{
    LOG((RTC_TRACE, "CRTCProfile::FreeProvider[%p]", pStruct));

    RTCFREE(pStruct->szName);
    RTCFREE(pStruct->szHomepage);
    RTCFREE(pStruct->szHelpdesk);
    RTCFREE(pStruct->szPersonal);
    RTCFREE(pStruct->szCallDisplay);
    RTCFREE(pStruct->szIdleDisplay);
    RTCFREE(pStruct->szData);
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FreeClient
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCProfile::FreeClient(PROF_CLIENT * pStruct)
{
    LOG((RTC_TRACE, "CRTCProfile::FreeClient[%p]", pStruct));

    RTCFREE(pStruct->szName);
    RTCFREE(pStruct->szMinVer);
    RTCFREE(pStruct->szCurVer);
    RTCFREE(pStruct->szUpdateUri);
    RTCFREE(pStruct->szData);
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FreeUser
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCProfile::FreeUser(PROF_USER * pStruct)
{
    LOG((RTC_TRACE, "CRTCProfile::FreeUser[%p]", pStruct));

    RTCFREE(pStruct->szAccount);
    RTCFREE(pStruct->szName);
    RTCFREE(pStruct->szUri);
    RTCFREE(pStruct->szPassword);
    RTCFREE(pStruct->szRealm);
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FreeServer
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCProfile::FreeServer(PROF_SERVER * pStruct)
{
    LOG((RTC_TRACE, "CRTCProfile::FreeServer[%p]", pStruct));

    RTCFREE(pStruct->szAddr);    
}

/*
/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FreeAccessControl
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCProfile::FreeAccessControl(PROF_ACCESSCONTROL * pStruct)
{
    LOG((RTC_TRACE, "CRTCProfile::FreeAccessControl[%p]", pStruct));

    RTCFREE(pStruct->szDomain);
    RTCFREE(pStruct->szSig);
}

/////////////////////////////////////////////////////////////////////////////
//
// base64decode
//
/////////////////////////////////////////////////////////////////////////////

PBYTE 
base64decode(
    PWSTR pszBufCoded, 
    long * plDecodedSize
    )
{
    long lBytesDecoded;
    int pr2six[256];
    int i;
    int j=0;
    PWSTR pszCur = pszBufCoded;
    int fDone = FALSE;
    long lBufSize = 0;
    long lCount = 0;
    PWSTR pszBufIn = NULL;
    PBYTE pbBufOut = NULL;
    PBYTE pbTemp = NULL;    
    PBYTE pbBufDecoded = NULL;
    int lop_off;
    HRESULT hr = S_OK;

    //
    // Build up the reverse index from base64 characters to values
    // The multiple loops are easier
    //
    for (i=65; i<91; i++) {
         pr2six[i]=j++;
    }
    
    for (i=97; i<123; i++) {
         pr2six[i]=j++;
    }
    
    for (i=48; i<58; i++) {
        pr2six[i]=j++;
    }

    pr2six[43]=j++;
    pr2six[47]=j++;
    pr2six[61]=0;

    //
    // The old code relied on the size of the original data provided before 
    // the encoding. We don't have that, so we'll just allocate as much as 
    // the encoded data, relying on the fact that the encoded data is always 
    // larger. (+4 for good measure)
    // 
    lBufSize=wcslen(pszCur)-1+4;
    *plDecodedSize = lBufSize;

    pbBufDecoded = (PBYTE)RtcAlloc(lBufSize*sizeof(BYTE));
    if(!pbBufDecoded) {
        hr = E_OUTOFMEMORY;
        return NULL;
    }

        
    lCount=wcslen(pszCur);

    // Do the decoding to new buffer
    pszBufIn = pszCur;
    pbBufOut = pbBufDecoded;

    while(lCount > 0) {
        *(pbBufOut++) = (BYTE) (pr2six[*pszBufIn] << 2 | pr2six[pszBufIn[1]] >> 4);
        *(pbBufOut++) = (BYTE) (pr2six[pszBufIn[1]] << 4 | pr2six[pszBufIn[2]] >> 2);
        *(pbBufOut++) = (BYTE) (pr2six[pszBufIn[2]] << 6 | pr2six[pszBufIn[3]]);
        pszBufIn += 4;
        lCount -= 4;
    }

    //
    // The line below does not make much sense since \0 is really a valid 
    // binary value, so we can't add it to our data stream
    //
    //*(pbBufOut++) = '\0';
    
    //
    // Let's calculate the real size of our data
    //
    *plDecodedSize=(ULONG)(pbBufOut-pbBufDecoded);
    
    // 
    // if there were pads in the encoded stream, lop off the nulls the 
    // NULLS they created
    //
    lop_off=0;
    if (pszBufIn[-1]=='=') lop_off++;
    if (pszBufIn[-2]=='=') lop_off++;
    
    *plDecodedSize=*plDecodedSize-lop_off;

    pbTemp = (PBYTE) RtcAlloc((*plDecodedSize)*sizeof(BYTE));
    if (!pbTemp) {
        hr = E_OUTOFMEMORY;
        RtcFree(pbBufDecoded);
        return NULL;
    }
    memcpy(pbTemp, pbBufDecoded, (*plDecodedSize)*sizeof(BYTE));

    if (pbBufDecoded) {
        RtcFree(pbBufDecoded);
    }
    
    return pbTemp; 
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ValidateAccessControl
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::ValidateAccessControl()
{
    LOG((RTC_TRACE, "CRTCProfile::ValidateAccessControl - enter"));

    HCRYPTPROV  hProv = NULL;
    HCRYPTKEY   hKey = NULL;
    HRESULT     hr;

    //
    // Delete any existing keyset
    //

    CryptAcquireContext(
        &hProv,
        g_szKeyContainer,
        MS_DEF_PROV,
        PROV_RSA_FULL,
        CRYPT_DELETEKEYSET);

    //
    // Initialize crypto API
    //

    if(!CryptAcquireContext(
        &hProv,
        g_szKeyContainer,
        MS_DEF_PROV,
        PROV_RSA_FULL,
        CRYPT_SILENT | CRYPT_NEWKEYSET))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        LOG((RTC_ERROR, "CRTCProfile::ValidateAccessControl - "
                            "CryptAcquireContext failed 0x%lx", hr));
        
        return hr;
    }

    //
    // Import public key
    //

    if(!CryptImportKey(
        hProv,
        g_PublicKeyBlob,
        sizeof(g_PublicKeyBlob),
        NULL,
        0,
        &hKey))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        LOG((RTC_ERROR, "CRTCProfile::ValidateAccessControl - "
                            "CryptImportKey failed 0x%lx", hr));

        CryptReleaseContext(hProv, 0);
        
        return hr;
    }

    for ( int n=0; n < m_AccessControlArray.GetSize(); n++ )
    {
        //
        // Validate the key (signature)
        //

        HCRYPTHASH  hHash = NULL;

        //
        // Create a hash object
        //

        if(!CryptCreateHash(
            hProv,
            CALG_MD5,
            NULL,
            0,
            &hHash))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            LOG((RTC_ERROR, "CRTCProfile::ValidateAccessControl - "
                                "CryptCreateHash failed 0x%lx", hr));

            CryptDestroyKey(hKey);
            CryptReleaseContext(hProv, 0);
        
            return hr;
        }

        //
        // Hash the pieces (mater key, a colon, and the suffix)
        //

        if(!CryptHashData(hHash, (BYTE *)g_szMasterKeyWithColon, wcslen(g_szMasterKeyWithColon)*sizeof(WCHAR), 0) ||
           !CryptHashData(hHash, (BYTE *)m_AccessControlArray[n].szDomain, wcslen(m_AccessControlArray[n].szDomain) * sizeof(WCHAR), 0) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            LOG((RTC_ERROR, "CRTCProfile::ValidateAccessControl - "
                                "CryptHashData failed 0x%lx", hr));

            CryptDestroyHash(hHash);
            CryptDestroyKey(hKey);
            CryptReleaseContext(hProv, 0);
        
            return hr;
        }

        //
        // Convert the key to bytes
        //

        PBYTE   pSignature = NULL;
        DWORD   dwLength = 0;

        pSignature = base64decode(m_AccessControlArray[n].szSig, (long *)&dwLength);

        if (!pSignature)
        {
            LOG((RTC_ERROR, "CRTCProfile::ValidateAccessControl - "
                                "out of memory"));

            CryptDestroyHash(hHash);
            CryptDestroyKey(hKey);
            CryptReleaseContext(hProv, 0);
        
            return E_OUTOFMEMORY;
        }

        //
        // Verify the signature
        //

        if(!CryptVerifySignature(
            hHash,
            pSignature,
            dwLength,
            hKey,
            NULL,
            0))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            LOG((RTC_ERROR, "CRTCProfile::ValidateAccessControl - "
                                "CryptVerifySignature failed 0x%lx", hr));

            if( hr == HRESULT_FROM_WIN32(NTE_BAD_SIGNATURE) )
            {
                hr = RTC_E_PROFILE_INVALID_ACCESSCONTROL_SIGNATURE;

                LOG((RTC_ERROR, "CRTCProfile::ValidateAccessControl - "
                                    "invalid signature"));
            }

            RtcFree(pSignature);
            CryptDestroyHash(hHash);
            CryptDestroyKey(hKey);
            CryptReleaseContext(hProv, 0);

            return hr;
        }

        RtcFree(pSignature);
        CryptDestroyHash(hHash);
    }

    //
    // Release crypto objects
    //

    CryptDestroyKey(hKey);
    CryptReleaseContext(hProv, 0);
 
    LOG((RTC_TRACE, "CRTCProfile::ValidateAccessControl - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::IsMatchingAddress
//
/////////////////////////////////////////////////////////////////////////////

BOOL 
CRTCProfile::IsMatchingAddress(WCHAR *pszAddress, WCHAR *pszPattern)
{
    WCHAR * pwcAddrCrt = pszAddress;
    WCHAR * pwcPatternCrt = pszPattern;

    if(!pszAddress || !pszPattern)
    {
        return FALSE;
    }

    //
    // Go to the end
    //

    while(*pwcAddrCrt) 
    {
        if(*pwcAddrCrt==L':') // ignore the port
            break;

        pwcAddrCrt++;
    }

    while(*pwcPatternCrt) pwcPatternCrt++;

    //
    // Compare the suffix
    //

    while(1)
    {
        pwcPatternCrt--;
        pwcAddrCrt--;

        if(pwcPatternCrt >= pszPattern)
        {
            if(pwcAddrCrt >= pszAddress)
            {
                if(tolower(*pwcAddrCrt) != tolower(*pwcPatternCrt))
                {
                    //
                    // Doesn't match
                    //

                    return FALSE;
                }
            }
            else
            {
                //
                // The address is shorter, the matching failed
                //

                return FALSE;
            }
        }
        else
        {
            //
            // End of the pattern
            //

            if(pwcAddrCrt >= pszAddress)
            {
                //
                // Address is longer. Next char MUST be '.'
                //

                if(*pwcAddrCrt != L'.')
                {
                    return FALSE;
                }
                else
                {
                    return TRUE;
                }
            }
            else
            {
                //
                // Perfect match
                //

                return TRUE;
            }
        }
    }

    return FALSE;
}
*/

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::SetState
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::SetState(
        RTC_REGISTRATION_STATE enState,
        long lStatusCode,
        PCWSTR szStatusText
        )
{
    LOG((RTC_TRACE, "CRTCProfile::SetState - enter"));

    m_enState = enState;

    CRTCRegistrationStateChangeEvent::FireEvent(
                                                 m_pCClient,
                                                 this,
                                                 m_enState,
                                                 lStatusCode, // status code
                                                 szStatusText // status text
                                                 );

    if ( m_enState == RTCRS_NOT_REGISTERED )
    {
        //
        // Notify the core
        //

        PostMessage( m_pCClient->GetWindow(), WM_PROFILE_UNREG, (WPARAM)this, 0 );
    }

    LOG((RTC_TRACE, "CRTCProfile::SetState - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::Enable
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::Enable(long lRegisterFlags)
{
    LOG((RTC_TRACE, "CRTCProfile::Enable - enter"));

    if ( m_pSipStack == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::Enable - "
                            "no sip stack"));

        return E_UNEXPECTED;
    }

    //
    // Fill the SIP_PROVIDER_PROFILE structure
    //
   
    SIP_PROVIDER_PROFILE SipProfile;
    HRESULT hr;

    hr = GetSipProviderProfile( &SipProfile, lRegisterFlags );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::Enable - "
                            "GetSipProviderProfile failed 0x%lx", hr));   

        return hr;
    } 

    //
    // Set the SIP_PROVIDER_PROFILE in the SIP stack
    //

    hr = m_pSipStack->SetProviderProfile( &SipProfile );

    FreeSipProviderProfile( &SipProfile );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::Enable - "
                            "SetProviderProfile failed 0x%lx", hr));

        return hr;
    }

    m_fEnabled = TRUE;
    m_lRegisterFlags = lRegisterFlags;

    LOG((RTC_TRACE, "CRTCProfile::Enable - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::Disable
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::Disable()
{
    LOG((RTC_TRACE, "CRTCProfile::Disable - enter"));

    if ( m_pSipStack == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::Disable - "
                            "no sip stack"));

        return E_UNEXPECTED;
    }

    if ( IsEqualGUID( m_ProfileGuid, GUID_NULL ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::Disable - "
                            "null guid"));

        return E_UNEXPECTED;
    }

    if ( !m_lRegisterFlags )
    {
        //
        // Notify the core
        //

        PostMessage( m_pCClient->GetWindow(), WM_PROFILE_UNREG, (WPARAM)this, 0 );
    }

    if ( m_fEnabled )
    {
        HRESULT hr;

        hr = m_pSipStack->DeleteProviderProfile( &m_ProfileGuid );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCProfile::Disable - "
                                "DeleteProviderProfile failed 0x%lx", hr));

            return hr;
        }

        m_fEnabled = FALSE;
        m_lRegisterFlags = 0;
    }

    LOG((RTC_TRACE, "CRTCProfile::Disable - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::Redirect
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::Redirect(ISipRedirectContext * pSipRedirectContext)
{
    LOG((RTC_TRACE, "CRTCProfile::Redirect - enter"));

    if ( m_pSipStack == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::Redirect - "
                            "no sip stack"));

        return E_UNEXPECTED;
    }

    //
    // Get the next SIP URI
    //

    BSTR bstrRedirectURI = NULL;
    BSTR bstrRedirectName = NULL;
    HRESULT hr;

    hr = pSipRedirectContext->Advance();

    if ( hr != S_OK )
    {
        if ( hr == S_FALSE )
        {
            LOG((RTC_ERROR, "CRTCProfile::Redirect - "
                                "redirect list empty"));
        }
        else
        {
            LOG((RTC_ERROR, "CRTCProfile::Redirect - "
                                "Advance failed 0x%lx", hr));
        }

        return hr;
    }

    hr = pSipRedirectContext->GetSipUrlAndDisplayName( &bstrRedirectURI, &bstrRedirectName );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::Redirect - "
                            "GetSipUrlAndDisplayName failed 0x%lx", hr));

        return hr;
    }

    SysFreeString( bstrRedirectName );
    bstrRedirectName = NULL;

    //
    // Fill the SIP_PROVIDER_PROFILE structure
    //
   
    SIP_PROVIDER_PROFILE SipProfile;

    hr = GetSipProviderProfile( &SipProfile, m_lRegisterFlags );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::Redirect - "
                            "GetSipProviderProfile failed 0x%lx", hr));

        SysFreeString( bstrRedirectURI );
        bstrRedirectURI = NULL;        

        return hr;
    } 

    if ( SipProfile.lRegisterAccept != 0 )
    {
        RTCFREE( SipProfile.Registrar.ServerAddress );

        SipProfile.Registrar.ServerAddress = RtcAllocString( bstrRedirectURI );
        SipProfile.Registrar.IsServerAddressSIPURI = TRUE;
        SipProfile.Registrar.AuthProtocol = SIP_AUTH_PROTOCOL_NONE;
        SipProfile.Registrar.TransportProtocol = SIP_TRANSPORT_UNKNOWN;

        if ( SipProfile.Registrar.ServerAddress == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::NotifyRegisterRedirect - "
                                "out of memory"));

            FreeSipProviderProfile( &SipProfile );

            SysFreeString( bstrRedirectURI );
            bstrRedirectURI = NULL;   

            return E_OUTOFMEMORY;
        }
    }

    SysFreeString( bstrRedirectURI );
    bstrRedirectURI = NULL;  

    //
    // Set the SIP_PROVIDER_PROFILE in the SIP stack
    //

    hr = m_pSipStack->SetProviderProfile( &SipProfile );

    FreeSipProviderProfile( &SipProfile );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::Redirect - "
                            "SetProviderProfile failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCProfile::Redirect - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::GetGuid
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCProfile::GetGuid(GUID * pGUID)
{
    LOG((RTC_TRACE, "CRTCProfile::GetGuid"));

    CopyMemory( pGUID, &m_ProfileGuid, sizeof(GUID) );
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_Key
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_Key(
        BSTR * pbstrKey
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_Key - enter"));

    if ( IsBadWritePtr( pbstrKey, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_Key - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_Key - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Provision.szKey == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_Key - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrKey = SysAllocString( m_Provision.szKey );
    
    if ( *pbstrKey == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_Key - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_Key - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_Name
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_Name(
        BSTR * pbstrName
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_Name - enter"));

    if ( IsBadWritePtr( pbstrName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_Name - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_Name - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Provision.szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_Name - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrName = SysAllocString( m_Provision.szName );
    
    if ( *pbstrName == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_Name - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_Name - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_XML
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_XML(
        BSTR * pbstrXML
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_XML - enter"));

    if ( IsBadWritePtr( pbstrXML, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_XML - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_XML - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_szProfileXML == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_XML - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrXML = SysAllocString( m_szProfileXML );
    
    if ( *pbstrXML == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_XML - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_XML - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ProviderName
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ProviderName(
        BSTR * pbstrName
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ProviderName - enter"));

    if ( IsBadWritePtr( pbstrName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderName - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderName - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Provider.szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderName - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrName = SysAllocString( m_Provider.szName );
    
    if ( *pbstrName == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderName - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_ProviderName - exit"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ProviderURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ProviderURI(
        RTC_PROVIDER_URI enURI,
        BSTR * pbstrURI
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ProviderURI - enter"));

    if ( IsBadWritePtr( pbstrURI, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }    

    switch( enURI )
    {
    case RTCPU_URIHOMEPAGE:
        if ( m_Provider.szHomepage == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                                "no value"));

            return E_FAIL;
        }

        *pbstrURI = SysAllocString( m_Provider.szHomepage );
        break;

    case RTCPU_URIHELPDESK:
        if ( m_Provider.szHelpdesk == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                                "no value"));

            return E_FAIL;
        }

        *pbstrURI = SysAllocString( m_Provider.szHelpdesk );
        break;

    case RTCPU_URIPERSONALACCOUNT:
        if ( m_Provider.szPersonal == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                                "no value"));

            return E_FAIL;
        }

        *pbstrURI = SysAllocString( m_Provider.szPersonal );
        break;

    case RTCPU_URIDISPLAYDURINGCALL:
        if ( m_Provider.szCallDisplay == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                                "no value"));

            return E_FAIL;
        }

        *pbstrURI = SysAllocString( m_Provider.szCallDisplay );
        break;

    case RTCPU_URIDISPLAYDURINGIDLE:
        if ( m_Provider.szIdleDisplay == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                                "no value"));

            return E_FAIL;
        }

        *pbstrURI = SysAllocString( m_Provider.szIdleDisplay );
        break;

    default:
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                            "bad RTC_PROVIDER_URI"));

        return E_INVALIDARG;
    }
    
    if ( *pbstrURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_ProviderURI - exit"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ProviderData
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ProviderData(
        BSTR * pbstrData
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ProviderData - enter"));

    if ( IsBadWritePtr( pbstrData, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderData - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderData - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Provider.szData == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderData - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrData = SysAllocString( m_Provider.szData );
    
    if ( *pbstrData == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderData - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_ProviderData - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ClientName
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ClientName(
        BSTR * pbstrName
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ClientName - enter"));

    if ( IsBadWritePtr( pbstrName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientName - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientName - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Client.szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientName - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrName = SysAllocString( m_Client.szName );
    
    if ( *pbstrName == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientName - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_ClientName - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ClientBanner
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ClientBanner(
        VARIANT_BOOL * pfBanner
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ClientBanner - enter"));

    if ( IsBadWritePtr( pfBanner, sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientBanner - "
                            "bad VARIANT_BOOL pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientBanner - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    *pfBanner = m_Client.fBanner ? VARIANT_TRUE : VARIANT_FALSE;

    LOG((RTC_TRACE, "CRTCProfile::get_ClientBanner - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ClientMinVer
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ClientMinVer(
        BSTR * pbstrMinVer
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ClientMinVer - enter"));

    if ( IsBadWritePtr( pbstrMinVer, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientMinVer - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientMinVer - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Client.szMinVer == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientMinVer - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrMinVer = SysAllocString( m_Client.szMinVer );
    
    if ( *pbstrMinVer == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientMinVer - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_ClientMinVer - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ClientCurVer
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ClientCurVer(
        BSTR * pbstrCurVer
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ClientCurVer - enter"));

    if ( IsBadWritePtr( pbstrCurVer, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientCurVer - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientCurVer - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Client.szCurVer == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientCurVer - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrCurVer = SysAllocString( m_Client.szCurVer );
    
    if ( *pbstrCurVer == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientCurVer - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_ClientCurVer - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ClientUpdateURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ClientUpdateURI(
        BSTR * pbstrUpdateURI
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ClientUpdateURI - enter"));

    if ( IsBadWritePtr( pbstrUpdateURI, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientUpdateURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientUpdateURI - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Client.szUpdateUri == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientUpdateURI - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrUpdateURI = SysAllocString( m_Client.szUpdateUri );
    
    if ( *pbstrUpdateURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientUpdateURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_ClientUpdateURI - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ClientData
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ClientData(
        BSTR * pbstrData
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ClientData - enter"));

    if ( IsBadWritePtr( pbstrData, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientData - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientData - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Client.szData == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientData - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrData = SysAllocString( m_Client.szData );
    
    if ( *pbstrData == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientData - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_ClientData - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_UserURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_UserURI(
        BSTR * pbstrUserURI
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_UserURI - enter"));

    if ( IsBadWritePtr( pbstrUserURI, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserURI - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_User.szUri == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserURI - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrUserURI = SysAllocString( m_User.szUri );
    
    if ( *pbstrUserURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_UserURI - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_UserName
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_UserName(
        BSTR * pbstrUserName
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_UserName - enter"));

    if ( IsBadWritePtr( pbstrUserName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserName - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserName - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_User.szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserName - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrUserName = SysAllocString( m_User.szName );
    
    if ( *pbstrUserName == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserName - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_UserName - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_UserAccount
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_UserAccount(
        BSTR * pbstrUserAccount
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_UserAccount - enter"));

    if ( IsBadWritePtr( pbstrUserAccount, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserAccount - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserAccount - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_User.szAccount == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserAccount - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrUserAccount = SysAllocString( m_User.szAccount );
    
    if ( *pbstrUserAccount == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserAccount - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_UserAccount - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::SetCredentials
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::SetCredentials(
        BSTR    bstrUserURI,
        BSTR    bstrUserAccount,
        BSTR    bstrPassword
        )
{
    LOG((RTC_TRACE, "CRTCProfile::SetCredentials - enter"));

    if ( IsBadStringPtrW( bstrUserURI, -1 ) ||
         ((bstrUserAccount != NULL) && IsBadStringPtrW( bstrUserAccount, -1 )) ||
         ((bstrPassword != NULL) && IsBadStringPtrW( bstrPassword, -1 )) )
    {
        LOG((RTC_ERROR, "CRTCProfile::SetCredentials - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::SetCredentials - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    PWSTR szUserURI = NULL;
    PWSTR szUserAccount = NULL;
    PWSTR szPassword = NULL;
    HRESULT hr;

    hr = AllocCleanSipString( bstrUserURI, &szUserURI );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::SetCredentials - "
                        "out of memory"));

        return E_OUTOFMEMORY;
    }

    if ( bstrUserAccount )
    {
        szUserAccount = RtcAllocString( bstrUserAccount );

        if ( szUserAccount == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::SetCredentials - "
                            "out of memory"));

            RTCFREE(szUserURI);

            return E_OUTOFMEMORY;
        }
    }

    if ( bstrPassword )
    {
        szPassword = RtcAllocString( bstrPassword );

        if ( szPassword == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::SetCredentials - "
                            "out of memory"));

            RTCFREE(szUserURI);
            RTCFREE(szUserAccount);

            return E_OUTOFMEMORY;
        }
    }

    RTCFREE(m_User.szUri);
    RTCFREE(m_User.szAccount);
    RTCFREE(m_User.szPassword);

    m_User.szUri = szUserURI;
    m_User.szAccount = szUserAccount;
    m_User.szPassword = szPassword;

    LOG((RTC_TRACE, "CRTCProfile::SetCredentials - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_SessionCapabilities
//
/////////////////////////////////////////////////////////////////////////////
    
STDMETHODIMP 
CRTCProfile::get_SessionCapabilities(
        long * plSupportedSessions
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_SessionCapabilities - enter"));

    if ( IsBadWritePtr( plSupportedSessions, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_SessionCapabilities - "
                            "bad long pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_SessionCapabilities - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    *plSupportedSessions = 0;
    
    for ( int n=0; n < m_ServerArray.GetSize(); n++ )
    {
        *plSupportedSessions |= m_ServerArray[n].lSessions;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_SessionCapabilities - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_State
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_State(
        RTC_REGISTRATION_STATE * penState
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_State - enter"));

    if ( IsBadWritePtr( penState, sizeof(RTC_REGISTRATION_STATE) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_State - "
                            "bad RTC_REGISTRATION_STATE pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_State - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    *penState = m_enState;

    LOG((RTC_TRACE, "CRTCProfile::get_State - exit"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcreg.cpp ===
#include "stdafx.h"
#include "rtcreg.h"

const TCHAR * g_szRtcKeyName = _T("Software\\Microsoft\\RTC");

WCHAR *g_szRtcRegistryStringNames[] =
{
    L"TermAudioCapture",
    L"TermAudioRender",
    L"TermVideoCapture"
};

WCHAR *g_szRtcRegistryDwordNames[] =
{
    L"PreferredMediaTypes",
    L"Tuned"
};

/////////////////////////////////////////////////////////////////////////////
//
// put_RegistryString
//
// This is a method that stores a settings string in
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
put_RegistryString(
        RTC_REGISTRY_STRING enSetting,
        BSTR bstrValue            
        )
{
    // LOG((RTC_TRACE, "put_RegistryString - enter"));

    if ( IsBadStringPtrW( bstrValue, -1 ) )
    {
        LOG((RTC_ERROR, "put_RegistryString - "
                            "bad string pointer"));

        return E_POINTER;
    }  

    //
    // Open the RTCClient key
    //

    LONG lResult;
    HKEY hkeyRTC;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szRtcKeyName,
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyRTC,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "put_RegistryString - "
                            "RegCreateKeyEx(RTCClient) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    lResult = RegSetValueExW(
                             hkeyRTC,
                             g_szRtcRegistryStringNames[enSetting],
                             0,
                             REG_SZ,
                             (LPBYTE)bstrValue,
                             sizeof(WCHAR) * (lstrlenW(bstrValue) + 1)
                            );

    RegCloseKey( hkeyRTC );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "put_RegistryString - "
                            "RegSetValueEx failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }    
      
    // LOG((RTC_TRACE, "put_RegistryString - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// get_RegistryString
//
// This is a method that gets a settings string from
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
get_RegistryString(
        RTC_REGISTRY_STRING enSetting,
        BSTR * pbstrValue            
        )
{
    // LOG((RTC_TRACE, "get_RegistryString - enter"));

    if ( IsBadWritePtr( pbstrValue, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "get_RegistryString - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }  

    //
    // Open the RTCClient key
    //

    LONG lResult;
    HKEY hkeyRTC;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szRtcKeyName,
                             0,
                             NULL,
                             0,
                             KEY_READ,
                             NULL,
                             &hkeyRTC,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_WARN, "get_RegistryString - "
                            "RegCreateKeyEx(RTCClient) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    PWSTR szString = NULL;

    szString = RtcRegQueryString( hkeyRTC, g_szRtcRegistryStringNames[enSetting] );

    RegCloseKey( hkeyRTC );

    if ( szString == NULL )
    {
        LOG((RTC_ERROR, "get_RegistryString - "
                            "RtcRegQueryString failed"));

        return E_FAIL;
    }
    
    *pbstrValue = SysAllocString( szString );

    RtcFree( szString );

    if ( *pbstrValue == NULL )
    {
        LOG((RTC_ERROR, "get_RegistryString - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }
      
    // LOG((RTC_TRACE, "get_RegistryString - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// DeleteRegistryString
//
// This is a method that deletes a settings string in
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
DeleteRegistryString(
        RTC_REGISTRY_STRING enSetting         
        )
{
    // LOG((RTC_TRACE, "DeleteRegistryString - enter")); 

    //
    // Open the RTCClient key
    //

    LONG lResult;
    HKEY hkeyRTC;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szRtcKeyName,
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyRTC,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DeleteRegistryString - "
                            "RegCreateKeyEx(RTCClient) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    lResult = RegDeleteValueW(
                             hkeyRTC,
                             g_szRtcRegistryStringNames[enSetting]
                            );

    RegCloseKey( hkeyRTC );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_WARN, "DeleteRegistryString - "
                            "RegDeleteValueW failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }    
      
    // LOG((RTC_TRACE, "DeleteRegistryString - exit S_OK"));

    return S_OK;
}          

/////////////////////////////////////////////////////////////////////////////
//
// put_RegistryDword
//
// This is a method that stores a settings dword in
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
put_RegistryDword(
        RTC_REGISTRY_DWORD enSetting,
        DWORD dwValue            
        )
{
    // LOG((RTC_TRACE, "put_RegistryDword - enter"));

    //
    // Open the RTCClient key
    //

    LONG lResult;
    HKEY hkeyRTC;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szRtcKeyName,
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyRTC,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "put_RegistryDword - "
                            "RegCreateKeyEx(RTCClient) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    lResult = RegSetValueExW(
                     hkeyRTC,
                     g_szRtcRegistryDwordNames[enSetting],
                     0,
                     REG_DWORD,
                     (LPBYTE)&dwValue,
                     sizeof(DWORD)
                    );

    RegCloseKey( hkeyRTC );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "put_RegistryDword - "
                            "RegSetValueEx failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }    
      
    // LOG((RTC_TRACE, "put_RegistryDword - exit S_OK"));

    return S_OK;
}            

/////////////////////////////////////////////////////////////////////////////
//
// get_RegistryDword
//
// This is a method that gets a settings dword from
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
get_RegistryDword(
        RTC_REGISTRY_DWORD enSetting,
        DWORD * pdwValue            
        )
{
    // LOG((RTC_TRACE, "get_RegistryDword - enter"));

    if ( IsBadWritePtr( pdwValue, sizeof(DWORD) ) )
    {
        LOG((RTC_ERROR, "get_RegistryDword - "
                            "bad DWORD pointer"));

        return E_POINTER;
    }

    //
    // Open the RTCClient key
    //

    LONG lResult;
    HKEY hkeyRTC;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szRtcKeyName,
                             0,
                             NULL,
                             0,
                             KEY_READ,
                             NULL,
                             &hkeyRTC,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "get_RegistryDword - "
                            "RegCreateKeyEx(RTCClient) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    DWORD cbSize = sizeof(DWORD);

    lResult = RegQueryValueExW(
                               hkeyRTC,
                               g_szRtcRegistryDwordNames[enSetting],
                               0,
                               NULL,
                               (LPBYTE)pdwValue,
                               &cbSize
                              );

    RegCloseKey( hkeyRTC );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_WARN, "get_RegistryDword - "
                            "RegQueryValueExW failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }    
      
    // LOG((RTC_TRACE, "get_RegistryDword - exit S_OK"));

    return S_OK;
}                    

/////////////////////////////////////////////////////////////////////////////
//
// DeleteRegistryDword
//
// This is a method that deletes a settings dword in
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
DeleteRegistryDword(
        RTC_REGISTRY_DWORD enSetting
        )
{
    // LOG((RTC_TRACE, "DeleteRegistryDword - enter"));

    //
    // Open the RTCClient key
    //

    LONG lResult;
    HKEY hkeyRTC;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szRtcKeyName,
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyRTC,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DeleteRegistryDword - "
                            "RegCreateKeyEx(RTCClient) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    lResult = RegDeleteValueW(
                     hkeyRTC,
                     g_szRtcRegistryDwordNames[enSetting]
                    );

    RegCloseKey( hkeyRTC );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_WARN, "DeleteRegistryDword - "
                            "RegDeleteValueW failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }    
      
    // LOG((RTC_TRACE, "DeleteRegistryDword - exit S_OK"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcreg.h ===
//
// rtcreg.h
//

#ifndef __RTCREG_H_
#define __RTCREG_H_

typedef enum RTC_REGISTRY_STRING
{
    RTCRS_TERM_AUDIO_CAPTURE,
    RTCRS_TERM_AUDIO_RENDER,
    RTCRS_TERM_VIDEO_CAPTURE
    
} RTC_REGISTRY_STRING;

typedef enum RTC_REGISTRY_DWORD
{
    RTCRD_PREFERRED_MEDIA_TYPES,
    RTCRD_TUNED
    
} RTC_REGISTRY_DWORD;


HRESULT put_RegistryString(
        RTC_REGISTRY_STRING enSetting,
        BSTR bstrValue            
        ); 

HRESULT get_RegistryString(
        RTC_REGISTRY_STRING enSetting,
        BSTR * pbstrValue            
        ); 

HRESULT DeleteRegistryString(
        RTC_REGISTRY_STRING enSetting
        );

HRESULT put_RegistryDword(
        RTC_REGISTRY_DWORD enSetting,
        DWORD dwValue            
        ); 

HRESULT get_RegistryDword(
        RTC_REGISTRY_DWORD enSetting,
        DWORD * pdwValue            
        ); 

HRESULT DeleteRegistryDword(
        RTC_REGISTRY_DWORD enSetting
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcwaves.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCWaves.h

Abstract:

    Definition of the CWavePlayer class

--*/

#ifndef __RTCWAVES__
#define __RTCWAVES__

#include <mmsystem.h>

#define NUM_WAVES 4

typedef enum WAVE
{
	WAVE_TONE,
	WAVE_RING,
    WAVE_MESSAGE,
    WAVE_RINGBACK
	
} WAVE;

//////////////////////////////////////////////////////////////////////////////
//
// class CWavePlayer
//
//

class CWavePlayer
{
public:

	CWavePlayer();
    ~CWavePlayer();

    static HRESULT Initialize(void);

    HRESULT OpenWaveDevice(long lWaveId);
    void    CloseWaveDevice(void);

    BOOL IsWaveDeviceOpen(void);

    HRESULT PlayWave(WAVE enWave);
    HRESULT StopWave();

private:

    // TRUE if Initialize has succeeded.
    static BOOL    m_fInitialized;

    // Handle to the wave out device. NULL when the device is not open.
    HWAVEOUT m_hWaveOut;

    // Wave header
    WAVEHDR m_WaveHeader;

    // Buffers for the tones
    static LPBYTE   m_lpWaveform[ NUM_WAVES ];

    static DWORD    m_dwWaveformSize[ NUM_WAVES ];
};

#endif // __RTCWAVES__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcwatcher.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCWatcher.cpp

Abstract:

    Definition of the CRTCWatcher class

--*/
#include "stdafx.h"


/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::FinalConstruct
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCWatcher::FinalConstruct()
{
    LOG((RTC_TRACE, "CRTCWatcher::FinalConstruct [%p] - enter", this));

#if DBG
    m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)m_pDebug) = this;
#endif

    LOG((RTC_TRACE, "CRTCWatcher::FinalConstruct [%p] - exit S_OK", this));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCWatcher::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCWatcher::FinalRelease [%p] - enter", this));

    RemoveSIPWatchers(FALSE);

    ReleaseAll();

    m_SIPWatchers.Shutdown();

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCWatcher::FinalRelease [%p] - exit", this));
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::InternalAddRef
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCWatcher::InternalAddRef()
{
    DWORD dwR;

    dwR = InterlockedIncrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCWatcher::InternalAddRef [%p] - dwR %d", this, dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::InternalRelease
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCWatcher::InternalRelease()
{
    DWORD               dwR;
    
    dwR = InterlockedDecrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCWatcher::InternalRelease [%p] - dwR %d", this, dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::ReleaseAll
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCWatcher::ReleaseAll()
{
    if ( m_pCClient != NULL )
    {
        m_pCClient->Release();
        m_pCClient = NULL;
    }

    if ( m_pSIPWatcherManager != NULL )
    {
        m_pSIPWatcherManager->Release();
        m_pSIPWatcherManager = NULL;
    }

    if ( m_szName != NULL )
    {
        RtcFree(m_szName);
        m_szName = NULL;
    }
    
    if ( m_szData != NULL )
    {
        RtcFree(m_szData);
        m_szData = NULL;
    }

	if ( m_szShutdownBlob != NULL )
    {
        RtcFree(m_szShutdownBlob);
        m_szShutdownBlob = NULL;
    }

    if ( m_szPresentityURI != NULL )
    {
        RtcFree(m_szPresentityURI);
        m_szPresentityURI = NULL;
    }
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::Initialize
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCWatcher::Initialize(
                            CRTCClient         * pCClient, 
                            ISIPWatcherManager * pSIPWatcherManager,
                            PCWSTR               szPresentityURI,
                            PCWSTR               szName,
                            PCWSTR               szData,
                            PCWSTR               szShutdownBlob,
                            BOOL                 bPersistent
                            )
{
    LOG((RTC_TRACE, "CRTCWatcher::Initialize - enter"));

    if ( IsBadReadPtr( pCClient, sizeof(CRTCClient) ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::Initialize - "
                            "bad CRTCClient pointer"));

        return E_POINTER;
    }

    if ( IsBadReadPtr( pSIPWatcherManager, sizeof(ISIPWatcherManager) ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::Initialize - "
                            "bad ISIPWatcherManager pointer"));

        return E_POINTER;
    }

    // this object supports re-initialize
    ReleaseAll();

    m_szPresentityURI = RtcAllocString(szPresentityURI);
    m_szName = RtcAllocString(szName);
    m_szData = RtcAllocString(szData);
    m_szShutdownBlob = RtcAllocString(szShutdownBlob);

    m_bPersistent = bPersistent;

    m_pCClient = pCClient;
    m_pCClient->AddRef();

    m_pSIPWatcherManager = pSIPWatcherManager;
    m_pSIPWatcherManager->AddRef();

    LOG((RTC_TRACE, "CRTCWatcher::Initialize - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::SetSIPWatcher
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCWatcher::SetSIPWatcher(
        ISIPWatcher * pSIPWatcher
)
{
    LOG((RTC_TRACE, "CRTCWatcher::SetSIPWatcher - enter"));

    HRESULT     hr;

    //
    // Clear the watcher shutdown blob
    //

    if ( m_szShutdownBlob != NULL )
    {
        RtcFree( m_szShutdownBlob );
        m_szShutdownBlob = NULL;
    }

    //
    // Search an existing entry. Add the pointer only when it is not yet in the array
    //
    int   iIndex;

    iIndex = m_SIPWatchers.Find(pSIPWatcher);

    if(iIndex!=-1)
    {
        // Hmm, the SIP watcher is already here...

        LOG((RTC_WARN, "CRTCWatcher::SetSIPWatcher - "
                                "Duplicate offer watcher"));

        return S_OK;
    }

    // there is no entry
    // create one
    BOOL fResult;

    fResult = m_SIPWatchers.Add(pSIPWatcher);
    
    if(!fResult)
    {
        LOG((RTC_ERROR, "CRTCClient::SetSIPWatcher - "
                               "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCWatcher::SetSIPWatcher - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::RemoveSIPWatcher
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCWatcher::RemoveSIPWatcher(
        ISIPWatcher * pSIPWatcher,
        BOOL bShutdown)
{
    LOG((RTC_TRACE, "CRTCWatcher::RemoveSIPWatcher - enter"));

    HRESULT hr; 

    //
    // Search in the array
    //

    int   iIndex;

    iIndex = m_SIPWatchers.Find(pSIPWatcher);

    if(iIndex==-1)
    {
        LOG((RTC_WARN, "CRTCWatcher::RemoveSIPWatcher - "
            "SIP watcher not found in the array"));

        // remove it from the SIP list of watchers.

        m_pSIPWatcherManager->RemoveWatcher(
        pSIPWatcher,
        bShutdown ? APPLICATION_SHUTDOWN : BUDDY_REMOVED_BYUSER);

        return E_FAIL;
        // continue
    }

    // remove from the SIP watcher list
    // There are some cases (for some of the core watchers in OFFERING state)
    // this call is not necessary, but we'd better call it rather than leaking something
    //

    hr = RemoveSIPWatcher(iIndex, bShutdown);

    if ( FAILED(hr) )
    {        
        LOG((RTC_ERROR, "CRTCWatcher::RemoveSIPWatcher - "
                        "RemoveSIPWatcher (index) failed 0x%lx", hr));
    } 

    LOG((RTC_TRACE, "CRTCWatcher::RemoveSIPWatcher - exit S_OK"));

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::RemoveSIPWatcher (by index)
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCWatcher::RemoveSIPWatcher(
        int  iIndex,
        BOOL bShutdown)
{
    LOG((RTC_TRACE, "CRTCWatcher::RemoveSIPWatcher (index) - enter"));

    HRESULT hr; 

    // remove from the SIP watcher list
    // There are some cases (for some of the core watchers in OFFERING state)
    // this call is not necessary, but we'd better call it rather than leaking something
    //

    hr = m_pSIPWatcherManager->RemoveWatcher(
            m_SIPWatchers[iIndex],
            bShutdown ? APPLICATION_SHUTDOWN : BUDDY_REMOVED_BYUSER);

    if ( FAILED(hr) )
    {        
        LOG((RTC_ERROR, "CRTCWatcher::RemoveSIPWatcher (index) - "
                        "RemoveWatcher failed 0x%lx", hr));
    } 

    // Don't change the array if we are in the middle of some iteration
    if(m_bIsNested)
    {
        ISIPWatcher     *pSIPWatcher;
        
        pSIPWatcher = m_SIPWatchers[iIndex];
        m_SIPWatchers[iIndex] = NULL;
        
        pSIPWatcher->Release();
    }
    else
    {
        // remove from array
        //
        m_SIPWatchers.RemoveAt(iIndex);
    }

    LOG((RTC_TRACE, "CRTCWatcher::RemoveSIPWatcher (index) - exit S_OK"));

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::ChangeBlockedStatus
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCWatcher::ChangeBlockedStatus(
    WATCHER_BLOCKED_STATUS Status)
{
    HRESULT         hrAll = S_OK;
    
    if ( Status == WATCHER_UNBLOCKED )
    {
        //
        // Send the watcher shutdown blob if it exists
        //

        SendSIPWatcherShutdownBlob();
    }

    ISIPWatcher     ** pCrt;
    ISIPWatcher     ** pEnd;

    m_bIsNested = TRUE;

    for(pCrt = &m_SIPWatchers[0], pEnd = pCrt + m_SIPWatchers.GetSize();
        pCrt < pEnd;
        pCrt ++)
    {
        HRESULT     hr;

        hr = (*pCrt)->ChangeBlockedStatus(Status);
    
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCWatcher::ChangeBlockStatus - "
                            "ChangeBlockStatus failed 0x%lx", hr));

            if(hrAll==S_OK)
            {
                hrAll = hr;
            }
        }
    }

    m_bIsNested = FALSE;

    PostSIPWatchersCleanUp();

    return hrAll;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::RemoveSIPWatchers
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCWatcher::RemoveSIPWatchers(
        BOOL bShutdown)
{
    HRESULT         hrAll = S_OK;

    LOG((RTC_TRACE, "CRTCWatcher::RemoveSIPWatchers - enter"));

    m_bIsNested = TRUE;

    int iIndex;    

    for(iIndex = 0;
        iIndex < m_SIPWatchers.GetSize();
        iIndex ++)
    {
        HRESULT     hr;

        hr = RemoveSIPWatcher(
            iIndex,
            bShutdown);
    
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCWatcher::RemoveSIPWatchers - "
                            "RemoveSIPWatcher (index) failed 0x%lx", hr));

            if(hrAll==S_OK)
            {
                hrAll = hr;
            }
        }
    }

    m_bIsNested = FALSE;

    PostSIPWatchersCleanUp();
    
    LOG((RTC_TRACE, "CRTCWatcher::RemoveSIPWatchers - exit"));

    return hrAll;    
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::ApproveSubscription
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCWatcher::ApproveSubscription(
        DWORD dwPresenceInfoRules)
{
    HRESULT         hrAll = S_OK;

    LOG((RTC_TRACE, "CRTCWatcher::ApproveSubscription - enter"));

    ISIPWatcher     ** pCrt;
    ISIPWatcher     ** pEnd;

    m_bIsNested = TRUE;

    for(pCrt = &m_SIPWatchers[0], pEnd = pCrt + m_SIPWatchers.GetSize();
        pCrt < pEnd;
        pCrt ++)
    {
        HRESULT     hr;

        hr = (*pCrt)->ApproveSubscription(dwPresenceInfoRules);
    
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCWatcher::ApproveSubscription - "
                            "ApproveSubscription failed 0x%lx", hr));

            if(hrAll==S_OK)
            {
                hrAll = hr;
            }
        }
    }

    m_bIsNested = FALSE;

    PostSIPWatchersCleanUp();
    
    LOG((RTC_TRACE, "CRTCWatcher::ApproveSubscription - exit"));

    return hrAll;    
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::RejectSubscription
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCWatcher::RejectSubscription(
    WATCHER_REJECT_REASON ulReason
    )
{
    HRESULT         hrAll = S_OK;

    LOG((RTC_TRACE, "CRTCWatcher::RejectSubscription - enter"));

    ISIPWatcher      ** pCrt;
    ISIPWatcher      ** pEnd;

    m_bIsNested = TRUE;

    for(pCrt = &m_SIPWatchers[0], pEnd = pCrt + m_SIPWatchers.GetSize();
        pCrt < pEnd;
        pCrt ++)
    {
        HRESULT     hr;

        hr = (*pCrt)->RejectSubscription(ulReason);
    
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCWatcher::RejectSubscription - "
                            "RejectSubscription failed 0x%lx", hr));

            if(hrAll==S_OK)
            {
                hrAll = hr;
            }
        }
    }

    m_bIsNested = FALSE;

    PostSIPWatchersCleanUp();
    
    LOG((RTC_TRACE, "CRTCWatcher::RejectSubscription - exit"));

    return hrAll;    
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::PostSIPWatchersCleanUp
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCWatcher::PostSIPWatchersCleanUp(void)
{
    ISIPWatcher ** pCrt;
    ISIPWatcher ** pEnd;

    for(pCrt = &m_SIPWatchers[0], pEnd = pCrt + m_SIPWatchers.GetSize();
        pCrt < pEnd;
        )
    {
        if((*pCrt)==NULL)
        {
            m_SIPWatchers.RemoveAt((int)(pCrt - &m_SIPWatchers[0]));
            pEnd -- ;
        }
        else
        {
            pCrt++;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::GetSIPWatcherShutdownBlob
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCWatcher::GetSIPWatcherShutdownBlob()
{
    LOG((RTC_TRACE, "CRTCWatcher::GetSIPWatcherShutdownBlob - enter"));

    ISIPWatcher      ** pCrt;
    ISIPWatcher      ** pEnd;
    HRESULT             hr;
    DWORD               dwLength;
    PSTR                szShutdown = NULL;
    PWSTR               wszShutdown = NULL;    

    if ( m_szShutdownBlob != NULL )
    {
        LOG((RTC_INFO, "CRTCWatcher::GetSIPWatcherShutdownBlob - "
                            "already have a shutdown blob"));

        return S_OK;
    }

    szShutdown = (PSTR)RtcAlloc(2000); // maximum size for the shutdown data

    if ( szShutdown == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::GetSIPWatcherShutdownBlob - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    for(pCrt = &m_SIPWatchers[0], pEnd = pCrt + m_SIPWatchers.GetSize();
        pCrt < pEnd;
        pCrt ++)
    {
        dwLength = 2000;        

        hr = (*pCrt)->GetWatcherShutdownData(szShutdown, &dwLength);
    
        if ( SUCCEEDED(hr) )
        {
            LOG((RTC_INFO, "CRTCWatcher::GetSIPWatcherShutdownBlob - "
                            "got a shutdown data blob"));

            DWORD dwWideLength;
            
            dwWideLength = MultiByteToWideChar( CP_ACP, 0, szShutdown, dwLength, NULL, 0 );

            if ( dwWideLength == 0 )
            {
                hr = HRESULT_FROM_WIN32(GetLastError());

                LOG((RTC_ERROR, "CRTCWatcher::GetSIPWatcherShutdownBlob - "
                            "MultiByteToWideChar failed 0xlx", hr));

                RtcFree( szShutdown );

                return hr;
            }

            wszShutdown = (PWSTR)RtcAlloc( (dwWideLength + 1) * sizeof(WCHAR) );

            if ( wszShutdown == NULL )
            {
                LOG((RTC_ERROR, "CRTCWatcher::GetSIPWatcherShutdownBlob - "
                            "out of memory"));

                RtcFree( szShutdown );

                return E_OUTOFMEMORY;
            }

            ZeroMemory( wszShutdown, (dwWideLength + 1) * sizeof(WCHAR) );

            if ( MultiByteToWideChar( CP_ACP, 0, szShutdown, dwLength, wszShutdown, dwWideLength ) == 0 )
            {
                hr = HRESULT_FROM_WIN32(GetLastError());

                LOG((RTC_ERROR, "CRTCWatcher::GetSIPWatcherShutdownBlob - "
                            "MultiByteToWideChar failed 0xlx", hr));

                RtcFree( szShutdown );
                RtcFree( wszShutdown );

                return hr;
            }

            break;
        }
    }

    RtcFree( szShutdown );

    m_szShutdownBlob = wszShutdown;

    LOG((RTC_TRACE, "CRTCWatcher::GetSIPWatcherShutdownBlob - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::SendSIPWatcherShutdownBlob
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCWatcher::SendSIPWatcherShutdownBlob()
{
    LOG((RTC_TRACE, "CRTCWatcher::SendSIPWatcherShutdownBlob - enter"));

    HRESULT hr;
    PSTR    szShutdown = NULL;
    DWORD   dwLength;

    if ( m_szShutdownBlob == NULL )
    {
        LOG((RTC_INFO, "CRTCWatcher::GetSIPWatcherShutdownBlob - "
                            "no shutdown blob"));

        return S_OK;
    }

    dwLength = WideCharToMultiByte( CP_ACP, 0, m_szShutdownBlob, -1, NULL, 0, NULL, NULL);

    if ( dwLength == 0 )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        LOG((RTC_ERROR, "CRTCWatcher::SendSIPWatcherShutdownBlob - "
                    "WideCharToMultiByte failed 0xlx", hr));

        return hr;
    }

    szShutdown = (PSTR)RtcAlloc( dwLength + 1 );

    if ( szShutdown == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::SendSIPWatcherShutdownBlob - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    ZeroMemory( szShutdown, dwLength + 1 );

    if ( WideCharToMultiByte( CP_ACP, 0, m_szShutdownBlob, -1, szShutdown, dwLength, NULL, NULL) == 0 )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        LOG((RTC_ERROR, "CRTCWatcher::SendSIPWatcherShutdownBlob - "
                    "WideCharToMultiByte failed 0xlx", hr));

        RtcFree( szShutdown );

        return hr;
    }

    IRTCProfile * pProfile = NULL;
    RTC_SESSION_TYPE enType = RTCST_PC_TO_PC;

    hr = m_pCClient->GetBestProfile(
            &enType,
            m_szPresentityURI,
            FALSE,
            &pProfile
            );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::SendSIPWatcherShutdownBlob - "
                            "GetBestProfile failed 0x%lx", hr));

        RtcFree( szShutdown );

        return hr;
    }

    if ( pProfile == NULL )
    {
        LOG((RTC_ERROR, "CRTCSession::SendSIPWatcherShutdownBlob - "
                            "no profile found"));

        RtcFree( szShutdown );

        return hr;
    }

    SIP_SERVER_INFO Proxy;            
    CRTCProfile * pCProfile = NULL;

    pCProfile = static_cast<CRTCProfile *>(pProfile);  

    hr = pCProfile->GetSipProxyServerInfo( RTCSI_PC_TO_PC, &Proxy );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::SendSIPWatcherShutdownBlob - "
                            "GetSipProxyServerInfo failed 0x%lx", hr));

        pProfile->Release();
        RtcFree( szShutdown );

        return hr;
    }

    hr = m_pSIPWatcherManager->SendUnsubToWatcher( szShutdown, dwLength, &Proxy );

    pCProfile->FreeSipServerInfo( &Proxy );
    pProfile->Release();

    RtcFree( szShutdown );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::SendSIPWatcherShutdownBlob - "
                    "SendUnsubToWatcher failed 0xlx", hr));

        return hr;
    }

    RtcFree( m_szShutdownBlob );
    m_szShutdownBlob = NULL;

    LOG((RTC_TRACE, "CRTCWatcher::SendSIPWatcherShutdownBlob - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::CreateXMLDOMNode
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCWatcher::CreateXMLDOMNode( IXMLDOMDocument * pXMLDoc, IXMLDOMNode ** ppXDN )
{
    IXMLDOMNode    * pWatcherInfo = NULL;
    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCWatcher::CreateXMLDOMNode - enter"));

    hr = pXMLDoc->createNode( CComVariant(NODE_ELEMENT), CComBSTR(_T("WatcherInfo")), NULL, &pWatcherInfo );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::CreateXMLDOMNode - "
                        "createNode failed 0x%lx", hr));

        return hr;
    }
    
    hr = pWatcherInfo->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::CreateXMLDOMNode - "
                        "QueryInterface failed 0x%lx", hr));

        pWatcherInfo->Release();

        return hr;
    }

    if (m_szPresentityURI != NULL)
    {
        hr = pElement->setAttribute( CComBSTR(_T("Presentity")), CComVariant( m_szPresentityURI ) );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCWatcher::CreateXMLDOMNode - "
                        "setAttribute(Presentity) failed 0x%lx", hr));

            pElement->Release();
            pWatcherInfo->Release();

            return hr;
        }
    }

    if (m_szName != NULL)
    {
        hr = pElement->setAttribute( CComBSTR(_T("Name")), CComVariant( m_szName ) );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCWatcher::CreateXMLDOMNode - "
                        "setAttribute(Name) failed 0x%lx", hr));

            pElement->Release();
            pWatcherInfo->Release();

            return hr;
        }
    }

    if (m_szData != NULL)
    {
        hr = pElement->setAttribute( CComBSTR(_T("Data")), CComVariant( m_szData ) );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCWatcher::CreateXMLDOMNode - "
                        "setAttribute(Data) failed 0x%lx", hr));

            pElement->Release();
            pWatcherInfo->Release();

            return hr;
        }
    }

    if (m_szShutdownBlob != NULL)
    {
        hr = pElement->setAttribute( CComBSTR(_T("ShutdownBlob")), CComVariant( m_szShutdownBlob ) );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCWatcher::CreateXMLDOMNode - "
                        "setAttribute(ShutdownBlob) failed 0x%lx", hr));

            pElement->Release();
            pWatcherInfo->Release();

            return hr;
        }
    }

    pElement->Release();

    *ppXDN = pWatcherInfo;

    LOG((RTC_TRACE, "CRTCWatcher::CreateXMLDOMNode - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::GetClient
//
/////////////////////////////////////////////////////////////////////////////

CRTCClient * 
CRTCWatcher::GetClient()
{
    LOG((RTC_TRACE, "CRTCWatcher::GetClient"));

    return m_pCClient;
} 


/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::get_PresentityURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::get_PresentityURI(
        BSTR * pbstrPresentityURI
        )
{
    LOG((RTC_TRACE, "CRTCWatcher::get_PresentityURI - enter"));

    if ( IsBadWritePtr( pbstrPresentityURI, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_PresentityURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szPresentityURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_PresentityURI - "
                            "watcher has no address"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrPresentityURI = SysAllocString(m_szPresentityURI);

    if ( *pbstrPresentityURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_PresentityURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCWatcher::get_PresentityURI - exit S_OK"));

    return S_OK;
}    

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::put_PresentityURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::put_PresentityURI(
        BSTR bstrPresentityURI
        )
{
    LOG((RTC_TRACE, "CRTCWatcher::put_PresentityURI - enter"));

    HRESULT hr;

    if ( IsBadStringPtrW( bstrPresentityURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::put_PresentityURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    //
    // Clean the presentity URI
    //

    PWSTR szCleanPresentityURI = NULL;

    AllocCleanSipString( bstrPresentityURI, &szCleanPresentityURI );

    if ( szCleanPresentityURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::put_PresentityURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    //
    // Is this different than the existing presentity URI?
    //

    if ( !IsEqualURI( m_szPresentityURI, bstrPresentityURI ) )
    {
        //
        // Don't allow duplicates
        //

        IRTCWatcher *pWatcher = NULL;

        hr = m_pCClient->FindWatcherByURI(
            szCleanPresentityURI,
            FALSE,
            &pWatcher);

        if (hr == S_OK)
        {
            RtcFree( szCleanPresentityURI );
            szCleanPresentityURI = NULL;
        
            LOG((RTC_ERROR, "CRTCWatcher::put_PresentityURI - "
                                    "duplicate watcher"));

            return E_FAIL;
        }

        // 
        // If there's a hidden watcher, we free it.
        //
        // It is not worth reusing it. 
        //
        
        hr = m_pCClient->FindWatcherByURI(
            szCleanPresentityURI,
            TRUE,
            &pWatcher);

        if(hr == S_OK)
        {
            CRTCWatcher * pCWatcher = static_cast<CRTCWatcher *>(pWatcher);

            pCWatcher->RemoveSIPWatchers(FALSE);

            m_pCClient->RemoveHiddenWatcher(pWatcher);

            pWatcher->Release();
            pWatcher = NULL;
        }

        //
        // Release the SIP watchers
        //

        PWSTR szOldPresentityURI = m_szPresentityURI;
      
        m_szPresentityURI = szCleanPresentityURI;
        szCleanPresentityURI = NULL;
        
        hr = RemoveSIPWatchers(FALSE);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCWatcher::put_PresentityURI - RemoveSIPWatchers failed 0x%lx", hr));

            RtcFree(m_szPresentityURI);
            m_szPresentityURI = szOldPresentityURI;

            return hr;
        }

        if ( szOldPresentityURI != NULL )
        {
            RtcFree( szOldPresentityURI );
            szOldPresentityURI = NULL;
        }

        //
        // Update storage
        //

        if ( m_bPersistent )
        {
            m_pCClient->UpdatePresenceStorage();
        }

#ifdef DUMP_PRESENCE
        m_pCClient->DumpWatchers("PUT_PRESENTITYURI");
#endif

    }
    else
    {
        RtcFree( szCleanPresentityURI );
        szCleanPresentityURI = NULL;
    }
        
    LOG((RTC_TRACE, "CRTCWatcher::put_PresentityURI - exit S_OK"));

    return S_OK;
}            

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::get_Name
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::get_Name(
        BSTR * pbstrName
        )
{
    LOG((RTC_TRACE, "CRTCWatcher::get_Name - enter"));

    if ( IsBadWritePtr( pbstrName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_Name - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_Name - "
                            "watcher has no name"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrName = SysAllocString(m_szName);

    if ( *pbstrName == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_Name - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCWatcher::get_Name - exit S_OK"));

    return S_OK;
}    

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::put_Name
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::put_Name(
        BSTR bstrName
        )
{
    LOG((RTC_TRACE, "CRTCWatcher::put_Name - enter"));

    if ( IsBadStringPtrW( bstrName, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::put_Name - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szName != NULL )
    {
        RtcFree( m_szName );
        m_szName = NULL;
    }

    m_szName = RtcAllocString( bstrName );    

    if ( m_szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::put_Name - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    

    //
    // Update storage
    //

    if ( m_bPersistent )
    {
        m_pCClient->UpdatePresenceStorage();
    }
    
    LOG((RTC_TRACE, "CRTCWatcher::put_Name - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::get_Data
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::get_Data(
        BSTR * pbstrData
        )
{
    LOG((RTC_TRACE, "CRTCWatcher::get_Data - enter"));

    if ( IsBadWritePtr( pbstrData, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_Data - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szData == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_Data - "
                            "watcher has no guid string"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrData = SysAllocString(m_szData);

    if ( *pbstrData == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_Data - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCWatcher::get_Data - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::put_Data
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::put_Data(
        BSTR bstrData
        )
{
    LOG((RTC_TRACE, "CRTCWatcher::put_Data - enter"));

    if ( IsBadStringPtrW( bstrData, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::put_Data - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szData != NULL )
    {
        RtcFree( m_szData );
        m_szData = NULL;
    }

    m_szData = RtcAllocString( bstrData );    

    if ( m_szData == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::put_Data - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }  
    
    //
    // Update storage
    //

    if ( m_bPersistent )
    {
        m_pCClient->UpdatePresenceStorage();
    }
    
    LOG((RTC_TRACE, "CRTCWatcher::put_Data - exit S_OK"));

    return S_OK;
}      
    
/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::get_Persistent
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::get_Persistent(
            VARIANT_BOOL * pfPersistent
            )
{
    LOG((RTC_TRACE, "CRTCWatcher::get_Persistent - enter"));

    if ( IsBadWritePtr( pfPersistent, sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::pfPersistent - "
                            "bad pointer"));

        return E_POINTER;
    }

    *pfPersistent = m_bPersistent ? VARIANT_TRUE : VARIANT_FALSE;

    LOG((RTC_TRACE, "CRTCWatcher::get_Persistent - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::put_Persistent
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::put_Persistent(
            VARIANT_BOOL fPersistent
            )
{
    LOG((RTC_TRACE, "CRTCWatcher::put_Persistent - enter"));

    m_bPersistent = fPersistent ? TRUE : FALSE;

    //
    // Update storage
    //

    m_pCClient->UpdatePresenceStorage();

#ifdef DUMP_PRESENCE
    m_pCClient->DumpWatchers("PUT_PERSISTENT");
#endif

    LOG((RTC_TRACE, "CRTCWatcher::put_Persistent - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::get_State
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::get_State(
            RTC_WATCHER_STATE * penState
            )
{
    LOG((RTC_TRACE, "CRTCWatcher::get_State - enter"));

    if ( IsBadWritePtr( penState, sizeof(RTC_WATCHER_STATE) ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_State - "
                            "bad pointer"));

        return E_POINTER;
    }

    *penState = m_nState;

    LOG((RTC_TRACE, "CRTCWatcher::get_State - exit"));

    return S_OK;
}
    
/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::put_State
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::put_State(
            RTC_WATCHER_STATE  enState
            )
{
    HRESULT         hr;

    LOG((RTC_TRACE, "CRTCWatcher::put_State - enter"));

    if(enState != RTCWS_ALLOWED && 
       enState != RTCWS_BLOCKED)
    {
        LOG((RTC_ERROR, "CRTCWatcher::put_State - invalid state"));

        return E_INVALIDARG;
    }

    if(m_nState == RTCWS_OFFERING)
    {
        // Offering state ? Ok, depending on the new state
        // we approve or reject the subscription 
        //

        if(enState == RTCWS_ALLOWED)
        {
            hr = ApproveSubscription(0);

            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "CRTCWatcher::put_State: "
                    "ApproveSubscription failed: x%x.", hr));
            }
        }
        else
        {
            hr = RejectSubscription(REJECT_REASON_NONE);
            
            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "CRTCWatcher::put_State: "
                    "RejectSubscription failed: x%x.", hr));
            }
        }
    }
    else
    {
        if((enState == RTCWS_ALLOWED && m_nState != RTCWS_ALLOWED) ||
            (enState == RTCWS_BLOCKED && m_nState != RTCWS_BLOCKED))
        {
            hr = ChangeBlockedStatus(
                enState == RTCWS_ALLOWED ? WATCHER_UNBLOCKED : WATCHER_BLOCKED
                );

            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "CRTCWatcher::put_State: "
                    "ChangeBlockedStatus failed: x%x.", hr));
            }
        }
    }


    //
    // Change the local state
    //

    m_nState = enState;

    //
    // Update storage
    //

    if ( m_bPersistent )
    {
        m_pCClient->UpdatePresenceStorage();
    }

#ifdef DUMP_PRESENCE
    m_pCClient->DumpWatchers("PUT_STATE");
#endif

    LOG((RTC_TRACE, "CRTCWatcher::put_State - exit"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcsession.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCSession.h

Abstract:

    Definition of the CRTCSession class

--*/

#ifndef __RTCSESSION__
#define __RTCSESSION__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CRTCSession

class ATL_NO_VTABLE CRTCSession : 
#ifdef TEST_IDISPATCH
    public IDispatchImpl<IRTCSession, &IID_IRTCSession, &LIBID_RTCCORELib>, 
#else
    public IRTCSession,
#endif
    public IRTCSessionPortManagement,
    public ISipCallNotify,
	public CComObjectRoot
{
public:
    CRTCSession() : m_pCClient(NULL),
                    m_pCall(NULL),
                    m_pStack(NULL),
                    m_pIMManager(NULL),
                    m_pIMSession(NULL),
                    m_enState(RTCSS_IDLE),
                    m_szLocalName(NULL),
                    m_szLocalUserURI(NULL),
                    m_szLocalPhoneURI(NULL),
                    m_szRemoteUserName(NULL),
                    m_szRemoteUserURI(NULL),
                    m_szRedirectProxy(NULL),
                    m_pProfile(NULL),
                    m_pSipRedirectContext(NULL),
                    m_lFlags(0)
    {}
BEGIN_COM_MAP(CRTCSession)
#ifdef TEST_IDISPATCH
    COM_INTERFACE_ENTRY(IDispatch)
#endif
    COM_INTERFACE_ENTRY(IRTCSession)
    COM_INTERFACE_ENTRY(IRTCSessionPortManagement)
    COM_INTERFACE_ENTRY(ISipCallNotify)
END_COM_MAP()

    HRESULT FinalConstruct();

    void FinalRelease();

    STDMETHOD_(ULONG, InternalAddRef)();

    STDMETHOD_(ULONG, InternalRelease)(); 
    
    CRTCClient * GetClient();

    HRESULT InitializeOutgoing(
            CRTCClient        * pCClient,
            IRTCProfile       * pProfile,
            ISipStack         * pStack,
            RTC_SESSION_TYPE    enType,
            PCWSTR              szLocalName,
            PCWSTR              szLocalUserURI,
            PCWSTR              szLocalPhoneURI,
            long                lFlags
            );

    HRESULT InitializeIncoming(
            CRTCClient        * pCClient,
            ISipCall          * pCall,
            SIP_PARTY_INFO    * pCallerInfo
            );

    HRESULT InitializeIncomingIM(
            CRTCClient        * pCClient,
            ISipStack         * pStack,
            IIMSession        * pSession,
            BSTR                msg,
            BSTR                ContentType,
            SIP_PARTY_INFO    * pCallerInfo
            );

    HRESULT SetState(
            RTC_SESSION_STATE enState,
            long lStatusCode,
            PCWSTR szStatusText
            );

private:

    CRTCClient                        * m_pCClient;
    ISipCall                          * m_pCall; 
    ISipStack                         * m_pStack;
    IIMManager                        * m_pIMManager;
    IIMSession                        * m_pIMSession;
    IRTCProfile                       * m_pProfile;
    RTC_SESSION_STATE                   m_enState;
    RTC_SESSION_TYPE                    m_enType;
    PWSTR                               m_szLocalName;
    PWSTR                               m_szLocalUserURI;
    PWSTR                               m_szLocalPhoneURI;
    PWSTR                               m_szRemoteUserName;
    PWSTR                               m_szRemoteUserURI;
    PWSTR                               m_szRedirectProxy;
    ISipRedirectContext               * m_pSipRedirectContext;
    long                                m_lFlags;
    
    CRTCObjectArray<IRTCParticipant *>  m_ParticipantArray;

#if DBG
    PWSTR                               m_pDebug;
#endif

    HRESULT InternalCreateParticipant(
        IRTCParticipant ** ppParticipant
        );

    HRESULT CreateSipSession(
            PCWSTR              szDestUserURI
            );

    HRESULT InitializeLocalPhoneParticipant();
    
// IRTCSession
public:
    STDMETHOD(get_Client)(
            IRTCClient ** ppClient
            );
                        
    STDMETHOD(Answer)(); 

    STDMETHOD(Terminate)(
            RTC_TERMINATE_REASON enReason
            );  

    STDMETHOD(Redirect)(
            RTC_SESSION_TYPE enType,
            BSTR bstrLocalPhoneURI,
            IRTCProfile * pProfile,
            long     lFlags
            );  

    STDMETHOD(get_State)(
            RTC_SESSION_STATE * penState
            ); 
    
    STDMETHOD(get_Type)(
            RTC_SESSION_TYPE * penType
            );

    STDMETHOD(get_Profile)(
            IRTCProfile ** ppProfile
            );

    STDMETHOD(AddParticipant)(
            BSTR bstrUserURI,
            BSTR bstrName,
            IRTCParticipant ** ppParticipant
            );  

    STDMETHOD(RemoveParticipant)(
            IRTCParticipant * pParticipant
            );      

    STDMETHOD(EnumerateParticipants)(
            IRTCEnumParticipants ** ppEnum
            ); 

    STDMETHOD(get_Participants)(
            IRTCCollection ** ppCollection
            );

    STDMETHOD(get_CanAddParticipants)(
            VARIANT_BOOL * pfCanAdd
            );  
    
    STDMETHOD(get_RedirectedUserURI)(
                           BSTR * pbstrUserURI
                          );

    STDMETHOD(get_RedirectedUserName)(
                           BSTR * pbstrUserName
                          );

    STDMETHOD(NextRedirectedUser)();
    
    STDMETHOD(SendMessage)(
            BSTR bstrMessageHeader,
            BSTR bstrMessage,
            long lCookie
            );

    STDMETHOD(SendMessageStatus)(
            RTC_MESSAGING_USER_STATUS enUserStatus,
            long lCookie
            );

    STDMETHOD(AddStream)(
            long lMediaType,
            long lCookie
            );

    STDMETHOD(RemoveStream)(
            long lMediaType,
            long lCookie
            );

    STDMETHOD(put_EncryptionKey)(
            long lMediaType,
            BSTR EncryptionKey
            );

// ISipCallNotify
    STDMETHOD(NotifyCallChange)(
            SIP_CALL_STATUS * CallStatus
            );

    STDMETHOD(NotifyStartOrStopStreamCompletion)(
            long                   lCookie,
            SIP_STATUS_BLOB       *pStatus
            );
    
    STDMETHOD(NotifyPartyChange)(
            SIP_PARTY_INFO * PartyInfo
            );

    STDMETHOD(NotifyRedirect)(
            ISipRedirectContext *pSipRedirectContext,
            SIP_CALL_STATUS * pCallStatus
            );

    STDMETHOD(NotifyMessageRedirect)(
            ISipRedirectContext    *pRedirectContext,
            SIP_CALL_STATUS        *pCallStatus,
            BSTR                   bstrMsg,
            BSTR                   bstrContentType,
            USR_STATUS             UsrStatus,
            long                   lCookie
            );

    STDMETHOD(NotifyIncomingMessage)(
		    IIMSession *pSession,
		    BSTR msg,
            BSTR ContentType,
		    SIP_PARTY_INFO * CallerInfo
		    );

    STDMETHOD(NotifyUsrStatus)(
            USR_STATUS  UsrStatus,
            SIP_PARTY_INFO * CallerInfo
            );

    STDMETHOD(NotifyMessageCompletion)(
            SIP_STATUS_BLOB *      pStatus,
            long                   lCookie
            );

// IRTCSessionPortManagement
    STDMETHOD(SetPortManager)(
            IRTCPortManager * pPortManager
            );
};

#endif //__RTCSESSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcwatcher.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCWatcher.h

Abstract:

    Definition of the CRTCWatcher class

--*/

#pragma once


/////////////////////////////////////////////////////////////////////////////
// CRTCParticipant

class ATL_NO_VTABLE CRTCWatcher :
#ifdef TEST_IDISPATCH
    public IDispatchImpl<IRTCWatcher, &IID_IRTCWatcher, &LIBID_RTCCORELib>, 
#else
    public IRTCWatcher,
#endif
	public CComObjectRoot
{

friend CRTCClient;

public:
    CRTCWatcher() : m_pCClient(NULL),
                    m_pSIPWatcherManager(NULL),
                    m_szPresentityURI(NULL),
                    m_szName(NULL),
                    m_szData(NULL),
                    m_bPersistent(FALSE),
                    m_nState(RTCWS_UNKNOWN),
                    m_bIsNested(FALSE),
                    m_szShutdownBlob(NULL)

    {}
BEGIN_COM_MAP(CRTCWatcher)
#ifdef TEST_IDISPATCH
    COM_INTERFACE_ENTRY(IDispatch)
#endif
    COM_INTERFACE_ENTRY(IRTCWatcher)
    COM_INTERFACE_ENTRY(IRTCPresenceContact)
END_COM_MAP()

    HRESULT FinalConstruct();

    void FinalRelease();

    STDMETHOD_(ULONG, InternalAddRef)();

    STDMETHOD_(ULONG, InternalRelease)(); 

    CRTCClient * GetClient();

    void    ReleaseAll();

    HRESULT Initialize(
                      CRTCClient         * pCClient,
                      ISIPWatcherManager * pSIPWatcherManager,
                      PCWSTR               szPresentityURI,
                      PCWSTR               szName,
                      PCWSTR               szData,
                      PCWSTR               szShutdownBlob,
                      BOOL                 bPersistent
                      );

    HRESULT SetSIPWatcher(
        ISIPWatcher * pSIPWatcher
        );

    HRESULT RemoveSIPWatcher(
        ISIPWatcher * pSIPWatcher,
        BOOL          bShutdown);
    
    HRESULT RemoveSIPWatcher(
        int           iIndex,
        BOOL          bShutdown);

    HRESULT GetSIPWatcherShutdownBlob();

    HRESULT SendSIPWatcherShutdownBlob();
    
    HRESULT CreateXMLDOMNode( IXMLDOMDocument * pXMLDoc, IXMLDOMNode ** ppXDN );

    HRESULT ChangeBlockedStatus(
        WATCHER_BLOCKED_STATUS Status);

    HRESULT ApproveSubscription(
        DWORD dwPresenceInfoRules 
        );

    HRESULT RejectSubscription(
        WATCHER_REJECT_REASON ulReason
        );

    HRESULT RemoveSIPWatchers(
        BOOL          bShutdown);

    void    PostSIPWatchersCleanUp(void);
       
private:

    CRTCClient            * m_pCClient;
    ISIPWatcherManager    * m_pSIPWatcherManager;
    PWSTR                   m_szPresentityURI;
    PWSTR                   m_szName;
    PWSTR                   m_szData;
    PWSTR                   m_szShutdownBlob;
    BOOL                    m_bPersistent;
    CRTCObjectArray<ISIPWatcher *>
                            m_SIPWatchers;
    RTC_WATCHER_STATE       m_nState;
    BOOL                    m_bIsNested;      

 
#if DBG
    PWSTR                   m_pDebug;
#endif

// IRTCWatcher
public:

    STDMETHOD(get_PresentityURI)(
            BSTR * pbstrPresentityURI
            );   

    STDMETHOD(put_PresentityURI)(
            BSTR bstrPresentityURI
            ); 

    STDMETHOD(get_Name)(
            BSTR * pbstrName
            );

    STDMETHOD(put_Name)(
            BSTR bstrName
            );

    STDMETHOD(get_Data)(
            BSTR * pbstrData
            );

    STDMETHOD(put_Data)(
            BSTR bstrData
            );

    STDMETHOD(get_Persistent)(
            VARIANT_BOOL *pfPersistent
            );                 
	
    STDMETHOD(put_Persistent)(
            VARIANT_BOOL fPersistent
            );                 

    STDMETHOD(get_State)(
            RTC_WATCHER_STATE * penState
            );                
    
    STDMETHOD(put_State)(
            RTC_WATCHER_STATE  enState
            );                
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcsession.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCSession.cpp

Abstract:

    Implementation of the CRTCSession class

--*/

#include "stdafx.h"

#define     SIP_NAMESPACE_PREFIX    L"sip:"
#define     TEL_NAMESPACE_PREFIX    L"tel:"

#define     PREFIX_LENGTH           4

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::InitializeOutgoing
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSession::InitializeOutgoing(
            CRTCClient        * pCClient,
            IRTCProfile       * pProfile,
            ISipStack         * pStack,
            RTC_SESSION_TYPE    enType,
            PCWSTR              szLocalName,
            PCWSTR              szLocalUserURI,
            PCWSTR              szLocalPhoneURI,
            long                lFlags
            )
{
    LOG((RTC_TRACE, "CRTCSession::InitializeOutgoing - enter"));

    HRESULT     hr;

    m_szLocalName = RtcAllocString(szLocalName);

    if ( m_szLocalName == NULL )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeOutgoing - "
                            "out of memory"));
        
        return E_OUTOFMEMORY;
    }

    m_szLocalUserURI = RtcAllocString(szLocalUserURI);

    if ( m_szLocalUserURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeOutgoing - "
                            "out of memory"));
        
        return E_OUTOFMEMORY;
    }

    hr = AllocCleanTelString( szLocalPhoneURI, &m_szLocalPhoneURI);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeOutgoing - "
                            "AllocCleanTelString failed 0x%lx", hr));
        
        return hr;
    }   

    m_pCClient = pCClient;
    if (m_pCClient != NULL)
    {
        m_pCClient->AddRef();    
    }

    m_pProfile = pProfile;
    if (m_pProfile != NULL)
    {
        m_pProfile->AddRef();
    }

    m_pStack = pStack;
    if (m_pStack != NULL)
    {
        m_pStack->AddRef();
    }

    m_enType = enType;
    m_lFlags = lFlags;

    if ( enType == RTCST_PHONE_TO_PHONE )
    {
        hr = InitializeLocalPhoneParticipant();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::InitializeOutgoing - "
                            "InitializeLocalPhoneParticipant failed 0x%lx", hr));
        
            return hr;
        }
    }

    if ( enType == RTCST_IM )
    {
        hr = m_pStack->QueryInterface( IID_IIMManager, (void**)&m_pIMManager );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::InitializeOutgoing - "
                                "QI IIMManager failed 0x%lx", hr));         

            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCSession::InitializeOutgoing - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::CreateSipSession
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSession::CreateSipSession(
            PCWSTR              szDestUserURI
            )
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCSession::CreateSipSession - enter"));

    //
    // Choose the best profile if needed
    //

    if ( !(m_lFlags & RTCCS_FORCE_PROFILE) )
    {
        IRTCProfile * pProfile;

        hr = m_pCClient->GetBestProfile(
                &m_enType,
                szDestUserURI,
                (m_pSipRedirectContext != NULL),
                &pProfile
                );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "GetBestProfile failed 0x%lx", hr));

            return hr;
        }

        if ( m_pProfile != NULL )
        {
            m_pProfile->Release();
            m_pProfile = NULL;
        }

        m_pProfile = pProfile;
    }

    LOG((RTC_INFO, "CRTCSession::CreateSipSession - "
                                "profile [%p]", m_pProfile));

    //
    // Check session type 
    //

    SIP_CALL_TYPE sct;
    LONG lSessionType;

    switch (m_enType)
    {
        case RTCST_PC_TO_PC:
        {
            LOG((RTC_INFO, "CRTCSession::CreateSipSession - "
                    "RTCST_PC_TO_PC"));

            sct = SIP_CALL_TYPE_RTP;
            lSessionType = RTCSI_PC_TO_PC;

            break;
        }

        case RTCST_PC_TO_PHONE:
        {
            LOG((RTC_INFO, "CRTCSession::CreateSipSession - "
                    "RTCST_PC_TO_PHONE"));

            sct = SIP_CALL_TYPE_RTP;
            lSessionType = RTCSI_PC_TO_PHONE;

            break;
        }

        case RTCST_PHONE_TO_PHONE:
        {
            LOG((RTC_INFO, "CRTCSession::CreateSipSession - "
                    "RTCST_PHONE_TO_PHONE"));

            sct = SIP_CALL_TYPE_PINT;
            lSessionType = RTCSI_PHONE_TO_PHONE;

            if ( m_szLocalPhoneURI == NULL )
            {
                LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                    "PHONE_TO_PHONE sessions need a local phone URI"));
            
                return RTC_E_LOCAL_PHONE_NEEDED;
            }

            break;
        }

        case RTCST_IM:
        {
            LOG((RTC_INFO, "CRTCSession::CreateSipSession - "
                    "RTCST_IM"));
            
            sct = SIP_CALL_TYPE_MESSAGE;
            lSessionType = RTCSI_IM;

            break;
        }

        default:
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                            "invalid session type"));
        
            return RTC_E_INVALID_SESSION_TYPE;
        }
    }

    //
    // Get profile info
    //

    SIP_PROVIDER_ID ProviderID = GUID_NULL;
    SIP_SERVER_INFO Proxy;        
    long lSupportedSessions = RTCSI_PC_TO_PC | RTCSI_IM;
    CRTCProfile * pCProfile = NULL;

    if ( m_pProfile != NULL )
    {
        //
        // Get pointer to profile object
        //

        pCProfile = static_cast<CRTCProfile *>(m_pProfile);

        //
        // Get the SIP provider ID from the profile. If the profile is NULL
        // then this call has no provider. In that case we just use GUID_NULL.
        //

        pCProfile->GetGuid( &ProviderID ); 

        //
        // Determine supported session types for this profile
        //

        hr = m_pProfile->get_SessionCapabilities( &lSupportedSessions );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "get_SessionCapabilities failed 0x%lx", hr));
            
            return hr;
        }   
        
        //
        // Get the user name from the profile
        //
        
        BSTR bstrProfileUserName = NULL;

        hr = m_pProfile->get_UserName( &bstrProfileUserName );

        if ( FAILED(hr) )
        {
            LOG((RTC_WARN, "CRTCClient::CreateSession - "
                                "get_UserName failed 0x%lx", hr));
        }
        else
        {
            if ( m_szLocalName != NULL )
            {
                RtcFree( m_szLocalName );
                m_szLocalName = NULL;
            }

            m_szLocalName = RtcAllocString( bstrProfileUserName );

            SysFreeString( bstrProfileUserName );
            bstrProfileUserName = NULL;

            if ( m_szLocalName == NULL )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                                "out of memory"));

                return E_OUTOFMEMORY;
            }                
        }

        //
        // Get the user URI from the profile
        //
        
        BSTR bstrProfileUserURI = NULL;

        hr = m_pProfile->get_UserURI( &bstrProfileUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_WARN, "CRTCClient::CreateSession - "
                                "get_UserURI failed 0x%lx", hr));
        }
        else
        {
            if ( m_szLocalUserURI != NULL )
            {
                RtcFree( m_szLocalUserURI );
                m_szLocalUserURI = NULL;
            }

            m_szLocalUserURI = RtcAllocString( bstrProfileUserURI );

            SysFreeString( bstrProfileUserURI );
            bstrProfileUserURI = NULL;

            if ( m_szLocalUserURI == NULL )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                                "out of memory"));

                return E_OUTOFMEMORY;
            }                
        }
    }

    //
    // Validate session type
    //

    if ( !(lSessionType & lSupportedSessions) )
    {
        LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                            "session type is not supported by this profile"));

        return RTC_E_INVALID_SESSION_TYPE;
    }

    //
    // Get SIP proxy info
    //

    if ( pCProfile != NULL )
    {
        hr = pCProfile->GetSipProxyServerInfo( lSessionType, &Proxy );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "GetSipProxyServerInfo failed 0x%lx", hr));

            return hr;
        } 
    }

    if ( m_szRedirectProxy != NULL )
    {
        //
        // We need to redirect to a different proxy
        //

        if ( Proxy.ServerAddress != NULL )
        {
            RtcFree( Proxy.ServerAddress );
        }

        Proxy.ServerAddress = m_szRedirectProxy;
        m_szRedirectProxy = NULL;

        Proxy.IsServerAddressSIPURI = TRUE;
        Proxy.AuthProtocol = SIP_AUTH_PROTOCOL_NONE;
        Proxy.TransportProtocol = SIP_TRANSPORT_UNKNOWN;
        
        ProviderID = GUID_NULL;
    }

    //
    // Create the SIP session
    //

    if ( m_enType == RTCST_IM )
    {
        BSTR bstrLocalName = SysAllocString(m_szLocalName);
        BSTR bstrLocalUserURI = SysAllocString(m_szLocalUserURI);

        hr = m_pIMManager->CreateSession(
                                       bstrLocalName,
                                       bstrLocalUserURI,
                                       &ProviderID,
                                       (pCProfile != NULL) ? &Proxy : NULL,
                                       m_pSipRedirectContext,
                                       &m_pIMSession
                                      );

        if (bstrLocalName != NULL)
        {
            SysFreeString(bstrLocalName);
            bstrLocalName = NULL;
        }

        if (bstrLocalUserURI != NULL)
        {
            SysFreeString(bstrLocalUserURI);
            bstrLocalUserURI = NULL;
        }

        if (pCProfile != NULL)
        {
            pCProfile->FreeSipServerInfo( &Proxy );
        }

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "CreateSession failed 0x%lx", hr));
        
            return hr;
        }

        hr = m_pIMSession->SetNotifyInterface(this);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "SetNotifyInterface failed 0x%lx", hr));
        
            return hr;
        }
    }
    else 
    {
        //
        // This is a RTP or PINT session
        //

        hr = m_pStack->CreateCall(
                                     &ProviderID,
                                     (pCProfile != NULL) ? &Proxy : NULL,
                                     sct,
                                     m_pSipRedirectContext,
                                     &m_pCall
                                    ); 

        if (pCProfile != NULL)
        {
            pCProfile->FreeSipServerInfo( &Proxy );
        }

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "CreateCall failed 0x%lx", hr));
        
            return hr;
        }

        hr = m_pCall->SetNotifyInterface(this);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "SetNotifyInterface failed 0x%lx", hr));
        
            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCSession::CreateSipSession - exit S_OK"));

    return S_OK;
}   

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::InitializeLocalPhoneParticipant
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSession::InitializeLocalPhoneParticipant()
{
    LOG((RTC_TRACE, "CRTCSession::InitializeLocalPhoneParticipant - enter"));

    HRESULT hr;

    //
    // Add a participant for ourselves in a phone-to-phone call
    //

    //
    // Create the participant
    //

    IRTCParticipant * pParticipant = NULL;

    hr = InternalCreateParticipant( &pParticipant );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeLocalPhoneParticipant - "
                            "failed to create participant 0x%lx", hr));
    
        return hr;
    }

    //
    // Initialize the participant
    //

    CRTCParticipant * pCParticipant = NULL;

    pCParticipant = static_cast<CRTCParticipant *>(pParticipant);

    hr = pCParticipant->Initialize( m_pCClient, 
                                    this,
                                    m_szLocalPhoneURI,
                                    m_szLocalName
                                   );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeLocalPhoneParticipant - "
                            "Initialize failed 0x%lx", hr));

        pParticipant->Release();
    
        return hr;
    }  

    //
    // Add the participant to the array
    //

    BOOL fResult;

    fResult = m_ParticipantArray.Add(pParticipant);

    pParticipant->Release();

    if ( fResult == FALSE )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeLocalPhoneParticipant - "
                            "out of memory"));
    
        return E_OUTOFMEMORY;
    }                

    LOG((RTC_TRACE, "CRTCSession::InitializeLocalPhoneParticipant - exit S_OK"));

    return S_OK;
}
                                            

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::InitializeIncoming
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSession::InitializeIncoming(        
        CRTCClient        * pCClient,
        ISipCall          * pCall,  
        SIP_PARTY_INFO    * pCallerInfo
        )
{
    LOG((RTC_TRACE, "CRTCSession::InitializeIncoming - enter"));
  
    HRESULT hr;

    m_pCall = pCall;
    if (m_pCall != NULL)
    {
        m_pCall->AddRef();
    }

    m_pCClient = pCClient;
    if (m_pCClient != NULL)
    {
        m_pCClient->AddRef(); 
    }

    m_enType = RTCST_PC_TO_PC;

    hr = m_pCall->SetNotifyInterface(this);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncoming - "
                            "failed to set notify interface 0x%lx", hr));
        
        return hr;
    }

    //
    // Create the participant
    //

    IRTCParticipant * pParticipant = NULL;

    hr = InternalCreateParticipant( &pParticipant );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncoming - "
                            "failed to create participant 0x%lx", hr));
        
        return hr;
    }

    //
    // Initialize the participant
    //

    CRTCParticipant * pCParticipant = NULL;

    pCParticipant = static_cast<CRTCParticipant *>(pParticipant);
    
    hr = pCParticipant->Initialize( m_pCClient,  
                                    this,
                                    pCallerInfo->URI,
                                    pCallerInfo->DisplayName
                                   );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncoming - "
                            "Initialize failed 0x%lx", hr));

        pParticipant->Release();
        
        return hr;
    }  

    //
    // Add the participant to the array
    //

    BOOL fResult;

    fResult = m_ParticipantArray.Add(pParticipant);

    if ( fResult == FALSE )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncoming - "
                            "out of memory"));

        pParticipant->Release();
        
        return E_OUTOFMEMORY;
    }    

    //
    // Set the session state
    //

    SetState( RTCSS_INCOMING, 0, NULL );

    //
    // Release the participant pointer
    //
    
    pParticipant->Release();
   
    LOG((RTC_TRACE, "CRTCSession::InitializeIncoming - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::InitializeIncomingIM
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSession::InitializeIncomingIM(
            CRTCClient        * pCClient,
            ISipStack         * pStack,
            IIMSession        * pSession,
            BSTR                msg,
            BSTR                ContentType,
            SIP_PARTY_INFO    * pCallerInfo
            )
{
    LOG((RTC_TRACE, "CRTCSession::InitializeIncomingIM - enter"));
  
    HRESULT hr;

    hr = pStack->QueryInterface( IID_IIMManager, (void**)&m_pIMManager );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncomingIM - "
                            "QI IIMManager failed 0x%lx", hr));

        return hr;
    }

    m_pIMSession = pSession;
    if (m_pIMSession != NULL)
    {
        m_pIMSession->AddRef();
    }

    m_pCClient = pCClient;
    if (m_pCClient != NULL)
    {
        m_pCClient->AddRef(); 
    }

    m_enType = RTCST_IM;

    hr = m_pIMSession->SetNotifyInterface(this);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncomingIM - "
                            "SetNotifyInterface failed 0x%lx", hr));
        
        return hr;
    }

    //
    // Create the participant
    //

    IRTCParticipant * pParticipant = NULL;

    hr = InternalCreateParticipant( &pParticipant );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncomingIM - "
                            "failed to create participant 0x%lx", hr));
        
        return hr;
    }

    //
    // Initialize the participant
    //

    CRTCParticipant * pCParticipant = NULL;

    pCParticipant = static_cast<CRTCParticipant *>(pParticipant);
    
    hr = pCParticipant->Initialize( m_pCClient, 
                                    this,
                                    pCallerInfo->URI,
                                    pCallerInfo->DisplayName
                                   );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncomingIM - "
                            "Initialize failed 0x%lx", hr));

        pParticipant->Release();
        
        return hr;
    }  

    //
    // Add the participant to the array
    //

    BOOL fResult;

    fResult = m_ParticipantArray.Add(pParticipant);

    if ( fResult == FALSE )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncomingIM - "
                            "out of memory"));

        pParticipant->Release();
        
        return E_OUTOFMEMORY;
    }    

    //
    // Set the session state
    //

    SetState( RTCSS_INCOMING, 0, NULL );

    SetState( RTCSS_CONNECTED, 0, NULL );

    //
    // Fire a message event
    //

    CRTCMessagingEvent::FireEvent(this, pParticipant, msg, ContentType, RTCMSET_MESSAGE, RTCMUS_IDLE);

    //
    // Release the participant pointer
    //
    
    pParticipant->Release();
   
    LOG((RTC_TRACE, "CRTCSession::InitializeIncomingIM - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::FinalConstruct
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCSession::FinalConstruct()
{
    LOG((RTC_TRACE, "CRTCSession::FinalConstruct [%p] - enter", this));

#if DBG
    m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)m_pDebug) = this;
#endif

    LOG((RTC_TRACE, "CRTCSession::FinalConstruct [%p] - exit S_OK", this));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCSession::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCSession::FinalRelease [%p] - enter", this));

    m_ParticipantArray.Shutdown();

    if ( m_pCall != NULL )
    {
        m_pCall->SetNotifyInterface(NULL);

        m_pCall->Release();
        m_pCall = NULL;
    }

    if ( m_pIMSession != NULL )
    {
        m_pIMSession->SetNotifyInterface(NULL);

        m_pIMSession->Release();
        m_pIMSession = NULL;
    }

    if ( m_pIMManager != NULL )
    {
        m_pIMManager->Release();
        m_pIMManager = NULL;
    }
    
    if ( m_pStack != NULL )
    {
        m_pStack->Release();
        m_pStack = NULL;
    }

    if ( m_pProfile != NULL )
    {
        m_pProfile->Release();
        m_pProfile = NULL;
    }

    if ( m_pCClient != NULL )
    {
        m_pCClient->Release();
        m_pCClient = NULL;
    }

    if ( m_szLocalName != NULL )
    {
        RtcFree(m_szLocalName);
        m_szLocalName = NULL;
    }

    if ( m_szLocalUserURI != NULL )
    {
        RtcFree(m_szLocalUserURI);
        m_szLocalUserURI = NULL;
    }

    if ( m_szLocalPhoneURI != NULL )
    {
        RtcFree(m_szLocalPhoneURI);
        m_szLocalPhoneURI = NULL;
    }

    if ( m_szRemoteUserName != NULL )
    {
        RtcFree(m_szRemoteUserName);
        m_szRemoteUserName = NULL;
    }

    if ( m_szRemoteUserURI != NULL )
    {
        RtcFree(m_szRemoteUserURI);
        m_szRemoteUserURI = NULL;
    }

    if ( m_pSipRedirectContext != NULL )
    {
        m_pSipRedirectContext->Release();
        m_pSipRedirectContext = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCSession::FinalRelease [%p] - exit", this));
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::InternalAddRef
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCSession::InternalAddRef()
{
    DWORD dwR;

    dwR = InterlockedIncrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCSession::InternalAddRef [%p] - dwR %d", this, dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::InternalRelease
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCSession::InternalRelease()
{
    DWORD               dwR;
    
    dwR = InterlockedDecrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCSession::InternalRelease [%p] - dwR %d", this, dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::GetClient
//
/////////////////////////////////////////////////////////////////////////////

CRTCClient * 
CRTCSession::GetClient()
{
    LOG((RTC_TRACE, "CRTCSession::GetClient"));

    return m_pCClient;
} 

/////////////////////////////////////////////////////////////////////////////
//
//  getPSfromSS  helper function for CRTCSession::SetState
//               map a  RTC_SESSION_STATE to a RTC_PARTICIPANT_STATE
//
/////////////////////////////////////////////////////////////////////////////
HRESULT getPSfromSS(RTC_SESSION_STATE ss, RTC_PARTICIPANT_STATE * p_ps)
{
    struct SessionState_ParticipantState_Map
    {
        RTC_SESSION_STATE ss;
        RTC_PARTICIPANT_STATE ps;
    } sessionParticipantMaps[]=
    {
        {RTCSS_IDLE	,RTCPS_IDLE},
        {RTCSS_INCOMING	,RTCPS_INCOMING},
        {RTCSS_ANSWERING	,RTCPS_ANSWERING},
        {RTCSS_INPROGRESS,RTCPS_INPROGRESS},
        {RTCSS_CONNECTED	,RTCPS_CONNECTED},
        {RTCSS_DISCONNECTED,RTCPS_DISCONNECTED}
    };
    
    int n=sizeof(sessionParticipantMaps)/sizeof(SessionState_ParticipantState_Map);
    for(int i=0;i<n;i++)
    {
        if(sessionParticipantMaps[i].ss == ss )
        {
            *p_ps = sessionParticipantMaps[i].ps;
            return S_OK;
        }
    }
    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::SetState
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSession::SetState(
                      RTC_SESSION_STATE enState,
                      long lStatusCode,
                      PCWSTR szStatusText
                     )
{
    LOG((RTC_TRACE, "CRTCSession::SetState - enter"));

    HRESULT hr = S_OK;
    BOOL    fFireEvent = FALSE;
    BOOL    fNewState = FALSE;

    //
    // We only need to do something if this is a new state
    //
    
    if (m_enState != enState)
    {
        LOG((RTC_INFO, "CRTCSession::SetState - new state"));

        fFireEvent = TRUE;
        fNewState = TRUE;
        m_enState = enState;
    }
    else
    {
        //
        // We are already in this state. Only fire an event if we have a useful status
        // code to report.
        //

        if ( (lStatusCode != 0) || (szStatusText != NULL) )
        {
            fFireEvent = TRUE;
        }
    }

    if ( szStatusText != NULL )
    {
        LOG((RTC_INFO, "CRTCSession::SetState - "
                "state [%d] status [%d] text[%ws]", enState, lStatusCode, szStatusText));
    }
    else
    {
        LOG((RTC_INFO, "CRTCSession::SetState - "
                "state [%d] status [%d]", enState, lStatusCode));
    }

    if ( fFireEvent )
    {
        if ( m_enState != RTCSS_DISCONNECTED )
        {
            //
            // Fire a state change event. Since this is not a disconnected event, we want
            // to fire it before any related participant events.
            //
    
            CRTCSessionStateChangeEvent::FireEvent(this, m_enState, lStatusCode, szStatusText);
        }

        if ( fNewState && ((m_enState == RTCSS_DISCONNECTED) || (m_enType != RTCST_PHONE_TO_PHONE)) )
        {
            //
            // Propagate session state to all participants
            //

            RTC_PARTICIPANT_STATE psState;

            hr = getPSfromSS(m_enState, &psState);

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::SetState - "
                    "Participant->getPSfromSS failed 0x%lx, m_enState=%d", hr, m_enState));
            }
            else
            {
                for (int n = 0; n < m_ParticipantArray.GetSize(); n++)
                {
                    CRTCParticipant * pCParticipant;
                    RTC_PARTICIPANT_STATE state;

                    pCParticipant = static_cast<CRTCParticipant *>(m_ParticipantArray[n]);
                
                    hr = pCParticipant->get_State(&state);

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CRTCSession::SetState - "
                                            "Participant->get_State failed 0x%lx", hr));

                        continue;
                    }
                
                    if ( state != psState )
                    {
                        hr = pCParticipant->SetState( psState, 0 );

                        if ( FAILED(hr) )
                        {
                            LOG((RTC_ERROR, "CRTCSession::SetState - "
                                                "Participant->SetState failed 0x%lx", hr));

                            continue;
                        }
                    }
                }
            }
        }

        if ( m_enState == RTCSS_DISCONNECTED )
        {
            m_ParticipantArray.Shutdown();

            //
            // Fire a state change event. Since this is a disconnected event, we want
            // to fire it after any related participant events.
            //
    
            CRTCSessionStateChangeEvent::FireEvent(this, m_enState, lStatusCode, szStatusText);
        }
    }

    //
    // Don't access any member variables after FireEvent. If the state was
    // changing to disconnected this object could be released.
    //

    LOG((RTC_TRACE, "CRTCSession::SetState - exit 0x%lx", hr));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::get_Client
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::get_Client(
                        IRTCClient ** ppClient
                       )
{
    LOG((RTC_TRACE, "CRTCSession::get_Client - enter"));

    if ( IsBadWritePtr(ppClient , sizeof(IRTCClient *) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_Client - bad pointer"));

        return E_POINTER;
    }

    HRESULT hr;

    hr = m_pCClient->QueryInterface( 
                           IID_IRTCClient,
                           (void **)ppClient
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_Client - "
                            "QI failed 0x%lx", hr));

        return hr;
    }
   
    LOG((RTC_TRACE, "CRTCSession::get_Client - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::Answer
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::Answer()
{
    LOG((RTC_TRACE, "CRTCSession::Answer - enter"));

    HRESULT hr;
    
    //
    // Check that this session is RTCSS_INCOMING
    //

    if ( m_enState != RTCSS_INCOMING )
    {
        LOG((RTC_ERROR, "CRTCSession::Answer - "
                            "session is not incoming"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    SetState( RTCSS_ANSWERING, 0, NULL );

    if ( m_enType == RTCST_IM )
    {
        hr = m_pIMSession->AcceptSession();
    }
    else
    {
        hr = m_pCall->Accept();
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::Answer - "
                            "Accept failed 0x%lx", hr));

        SetState( RTCSS_DISCONNECTED, 0, NULL );

        //
        // Don't access any member variables after the state is
        // set to disconnected. This object could be released.
        //
        
        return hr;
    }  

    LOG((RTC_TRACE, "CRTCSession::Answer - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::Terminate
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::Terminate(
                       RTC_TERMINATE_REASON enReason
                      )
{
    LOG((RTC_TRACE, "CRTCSession::Terminate - enter"));

    HRESULT hr;

    if ( m_enType == RTCST_IM )
    {
        if ( m_pIMSession != NULL )
        {
            m_pIMManager->DeleteSession( m_pIMSession );
        }

        if ( m_enState != RTCSS_DISCONNECTED )
        {
            SetState( RTCSS_DISCONNECTED, 0, NULL );
        }

        //
        // Don't access any member variables after the state is
        // set to disconnected. This object could be released.
        //
    } 
    else
    {
        switch ( m_enState)
        {    
        case RTCSS_IDLE:
            {
                //
                // If we are idle, fail
                //

                LOG((RTC_ERROR, "CRTCSession::Terminate - "
                                    "session is idle"));

                return RTC_E_INVALID_SESSION_STATE;
            }

        case RTCSS_DISCONNECTED:
            {
                //
                // If we are already disconnected, return
                //

                LOG((RTC_ERROR, "CRTCSession::Terminate - "
                                    "session is already disconnected"));

                break;
            }

        case RTCSS_INCOMING:
            {
                //
                // If the session is incoming, reject it
                //

                SIP_STATUS_CODE Status;

                switch ( enReason )
                {
                case RTCTR_DND:
                    Status = 480;
                    break;

                case RTCTR_REJECT:
                    Status = 603;
                    break;

                case RTCTR_TIMEOUT:
                    Status = 408;
                    break;

                case RTCTR_BUSY:
                case RTCTR_SHUTDOWN:
                    Status = 486;
                    break;
            
                default:
                    LOG((RTC_ERROR, "CRTCSession::Terminate - "
                                    "invalid reason for reject"));

                    return E_INVALIDARG;
                }

                hr = m_pCall->Reject( Status );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCSession::Terminate - "
                                        "Reject failed 0x%lx", hr));
    
                    return hr;
                }

                SetState( RTCSS_DISCONNECTED, 0, NULL );

                //
                // Don't access any member variables after the state is
                // set to disconnected. This object could be released.
                //

                break;
            }

        default:
            {
                //
                // Otherwise, disconnect it
                //

                if ( enReason != RTCTR_NORMAL && enReason != RTCTR_SHUTDOWN)
                {
                    LOG((RTC_ERROR, "CRTCSession::Terminate - "
                                    "invalid reason for disconnect"));

                    return E_INVALIDARG;
                }

                hr = m_pCall->Disconnect();

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCSession::Terminate - "
                                        "Disconnect failed 0x%lx", hr));
    
                    return hr;
                }
            }
        }
    }

    LOG((RTC_TRACE, "CRTCSession::Terminate - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::Redirect
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::Redirect(
        RTC_SESSION_TYPE enType,
        BSTR bstrLocalPhoneURI,
        IRTCProfile * pProfile,
        long     lFlags
        )
{
    LOG((RTC_TRACE, "CRTCSession::Redirect - enter"));

    HRESULT hr;

    if ( m_pSipRedirectContext == NULL )
    {
        LOG((RTC_ERROR, "CRTCSession::Redirect - no sip redirect context"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    LOG((RTC_INFO, "CRTCSession::Redirect - enType [%d]",
        enType));
    LOG((RTC_INFO, "CRTCSession::Redirect - bstrLocalPhoneURI [%ws]",
        bstrLocalPhoneURI));
    LOG((RTC_INFO, "CRTCSession::Redirect - pProfile [0x%p]",
        pProfile));
    LOG((RTC_INFO, "CRTCSession::Redirect - lFlags [0x%lx]",
        lFlags));

    //
    // Clean up the old state
    //

    m_ParticipantArray.Shutdown();

    if ( m_pCall != NULL )
    {
        m_pCall->SetNotifyInterface(NULL);

        m_pCall->Release();
        m_pCall = NULL;
    }

    if ( m_pIMSession != NULL )
    {
        m_pIMSession->SetNotifyInterface(NULL);

        m_pIMSession->Release();
        m_pIMSession = NULL;
    }

    if ( m_pProfile != NULL )
    {
        m_pProfile->Release();
        m_pProfile = NULL;
    }

    if ( m_szLocalPhoneURI != NULL )
    {
        RtcFree(m_szLocalPhoneURI);
        m_szLocalPhoneURI = NULL;
    }

    m_enState = RTCSS_IDLE;

    //
    // Set the new state
    //

    hr = AllocCleanTelString( bstrLocalPhoneURI, &m_szLocalPhoneURI );

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCSession::Redirect - "
                            "AllocCleanTelString failed 0x%lx", hr));
        
        return hr;
    }

    m_pProfile = pProfile;
    if (m_pProfile != NULL)
    {
        m_pProfile->AddRef();
    }

    m_enType = enType;
    m_lFlags = lFlags;

    if ( enType == RTCST_PHONE_TO_PHONE )
    {
        hr = InitializeLocalPhoneParticipant();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::Redirect - "
                            "InitializeLocalPhoneParticipant failed 0x%lx", hr));
        
            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCSession::Redirect - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::get_State
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::get_State(
        RTC_SESSION_STATE * penState
        )
{
    LOG((RTC_TRACE, "CRTCSession::get_State - enter"));

    if ( IsBadWritePtr(penState , sizeof(RTC_SESSION_STATE) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_State - bad pointer"));

        return E_POINTER;
    }

    *penState = m_enState;
   
    LOG((RTC_TRACE, "CRTCSession::get_State - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::get_Type
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::get_Type(
        RTC_SESSION_TYPE * penType
        )
{
    LOG((RTC_TRACE, "CRTCSession::get_Type - enter"));

    if ( IsBadWritePtr(penType , sizeof(RTC_SESSION_TYPE) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_Type - bad pointer"));

        return E_POINTER;
    }

    *penType = m_enType;
   
    LOG((RTC_TRACE, "CRTCSession::get_Type - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::get_Profile
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::get_Profile(
        IRTCProfile ** ppProfile
        )
{
    LOG((RTC_TRACE, "CRTCSession::get_Profile - enter"));

    if ( IsBadWritePtr(ppProfile , sizeof(IRTCProfile *) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_Profile - bad pointer"));

        return E_POINTER;
    }

    if ( m_pProfile == NULL )
    {
        LOG((RTC_ERROR, "CRTCSession::get_Profile - no profile"));

        return RTC_E_NO_PROFILE;
    } 

    *ppProfile = m_pProfile;
    m_pProfile->AddRef();
   
    LOG((RTC_TRACE, "CRTCSession::get_Profile - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::AddStream
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::AddStream(
        long lMediaType,
        long lCookie
        )
{
    LOG((RTC_TRACE, "CRTCSession::AddStream - enter"));

    HRESULT hr;

    if ( (m_enType != RTCST_PC_TO_PC) &&
         (m_enType != RTCST_PC_TO_PHONE) )
    {
        LOG((RTC_ERROR, "CRTCSession::AddStream - "
                "not a rtp call"));

        return RTC_E_INVALID_SESSION_TYPE;
    }

    if ( (m_enState != RTCSS_CONNECTED) &&
         (m_enState != RTCSS_INPROGRESS) )
    {
        LOG((RTC_ERROR, "CRTCSession::AddStream - "
                "invalid session state"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    switch ( lMediaType )
    {
    case RTCMT_AUDIO_SEND:
        hr = m_pCall->StartStream( RTC_MT_AUDIO, RTC_MD_CAPTURE,
                                   lCookie
                                   );
        break;

    case RTCMT_AUDIO_RECEIVE:
        hr = m_pCall->StartStream( RTC_MT_AUDIO, RTC_MD_RENDER,
                                   lCookie
                                   );
        break;

    case RTCMT_VIDEO_SEND:
        hr = m_pCall->StartStream( RTC_MT_VIDEO, RTC_MD_CAPTURE,
                                   lCookie
                                   );
        break;

    case RTCMT_VIDEO_RECEIVE:
        hr = m_pCall->StartStream( RTC_MT_VIDEO, RTC_MD_RENDER,
                                   lCookie
                                   );
        break;

    case RTCMT_T120_SENDRECV:
        hr = m_pCall->StartStream( RTC_MT_DATA, RTC_MD_CAPTURE,
                                   lCookie
                                   );
        if (hr == RTC_E_SIP_STREAM_PRESENT)
        {
            //  Ignore stream already started error as it does happen (expected)
            hr = S_OK;
        }
        break;

    default:
        LOG((RTC_ERROR, "CRTCSession::AddStream - "
                "invalid media type"));

        return E_INVALIDARG;
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::AddStream - "
                "StartStream failed 0x%lx", hr));

        return hr;
    } 

    LOG((RTC_TRACE, "CRTCSession::AddStream - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::RemoveStream
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::RemoveStream(
        long lMediaType,
        long lCookie
        )
{
    LOG((RTC_TRACE, "CRTCSession::RemoveStream - enter"));

    HRESULT hr;

    if ( (m_enType != RTCST_PC_TO_PC) &&
         (m_enType != RTCST_PC_TO_PHONE) )
    {
        LOG((RTC_ERROR, "CRTCSession::RemoveStream - "
                "not a rtp call"));

        return RTC_E_INVALID_SESSION_TYPE;
    }

    if ( (m_enState != RTCSS_CONNECTED) &&
         (m_enState != RTCSS_INPROGRESS) )
    {
        LOG((RTC_ERROR, "CRTCSession::RemoveStream - "
                "invalid session state"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    switch ( lMediaType )
    {
    case RTCMT_AUDIO_SEND:
        hr = m_pCall->StopStream( RTC_MT_AUDIO, RTC_MD_CAPTURE,
                                  lCookie
                                  );
        break;

    case RTCMT_AUDIO_RECEIVE:
        hr = m_pCall->StopStream( RTC_MT_AUDIO, RTC_MD_RENDER,
                                  lCookie
                                  );
        break;

    case RTCMT_VIDEO_SEND:
        hr = m_pCall->StopStream( RTC_MT_VIDEO, RTC_MD_CAPTURE,
                                  lCookie
                                  );
        break;

    case RTCMT_VIDEO_RECEIVE:
        hr = m_pCall->StopStream( RTC_MT_VIDEO, RTC_MD_RENDER,
                                  lCookie
                                  );
        break;

    case RTCMT_T120_SENDRECV:
        hr = m_pCall->StopStream( RTC_MT_DATA, RTC_MD_CAPTURE,
                                  lCookie
                                  );

        break;

    default:
        LOG((RTC_ERROR, "CRTCSession::RemoveStream - "
                "invalid media type"));

        return E_INVALIDARG;
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::RemoveStream - "
                "StopStream failed 0x%lx", hr));

        return hr;
    } 
   
    LOG((RTC_TRACE, "CRTCSession::RemoveStream - exit S_OK"));

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::put_EncryptionKey
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::put_EncryptionKey(
        long lMediaType,
        BSTR bstrEncryptionKey
        )
{
    LOG((RTC_TRACE, "CRTCSession::put_EncryptionKey - enter"));

    HRESULT hr;

    if ( (m_enType != RTCST_PC_TO_PC) &&
         (m_enType != RTCST_PC_TO_PHONE) )
    {
        LOG((RTC_ERROR, "CRTCSession::put_EncryptionKey - "
                "not a rtp call"));

        return RTC_E_INVALID_SESSION_TYPE;
    }
    
    LOG((RTC_INFO, "SSPPYY RTCMT_ALL_RTP                    %x", RTCMT_ALL_RTP));
    LOG((RTC_INFO, "SSPPYY ~RTCMT_ALL_RTP                   %x", ~RTCMT_ALL_RTP));
    LOG((RTC_INFO, "SSPPYY lMediaType & ~RTCMT_ALL_RTP      %x", lMediaType & ~RTCMT_ALL_RTP));

    if(lMediaType & ~RTCMT_ALL_RTP)
    {
        LOG((RTC_ERROR, "CRTCSession::put_EncryptionKey - "
                "invalid media type"));

        return E_INVALIDARG;
    }

    if ( IsBadStringPtrW( bstrEncryptionKey, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCSession::put_EncryptionKey - bad string pointer"));

        return E_POINTER;
    }

    // XXX - it's not per call right now
    hr = m_pCClient->SetEncryptionKey( lMediaType, bstrEncryptionKey );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::put_EncryptionKey - "
                "SetEncryptionKey failed 0x%lx", hr));

        return hr;
    } 
    if(m_pCall != NULL)
    {
        m_pCall->SetNeedToReinitializeMediaManager(TRUE);
    }
    else
    {
        LOG((RTC_TRACE, "CRTCSession::put_EncryptionKey - m_pCall"
            "is NULL, unable to call SetNeedToReinitializeMediaManager"));
    }
    LOG((RTC_TRACE, "CRTCSession::put_EncryptionKey - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::SendMessage
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::SendMessage(
        BSTR bstrMessageHeader,
        BSTR bstrMessage,
        long lCookie
        )
{
    LOG((RTC_TRACE, "CRTCSession::SendMessage - enter"));

    HRESULT hr;

    if ( m_enType != RTCST_IM )
    {
        LOG((RTC_ERROR, "CRTCSession::SendMessage - "
                "valid only for RTCST_IM sessions"));

        return RTC_E_INVALID_SESSION_TYPE;
    }

    if ( (m_enState != RTCSS_INPROGRESS) &&
         (m_enState != RTCSS_INCOMING) &&
         (m_enState != RTCSS_CONNECTED) )
    {
        LOG((RTC_ERROR, "CRTCSession::SendMessage - "
                "invalid session state"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    if ( IsBadStringPtrW( bstrMessage, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCSession::SendMessage - bad message string pointer"));

        return E_POINTER;
    }

    if ( (bstrMessageHeader != NULL) &&
         IsBadStringPtrW( bstrMessageHeader, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCSession::SendMessage - bad message header string pointer"));

        return E_POINTER;
    }

    hr = m_pIMSession->SendTextMessage( bstrMessage, bstrMessageHeader, lCookie );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::SendMessage - "
                "SendTextMessage failed 0x%lx", hr));

        return hr;
    } 

    LOG((RTC_TRACE, "CRTCSession::SendMessage - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::SendMessageStatus
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::SendMessageStatus(
        RTC_MESSAGING_USER_STATUS enUserStatus,
        long lCookie
        )
{
    LOG((RTC_TRACE, "CRTCSession::SendMessageStatus - enter"));

    HRESULT hr;

    if ( m_enType != RTCST_IM )
    {
        LOG((RTC_ERROR, "CRTCSession::SendMessageStatus - "
                "valid only for RTCST_IM sessions"));

        return RTC_E_INVALID_SESSION_TYPE;
    }

    if ( (m_enState != RTCSS_INPROGRESS) &&
         (m_enState != RTCSS_INCOMING) &&
         (m_enState != RTCSS_CONNECTED) )
    {
        LOG((RTC_ERROR, "CRTCSession::SendMessageStatus - "
                "invalid session state"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    USR_STATUS enSIPUserStatus;

    switch ( enUserStatus )
    {
    case RTCMUS_IDLE:
        enSIPUserStatus = USR_STATUS_IDLE;
        break;

    case RTCMUS_TYPING:
        enSIPUserStatus = USR_STATUS_TYPING;
        break;

    default:
        LOG((RTC_ERROR, "CRTCSession::SendMessageStatus - "
                "invalid RTC_MESSAGING_USER_STATUS"));

        return E_INVALIDARG;
    }

    hr = m_pIMSession->SendUsrStatus( enSIPUserStatus, lCookie );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::SendMessageStatus - "
                "SendUsrStatus failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCSession::SendMessageStatus - exit"));

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::InternalCreateParticipant
//
// Private helper method
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSession::InternalCreateParticipant(
        IRTCParticipant ** ppParticipant
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCSession::InternalCreateParticipant - enter"));
  
    //
    // Create the participant
    //

    CComObject<CRTCParticipant> * pCParticipant;
    hr = CComObject<CRTCParticipant>::CreateInstance( &pCParticipant );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCSession::InternalCreateParticipant - CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Get the IRTCParticipant interface
    //

    IRTCParticipant * pParticipant = NULL;

    hr = pCParticipant->QueryInterface(
                           IID_IRTCParticipant,
                           (void **)&pParticipant
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::InternalCreateParticipant - QI failed 0x%lx", hr));
        
        delete pCParticipant;
        
        return hr;
    }

    *ppParticipant = pParticipant;

    LOG((RTC_TRACE, "CRTCSession::InternalCreateParticipant - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::AddParticipant
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::AddParticipant(
        BSTR bstrUserURI,
        BSTR bstrName,
        IRTCParticipant ** ppParticipant
        )
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CRTCSession::AddParticipant - enter"));

    //
    // NULL is okay for ppParticipant
    //
    
    if ( (ppParticipant != NULL) &&
         IsBadWritePtr( ppParticipant, sizeof(IRTCParticipant *) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::AddParticipant - bad IRTCParticipant pointer"));

        return E_POINTER;
    }

    if ( IsBadStringPtrW( bstrUserURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCSession::AddParticipant - bad user URI string pointer"));

        return E_POINTER;
    }

    if ( (bstrName != NULL) &&
         IsBadStringPtrW( bstrName, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCSession::AddParticipant - bad user name string pointer"));

        return E_POINTER;
    }

    LOG((RTC_INFO, "CRTCSession::AddParticipant - bstrUserURI [%ws]",
        bstrUserURI));
    LOG((RTC_INFO, "CRTCSession::AddParticipant - bstrName [%ws]",
        bstrName));

    //
    // Reject an empty UserURI string
    //

    if ( *bstrUserURI == L'\0' )
    {
        LOG((RTC_ERROR, "CRTCSession::AddParticipant - empty string"));

        return HRESULT_FROM_WIN32(ERROR_INVALID_NETNAME);
    }

    //
    // If the session is idle, create the SIP session
    //

    if ( m_enState == RTCSS_IDLE )
    {
        hr = CreateSipSession( bstrUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                                "CreateSipSession failed 0x%lx", hr));

            return hr;
        }
    }

    //
    // Allocate a remote UserName
    //

    if ( m_szRemoteUserName != NULL )
    {
        RtcFree(m_szRemoteUserName);
        m_szRemoteUserName = NULL;
    }

    if ( bstrName )
    {
        m_szRemoteUserName = RtcAllocString( bstrName );
    }
    else
    {
        m_szRemoteUserName = RtcAllocString( L"" );
    }

    //
    // Allocate a remote UserURI
    //

    if ( m_szRemoteUserURI != NULL )
    {
        RtcFree(m_szRemoteUserURI);
        m_szRemoteUserURI = NULL;
    }

    switch ( m_enType )
    {

    case RTCST_PHONE_TO_PHONE:
        {
            hr = AllocCleanTelString( bstrUserURI, &m_szRemoteUserURI );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                        "AllocCleanTelString failed 0x%lx", hr));

                return hr;
            }
            break;
        }

    case RTCST_PC_TO_PHONE:
        {
            if ( _wcsnicmp(bstrUserURI, SIP_NAMESPACE_PREFIX, PREFIX_LENGTH) == 0 )
            {
                hr = AllocCleanSipString( bstrUserURI, &m_szRemoteUserURI );
                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                         "AllocCleanSipString failed 0x%lx", hr));
                    return hr;
                }
            }
            else
            {
                hr = AllocCleanTelString( bstrUserURI, &m_szRemoteUserURI );
                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                         "AllocCleanTelString failed 0x%lx", hr));
                    return hr;
                }
            }
            
            break;
        }
    case RTCST_PC_TO_PC:
        {
            hr = AllocCleanSipString( bstrUserURI, &m_szRemoteUserURI );
            
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                        "AllocCleanSipString failed 0x%lx", hr));

                return hr;
            }
            break;
        }
    case RTCST_IM:
        {
            hr = AllocCleanSipString( bstrUserURI, &m_szRemoteUserURI );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                        "AllocCleanSipString failed 0x%lx", hr));

                return hr;
            }
            break;
        }

    default:
        {
            LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                                "invalid session type"));

            return RTC_E_INVALID_SESSION_TYPE;
        }
    }  

    LOG((RTC_INFO, "CRTCSession::AddParticipant - m_szRemoteUserURI [%ws]",
        m_szRemoteUserURI));

    //
    // Search the pariticipant array and make sure we are not
    // trying to add a duplicate
    //

    IRTCParticipant * pSearchParticipant = NULL;
    BSTR              bstrSearchUserURI = NULL;

    for (int n = 0; n < m_ParticipantArray.GetSize(); n++)
    {
        pSearchParticipant = m_ParticipantArray[n];

        hr = pSearchParticipant->get_UserURI( &bstrSearchUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                                "get_UserURI[%p] failed 0x%lx",
                                pSearchParticipant, hr));

            return hr;
        }

        if ( IsEqualURI( m_szRemoteUserURI, bstrSearchUserURI ) )
        {
            //
            // This is a match, return an error
            //

            LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                                "duplicate participant already exists"));

            SysFreeString( bstrSearchUserURI );

            return HRESULT_FROM_WIN32(ERROR_USER_EXISTS);
        }

        SysFreeString( bstrSearchUserURI );
    }

    //
    // Create the participant
    //

    IRTCParticipant * pParticipant = NULL;

    hr = InternalCreateParticipant( &pParticipant );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                            "failed to create participant 0x%lx", hr));

        return hr;
    }

    //
    // Initialize the participant
    //

    CRTCParticipant * pCParticipant = NULL;

    pCParticipant = static_cast<CRTCParticipant *>(pParticipant);
    
    hr = pCParticipant->Initialize( m_pCClient, 
                                    this,
                                    m_szRemoteUserURI,
                                    m_szRemoteUserName,
                                    m_enType == RTCST_PHONE_TO_PHONE
                                   );

    
 
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::AddParticipant - Initialize failed 0x%lx", hr));

        pParticipant->Release();
        
        return hr;
    }  

    //
    // Add the participant to the array
    //

    BOOL fResult;

    fResult = m_ParticipantArray.Add(pParticipant);

    if ( fResult == FALSE )
    {
        LOG((RTC_ERROR, "CRTCSession::AddParticipant - out of memory"));

        pParticipant->Release();
        
        return E_OUTOFMEMORY;
    }   

    switch ( m_enType )
    {

    case RTCST_PHONE_TO_PHONE:
        {
            //
            // This is a RTCST_PHONE_TO_PHONE session. We can add participants as long as
            // the call is IDLE, INPROGRESS, or CONNECTED.
            //

            if ( (m_enState != RTCSS_IDLE) &&
                 (m_enState != RTCSS_INPROGRESS) &&
                 (m_enState != RTCSS_CONNECTED) )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                                    "session can not add participants"));

                m_ParticipantArray.Remove(pParticipant);
                pParticipant->Release();                

                return RTC_E_INVALID_SESSION_STATE;
            }        

            //
            // Fill in the SIP_PARTY_INFO.
            //

            SIP_PARTY_INFO spi;

            ZeroMemory(&spi, sizeof(SIP_PARTY_INFO));

            spi.DisplayName = m_szRemoteUserName;
            spi.URI = m_szRemoteUserURI;

            //
            // Add the party to the SIP call.
            //

            hr = m_pCall->AddParty( &spi );
                                 
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - AddParty failed 0x%lx", hr));

                m_ParticipantArray.Remove(pParticipant);
                pParticipant->Release();     

                return hr;
            }   

            //
            // If the session state is idle, we need to call Connect to place the call.
            //
    
            if ( m_enState == RTCSS_IDLE )
            {
                hr = m_pCall->Connect(
                                  m_szLocalName,
                                  m_szLocalUserURI,
                                  m_szLocalUserURI,
                                  m_szLocalPhoneURI
                                 );
                                 
                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCSession::AddParticipant - Connect failed 0x%lx", hr));        

                    m_ParticipantArray.Remove(pParticipant);
                    pParticipant->Release();     

                    return hr;
                } 
                
                //
                // Set the session state
                //

                SetState( RTCSS_INPROGRESS, 0, NULL );
            }

            break;
        }

    case RTCST_PC_TO_PC:
    case RTCST_PC_TO_PHONE:
        {
            //
            // This is a RTCST_PC_TO_X session. We can only add participants when the session state
            // is IDLE.
            //

            if ( m_enState != RTCSS_IDLE )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                                "session can not add participants"));

                m_ParticipantArray.Remove(pParticipant);
                pParticipant->Release();     

                return RTC_E_INVALID_SESSION_STATE;
            }
         
            //
            // Call Connect to place the call.
            //

            hr = m_pCall->Connect(
                                  m_szLocalName,
                                  m_szLocalUserURI,
                                  m_szRemoteUserURI,
                                  NULL
                                 );
                                 
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - Connect failed 0x%lx", hr));

                m_ParticipantArray.Remove(pParticipant);
                pParticipant->Release();     

                return hr;
            }   

            //
            // Set the session state
            //

            SetState( RTCSS_INPROGRESS, 0, NULL );

            break;
        }

    case RTCST_IM:
        {
            //
            // This is a RTCST_IM session. We can only add participants when the session state
            // is IDLE.
            //

            if ( m_enState != RTCSS_IDLE )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                                "session can not add participants"));

                m_ParticipantArray.Remove(pParticipant);
                pParticipant->Release();     

                return RTC_E_INVALID_SESSION_STATE;
            }

            //
            // Fill in the SIP_PARTY_INFO.
            //

            SIP_PARTY_INFO spi;

            ZeroMemory(&spi, sizeof(SIP_PARTY_INFO));

            spi.DisplayName = m_szRemoteUserName;
            spi.URI = m_szRemoteUserURI;

            //
            // Add the party to the SIP call.
            //

            hr = m_pIMSession->AddParty( &spi );
                                 
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - AddParty failed 0x%lx", hr));

                m_ParticipantArray.Remove(pParticipant);
                pParticipant->Release();     

                return hr;
            }  
            
            //
            // Set the session state
            //

            SetState( RTCSS_INPROGRESS, 0, NULL );

            break;
        } 
    }

    //
    // Should we return the participant?
    //
    
    if ( ppParticipant != NULL )
    {
        *ppParticipant = pParticipant;
    }
    else
    {
        pParticipant->Release();
        pParticipant = NULL;
    }

    LOG((RTC_TRACE, "CRTCSession::AddParticipant - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::RemoveParticipant
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::RemoveParticipant(
        IRTCParticipant * pParticipant
        )
{
    LOG((RTC_TRACE, "CRTCSession::RemoveParticipant - enter"));   

    if ( IsBadReadPtr( pParticipant, sizeof(IRTCParticipant) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::RemoveParticipant - "
                            "bad IRTCParticipant pointer"));

        return E_POINTER;
    }
    
    //
    // Check to see if the participant is removable
    //

    VARIANT_BOOL fRemovable;
    HRESULT hr;

    hr = pParticipant->get_Removable( &fRemovable );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::RemoveParticipant - "
                            "get_Removable failed 0x%lx", hr));

        return hr;
    }

    if ( fRemovable == VARIANT_FALSE )
    {
        LOG((RTC_ERROR, "CRTCSession::RemoveParticipant - "
                            "this participant is not removeable"));

        return E_FAIL;
    }

    //
    // Get the UserURI
    // 

    BSTR bstrUserURI = NULL;

    hr = pParticipant->get_UserURI( &bstrUserURI );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::RemoveParticipant - "
                            "get_UserURI failed 0x%lx", hr));        
    }  
    else
    {
        //
        // Remove the party from the SIP call
        //

        hr = m_pCall->RemoveParty( bstrUserURI );

        SysFreeString( bstrUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::RemoveParticipant - "
                                "RemoveParty failed 0x%lx", hr));
        }
    }

    //
    // The participant will be removed from the list once it reaches the
    // RTCSS_DISCCONNECTED state. However, if RemoveParty failed we will
    // need to do this right now.
    //

    if ( FAILED(hr) )
    {
        //
        // Set participant state
        //

        CRTCParticipant * pCParticipant;

        pCParticipant = static_cast<CRTCParticipant *>(pParticipant);

        pCParticipant->SetState( RTCPS_DISCONNECTED, 0 );
        
        //
        // Remove the participant from our array
        //

        BOOL fResult;

        fResult = m_ParticipantArray.Remove(pParticipant);

        if ( fResult == FALSE )
        {
            LOG((RTC_ERROR, "CRTCSession::RemoveParticipant - "
                                "participant not found"));
        }
    }

    LOG((RTC_TRACE, "CRTCSession::RemoveParticipant - exit 0x%lx", hr));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::EnumerateParticipants
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::EnumerateParticipants(
        IRTCEnumParticipants ** ppEnum
        )
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "CRTCSession::EnumerateParticipants enter"));

    if ( IsBadWritePtr( ppEnum, sizeof( IRTCEnumParticipants * ) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::EnumerateParticipants - "
                            "bad IRTCEnumParticipants pointer"));

        return E_POINTER;
    }

    //
    // Create the enumeration
    //
 
    CComObject< CRTCEnum< IRTCEnumParticipants,
                          IRTCParticipant,
                          &IID_IRTCEnumParticipants > > * p;
                          
    hr = CComObject< CRTCEnum< IRTCEnumParticipants,
                               IRTCParticipant,
                               &IID_IRTCEnumParticipants > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCSession::EnumerateParticipants - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the enumeration (adds a reference)
    //
    
    hr = p->Initialize( m_ParticipantArray );

    if (S_OK != hr)
    {
        LOG((RTC_ERROR, "CRTCSession::EnumerateParticipants - "
                            "could not initialize enumeration" ));
    
        delete p;
        return hr;
    }

    *ppEnum = p;

    LOG((RTC_TRACE, "CRTCSession::EnumerateParticipants - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::get_Participants
//
// This is an IRTCSession method that enumerates participants on
// the session.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCSession::get_Participants(
        IRTCCollection ** ppCollection
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCSession::get_Participants - enter"));

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( ppCollection, sizeof(IRTCCollection *) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_Participants - "
                            "bad IRTCCollection pointer"));

        return E_POINTER;
    }

    //
    // Create the collection
    //
 
    CComObject< CRTCCollection< IRTCParticipant > > * p;
                          
    hr = CComObject< CRTCCollection< IRTCParticipant > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::get_Participants - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the collection (adds a reference)
    //
    
    hr = p->Initialize(m_ParticipantArray);

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Participants - "
                            "could not initialize collection" ));
    
        delete p;
        return hr;
    }

    *ppCollection = p;

    LOG((RTC_TRACE, "CRTCSession::get_Participants - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::get_CanAddParticipants
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::get_CanAddParticipants(
        VARIANT_BOOL * pfCanAdd
        )
{
    LOG((RTC_TRACE, "CRTCSession::get_CanAddParticipants - enter"));

    if ( IsBadWritePtr(pfCanAdd , sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_CanAddParticipants - bad pointer"));

        return E_POINTER;
    }

    //
    // Set this to TRUE for now
    //

    *pfCanAdd = VARIANT_TRUE;

    switch ( m_enType )
    {

    case RTCST_PHONE_TO_PHONE:
        {
            //
            // This is a RTCST_PHONE_TO_PHONE session. We can add participants as long as 
            // the call is IDLE, INPROGRESS, or CONNECTED.
            //

            if ( (m_enState != RTCSS_IDLE) &&
                 (m_enState != RTCSS_INPROGRESS) &&
                 (m_enState != RTCSS_CONNECTED) )
            {
                LOG((RTC_ERROR, "CRTCSession::get_CanAddParticipants - "
                                    "session can not add participants"));

                *pfCanAdd = VARIANT_FALSE;
            }

            break;
        }

    case RTCST_PC_TO_PC:
    case RTCST_PC_TO_PHONE:
        {
            //
            // This is a RTCST_PC_TO_X session. We can only add participants when the session state
            // is IDLE.
            //

            if ( m_enState != RTCSS_IDLE )
            {
                LOG((RTC_ERROR, "CRTCSession::get_CanAddParticipants - "
                                "session can not add participants"));

                *pfCanAdd = VARIANT_FALSE;
            }

            break;
        }

    case RTCST_IM:
        {
            //
            // This is a RTCST_IM session. We can only add participants when the session state
            // is IDLE.
            //

            if ( m_enState != RTCSS_IDLE )
            {
                LOG((RTC_ERROR, "CRTCSession::get_CanAddParticipants - "
                                "session can not add participants"));

                *pfCanAdd = VARIANT_FALSE;
            }

            break;
        }

    default:
        {
            LOG((RTC_ERROR, "CRTCSession::get_CanAddParticipants - "
                                "invalid session type"));

            *pfCanAdd = VARIANT_FALSE;
        }
    }

    LOG((RTC_TRACE, "CRTCSession::get_CanAddParticipants - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::get_RedirectedUserURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::get_RedirectedUserURI(
        BSTR * pbstrUserURI
        )
{
    LOG((RTC_TRACE, "CRTCSession::get_RedirectedUserURI - enter" ));

    if ( IsBadWritePtr(pbstrUserURI , sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_RedirectedUserURI - bad pointer"));

        return E_POINTER;
    }

    if ( m_pSipRedirectContext == NULL )
    {
        LOG((RTC_ERROR, "CRTCSession::get_RedirectedUserURI - no sip redirect context"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    BSTR bstrSipUrl = NULL;
    BSTR bstrDisplayName = NULL;
    HRESULT hr;

    hr = m_pSipRedirectContext->GetSipUrlAndDisplayName(
                                    &bstrSipUrl,
                                    &bstrDisplayName
                                    );

    if ( SUCCEEDED(hr) )
    {
        LOG((RTC_INFO, "CRTCSession::get_RedirectedUserURI - [%ws]", bstrSipUrl ));

        *pbstrUserURI = bstrSipUrl;

        SysFreeString( bstrDisplayName );
    }

    LOG((RTC_TRACE, "CRTCSession::get_RedirectedUserURI - exit" ));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::get_RedirectedUserName
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::get_RedirectedUserName(
        BSTR * pbstrUserName
        )
{
    LOG((RTC_TRACE, "CRTCSession::get_RedirectedUserName - enter" ));

    if ( IsBadWritePtr(pbstrUserName , sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_RedirectedUserName - bad pointer"));

        return E_POINTER;
    }

    if ( m_pSipRedirectContext == NULL )
    {
        LOG((RTC_ERROR, "CRTCSession::get_RedirectedUserName - no sip redirect context"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    BSTR bstrSipUrl = NULL;
    BSTR bstrDisplayName = NULL;
    HRESULT hr;

    hr = m_pSipRedirectContext->GetSipUrlAndDisplayName(
                                    &bstrSipUrl,
                                    &bstrDisplayName
                                    );

    if ( SUCCEEDED(hr) )
    {
        LOG((RTC_INFO, "CRTCSession::get_RedirectedUserName - [%ws]", bstrDisplayName ));

        *pbstrUserName = bstrDisplayName;

        SysFreeString( bstrSipUrl );
    }

    LOG((RTC_TRACE, "CRTCSession::get_RedirectedUserName - exit" ));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NextRedirectedUser
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::NextRedirectedUser()
{
    LOG((RTC_TRACE, "CRTCSession::NextRedirectedUser - enter" ));

    if ( m_pSipRedirectContext == NULL )
    {
        LOG((RTC_ERROR, "CRTCSession::NextRedirectedUser - no sip redirect context"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    HRESULT hr;

    hr = m_pSipRedirectContext->Advance();

    LOG((RTC_TRACE, "CRTCSession::NextRedirectedUser - exit" ));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NotifyCallChange
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCSession::NotifyCallChange(
        SIP_CALL_STATUS * CallStatus
        )
{
    LOG((RTC_TRACE, "CRTCSession::NotifyCallChange - enter"));

    switch (CallStatus->State)
    {
        case SIP_CALL_STATE_IDLE:
            SetState(RTCSS_IDLE,
                CallStatus->Status.StatusCode,
                CallStatus->Status.StatusText);
            break;

        case SIP_CALL_STATE_OFFERING:
            SetState(RTCSS_INCOMING,
                CallStatus->Status.StatusCode,
                CallStatus->Status.StatusText);
            break;

        case SIP_CALL_STATE_REJECTED:               
        case SIP_CALL_STATE_DISCONNECTED:
        case SIP_CALL_STATE_ERROR: 
            SetState(RTCSS_DISCONNECTED,
                CallStatus->Status.StatusCode,
                CallStatus->Status.StatusText);
            
            //
            // Don't access any member variables after the state is
            // set to disconnected. This object could be released.
            //
            break;

        case SIP_CALL_STATE_ALERTING:
        case SIP_CALL_STATE_CONNECTING:
            SetState(RTCSS_INPROGRESS,
                CallStatus->Status.StatusCode,
                CallStatus->Status.StatusText);
            break;

        case SIP_CALL_STATE_CONNECTED:
            SetState(RTCSS_CONNECTED,
                CallStatus->Status.StatusCode,
                CallStatus->Status.StatusText);
            break;        

        default:
            LOG((RTC_ERROR, "CRTCSession::NotifyCallChange - "
                                "invalid call state"));                                
    }

    LOG((RTC_TRACE, "CRTCSession::NotifyCallChange - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NotifyStartOrStopStreamCompletion
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCSession::NotifyStartOrStopStreamCompletion(
        long                   lCookie,
        SIP_STATUS_BLOB       *pStatus
        )
{
    LOG((RTC_TRACE, "CRTCSession::NotifyStartOrStopStreamCompletion - enter"));

    CRTCSessionOperationCompleteEvent::FireEvent(
                                         this,
                                         lCookie,
                                         pStatus->StatusCode,
                                         pStatus->StatusText
                                        );   

    LOG((RTC_TRACE, "CRTCSession::NotifyStartOrStopStreamCompletion - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NotifyPartyChange
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCSession::NotifyPartyChange(
        SIP_PARTY_INFO * PartyInfo
        )
{
    LOG((RTC_TRACE, "CRTCSession::NotifyPartyChange - enter"));

    //
    // Find the participant that we are being notified about
    //

    IRTCParticipant * pParticipant = NULL; 
    BSTR bstrUserURI = NULL;
    BOOL bFound = FALSE;
    HRESULT hr;

    for (int n = 0; (n < m_ParticipantArray.GetSize()) && (!bFound); n++)
    {
        pParticipant = m_ParticipantArray[n];

        hr = pParticipant->get_UserURI( &bstrUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::NotifyPartyChange - "
                                "get_UserURI[%p] failed 0x%lx",
                                pParticipant, hr));

            return hr;
        }

        if ( IsEqualURI( PartyInfo->URI, bstrUserURI ) )
        {
            //
            // This is a match
            //

            CRTCParticipant * pCParticipant;

            pCParticipant = static_cast<CRTCParticipant *>(pParticipant);            

            switch( PartyInfo->State )
            {
            case SIP_PARTY_STATE_CONNECT_INITIATED: // consider this a pending situation
            case SIP_PARTY_STATE_PENDING:
                pCParticipant->SetState(RTCPS_PENDING, PartyInfo->StatusCode);
                break;

            case SIP_PARTY_STATE_CONNECTING:
                pCParticipant->SetState(RTCPS_INPROGRESS, PartyInfo->StatusCode);
                break;
            
            case SIP_PARTY_STATE_DISCONNECT_INITIATED:
            case SIP_PARTY_STATE_DISCONNECTING:
                pCParticipant->SetState(RTCPS_DISCONNECTING, PartyInfo->StatusCode);
                break;

            case SIP_PARTY_STATE_REJECTED:
            case SIP_PARTY_STATE_DISCONNECTED:  
            case SIP_PARTY_STATE_ERROR:
                pCParticipant->SetState(RTCPS_DISCONNECTED, PartyInfo->StatusCode);

                //
                // Remove the participant from our array
                //
                m_ParticipantArray.Remove(pParticipant);  
                
                break;           

            case SIP_PARTY_STATE_CONNECTED:
                pCParticipant->SetState(RTCPS_CONNECTED, PartyInfo->StatusCode);
                break;
            
            default:
                LOG((RTC_ERROR, "CRTCSession::NotifyPartyChange - "
                                    "invalid party state"));               
            }

            bFound = TRUE;
        }

        SysFreeString( bstrUserURI );
    }

    if (!bFound)
    {
        LOG((RTC_ERROR, "CRTCSession::NotifyPartyChange - "
                            "participant not found")); 
        
        return E_FAIL;
    }

    LOG((RTC_TRACE, "CRTCSession::NotifyPartyChange - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NotifyRedirect
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCSession::NotifyRedirect(
        ISipRedirectContext * pSipRedirectContext,
        SIP_CALL_STATUS * pCallStatus
        )
{
    LOG((RTC_TRACE, "CRTCSession::NotifyRedirect - enter"));

    HRESULT hr;

    //
    // Save the redirect context
    //

    if ( m_pSipRedirectContext != NULL )
    {
        m_pSipRedirectContext->Release();
        m_pSipRedirectContext = NULL;
    }

    m_pSipRedirectContext = pSipRedirectContext;
    m_pSipRedirectContext->AddRef();
  
    if ( m_lFlags & RTCCS_FAIL_ON_REDIRECT )
    {
        //
        // Change the session state, notifying the UI
        //

        SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

        //
        // Don't access any member variables after the state is
        // set to disconnected. This object could be released.
        //
    }
    else
    {
        //
        // Do the redirection
        //

        BSTR bstrLocalPhoneURI = NULL;
        BSTR bstrRedirectedUserURI = NULL;
        BSTR bstrRedirectedUserName = NULL;

        hr = m_pSipRedirectContext->Advance();

        if ( hr != S_OK )
        {            
            if ( hr == S_FALSE )
            {
                LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                            "redirect list empty"));
            }
            else
            {
                LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                            "Advance failed 0x%lx", hr)); 
            }

            SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

            //
            // Don't access any member variables after the state is
            // set to disconnected. This object could be released.
            //
    
            return hr;
        }

        hr = m_pSipRedirectContext->GetSipUrlAndDisplayName( &bstrRedirectedUserURI, &bstrRedirectedUserName );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                        "GetSipUrlAndDisplayName failed 0x%lx", hr)); 

            SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

            //
            // Don't access any member variables after the state is
            // set to disconnected. This object could be released.
            //

            return hr;
        }

        if ( m_szLocalPhoneURI != NULL )
        {
            bstrLocalPhoneURI = SysAllocString( m_szLocalPhoneURI );

            if ( bstrLocalPhoneURI == NULL )
            {
                LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                            "out of memory")); 

                SysFreeString( bstrRedirectedUserName );
                bstrRedirectedUserName = NULL;

                SysFreeString( bstrRedirectedUserURI );
                bstrRedirectedUserURI = NULL;

                SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

                //
                // Don't access any member variables after the state is
                // set to disconnected. This object could be released.
                //
        
                return E_OUTOFMEMORY;
            }
        }

        if ( m_enType == RTCST_PHONE_TO_PHONE )
        {
            //
            // We must redirect to a new phone to phone proxy
            //

            m_szRedirectProxy = RtcAllocString( bstrRedirectedUserURI );

            SysFreeString( bstrRedirectedUserName );
            bstrRedirectedUserName = NULL;

            SysFreeString( bstrRedirectedUserURI );
            bstrRedirectedUserURI = NULL;

            if ( m_szRedirectProxy == NULL )
            {
                LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                            "out of memory")); 

                SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

                //
                // Don't access any member variables after the state is
                // set to disconnected. This object could be released.
                //
        
                return E_OUTOFMEMORY;
            }

            //
            // Use the Name and URI of last participant
            //

            bstrRedirectedUserName = SysAllocString( m_szRemoteUserName );

            if ( bstrRedirectedUserName == NULL )
            {
                LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                            "out of memory")); 

                RtcFree(m_szRedirectProxy);
                m_szRedirectProxy = NULL;

                SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

                //
                // Don't access any member variables after the state is
                // set to disconnected. This object could be released.
                //
        
                return E_OUTOFMEMORY;
            }
            
            bstrRedirectedUserURI = SysAllocString( m_szRemoteUserURI );

            if ( bstrRedirectedUserURI == NULL )
            {
                LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                            "out of memory")); 

                RtcFree(m_szRedirectProxy);
                m_szRedirectProxy = NULL;

                SysFreeString(bstrRedirectedUserName);
                bstrRedirectedUserName = NULL;

                SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

                //
                // Don't access any member variables after the state is
                // set to disconnected. This object could be released.
                //
        
                return E_OUTOFMEMORY;
            }
        }

        IRTCProfile * pProfile = m_pProfile;

        if ( pProfile != NULL )
        {
            pProfile->AddRef();
        }

        hr = Redirect( m_enType, bstrLocalPhoneURI, pProfile, m_lFlags & ~RTCCS_FORCE_PROFILE );

        if ( pProfile != NULL )
        {
            pProfile->Release();
            pProfile = NULL;
        }

        if ( bstrLocalPhoneURI != NULL )
        {
            SysFreeString( bstrLocalPhoneURI );
            bstrLocalPhoneURI = NULL;
        }

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                        "Redirect failed 0x%lx", hr)); 

            if ( m_szRedirectProxy != NULL )
            {
                RtcFree(m_szRedirectProxy);
                m_szRedirectProxy = NULL;
            }

            SysFreeString( bstrRedirectedUserName );
            bstrRedirectedUserName = NULL;

            SysFreeString( bstrRedirectedUserURI );
            bstrRedirectedUserURI = NULL;

            SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

            //
            // Don't access any member variables after the state is
            // set to disconnected. This object could be released.
            //
    
            return hr;
        }
        
        hr = AddParticipant( bstrRedirectedUserURI, bstrRedirectedUserName, NULL );

        if ( m_szRedirectProxy != NULL )
        {
            RtcFree(m_szRedirectProxy);
            m_szRedirectProxy = NULL;
        }

        SysFreeString( bstrRedirectedUserName );
        bstrRedirectedUserName = NULL;

        SysFreeString( bstrRedirectedUserURI );
        bstrRedirectedUserURI = NULL;

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                        "AddParticipant failed 0x%lx", hr)); 

            SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

            //
            // Don't access any member variables after the state is
            // set to disconnected. This object could be released.
            //
    
            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCSession::NotifyRedirect - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NotifyMessageRedirect
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::NotifyMessageRedirect(
            ISipRedirectContext    *pRedirectContext,
            SIP_CALL_STATUS        *pCallStatus,
            BSTR                   bstrMsg,
            BSTR                   bstrContentType,
            USR_STATUS             UsrStatus,
            long                   lCookie
            )
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCSession::NotifyMessageRedirect - enter"));
    
    //
    // First, do normal redirect processing
    //

    hr = NotifyRedirect(pRedirectContext, pCallStatus);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::NotifyMessageRedirect - "
                    "NotifyRedirect failed 0x%lx", hr)); 
       
        //
        // Due to failure we need to notify operation complete
        //
       
        CRTCSessionOperationCompleteEvent::FireEvent(
                                         this,
                                         lCookie,
                                         pCallStatus->Status.StatusCode,
                                         pCallStatus->Status.StatusText
                                        ); 

        SetState( RTCSS_DISCONNECTED, pCallStatus->Status.StatusCode, pCallStatus->Status.StatusText );

        //
        // Don't access any member variables after the state is
        // set to disconnected. This object could be released.
        //

        return hr;
    }

    if ( m_lFlags & RTCCS_FAIL_ON_REDIRECT )
    {
        //
        // Due to failure we need to notify operation complete
        //

        CRTCSessionOperationCompleteEvent::FireEvent(
                                         this,
                                         lCookie,
                                         pCallStatus->Status.StatusCode,
                                         pCallStatus->Status.StatusText
                                        ); 

        SetState( RTCSS_DISCONNECTED, pCallStatus->Status.StatusCode, pCallStatus->Status.StatusText );

        //
        // Don't access any member variables after the state is
        // set to disconnected. This object could be released.
        //
    }
    else
    {
        //
        // Resend the message/info
        //

        if ( bstrMsg != NULL )
        {
            hr = m_pIMSession->SendTextMessage( bstrMsg, bstrContentType, lCookie );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::NotifyMessageRedirect - "
                        "SendTextMessage failed 0x%lx", hr));

                //
                // Due to failure we need to notify operation complete
                //

                CRTCSessionOperationCompleteEvent::FireEvent(
                                                 this,
                                                 lCookie,
                                                 pCallStatus->Status.StatusCode,
                                                 pCallStatus->Status.StatusText
                                                ); 

                SetState( RTCSS_DISCONNECTED, pCallStatus->Status.StatusCode, pCallStatus->Status.StatusText );

                //
                // Don't access any member variables after the state is
                // set to disconnected. This object could be released.
                //

                return hr;
            } 
        }
        else
        {
            hr = m_pIMSession->SendUsrStatus( UsrStatus, lCookie );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::NotifyMessageRedirect - "
                        "SendUsrStatus failed 0x%lx", hr));

                //
                // Due to failure we need to notify operation complete
                //

                CRTCSessionOperationCompleteEvent::FireEvent(
                                                 this,
                                                 lCookie,
                                                 pCallStatus->Status.StatusCode,
                                                 pCallStatus->Status.StatusText
                                                ); 

                SetState( RTCSS_DISCONNECTED, pCallStatus->Status.StatusCode, pCallStatus->Status.StatusText );

                //
                // Don't access any member variables after the state is
                // set to disconnected. This object could be released.
                //

                return hr;
            }
        }
    }

    LOG((RTC_TRACE, "CRTCSession::NotifyMessageRedirect - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NotifyIncomingMessage
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCSession::NotifyIncomingMessage(
            IIMSession *pSession,
            BSTR msg,
            BSTR ContentType,
            SIP_PARTY_INFO * CallerInfo
            )
{
    LOG((RTC_TRACE, "CRTCSession::NotifyIncomingMessage - enter"));

    if ( m_enType != RTCST_IM )
    {
        LOG((RTC_ERROR, "CRTCSession::NotifyIncomingMessage - "
                "valid only for RTCST_IM sessions"));

        return RTC_E_INVALID_SESSION_TYPE;
    }

    //
    // Find the participant that we are being notified about
    //

    IRTCParticipant * pParticipant = NULL; 
    BSTR bstrUserURI = NULL;
    BOOL bFound = FALSE;
    HRESULT hr;

    for (int n = 0; (n < m_ParticipantArray.GetSize()) && (!bFound); n++)
    {
        pParticipant = m_ParticipantArray[n];

        hr = pParticipant->get_UserURI( &bstrUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::NotifyIncomingMessage - "
                                "get_UserURI[%p] failed 0x%lx",
                                pParticipant, hr));

            return hr;
        }

        if ( IsEqualURI( CallerInfo->URI, bstrUserURI ) )
        {
            //
            // This is a match
            //

            //
            // Fire a message event
            //
    
            CRTCMessagingEvent::FireEvent(this, pParticipant, msg, ContentType, RTCMSET_MESSAGE, RTCMUS_IDLE);

            bFound = TRUE;
        }

        SysFreeString( bstrUserURI );
    }

    if (!bFound)
    {
        LOG((RTC_ERROR, "CRTCSession::NotifyIncomingMessage - "
                            "participant not found")); 
        
        return E_FAIL;
    }

    LOG((RTC_TRACE, "CRTCSession::NotifyIncomingMessage - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NotifyUsrStatus
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::NotifyUsrStatus(
        USR_STATUS  UsrStatus,
        SIP_PARTY_INFO * CallerInfo
        )
{
    LOG((RTC_TRACE, "CRTCSession::NotifyUsrStatus - enter"));

    if ( m_enType != RTCST_IM )
    {
        LOG((RTC_ERROR, "CRTCSession::NotifyUsrStatus - "
                "valid only for RTCST_IM sessions"));

        return RTC_E_INVALID_SESSION_TYPE;
    }

    //
    // Find the participant that we are being notified about
    //

    IRTCParticipant * pParticipant = NULL; 
    BSTR bstrUserURI = NULL;
    BOOL bFound = FALSE;
    HRESULT hr;

    for (int n = 0; (n < m_ParticipantArray.GetSize()) && (!bFound); n++)
    {
        pParticipant = m_ParticipantArray[n];

        hr = pParticipant->get_UserURI( &bstrUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::NotifyUsrStatus - "
                                "get_UserURI[%p] failed 0x%lx",
                                pParticipant, hr));

            return hr;
        }

        if ( IsEqualURI( CallerInfo->URI, bstrUserURI ) )
        {
            //
            // This is a match
            //

            //
            // Fire a message event
            //
            
            switch ( UsrStatus )
            {
            case USR_STATUS_IDLE:
                CRTCMessagingEvent::FireEvent(this, pParticipant, NULL, NULL, RTCMSET_STATUS, RTCMUS_IDLE);
                break;

            case USR_STATUS_TYPING:
                CRTCMessagingEvent::FireEvent(this, pParticipant, NULL, NULL, RTCMSET_STATUS, RTCMUS_TYPING);
                break;

            default:
                LOG((RTC_ERROR, "CRTCSession::NotifyUsrStatus - "
                            "invalid USR_STATUS")); 
            }

            bFound = TRUE;
        }

        SysFreeString( bstrUserURI );
    }

    if (!bFound)
    {
        LOG((RTC_ERROR, "CRTCSession::NotifyUsrStatus - "
                            "participant not found")); 
        
        return E_FAIL;
    }

    LOG((RTC_TRACE, "CRTCSession::NotifyUsrStatus - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NotifyMessageCompletion
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::NotifyMessageCompletion(
        SIP_STATUS_BLOB *      pStatus,
        long                   lCookie
        )
{
    LOG((RTC_TRACE, "CRTCSession::NotifyMessageCompletion - enter"));

    if ( (HRESULT_FACILITY(pStatus->StatusCode) == FACILITY_SIP_STATUS_CODE) &&
         (HRESULT_CODE(pStatus->StatusCode) >= 300) &&
         (HRESULT_CODE(pStatus->StatusCode) <= 399) )  
    {
        //
        // Ignore the redirect because we will handle this in NotifyMessageRedirect. We
        // will notify completion on redirection error, or on completion of the
        // redirected message.
        //

        LOG((RTC_TRACE, "CRTCSession::NotifyMessageCompletion - ignoring redirect"));

        return S_OK;
    }

    if ( SUCCEEDED(pStatus->StatusCode) && (m_enState != RTCSS_CONNECTED) )
    {
        //
        // If the first result is success, set the session state to connected
        //

        SetState( RTCSS_CONNECTED, pStatus->StatusCode, pStatus->StatusText );
    }

    CRTCSessionOperationCompleteEvent::FireEvent(
                                         this,
                                         lCookie,
                                         pStatus->StatusCode,
                                         pStatus->StatusText
                                        );  

    if ( FAILED(pStatus->StatusCode) && (m_enState != RTCSS_CONNECTED) )
    {
        //
        // If the first result is failure, set the session state to disconnected
        //

        SetState( RTCSS_DISCONNECTED, pStatus->StatusCode, pStatus->StatusText );

        //
        // Don't access any member variables after the state is
        // set to disconnected. This object could be released.
        //
    }

    LOG((RTC_TRACE, "CRTCSession::NotifyMessageCompletion - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::SetPortManager
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::SetPortManager(
            IRTCPortManager * pPortManager
            )
{
    IRTCMediaManage * pMedia = NULL;
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCSession::SetPortManager - enter"));

    if ( (pPortManager != NULL) &&
         IsBadReadPtr( pPortManager, sizeof(IRTCPortManager) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::SetPortManager - "
                            "bad IRTCPortManager pointer"));

        return E_POINTER;
    }

    // port manager can only be set on pc-to-XXX sessions
    if ( m_enType != RTCST_PC_TO_PHONE )
    {
        LOG((RTC_ERROR, "CRTCSession::SetPortManager - "
                "not a pc2phone call"));

        return RTC_E_INVALID_SESSION_TYPE;
    }

    hr = m_pCClient->GetMediaManager(&pMedia);

    if (FAILED(hr))
    {
        return hr;
    }

    hr = pMedia->SetPortManager(pPortManager);

    pMedia->Release();

    LOG((RTC_TRACE, "CRTCSession::SetPortManager - exit"));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\rtcwaves.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCWaves.cpp

Abstract:

    Implementation of the CWavePlayer class

--*/

#include "stdafx.h"

BOOL DSParseWaveResource(void *pvRes, WAVEFORMATEX **ppWaveHeader, BYTE ** ppbWaveData, DWORD *pdwWaveSize);
static const TCHAR c_szWAV[] = _T("WAVE");

BOOL   CWavePlayer::m_fInitialized = FALSE;
LPBYTE CWavePlayer::m_lpWaveform[ NUM_WAVES ];
DWORD  CWavePlayer::m_dwWaveformSize[ NUM_WAVES ];

///////////////////////////////////////////////////////////////////////////////
//
// DSGetWaveResource
//
///////////////////////////////////////////////////////////////////////////////

BOOL DSGetWaveResource(HMODULE hModule, LPCTSTR lpName,
    WAVEFORMATEX **ppWaveHeader, BYTE **ppbWaveData, DWORD *pcbWaveSize)
{
    HRSRC hResInfo;
    HGLOBAL hResData;
    void *pvRes;

    if (((hResInfo = FindResource(hModule, lpName, c_szWAV)) != NULL) &&
        ((hResData = LoadResource(hModule, hResInfo)) != NULL) &&
        ((pvRes = LockResource(hResData)) != NULL) &&
        DSParseWaveResource(pvRes, ppWaveHeader, ppbWaveData, pcbWaveSize))
    {
         return TRUE;
    }
   
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

BOOL DSParseWaveResource(void *pvRes, WAVEFORMATEX **ppWaveHeader, BYTE **
ppbWaveData,DWORD *pcbWaveSize)
{   
    DWORD *pdw;
    DWORD *pdwEnd;
    DWORD dwRiff;
    DWORD dwType;
    DWORD dwLength;

    if (ppWaveHeader)
    {
        *ppWaveHeader = NULL;
    }

    if (ppbWaveData)
    {
        *ppbWaveData = NULL;
    }

    if (pcbWaveSize)
    {
        *pcbWaveSize = 0;
    }

    pdw = (DWORD *)pvRes;
    dwRiff = *pdw++;
    dwLength = *pdw++;
    dwType = *pdw++;

    if (dwRiff != mmioFOURCC('R', 'I', 'F', 'F'))
        goto exit;      // not even RIFF

    if (dwType != mmioFOURCC('W', 'A', 'V', 'E'))
        goto exit;      // not a WAV

    pdwEnd = (DWORD *)((BYTE *)pdw + dwLength-4);

    while (pdw < pdwEnd)
    {
        dwType = *pdw++;
        dwLength = *pdw++;

        switch (dwType)
        {
        case mmioFOURCC('f', 'm', 't', ' '):
            if (ppWaveHeader && !*ppWaveHeader)
            {
                if (dwLength < sizeof(WAVEFORMAT))
                {
                    goto exit;      // not a WAV
                }

                *ppWaveHeader = (WAVEFORMATEX *)pdw;

                if ((!ppbWaveData || *ppbWaveData) &&
                    (!pcbWaveSize || *pcbWaveSize))
                {                 
                    return TRUE;
                }
            }
            break;

        case mmioFOURCC('d', 'a', 't', 'a'):
            if ((ppbWaveData && !*ppbWaveData) ||
                (pcbWaveSize && !*pcbWaveSize))
            {
                if (ppbWaveData)
                {
                    *ppbWaveData = (LPBYTE)pdw;
                }

                if (pcbWaveSize)
                {
                    *pcbWaveSize = dwLength;
                }

                if (!ppWaveHeader || *ppWaveHeader)
                {     
                    return TRUE;
                }
            }
            break;
        }

        pdw = (DWORD *)((BYTE *)pdw + ((dwLength+1)&~1));
    }

exit:
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//

CWavePlayer::CWavePlayer()
{
    m_hWaveOut = NULL;
}

//////////////////////////////////////////////////////////////////////////////
//

CWavePlayer::~CWavePlayer()
{
    //
    // We should have closed the wave device by now.
    //

    _ASSERTE( m_hWaveOut == NULL );
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::Initialize(void)
{
    LOG((RTC_TRACE, "CWavePlayer::Initialize - enter"));
    
    int i;

    //
    // It's wasteful to initialize twice, but it won't break anything.
    //

    _ASSERTE( m_fInitialized == FALSE );

    //
    // Read all wave data resources.
    // We ignore the size and the wave header -- since these are our own
    // resources, we do not expect any surprises.
    //

    BOOL fResult;

    //
    // For each wave
    //

    for ( i = 0; i < NUM_WAVES; i ++ )
    {
        //
        // Read the wave resource for this tone.
        //

       fResult = DSGetWaveResource(
            _Module.GetResourceInstance(),   // HMODULE hModule,
            (LPCTSTR)UlongToPtr(IDR_WAV_TONE + i),    // LPCTSTR lpName,
            NULL,                            // WAVEFORMATEX **ppWaveHeader,
            &m_lpWaveform[i],                // BYTE **ppbWaveData,
            &m_dwWaveformSize[i]             // DWORD *pcbWaveSize
            );

        if ( fResult == FALSE )
        { 
            LOG((RTC_ERROR, "CWavePlayer::Initialize - DSGetWaveResource failed"));
            
            return E_FAIL;
        }
    }

    //
    // We can now go ahead with the other methods.
    //

    m_fInitialized = TRUE;

    LOG((RTC_TRACE, "CWavePlayer::Initialize - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::PlayWave(WAVE enWave)
{
    LOG((RTC_TRACE, "CWavePlayer::PlayWave - enter"));
    
    MMRESULT mmresult;

    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_hWaveOut == NULL )
    {
        _ASSERTE( FALSE );
        return E_FAIL;
    }
     
    //
    // Reset the wave device to flush out any pending buffers.
    //

    mmresult = waveOutReset( m_hWaveOut );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        LOG((RTC_ERROR, "CWavePlayer::PlayWave - "
                            "waveOutReset failed 0x%lx", mmresult));
        
        return E_FAIL;
    }

    //
    // Construct a wave header structure that will indicate what to play
    // in waveOutWrite.
    //
 
    ZeroMemory( & m_WaveHeader, sizeof( m_WaveHeader ) );

    m_WaveHeader.lpData          = (LPSTR)m_lpWaveform[(long)enWave];
    m_WaveHeader.dwBufferLength  = m_dwWaveformSize[(long)enWave];
    m_WaveHeader.dwFlags         = 0;
    m_WaveHeader.dwLoops         = (DWORD) 0;

    //
    // Submit the data to the wave device. The wave header indicated that
    // we want to loop. Need to prepare the header first, but it can
    // only be prepared after the device has been opened.
    //

    mmresult = waveOutPrepareHeader(m_hWaveOut,
                                    & m_WaveHeader,
                                    sizeof(WAVEHDR)
                                    );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    mmresult = waveOutWrite(m_hWaveOut,
                            & m_WaveHeader,
                            sizeof(WAVEHDR)
                            );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        LOG((RTC_ERROR, "CWavePlayer::PlayWave - "
                            "waveOutWrite failed 0x%lx", mmresult));
        
        return E_FAIL;
    }

    LOG((RTC_TRACE, "CWavePlayer::PlayWave - exit S_OK"));
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::StopWave()
{
    LOG((RTC_TRACE, "CWavePlayer::StopWave - enter"));

    MMRESULT mmresult;

    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_hWaveOut == NULL )
    {
        _ASSERTE( FALSE );
        return E_FAIL;
    } 

    //
    // Reset the wave device.
    //

    mmresult = waveOutReset( m_hWaveOut );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        LOG((RTC_ERROR, "CWavePlayer::StopWave - "
                            "waveOutReset failed 0x%lx", mmresult));
                            
        return E_FAIL;
    }  

    LOG((RTC_TRACE, "CWavePlayer::StopWave - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::OpenWaveDevice(
    long lWaveID
    )
{
    LOG((RTC_TRACE, "CWavePlayer::OpenWaveDevice - enter"));
    
    MMRESULT mmresult; 

    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    //
    // We expect that the wave device will not be opened twice. This is
    // dependent on the calling code.
    //

    _ASSERTE( m_hWaveOut == NULL );

    //
    // Open the wave device. Here we specify a hard-coded audio format.
    //

    WAVEFORMATEX waveFormat;

    waveFormat.wFormatTag      = WAVE_FORMAT_PCM; // linear PCM
    waveFormat.nChannels       = 1;               // mono
    waveFormat.nSamplesPerSec  = 8000;            // 8 KHz
    waveFormat.wBitsPerSample  = 16;              // 16-bit samples
    waveFormat.nBlockAlign     = waveFormat.nChannels * waveFormat.wBitsPerSample / 8;
    waveFormat.nAvgBytesPerSec = waveFormat.nSamplesPerSec *  waveFormat.nBlockAlign;
    waveFormat.cbSize          = 0;               // no extra format info

    mmresult = waveOutOpen(& m_hWaveOut,        // returned handle
                           lWaveID,             // which device to use
                           &waveFormat,         // wave format to use
                           0,                   // callback function pointer
                           0,                   // callback instance data
                           WAVE_FORMAT_DIRECT   // we don't want ACM
                           );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        LOG((RTC_ERROR, "CWavePlayer::OpenWaveDevice - "
                            "waveOutOpen failed 0x%lx", mmresult));
                            
        m_hWaveOut = NULL;
        return E_FAIL;
    }

    LOG((RTC_TRACE, "CWavePlayer::OpenWaveDevice - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

void CWavePlayer::CloseWaveDevice(void)
{
    LOG((RTC_TRACE, "CWavePlayer::CloseWaveDevice - enter"));
    
    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
    }

    if ( m_hWaveOut != NULL )
    {
        waveOutReset( m_hWaveOut );
        waveOutClose( m_hWaveOut );

        m_hWaveOut = NULL;
    }

    LOG((RTC_TRACE, "CWavePlayer::CloseWaveDevice - exit"));
}

//////////////////////////////////////////////////////////////////////////////
//

BOOL CWavePlayer::IsWaveDeviceOpen(void)
{        
    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
    }

    BOOL fResult = ( m_hWaveOut != NULL );

    LOG((RTC_TRACE, "CWavePlayer::IsWaveDeviceOpen - %s", fResult ? "TRUE" : "FALSE" ));

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__971134B4_012C_4FC2_B7EB_6CD55D5EE1B0__INCLUDED_)
#define AFX_STDAFX_H__971134B4_012C_4FC2_B7EB_6CD55D5EE1B0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <control.h>
#include <RTCCore.h>

#include "rtcerr.h"
#include "rtcsip.h"
#include "RTCLog.h"
#include "RTCMem.h"
#include "RTCReg.h"
#include "RTCUtils.h"
#include "RTCWaves.h"
#include "RTCConnect.h"
#include "RTCClient.h"
#include "RTCSession.h"
#include "RTCParticipant.h"
#include "RTCBuddy.h"
#include "RTCWatcher.h"
#include "RTCProfile.h"
#include "RTCEnum.h"
#include "RTCColl.h"
#include "RTCEvents.h"
#include "RTCURI.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__971134B4_012C_4FC2_B7EB_6CD55D5EE1B0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\genkey\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	genkey.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\genkey\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__E1A62BB8_7960_40A9_9860_3DD97CD5A656__INCLUDED_)
#define AFX_STDAFX_H__E1A62BB8_7960_40A9_9860_3DD97CD5A656__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E1A62BB8_7960_40A9_9860_3DD97CD5A656__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\stress\rtcstress.h ===
#ifndef __RTCTEST__
#define __RTCTEST__

#define WM_CORE_EVENT      WM_USER+100
#define WM_TEST            WM_USER+101
#define WM_UPDATE          WM_USER+102

#define TID_TIMER          100

class CRTCEvents :
	public IRTCEventNotification
{
private:
    DWORD m_dwRefCount;
    DWORD m_dwCookie;
    HWND  m_hWnd;

public:
    CRTCEvents() : m_dwRefCount(NULL),
                   m_dwCookie(NULL),
                   m_hWnd(NULL)
    {
    }

    /////////////////////////////////////////////
    //
    // QueryInterface
    // 

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_IRTCEventNotification)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    /////////////////////////////////////////////
    //
    // AddRef
    // 

	ULONG STDMETHODCALLTYPE AddRef()
    {
        m_dwRefCount++;
        return m_dwRefCount;
    }
    
    /////////////////////////////////////////////
    //
    // Release
    // 

	ULONG STDMETHODCALLTYPE Release()
    {
        m_dwRefCount--;

        if ( 0 == m_dwRefCount)
        {
            delete this;
        }

        return 1;
    }

    /////////////////////////////////////////////
    //
    // Advise
    // 

    HRESULT Advise(IRTCClient * pClient, HWND hWnd)
    {    
	    IConnectionPointContainer * pCPC;
	    IConnectionPoint * pCP;

	    HRESULT hr = pClient->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	    if (SUCCEEDED(hr))
        {
		    hr = pCPC->FindConnectionPoint(IID_IRTCEventNotification, &pCP);

            pCPC->Release();

            if (SUCCEEDED(hr))
            {
		        hr = pCP->Advise(this, &m_dwCookie);

                pCP->Release();
            }
        }

        m_hWnd = hWnd;

	    return hr;
    }

    /////////////////////////////////////////////
    //
    // Unadvise
    // 

    HRESULT Unadvise(IRTCClient * pClient)
    {
	    IConnectionPointContainer * pCPC;
	    IConnectionPoint * pCP;

	    HRESULT hr = pClient->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	    if (SUCCEEDED(hr))
        {
		    hr = pCPC->FindConnectionPoint(IID_IRTCEventNotification, &pCP);

            pCPC->Release();

            if (SUCCEEDED(hr))
            {
		        hr = pCP->Unadvise(m_dwCookie);

                pCP->Release();
            }
        }

	    return hr;
    }

    /////////////////////////////////////////////
    //
    // Event
    // 

	HRESULT STDMETHODCALLTYPE Event(
        RTC_EVENT enEvent,
        IDispatch * pDisp
        )
    {
        pDisp->AddRef();

        PostMessage( m_hWnd, WM_CORE_EVENT, (WPARAM)enEvent, (LPARAM)pDisp );

        return S_OK;
    }
};

/////////////////////////////////////////////

template <class T>
class CRTCObjectArray
{
private:
    
	T           * m_aT;
	int           m_nSize;
    int           m_nUsed;

public:
	CRTCObjectArray() : m_aT(NULL), m_nSize(0), m_nUsed(0){}

	~CRTCObjectArray()
	{}

	int GetSize() const
	{
		return m_nUsed;
	}
    
	BOOL Add(T& t)
	{
		if(m_nSize == m_nUsed)
		{
			T       * aT;
            int       nNewSize;
                    
			nNewSize = (m_nSize == 0) ? 1 : (m_nSize * 2);
            
			aT = (T*) malloc (nNewSize * sizeof(T));
            
			if(aT == NULL)
            {
				return FALSE;
            }

            CopyMemory(
                       aT,
                       m_aT,
                       m_nUsed * sizeof(T)
                      );

            free( m_aT );

            m_aT = aT;
            
			m_nSize = nNewSize;
		}

        m_aT[m_nUsed] = t;

        if(t)
        {
            t->AddRef();
        }

		m_nUsed++;
        
		return TRUE;
	}
    
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
        
		if(nIndex == -1)
			return FALSE;
        
		return RemoveAt(nIndex);
	}
    
	BOOL RemoveAt(int nIndex)
	{
        T t = m_aT[nIndex];
        m_aT[nIndex] = NULL;

        if(t)
        {
            t->Release();
        }

        if(nIndex != (m_nUsed - 1))
        {
			MoveMemory(
                       (void*)&m_aT[nIndex],
                       (void*)&m_aT[nIndex + 1],
                       (m_nUsed - (nIndex + 1)) * sizeof(T)
                      );
        }
        

		m_nUsed--;
        
		return TRUE;
	}
    
	void Shutdown()
	{
		if( NULL != m_aT )
		{
            int     index;

            for (index = 0; index < m_nUsed; index++)
            {
                T t = m_aT[index];
                m_aT[index] = NULL;

                if(t)
                {
                    t->Release();
                }
            }

			free(m_aT);
            
			m_aT = NULL;
			m_nUsed = 0;
			m_nSize = 0;
		}
	}
    
	T& operator[] (int nIndex) const
	{
		return m_aT[nIndex];
	}
    
	int Find(T& t) const
	{
		for(int i = 0; i < m_nUsed; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};

#endif //__RTCTEST__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\test\rtctest.cpp ===
#define UNICODE
#include <windows.h>
#include <RTCCore.h>
#include <rtcerr.h>
#include <stdio.h>

#include "RTCTest.h"

IRTCClient  * g_pClient = NULL;
IRTCSession * g_pSession = NULL;
CRTCEvents  * g_pEvents = NULL;

/////////////////////////////////////////////
//
// WndProc
// 

LRESULT CALLBACK WndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hr;

    switch ( uMsg )
    {
    case WM_CREATE:
        {
            hr = CoCreateInstance(
                                  CLSID_RTCClient,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IRTCClient,
                                  (LPVOID *)&g_pClient
                                 );

            if ( FAILED(hr) )
            {
                printf("CoCreateInstance failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->Initialize();

            if ( FAILED(hr) )
            {
                printf("Initialize failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->SetPreferredMediaTypes( 
                         RTCMT_AUDIO_SEND |
                         RTCMT_AUDIO_RECEIVE |
                         RTCMT_VIDEO_SEND |
                         RTCMT_VIDEO_RECEIVE,
                         VARIANT_FALSE
                         );

            if ( FAILED(hr) )
            {
                printf("SetPreferredMediaTypes failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->put_EventFilter( 
                         RTCEF_SESSION_STATE_CHANGE |
                         RTCEF_MEDIA |
                         RTCEF_CLIENT
                         );

            if ( FAILED(hr) )
            {
                printf("put_EventFilter failed 0x%lx\n", hr);

                return -1;
            }


            g_pEvents = new CRTCEvents;

            hr = g_pEvents->Advise( g_pClient, hWnd );

            if ( FAILED(hr) )
            {
                printf("Advise failed 0x%lx\n", hr);

                return -1;
            }
    
            return 0;
        }

    case WM_DESTROY:        
        {
            printf("Exiting...\n");

            if ( g_pEvents )
            {
                hr = g_pEvents->Unadvise( g_pClient );

                if ( FAILED(hr) )
                {
                    printf("Unadvise failed 0x%lx\n", hr);
                }

                g_pEvents = NULL;
            }

            if ( g_pSession )
            {
                g_pSession->Release();
                g_pSession = NULL;
            }
            
            if ( g_pClient )
            {
                hr = g_pClient->Shutdown();

                if ( FAILED(hr) )
                {
                    printf("Shutdown failed 0x%lx\n", hr);
                }

                g_pClient->Release();
                g_pClient = NULL;
            }

            PostQuitMessage(0);

            return 0;
        }

    case WM_TIMER:
        {
            if ( wParam == TID_CALL_TIMER )
            {
                KillTimer( hWnd, TID_CALL_TIMER );

                if ( g_pSession )
                {
                    hr = g_pSession->Terminate( RTCTR_NORMAL );

                    if ( FAILED(hr) )
                    {
                        printf("Terminate failed 0x%lx\n", hr);

                        DestroyWindow(hWnd);
                    }
                }
            }

            return 0;
        }

    case WM_CORE_EVENT:
        {
            switch ( wParam )
            {
                case RTCE_SESSION_STATE_CHANGE:
                    {
                        IRTCSessionStateChangeEvent * pSSC;
                        IRTCSession                 * pSession;
                        RTC_SESSION_STATE             enSS;
                        IDispatch                   * pDisp;
                        long                          lStatus;
                        BSTR                          bstrStatus;
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCSessionStateChangeEvent,
                                               (void **)&pSSC
                                             );

                        pDisp->Release();
                                       
                        hr = pSSC->get_State(&enSS);

                        if ( FAILED(hr) )
                        {
                            printf("get_State failed 0x%lx\n", hr);

                            pSSC->Release();
                            return 0;
                        }

                        hr = pSSC->get_StatusCode(&lStatus);

                        if ( FAILED(hr) )
                        {
                            printf("get_StatusCode failed 0x%lx\n", hr);

                            pSSC->Release();
                            return 0;
                        }

                        hr = pSSC->get_StatusText(&bstrStatus);

                        if ( FAILED(hr) && (hr != E_FAIL))
                        {
                            printf("get_StatusText failed 0x%lx\n", hr);
                            
                            pSSC->Release();
                            return 0;
                        }

                        if (HRESULT_FACILITY(lStatus) == FACILITY_SIP_STATUS_CODE)
                        {
                            printf("Status: %d %ws\n", HRESULT_CODE(lStatus), bstrStatus);
                        }

                        SysFreeString( bstrStatus );

                        hr = pSSC->get_Session(&pSession);

                        if ( FAILED(hr) )
                        {
                            printf("get_Session failed 0x%lx\n", hr);

                            pSSC->Release();
                            return 0;
                        }

                        if ( (g_pSession == pSession) ||
                             (enSS == RTCSS_INCOMING) )
                        {
                            switch(enSS)
                            {
                                case RTCSS_IDLE:
                                    printf("IDLE [0x%lx]\n", pSession);
                                    break;

                                case RTCSS_INPROGRESS:
                                    printf("INPROGRESS [0x%lx]\n", pSession);
                                    break;

                                case RTCSS_INCOMING:
                                    printf("INCOMING [0x%lx]\n", pSession);

                                    if ( g_pSession ) g_pSession->Release();

                                    g_pSession = pSession;
                                    g_pSession->AddRef();

                                    hr = g_pSession->Answer();

                                    if ( FAILED(hr) )
                                    {
                                        printf("Answer failed 0x%lx\n", hr);

                                        DestroyWindow(hWnd);
                                    }

                                    break;

                                case RTCSS_CONNECTED:
                                    printf("CONNECTED [0x%lx]\n", pSession);

                                    SetTimer( hWnd, TID_CALL_TIMER, 30000, NULL);

                                    break;

                                case RTCSS_DISCONNECTED:
                                    printf("DISCONNECTED [0x%lx]\n", pSession);

                                    if ( g_pSession ) g_pSession->Release();
                                    g_pSession = NULL;

                                    hr = g_pClient->PrepareForShutdown();

                                    if ( FAILED(hr) )
                                    {
                                        printf("PrepareForShutdown failed 0x%lx\n", hr);

                                        DestroyWindow(hWnd);
                                    }
                                    break;
                            }
                        }

                        pSSC->Release();
                        pSession->Release();
                    }            
                    break;  
                    
                case RTCE_MEDIA:
                    {
                        IRTCMediaEvent        * pM;
                        IDispatch             * pDisp;
                        RTC_MEDIA_EVENT_TYPE	enEventType; 
                        long                    lMediaType;
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCMediaEvent,
                                               (void **)&pM
                                             );

                        pDisp->Release();
                                       
                        hr = pM->get_EventType(&enEventType);

                        if ( FAILED(hr) )
                        {
                            printf("get_EventType failed 0x%lx\n", hr);

                            pM->Release();
                            return 0;
                        }

                        hr = pM->get_MediaType(&lMediaType);

                        if ( FAILED(hr) )
                        {
                            printf("get_MediaType failed 0x%lx\n", hr);

                            pM->Release();
                            return 0;
                        }
                        
                        IVideoWindow * pVid = NULL;
                           
                        if ( lMediaType == RTCMT_VIDEO_SEND )
                        {
                            hr = g_pClient->get_IVideoWindow(RTCVD_PREVIEW, &pVid);
                        }
                        else if ( lMediaType == RTCMT_VIDEO_RECEIVE )
                        {
                            hr = g_pClient->get_IVideoWindow(RTCVD_RECEIVE, &pVid);
                        }

                        if ( (pVid != NULL) && SUCCEEDED(hr) )
                        {
                            if ( enEventType == RTCMET_STARTED )
                            {
                                pVid->put_Visible( -1 );
                            }
                            else if ( enEventType == RTCMET_STOPPED )
                            {
                                pVid->put_Visible( 0 );
                            }

                            pVid->Release();
                        }                     
                        
                        pM->Release();
                    }            
                    break;  
                    
                case RTCE_CLIENT:
                    {
                        IRTCClientEvent       * pC;
                        IDispatch             * pDisp;
                        RTC_CLIENT_EVENT_TYPE	enEventType; 
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCClientEvent,
                                               (void **)&pC
                                             );

                        pDisp->Release();
                                       
                        hr = pC->get_EventType(&enEventType);

                        if ( FAILED(hr) )
                        {
                            printf("get_EventType failed 0x%lx\n", hr);

                            pC->Release();
                            return 0;
                        }

                        if ( enEventType == RTCCET_ASYNC_CLEANUP_DONE )
                        {
                            DestroyWindow(hWnd);
                        }
                        
                        pC->Release();
                    }            
                    break; 
            }

            return 0;
        }

    case WM_CREATE_SESSION:
        {
            printf("Calling %ws...\n", (BSTR)wParam);

            hr = g_pClient->CreateSession( RTCST_PC_TO_PC, NULL, NULL, 0, &g_pSession );

            if ( FAILED(hr) )
            {
                printf("CreateSession failed 0x%lx\n", hr);

                DestroyWindow(hWnd);
            }

            hr = g_pSession->AddParticipant( (BSTR)wParam, NULL, NULL);

            if ( FAILED(hr) )
            {
                printf("AddParticipant failed 0x%lx\n", hr);

                DestroyWindow(hWnd);
            }

            SysFreeString( (BSTR)wParam );

            return 0;
        }

    case WM_LISTEN:
        {
            printf("Listening...\n");

            hr = g_pClient->put_ListenForIncomingSessions( RTCLM_BOTH );

            if ( FAILED(hr) )
            {
                printf("put_ListenForIncomingSessions failed 0x%lx\n", hr);

                DestroyWindow(hWnd);
            }

            return 0;
        }


    default:
        return DefWindowProc( hWnd, uMsg, wParam, lParam );
    }

    return 0;
}

/////////////////////////////////////////////
//
// Main
// 

int _cdecl main(int argc, char* argv[])
{
    WNDCLASS wc;
    HWND     hWnd;
    MSG      msg;
    HRESULT  hr;

    hr =  CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if ( FAILED(hr) )
    {
        printf("CoInitializeEx failed 0x%lx\n", hr);

        return 0;
    }
    
    ZeroMemory(&wc, sizeof(WNDCLASS));

    wc.lpfnWndProc = WndProc;
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpszClassName = TEXT("RTCTestClass");
    
    if ( !RegisterClass( &wc ) )
    {
        printf("RegisterClass failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    }
    
    hWnd = CreateWindow(
            TEXT("RTCTestClass"),
            TEXT("RTCTest"),
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            NULL,
            NULL,
            GetModuleHandle(NULL),
            NULL
            );

    if ( hWnd == NULL )
    {
        printf("CreateWindow failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    }           

    if ( argc > 1 )
    {
        BSTR bstrURI;
        WCHAR szURI[256];

        MultiByteToWideChar( CP_ACP, 0, argv[1], -1, szURI, 256 );

        bstrURI = SysAllocString(szURI);

        PostMessage( hWnd, WM_CREATE_SESSION, (WPARAM)bstrURI, 0 );
    }
    else
    {
        PostMessage( hWnd, WM_LISTEN, 0, 0 );
    }

    while ( GetMessage( &msg, NULL, 0, 0 ) > 0 )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\genkey\genkey.cpp ===
// genkey.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

PWSTR 
base64encode(
    PBYTE pbBufInput, 
    long nBytes
    );

#define MASTER_KEY   L"Microsoft Real-Time Communications authorized domain"

BYTE    OurSecretKeyBlob[1024]; 

#define KEY_CONTAINER   L"Microsoft.RTCContainer"


int __cdecl wmain(int argc, WCHAR* argv[])
{
    DWORD   dwError;
    HCRYPTPROV  hProv = NULL;
    HCRYPTKEY   hKey = NULL;
    HANDLE hFile = NULL;
    DWORD      dwKeyLength = 0;
    PWSTR      pszName;

    // open the private key file
    pszName = argc>1 ? argv[1] : L"rtcpriv.bin";

    hFile = CreateFile(
        pszName,                         // file name
        GENERIC_READ,                      // access mode
        0,                          // share mode
        NULL, // SD
        OPEN_EXISTING,                // how to create
        FILE_ATTRIBUTE_NORMAL,                 // file attributes
        NULL);

    if(hFile == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();

        fwprintf(stderr, L"Error %x returned by CreateFile\n", dwError);

        return dwError;
    }

    if(!ReadFile(
        hFile,
        OurSecretKeyBlob,
        sizeof(OurSecretKeyBlob),
        &dwKeyLength,
        NULL))
    {
        dwError = GetLastError();

        fwprintf(stderr, L"Error %x returned by ReadFile\n", dwError);
        CloseHandle(hFile);

        return dwError;
    }
    
    CloseHandle(hFile);

    // delete any existing container
    CryptAcquireContext(
        &hProv,
        KEY_CONTAINER,
        MS_DEF_PROV,
        PROV_RSA_FULL,
        CRYPT_DELETEKEYSET);

    // initialize crypto, create a new keyset
    if(!CryptAcquireContext(
        &hProv,
        KEY_CONTAINER,
        MS_DEF_PROV,
        PROV_RSA_FULL,
        CRYPT_NEWKEYSET | CRYPT_SILENT))
    {
        dwError = GetLastError();

        fwprintf(stderr, L"Error %x returned by CryptAcquireContext\n", dwError);

        return dwError;
    }

    // import the key
    if(!CryptImportKey(
        hProv,
        OurSecretKeyBlob,
        dwKeyLength,
        NULL,
        0,
        &hKey))
    {
        dwError = GetLastError();

        fwprintf(stderr, L"Error %x returned by CryptImportKey\n", dwError);

        CryptReleaseContext(hProv, 0);

        return dwError;
    }

    WCHAR   szLine[1024];  // hope it's enough

    // loop
    while(NULL != _getws(szLine))
    {
        HCRYPTHASH  hHash = NULL;
        WCHAR   szText[2048];
        BYTE    Signature[0x100]; // should be enough
        DWORD   dwSignatureLength = sizeof(Signature);
        
        // create a hash
        if(!CryptCreateHash(
            hProv,
            CALG_MD5,
            NULL,
            0,
            &hHash))

        {
            dwError = GetLastError();

            fwprintf(stderr, L"Error %x returned by CryptCreateHash\n", dwError);

            CryptDestroyKey(hKey);        
            CryptReleaseContext(hProv, 0);
    
            return dwError;
        }

        // create the text
        swprintf(szText, L"%s:%s", MASTER_KEY, szLine);

        // Hash it
        if(!CryptHashData(
            hHash,
            (BYTE *)szText,
            wcslen(szText) * sizeof(WCHAR), // length in bytes, without the NULL
            0))
        {
            dwError = GetLastError();
            
            fwprintf(stderr, L"Error %x returned by CryptHashData\n", dwError);
            
            CryptDestroyHash(hHash);
            CryptDestroyKey(hKey);        
            CryptReleaseContext(hProv, 0);

            return dwError;
        }

        // sign the hash
        if(!CryptSignHash(
            hHash,
            AT_SIGNATURE,
            NULL,
            0,
            Signature,
            &dwSignatureLength))

        {
            dwError = GetLastError();
            
            fwprintf(stderr, L"Error %x returned by CryptGetHashParam\n", dwError);
            
            CryptDestroyKey(hKey);        
            CryptDestroyHash(hHash);
            CryptReleaseContext(hProv, 0);

            return dwError;
        }
        
        // release the hash object and the key
        CryptDestroyHash(hHash);
        hHash = NULL;

        // convert the hash value to base64
        PWSTR pszStringValue = NULL;

        pszStringValue = base64encode(Signature, dwSignatureLength);
        if(!pszStringValue)
        {
            fwprintf(stderr, L"Out of memory\n");
         
            CryptDestroyKey(hKey);       
            CryptReleaseContext(hProv, 0);

            return ERROR_OUTOFMEMORY;
        }
        
        wprintf(L"%s\n", pszStringValue);

        LocalFree(pszStringValue);
    }

    CryptDestroyKey(hKey);       
    CryptReleaseContext(hProv, 0);

	return 0;
}



//
// the map for the encoder, according to RFC 1521
//
WCHAR _six2pr64[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};


//-------------------------------------------------------------------------------------------
// Function:     base64encode()
//
// Description:  base-64 encode a string of data
//
// Arguments:    bufin          -pointer to data to encode
//               nbytes         -number of bytes to encode (do not include the trailing '\0'
//                                                               in this measurement if it is a string.)
//
// Return Value: Returns '\0' terminated string if successful; otherwise NULL is returned.
//-------------------------------------------------------------------------------------------
PWSTR 
base64encode(
    PBYTE pbBufInput, 
    long nBytes
    )
{
    PWSTR pszOut = NULL;
    PWSTR pszReturn = NULL;
    long i;
    long OutBufSize;
    PWSTR six2pr = _six2pr64;
    PBYTE pbBufIn = NULL;
    PBYTE pbBuffer = NULL;
    DWORD nPadding;
    HRESULT hr;

    //  
    // Size of input buffer * 133%
    //  
    OutBufSize = nBytes + ((nBytes + 3) / 3) + 5; 

    //
    //  Allocate buffer with 133% of nBytes
    //
    pszOut = (PWSTR)LocalAlloc(LPTR, (OutBufSize + 1)*sizeof(WCHAR));
    if (pszOut == NULL)
    {
        hr = E_OUTOFMEMORY;
        return NULL;
    }
    pszReturn = pszOut;

    nPadding = 3 - (nBytes % 3);
    if (nPadding == 3) {
        pbBufIn = pbBufInput;
    }
    else {
        pbBuffer = (PBYTE)LocalAlloc(LPTR, nBytes + nPadding);
        if (pbBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
            LocalFree(pszOut);
            return NULL;
        }
        pbBufIn = pbBuffer;
        memcpy(pbBufIn,pbBufInput,nBytes);
        while (nPadding) {
            pbBufIn[nBytes+nPadding-1] = 0;
            nPadding--;
        }
    }
    

    //
    // Encode everything
    //  
    for (i=0; i<nBytes; i += 3) {
        *(pszOut++) = six2pr[*pbBufIn >> 2];                                     // c1 
        *(pszOut++) = six2pr[((*pbBufIn << 4) & 060) | ((pbBufIn[1] >> 4) & 017)]; // c2
        *(pszOut++) = six2pr[((pbBufIn[1] << 2) & 074) | ((pbBufIn[2] >> 6) & 03)];// c3
        *(pszOut++) = six2pr[pbBufIn[2] & 077];                                  // c4 
        pbBufIn += 3;
    }

    //
    // If nBytes was not a multiple of 3, then we have encoded too
    // many characters.  Adjust appropriately.
    //
    if (i == nBytes+1) {
        // There were only 2 bytes in that last group 
        pszOut[-1] = '=';
    } 
    else if (i == nBytes+2) {
        // There was only 1 byte in that last group 
        pszOut[-1] = '=';
        pszOut[-2] = '=';
    }

    *pszOut = '\0';

    LocalFree(pbBuffer);
    
    return pszReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\stress\rtcstress.cpp ===
#define UNICODE
#include <windows.h>
#include <RTCCore.h>
#include <stdio.h>

#include "RTCStress.h"

IRTCClient  * g_pClient = NULL;
CRTCEvents  * g_pEvents = NULL;
IRTCClientProvisioning * g_pProv = NULL;

CRTCObjectArray<IRTCProfile *> g_ProfileArray;
int g_nProfilesEnabled = 0;
int g_nProfilesUpdated = 0;
int g_nProfilesDisabled = 0;
int g_nProfilesRegistering = 0;
int g_nProfilesRegistered = 0;
int g_nProfilesUnregistering = 0;
int g_nProfilesUnregistered = 0;
int g_nProfilesReject = 0;
int g_nProfilesError = 0;

HWND g_hEditWnd = NULL;
BOOL g_bExit = FALSE;

/////////////////////////////////////////////
//
// WndProc
// 

LRESULT CALLBACK WndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hr;

    switch ( uMsg )
    {
    case WM_CREATE:
        {
            hr = CoCreateInstance(
                                  CLSID_RTCClient,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IRTCClient,
                                  (LPVOID *)&g_pClient
                                 );

            if ( FAILED(hr) )
            {
                printf("CoCreateInstance failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->Initialize();

            if ( FAILED(hr) )
            {
                printf("Initialize failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->put_EventFilter( 
                         RTCEF_REGISTRATION_STATE_CHANGE |
                         RTCEF_CLIENT
                         );

            if ( FAILED(hr) )
            {
                printf("put_EventFilter failed 0x%lx\n", hr);

                return -1;
            }


            g_pEvents = new CRTCEvents;

            hr = g_pEvents->Advise( g_pClient, hWnd );

            if ( FAILED(hr) )
            {
                printf("Advise failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->QueryInterface( IID_IRTCClientProvisioning, (void**)&g_pProv );

            if ( FAILED(hr) )
            {
                printf("QueryInterface failed 0x%lx\n", hr);

                return -1;
            }            

            PostMessage( hWnd, WM_TEST, 0, 0 );
    
            return 0;
        }

    case WM_DESTROY:        
        {
            printf("Exiting...\n");

            if ( g_pEvents )
            {
                hr = g_pEvents->Unadvise( g_pClient );

                if ( FAILED(hr) )
                {
                    printf("Unadvise failed 0x%lx\n", hr);
                }

                delete g_pEvents;
            }

            if ( g_pProv )
            {
                g_pProv->Release();
            }
            
            if ( g_pClient )
            {
                hr = g_pClient->Shutdown();

                if ( FAILED(hr) )
                {
                    printf("Shutdown failed 0x%lx\n", hr);
                }

                g_pClient->Release();
            }

            PostQuitMessage(0);

            return 0;
        }

    case WM_TEST:
        {
            switch ( rand() & 3 )
            {
            case 0: // enable a profile
                {
                    int n = rand();                    

                    WCHAR szXML[1000];
                    _snwprintf( szXML, 1000, L"<provision key=\"%x\" name=\"Amun\"><provider name=\"Amun\" homepage=\"http://winrtc/phoenix\"><data>test</data></provider><client name=\"Phoenix\" banner=\"false\"/><user uri=\"sip:rtctest@microsoft.com\"/><accesscontrol domain=\"ntdev.microsoft.com\" sig=\"43r8mXTFvSMBZHajABKbd5ee1vHXUDqJIUxhsmtF67UZZryIolEdp/1qs2oiTKbKrAlAsIzOoCL75lTzZSbacA==\" /><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"registrar\"/><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"proxy\"><session party=\"first\" type=\"pc2pc\"/><session party=\"first\" type=\"pc2ph\"/><session party=\"first\" type=\"im\"/></sipsrv></provision>", n );
                   
                    IRTCProfile * pProfile;

                    BSTR bstrXML = SysAllocString( szXML );
                    hr = g_pProv->CreateProfile( bstrXML, &pProfile );

                    SysFreeString( bstrXML );

                    if ( FAILED(hr) )
                    {
                        printf("CreateProfile failed 0x%lx\n", hr);

                        DebugBreak();

                        break;
                    }

                    printf("Enabling profile 0x%x...\n", pProfile);

                    hr = g_pProv->EnableProfile( pProfile, RTCRF_REGISTER_ALL );

                    if ( FAILED(hr) )
                    {
                        printf("EnableProfile failed 0x%lx\n", hr);

                        DebugBreak();

                        break;
                    }

                    g_ProfileArray.Add(pProfile);
                    g_nProfilesEnabled++;

                    pProfile->Release();     
                }
                break;

            case 1: // update a profile
                {
                    if ( g_ProfileArray.GetSize() == 0 ) break;

                    int index = rand() % g_ProfileArray.GetSize();

                    BSTR bstrXML;
                                     
                    hr = g_ProfileArray[index]->get_XML( &bstrXML );

                    if ( FAILED(hr) )
                    {
                        printf("get_XML failed 0x%lx\n", hr);

                        DebugBreak();

                        break;
                    }

                    IRTCProfile * pProfile;

                    hr = g_pProv->CreateProfile( bstrXML, &pProfile );

                    SysFreeString( bstrXML );

                    if ( FAILED(hr) )
                    {
                        printf("CreateProfile failed 0x%lx\n", hr);

                        DebugBreak();

                        break;
                    }

                    printf("Updating profile 0x%x -> 0x%x...\n", g_ProfileArray[index], pProfile);

                    hr = g_pProv->EnableProfile( pProfile, RTCRF_REGISTER_ALL );

                    if ( FAILED(hr) )
                    {
                        printf("EnableProfile failed 0x%lx\n", hr);

                        DebugBreak();

                        break;
                    }

                    g_ProfileArray.RemoveAt(index);
                    g_ProfileArray.Add(pProfile);
                    g_nProfilesUpdated++;

                    pProfile->Release();     
                }

            case 2: // disable a profile
                {
                    if ( g_ProfileArray.GetSize() == 0 ) break;

                    int index = rand() % g_ProfileArray.GetSize();

                    printf("Disable profile 0x%x...\n", g_ProfileArray[index]);

                    hr = g_pProv->DisableProfile( g_ProfileArray[index] );

                    if ( FAILED(hr) )
                    {
                        printf("DisableProfile failed 0x%lx\n", hr);

                        DebugBreak();

                        break;
                    }

                    g_ProfileArray.RemoveAt(index);
                    g_nProfilesDisabled++;  
                }
            }

            SendMessage( hWnd, WM_UPDATE, 0, 0 );

            SetTimer( hWnd, TID_TIMER, 100, NULL);

            return 0;
        }

    case WM_UPDATE:
        {
            WCHAR szText[1000];
            _snwprintf( szText, 1000, L"Enabled = %d\nUpdated = %d\nDisabled = %d\n\nRegistering = %d\nRegistered = %d\nUnregistering = %d\nUnregistered = %d\nReject = %d\nError = %d",
                g_nProfilesEnabled,
                g_nProfilesUpdated,
                g_nProfilesDisabled,
                g_nProfilesRegistering,
                g_nProfilesRegistered,
                g_nProfilesUnregistering,
                g_nProfilesUnregistered,
                g_nProfilesReject,
                g_nProfilesError);

            SetWindowTextW( g_hEditWnd, szText );

            return 0;
        }

    case WM_TIMER:
        {
            switch ( wParam )
            {
            case TID_TIMER:
                {
                    KillTimer( hWnd, TID_TIMER );

                    if ( !g_bExit ) PostMessage( hWnd, WM_TEST, 0, 0 );
                }
                break;
            }

            return 0;
        }

    case WM_CLOSE:
        {
            if ( g_bExit )
            {
                SetWindowText( hWnd, TEXT("RTCStress - Shutdown...") );

                g_pClient->PrepareForShutdown();

                return 0;
            }

            g_bExit = TRUE;

            SetWindowText( hWnd, TEXT("RTCStress - Waiting...") );

            while ( g_ProfileArray.GetSize() )
            {
                printf("Disable profile 0x%x...\n", g_ProfileArray[0]);

                hr = g_pProv->DisableProfile( g_ProfileArray[0] ); 

                if ( FAILED(hr) )
                {
                    printf("DisableProfile failed 0x%lx\n", hr);

                    DebugBreak();

                    break;
                }

                g_ProfileArray.RemoveAt(0);
                g_nProfilesDisabled++;
            }

            //MessageBox( hWnd, TEXT("Finished!"), TEXT("RTCStress"), MB_OK );

            //DestroyWindow( hWnd );

            return 0;
        }

    case WM_CORE_EVENT:
        {
            switch ( wParam )
            {
                case RTCE_REGISTRATION_STATE_CHANGE:
                    {
                        IRTCRegistrationStateChangeEvent * pRSC;
                        IRTCProfile                      * pProfile;
                        RTC_REGISTRATION_STATE             enRS;
                        IDispatch                        * pDisp;
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCRegistrationStateChangeEvent,
                                               (void **)&pRSC
                                             );

                        pDisp->Release();
                                       
                        hr = pRSC->get_State(&enRS);

                        if ( FAILED(hr) )
                        {
                            printf("get_State failed 0x%lx\n", hr);

                            pRSC->Release();
                            return 0;
                        }

                        hr = pRSC->get_Profile(&pProfile);

                        if ( FAILED(hr) )
                        {
                            printf("get_Profile failed 0x%lx\n", hr);

                            pRSC->Release();
                            return 0;
                        }

                        switch(enRS)
                        {
                            case RTCRS_NOT_REGISTERED:
                                printf("RTCRS_NOT_REGISTERED [0x%lx]\n", pProfile);

                                g_nProfilesUnregistered++;
                                break;

                            case RTCRS_REGISTERING:
                                printf("RTCRS_REGISTERING [0x%lx]\n", pProfile);

                                g_nProfilesRegistering++;
                                break;

                            case RTCRS_REGISTERED:
                                printf("RTCRS_REGISTERED [0x%lx]\n", pProfile);

                                g_nProfilesRegistered++;
                                break;

                            case RTCRS_REJECTED:
                                printf("RTCRS_REJECTED [0x%lx]\n", pProfile);

                                g_nProfilesReject++;
                                break;

                            case RTCRS_UNREGISTERING:
                                printf("RTCRS_UNREGISTERING [0x%lx]\n", pProfile);

                                g_nProfilesUnregistering++;
                                break;

                            case RTCRS_ERROR:
                                printf("RTCRS_ERROR [0x%lx]\n", pProfile);

                                g_nProfilesError++;
                                break;
                        }

                        pRSC->Release();
                        pProfile->Release();

                        SendMessage( hWnd, WM_UPDATE, 0, 0 );
                    }            
                    break;            
                    
                case RTCE_CLIENT:
                    {
                        IRTCClientEvent       * pC;
                        IDispatch             * pDisp;
                        RTC_CLIENT_EVENT_TYPE	enEventType; 
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCClientEvent,
                                               (void **)&pC
                                             );

                        pDisp->Release();
                                       
                        hr = pC->get_EventType(&enEventType);

                        if ( FAILED(hr) )
                        {
                            printf("get_EventType failed 0x%lx\n", hr);

                            pC->Release();
                            return 0;
                        }

                        if ( enEventType == RTCCET_ASYNC_CLEANUP_DONE )
                        {
                            DestroyWindow(hWnd);
                        }
                        
                        pC->Release();
                    }            
                    break; 
            }

            return 0;
        }

    default:
        return DefWindowProc( hWnd, uMsg, wParam, lParam );
    }

    return 0;
}

/////////////////////////////////////////////
//
// Main
// 

int _cdecl main(int argc, char* argv[])
{
    WNDCLASS wc;
    HWND     hWnd;
    MSG      msg;
    HRESULT  hr;

    hr =  CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if ( FAILED(hr) )
    {
        printf("CoInitializeEx failed 0x%lx\n", hr);

        return 0;
    }
    
    ZeroMemory(&wc, sizeof(WNDCLASS));

    wc.lpfnWndProc = WndProc;
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpszClassName = TEXT("RTCStressClass");
    
    if ( !RegisterClass( &wc ) )
    {
        printf("RegisterClass failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    }

#define WIDTH 300
#define HEIGHT 200
    
    hWnd = CreateWindow(
            TEXT("RTCStressClass"),
            TEXT("RTCStress"),
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            WIDTH,
            HEIGHT,
            NULL,
            NULL,
            GetModuleHandle(NULL),
            NULL
            );

    if ( hWnd == NULL )
    {
        printf("CreateWindow failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    } 

    g_hEditWnd = CreateWindow(
            TEXT("STATIC"),
            TEXT(""),
            WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
            0,
            0,
            WIDTH,
            HEIGHT,
            hWnd,
            NULL,
            GetModuleHandle(NULL),
            NULL
            );

    if ( g_hEditWnd == NULL )
    {
        printf("CreateWindow failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    }
    
    ShowWindow( hWnd, SW_SHOW );
    UpdateWindow( hWnd );

    while ( GetMessage( &msg, NULL, 0, 0 ) > 0 )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\test\rtctest.h ===
#ifndef __RTCTEST__
#define __RTCTEST__

#define WM_CORE_EVENT      WM_USER+100
#define WM_CREATE_SESSION  WM_USER+101
#define WM_LISTEN          WM_USER+102

#define TID_CALL_TIMER     100

class CRTCEvents :
	public IRTCEventNotification
{
private:
    DWORD m_dwRefCount;
    DWORD m_dwCookie;
    HWND  m_hWnd;

public:
    CRTCEvents() : m_dwRefCount(NULL),
                   m_dwCookie(NULL),
                   m_hWnd(NULL)
    {
    }

    /////////////////////////////////////////////
    //
    // QueryInterface
    // 

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_IRTCEventNotification)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    /////////////////////////////////////////////
    //
    // AddRef
    // 

	ULONG STDMETHODCALLTYPE AddRef()
    {
        m_dwRefCount++;
        return m_dwRefCount;
    }
    
    /////////////////////////////////////////////
    //
    // Release
    // 

	ULONG STDMETHODCALLTYPE Release()
    {
        m_dwRefCount--;

        if ( 0 == m_dwRefCount)
        {
            delete this;
        }

        return 1;
    }

    /////////////////////////////////////////////
    //
    // Advise
    // 

    HRESULT Advise(IRTCClient * pClient, HWND hWnd)
    {    
	    IConnectionPointContainer * pCPC;
	    IConnectionPoint * pCP;

	    HRESULT hr = pClient->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	    if (SUCCEEDED(hr))
        {
		    hr = pCPC->FindConnectionPoint(IID_IRTCEventNotification, &pCP);

            pCPC->Release();

            if (SUCCEEDED(hr))
            {
		        hr = pCP->Advise(this, &m_dwCookie);

                pCP->Release();
            }
        }

        m_hWnd = hWnd;

	    return hr;
    }

    /////////////////////////////////////////////
    //
    // Unadvise
    // 

    HRESULT Unadvise(IRTCClient * pClient)
    {
	    IConnectionPointContainer * pCPC;
	    IConnectionPoint * pCP;

	    HRESULT hr = pClient->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	    if (SUCCEEDED(hr))
        {
		    hr = pCPC->FindConnectionPoint(IID_IRTCEventNotification, &pCP);

            pCPC->Release();

            if (SUCCEEDED(hr))
            {
		        hr = pCP->Unadvise(m_dwCookie);

                pCP->Release();
            }
        }

	    return hr;
    }

    /////////////////////////////////////////////
    //
    // Event
    // 

	HRESULT STDMETHODCALLTYPE Event(
        RTC_EVENT enEvent,
        IDispatch * pDisp
        )
    {
        pDisp->AddRef();

        PostMessage( m_hWnd, WM_CORE_EVENT, (WPARAM)enEvent, (LPARAM)pDisp );

        return S_OK;
    }
};

#endif //__RTCTEST__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\test2\rtctest.cpp ===
#define UNICODE
#include <windows.h>
#include <RTCCore.h>
#include <stdio.h>

#include "RTCTest.h"

IRTCClient  * g_pClient = NULL;
CRTCEvents  * g_pEvents = NULL;
IRTCClientProvisioning * g_pProv = NULL;

/////////////////////////////////////////////
//
// WndProc
// 

LRESULT CALLBACK WndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hr;

    switch ( uMsg )
    {
    case WM_CREATE:
        {
            hr = CoCreateInstance(
                                  CLSID_RTCClient,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IRTCClient,
                                  (LPVOID *)&g_pClient
                                 );

            if ( FAILED(hr) )
            {
                printf("CoCreateInstance failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->Initialize();

            if ( FAILED(hr) )
            {
                printf("Initialize failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->put_EventFilter( 
                         RTCEF_REGISTRATION_STATE_CHANGE |
                         RTCEF_CLIENT
                         );

            if ( FAILED(hr) )
            {
                printf("put_EventFilter failed 0x%lx\n", hr);

                return -1;
            }


            g_pEvents = new CRTCEvents;

            hr = g_pEvents->Advise( g_pClient, hWnd );

            if ( FAILED(hr) )
            {
                printf("Advise failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->QueryInterface( IID_IRTCClientProvisioning, (void**)&g_pProv );

            if ( FAILED(hr) )
            {
                printf("QueryInterface failed 0x%lx\n", hr);

                return -1;
            }

            IRTCProfile * pProfile;

            BSTR bstrXML = SysAllocString( L"<provision key=\"amun1\" name=\"Amun\"><provider name=\"Amun\" homepage=\"http://winrtc/phoenix\"><data>test</data></provider><client name=\"Phoenix\" banner=\"false\"/><user uri=\"sip:rtctest@microsoft.com\"/><accesscontrol domain=\"ntdev.microsoft.com\" sig=\"43r8mXTFvSMBZHajABKbd5ee1vHXUDqJIUxhsmtF67UZZryIolEdp/1qs2oiTKbKrAlAsIzOoCL75lTzZSbacA==\" /><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"registrar\"/><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"proxy\"><session party=\"first\" type=\"pc2pc\"/><session party=\"first\" type=\"pc2ph\"/><session party=\"first\" type=\"im\"/></sipsrv></provision>" );
 
            hr = g_pProv->CreateProfile( bstrXML, &pProfile );

            printf("Adding profile 1...[%p]\n", pProfile);

            SysFreeString( bstrXML );

            if ( FAILED(hr) )
            {
                printf("CreateProfile failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pProv->EnableProfile( pProfile, RTCRF_REGISTER_ALL );

            if ( FAILED(hr) )
            {
                printf("EnableProfile failed 0x%lx\n", hr);

                return -1;
            }

            pProfile->Release();      

            SetTimer( hWnd, TID_TIMER1, 3000, NULL );
    
            return 0;
        }

    case WM_DESTROY:        
        {
            printf("Exiting...\n");

            if ( g_pEvents )
            {
                hr = g_pEvents->Unadvise( g_pClient );

                if ( FAILED(hr) )
                {
                    printf("Unadvise failed 0x%lx\n", hr);
                }

                g_pEvents = NULL;
            }

            if ( g_pProv )
            {
                g_pProv->Release();
                g_pProv = NULL;
            }
            
            if ( g_pClient )
            {
                hr = g_pClient->Shutdown();

                if ( FAILED(hr) )
                {
                    printf("Shutdown failed 0x%lx\n", hr);
                }

                g_pClient->Release();
                g_pClient = NULL;
            }

            PostQuitMessage(0);

            return 0;
        }

    case WM_TIMER:
        {
            switch ( wParam )
            {
            case TID_TIMER1:
                {
                    KillTimer( hWnd, TID_TIMER1 );

                    IRTCProfile * pProfile;

                    BSTR bstrXML = SysAllocString( L"<provision key=\"amun1\" name=\"Amun\"><provider name=\"Amun\" homepage=\"http://winrtc/phoenix\"><data>test</data></provider><client name=\"Phoenix\" banner=\"false\"/><user uri=\"sip:rtctest@microsoft.com\"/><accesscontrol domain=\"ntdev.microsoft.com\" sig=\"43r8mXTFvSMBZHajABKbd5ee1vHXUDqJIUxhsmtF67UZZryIolEdp/1qs2oiTKbKrAlAsIzOoCL75lTzZSbacA==\" /><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"registrar\"/><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"proxy\"><session party=\"first\" type=\"pc2pc\"/><session party=\"first\" type=\"pc2ph\"/><session party=\"first\" type=\"im\"/></sipsrv></provision>" );
                    
                    hr = g_pProv->CreateProfile( bstrXML, &pProfile );

                    printf("Replacing profile 1...[%p]\n", pProfile);

                    SysFreeString( bstrXML );

                    if ( FAILED(hr) )
                    {
                        printf("CreateProfile failed 0x%lx\n", hr);

                        return 0;
                    }

                    hr = g_pProv->EnableProfile( pProfile, RTCRF_REGISTER_ALL );

                    if ( FAILED(hr) )
                    {
                        printf("EnableProfile failed 0x%lx\n", hr);

                        return 0;
                    }

                    pProfile->Release();      

                    SetTimer( hWnd, TID_TIMER2, 3000, NULL );
                }
                break;

            case TID_TIMER2:
                {
                    KillTimer( hWnd, TID_TIMER2 );                    

                    IRTCProfile * pProfile;

                    BSTR bstrXML = SysAllocString( L"<provision key=\"amun2\" name=\"Amun\"><provider name=\"Amun\" homepage=\"http://winrtc/phoenix\"><data>test</data></provider><client name=\"Phoenix\" banner=\"false\"/><user uri=\"sip:rtctest@microsoft.com\"/><accesscontrol domain=\"ntdev.microsoft.com\" sig=\"43r8mXTFvSMBZHajABKbd5ee1vHXUDqJIUxhsmtF67UZZryIolEdp/1qs2oiTKbKrAlAsIzOoCL75lTzZSbacA==\" /><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"registrar\"/><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"proxy\"><session party=\"first\" type=\"pc2pc\"/><session party=\"first\" type=\"pc2ph\"/><session party=\"first\" type=\"im\"/></sipsrv></provision>" );
                    
                    hr = g_pProv->CreateProfile( bstrXML, &pProfile );

                    printf("Adding profile 2 [don't register]...[%p]\n", pProfile);

                    SysFreeString( bstrXML );

                    if ( FAILED(hr) )
                    {
                        printf("CreateProfile failed 0x%lx\n", hr);

                        return 0;
                    }

                    hr = g_pProv->EnableProfile( pProfile, 0 );

                    if ( FAILED(hr) )
                    {
                        printf("EnableProfile failed 0x%lx\n", hr);

                        return 0;
                    }

                    pProfile->Release();      

                    SetTimer( hWnd, TID_TIMER3, 3000, NULL );
                }
                break;

            case TID_TIMER3:
                {
                    KillTimer( hWnd, TID_TIMER3 );                    

                    IRTCProfile * pProfile;

                    BSTR bstrXML = SysAllocString( L"<provision key=\"amun3\" name=\"Amun\"><provider name=\"Amun\" homepage=\"http://winrtc/phoenix\"><data>test</data></provider><client name=\"Phoenix\" banner=\"false\"/><user uri=\"sip:rtctest@microsoft.com\"/><accesscontrol domain=\"ntdev.microsoft.com\" sig=\"43r8mXTFvSMBZHajABKbd5ee1vHXUDqJIUxhsmtF67UZZryIolEdp/1qs2oiTKbKrAlAsIzOoCL75lTzZSbacA==\" /><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"registrar\"/><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"proxy\"><session party=\"first\" type=\"pc2pc\"/><session party=\"first\" type=\"pc2ph\"/><session party=\"first\" type=\"im\"/></sipsrv></provision>" );
                    
                    hr = g_pProv->CreateProfile( bstrXML, &pProfile );

                    printf("Adding profile 3...[%p]\n", pProfile);

                    SysFreeString( bstrXML );

                    if ( FAILED(hr) )
                    {
                        printf("CreateProfile failed 0x%lx\n", hr);

                        return 0;
                    }

                    hr = g_pProv->EnableProfile( pProfile, RTCRF_REGISTER_ALL );

                    if ( FAILED(hr) )
                    {
                        printf("EnableProfile failed 0x%lx\n", hr);

                        return 0;
                    }

                    pProfile->Release();      

                    SetTimer( hWnd, TID_TIMER4, 3000, NULL );
                }
                break;

            case TID_TIMER4:
                {
                    KillTimer( hWnd, TID_TIMER4 );

                    printf("Removing profile 1...\n");

                    IRTCEnumProfiles * pEnum;

                    hr = g_pProv->EnumerateProfiles( &pEnum );

                    if ( FAILED(hr) )
                    {
                        printf("EnumerateProfiles failed 0x%lx\n", hr);

                        return 0;
                    }

                    IRTCProfile * pProfile;
                    
                    hr = pEnum->Next( 1, &pProfile, NULL );

                    pEnum->Release();

                    if ( FAILED(hr) )
                    {
                        printf("Next failed 0x%lx\n", hr);

                        return 0;
                    }

                    hr = g_pProv->DisableProfile( pProfile );

                    pProfile->Release();

                    if ( FAILED(hr) )
                    {
                        printf("DisableProfile failed 0x%lx\n", hr);

                        return 0;
                    }

                    SetTimer( hWnd, TID_TIMER5, 3000, NULL );
                }
                break;

            case TID_TIMER5:
                {
                    KillTimer( hWnd, TID_TIMER5 );

                    printf("Shuting down...\n");

                    hr = g_pClient->PrepareForShutdown();

                    if ( FAILED(hr) )
                    {
                        printf("PrepareForShutdown failed 0x%lx\n", hr);
                    }
                }
                break;
            }

            return 0;
        }

    case WM_CORE_EVENT:
        {
            switch ( wParam )
            {
                case RTCE_REGISTRATION_STATE_CHANGE:
                    {
                        IRTCRegistrationStateChangeEvent * pRSC;
                        IRTCProfile                      * pProfile;
                        RTC_REGISTRATION_STATE             enRS;
                        IDispatch                        * pDisp;
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCRegistrationStateChangeEvent,
                                               (void **)&pRSC
                                             );

                        pDisp->Release();
                                       
                        hr = pRSC->get_State(&enRS);

                        if ( FAILED(hr) )
                        {
                            printf("get_State failed 0x%lx\n", hr);

                            pRSC->Release();
                            return 0;
                        }

                        hr = pRSC->get_Profile(&pProfile);

                        if ( FAILED(hr) )
                        {
                            printf("get_Profile failed 0x%lx\n", hr);

                            pRSC->Release();
                            return 0;
                        }

                        switch(enRS)
                        {
                            case RTCRS_NOT_REGISTERED:
                                printf("RTCRS_NOT_REGISTERED [0x%lx]\n", pProfile);
                                break;

                            case RTCRS_REGISTERING:
                                printf("RTCRS_REGISTERING [0x%lx]\n", pProfile);
                                break;

                            case RTCRS_REGISTERED:
                                printf("RTCRS_REGISTERED [0x%lx]\n", pProfile);
                                break;

                            case RTCRS_REJECTED:
                                printf("RTCRS_REJECTED [0x%lx]\n", pProfile);
                                break;

                            case RTCRS_UNREGISTERING:
                                printf("RTCRS_UNREGISTERING [0x%lx]\n", pProfile);
                                break;

                            case RTCRS_ERROR:
                                printf("RTCRS_ERROR [0x%lx]\n", pProfile);
                                break;
                        }

                        pRSC->Release();
                        pProfile->Release();
                    }            
                    break;            
                    
                case RTCE_CLIENT:
                    {
                        IRTCClientEvent       * pC;
                        IDispatch             * pDisp;
                        RTC_CLIENT_EVENT_TYPE	enEventType; 
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCClientEvent,
                                               (void **)&pC
                                             );

                        pDisp->Release();
                                       
                        hr = pC->get_EventType(&enEventType);

                        if ( FAILED(hr) )
                        {
                            printf("get_EventType failed 0x%lx\n", hr);

                            pC->Release();
                            return 0;
                        }

                        if ( enEventType == RTCCET_ASYNC_CLEANUP_DONE )
                        {
                            DestroyWindow(hWnd);
                        }
                        
                        pC->Release();
                    }            
                    break; 
            }

            return 0;
        }

    default:
        return DefWindowProc( hWnd, uMsg, wParam, lParam );
    }

    return 0;
}

/////////////////////////////////////////////
//
// Main
// 

int _cdecl main(int argc, char* argv[])
{
    WNDCLASS wc;
    HWND     hWnd;
    MSG      msg;
    HRESULT  hr;

    hr =  CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if ( FAILED(hr) )
    {
        printf("CoInitializeEx failed 0x%lx\n", hr);

        return 0;
    }
    
    ZeroMemory(&wc, sizeof(WNDCLASS));

    wc.lpfnWndProc = WndProc;
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpszClassName = TEXT("RTCTestClass");
    
    if ( !RegisterClass( &wc ) )
    {
        printf("RegisterClass failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    }
    
    hWnd = CreateWindow(
            TEXT("RTCTestClass"),
            TEXT("RTCTest"),
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            NULL,
            NULL,
            GetModuleHandle(NULL),
            NULL
            );

    if ( hWnd == NULL )
    {
        printf("CreateWindow failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    }           

    while ( GetMessage( &msg, NULL, 0, 0 ) > 0 )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\test2\rtctest.h ===
#ifndef __RTCTEST__
#define __RTCTEST__

#define WM_CORE_EVENT      WM_USER+100

#define TID_TIMER1         100
#define TID_TIMER2         101
#define TID_TIMER3         102
#define TID_TIMER4         103
#define TID_TIMER5         104

class CRTCEvents :
	public IRTCEventNotification
{
private:
    DWORD m_dwRefCount;
    DWORD m_dwCookie;
    HWND  m_hWnd;

public:
    CRTCEvents() : m_dwRefCount(NULL),
                   m_dwCookie(NULL),
                   m_hWnd(NULL)
    {
    }

    /////////////////////////////////////////////
    //
    // QueryInterface
    // 

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_IRTCEventNotification)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    /////////////////////////////////////////////
    //
    // AddRef
    // 

	ULONG STDMETHODCALLTYPE AddRef()
    {
        m_dwRefCount++;
        return m_dwRefCount;
    }
    
    /////////////////////////////////////////////
    //
    // Release
    // 

	ULONG STDMETHODCALLTYPE Release()
    {
        m_dwRefCount--;

        if ( 0 == m_dwRefCount)
        {
            delete this;
        }

        return 1;
    }

    /////////////////////////////////////////////
    //
    // Advise
    // 

    HRESULT Advise(IRTCClient * pClient, HWND hWnd)
    {    
	    IConnectionPointContainer * pCPC;
	    IConnectionPoint * pCP;

	    HRESULT hr = pClient->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	    if (SUCCEEDED(hr))
        {
		    hr = pCPC->FindConnectionPoint(IID_IRTCEventNotification, &pCP);

            pCPC->Release();

            if (SUCCEEDED(hr))
            {
		        hr = pCP->Advise(this, &m_dwCookie);

                pCP->Release();
            }
        }

        m_hWnd = hWnd;

	    return hr;
    }

    /////////////////////////////////////////////
    //
    // Unadvise
    // 

    HRESULT Unadvise(IRTCClient * pClient)
    {
	    IConnectionPointContainer * pCPC;
	    IConnectionPoint * pCP;

	    HRESULT hr = pClient->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	    if (SUCCEEDED(hr))
        {
		    hr = pCPC->FindConnectionPoint(IID_IRTCEventNotification, &pCP);

            pCPC->Release();

            if (SUCCEEDED(hr))
            {
		        hr = pCP->Unadvise(m_dwCookie);

                pCP->Release();
            }
        }

	    return hr;
    }

    /////////////////////////////////////////////
    //
    // Event
    // 

	HRESULT STDMETHODCALLTYPE Event(
        RTC_EVENT enEvent,
        IDispatch * pDisp
        )
    {
        pDisp->AddRef();

        PostMessage( m_hWnd, WM_CORE_EVENT, (WPARAM)enEvent, (LPARAM)pDisp );

        return S_OK;
    }
};

#endif //__RTCTEST__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\test3\rtctest.cpp ===
#define UNICODE
#include <windows.h>
#include <RTCCore.h>
#include <stdio.h>

#define MAX_XML_LEN 8192

IRTCClient  * g_pClient = NULL;
IRTCClientProvisioning * g_pProv = NULL;

/////////////////////////////////////////////
//
// Main
// 

int _cdecl main(int argc, char* argv[])
{
    WNDCLASS wc;
    HWND     hWnd;
    MSG      msg;
    HRESULT  hr;
    WCHAR    wszFilename[MAX_PATH];    

    if ( argc != 2 )
    {
        printf("Usage: RTCTest <filename>\n");

        return 0;
    }

    //
    // Get the filename
    //

    if ( !MultiByteToWideChar( CP_ACP, 0, argv[1], -1, wszFilename, MAX_PATH ) )
    {
        printf("MultiByteToWideChar failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()) );

        return 0;
    }

    HANDLE hFile;
    DWORD  dwBytesRead;
    char   szXML[MAX_XML_LEN];
    WCHAR  wszXML[MAX_XML_LEN];
    BSTR   bstrXML;

    //
    // Read the XML from the file
    //
    
    hFile = CreateFile( wszFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        printf("CreateFile failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()) );

        return 0;
    }

    if ( !ReadFile( hFile, szXML, MAX_XML_LEN, &dwBytesRead, NULL ) )
    {
        printf("ReadFile failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()) );

        CloseHandle( hFile );

        return 0;
    }

    printf("Read file '%ws' %d bytes\n", wszFilename, dwBytesRead);

    CloseHandle( hFile );

    if ( !MultiByteToWideChar( CP_ACP, 0, szXML, dwBytesRead, wszXML, MAX_XML_LEN ) )
    {
        printf("MultiByteToWideChar failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()) );

        return 0;
    }

    printf("%ws\n", wszXML);

    //
    // Initialize RTC
    //

    hr =  CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if ( FAILED(hr) )
    {
        printf("CoInitializeEx failed 0x%lx\n", hr);

        return 0;
    }

    hr = CoCreateInstance(
                          CLSID_RTCClient,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IRTCClient,
                          (LPVOID *)&g_pClient
                         );

    if ( FAILED(hr) )
    {
        printf("CoCreateInstance failed 0x%lx\n", hr);

        goto exit;
    }

    hr = g_pClient->Initialize();

    if ( FAILED(hr) )
    {
        printf("Initialize failed 0x%lx\n", hr);

        goto exit;
    }

    hr = g_pClient->QueryInterface( IID_IRTCClientProvisioning, (void**)&g_pProv );

    if ( FAILED(hr) )
    {
        printf("QueryInterface failed 0x%lx\n", hr);

        goto exit;
    }

    //
    // Parse the profile
    //

    IRTCProfile * pProfile;

    bstrXML = SysAllocString(wszXML);

    if ( bstrXML == NULL )
    {
        printf("SysAllocString failed\n");

        goto exit;
    }

    hr = g_pProv->CreateProfile( bstrXML, &pProfile );

    SysFreeString( bstrXML );

    if ( FAILED(hr) )
    {
        printf("CreateProfile failed 0x%lx\n", hr);

        goto exit;
    }

    printf("CreateProfile succeeded\n");

    pProfile->Release();   

    //
    // Shutdown
    //

exit:
    
    if ( g_pProv )
    {
        g_pProv->Release();
    }
    
    if ( g_pClient )
    {
        hr = g_pClient->Shutdown();

        if ( FAILED(hr) )
        {
            printf("Shutdown failed 0x%lx\n", hr);
        }

        g_pClient->Release();
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\dll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\test4\rtctest.h ===
#ifndef __RTCTEST__
#define __RTCTEST__

#define WM_CORE_EVENT      WM_USER+100
#define WM_CREATE_SESSION  WM_USER+101
#define WM_LISTEN          WM_USER+102
#define WM_CREATE_PROFILE  WM_USER+103

#define TID_CALL_TIMER     100

class CRTCEvents :
	public IRTCEventNotification
{
private:
    DWORD m_dwRefCount;
    DWORD m_dwCookie;
    HWND  m_hWnd;

public:
    CRTCEvents() : m_dwRefCount(NULL),
                   m_dwCookie(NULL),
                   m_hWnd(NULL)
    {
    }

    /////////////////////////////////////////////
    //
    // QueryInterface
    // 

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_IRTCEventNotification)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    /////////////////////////////////////////////
    //
    // AddRef
    // 

	ULONG STDMETHODCALLTYPE AddRef()
    {
        m_dwRefCount++;
        return m_dwRefCount;
    }
    
    /////////////////////////////////////////////
    //
    // Release
    // 

	ULONG STDMETHODCALLTYPE Release()
    {
        m_dwRefCount--;

        if ( 0 == m_dwRefCount)
        {
            delete this;
        }

        return 1;
    }

    /////////////////////////////////////////////
    //
    // Advise
    // 

    HRESULT Advise(IRTCClient * pClient, HWND hWnd)
    {    
	    IConnectionPointContainer * pCPC;
	    IConnectionPoint * pCP;

	    HRESULT hr = pClient->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	    if (SUCCEEDED(hr))
        {
		    hr = pCPC->FindConnectionPoint(IID_IRTCEventNotification, &pCP);

            pCPC->Release();

            if (SUCCEEDED(hr))
            {
		        hr = pCP->Advise(this, &m_dwCookie);

                pCP->Release();
            }
        }

        m_hWnd = hWnd;

	    return hr;
    }

    /////////////////////////////////////////////
    //
    // Unadvise
    // 

    HRESULT Unadvise(IRTCClient * pClient)
    {
	    IConnectionPointContainer * pCPC;
	    IConnectionPoint * pCP;

	    HRESULT hr = pClient->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	    if (SUCCEEDED(hr))
        {
		    hr = pCPC->FindConnectionPoint(IID_IRTCEventNotification, &pCP);

            pCPC->Release();

            if (SUCCEEDED(hr))
            {
		        hr = pCP->Unadvise(m_dwCookie);

                pCP->Release();
            }
        }

	    return hr;
    }

    /////////////////////////////////////////////
    //
    // Event
    // 

	HRESULT STDMETHODCALLTYPE Event(
        RTC_EVENT enEvent,
        IDispatch * pDisp
        )
    {
        pDisp->AddRef();

        PostMessage( m_hWnd, WM_CORE_EVENT, (WPARAM)enEvent, (LPARAM)pDisp );

        return S_OK;
    }
};

#endif //__RTCTEST__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\test4\rtctest.cpp ===
#define UNICODE
#include <windows.h>
#include <RTCCore.h>
#include <rtcerr.h>
#include <stdio.h>

#include "RTCTest.h"

IRTCClient  * g_pClient = NULL;
IRTCSession * g_pSession = NULL;
IRTCProfile * g_pProfile = NULL;
CRTCEvents  * g_pEvents = NULL;

/////////////////////////////////////////////
//
// WndProc
// 

LRESULT CALLBACK WndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hr;

    switch ( uMsg )
    {
    case WM_CREATE:
        {
            hr = CoCreateInstance(
                                  CLSID_RTCClient,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IRTCClient,
                                  (LPVOID *)&g_pClient
                                 );

            if ( FAILED(hr) )
            {
                printf("CoCreateInstance failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->Initialize();

            if ( FAILED(hr) )
            {
                printf("Initialize failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->SetPreferredMediaTypes( 
                         RTCMT_AUDIO_SEND |
                         RTCMT_AUDIO_RECEIVE |
                         RTCMT_VIDEO_SEND |
                         RTCMT_VIDEO_RECEIVE,
                         VARIANT_FALSE
                         );

            if ( FAILED(hr) )
            {
                printf("SetPreferredMediaTypes failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->put_EventFilter( 
                         RTCEF_SESSION_STATE_CHANGE |
                         RTCEF_REGISTRATION_STATE_CHANGE |
                         RTCEF_MEDIA |
                         RTCEF_CLIENT
                         );

            if ( FAILED(hr) )
            {
                printf("put_EventFilter failed 0x%lx\n", hr);

                return -1;
            }


            g_pEvents = new CRTCEvents;

            hr = g_pEvents->Advise( g_pClient, hWnd );

            if ( FAILED(hr) )
            {
                printf("Advise failed 0x%lx\n", hr);

                return -1;
            }
    
            return 0;
        }

    case WM_DESTROY:        
        {
            printf("Exiting...\n");

            if ( g_pEvents )
            {
                hr = g_pEvents->Unadvise( g_pClient );

                if ( FAILED(hr) )
                {
                    printf("Unadvise failed 0x%lx\n", hr);
                }

                g_pEvents = NULL;
            }

            if ( g_pSession )
            {
                g_pSession->Release();
                g_pSession = NULL;
            }

            if ( g_pProfile )
            {
                g_pProfile->Release();
                g_pProfile = NULL;
            }
            
            if ( g_pClient )
            {
                hr = g_pClient->Shutdown();

                if ( FAILED(hr) )
                {
                    printf("Shutdown failed 0x%lx\n", hr);
                }

                g_pClient->Release();
                g_pClient = NULL;
            }

            PostQuitMessage(0);

            return 0;
        }

    case WM_TIMER:
        {
            if ( wParam == TID_CALL_TIMER )
            {
                KillTimer( hWnd, TID_CALL_TIMER );

                if ( g_pSession )
                {
                    hr = g_pSession->Terminate( RTCTR_NORMAL );

                    if ( FAILED(hr) )
                    {
                        printf("Terminate failed 0x%lx\n", hr);

                        DestroyWindow(hWnd);
                    }
                }
            }

            return 0;
        }

    case WM_CORE_EVENT:
        {
            switch ( wParam )
            {
                case RTCE_SESSION_STATE_CHANGE:
                    {
                        IRTCSessionStateChangeEvent * pSSC;
                        IRTCSession                 * pSession;
                        RTC_SESSION_STATE             enSS;
                        IDispatch                   * pDisp;
                        long                          lStatus;
                        BSTR                          bstrStatus;
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCSessionStateChangeEvent,
                                               (void **)&pSSC
                                             );

                        pDisp->Release();
                                       
                        hr = pSSC->get_State(&enSS);

                        if ( FAILED(hr) )
                        {
                            printf("get_State failed 0x%lx\n", hr);

                            pSSC->Release();
                            return 0;
                        }

                        lStatus = S_OK;

                        hr = pSSC->get_StatusCode(&lStatus);

                        if ( FAILED(hr) )
                        {
                            printf("get_StatusCode failed 0x%lx\n", hr);
                            
                            pSSC->Release();
                            return 0;
                        }

                        hr = pSSC->get_StatusText(&bstrStatus);

                        if ( FAILED(hr) && (hr != E_FAIL))
                        {
                            printf("get_StatusText failed 0x%lx\n", hr);
                            
                            pSSC->Release();
                            return 0;
                        }

                        if (HRESULT_FACILITY(lStatus) == FACILITY_SIP_STATUS_CODE)
                        {
                            printf("Status: %d %ws\n", HRESULT_CODE(lStatus), bstrStatus);
                        }

                        SysFreeString( bstrStatus );

                        hr = pSSC->get_Session(&pSession);

                        if ( FAILED(hr) )
                        {
                            printf("get_Session failed 0x%lx\n", hr);

                            pSSC->Release();
                            return 0;
                        }                        

                        if ( (g_pSession == pSession) ||
                             (enSS == RTCSS_INCOMING) )
                        {
                            switch(enSS)
                            {
                                case RTCSS_IDLE:
                                    printf("IDLE [0x%lx]\n", pSession);
                                    break;

                                case RTCSS_INPROGRESS:
                                    printf("INPROGRESS [0x%lx]\n", pSession);
                                    break;

                                case RTCSS_INCOMING:
                                    {
                                        printf("INCOMING [0x%lx]\n", pSession);

                                        if ( g_pSession ) g_pSession->Release();

                                        g_pSession = pSession;
                                        g_pSession->AddRef();

                                        BSTR bstrKey = SysAllocString(L"RTC");

                                        hr = g_pSession->put_EncryptionKey( RTCMT_ALL_RTP, bstrKey );

                                        SysFreeString( bstrKey );

                                        if ( FAILED(hr) )
                                        {
                                            printf("put_EncryptionKey failed 0x%lx\n", hr);

                                            DestroyWindow(hWnd);
                                        }

                                        hr = g_pSession->Answer();

                                        if ( FAILED(hr) )
                                        {
                                            printf("Answer failed 0x%lx\n", hr);

                                            DestroyWindow(hWnd);
                                        }
                                    }
                                    break;

                                case RTCSS_CONNECTED:
                                    printf("CONNECTED [0x%lx]\n", pSession);

                                    SetTimer( hWnd, TID_CALL_TIMER, 30000, NULL);

                                    break;

                                case RTCSS_DISCONNECTED:
                                    printf("DISCONNECTED [0x%lx]\n", pSession);

                                    if ( g_pSession ) 
                                    {
                                        g_pSession->Release();
                                        g_pSession = NULL;
                                    }

                                    hr = g_pClient->PrepareForShutdown();

                                    if ( FAILED(hr) )
                                    {
                                        printf("PrepareForShutdown failed 0x%lx\n", hr);

                                        DestroyWindow(hWnd);
                                    }
                                    break;
                            }
                        }                        

                        pSSC->Release();
                        pSession->Release();
                    }            
                    break;  
                    
                case RTCE_MEDIA:
                    {
                        IRTCMediaEvent        * pM;
                        IDispatch             * pDisp;
                        RTC_MEDIA_EVENT_TYPE	enEventType; 
                        long                    lMediaType;
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCMediaEvent,
                                               (void **)&pM
                                             );

                        pDisp->Release();
                                       
                        hr = pM->get_EventType(&enEventType);

                        if ( FAILED(hr) )
                        {
                            printf("get_EventType failed 0x%lx\n", hr);

                            pM->Release();
                            return 0;
                        }

                        hr = pM->get_MediaType(&lMediaType);

                        if ( FAILED(hr) )
                        {
                            printf("get_MediaType failed 0x%lx\n", hr);

                            pM->Release();
                            return 0;
                        }
                        
                        IVideoWindow * pVid = NULL;
                           
                        switch (lMediaType)
                        {
                        case RTCMT_VIDEO_SEND:                        
                            hr = g_pClient->get_IVideoWindow(RTCVD_PREVIEW, &pVid);

                            printf("RTCMT_VIDEO_SEND - ");
                            break;

                        case RTCMT_VIDEO_RECEIVE:
                            hr = g_pClient->get_IVideoWindow(RTCVD_RECEIVE, &pVid);

                            printf("RTCMT_VIDEO_RECEIVE - ");
                            break;

                        case RTCMT_AUDIO_SEND:
                            printf("RTCMT_AUDIO_SEND - ");
                            break;

                        case RTCMT_AUDIO_RECEIVE:
                            printf("RTCMT_AUDIO_RECEIVE - ");
                            break;

                        case RTCMT_T120_SENDRECV:
                            printf("RTCMT_T120_SENDRECV - ");
                            break;
                        }
                        
                        switch (enEventType) 
                        {
                        case RTCMET_STARTED:
                            printf("RTCMET_STARTED\n");

                            if ( (pVid != NULL) && SUCCEEDED(hr) )
                            {
                                pVid->put_Visible( -1 );
                                pVid->Release();
                            }
                            break;

                        case RTCMET_STOPPED:
                            printf("RTCMET_STOPPED\n");

                            if ( (pVid != NULL) && SUCCEEDED(hr) )
                            {
                                pVid->put_Visible( 0 );
                                pVid->Release();
                            }
                            break;

                        case RTCMET_FAILED:
                            printf("RTCMET_FAILED\n");
                            break;
                        }
                        
                        pM->Release();
                    }            
                    break; 
                    
                case RTCE_REGISTRATION_STATE_CHANGE:
                    {
                        IRTCRegistrationStateChangeEvent * pRSC;
                        IRTCProfile                      * pProfile;
                        RTC_REGISTRATION_STATE             enRS;
                        IDispatch                        * pDisp;
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCRegistrationStateChangeEvent,
                                               (void **)&pRSC
                                             );

                        pDisp->Release();
                                       
                        hr = pRSC->get_State(&enRS);

                        if ( FAILED(hr) )
                        {
                            printf("get_State failed 0x%lx\n", hr);

                            pRSC->Release();
                            return 0;
                        }

                        hr = pRSC->get_Profile(&pProfile);

                        if ( FAILED(hr) )
                        {
                            printf("get_Profile failed 0x%lx\n", hr);

                            pRSC->Release();
                            return 0;
                        }

                        switch(enRS)
                        {
                            case RTCRS_NOT_REGISTERED:
                                printf("RTCRS_NOT_REGISTERED [0x%lx]\n", pProfile);
                                break;

                            case RTCRS_REGISTERING:
                                printf("RTCRS_REGISTERING [0x%lx]\n", pProfile);
                                break;

                            case RTCRS_REGISTERED:
                                printf("RTCRS_REGISTERED [0x%lx]\n", pProfile);
                                break;

                            case RTCRS_REJECTED:
                                printf("RTCRS_REJECTED [0x%lx]\n", pProfile);
                                break;

                            case RTCRS_UNREGISTERING:
                                printf("RTCRS_UNREGISTERING [0x%lx]\n", pProfile);
                                break;

                            case RTCRS_ERROR:
                                printf("RTCRS_ERROR [0x%lx]\n", pProfile);
                                break;
                        }

                        pRSC->Release();
                        pProfile->Release();
                    }            
                    break;       
                    
                case RTCE_CLIENT:
                    {
                        IRTCClientEvent       * pC;
                        IDispatch             * pDisp;
                        RTC_CLIENT_EVENT_TYPE	enEventType; 
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCClientEvent,
                                               (void **)&pC
                                             );

                        pDisp->Release();
                                       
                        hr = pC->get_EventType(&enEventType);

                        if ( FAILED(hr) )
                        {
                            printf("get_EventType failed 0x%lx\n", hr);

                            pC->Release();
                            return 0;
                        }

                        if ( enEventType == RTCCET_ASYNC_CLEANUP_DONE )
                        {
                            DestroyWindow(hWnd);
                        }
                        
                        pC->Release();
                    }            
                    break; 
            }

            return 0;
        }

    case WM_CREATE_SESSION:
        {
            printf("Calling %ws...\n", (BSTR)wParam);

            if ( lParam )
            {
                printf("From %ws\n", (BSTR)lParam);

                hr = g_pClient->CreateSession( RTCST_PHONE_TO_PHONE, (BSTR)lParam, NULL, 0, &g_pSession );

                SysFreeString( (BSTR)lParam );
            }
            else
            {
                hr = g_pClient->CreateSession( RTCST_PC_TO_PC, NULL, NULL, 0, &g_pSession );
            }

            if ( FAILED(hr) )
            {
                printf("CreateSession failed 0x%lx\n", hr);

                DestroyWindow(hWnd);
            }

            BSTR bstrKey = SysAllocString(L"RTC");

            hr = g_pSession->put_EncryptionKey( RTCMT_ALL_RTP, bstrKey );

            SysFreeString( bstrKey );

            if ( FAILED(hr) )
            {
                printf("put_EncryptionKey failed 0x%lx\n", hr);

                DestroyWindow(hWnd);
            }

            hr = g_pSession->AddParticipant( (BSTR)wParam, NULL, NULL);

            if ( FAILED(hr) )
            {
                printf("AddParticipant failed 0x%lx\n", hr);

                DestroyWindow(hWnd);
            }

            SysFreeString( (BSTR)wParam );

            return 0;
        }

    case WM_LISTEN:
        {
            printf("Listening...\n");

            hr = g_pClient->put_ListenForIncomingSessions( RTCLM_BOTH );

            if ( FAILED(hr) )
            {
                printf("put_ListenForIncomingSessions failed 0x%lx\n", hr);

                DestroyWindow(hWnd);
            }

            return 0;
        }

    case WM_CREATE_PROFILE:
        {
            printf("Creating profile...\n");
    
            IRTCClientProvisioning * pProv;

            hr = g_pClient->QueryInterface( IID_IRTCClientProvisioning, (void**)&pProv );

            if ( FAILED(hr) )
            {
                printf("QueryInterface failed 0x%lx\n", hr);

                DestroyWindow(hWnd);
            }

            hr = pProv->CreateProfile( (BSTR)wParam, &g_pProfile );

            SysFreeString( (BSTR)wParam );

            if ( FAILED(hr) )
            {
                printf("CreateProfile failed 0x%lx\n", hr);

                DestroyWindow(hWnd);
            }

            printf("Enabling profile...\n");

            hr = pProv->EnableProfile( g_pProfile, 0 );

            if ( FAILED(hr) )
            {
                printf("EnableProfile failed 0x%lx\n", hr);

                DestroyWindow(hWnd);
            }

            pProv->Release();

            return 0;
        }

    default:
        return DefWindowProc( hWnd, uMsg, wParam, lParam );
    }

    return 0;
}

/////////////////////////////////////////////
//
// Main
// 

int _cdecl main(int argc, char* argv[])
{
    WNDCLASS wc;
    HWND     hWnd;
    MSG      msg;
    HRESULT  hr;

    hr =  CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if ( FAILED(hr) )
    {
        printf("CoInitializeEx failed 0x%lx\n", hr);

        return 0;
    }
    
    ZeroMemory(&wc, sizeof(WNDCLASS));

    wc.lpfnWndProc = WndProc;
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpszClassName = TEXT("RTCTestClass");
    
    if ( !RegisterClass( &wc ) )
    {
        printf("RegisterClass failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    }
    
    hWnd = CreateWindow(
            TEXT("RTCTestClass"),
            TEXT("RTCTest"),
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            NULL,
            NULL,
            GetModuleHandle(NULL),
            NULL
            );

    if ( hWnd == NULL )
    {
        printf("CreateWindow failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    }      

    if ( argc > 2 )
    {
        #define MAX_XML_LEN 8192

        WCHAR  wszFilename[MAX_PATH];  
        HANDLE hFile;
        DWORD  dwBytesRead;
        char   szXML[MAX_XML_LEN];
        WCHAR  wszXML[MAX_XML_LEN];
        BSTR   bstrXML;

        //
        // Get the filename
        //

        if ( !MultiByteToWideChar( CP_ACP, 0, argv[2], -1, wszFilename, MAX_PATH ) )
        {
            printf("MultiByteToWideChar failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()) );

            return 0;
        }
       
        //
        // Read the XML from the file
        //
    
        hFile = CreateFile( wszFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

        if ( hFile == INVALID_HANDLE_VALUE )
        {
            printf("CreateFile failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()) );

            return 0;
        }

        if ( !ReadFile( hFile, szXML, MAX_XML_LEN, &dwBytesRead, NULL ) )
        {
            printf("ReadFile failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()) );

            CloseHandle( hFile );

            return 0;
        }

        printf("Read file '%ws' %d bytes\n", wszFilename, dwBytesRead);

        CloseHandle( hFile );

        if ( !MultiByteToWideChar( CP_ACP, 0, szXML, dwBytesRead, wszXML, MAX_XML_LEN ) )
        {
            printf("MultiByteToWideChar failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()) );

            return 0;
        }

        printf("%ws\n", wszXML);

        bstrXML = SysAllocString(wszXML);

        PostMessage( hWnd, WM_CREATE_PROFILE, (WPARAM)bstrXML, 0 );
    }
    
    if ( argc > 1 )
    {
        BSTR bstrURI;
        WCHAR szURI[256];
        BSTR bstrLocalPhone = NULL;
        WCHAR szLocalPhone[256];

        MultiByteToWideChar( CP_ACP, 0, argv[1], -1, szURI, 256 );        

        bstrURI = SysAllocString(szURI);

        if ( argc > 3 )
        {
            MultiByteToWideChar( CP_ACP, 0, argv[3], -1, szLocalPhone, 256 );        

            bstrLocalPhone = SysAllocString(szLocalPhone);  
        }

        PostMessage( hWnd, WM_CREATE_SESSION, (WPARAM)bstrURI, (LPARAM)bstrLocalPhone );
    }
    else
    {
        PostMessage( hWnd, WM_LISTEN, 0, 0 );
    }

    while ( GetMessage( &msg, NULL, 0, 0 ) > 0 )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\dll\makefile.inc ===
$(O)\rtcerrlocal.mc: $(PROJECT_ROOT)\published\inc\rtcerr.mc
    -copy /v $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\test5\rtctest.cpp ===
#define UNICODE
#include <windows.h>
#include <RTCCore.h>
#include <stdio.h>

IRTCClient  * g_pClient = NULL;

/////////////////////////////////////////////
//
// WndProc
// 

LRESULT CALLBACK WndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hr;

    switch ( uMsg )
    {
    case WM_CREATE:
        {
            hr = CoCreateInstance(
                                  CLSID_RTCClient,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IRTCClient,
                                  (LPVOID *)&g_pClient
                                 );

            if ( FAILED(hr) )
            {
                printf("CoCreateInstance failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->Initialize();

            if ( FAILED(hr) )
            {
                printf("Initialize failed 0x%lx\n", hr);

                return -1;
            }

            PostMessage(hWnd, WM_DESTROY, 0, 0);

            hr = g_pClient->InvokeTuningWizard(NULL);

            if ( FAILED(hr) )
            {
                printf("InvokeTuningWizard failed 0x%lx\n", hr);

                return -1;
            }

            PostQuitMessage(0);
    
            return 0;
        }

    case WM_DESTROY:        
        {
            printf("Exiting...\n");           
            
            if ( g_pClient )
            {
                hr = g_pClient->Shutdown();

                if ( FAILED(hr) )
                {
                    printf("Shutdown failed 0x%lx\n", hr);
                }

                g_pClient->Release();
            }

            //PostQuitMessage(0);

            return 0;
        }

    default:
        return DefWindowProc( hWnd, uMsg, wParam, lParam );
    }

    return 0;
}

/////////////////////////////////////////////
//
// Main
// 

int _cdecl main(int argc, char* argv[])
{
    WNDCLASS wc;
    HWND     hWnd;
    MSG      msg;
    HRESULT  hr;

    hr =  CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if ( FAILED(hr) )
    {
        printf("CoInitializeEx failed 0x%lx\n", hr);

        return 0;
    }
    
    ZeroMemory(&wc, sizeof(WNDCLASS));

    wc.lpfnWndProc = WndProc;
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpszClassName = TEXT("RTCTestClass");
    
    if ( !RegisterClass( &wc ) )
    {
        printf("RegisterClass failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    }
    
    hWnd = CreateWindow(
            TEXT("RTCTestClass"),
            TEXT("RTCTest"),
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            NULL,
            NULL,
            GetModuleHandle(NULL),
            NULL
            );

    if ( hWnd == NULL )
    {
        printf("CreateWindow failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    }           

    while ( GetMessage( &msg, NULL, 0, 0 ) > 0 )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\dll\rtcdll.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCDLL.cpp

Abstract:

    Implementation of DLL exports.

--*/

#include "stdafx.h"
#include "dllres.h"
#include <initguid.h>

#include "RTCSip_i.c"
#include "RTCMedia_i.c"

//
// For the ntbuild environment we need to include this file to get the base
//  class implementations.

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_RTCClient, CRTCClient)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        LOGREGISTERDEBUGGER(_T("RTCDLL"));

        LOG((RTC_TRACE, "DllMain - DLL_PROCESS_ATTACH"));

        //
        // Create a heap for memory allocation
        //

        if ( RtcHeapCreate() == FALSE )
        {
            return FALSE;
        }
               
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);       
        
        // initialize Fusion
        SHFusionInitializeFromModuleID(_Module.GetResourceInstance(), 124);

        if (SipStackInitialize() != S_OK)
        {
            return FALSE;
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        LOG((RTC_TRACE, "DllMain - DLL_PROCESS_DETACH"));

        SipStackShutdown();
        
        SHFusionUninitialize();

#if DBG
        //
        // Make sure we didn't leak anything
        //
             
        RtcDumpMemoryList();
#endif

        //
        // Destroy the heap
        //
        
        RtcHeapDestroy();        

        //
        // Unregister for debug tracing
        //
        
        LOGDEREGISTERDEBUGGER() ;

        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // There are two typelibraries...
    HRESULT hr;

    // try to unregister old XP Beta2 components
    _Module.UpdateRegistryFromResource(IDR_DLLOLDSTUFF, FALSE, NULL);

    hr = _Module.RegisterServer(TRUE);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer(TRUE);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\dpnathlp\dpnhguid.cpp ===
#include <windows.h>
#include <winsock.h>
#include <iphlpapi.h>
#include <tchar.h>
#include <rpc.h>
// #include <objbase.h>
// #include <oledb.h>
// #include <oledberr.h>

// ANSI
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

#include <initguid.h>
#include <dpnathlp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\coresink.h ===
// coresink.h : header file for the COM object implementing
//  the IRTCEventNotification interface

#pragma once

#include "stdafx.h"

#define     WM_CORE_EVENT       WM_USER+301

class ATL_NO_VTABLE CRTCCoreNotifySink :
	public CComObjectRootEx<CComSingleThreadModel>,
    public IRTCEventNotification

{
public:
    CRTCCoreNotifySink()
    {
        m_dwCookie = 0;
        m_bConnected = FALSE;
    }

    ~CRTCCoreNotifySink()
    {
        ATLASSERT(!m_bConnected);
    }


DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRTCCoreNotifySink)
	COM_INTERFACE_ENTRY(IRTCEventNotification)
END_COM_MAP()

    // IRTCEventNotification
    STDMETHOD(Event)(RTC_EVENT enEvent, IDispatch * pEvent);

    HRESULT   AdviseControl(IUnknown *, CWindow *);
    HRESULT   UnadviseControl(void);

private:

    DWORD       m_dwCookie;
    BOOL        m_bConnected;
    CComPtr<IUnknown>
                m_pSource;
    CWindow     m_hTargetWindow;

};

extern CComObjectGlobal<CRTCCoreNotifySink> g_CoreNotifySink;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\coresink.cpp ===
// Ctlsink.cpp : Implementation of CRTCCoreNotifySink
#include "stdafx.h"
#include "coresink.h"

STDMETHODIMP CRTCCoreNotifySink::Event(RTC_EVENT enEvent, IDispatch * pEvent)
{
    //LOG((RTC_TRACE, "CRTCCoreNotifySink::Event - enter"));

    m_hTargetWindow.SendMessage(WM_CORE_EVENT, (WPARAM)enEvent, (LPARAM)pEvent);
    
    //LOG((RTC_TRACE, "CRTCCoreNotifySink::Event - exit"));
    return S_OK;
}

// AdviseControl
// Connects to the control
HRESULT CRTCCoreNotifySink::AdviseControl(IUnknown *pCoreIntf, CWindow *pTarget)
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCCoreNotifySink::AdviseControl - enter"));

    ATLASSERT(!m_bConnected);
    ATLASSERT(pCoreIntf);

    hr = AtlAdvise(pCoreIntf, this, IID_IRTCEventNotification, &m_dwCookie);

    if(SUCCEEDED(hr))
    {
        m_bConnected = TRUE;
        m_pSource = pCoreIntf;
        m_hTargetWindow = *pTarget;
    }
    else
    {
        LOG((RTC_ERROR, "CRTCCoreNotifySink::AdviseControl - errr (%x) when trying to Advise", hr));
    }

    LOG((RTC_TRACE, "CRTCCoreNotifySink::AdviseControl - exit"));

    return hr;
}

HRESULT  CRTCCoreNotifySink::UnadviseControl(void)
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCCoreNotifySink::UnadviseControl - enter"));

    if(m_bConnected)
    {
        hr = AtlUnadvise(m_pSource, IID_IRTCEventNotification, m_dwCookie);
        if(SUCCEEDED(hr))
        {
            m_bConnected = FALSE;
            m_pSource.Release();
        }
    }
    else
    {
        hr = S_OK;
    }

    LOG((RTC_TRACE, "CRTCCoreNotifySink::UnadviseControl - exit"));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\ctlsink.cpp ===
// Ctlsink.cpp : Implementation of CRTCCtlNotifySink
#include "stdafx.h"
#include "ctlsink.h"

STDMETHODIMP CRTCCtlNotifySink::OnControlStateChange(RTCAX_STATE State, UINT ResID)
{
    LOG((RTC_TRACE, "CRTCCtlNotifySink::OnControlStateChange(%d) - enter", State));

    m_hTargetWindow.SendMessage(WM_UPDATE_STATE, (WPARAM)State, LPARAM(ResID));
    
    LOG((RTC_TRACE, "CRTCCtlNotifySink::OnControlStateChange(%d) - exit", State));
    return S_OK;
}

// AdviseControl
// Connects to the control
HRESULT CRTCCtlNotifySink::AdviseControl(IUnknown *pControlIntf, CWindow *pTarget)
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCCtlNotifySink::AdviseControl - enter"));

    ATLASSERT(!m_bConnected);
    ATLASSERT(pControlIntf);

    hr = AtlAdvise(pControlIntf, this, IID_IRTCCtlNotify, &m_dwCookie);

    if(SUCCEEDED(hr))
    {
        m_bConnected = TRUE;
        m_pSource = pControlIntf;
        m_hTargetWindow = *pTarget;
    }
    else
    {
        LOG((RTC_ERROR, "CRTCCtlNotifySink::AdviseControl - errr (%x) when trying to Advise", hr));
    }

    LOG((RTC_TRACE, "CRTCCtlNotifySink::AdviseControl - exit"));

    return hr;
}

HRESULT  CRTCCtlNotifySink::UnadviseControl(void)
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCCtlNotifySink::UnadviseControl - enter"));

    if(m_bConnected)
    {
        hr = AtlUnadvise(m_pSource, IID_IRTCCtlNotify, m_dwCookie);
        if(SUCCEEDED(hr))
        {
            m_bConnected = FALSE;
            m_pSource.Release();
        }
    }
    else
    {
        hr = S_OK;
    }

    LOG((RTC_TRACE, "CRTCCtlNotifySink::UnadviseControl - exit"));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\dll\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__971134B4_012C_4FC2_B7EB_6CD55D5EE1B0__INCLUDED_)
#define AFX_STDAFX_H__971134B4_012C_4FC2_B7EB_6CD55D5EE1B0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#define ATL_TRACE_LEVEL     2

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlhost.h>
#include <control.h>

#include <commctrl.h>
#include <shfusion.h>

#include <rtccore.h>

#include <rtclog.h>
#include <rtcmem.h>
#include <rtcutils.h>
#include <rtcsip.h>
#include <rtcconnect.h>
#include <rtcclient.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__971134B4_012C_4FC2_B7EB_6CD55D5EE1B0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\ctlsink.h ===
// ctlsink.h : header file for the COM object implementing
//  the IRTCCtlNotify interface

#pragma once

#include "stdafx.h"

#define     WM_UPDATE_STATE     WM_USER+201

class ATL_NO_VTABLE CRTCCtlNotifySink :
	public CComObjectRootEx<CComSingleThreadModel>,
    public IRTCCtlNotify

{
public:
    CRTCCtlNotifySink()
    {
        m_dwCookie = 0;
        m_bConnected = FALSE;
    }

    ~CRTCCtlNotifySink()
    {
        ATLASSERT(!m_bConnected);
    }


//DECLARE_REGISTRY_RESOURCEID(IDR_RTCCTL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRTCCtlNotifySink)
	COM_INTERFACE_ENTRY(IRTCCtlNotify)
END_COM_MAP()

	STDMETHOD(OnControlStateChange)(RTCAX_STATE State, UINT ResID);

    HRESULT   AdviseControl(IUnknown *, CWindow *);
    HRESULT   UnadviseControl(void);

private:

    DWORD       m_dwCookie;
    BOOL        m_bConnected;
    CComPtr<IUnknown>
                m_pSource;
    CWindow     m_hTargetWindow;

};

extern CComObjectGlobal<CRTCCtlNotifySink> g_NotifySink;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\dplayhlp.h ===
// dplayhlp.h : Helpers for DirectPlay integration

#pragma once

#include <dplobby.h>

#define  LAUNCHED_FROM_LOBBY_SWITCH     L"Lobbied"

/////////////////////////////////////////////////////////////////////////////
// CRTCDPlay
//

class ATL_NO_VTABLE CRTCDPlay
{
public:

    static HRESULT WINAPI UpdateRegistry(BOOL bRegister);
    
    static void WINAPI ObjectMain(bool) {};
    
    BEGIN_CATEGORY_MAP(CRTCDPlay)
    END_CATEGORY_MAP()
    
    static  HRESULT DirectPlayConnect();
    static  void    DirectPlayDisconnect();

    static BOOL WINAPI EnumAddressCallback(
        REFGUID guidDataType,
        DWORD   dwDataSize,
        LPCVOID lpData,
        LPVOID  lpContext);

    static  WCHAR           s_Address[];

private:

    static  LPDIRECTPLAY4   s_pDirectPlay4;
   
};


extern CRTCDPlay   dpHelper;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\dplayhlp.cpp ===
//
// dplayhlp.cpp : helpers for DirectPlay integration
//

#include "stdafx.h"
#include <initguid.h>
#include "dplayhlp.h"
#include "urlreg.h"

CRTCDPlay   dpHelper;

// d8b09741-1c3d-4179-89b5-8cc8ddc636fa
const GUID appGuid = { 0xd8b09741, 0x1c3d, 0x4179, 
{ 0x89, 0xb5, 0x8c, 0xc8, 0xdd, 0xc6, 0x36, 0xfa}};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CRTCDPlay
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define MAX_ADDR_SIZE   0x1f

LPDIRECTPLAY4  CRTCDPlay::s_pDirectPlay4 = NULL;
WCHAR          CRTCDPlay::s_Address[MAX_ADDR_SIZE + 1];


HRESULT WINAPI CRTCDPlay::UpdateRegistry(BOOL bRegister)
{
    HRESULT             hr;

    // CoInitialize
    hr = CoInitialize(NULL);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCDPlay::UpdateRegistry: CoInitialize"
            " failed with error %x", hr));

        return hr;
    }

    LPDIRECTPLAYLOBBY3  pLobby3 = NULL;

    hr = CoCreateInstance(
        CLSID_DirectPlayLobby,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IDirectPlayLobby3,
        (LPVOID *)&pLobby3);
    
    if(FAILED(hr))
    {
        CoUninitialize();

        LOG((RTC_ERROR, "CRTCDPlay::UpdateRegistry: CoCreateInstance"
            " failed with error %x", hr));

        return hr;
    }
    
    ATLASSERT(pLobby3);

    if(bRegister)
    {

        DPAPPLICATIONDESC   appDesc;
        WCHAR               szPath[MAX_PATH + 1];
        WCHAR               szFileName[MAX_PATH + 1];



        szPath[0] = L'\0';
        GetShortModuleFileNameW(NULL, szPath, sizeof(szPath)/sizeof(szPath[0]));

        // extract the filename
        //
        // Search the last '\'
        WCHAR * pszSep = wcsrchr(szPath, L'\\');
        if(pszSep)
        {
            
            wcscpy(szFileName, pszSep + 1);

            // remove the filename from the path, keep the last backspace for "X:\" style
            if(pszSep - szPath == 2)
            {
                pszSep++;
            }

            *pszSep = L'\0';

            // Load name
            WCHAR   szAppName[0x80];
            CHAR    szAppNameA[0x80];

            szAppName[0] = L'\0';
            LoadStringW(
                _Module.GetResourceInstance(),
                IDS_APPNAME_FUNC,
                szAppName,
                sizeof(szAppName)/sizeof(szAppName[0]));
            
            szAppNameA[0] = '\0';
            LoadStringA(
                _Module.GetResourceInstance(),
                IDS_APPNAME_FUNC,
                szAppNameA,
                sizeof(szAppNameA)/sizeof(szAppNameA[0]));

            appDesc.dwSize = sizeof(DPAPPLICATIONDESC);
            appDesc.dwFlags = 0;
            // this is not localized !
            appDesc.lpszApplicationName = L"RTC Phoenix";
            appDesc.guidApplication = appGuid;
            appDesc.lpszFilename = szFileName;
            appDesc.lpszCommandLine = L"-" LAUNCHED_FROM_LOBBY_SWITCH;
            appDesc.lpszPath = szPath;
            appDesc.lpszCurrentDirectory = szPath;
            appDesc.lpszDescriptionA = szAppNameA;
            appDesc.lpszDescriptionW = szAppName;

            // register

            hr = pLobby3->RegisterApplication(
                0,
                (LPVOID)&appDesc);

            if(SUCCEEDED(hr))
            {
                LOG((RTC_TRACE, "CRTCDPlay::UpdateRegistry: DirectPlay"
                    " registration succeeded"));
            }
            else
            {
                LOG((RTC_ERROR, "CRTCDPlay::UpdateRegistry: RegisterApplication"
                    " failed with error %x", hr));
            }
        }
        else
        {
            LOG((RTC_ERROR, "CRTCDPlay::UpdateRegistry: the module path"
                " (%S) doesn't contain any backslash", szPath));

            hr = E_UNEXPECTED;
        }
    }
    else
    {
        // unregister

        hr = pLobby3->UnregisterApplication(
             0,
             appGuid);

        if(SUCCEEDED(hr))
        {
            LOG((RTC_TRACE, "CRTCDPlay::UpdateRegistry: DirectPlay"
                " unregistration succeeded"));
        }
        else
        {
            LOG((RTC_ERROR, "CRTCDPlay::UpdateRegistry: UnregisterApplication"
                " failed with error %x", hr));
        }
        
        // mask the error
        hr = S_OK;
    }

    //release the interface
    pLobby3->Release();
    pLobby3 = NULL;

    CoUninitialize();

    return hr;
}


HRESULT CRTCDPlay::DirectPlayConnect()
{
    HRESULT     hr;
    DWORD       dwSize;
    LPDIRECTPLAYLOBBY3  pLobby3 = NULL;

    DPLCONNECTION *pdpConnection;
    
    LOG((RTC_TRACE, "CRTCDPlay::DirectPlayConnect - enter"));

    hr = CoCreateInstance(
        CLSID_DirectPlayLobby,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IDirectPlayLobby3,
        (LPVOID *)&pLobby3);
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCDPlay::DirectPlayConnect: CoCreateInstance"
            " failed with error %x", hr));

        return hr;
    }

    // get connection settings from the lobby
    hr = pLobby3 -> GetConnectionSettings(0, NULL, &dwSize);
    if(FAILED(hr) && (DPERR_BUFFERTOOSMALL != hr))
    {
        LOG((RTC_ERROR, "CRTCDPlay::DirectPlayConnect: GetConnectionSettings"
            " failed with error %x", hr));
        
        pLobby3->Release();

        return hr;
    }

    // allocate space for connection settings
    pdpConnection = (DPLCONNECTION *)RtcAlloc(dwSize);
    if(pdpConnection == NULL)
    {
        pLobby3->Release();
        return E_OUTOFMEMORY;
    }

    hr = pLobby3->GetConnectionSettings(0, pdpConnection, &dwSize);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCDPlay::DirectPlayConnect: GetConnectionSettings"
            " failed with error %x", hr));
        
        pLobby3->Release();
        RtcFree(pdpConnection);
        return hr;
    }
        
    // Connect
    // This is a blocking call
    hr = pLobby3->ConnectEx(
        0,
        IID_IDirectPlay4,
        (LPVOID *)&s_pDirectPlay4,
        NULL);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCDPlay::DirectPlayConnect: ConnectEx"
            " failed with error %x", hr));
        
        pLobby3->Release();
        RtcFree(pdpConnection);
        return hr;
    }

    LOG((RTC_TRACE, "CRTCDPlay::DirectPlayConnect - ConnectEx succeeded"));
    
    s_Address[0] = L'\0';

    hr = S_OK;
    
    if(0 != pdpConnection ->dwAddressSize)
    {
        hr = pLobby3->EnumAddress(
            EnumAddressCallback,
            pdpConnection->lpAddress,
            pdpConnection->dwAddressSize,
            NULL);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCDPlay::DirectPlayConnect: EnumAddress"
                " failed with error %x", hr));
        }
    }
    
    pLobby3->Release();
    RtcFree(pdpConnection);
    
    LOG((RTC_TRACE, "CRTCDPlay::DirectPlayConnect - exit"));

    return hr;
}


void CRTCDPlay::DirectPlayDisconnect()
{
    if(s_pDirectPlay4)
    {
        s_pDirectPlay4->Close();
        s_pDirectPlay4->Release();
        s_pDirectPlay4 = NULL;
    }
}


BOOL WINAPI CRTCDPlay::EnumAddressCallback(
        REFGUID guidDataType,
        DWORD   dwDataSize,
        LPCVOID lpData,
        LPVOID  lpContext)
{
    BOOL    bRet = TRUE;

    if(DPAID_INet == guidDataType)
    {
        // copy the address
        MultiByteToWideChar(
            CP_ACP,
            0,
            (LPCSTR)lpData,
            -1,
            s_Address,
            MAX_ADDR_SIZE);

        s_Address[MAX_ADDR_SIZE] = L'\0';
        
        bRet = FALSE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\exereshm.h ===
#pragma once

extern WCHAR   g_szExeContextHelpFileName[];

// help ids
#define IDH_DIALOG_NAME_OPTIONS_EDIT_DISPLAYNAME                100
#define IDH_DIALOG_NAME_OPTIONS_EDIT_ADDRESS                    101
#define IDH_DIALOG_NAME_OPTIONS_CHECK_RUN_STARTUP               102 
#define IDH_DIALOG_NAME_OPTIONS_CHECK_MINIMIZE_CLOSE            103
#define IDH_DIALOG_NAME_OPTIONS_CHECK_DEFAULT_TELEPHONYAPP      104

#define IDH_DIALOG_URL_REGISTER_DONTASK                         200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\frameimpl.h ===
// RTCFrame.h : Declaration of the CRTCFrame

#ifndef __RTCFRAME_H_
#define __RTCFRAME_H_

/////////////////////////////////////////////////////////////////////////////
// CRTCFrame
//

class ATL_NO_VTABLE CRTCFrame : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CRTCFrame, &CLSID_RTCFrame>,
    public IDispatchImpl<IRTCFrame, &IID_IRTCFrame, &LIBID_RTCFRAMELib>
{
public:
    CRTCFrame()
    {
    }

DECLARE_NO_REGISTRY()
DECLARE_CLASSFACTORY_SINGLETON(CRTCFrame)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRTCFrame)
    COM_INTERFACE_ENTRY(IRTCFrame)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IRTCFrame
public:
    STDMETHOD(OnTop)();
    STDMETHOD(PlaceCall)(BSTR callString);
};

#endif //__RTCFRAME_H_


HRESULT ParseAndPlaceCall(IRTCCtlFrameSupport * pControlIf, BSTR bstrCallString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\frameimpl.cpp ===
// FrameProxy.cpp : Implementation of CRTCFrame
#include "stdafx.h"
#include "mainfrm.h"
#include "frameimpl.h"
#include "string.h"

/////////////////////////////////////////////////////////////////////////////
// CRTCFrame


HRESULT ParseAndPlaceCall(IRTCCtlFrameSupport * pControlIf, BSTR bstrCallString)
{
    BSTR    callStringCopy;

    BOOL fPhoneCall = FALSE;

    HRESULT hr = S_OK;
  

    LOG((RTC_TRACE, "ParseAndPlaceCall: Entered"));

    if (pControlIf == NULL)
    {
        LOG((RTC_ERROR, "ParseAndPlaceCall: Invalid param, pControlIf is NULL"));
        return E_INVALIDARG;
    }
    if (bstrCallString == NULL)
    {
        LOG((RTC_ERROR, "ParseAndPlaceCall: Invalid param, bstrCallString is NULL"));
        return E_INVALIDARG;
    }

    //
    // Now call the method with the parameters we have set above. We are using 
    // actual call string passed to us, we don't skip the sip or tel prefix.

    hr = pControlIf->Call(FALSE,        // bCallPhone (doesn't matter)
                          NULL,         // pDestName
                          bstrCallString,  // pDestAddress
                          FALSE,        // pDestAddressEditable
                          NULL,         // pLocalPhoneAddress
                          FALSE,        // bProfileSelected
                          NULL,         // pProfile
                          NULL);        // ppDestAddressChosen

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "ParseAndPlaceCall: Failed in invoking IRTCCtlFrameSupport->Call()(hr=0x%x)", hr));
        return hr;
    }

    // Everything is fine, return OK.
    
    LOG((RTC_TRACE, "ParseAndPlaceCall: Exited"));

    return S_OK;

}


STDMETHODIMP CRTCFrame::PlaceCall(BSTR callString)
{
     BSTR bstrCallStringCopy;

    LOG((RTC_TRACE, "CRTCFrame::PlaceCall: Entered"));

    LOG((RTC_TRACE, "URL to call: %S", callString));

    bstrCallStringCopy = ::SysAllocString(callString);
    if (bstrCallStringCopy == NULL)
    {
        LOG((RTC_ERROR, "CRTCFrame::PlaceCall: No memory to copy call string."));
        return E_OUTOFMEMORY;
    }

    // Post a window message..
    PostMessage(g_pMainFrm->m_hWnd, WM_REMOTE_PLACECALL, NULL, (LPARAM)bstrCallStringCopy);
    return S_OK;
}


STDMETHODIMP CRTCFrame::OnTop()
{
    g_pMainFrm->ShowWindow(SW_SHOW);
    g_pMainFrm->ShowWindow(SW_RESTORE);
    
    LOG((RTC_TRACE, "Window should be at Top now!"));
    
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\exeres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RTCCLNT.RC
//
#define IDS_PROJNAME                    100
#define IDS_APPNAME                     101
#define IDM_ABOUT                       104
#define IDS_MENU_ITEM_HELP_ABOUT        104
#define IDM_EXIT                        105
#define IDS_MENU_ITEM_HELP_EXIT         105
#define IDS_APPNAME_FUNC                106
#define IDC_UI                          109
#define IDI_APPICON                     110
#define IDB_TOOLBAR_DISABLED            113
#define IDB_TOOLBAR_HOT                 114
#define IDB_TOOLBAR_NORMAL              115
#define IDC_BUDDY_CONTEXT               116
#define IDD_DIALOG_INCOMING_CALL        117
#define IDB_CONTACT_LIST                118
#define IDC_NOTIFY_ICON_MENU            119
#define IDB_REDIAL_NORMAL               120
#define IDB_REDIAL_DISABLED             121
#define IDD_DIALOG_URL_REGISTER         122
#define IDR_ACCELERATOR_MAIN            124
#define IDC_NOTIFY_ICON                 125
#define IDD_DIALOG_NAME_OPTIONS         127
#define IDB_CLOSE_NORM                  128
#define IDB_CLOSE_PRESS                 129
#define IDB_CLOSE_MASK                  130
#define IDB_MIN_NORM                    131
#define IDB_MIN_PRESS                   132
#define IDB_MIN_MASK                    133
#define IDB_SYS_NORM                    134
#define IDB_SYS_MASK                    135
#define IDB_UI_BKGND                    136
#define IDB_BUTTON_NORM                 137
#define IDB_BUTTON_PRESS                138
#define IDB_BUTTON_HOT                  139
#define IDB_BUTTON_DIS                  140
#define IDB_CALLPC_NORM                 141
#define IDB_CALLPC_PRESS                142
#define IDB_CALLPC_DIS                  143
#define IDB_CALLPC_HOT                  144
#define IDB_CALLPHONE_NORM              145
#define IDB_CALLPHONE_PRESS             146
#define IDB_CALLPHONE_DIS               147
#define IDB_CALLPHONE_HOT               148
#define IDB_SMALLBUTTON_DIS             149
#define IDB_SMALLBUTTON_HOT             150
#define IDB_SMALLBUTTON_NORM            151
#define IDB_SMALLBUTTON_PRESS           152
#define IDD_DIALOG_ADD_BUDDY            153
#define IDD_DIALOG_EDIT_BUDDY           154
#define IDD_DIALOG_OFFER_WATCHER        155
#define IDD_DIALOG_PRESENCE_INFO        156
#define IDC_PRESENCE_STATUSES           157
#define IDD_DIALOG_CUSTOM_PRESENCE      158
#define IDC_STATUSBAR                   208
#define IDC_BUDDYLIST                   209
#define IDC_TOOLBAR                     210
#define IDC_STATIC_CALL_FROM            211
#define ID_YES                          211
#define ID_NO                           212
#define ID_NO_DONT_ASK_ME               213
#define IDC_CHECK_DONT_ASK_ME           214
#define IDC_EDIT_DISPLAYNAME            215
#define IDC_EDIT_USERURI                216
#define IDC_CHECK_RUNATSTARTUP          217
#define IDC_CHECK_MINIMIZEONCLOSE       219
#define IDC_TOOLBAR_MENU                220
#define IDC_STATUS_TEXT                 221
#define IDC_CHECK_CHECKDEFAULTAPP       221
#define IDC_STATUS_ELAPSED_TIME         222
#define ID_CANCEL                       223
#define ID_MINIMIZE                     224
#define ID_SYS                          225
#define ID_CALLPC                       226
#define ID_CALLPHONE                    227
#define ID_REDIAL                       228
#define ID_HANGUP                       229
#define ID_KEYPAD0                      230
#define ID_KEYPAD1                      231
#define ID_KEYPAD2                      232
#define ID_KEYPAD3                      233
#define ID_KEYPAD4                      234
#define ID_KEYPAD5                      235
#define ID_KEYPAD6                      236
#define ID_KEYPAD7                      237
#define ID_KEYPAD8                      238
#define ID_KEYPAD9                      239
#define ID_KEYPADSTAR                   240
#define ID_KEYPADPOUND                  241
#define IDC_COMBO_SERVICE_PROVIDER      242
#define IDC_COMBO_CALL_FROM             243
#define IDC_RADIO_FROM_PHONE            244
#define IDC_RADIO_FROM_COMPUTER         245
#define ID_CALL_FROM_EDIT               246
#define ID_SERVICE_PROVIDER_EDIT        247
#define IDS_NONE                        248
#define IDS_SELECT_PROVIDER             249
#define IDS_EDIT_LIST                   250
#define IDS_CALL_FROM                   251
#define IDS_CALL_TO                     252
#define IDS_MY_COMPUTER                 253
#define IDS_PHONE                       254
#define IDS_REDIAL                      255
#define IDS_HANGUP                      256
#define IDS_NO_BUDDIES                  257
#define IDS_CALL_PC                     258
#define IDS_CALL_PHONE                  259
#define IDC_EDIT_FIRST_NAME             260
#define IDC_EDIT_LAST_NAME              261
#define IDC_EDIT_EMAIL                  262
#define IDC_CHECK_ALLOW_MONITOR         263
#define IDC_EDIT_DISPLAY_NAME           264
#define IDC_EDIT_WATCHER_NAME           265
#define IDC_RADIO_ALLOW_MONITOR         266
#define IDC_RADIO_BLOCK_MONITOR         267
#define IDC_CHECK_ADD_AS_BUDDY          268
#define IDC_CHECK_AUTO_ALLOW            269
#define IDC_LIST_ALLOWED_USERS          270
#define IDC_LIST_BLOCKED_USERS          271
#define IDC_BUTTON_BLOCK                272
#define IDC_BUTTON_ALLOW                273
#define IDC_EDIT_CUSTOM_TEXT            273
#define IDC_BUTTON_REMOVE               274
#define ID_YES_DONT_ASK_ME              275
#define IDS_URL_TEL                     300
#define IDS_URL_SIP                     301
#define IDS_TEXT_REQUEST_BUDDY_STATUS   350
#define IDS_TEXT_REMOVE_BUDDY_STATUS    351
#define IDS_TEXT_CALL_BUDDY             352
#define IDS_TEXT_SEND_MESSAGE_BUDDY     353
#define IDS_TEXT_BUDDY_BUSY             354
#define IDS_TEXT_BUDDY_AWAY             355
#define IDS_TEXT_BUDDY_FORMAT           356
#define IDS_TEXT_BUDDY_ERROR            357
#define IDS_TEXT_BUDDY_OUT_TO_LUNCH     358
#define IDS_TEXT_BUDDY_BE_RIGHT_BACK    359
#define IDS_TEXT_BUDDY_ON_THE_PHONE     360
#define IDS_BUTTON_CALLPC               400
#define IDS_BUTTON_CALLPHONE            401
#define IDS_BUTTON_REDIAL               402
#define IDS_BUTTON_HANGUP               403
#define IDS_MENU_ITEM_HELP_CALLPC       500
#define IDM_CALL_CALLPC                 500
#define IDS_MENU_ITEM_HELP_CALLPHONE    501
#define IDM_CALL_CALLPHONE              501
#define IDS_MENU_ITEM_HELP_HANGUP       502
#define IDM_CALL_HANGUP                 502
#define IDS_MENU_ITEM_HELP_DND          503
#define IDM_CALL_DND                    503
#define IDS_MENU_ITEM_HELP_AUTOANSWER   504
#define IDM_CALL_AUTOANSWER             504
#define IDS_MENU_ITEM_HELP_HELPTOPICS   505
#define IDM_HELP_HELPTOPICS             505
#define IDS_MENU_ITEM_HELP_CALL_FROM_OPTIONS 506
#define IDM_TOOLS_CALL_FROM_OPTIONS     506
#define IDS_MENU_ITEM_HELP_SERVICE_PROVIDER_OPTIONS 507
#define IDM_TOOLS_SERVICE_PROVIDER_OPTIONS 507
#define IDM_TOOLS_TUNING_WIZARD         509
#define IDS_MENU_ITEM_HELP_TUNING_WIZ   509
#define IDM_CALL_REDIAL_MENU            510
#define IDS_MENU_ITEM_HELP_REDIAL_MENU  510
#define IDM_TOOLS_OUTGOINGVIDEO         511
#define IDS_MENU_ITEM_HELP_OUTVIDEO     511
#define IDM_TOOLS_INCOMINGVIDEO         512
#define IDS_MENU_ITEM_HELP_INCVIDEO     512
#define IDM_TOOLS_MUTE_SPEAKER          513
#define IDS_MENU_ITEM_HELP_MUTE_SPK     513
#define IDM_TOOLS_MUTE_MICROPHONE       514
#define IDS_MENU_ITEM_HELP_MUTE_MIC     514
#define ID_DO_NOTHING                   515
#define IDM_OPEN                        516
#define IDM_TOOLS_NAME_OPTIONS          517
#define IDS_MENU_ITEM_HELP_NAME_OPTIONS 517
#define IDM_TOOLS_VIEW_PREVIEW          518
#define IDS_MENU_ITEM_HELP_VIEW_PREVIEW 518
#define IDM_TOOLS_VIDEOPREVIEW          518
#define IDM_CALL_MESSAGE                519
#define IDS_MENU_ITEM_HELP_MESSAGE      519
#define IDM_TOOLS_PRESENCE_OPTIONS      520
#define IDS_MENU_ITEM_HELP_USER_PRESENCE_OPTIONS 520
#define IDM_TOOLS_PRESENCE_STATUS       521
#define IDS_MENU_ITEM_HELP_USER_PRESENCE_STATUS 521
#define IDM_PRESENCE_ONLINE             522
#define IDM_PRESENCE_AWAY               523
#define IDM_PRESENCE_BUSY               524
#define IDM_PRESENCE_OFFLINE            525
#define IDM_PRESENCE_CUSTOM_BUSY        526
#define IDM_PRESENCE_OUT_TO_LUNCH       527
#define IDM_PRESENCE_ON_THE_PHONE       529
#define IDM_PRESENCE_BE_RIGHT_BACK      530
#define IDM_PRESENCE_CUSTOM_AWAY        531
#define IDS_MENU_POPUP_HELP_CALL        550
#define IDS_MENU_POPUP_HELP_TOOLS       551
#define IDS_MENU_POPUP_HELP_HELP        552
#define IDC_MENU_ITEM                   560
#define IDC_MENU_ITEM_MAX               569
#define IDS_SB_STATUS_NONE              600
#define IDS_SB_STATUS_ERROR             601
#define IDS_SB_STATUS_IDLE              602
#define IDS_SB_STATUS_UI_BUSY           603
#define IDS_SB_STATUS_DIALING           604
#define IDS_SB_STATUS_CONNECTING        605
#define IDS_SB_STATUS_ANSWERING         606
#define IDS_SB_STATUS_DISCONNECTING     607
#define IDS_SB_STATUS_ALERTING          608
#define IDS_SB_STATUS_CONNECTED         609
#define IDM_NEW_BUDDY                   730
#define IDS_NEW_BUDDY                   730
#define IDM_EDIT_BUDDY                  731
#define IDS_EDIT_BUDDY                  731
#define IDM_DELETE_BUDDY                732
#define IDS_DELETE_BUDDY                732
#define IDS_CALL_BUDDY                  737
#define IDM_CALL_BUDDY                  737
#define IDS_SEND_MESSAGE_BUDDY          738
#define IDM_SEND_MESSAGE_BUDDY          738
#define IDM_REDIAL                      740
#define IDS_MENU_ITEM_HELP_REDIAL       740
#define IDM_REDIAL_MAX                  749
#define IDS_TIPS_CALLPC                 750
#define IDS_TIPS_CALLPHONE              751
#define IDS_TIPS_REDIAL                 752
#define IDS_TIPS_HANGUP                 753
#define IDS_ERROR_NO_HELP               754
#define IDS_REDIAL_NONE                 755
#define IDS_TIPS_MINIMIZE               756
#define IDS_TIPS_CLOSE                  757
#define IDS_TIPS_KEYPAD0                758
#define IDS_TIPS_KEYPAD1                759
#define IDS_TIPS_KEYPAD2                760
#define IDS_TIPS_KEYPAD3                761
#define IDS_TIPS_KEYPAD4                762
#define IDS_TIPS_KEYPAD5                763
#define IDS_TIPS_KEYPAD6                764
#define IDS_TIPS_KEYPAD7                765
#define IDS_TIPS_KEYPAD8                766
#define IDS_TIPS_KEYPAD9                767
#define IDS_TIPS_KEYPADSTAR             768
#define IDS_TIPS_KEYPADPOUND            769
#define IDS_TIPS_SERVICE_PROVIDER_EDIT  770
#define IDS_TIPS_CALL_FROM_EDIT         771
#define IDS_FORMAT_INCOMING_CALL_1      800
#define IDS_FORMAT_INCOMING_CALL_2      801
#define IDS_FORMAT_SHELL_STATUS         802
#define IDS_MESSAGE_CANTCALL            803
#define IDS_MESSAGE_SHOULDHANGUP        804
#define IDS_MESSAGE_CANTCALLINIT        805
#define IDS_MESSAGE_CLOSEANDDROPCALL    806
#define IDS_MESSAGE_EXITANDDROPCALL     807
#define IDS_MESSAGE_CANTCALLBUSY        808
#define IDS_MESSAGE_AXCTL_NOTFOUND      809
#define IDS_MESSAGE_AXCTL_INIT_FAILED   810
#define IDS_FORMAT_TITLE_WITH_STATUS    811
#define IDS_MESSAGE_CLOSEANDRELEASECALL 812
#define IDS_MESSAGE_EXITANDRELEASECALL  813
#define IDS_ERROR_ADD_BUDDY_NO_NAME     814
#define IDS_ERROR_ADD_BUDDY_NO_EMAIL    815
#define IDS_MESSAGE_ALLOW_MONITOR       816
#define IDS_CAPTION_ALLOW_MONITOR       817
#define IDS_FORMAT_ADDRESS_WITH_FRIENDLY_NAME 818
#define IDS_CHECK_ADD_AS_BUDDY          819
#define IDB_KEYPAD0_NORM                900
#define IDB_KEYPAD1_NORM                901
#define IDB_KEYPAD2_NORM                902
#define IDB_KEYPAD3_NORM                903
#define IDB_KEYPAD4_NORM                904
#define IDB_KEYPAD5_NORM                905
#define IDB_KEYPAD6_NORM                906
#define IDB_KEYPAD7_NORM                907
#define IDB_KEYPAD8_NORM                908
#define IDB_KEYPAD9_NORM                909
#define IDB_KEYPADSTAR_NORM             910
#define IDB_KEYPADPOUND_NORM            911
#define IDB_KEYPAD0_PRESS               912
#define IDB_KEYPAD1_PRESS               913
#define IDB_KEYPAD2_PRESS               914
#define IDB_KEYPAD3_PRESS               915
#define IDB_KEYPAD4_PRESS               916
#define IDB_KEYPAD5_PRESS               917
#define IDB_KEYPAD6_PRESS               918
#define IDB_KEYPAD7_PRESS               919
#define IDB_KEYPAD8_PRESS               920
#define IDB_KEYPAD9_PRESS               921
#define IDB_KEYPADSTAR_PRESS            922
#define IDB_KEYPADPOUND_PRESS           923
#define IDB_KEYPAD0_HOT                 924
#define IDB_KEYPAD1_HOT                 925
#define IDB_KEYPAD2_HOT                 926
#define IDB_KEYPAD3_HOT                 927
#define IDB_KEYPAD4_HOT                 928
#define IDB_KEYPAD5_HOT                 929
#define IDB_KEYPAD6_HOT                 930
#define IDB_KEYPAD7_HOT                 931
#define IDB_KEYPAD8_HOT                 932
#define IDB_KEYPAD9_HOT                 933
#define IDB_KEYPADSTAR_HOT              934
#define IDB_KEYPADPOUND_HOT             935
#define IDB_KEYPAD0_DIS                 936
#define IDB_KEYPAD1_DIS                 937
#define IDB_KEYPAD2_DIS                 938
#define IDB_KEYPAD3_DIS                 939
#define IDB_KEYPAD4_DIS                 940
#define IDB_KEYPAD5_DIS                 941
#define IDB_KEYPAD6_DIS                 942
#define IDB_KEYPAD7_DIS                 943
#define IDB_KEYPAD8_DIS                 944
#define IDB_KEYPAD9_DIS                 945
#define IDB_KEYPADSTAR_DIS              946
#define IDB_KEYPADPOUND_DIS             947
#define IDM_TOOLS_WHITEBOARD            948
#define IDM_TOOLS_SHARING               950
#define IDS_BUSINESS                    1100
#define IDS_BUSINESS2                   1101
#define IDS_CALLBACK                    1102
#define IDS_CAR                         1103
#define IDS_HOME                        1104
#define IDS_HOME2                       1105
#define IDS_MOBILE                      1106
#define IDS_OTHER                       1107
#define IDS_PAGER                       1108
#define IDS_PRIMARY                     1109
#define IDS_RADIO                       1110
#define IDS_TTYTDD                      1111
#define IDS_IPPHONE                     1112
#define IDS_EMAIL                       1113
#define IDS_WAB                         1200
#define IDS_CONTACTLIST_HEADER          1210

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        158
#define _APS_NEXT_COMMAND_VALUE         532
#define _APS_NEXT_CONTROL_VALUE         276
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\menuagent.cpp ===
#include "stdafx.h"
#include "menuagent.h"

HHOOK        CMenuAgent::m_hHook = NULL;
HWND         CMenuAgent::m_hWnd;
HWND         CMenuAgent::m_hToolbar;
HMENU        CMenuAgent::m_hSubMenu;
UINT         CMenuAgent::m_uFlagsLastSelected; 
HMENU        CMenuAgent::m_hMenuLastSelected;
POINT        CMenuAgent::m_ptLastMove;
int          CMenuAgent::m_nCancelled;

/////////////////////////////////////////////////////////////////////////////
//
//
void CMenuAgent::InstallHook(HWND hWnd, HWND hToolbar, HMENU hSubMenu)
{
    LOG((RTC_TRACE, "CMenuAgent::InstallHook"));

    m_hWnd = hWnd;
    m_hToolbar = hToolbar;
    m_hSubMenu = hSubMenu;
    m_nCancelled = MENUAGENT_NOT_CANCELLED;
    m_hMenuLastSelected = NULL;
    m_uFlagsLastSelected = 0;

    m_hHook = SetWindowsHookEx(WH_MSGFILTER, CMenuAgent::MessageProc, _Module.GetModuleInstance(), GetCurrentThreadId());
}

/////////////////////////////////////////////////////////////////////////////
//
//
void CMenuAgent::RemoveHook()
{
    LOG((RTC_TRACE, "CMenuAgent::RemoveHook"));

    if(m_hHook)
    {
        UnhookWindowsHookEx( m_hHook );
        m_hHook = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//
void CMenuAgent::CancelMenu(int nCancel)
{
    LOG((RTC_TRACE, "CMenuAgent::CancelMenu"));

    m_nCancelled = nCancel;

    //
    // Cancel the menu
    //

    PostMessage( m_hWnd, WM_CANCELMODE, 0, 0);

    //
    // Cleanup the toolbar
    //

    InvalidateRect(m_hToolbar, NULL, TRUE);
}

/////////////////////////////////////////////////////////////////////////////
//
//
BOOL CMenuAgent::IsInstalled()
{
    //LOG((RTC_TRACE, "CMenuAgent::IsInstalled"));

    if (m_hHook != NULL)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//
int CMenuAgent::WasCancelled()
{
    //LOG((RTC_TRACE, "CMenuAgent::WasCancelled"));

    return m_nCancelled;
}

/////////////////////////////////////////////////////////////////////////////
//
//
LRESULT CALLBACK CMenuAgent::MessageProc(
  int nCode,      // hook code
  WPARAM wParam,  // removal option
  LPARAM lParam   // message
)
{
    //LOG((RTC_INFO, "CMenuAgent::GetMsgProc"));

    LRESULT lRet = 0;
    MSG * pmsg = (MSG *)lParam;

    if (nCode >= 0)
    {       
        switch (pmsg->message)
        {
        case WM_KEYDOWN:
            {
                WPARAM vkey = pmsg->wParam;

                //LOG((RTC_INFO, "CMenuAgent::GetMsgProc - WM_KEYDOWN"));

                //
                // If the menu window is RTL mirrored, then the arrow keys should
                // be mirrored to reflect proper cursor movement.
                //
                if (GetWindowLongPtr(m_hWnd, GWL_EXSTYLE) & WS_EX_RTLREADING)
                {
                    switch (vkey)
                    {
                    case VK_LEFT:
                      vkey = VK_RIGHT;
                      break;

                    case VK_RIGHT:
                      vkey = VK_LEFT;
                      break;
                    }
                }
             
                switch (vkey)
                {
                case VK_RIGHT:
                    if (!m_hMenuLastSelected || !(m_uFlagsLastSelected & MF_POPUP) || (m_uFlagsLastSelected & MF_DISABLED) ) 
                    {
                        // if the currently selected item does not have a cascade, then 
                        // we need to cancel out of all of this and tell the top menu bar to go right

                        LOG((RTC_INFO, "CMenuAgent::GetMsgProc - RIGHT"));

                        CancelMenu(MENUAGENT_CANCEL_RIGHT);
                    }
                    break;
        
                case VK_LEFT:
                    if (!m_hMenuLastSelected || m_hMenuLastSelected == m_hSubMenu) 
                    {
                        // if the currently selected menu item is in our top level menu,
                        // then we need to cancel out of all this menu loop and tell the top menu bar
                        // to go left 

                        LOG((RTC_INFO, "CMenuAgent::GetMsgProc - LEFT"));

                        CancelMenu(MENUAGENT_CANCEL_LEFT);
                    }
                    break;        
                }
            }
            break;

        case WM_MENUSELECT:

            //LOG((RTC_INFO, "CMenuAgent::GetMsgProc - WM_MENUSELECT"));

            m_hMenuLastSelected = (HMENU)(pmsg->lParam);
            m_uFlagsLastSelected = HIWORD(pmsg->wParam);
            break;

        case WM_MOUSEMOVE:

            //LOG((RTC_INFO, "CMenuAgent::GetMsgProc - WM_MOUSEMOVE"));

            POINT pt;
            
            // In screen coords....
            pt.x = LOWORD(pmsg->lParam);
            pt.y = HIWORD(pmsg->lParam);  
            
            // Ignore duplicate mouse move
            if (m_ptLastMove.x == pt.x && 
                m_ptLastMove.y == pt.y)
            {
                break;
            }
            m_ptLastMove = pt;

            // Forward the mouse moves to the toolbar so the toolbar still
            // has a chance to hot track.  Must convert the points to the 
            // toolbar's client space.
            
            ::MapWindowPoints( NULL, m_hToolbar, &pt, 1 );

            SendMessage(m_hToolbar, pmsg->message, pmsg->wParam, 
                        MAKELPARAM(pt.x, pt.y));
            break;
        }
    }
    else
    {
        return CallNextHookEx(m_hHook, nCode, wParam, lParam);
    }

    // Pass it on to the next hook in the chain
    if (0 == lRet)
        lRet = CallNextHookEx(m_hHook, nCode, wParam, lParam);

    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\mainfrm.h ===
// mainfrm.h : Declaration of the CMainFrm

#ifndef __MAINFRM_H_
#define __MAINFRM_H_

#include "coresink.h"
#include "ctlsink.h"
#include "msg.h"
#include "frameimpl.h"
#include "urlreg.h"
#include "webctl.h"
#include "menuagent.h"
#include "imsconf3.h"
#include "sdkinternal.h"

#define BMP_COLOR_MASK RGB(255,0,255)

#define WM_SHELL_NOTIFY         WM_USER+3
#define WM_REMOTE_PLACECALL     WM_USER+4
#define WM_INIT_COMPLETED       WM_USER+5

#define BITMAPMENU_DEFAULT_WIDTH        18
#define BITMAPMENU_DEFAULT_HEIGHT       18
#define BITMAPMENU_TEXTOFFSET_X         24
#define BITMAPMENU_TABOFFSET            20
#define BITMAPMENU_SELTEXTOFFSET_X      (BITMAPMENU_TEXTOFFSET_X - 2)

#define UI_WIDTH                        600 //608
#define UI_HEIGHT                       440 //480

#define TITLE_TOP                       6
#define TITLE_BOTTOM                    28
#define TITLE_LEFT                      127 //131
#define TITLE_RIGHT                     475 //479
#define TITLE_HEIGHT                    (TITLE_BOTTOM-TITLE_TOP)
#define TITLE_WIDTH                     (TITLE_RIGHT-TITLE_LEFT)

#define MENU_TOP                        27
#define MENU_BOTTOM                     48
#define MENU_LEFT                       127 //131
#define MENU_RIGHT                      475 //479
#define MENU_HEIGHT                     (MENU_BOTTOM-MENU_TOP)
#define MENU_WIDTH                      (MENU_RIGHT-MENU_LEFT)

#define BROWSER_TOP                     55
#define BROWSER_BOTTOM                  112
#define BROWSER_LEFT                    131 //135
#define BROWSER_RIGHT                   471 //475
#define BROWSER_HEIGHT                  (BROWSER_BOTTOM-BROWSER_TOP)
#define BROWSER_WIDTH                   (BROWSER_RIGHT-BROWSER_LEFT)

#define MINIMIZE_TOP                    8
#define MINIMIZE_BOTTOM                 26
#define MINIMIZE_LEFT                   428 //432
#define MINIMIZE_RIGHT                  447 //451
#define MINIMIZE_HEIGHT                 (MINIMIZE_BOTTOM-MINIMIZE_TOP)
#define MINIMIZE_WIDTH                  (MINIMIZE_RIGHT-MINIMIZE_LEFT)

#define CLOSE_TOP                       8
#define CLOSE_BOTTOM                    26
#define CLOSE_LEFT                      450 //454
#define CLOSE_RIGHT                     469 //473
#define CLOSE_HEIGHT                    (CLOSE_BOTTOM-CLOSE_TOP)
#define CLOSE_WIDTH                     (CLOSE_RIGHT-CLOSE_LEFT)

#define SYS_TOP                         8
#define SYS_BOTTOM                      26
#define SYS_LEFT                        133 //137
#define SYS_RIGHT                       151 //155
#define SYS_HEIGHT                      (SYS_BOTTOM-SYS_TOP)
#define SYS_WIDTH                       (SYS_RIGHT-SYS_LEFT)

#define BUDDIES_TOP                     168 //196
#define BUDDIES_BOTTOM                  334 //362
#define BUDDIES_LEFT                    42
#define BUDDIES_RIGHT                   152
#define BUDDIES_HEIGHT                  (BUDDIES_BOTTOM-BUDDIES_TOP)
#define BUDDIES_WIDTH                   (BUDDIES_RIGHT-BUDDIES_LEFT)

#define ACTIVEX_TOP                     144 //146
#define ACTIVEX_BOTTOM                  390 //420
#define ACTIVEX_LEFT                    180 //184
#define ACTIVEX_RIGHT                   419 //424
#define ACTIVEX_HEIGHT                  (ACTIVEX_BOTTOM-ACTIVEX_TOP)
#define ACTIVEX_WIDTH                   (ACTIVEX_RIGHT-ACTIVEX_LEFT)

#define STATUS_TOP                      359 //394
#define STATUS_BOTTOM                   409 //449
#define STATUS_LEFT                     443
#define STATUS_RIGHT                    566
#define STATUS_HEIGHT                   (STATUS_BOTTOM-STATUS_TOP)
#define STATUS_WIDTH                    (STATUS_RIGHT-STATUS_LEFT)

#define TIMER_TOP                       410 //450
#define TIMER_BOTTOM                    426 //466
#define TIMER_LEFT                      443
#define TIMER_RIGHT                     566
#define TIMER_HEIGHT                    (TIMER_BOTTOM-TIMER_TOP)
#define TIMER_WIDTH                     (TIMER_RIGHT-TIMER_LEFT)

#define REDIAL_TOP                      364 //394
#define REDIAL_BOTTOM                   387 //417
#define REDIAL_LEFT                     35
#define REDIAL_RIGHT                    159
#define REDIAL_HEIGHT                   (REDIAL_BOTTOM-REDIAL_TOP)
#define REDIAL_WIDTH                    (REDIAL_RIGHT-REDIAL_LEFT)

#define HANGUP_TOP                      392 //422
#define HANGUP_BOTTOM                   415 //445
#define HANGUP_LEFT                     35
#define HANGUP_RIGHT                    159
#define HANGUP_HEIGHT                   (HANGUP_BOTTOM-HANGUP_TOP)
#define HANGUP_WIDTH                    (HANGUP_RIGHT-HANGUP_LEFT)

#define KEYPAD_ROW1                     172 //200
#define KEYPAD_ROW2                     212 //240
#define KEYPAD_ROW3                     252 //280
#define KEYPAD_ROW4                     292 //320
#define KEYPAD_COL1                     446 //452
#define KEYPAD_COL2                     486 //492
#define KEYPAD_COL3                     526 //532
#define KEYPAD_WIDTH                    26
#define KEYPAD_HEIGHT                   36

#ifdef MULTI_PROVIDER

    #define PROVIDER_TEXT_TOP               156 //184
    #define PROVIDER_TEXT_BOTTOM            172 //200
    #define PROVIDER_TEXT_LEFT              187
    #define PROVIDER_TEXT_RIGHT             420
    #define PROVIDER_TEXT_HEIGHT            (PROVIDER_TEXT_BOTTOM-PROVIDER_TEXT_TOP)
    #define PROVIDER_TEXT_WIDTH             (PROVIDER_TEXT_RIGHT-PROVIDER_TEXT_LEFT)

    #define PROVIDER_TOP                    177 //205
    #define PROVIDER_BOTTOM                 327 //355
    #define PROVIDER_LEFT                   207
    #define PROVIDER_RIGHT                  412 //420
    #define PROVIDER_HEIGHT                 (PROVIDER_BOTTOM-PROVIDER_TOP)
    #define PROVIDER_WIDTH                  (PROVIDER_RIGHT-PROVIDER_LEFT)

    #define PROVIDER_EDIT_TOP               203 //231
    #define PROVIDER_EDIT_BOTTOM            223 //251
    #define PROVIDER_EDIT_LEFT              332 //340
    #define PROVIDER_EDIT_RIGHT             412 //420
    #define PROVIDER_EDIT_HEIGHT            (PROVIDER_EDIT_BOTTOM-PROVIDER_EDIT_TOP)
    #define PROVIDER_EDIT_WIDTH             (PROVIDER_EDIT_RIGHT-PROVIDER_EDIT_LEFT)

    #define CALLFROM_TEXT_TOP               215 //239
    #define CALLFROM_TEXT_BOTTOM            231 //255
    #define CALLFROM_TEXT_LEFT              187
    #define CALLFROM_TEXT_RIGHT             420
    #define CALLFROM_TEXT_HEIGHT            (CALLFROM_TEXT_BOTTOM-CALLFROM_TEXT_TOP)
    #define CALLFROM_TEXT_WIDTH             (CALLFROM_TEXT_RIGHT-CALLFROM_TEXT_LEFT)

    #define CALLFROM_RADIO1_TOP             236 //260
    #define CALLFROM_RADIO1_BOTTOM          252 //276
    #define CALLFROM_RADIO1_LEFT            207
    #define CALLFROM_RADIO1_RIGHT           420
    #define CALLFROM_RADIO1_HEIGHT          (CALLFROM_RADIO1_BOTTOM-CALLFROM_RADIO1_TOP)
    #define CALLFROM_RADIO1_WIDTH           (CALLFROM_RADIO1_RIGHT-CALLFROM_RADIO1_LEFT)

    #define CALLFROM_RADIO2_TOP             256 //280
    #define CALLFROM_RADIO2_BOTTOM          272 //296
    #define CALLFROM_RADIO2_LEFT            207
    #define CALLFROM_RADIO2_RIGHT           420
    #define CALLFROM_RADIO2_HEIGHT          (CALLFROM_RADIO2_BOTTOM-CALLFROM_RADIO2_TOP)
    #define CALLFROM_RADIO2_WIDTH           (CALLFROM_RADIO2_RIGHT-CALLFROM_RADIO2_LEFT)

    #define CALLFROM_TOP                    275 //299
    #define CALLFROM_BOTTOM                 425 //449
    #define CALLFROM_LEFT                   207
    #define CALLFROM_RIGHT                  412 //420
    #define CALLFROM_HEIGHT                 (CALLFROM_BOTTOM-CALLFROM_TOP)
    #define CALLFROM_WIDTH                  (CALLFROM_RIGHT-CALLFROM_LEFT)

    #define CALLFROM_EDIT_TOP               301 //325
    #define CALLFROM_EDIT_BOTTOM            321 //345
    #define CALLFROM_EDIT_LEFT              332 //340
    #define CALLFROM_EDIT_RIGHT             412 //420
    #define CALLFROM_EDIT_HEIGHT            (CALLFROM_EDIT_BOTTOM-CALLFROM_EDIT_TOP)
    #define CALLFROM_EDIT_WIDTH             (CALLFROM_EDIT_RIGHT-CALLFROM_EDIT_LEFT)

    #define CALLTO_TEXT_TOP                 312 //330
    #define CALLTO_TEXT_BOTTOM              328 //346
    #define CALLTO_TEXT_LEFT                187
    #define CALLTO_TEXT_RIGHT               420
    #define CALLTO_TEXT_HEIGHT              (CALLTO_TEXT_BOTTOM-CALLTO_TEXT_TOP)
    #define CALLTO_TEXT_WIDTH               (CALLTO_TEXT_RIGHT-CALLTO_TEXT_LEFT)

    #define CALLPC_TOP                      333 //351
    #define CALLPC_BOTTOM                   376 //394
    #define CALLPC_LEFT                     210
    #define CALLPC_RIGHT                    253
    #define CALLPC_HEIGHT                   (CALLPC_BOTTOM-CALLPC_TOP)
    #define CALLPC_WIDTH                    (CALLPC_RIGHT-CALLPC_LEFT)

    #define CALLPC_TEXT_TOP                 379
    #define CALLPC_TEXT_BOTTOM              395
    #define CALLPC_TEXT_LEFT                205
    #define CALLPC_TEXT_RIGHT               258
    #define CALLPC_TEXT_HEIGHT              (CALLPC_TEXT_BOTTOM-CALLPC_TEXT_TOP)
    #define CALLPC_TEXT_WIDTH               (CALLPC_TEXT_RIGHT-CALLPC_TEXT_LEFT)

    #define CALLPHONE_TOP                   333 //351
    #define CALLPHONE_BOTTOM                376 //394
    #define CALLPHONE_LEFT                  270
    #define CALLPHONE_RIGHT                 313
    #define CALLPHONE_HEIGHT                (CALLPHONE_BOTTOM-CALLPHONE_TOP)
    #define CALLPHONE_WIDTH                 (CALLPHONE_RIGHT-CALLPHONE_LEFT)

    #define CALLPHONE_TEXT_TOP              379
    #define CALLPHONE_TEXT_BOTTOM           395
    #define CALLPHONE_TEXT_LEFT             265
    #define CALLPHONE_TEXT_RIGHT            318
    #define CALLPHONE_TEXT_HEIGHT           (CALLPHONE_TEXT_BOTTOM-CALLPHONE_TEXT_TOP)
    #define CALLPHONE_TEXT_WIDTH            (CALLPHONE_TEXT_RIGHT-CALLPHONE_TEXT_LEFT)

#else

    #define CALLTO_TEXT_TOP                 156
    #define CALLTO_TEXT_BOTTOM              172
    #define CALLTO_TEXT_LEFT                187
    #define CALLTO_TEXT_RIGHT               420
    #define CALLTO_TEXT_HEIGHT              (CALLTO_TEXT_BOTTOM-CALLTO_TEXT_TOP)
    #define CALLTO_TEXT_WIDTH               (CALLTO_TEXT_RIGHT-CALLTO_TEXT_LEFT)

    #define CALLPC_TOP                      177
    #define CALLPC_BOTTOM                   220
    #define CALLPC_LEFT                     210
    #define CALLPC_RIGHT                    253
    #define CALLPC_HEIGHT                   (CALLPC_BOTTOM-CALLPC_TOP)
    #define CALLPC_WIDTH                    (CALLPC_RIGHT-CALLPC_LEFT)

    #define CALLPC_TEXT_TOP                 223
    #define CALLPC_TEXT_BOTTOM              239
    #define CALLPC_TEXT_LEFT                205
    #define CALLPC_TEXT_RIGHT               258
    #define CALLPC_TEXT_HEIGHT              (CALLPC_TEXT_BOTTOM-CALLPC_TEXT_TOP)
    #define CALLPC_TEXT_WIDTH               (CALLPC_TEXT_RIGHT-CALLPC_TEXT_LEFT)

    #define CALLPHONE_TOP                   177
    #define CALLPHONE_BOTTOM                220
    #define CALLPHONE_LEFT                  270
    #define CALLPHONE_RIGHT                 313
    #define CALLPHONE_HEIGHT                (CALLPHONE_BOTTOM-CALLPHONE_TOP)
    #define CALLPHONE_WIDTH                 (CALLPHONE_RIGHT-CALLPHONE_LEFT)

    #define CALLPHONE_TEXT_TOP              223
    #define CALLPHONE_TEXT_BOTTOM           239
    #define CALLPHONE_TEXT_LEFT             265
    #define CALLPHONE_TEXT_RIGHT            318
    #define CALLPHONE_TEXT_HEIGHT           (CALLPHONE_TEXT_BOTTOM-CALLPHONE_TEXT_TOP)
    #define CALLPHONE_TEXT_WIDTH            (CALLPHONE_TEXT_RIGHT-CALLPHONE_TEXT_LEFT)

    #define CALLFROM_TEXT_TOP               248
    #define CALLFROM_TEXT_BOTTOM            264
    #define CALLFROM_TEXT_LEFT              187
    #define CALLFROM_TEXT_RIGHT             420
    #define CALLFROM_TEXT_HEIGHT            (CALLFROM_TEXT_BOTTOM-CALLFROM_TEXT_TOP)
    #define CALLFROM_TEXT_WIDTH             (CALLFROM_TEXT_RIGHT-CALLFROM_TEXT_LEFT)

    #define CALLFROM_RADIO1_TOP             269
    #define CALLFROM_RADIO1_BOTTOM          285
    #define CALLFROM_RADIO1_LEFT            207
    #define CALLFROM_RADIO1_RIGHT           420
    #define CALLFROM_RADIO1_HEIGHT          (CALLFROM_RADIO1_BOTTOM-CALLFROM_RADIO1_TOP)
    #define CALLFROM_RADIO1_WIDTH           (CALLFROM_RADIO1_RIGHT-CALLFROM_RADIO1_LEFT)

    #define CALLFROM_RADIO2_TOP             289
    #define CALLFROM_RADIO2_BOTTOM          305
    #define CALLFROM_RADIO2_LEFT            207
    #define CALLFROM_RADIO2_RIGHT           420
    #define CALLFROM_RADIO2_HEIGHT          (CALLFROM_RADIO2_BOTTOM-CALLFROM_RADIO2_TOP)
    #define CALLFROM_RADIO2_WIDTH           (CALLFROM_RADIO2_RIGHT-CALLFROM_RADIO2_LEFT)

    #define CALLFROM_TOP                    308
    #define CALLFROM_BOTTOM                 458
    #define CALLFROM_LEFT                   207
    #define CALLFROM_RIGHT                  412
    #define CALLFROM_HEIGHT                 (CALLFROM_BOTTOM-CALLFROM_TOP)
    #define CALLFROM_WIDTH                  (CALLFROM_RIGHT-CALLFROM_LEFT)

    #define CALLFROM_EDIT_TOP               334
    #define CALLFROM_EDIT_BOTTOM            354
    #define CALLFROM_EDIT_LEFT              332
    #define CALLFROM_EDIT_RIGHT             412
    #define CALLFROM_EDIT_HEIGHT            (CALLFROM_EDIT_BOTTOM-CALLFROM_EDIT_TOP)
    #define CALLFROM_EDIT_WIDTH             (CALLFROM_EDIT_RIGHT-CALLFROM_EDIT_LEFT)

#endif MULTI_PROVIDER

typedef BOOL (WINAPI *GRADIENTPROC)(HDC,PTRIVERTEX,ULONG,PUSHORT,ULONG,ULONG);

extern HANDLE g_hMutex;

/////////////////////////////////////////////////////////////////////////////
// CMainFrm
class CMainFrm : 
    public CWindowImpl<CMainFrm>
{
    friend class CRTCFrame;   

public:
    CMainFrm();

    ~CMainFrm();

    static CWndClassInfo& GetWndClassInfo();

    HRESULT BrowseToUrl(
        IN   WCHAR * wszUrl
        );

        // Method to place a pending call.
    HRESULT (PlacePendingCall)(
        void
        );

    HRESULT (SetPendingCall)(
        IN  BSTR      bstrCallString
        );

    enum { TID_CALL_TIMER = 1,
           TID_BROWSER_RETRY_TIMER,
           TID_DBLCLICK_TIMER,
           TID_SYS_TIMER,
           TID_MESSAGE_TIMER,
           TID_KEYPAD_TIMER_BASE
    };
    
    enum { MAX_STRING_LEN = 0x40 };
    
    enum { ILI_TB_CALLPC = 0,
           ILI_TB_CALLPHONE,
           ILI_TB_REDIAL,
           ILI_TB_HANGUP
           
    };

    enum { ILI_BL_BLANK = 0,
           ILI_BL_NONE,
           ILI_BL_ONLINE_NORMAL,
           ILI_BL_OFFLINE,
           ILI_BL_ONLINE_BUSY,
           ILI_BL_ONLINE_TIME
    };

    enum { IDX_MAIN = 1
    };

    enum { IDM_POPUP_CALL =0,
           IDM_POPUP_TOOLS,
           IDM_POPUP_HELP
    };

BEGIN_MSG_MAP(CMainFrm)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_QUERYENDSESSION, OnClose)
    MESSAGE_HANDLER(WM_CLOSE, OnClose)
    MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)
    MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
    MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysColorChange)
    MESSAGE_HANDLER(WM_INITMENU, OnInitMenu)
    MESSAGE_HANDLER(WM_INITMENUPOPUP, OnInitMenuPopup)
    MESSAGE_HANDLER(WM_SHELL_NOTIFY, OnShellNotify)
    MESSAGE_HANDLER(m_uTaskbarRestart, OnTaskbarRestart)
    MESSAGE_HANDLER(WM_MEASUREITEM, OnMeasureItem)
    MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
    MESSAGE_HANDLER(WM_REMOTE_PLACECALL, OnPlaceCall)
    MESSAGE_HANDLER(WM_INIT_COMPLETED, OnInitCompleted)
    MESSAGE_HANDLER(WM_UPDATE_STATE, OnUpdateState)
    MESSAGE_HANDLER(WM_CORE_EVENT, OnCoreEvent)
    MESSAGE_HANDLER(WM_NCPAINT, OnNCPaint)
    MESSAGE_HANDLER(WM_NCHITTEST, OnNCHitTest)
    MESSAGE_HANDLER(WM_NCLBUTTONDOWN, OnNCLButton)
    MESSAGE_HANDLER(WM_NCLBUTTONDBLCLK, OnNCLButtonDbl)
    MESSAGE_HANDLER(WM_NCRBUTTONDOWN, OnNCRButton)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
    MESSAGE_HANDLER(WM_ACTIVATE, OnActivate)
    MESSAGE_HANDLER(WM_CTLCOLORBTN, OnColorTransparent)
    MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorTransparent)
    MESSAGE_HANDLER(WM_QUERYNEWPALETTE, OnQueryNewPalette)
    MESSAGE_HANDLER(WM_PALETTECHANGED, OnPaletteChanged)
    MESSAGE_HANDLER(WM_DISPLAYCHANGE, OnDisplayChange)
    MESSAGE_HANDLER(WM_SYSCOMMAND, OnSysCommand)
    MESSAGE_HANDLER(WM_POWERBROADCAST, OnPowerBroadcast)
    NOTIFY_CODE_HANDLER(TBN_DROPDOWN, OnToolbarDropDown)
    NOTIFY_CODE_HANDLER(TBN_HOTITEMCHANGE, OnToolbarHotItemChange)
    NOTIFY_CODE_HANDLER(NM_CUSTOMDRAW, OnCustomDraw)
    NOTIFY_ID_HANDLER(IDC_BUDDYLIST, OnBuddyList)
    COMMAND_HANDLER(ID_CALLPC, BN_CLICKED, OnCallPC)
    COMMAND_HANDLER(ID_CALLPHONE, BN_CLICKED, OnCallPhone)
    COMMAND_HANDLER(ID_REDIAL, BN_CLICKED, OnRedial)
    COMMAND_HANDLER(ID_HANGUP, BN_CLICKED, OnHangUp)
    COMMAND_HANDLER(ID_CANCEL, BN_CLICKED, OnCancel)
    COMMAND_HANDLER(ID_MINIMIZE, BN_CLICKED, OnMinimize)
    COMMAND_HANDLER(IDC_RADIO_FROM_COMPUTER, BN_CLICKED, OnCallFromSelect)
    COMMAND_HANDLER(IDC_RADIO_FROM_COMPUTER, 1, OnCallFromSelect) // accelerator
    COMMAND_HANDLER(IDC_RADIO_FROM_PHONE, BN_CLICKED, OnCallFromSelect)
    COMMAND_HANDLER(IDC_RADIO_FROM_PHONE, 1, OnCallFromSelect) // accelerator
    COMMAND_HANDLER(ID_CALL_FROM_EDIT, BN_CLICKED, OnCallFromOptions)
    COMMAND_HANDLER(IDM_TOOLS_WHITEBOARD, BN_CLICKED, OnWhiteboard)
    COMMAND_HANDLER(IDM_TOOLS_SHARING, BN_CLICKED, OnSharing)
    COMMAND_HANDLER(ID_SERVICE_PROVIDER_EDIT, BN_CLICKED, OnServiceProviderOptions)
    COMMAND_ID_HANDLER(IDC_COMBO_SERVICE_PROVIDER, OnCallFromSelect)
    COMMAND_ID_HANDLER(IDC_COMBO_CALL_FROM, OnCallFromSelect)
    COMMAND_ID_HANDLER(IDM_CALL_CALLPC, OnCallPC)
    COMMAND_ID_HANDLER(IDM_CALL_CALLPHONE, OnCallPhone)
    COMMAND_ID_HANDLER(IDM_CALL_MESSAGE, OnMessage)
    COMMAND_ID_HANDLER(IDM_CALL_HANGUP, OnHangUp)
    COMMAND_ID_HANDLER(IDM_CALL_AUTOANSWER, OnAutoAnswer)
    COMMAND_ID_HANDLER(IDM_CALL_DND, OnDND)
    COMMAND_ID_HANDLER(IDM_TOOLS_TUNING_WIZARD, OnTuningWizard)
    COMMAND_ID_HANDLER(IDM_TOOLS_INCOMINGVIDEO, OnIncomingVideo)
    COMMAND_ID_HANDLER(IDM_TOOLS_OUTGOINGVIDEO, OnOutgoingVideo)
    COMMAND_ID_HANDLER(IDM_TOOLS_VIDEOPREVIEW, OnVideoPreview)
    COMMAND_ID_HANDLER(IDM_TOOLS_MUTE_SPEAKER, OnMuteSpeaker)
    COMMAND_ID_HANDLER(IDM_TOOLS_MUTE_MICROPHONE, OnMuteMicrophone)
    COMMAND_ID_HANDLER(IDM_TOOLS_NAME_OPTIONS, OnNameOptions)
    COMMAND_ID_HANDLER(IDM_TOOLS_CALL_FROM_OPTIONS, OnCallFromOptions)
    COMMAND_ID_HANDLER(IDM_TOOLS_PRESENCE_OPTIONS, OnUserPresenceOptions)
    COMMAND_ID_HANDLER(IDM_TOOLS_SERVICE_PROVIDER_OPTIONS, OnServiceProviderOptions)
    COMMAND_ID_HANDLER(IDM_HELP_HELPTOPICS, OnHelpTopics)
    COMMAND_ID_HANDLER(IDM_ABOUT, OnAbout)    
    COMMAND_ID_HANDLER(IDM_OPEN, OnOpen)    
    COMMAND_ID_HANDLER(IDM_EXIT, OnExit)    
    COMMAND_RANGE_HANDLER(IDM_REDIAL, IDM_REDIAL_MAX, OnRedialSelect)
    COMMAND_RANGE_HANDLER(ID_KEYPAD0, ID_KEYPADPOUND, OnKeypadButton)
    COMMAND_RANGE_HANDLER(IDM_PRESENCE_ONLINE, IDM_PRESENCE_CUSTOM_AWAY, OnPresenceSelect)
END_MSG_MAP()

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnSysCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnPowerBroadcast(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnNCPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnNCHitTest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnNCLButton(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnNCLButtonDbl(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnNCRButton(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnQueryNewPalette(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnPaletteChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnDisplayChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnColorTransparent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnOpen(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnMinimize(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnCallFromSelect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnExit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnUpdateState(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnCoreEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);  

    LRESULT OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnSettingChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnInitMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnInitMenuPopup(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnCallPC(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnCallPhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnMessage(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnHangUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnRedial(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnRedialSelect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnPresenceSelect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnKeypadButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnCustomDraw(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnToolbarDropDown(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnToolbarHotItemChange(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnAutoAnswer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnDND(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnIncomingVideo(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnOutgoingVideo(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnVideoPreview(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnMuteSpeaker(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnMuteMicrophone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnNameOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnCallFromOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnUserPresenceOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnWhiteboard(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnSharing(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnServiceProviderOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnTuningWizard(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnHelpTopics(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnAbout(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnShellNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnTaskbarRestart(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnMeasureItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnPlaceCall(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnInitCompleted(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnBuddyList(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // Enhances the default IsDialogMessage with a TranslateAccelerator behavior
    BOOL IsDialogMessage(LPMSG lpMsg);

private:

    HRESULT OnMediaEvent(IRTCMediaEvent *pEvent);
    
    HRESULT OnBuddyEvent(IRTCBuddyEvent *pEvent);   
    
    HRESULT OnWatcherEvent(IRTCWatcherEvent *pEvent);

    BOOL CreateTooltips();

    HRESULT MenuVerify(HMENU hMenu, WORD wID);

    void SetCurvedEdges(HWND hwnd, int nCurveWidth, int nCurveHeight);
    void SetUIMask();
    
    void UpdateBuddyList(void);
    void ReleaseBuddyList(void);

    // buddy related functions
    HRESULT     GetBuddyTextAndIcon(
        IRTCBuddy  *pBuddy,
        int     *pIconID,
        BSTR    *pbstrText);

    HRESULT     UpdateBuddyImageAndText(
        IRTCBuddy  *pBuddy);

    HRESULT CreateRedialPopupMenu(void);
    void DestroyRedialPopupMenu(void);

    void UpdateFrameVisual(void);
    
    void StartCallTimer(void);
    void StopCallTimer(void);
    void ClearCallTimer(void);
    void ShowCallTimer(void);

    void UpdateLocaleInfo(void);
    
    void SetTimeStatus(
        BOOL    bSet,
        DWORD   dwSeconds);    
    
    HRESULT CreateToolbarControl(void);
    void    DestroyToolbarControl(void);

    HRESULT CreateToolbarMenuControl(void);
    void    DestroyToolbarMenuControl(void);

    HRESULT ShowIncomingCallDlg(BOOL bShow);

    HRESULT CreateStatusIcon(void);
    void    DeleteStatusIcon(void);
    void    UpdateStatusIcon(HICON, LPTSTR);

    // This method reads from the registry and places the window appropriately

    HRESULT PlaceWindowCorrectly(void);

    //
    void    PlaceWindowsAtTheirInitialPosition();

    // This method puts the current window position in the registry.

    HRESULT SaveWindowPosition(void);

    HRESULT FillGradient(HDC hdc, LPCRECT prc, COLORREF rgbLeft, COLORREF rgbRight);
    void    DrawTitleBar(HDC memDC);

    void    InvalidateTitleBar(BOOL bIncludingButtons);

    HRESULT Call(BOOL bCallPhone,
                 BSTR pDestName,
                 BSTR pDestAddress,
                 BOOL bDestAddressEditable);

    HRESULT Message(
                 BSTR pDestName,
                 BSTR pDestAddress,
                 BOOL bDestAddressEditable);

	HRESULT ShowCallDropPopup(BOOL fExit, BOOL * pfProceed);

    HPALETTE GeneratePalette();

    HRESULT AddToAllowedWatchers(
        BSTR    bstrPresentityURI,
        BSTR    bstrUserName);

private:

    // private interface to the control
    CComPtr<IRTCCtlFrameSupport> m_pControlIntf;

    // interface to the core
    CComPtr<IRTCClient>     m_pClientIntf;

    // mirrors the AXCTL state
    RTCAX_STATE     m_nState;

    // freezes the UI, for avoiding flickering
    BOOL            m_bVisualStateFrozen;

    // Resource id of the string displayed in the status bar
    UINT            m_nStatusStringResID;

    // Auto Answer mode
    BOOL            m_bAutoAnswerMode;

    // Do Not Disturb mode
    BOOL            m_bDoNotDisturb;

    // Time separator (four characters plus NULL)
    TCHAR           m_szTimeSeparator[5];

    BOOL            m_bWindowActive;

    // Window controls
    CAxWindow       m_hMainCtl;
#ifdef WEBCONTROL
    CAxWebWindow    m_hBrowser;
#endif

    CWindow         m_hTooltip;

    CWindow         m_hToolbarCtl;
    CWindow         m_hToolbarMenuCtl;
    
    CStaticText     m_hStatusText;
    CStaticText     m_hStatusElapsedTime;

    CWindow         m_hBuddyList;

    CWindow         m_hProviderCombo;
    CStaticText     m_hProviderText;
    CButton         m_hProviderEditList;

    CWindow         m_hCallFromCombo;
    CStaticText     m_hCallFromText;
    CWindow         m_hCallFromRadioPhone;
    CStaticText     m_hCallFromTextPhone;
    CWindow         m_hCallFromRadioPC;
    CStaticText     m_hCallFromTextPC;
    CStaticText     m_hCallToText;
    CButton         m_hCallFromEditList;
    CStaticText     m_hCallPCText;
    CStaticText     m_hCallPhoneText;

    DWORD           m_dwTickCount;
    BOOL            m_bCallTimerActive;
    BOOL            m_bUseCallTimer;

    BOOL            m_bMessageTimerActive;

    BSTR            m_bstrLastBrowse;

    BSTR            m_bstrLastCustomStatus;
    
    // Libary for FillGradient
    HMODULE      m_hImageLib;
    GRADIENTPROC m_fnGradient;

    // Menu
    HMENU       m_hMenu;

    CMenuAgent  m_MenuAgent;
    int         m_nLastHotItem;

    // Icon
    HICON       m_hIcon;

    // Font
    HFONT       m_hMessageFont;
    
    // Status bar
    TCHAR       m_szStatusText[256];

    // Title bar
    BOOL        m_bTitleShowsConnected;

    // Palette
    HPALETTE    m_hPalette;

    BOOL        m_bBackgroundPalette;

    HMENU       m_hPresenceStatusMenu;

    // Bitmaps for the UI
    //HBITMAP     m_hUIBkgnd;
    HANDLE      m_hUIBkgnd;

    HBITMAP     m_hSysMenuNorm;
    HBITMAP     m_hSysMenuMask;

    // Buttons
    CButton     m_hCloseButton;
    CButton     m_hMinimizeButton;
    CButton     m_hRedialButton;
    CButton     m_hHangupButton;
    CButton     m_hCallPCButton;
    CButton     m_hCallPhoneButton;

    CButton     m_hKeypad0;
    CButton     m_hKeypad1;
    CButton     m_hKeypad2;
    CButton     m_hKeypad3;
    CButton     m_hKeypad4;
    CButton     m_hKeypad5;
    CButton     m_hKeypad6;
    CButton     m_hKeypad7;
    CButton     m_hKeypad8;
    CButton     m_hKeypad9;
    CButton     m_hKeypadStar;
    CButton     m_hKeypadPound;

    // Incoming call dialog box
    CIncomingCallDlg *
                m_pIncomingCallDlg;

    BOOL        m_bShellStatusActive;

    // registered TaskbarCreated message
    UINT        m_uTaskbarRestart;

    // TRUE -> No status help is displayed for menu items
    BOOL        m_bHelpStatusDisabled;

    // Handle to redial popup menu and image list
    HMENU       m_hRedialPopupMenu;
    HIMAGELIST  m_hRedialImageList;
    HIMAGELIST  m_hRedialDisabledImageList;

    // Accelerator
    HACCEL      m_hAccelTable;

    IRTCEnumAddresses * m_pRedialAddressEnum;

    // Keep the callparam string that will be used to make a call
    BSTR        m_bstrCallParam;

    // if TRUE, it means Initialization is done. 
    BOOL        m_fInitCompleted;

    // This is the notify menu to be shown when the m_fMinimizeOnClose is set
    HMENU       m_hNotifyMenu;

    // if it is set, closing the window doesn't exit the app.
    BOOL        m_fMinimizeOnClose;

    // Hidden window handle

    HWND        m_hwndHiddenWindow;

    // Default page URL
    BSTR        m_bstrDefaultURL;

private:

    static UINT s_iMenuHelp[];

};

extern CMainFrm * g_pMainFrm;

#endif //__MAINFRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\menuagent.h ===
// menuagent.h : Declaration of the CMenuAgent

#ifndef __MENUAGENT_H_
#define __MENUAGENT_H_

#define MENUAGENT_NOT_CANCELLED 0
#define MENUAGENT_CANCEL_HOVER  1
#define MENUAGENT_CANCEL_LEFT   2
#define MENUAGENT_CANCEL_RIGHT  3

class CMenuAgent
{    
public:

    void InstallHook(HWND hWnd, HWND hToolbar, HMENU hSubMenu);
    void RemoveHook();

    static void CancelMenu(int nCancel);
    BOOL IsInstalled();
    int  WasCancelled();

private:

    static HHOOK        m_hHook;
    static HWND         m_hWnd;
    static HWND         m_hToolbar;
    static HMENU        m_hSubMenu;

    static UINT         m_uFlagsLastSelected; 
    static HMENU        m_hMenuLastSelected;
    static POINT        m_ptLastMove;

    static int          m_nCancelled;

    static LRESULT CALLBACK CMenuAgent::MessageProc(
      int nCode,      // hook code
      WPARAM wParam,  // removal option
      LPARAM lParam   // message
    );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\msg.h ===
// msg.h : header file for message and small dialog boxes
//  

#pragma once

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// CIncomingCallDlg

class CIncomingCallDlg : 
    public CAxDialogImpl<CIncomingCallDlg>
{

public:
    CIncomingCallDlg();

    ~CIncomingCallDlg();
    
    enum { IDD = IDD_DIALOG_INCOMING_CALL };

    enum { TID_DLG = 1,
           TID_RING 
    };

BEGIN_MSG_MAP(CIncomingCallDlg)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)
    COMMAND_ID_HANDLER(IDCANCEL, OnReject)
    COMMAND_ID_HANDLER(IDOK, OnAccept)
END_MSG_MAP()


    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnReject(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnAccept(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    BOOL    IsWindowDestroyingItself(void) { return m_bDestroying; };

private:

    void    PopulateDialog(void);

    void    RingTheBell(BOOL bPlay);
    void    ExitProlog(void);

private:

    // pointer to the AX control
    IRTCCtlFrameSupport *m_pControl;

    // dialog box is going to autodestroy
    BOOL    m_bDestroying;

    RTC_TERMINATE_REASON    m_nTerminateReason;
};

/////////////////////////////////////////////////////////////////////////////
// CAddBuddyDlg

struct  CAddBuddyDlgParam
{
    BSTR	bstrDisplayName;
	BSTR	bstrEmailAddress;
    BOOL    bAllowWatcher;
};

class CAddBuddyDlg : 
    public CDialogImpl<CAddBuddyDlg>
{

public:
    CAddBuddyDlg();

    ~CAddBuddyDlg();
    
    enum { IDD = IDD_DIALOG_ADD_BUDDY };

    enum { MAX_STRING_LEN = 0x80 };

BEGIN_MSG_MAP(CAddBuddyDlg)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
    COMMAND_ID_HANDLER(IDOK, OnOK)
END_MSG_MAP()


    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:

    CAddBuddyDlgParam      *   m_pParam;

    CWindow                 m_hDisplayName;
    CWindow                 m_hEmailName;
};


/////////////////////////////////////////////////////////////////////////////
// CEditBuddyDlg

struct  CEditBuddyDlgParam
{
    BSTR	bstrDisplayName;
	BSTR	bstrEmailAddress;
};

class CEditBuddyDlg : 
    public CDialogImpl<CEditBuddyDlg>
{

public:
    CEditBuddyDlg();

    ~CEditBuddyDlg();
    
    enum { IDD = IDD_DIALOG_EDIT_BUDDY };

    enum { MAX_STRING_LEN = 0x80 };

BEGIN_MSG_MAP(CEditBuddyDlg)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
    COMMAND_ID_HANDLER(IDOK, OnOK)
END_MSG_MAP()


    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:

    CEditBuddyDlgParam      *   m_pParam;

    CWindow                 m_hDisplayName;
    CWindow                 m_hEmailName;
};

/////////////////////////////////////////////////////////////////////////////
// COfferWatcherDlg

struct  COfferWatcherDlgParam
{
    BSTR    bstrDisplayName;
	BSTR	bstrPresentityURI;
    BOOL    bAllowWatcher;
    BOOL    bAddBuddy;
};

class COfferWatcherDlg : 
    public CDialogImpl<COfferWatcherDlg>
{

public:
    COfferWatcherDlg();

    ~COfferWatcherDlg();
    
    enum { IDD = IDD_DIALOG_OFFER_WATCHER };

    enum { MAX_STRING_LEN = 0x80 };

BEGIN_MSG_MAP(COfferWatcherDlg)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
    COMMAND_ID_HANDLER(IDOK, OnOK)
END_MSG_MAP()


    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:

    COfferWatcherDlgParam   *   m_pParam;

    CWindow                 m_hWatcherName;
    CWindow                 m_hAddAsBuddy;
};


/////////////////////////////////////////////////////////////////////////////
// CUserPresenceInfoDlg

struct  CUserPresenceInfoDlgParam
{
    IRTCClientPresence    *pClientPresence;
};

struct  CUserPresenceInfoDlgEntry
{
    LPWSTR          pszDisplayName;   
    BOOL            bDeleted;
    BOOL            bChanged;
    BOOL            bAllowed;
    IRTCWatcher    *pWatcher;
};

class CUserPresenceInfoDlg : 
    public CDialogImpl<CUserPresenceInfoDlg>
{

public:
    CUserPresenceInfoDlg();

    ~CUserPresenceInfoDlg();
    
    enum { IDD = IDD_DIALOG_PRESENCE_INFO };

    enum { MAX_STRING_LEN = 0x80 };

BEGIN_MSG_MAP(COfferWatcherDlg)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
    COMMAND_ID_HANDLER(IDOK, OnOK)
    COMMAND_HANDLER(IDC_BUTTON_BLOCK, BN_CLICKED, OnBlock)
    COMMAND_HANDLER(IDC_BUTTON_ALLOW, BN_CLICKED, OnAllow)
    COMMAND_HANDLER(IDC_BUTTON_REMOVE, BN_CLICKED, OnRemove)
    COMMAND_HANDLER(IDC_CHECK_AUTO_ALLOW, BN_CLICKED, OnAutoAllow)
    COMMAND_HANDLER(IDC_LIST_ALLOWED_USERS, LBN_SETFOCUS, OnChangeFocus)
    COMMAND_HANDLER(IDC_LIST_BLOCKED_USERS, LBN_SETFOCUS, OnChangeFocus)

END_MSG_MAP()


    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnBlock(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnAllow(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnAutoAllow(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnChangeFocus(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:

    void        RemoveAll(void);

    void        UpdateVisual(void);
    void        Move(BOOL   bAllow);

private:

    CUserPresenceInfoDlgParam   *   m_pParam;

    CWindow     m_hAllowedList;
    CWindow     m_hBlockedList;
    CWindow     m_hAllowButton;
    CWindow     m_hBlockButton;
    CWindow     m_hRemoveButton;
    CWindow     m_hAutoAllowCheckBox;

    CRTCArray<CUserPresenceInfoDlgEntry *>
                m_Watchers;

    BOOL        m_bAllowDir;

    BOOL        m_bDirty;
};


/////////////////////////////////////////////////////////////////////////////
// CCustomPresenceDlg

struct  CCustomPresenceDlgParam
{
    BSTR    bstrText;
};

class CCustomPresenceDlg : 
    public CDialogImpl<CCustomPresenceDlg>
{

public:
    CCustomPresenceDlg();

    ~CCustomPresenceDlg();
    
    enum { IDD = IDD_DIALOG_CUSTOM_PRESENCE };

    enum { MAX_STRING_LEN = 0x80 };

BEGIN_MSG_MAP(CCustomPresenceDlg)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
    COMMAND_ID_HANDLER(IDOK, OnOK)
END_MSG_MAP()


    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:

    CCustomPresenceDlgParam   
                        *   m_pParam;

    CWindow                 m_hText;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\msg.cpp ===
// msg.cpp : Implementation of message and small dialog boxes
//
 
#include "stdafx.h"
#include "msg.h"

/////////////////////////////////////////////////////////////////////////////
// CIncomingCallDlg

#define     RING_BELL_INTERVAL      3000
#define     RING_TIMEOUT           32000


////////////////////////////////////////
//

CIncomingCallDlg::CIncomingCallDlg()
{
    LOG((RTC_TRACE, "CIncomingCallDlg::CIncomingCallDlg"));

    m_pControl = NULL;
    m_bDestroying = FALSE;

    m_nTerminateReason = RTCTR_REJECT;  // default

}


////////////////////////////////////////
//

CIncomingCallDlg::~CIncomingCallDlg()
{
    LOG((RTC_TRACE, "CIncomingCallDlg::~CIncomingCallDlg"));
}


////////////////////////////////////////
//

LRESULT CIncomingCallDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIncomingCallDlg::OnInitDialog - enter"));

    // LPARAM contains an interface to AXCTL
    m_pControl = reinterpret_cast<IRTCCtlFrameSupport *>(lParam);

    ATLASSERT(m_pControl);

    // exit the dialog if NULL pointer
    if(m_pControl)
    {
        m_pControl->AddRef();
    }
    else
    {
        LOG((RTC_ERROR, "CIncomingCallDlg::OnInitDialog - no parameter, exit"));

        DestroyWindow();
    }

    //
    // Populate the controls
    //

    PopulateDialog();

    // Create a timer that dismisses the dialog
    if(0 == SetTimer(TID_DLG, RING_TIMEOUT))
    {
        LOG((RTC_ERROR, "CIncomingCallDlg::OnInitDialog - cannot create ring timeout timer"));

        // not fatal
    }

    // Create a timer for ringing the bell
    if(0 == SetTimer(TID_RING, RING_BELL_INTERVAL))
    {
        LOG((RTC_ERROR, "CIncomingCallDlg::OnInitDialog - cannot create ring bell timer"));

        // not fatal
    }

    RingTheBell(TRUE);

    LOG((RTC_TRACE, "CIncomingCallDlg::OnInitDialog - exit"));
    
    return 1;
}
    

////////////////////////////////////////
//

LRESULT CIncomingCallDlg::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIncomingCallDlg::OnDestroy - enter"));

    if(m_pControl)
    {
        m_pControl->Release();
        m_pControl = NULL;
    }

    LOG((RTC_TRACE, "CIncomingCallDlg::OnDestroy - exit"));
    
    return 0;
}
    

////////////////////////////////////////
//

LRESULT CIncomingCallDlg::OnReject(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIncomingCallDlg::OnReject - enter"));
    
    ExitProlog();
    
    if(m_pControl)
    {
        m_pControl->Reject(m_nTerminateReason);
    }
    
    LOG((RTC_TRACE, "CIncomingCallDlg::OnReject - exiting"));
   
    DestroyWindow();
    return 0;
}

////////////////////////////////////////
//

LRESULT CIncomingCallDlg::OnAccept(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIncomingCallDlg::OnAccept - enter"));
    
    ExitProlog();
    
    if(m_pControl)
    {
        m_pControl->Accept();
    }
    
    LOG((RTC_TRACE, "CIncomingCallDlg::OnAccept - exiting"));
    
    DestroyWindow();
    return 0;
}

////////////////////////////////////////
//

LRESULT CIncomingCallDlg::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIncomingCallDlg::OnTimer - enter"));

    switch(wParam)
    {
    case TID_RING:

        // Ring the bell
        RingTheBell(TRUE);
        break;

    case TID_DLG:
        
        // change the reason to timeout
        m_nTerminateReason = RTCTR_TIMEOUT;

        // dismisses the dialog
        SendMessage(WM_COMMAND, IDCANCEL);
        break;
    }

    LOG((RTC_TRACE, "CIncomingCallDlg::OnTimer - exit"));
    
    return 0;
}

////////////////////////////////////////
//

void CIncomingCallDlg::RingTheBell(BOOL bPlay)
{
    HRESULT     hr;
    IRTCClient  *pClient = NULL;

    LOG((RTC_TRACE, "CIncomingCallDlg::RingTheBell(%s) - enter", bPlay ? "true" : "false"));

    if(m_pControl)
    {
        //
        // Get an interface to the core
        //

        hr = m_pControl->GetClient(&pClient);

        if(SUCCEEDED(hr))
        {
            // play
            pClient -> PlayRing( RTCRT_PHONE, bPlay ? VARIANT_TRUE : VARIANT_FALSE);

            pClient -> Release();
        }
        else
        {
            LOG((RTC_TRACE, "CIncomingCallDlg::RingTheBell(%s) - "
                "cannot get a pointer intf to the core, error %x", bPlay ? "true" : "false", hr));
        }
    }

    LOG((RTC_TRACE, "CIncomingCallDlg::RingTheBell(%s) - exit", bPlay ? "true" : "false"));
}

////////////////////////////////////////
//

void CIncomingCallDlg::PopulateDialog(void)
{
    HRESULT             hr;
    IRTCSession    *    pSession = NULL;
    IRTCEnumParticipants
                   *    pEnumParticipants = NULL;
    IRTCParticipant *   pCaller = NULL;
    
    LOG((RTC_TRACE, "CIncomingCallDlg::PopulateDialog - enter"));

    ATLASSERT(m_pControl);

    //
    // Get a ptr intf to the incoming session
    //

    hr = m_pControl -> GetActiveSession(&pSession);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CIncomingCallDlg::PopulateDialog - error (%x) returned by GetActiveSession, exit",hr));

        return;
    }

    //
    //  Enumerate the participants. The first and only one is the caller
    //

    ATLASSERT(pSession);

    hr = pSession->EnumerateParticipants(&pEnumParticipants);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CIncomingCallDlg::PopulateDialog - error (%x) returned by EnumParticipants, exit",hr));

        pSession->Release();

        return;
    }

    pSession ->Release();
    pSession = NULL;

    //
    //  Get the first one
    //  

    ULONG   nGot;

    ATLASSERT(pEnumParticipants);

    hr = pEnumParticipants -> Next(1, &pCaller, &nGot);
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CIncomingCallDlg::PopulateDialog - error (%x) returned by Next, exit",hr));

        pEnumParticipants->Release();

        return;
    }

    if(hr != S_OK)
    {
        LOG((RTC_ERROR, "CIncomingCallDlg::PopulateDialog - there is no participant in the session !!!"));

        pEnumParticipants->Release();

        return;
    }
    
    pEnumParticipants->Release();
    pEnumParticipants = NULL;

    //
    //  Grab the useful info from the caller
    //  
    BSTR    bstrName = NULL;
    BSTR    bstrAddress = NULL;

    hr = pCaller -> get_UserURI(&bstrAddress);
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CIncomingCallDlg::PopulateDialog - error (%x) returned by get_UserURI, exit",hr));

        pCaller->Release();

        return;
    }
    
    hr = pCaller -> get_Name(&bstrName);
    
    if(FAILED(hr))
    {
        LOG((RTC_WARN, "CIncomingCallDlg::PopulateDialog - error (%x) returned by get_Name",hr));
        
        // continue
    }

    pCaller ->Release();
    pCaller = NULL;

    // there are two formats, depending on the presence of the displayable format.

    UINT    nId;
    TCHAR   szFormat[0x80];
    DWORD   dwSize;
    LPTSTR  pString = NULL;
    LPTSTR  pszArray[2];

    nId = (bstrName==NULL || *bstrName == L'\0') ? 
        IDS_FORMAT_INCOMING_CALL_1 :
        IDS_FORMAT_INCOMING_CALL_2;

    szFormat[0] = _T('\0');
    LoadString(_Module.GetResourceInstance(),
        nId,
        szFormat,
        sizeof(szFormat)/sizeof(szFormat[0]));

    if(nId == IDS_FORMAT_INCOMING_CALL_1)
    {
        pszArray[0] = bstrAddress ? bstrAddress : L"";

        dwSize = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
            szFormat,
            0,
            0,
            (LPTSTR)&pString, // what an ugly hack
            0,
            (va_list *)pszArray
            );
    }
    else
    {
        pszArray[0] = bstrName;
        pszArray[1] = bstrAddress ? bstrAddress : L"";
        
        dwSize = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
            szFormat,
            0,
            0,
            (LPTSTR)&pString, // what an ugly hack
            0,
            (va_list *)pszArray
            );
    }

    SysFreeString(bstrName);
    SysFreeString(bstrAddress);
    
    if(dwSize==0)
    {
        LOG((RTC_ERROR, "CIncomingCallDlg::PopulateDialog - "
            "error (%x) returned by FormatMessage, exit",GetLastError()));
        return;
    }

    //
    // Finally we have something
    //
    
    ATLASSERT(pString);

    SetDlgItemText(IDC_STATIC_CALL_FROM, pString);

    LocalFree(pString);

    LOG((RTC_TRACE, "CIncomingCallDlg::PopulateDialog - exit"));
}

////////////////////////////////////////
//

void CIncomingCallDlg::ExitProlog()
{
    // stop any bell
    RingTheBell(FALSE);

    // Hide the window
    ShowWindow(SW_HIDE);

    // activates the app
    SetForegroundWindow(GetParent());

    // kill timers
    KillTimer(TID_RING);
    KillTimer(TID_DLG);

    // prevent the main window to destroy us
    m_bDestroying = TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CAddBuddyDlg


////////////////////////////////////////
//

CAddBuddyDlg::CAddBuddyDlg()
{
    LOG((RTC_TRACE, "CAddBuddyDlg::CAddBuddyDlg"));

    m_pParam = NULL;

}


////////////////////////////////////////
//

CAddBuddyDlg::~CAddBuddyDlg()
{
    LOG((RTC_TRACE, "CAddBuddyDlg::~CAddBuddyDlg"));
}


////////////////////////////////////////
//

LRESULT CAddBuddyDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CAddBuddyDlg::OnInitDialog - enter"));

    m_pParam = reinterpret_cast<CAddBuddyDlgParam *>(lParam);

    ATLASSERT(m_pParam);

    m_hDisplayName.Attach(GetDlgItem(IDC_EDIT_DISPLAY_NAME));
    m_hEmailName.Attach(GetDlgItem(IDC_EDIT_EMAIL));

    // fix max sizes
    m_hDisplayName.SendMessage(EM_LIMITTEXT, MAX_STRING_LEN, 0);
    m_hEmailName.SendMessage(EM_LIMITTEXT, MAX_STRING_LEN, 0);

    // default is checked
    CheckDlgButton(IDC_CHECK_ALLOW_MONITOR, BST_CHECKED);

    LOG((RTC_TRACE, "CAddBuddyDlg::OnInitDialog - exit"));
    
    return 1;
}
    
////////////////////////////////////////
//

LRESULT CAddBuddyDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CAddBuddyDlg::OnCancel"));
    
    EndDialog(E_ABORT);
    return 0;
}

////////////////////////////////////////
//

LRESULT CAddBuddyDlg::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CAddBuddyDlg::OnOK - enter"));
    
    // Validations
    CComBSTR    bstrDisplayName;
    CComBSTR    bstrEmailName;
    
    m_hDisplayName.GetWindowText(&bstrDisplayName);
    m_hEmailName.GetWindowText(&bstrEmailName);
    
    if( (!bstrDisplayName || *bstrDisplayName==L'\0'))
    {
        // we need at least something...
        DisplayMessage(
            _Module.GetResourceInstance(),
            m_hWnd,
            IDS_ERROR_ADD_BUDDY_NO_NAME,
            IDS_APPNAME,
            MB_ICONEXCLAMATION
            );

        m_hDisplayName.SetFocus();

        return 0;
    }

    if(!bstrEmailName || *bstrEmailName==L'\0')
    {
        // we need at least something...
        DisplayMessage(
            _Module.GetResourceInstance(),
            m_hWnd,
            IDS_ERROR_ADD_BUDDY_NO_EMAIL,
            IDS_APPNAME,
            MB_ICONEXCLAMATION
            );

        m_hEmailName.SetFocus();

        return 0;

    }

    m_pParam->bstrDisplayName = bstrDisplayName.Detach();
    m_pParam->bstrEmailAddress = bstrEmailName.Detach();

    m_pParam->bAllowWatcher = (BST_CHECKED == IsDlgButtonChecked(IDC_CHECK_ALLOW_MONITOR));

    LOG((RTC_TRACE, "CAddBuddyDlg::OnOK - exiting"));
    
    EndDialog(S_OK);
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CEditBuddyDlg


////////////////////////////////////////
//

CEditBuddyDlg::CEditBuddyDlg()
{
    LOG((RTC_TRACE, "CEditBuddyDlg::CEditBuddyDlg"));

    m_pParam = NULL;

}


////////////////////////////////////////
//

CEditBuddyDlg::~CEditBuddyDlg()
{
    LOG((RTC_TRACE, "CEditBuddyDlg::~CEditBuddyDlg"));
}


////////////////////////////////////////
//

LRESULT CEditBuddyDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CEditBuddyDlg::OnInitDialog - enter"));

    m_pParam = reinterpret_cast<CEditBuddyDlgParam *>(lParam);

    ATLASSERT(m_pParam);

    m_hDisplayName.Attach(GetDlgItem(IDC_EDIT_DISPLAY_NAME));
    m_hEmailName.Attach(GetDlgItem(IDC_EDIT_EMAIL));

    // fix max sizes
    m_hDisplayName.SendMessage(EM_LIMITTEXT, MAX_STRING_LEN, 0);
    m_hEmailName.SendMessage(EM_LIMITTEXT, MAX_STRING_LEN, 0);

    if (m_pParam->bstrDisplayName != NULL)
    {
        m_hDisplayName.SetWindowText(m_pParam->bstrDisplayName);
    }

    if (m_pParam->bstrEmailAddress != NULL)
    {
        m_hEmailName.SetWindowText(m_pParam->bstrEmailAddress);
    }

    LOG((RTC_TRACE, "CEditBuddyDlg::OnInitDialog - exit"));
    
    return 1;
}
    
////////////////////////////////////////
//

LRESULT CEditBuddyDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CEditBuddyDlg::OnCancel"));
    
    EndDialog(E_ABORT);
    return 0;
}

////////////////////////////////////////
//

LRESULT CEditBuddyDlg::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CEditBuddyDlg::OnOK - enter"));
    
    // Validations
    CComBSTR    bstrDisplayName;
    CComBSTR    bstrEmailName;
    
    m_hDisplayName.GetWindowText(&bstrDisplayName);
    m_hEmailName.GetWindowText(&bstrEmailName);
    
    if( (!bstrDisplayName || *bstrDisplayName==L'\0'))
    {
        // we need at least something...
        DisplayMessage(
            _Module.GetResourceInstance(),
            m_hWnd,
            IDS_ERROR_ADD_BUDDY_NO_NAME,
            IDS_APPNAME,
            MB_ICONEXCLAMATION
            );

        m_hDisplayName.SetFocus();

        return 0;
    }

    if(!bstrEmailName || *bstrEmailName==L'\0')
    {
        // we need at least something...
        DisplayMessage(
            _Module.GetResourceInstance(),
            m_hWnd,
            IDS_ERROR_ADD_BUDDY_NO_EMAIL,
            IDS_APPNAME,
            MB_ICONEXCLAMATION
            );

        m_hEmailName.SetFocus();

        return 0;

    }

    if (m_pParam->bstrDisplayName != NULL)
    {
        SysFreeString(m_pParam->bstrDisplayName);
        m_pParam->bstrDisplayName = NULL;
    }

    m_pParam->bstrDisplayName = bstrDisplayName.Detach();

    if (m_pParam->bstrEmailAddress != NULL)
    {
        SysFreeString(m_pParam->bstrEmailAddress);
        m_pParam->bstrEmailAddress = NULL;
    }

    m_pParam->bstrEmailAddress = bstrEmailName.Detach();

    LOG((RTC_TRACE, "CEditBuddyDlg::OnOK - exiting"));
    
    EndDialog(S_OK);
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// COfferWatcherDlg


////////////////////////////////////////
//

COfferWatcherDlg::COfferWatcherDlg()
{
    LOG((RTC_TRACE, "COfferWatcherDlg::COfferWatcherDlg"));

    m_pParam = NULL;

}


////////////////////////////////////////
//

COfferWatcherDlg::~COfferWatcherDlg()
{
    LOG((RTC_TRACE, "COfferWatcherDlg::~COfferWatcherDlg"));
}


////////////////////////////////////////
//

LRESULT COfferWatcherDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "COfferWatcherDlg::OnInitDialog - enter"));

    m_pParam = reinterpret_cast<COfferWatcherDlgParam *>(lParam);

    ATLASSERT(m_pParam);

    m_hWatcherName.Attach(GetDlgItem(IDC_EDIT_WATCHER_NAME));
    m_hAddAsBuddy.Attach(GetDlgItem(IDC_CHECK_ADD_AS_BUDDY));

    // do we have friendly name ?
    BOOL bFriendly = (m_pParam->bstrDisplayName && *m_pParam->bstrDisplayName);

    LPTSTR  pString = NULL;
    LPTSTR  pszArray[2];
    DWORD   dwSize;
    TCHAR   szFormat[MAX_STRING_LEN];

    // the address
    if(bFriendly)
    {
        pszArray[0] = m_pParam->bstrDisplayName;
        pszArray[1] = m_pParam->bstrPresentityURI ? m_pParam->bstrPresentityURI : _T("");
        
        szFormat[0] = _T('\0');
        LoadString(_Module.GetResourceInstance(),
            IDS_FORMAT_ADDRESS_WITH_FRIENDLY_NAME,
            szFormat,
            sizeof(szFormat)/sizeof(szFormat[0]));
    
        dwSize = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_STRING |
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
                szFormat,
                0,
                0,
                (LPTSTR)&pString, // what an ugly hack
                0,
                (va_list *)pszArray
                );

        if(dwSize>0)
        {
            m_hWatcherName.SetWindowText(pString);

            LocalFree(pString);
            pString = NULL;
        }
    }
    else
    {
        m_hWatcherName.SetWindowText(m_pParam->bstrPresentityURI);
    }

    // the check box
    pszArray[0] = bFriendly ? m_pParam->bstrDisplayName : m_pParam->bstrPresentityURI;

    szFormat[0] = _T('\0');
    LoadString(_Module.GetResourceInstance(),
        IDS_CHECK_ADD_AS_BUDDY,
        szFormat,
        sizeof(szFormat)/sizeof(szFormat[0]));
    
    dwSize = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
            szFormat,
            0,
            0,
            (LPTSTR)&pString, // what an ugly hack
            0,
            (va_list *)pszArray
            );
 
    if(dwSize>0)
    {
        m_hAddAsBuddy.SetWindowText(pString);

        LocalFree(pString);
        pString = NULL;
    }

    // defaults
    CheckDlgButton(IDC_RADIO_ALLOW_MONITOR, BST_CHECKED);
    //CheckDlgButton(IDC_CHECK_ADD_AS_BUDDY, BST_CHECKED);

    // focus
    ::SetFocus(GetDlgItem(IDC_RADIO_ALLOW_MONITOR));

    LOG((RTC_TRACE, "COfferWatcherDlg::OnInitDialog - exit"));
    
    return 0;  // WE set the focus !!
}
    
////////////////////////////////////////
//

LRESULT COfferWatcherDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "COfferWatcherDlg::OnCancel"));
    
    EndDialog(E_ABORT);
    return 0;
}

////////////////////////////////////////
//

LRESULT COfferWatcherDlg::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "COfferWatcherDlg::OnOK - enter"));
    
    m_pParam->bAddBuddy = (BST_CHECKED == IsDlgButtonChecked(IDC_CHECK_ADD_AS_BUDDY));
    m_pParam->bAllowWatcher = (BST_CHECKED == IsDlgButtonChecked(IDC_RADIO_ALLOW_MONITOR));

    LOG((RTC_TRACE, "COfferWatcherDlg::OnOK - exiting"));
    
    EndDialog(S_OK);
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CUserPresenceInfoDlg


////////////////////////////////////////
//

CUserPresenceInfoDlg::CUserPresenceInfoDlg()
{
    LOG((RTC_TRACE, "CUserPresenceInfoDlg::CUserPresenceInfoDlg"));

    m_pParam = NULL;

}


////////////////////////////////////////
//

CUserPresenceInfoDlg::~CUserPresenceInfoDlg()
{
    LOG((RTC_TRACE, "CUserPresenceInfoDlg::~CUserPresenceInfoDlg"));
}


////////////////////////////////////////
//

LRESULT CUserPresenceInfoDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CUserPresenceInfoDlg::OnInitDialog - enter"));

    m_pParam = reinterpret_cast<CUserPresenceInfoDlgParam *>(lParam);

    ATLASSERT(m_pParam);

    m_hAllowedList.Attach(GetDlgItem(IDC_LIST_ALLOWED_USERS));
    m_hBlockedList.Attach(GetDlgItem(IDC_LIST_BLOCKED_USERS));
    m_hAllowButton.Attach(GetDlgItem(IDC_BUTTON_ALLOW));
    m_hBlockButton.Attach(GetDlgItem(IDC_BUTTON_BLOCK));
    m_hRemoveButton.Attach(GetDlgItem(IDC_BUTTON_REMOVE));
    m_hAutoAllowCheckBox.Attach(GetDlgItem(IDC_CHECK_AUTO_ALLOW));

    // temporary
    m_hAllowedList.SendMessage(LB_SETHORIZONTALEXTENT, 400, 0);
    m_hBlockedList.SendMessage(LB_SETHORIZONTALEXTENT, 400, 0);

    //
    m_bAllowDir = FALSE;

    //
    // Enumerate watchers
    //
    if(m_pParam->pClientPresence)
    {
        m_pParam->pClientPresence->AddRef();
        
        CComPtr<IRTCEnumWatchers> pRTCEnumWatchers;

        hr = m_pParam->pClientPresence->EnumerateWatchers(&pRTCEnumWatchers);
        if(SUCCEEDED(hr))
        {
            IRTCWatcher *   pWatcher = NULL;
            DWORD           dwReturned;

            // Enumerate the watchers
            while (S_OK == (hr = pRTCEnumWatchers->Next(1, &pWatcher, &dwReturned)))
            {
                // Allocate an entry
                CUserPresenceInfoDlgEntry *pEntry =
                    (CUserPresenceInfoDlgEntry *)RtcAlloc(sizeof(CUserPresenceInfoDlgEntry));

                ZeroMemory(pEntry, sizeof(*pEntry));

                // Get all the info from the watcher. 
                // State
                RTC_WATCHER_STATE  nState;

                hr = pWatcher->get_State(&nState);
                if(SUCCEEDED(hr))
                {
                    // ignore OFFERING state
                    if(nState == RTCWS_ALLOWED || nState == RTCWS_BLOCKED)
                    {
                        pEntry -> bAllowed = (nState == RTCWS_ALLOWED);
                        
                        CComBSTR    bstrPresentityURI;
                        CComBSTR    bstrUserName;

                        hr = pWatcher->get_PresentityURI(&bstrPresentityURI);
                        if(FAILED(hr))
                        {
                            LOG((RTC_ERROR, "CUserPresenceInfoDlg::OnInitDialog - "
                                "error (%x) returned by get_PresentityURI",hr));
                        }
                        
                        hr = pWatcher->get_Name(&bstrUserName);
                        if(FAILED(hr))
                        {
                            LOG((RTC_ERROR, "CUserPresenceInfoDlg::OnInitDialog - "
                                "error (%x) returned by get_Name",hr));
                        }

                        // find name to be displayed
                        if(bstrUserName && *bstrUserName)
                        {
                            LPTSTR  pString = NULL;
                            LPTSTR  pszArray[2];
                            DWORD   dwSize;
                            TCHAR   szFormat[MAX_STRING_LEN];

                            pszArray[0] = bstrUserName;
                            pszArray[1] = bstrPresentityURI ? bstrPresentityURI : _T("");
        
                            szFormat[0] = _T('\0');
                            LoadString(_Module.GetResourceInstance(),
                                IDS_FORMAT_ADDRESS_WITH_FRIENDLY_NAME,
                                szFormat,
                                sizeof(szFormat)/sizeof(szFormat[0]));
    
                            dwSize = FormatMessage(
                                    FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                                    FORMAT_MESSAGE_FROM_STRING |
                                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                    szFormat,
                                    0,
                                    0,
                                    (LPTSTR)&pString, // what an ugly hack
                                    0,
                                    (va_list *)pszArray
                                    );

                            if(dwSize>0)
                            {
                                pEntry->pszDisplayName = RtcAllocString(pString);;

                                LocalFree(pString);
                                pString = NULL;
                            }
                        }
                        else
                        {
                            pEntry ->pszDisplayName = RtcAllocString(
                                bstrPresentityURI ? bstrPresentityURI : L"");
                        }
                        
                    }
                    
                    // Add the entry to the array
                    BOOL Bool = m_Watchers.Add(pEntry);
                    
                    if(Bool)
                    {
                        //store a watcher pointer
                        pEntry->pWatcher = pWatcher;
                        pEntry->pWatcher->AddRef();

                        // this is all..
                    }
                    else
                    {
                        LOG((RTC_ERROR, "CUserPresenceInfoDlg::OnInitDialog - "
                            "out of memory"));

                        // free...
                        if(pEntry->pszDisplayName)
                        {
                            RtcFree(pEntry->pszDisplayName);
                        }
                
                        RtcFree(pEntry);
                    }
                }
                else
                {
                    LOG((RTC_ERROR, "CUserPresenceInfoDlg::OnInitDialog - "
                        "error (%x) returned by get_State",hr));
                }
                
                pWatcher -> Release();
                pWatcher = NULL;

            } // while
        }
        else
        {
            LOG((RTC_ERROR, "CUserPresenceInfoDlg::OnInitDialog - "
                "error (%x) returned by EnumerateWatchers",hr));
        }
    }

    //
    // Read the offer watcher mode
    //
    RTC_OFFER_WATCHER_MODE   nOfferMode;

    hr = m_pParam->pClientPresence->get_OfferWatcherMode(&nOfferMode);
    if(SUCCEEDED(hr))
    {
        m_hAutoAllowCheckBox.SendMessage(
            BM_SETCHECK, 
            nOfferMode == RTCOWM_AUTOMATICALLY_ADD_WATCHER ? BST_CHECKED : BST_UNCHECKED);
    }
    else
    {
        LOG((RTC_ERROR, "CUserPresenceInfoDlg::OnInitDialog - "
            "error (%x) returned by get_OfferWatcherMode",hr));

        m_hAutoAllowCheckBox.EnableWindow(FALSE);
    }
    
    //
    // It's time to populate the listboxes
    //
    CUserPresenceInfoDlgEntry  **pCrt, **pEnd;

    pCrt = &m_Watchers[0];
    pEnd = pCrt + m_Watchers.GetSize();

    for(; pCrt<pEnd; pCrt++)
    {
        if(*pCrt)
        {
            CWindow *m_hListBox = 
                (*pCrt)->bAllowed ? &m_hAllowedList : &m_hBlockedList;

            INT_PTR  iItem = m_hListBox->SendMessage(
                LB_ADDSTRING, 
                0,
                (LPARAM)((*pCrt)->pszDisplayName ?
                    (*pCrt)->pszDisplayName : L"")
                );  

            // store the pointer in the element
            if(iItem>=0)
            {
                m_hListBox->SendMessage(
                    LB_SETITEMDATA,
                    (WPARAM)iItem,
                    (LPARAM)(*pCrt));
            }
        }
    }
    
    
    m_bDirty = FALSE;

    // select the first entry (if any)
    m_hAllowedList.SendMessage(
        LB_SETCURSEL,
        0);

    m_hAllowedList.SetFocus(); // this calls UpdateVisual

    LOG((RTC_TRACE, "CUserPresenceInfoDlg::OnInitDialog - exit"));
    
    return 0; // We set the focus
}

////////////////////////////////////////
//

LRESULT CUserPresenceInfoDlg::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CUserPresenceInfoDlg::OnDestroy - enter"));

    RemoveAll();

    if(m_pParam->pClientPresence)
    {
        m_pParam->pClientPresence->Release();
    }
    
    LOG((RTC_TRACE, "CUserPresenceInfoDlg::OnDestroy - exit"));
    
    return 0;
}

    
////////////////////////////////////////
//

LRESULT CUserPresenceInfoDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CUserPresenceInfoDlg::OnCancel"));
    
    EndDialog(E_ABORT);
    return 0;
}

////////////////////////////////////////
//

LRESULT CUserPresenceInfoDlg::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CUserPresenceInfoDlg::OnOK - enter"));
    
    //
    // It's time to save the changes
    //

    CUserPresenceInfoDlgEntry  **pCrt, **pEnd;

    pCrt = &m_Watchers[0];
    pEnd = pCrt + m_Watchers.GetSize();

    for(; pCrt<pEnd; pCrt++)
    {
        if(*pCrt && (*pCrt)->bChanged)
        {
            // extract the watcher interface
            IRTCWatcher *pWatcher = (*pCrt)->pWatcher;

            if(pWatcher)
            {
                if((*pCrt)->bDeleted)
                {
                    hr = m_pParam->pClientPresence->RemoveWatcher(
                        pWatcher);

                    if(FAILED(hr))
                    {
                        LOG((RTC_ERROR, "CUserPresenceInfoDlg::OnOK - "
                            "RemoveWatcher failed with error %x", hr));
                    }
                }
                else
                {
                    hr = pWatcher->put_State(
                        (*pCrt)->bAllowed ? RTCWS_ALLOWED : RTCWS_BLOCKED);

                    if(FAILED(hr))
                    {
                        LOG((RTC_ERROR, "CUserPresenceInfoDlg::OnOK - "
                            "put_State failed with error %x", hr));
                    }
                }
            }
        }
    }

    hr = m_pParam->pClientPresence->put_OfferWatcherMode(
        m_hAutoAllowCheckBox.SendMessage(BM_GETCHECK) == BST_CHECKED ?
            RTCOWM_AUTOMATICALLY_ADD_WATCHER : RTCOWM_OFFER_WATCHER_EVENT);
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CUserPresenceInfoDlg::OnOK - "
            "put_OfferWatcherMode failed with error %x", hr));
    }
        
    LOG((RTC_TRACE, "CUserPresenceInfoDlg::OnOK - exiting"));
    
    EndDialog(S_OK);
    return 0;
}

LRESULT CUserPresenceInfoDlg::OnBlock(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CUserPresenceInfoDlg::OnBlock - enter"));
    
    Move(FALSE);

    m_bDirty = TRUE;

    UpdateVisual();

    LOG((RTC_TRACE, "CUserPresenceInfoDlg::OnBlock - exit"));
    
    return 0;

}

LRESULT CUserPresenceInfoDlg::OnAllow(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CUserPresenceInfoDlg::OnAllow - enter"));
    
    Move(TRUE);
    
    m_bDirty = TRUE;

    UpdateVisual();

    LOG((RTC_TRACE, "CUserPresenceInfoDlg::OnAllow - exit"));
    return 0;
}

LRESULT CUserPresenceInfoDlg::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CUserPresenceInfoDlg::OnRemove - enter"));

    CWindow *m_hList = m_bAllowDir 
        ? &m_hBlockedList : &m_hAllowedList;

    // Find the selection
    int iItem = (int)m_hList->SendMessage(
        LB_GETCURSEL,
        0);

    if(iItem>=0)
    {
        CUserPresenceInfoDlgEntry *pEntry = NULL;

        //
        // Get the entry
        pEntry = (CUserPresenceInfoDlgEntry *)m_hList->SendMessage(LB_GETITEMDATA, iItem);
        if(pEntry && (INT_PTR)pEntry != -1)
        {
            // mark it as deleted
            pEntry->bDeleted = TRUE;
            pEntry->bChanged = TRUE;
        }
        
        //
        // Delete it
        m_hList->SendMessage(LB_DELETESTRING, iItem);

        // New selection
        //
        if(iItem>=(int)m_hList->SendMessage(LB_GETCOUNT, 0))
        {
            iItem--;
        }

        if(iItem>=0)
        {
            m_hList->SendMessage(LB_SETCURSEL, iItem);
        }

    }

    m_bDirty = TRUE;

    UpdateVisual();

    LOG((RTC_TRACE, "CUserPresenceInfoDlg::OnRemove - exit"));

    return 0;
}


LRESULT CUserPresenceInfoDlg::OnAutoAllow(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_bDirty = TRUE;

    UpdateVisual();

    return 0;
}

LRESULT CUserPresenceInfoDlg::OnChangeFocus(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_bAllowDir = (wID == IDC_LIST_BLOCKED_USERS);

    // reset the selection on the other list box
    CWindow *m_hList = m_bAllowDir 
        ? &m_hAllowedList : &m_hBlockedList;

    m_hList->SendMessage(
        LB_SETCURSEL,
        -1);

    UpdateVisual();

    bHandled = FALSE;

    return 0;
}

void CUserPresenceInfoDlg::Move(BOOL bAllow)
{
    CWindow *m_hSrcList = bAllow 
        ? &m_hBlockedList : &m_hAllowedList;
    
    CWindow *m_hDestList = bAllow 
        ? &m_hAllowedList : &m_hBlockedList;
    
    // Find the selection
    int iItem = (int)m_hSrcList->SendMessage(
        LB_GETCURSEL,
        0);

    if(iItem>=0)
    {
        CUserPresenceInfoDlgEntry *pEntry = NULL;

        //
        // Get the entry
        pEntry = (CUserPresenceInfoDlgEntry *)m_hSrcList->SendMessage(LB_GETITEMDATA, iItem);
        if(pEntry && (INT_PTR)pEntry != -1)
        {
            pEntry->bAllowed = bAllow;
            // mark it as changed
            pEntry->bChanged = TRUE;
        }
        
        //
        // Delete it from the source
        m_hSrcList->SendMessage(LB_DELETESTRING, iItem);

        // Add it to the dest
        //
        int iNewItem = (int)m_hDestList->SendMessage(
            LB_ADDSTRING, 0, (LPARAM)pEntry->pszDisplayName);

        if(iNewItem >=0)
        {
            m_hDestList->SendMessage(LB_SETITEMDATA, iNewItem, (LPARAM)pEntry);
        }

        // New selection
        //
        if(iItem>=(int)m_hSrcList->SendMessage(LB_GETCOUNT, 0))
        {
            iItem--;
        }

        if(iItem>=0)
        {
            m_hSrcList->SendMessage(LB_SETCURSEL, iItem);
        }
    }
}


void CUserPresenceInfoDlg::UpdateVisual()
{
    CWindow *m_hList = m_bAllowDir 
        ? &m_hBlockedList : &m_hAllowedList;

    // based on the number of items
    INT_PTR iItems = m_hList->SendMessage(
        LB_GETCOUNT,
        0,
        0);

    m_hAllowButton.EnableWindow(m_bAllowDir && iItems>0);
    m_hBlockButton.EnableWindow(!m_bAllowDir && iItems>0);
    m_hRemoveButton.EnableWindow(iItems>0);

    ::EnableWindow(GetDlgItem(IDOK), m_bDirty);
}

void CUserPresenceInfoDlg::RemoveAll()
{
    CUserPresenceInfoDlgEntry  **pCrt, **pEnd;

    pCrt = &m_Watchers[0];
    pEnd = pCrt + m_Watchers.GetSize();

    for(; pCrt<pEnd; pCrt++)
    {
        if(*pCrt)
        {
            if((*pCrt)->pszDisplayName)
            {
                RtcFree((*pCrt)->pszDisplayName);
            }
            if((*pCrt)->pWatcher)
            {
                (*pCrt)->pWatcher->Release();
            }
            RtcFree(*pCrt);
        }
    }

    m_Watchers.Shutdown();   
}


/////////////////////////////////////////////////////////////////////////////
// CCustomPresenceDlg


////////////////////////////////////////
//

CCustomPresenceDlg::CCustomPresenceDlg()
{
    LOG((RTC_TRACE, "CCustomPresenceDlg::CCustomPresenceDlg"));

    m_pParam = NULL;

}


////////////////////////////////////////
//

CCustomPresenceDlg::~CCustomPresenceDlg()
{
    LOG((RTC_TRACE, "CCustomPresenceDlg::~CCustomPresenceDlg"));
}


////////////////////////////////////////
//

LRESULT CCustomPresenceDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CCustomPresenceDlg::OnInitDialog - enter"));

    m_pParam = reinterpret_cast<CCustomPresenceDlgParam *>(lParam);

    ATLASSERT(m_pParam);

    m_hText.Attach(GetDlgItem(IDC_EDIT_CUSTOM_TEXT));

    // fix max sizes
    m_hText.SendMessage(EM_LIMITTEXT, MAX_STRING_LEN, 0);

    if(m_pParam->bstrText)
    {
        m_hText.SetWindowText(m_pParam->bstrText);
    }

    m_hText.SetFocus();
        
    LOG((RTC_TRACE, "CCustomPresenceDlg::OnInitDialog - exit"));
    
    return 0; // We set the focus
}
    
////////////////////////////////////////
//

LRESULT CCustomPresenceDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CCustomPresenceDlg::OnCancel"));
    
    EndDialog(E_ABORT);
    return 0;
}

////////////////////////////////////////
//

LRESULT CCustomPresenceDlg::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CCustomPresenceDlg::OnOK - enter"));
    
    CComBSTR    bstrText;
    
    m_hText.GetWindowText(&bstrText);

    // Validation

    if(m_pParam->bstrText)
    {
        SysFreeString(m_pParam->bstrText);
    }

    m_pParam->bstrText = bstrText.Detach();

    LOG((RTC_TRACE, "CCustomPresenceDlg::OnOK - exiting"));
    
    EndDialog(S_OK);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\mainfrm.cpp ===
//
// Mainfrm.cpp : Implementation of CMainFrm
//

#include "stdafx.h"
#include "Mainfrm.h"
#include "options.h"
#include "frameimpl.h"
#include "imsconf3_i.c"
#include "sdkinternal_i.c"

const TCHAR * g_szWindowClassName = _T("PhoenixMainWnd");

#define RELEASE_NULLIFY(p) if(p){ p->Release(); p=NULL; }

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CMainFrm
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL IsAncestorWindow(HWND hwndAncestor, HWND hwnd)
{
    while (hwnd != NULL)
    {
        hwnd = ::GetParent(hwnd);

        if (hwnd == hwndAncestor)
        {
            // Yes, we found the window
            return TRUE;
        }
    }

    // No, we reached the root
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
//
//

CMainFrm::CMainFrm()
{
    LOG((RTC_TRACE, "CMainFrm::CMainFrm"));
    m_nState = RTCAX_STATE_NONE;
    m_bVisualStateFrozen = FALSE;    

    m_nStatusStringResID = 0;

    m_bDoNotDisturb = FALSE;
    m_bAutoAnswerMode = FALSE;
    m_bCallTimerActive = FALSE;
    m_bUseCallTimer = FALSE;
    m_dwTickCount = 0;

    m_szTimeSeparator[0] = _T('\0');
    m_szStatusText[0] = _T('\0');

    m_hAccelTable = NULL;

    m_pIncomingCallDlg = NULL;

    m_bShellStatusActive = FALSE;

    m_uTaskbarRestart = 0;

    m_bHelpStatusDisabled = FALSE;

    m_hRedialPopupMenu = NULL;
    m_hRedialImageList = NULL;
    m_hRedialDisabledImageList = NULL;
    m_pRedialAddressEnum = NULL;
    
    m_bMessageTimerActive = FALSE;
    
    m_bstrCallParam = NULL;

    m_fInitCompleted = FALSE;

    m_hNotifyMenu = NULL;
    m_hMenu = NULL;
    m_hIcon = NULL;
    m_hMessageFont = NULL;

    m_fMinimizeOnClose = FALSE;
    m_bstrLastBrowse = NULL;

    m_bstrLastCustomStatus = NULL;

    m_hImageLib = NULL;
    m_fnGradient = NULL;

    m_hPalette = NULL;
    m_bBackgroundPalette = FALSE;

    m_hPresenceStatusMenu = FALSE;

    // forces the displaying of the normal title
    m_bTitleShowsConnected = TRUE;

    m_bWindowActive = TRUE;

    m_bstrDefaultURL = NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
//

CMainFrm::~CMainFrm()
{
    LOG((RTC_TRACE, "CMainFrm::~CMainFrm"));

    if (m_hImageLib != NULL)
    {
        FreeLibrary(m_hImageLib);
    }

    if (m_bstrCallParam != NULL)
    {
        ::SysFreeString(m_bstrCallParam);
    }

    if(m_bstrDefaultURL)
    {
        ::SysFreeString(m_bstrDefaultURL);
    }
}


/////////////////////////////////////////////////////////////////////////////
//
//

CWndClassInfo& CMainFrm::GetWndClassInfo() 
{ 
    LOG((RTC_TRACE, "CMainFrm::GetWndClassInfo"));

    static CWndClassInfo wc = 
    { 
        { sizeof(WNDCLASSEX), 0, StartWindowProc, 
          0, 0, NULL, NULL, NULL, NULL, NULL, g_szWindowClassName, NULL }, 
        NULL, NULL, IDC_ARROW, TRUE, 0, _T("") 
    }; 
    return wc;
}

/////////////////////////////////////////////////////////////////////////////
// CreateTooltips
//      Creates the tooltip window
// 

BOOL CMainFrm::CreateTooltips()
{
    HWND hwndTT = CreateWindowEx(0, TOOLTIPS_CLASS, (LPTSTR) NULL,
        0, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        CW_USEDEFAULT, m_hWnd, (HMENU) NULL, _Module.GetModuleInstance(), NULL);

    if (hwndTT == NULL)
        return FALSE;

    m_hTooltip.Attach(hwndTT);

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// 
// HiddenWndProc
//
LRESULT CALLBACK HiddenWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{ 
    static HWND s_hwndMain;
    switch (uMsg) 
    { 
        case WM_CREATE: 
            
            // Get the window handle for the main app that was passed as the 
            // lParam in CreateWindowEx call. We persist this handle so that
            // it can be used when we need to send the message.

            s_hwndMain = ( HWND )( ( ( LPCREATESTRUCT )( lParam ) )->lpCreateParams );

            return 0;

        case WM_COMMAND: 
        case WM_MEASUREITEM:
        case WM_DRAWITEM: 

            //
            // Forward this message to the main app.
            //
            return SendMessage(s_hwndMain, uMsg, wParam, lParam);

        default: 
            return DefWindowProc(hwnd, uMsg, wParam, lParam); 
    } 

    return 0;
} 

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT   hr;
    HMENU     hNotifyMenu;
    TCHAR     szString[256];
    RECT      rcDummy;
    TOOLINFO  ti;
    
    LOG((RTC_TRACE, "CMainFrm::OnCreate - enter"));

    //
    // Generate the palette
    //

    m_hPalette = GeneratePalette();

    //
    // Load menu
    //

    m_hMenu = LoadMenu( 
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(IDC_UI)
        ); 

    //
    // Load and set icons (both small and big)
    //

    m_hIcon = LoadIcon(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(IDI_APPICON)
        );

    SetIcon(m_hIcon, FALSE);
    SetIcon(m_hIcon, TRUE);

    //
    // Load bitmaps
    //

    HBITMAP hbmpTemp;

    hbmpTemp = (HBITMAP)LoadImage( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_UI_BKGND),
                             IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION );

    if(hbmpTemp)
    {
        m_hUIBkgnd = DibFromBitmap((HBITMAP)hbmpTemp,0,0,m_hPalette,0);

        DeleteObject(hbmpTemp);
    }

    m_hSysMenuNorm = (HBITMAP)LoadImage( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_SYS_NORM),
                             IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION );

    m_hSysMenuMask = (HBITMAP)LoadImage( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_SYS_MASK),
                             IMAGE_BITMAP, 0, 0, LR_MONOCHROME );

    //
    // Load fonts
    //

    NONCLIENTMETRICS metrics;
    metrics.cbSize = sizeof(metrics);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS,sizeof(metrics),&metrics,0);

    m_hMessageFont = CreateFontIndirect(&metrics.lfMessageFont);

    rcDummy.bottom = 0;
    rcDummy.left = 0;
    rcDummy.right = 0;
    rcDummy.top = 0;

    // Create tooltip window
    CreateTooltips();    
    
    // Create the toolbar menu control
    hr = CreateToolbarMenuControl();
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnCreate - failed to create toolbar menu - 0x%08x",
                        hr));
    }
    
    m_hToolbarMenuCtl.Attach(GetDlgItem(IDC_TOOLBAR_MENU));

    //
    //  Create the title bar buttons
    //

    m_hCloseButton.Create(m_hWnd, rcDummy, NULL, 0,
        MAKEINTRESOURCE(IDB_CLOSE_NORM),
        MAKEINTRESOURCE(IDB_CLOSE_PRESS),
        NULL,
        NULL,
        MAKEINTRESOURCE(IDB_CLOSE_MASK),
        ID_CANCEL);    

    ti.cbSize = TTTOOLINFO_V1_SIZE;
    ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
    ti.hwnd = m_hWnd;
    ti.uId = (UINT_PTR)(HWND)m_hCloseButton;
    ti.hinst = _Module.GetResourceInstance();
    ti.lpszText = MAKEINTRESOURCE(IDS_TIPS_CLOSE);

    m_hTooltip.SendMessage(TTM_ADDTOOL, 0,
            (LPARAM)(LPTOOLINFO)&ti);

    m_hMinimizeButton.Create(m_hWnd, rcDummy, NULL, 0,
        MAKEINTRESOURCE(IDB_MIN_NORM),
        MAKEINTRESOURCE(IDB_MIN_PRESS),
        NULL,
        NULL,
        MAKEINTRESOURCE(IDB_MIN_MASK),
        ID_MINIMIZE);

    ti.cbSize = TTTOOLINFO_V1_SIZE;
    ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
    ti.hwnd = m_hWnd;
    ti.uId = (UINT_PTR)(HWND)m_hMinimizeButton;
    ti.hinst = _Module.GetResourceInstance();
    ti.lpszText = MAKEINTRESOURCE(IDS_TIPS_MINIMIZE);

    m_hTooltip.SendMessage(TTM_ADDTOOL, 0,
            (LPARAM)(LPTOOLINFO)&ti);

    //
    //  Create call buttons
    //

    LoadString(_Module.GetResourceInstance(), IDS_REDIAL, szString, 256);

    m_hRedialButton.Create(m_hWnd, rcDummy, szString, WS_TABSTOP,
        MAKEINTRESOURCE(IDB_BUTTON_NORM),
        MAKEINTRESOURCE(IDB_BUTTON_PRESS),
        MAKEINTRESOURCE(IDB_BUTTON_DIS),
        MAKEINTRESOURCE(IDB_BUTTON_HOT),
        NULL,
        ID_REDIAL);

    ti.cbSize = TTTOOLINFO_V1_SIZE;
    ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
    ti.hwnd = m_hWnd;
    ti.uId = (UINT_PTR)(HWND)m_hRedialButton;
    ti.hinst = _Module.GetResourceInstance();
    ti.lpszText = MAKEINTRESOURCE(IDS_TIPS_REDIAL);

    m_hTooltip.SendMessage(TTM_ADDTOOL, 0,
            (LPARAM)(LPTOOLINFO)&ti);

    LoadString(_Module.GetResourceInstance(), IDS_HANGUP, szString, 256);

    m_hHangupButton.Create(m_hWnd, rcDummy, szString, WS_TABSTOP,
        MAKEINTRESOURCE(IDB_BUTTON_NORM),
        MAKEINTRESOURCE(IDB_BUTTON_PRESS),
        MAKEINTRESOURCE(IDB_BUTTON_DIS),
        MAKEINTRESOURCE(IDB_BUTTON_HOT),
        NULL,
        ID_HANGUP);

    ti.cbSize = TTTOOLINFO_V1_SIZE;
    ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
    ti.hwnd = m_hWnd;
    ti.uId = (UINT_PTR)(HWND)m_hHangupButton;
    ti.hinst = _Module.GetResourceInstance();
    ti.lpszText = MAKEINTRESOURCE(IDS_TIPS_HANGUP);

    m_hTooltip.SendMessage(TTM_ADDTOOL, 0,
            (LPARAM)(LPTOOLINFO)&ti);

    //
    // Create keypad buttons
    //

#define     CREATE_DIALPAD_BUTTON(s1,s2)                    \
    m_hKeypad##s1.Create(m_hWnd, rcDummy, NULL, WS_TABSTOP, \
        MAKEINTRESOURCE(IDB_KEYPAD##s2##_NORM),             \
        MAKEINTRESOURCE(IDB_KEYPAD##s2##_PRESS),            \
        MAKEINTRESOURCE(IDB_KEYPAD##s2##_DIS),              \
        MAKEINTRESOURCE(IDB_KEYPAD##s2##_HOT),              \
        NULL,                                               \
        ID_KEYPAD##s2);                                     \
                                                            \
        ti.cbSize = TTTOOLINFO_V1_SIZE;                     \
        ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;            \
        ti.hwnd = m_hWnd;                                   \
        ti.uId = (UINT_PTR)(HWND)m_hKeypad##s1;             \
        ti.hinst = _Module.GetResourceInstance();           \
        ti.lpszText = MAKEINTRESOURCE(IDS_TIPS_KEYPAD##s2); \
                                                            \
        m_hTooltip.SendMessage(TTM_ADDTOOL, 0,              \
                (LPARAM)(LPTOOLINFO)&ti);

    CREATE_DIALPAD_BUTTON(1,1) 
    CREATE_DIALPAD_BUTTON(2,2) 
    CREATE_DIALPAD_BUTTON(3,3) 
    CREATE_DIALPAD_BUTTON(4,4) 
    CREATE_DIALPAD_BUTTON(5,5) 
    CREATE_DIALPAD_BUTTON(6,6) 
    CREATE_DIALPAD_BUTTON(7,7) 
    CREATE_DIALPAD_BUTTON(8,8) 
    CREATE_DIALPAD_BUTTON(9,9) 
    CREATE_DIALPAD_BUTTON(Star,STAR) 
    CREATE_DIALPAD_BUTTON(0,0) 
    CREATE_DIALPAD_BUTTON(Pound,POUND) 
    
#undef CREATE_DIALPAD_BUTTON


    //
    //  Create the status text controls
    // 
    m_hStatusText.Create(m_hWnd, rcDummy, NULL, WS_CHILD | WS_VISIBLE, WS_EX_TRANSPARENT);
    m_hStatusText.put_WordWrap(TRUE);

    m_hStatusElapsedTime.Create(m_hWnd, rcDummy, NULL, WS_CHILD | WS_VISIBLE, WS_EX_TRANSPARENT);

    //
    // Create the buddy list control
    //

    RECT rcBuddyList;

    rcBuddyList.top = BUDDIES_TOP;
    rcBuddyList.bottom = BUDDIES_BOTTOM;
    rcBuddyList.right = BUDDIES_RIGHT;
    rcBuddyList.left = BUDDIES_LEFT;

    m_hBuddyList.Create(_T("SysListView32"), m_hWnd, rcBuddyList, NULL,
        WS_CHILD | WS_VISIBLE | LVS_SMALLICON | LVS_SINGLESEL | LVS_SORTASCENDING | WS_TABSTOP,
        0, IDC_BUDDYLIST);  
    
    ListView_SetBkColor(m_hBuddyList, CLR_NONE);
    ListView_SetTextBkColor(m_hBuddyList, CLR_NONE);
    ListView_SetTextColor(m_hBuddyList, RGB(0, 0, 0));

    // Create an imagelist for small icons and set it on the listview
    HIMAGELIST  hImageList;
    HBITMAP     hBitmap;

    hImageList = ImageList_Create(16, 16, ILC_COLOR24 | ILC_MASK, 10, 10);

    if(hImageList)
    {
        hBitmap = (HBITMAP)LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_CONTACT_LIST),
                                     IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

        if(hBitmap)
        {
            // Add the bitmap to the image list
            ImageList_AddMasked(hImageList, hBitmap, BMP_COLOR_MASK);

            // Set the image list
            ListView_SetImageList(m_hBuddyList, hImageList, LVSIL_SMALL);

            DeleteObject(hBitmap);
        }
    }

    SetCurvedEdges(m_hBuddyList, 12, 12);

    LOG((RTC_TRACE, "CMainFrm::OnCreate - cocreating the RTCCTL"));

    //
    // Instantiate the RTCCTL control. TODO - include the GUID from elsewhere
    //

    RECT rcActiveX;

    rcActiveX.top = ACTIVEX_TOP;
    rcActiveX.bottom = ACTIVEX_BOTTOM;
    rcActiveX.right = ACTIVEX_RIGHT;
    rcActiveX.left = ACTIVEX_LEFT;

    m_hMainCtl.Create(m_hWnd, &rcActiveX, _T("{cd44f458-26c3-4776-b6e4-d0fb28578eb8}"),
        WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 0);   
    
    LOG((RTC_TRACE, "CMainFrm::OnCreate - RTCCTL created"));

    // Obtain an interface to the hosted control
    hr = m_hMainCtl.QueryControl(&m_pControlIntf);

    if(SUCCEEDED(hr))
    {
        ATLASSERT(m_pControlIntf.p);

        // Advise 
        LOG((RTC_TRACE, "CMainFrm::OnCreate - connect to the control"));
        hr = g_NotifySink.AdviseControl(m_pControlIntf, this);
        if(SUCCEEDED(hr))
        {
            // Set the initial layout
            
            // This will display the default layout
            m_pControlIntf->put_Standalone(TRUE);

            // Set the palette
            m_pControlIntf->put_Palette(m_hPalette);

            // Synchronize the frame state
            m_pControlIntf->get_ControlState(&m_nState);

            // If IDLE, start listening for incoming calls
            if(m_nState == RTCAX_STATE_IDLE)
            {
                LOG((RTC_TRACE, "CMainFrm::OnCreate - start listen for incoming calls"));

                hr = m_pControlIntf->put_ListenForIncomingSessions(RTCLM_BOTH);
                //XXX some error processing here
            }

        }
        else
        {
            LOG((RTC_ERROR, "CMainFrm::OnCreate - error (%x) returned by AdviseControl", hr));
        }

        LOG((RTC_TRACE, "CMainFrm::OnCreate - connect to the core"));        
        
        hr = m_pControlIntf->GetClient( &m_pClientIntf );

        if ( SUCCEEDED(hr) )
        {
            long lEvents;

            hr = m_pClientIntf->get_EventFilter( &lEvents );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CMainFrm::OnCreate - "
                            "get_EventFilter failed 0x%lx", hr));
            }
            else
            {
                hr = m_pClientIntf->put_EventFilter( lEvents |                                      
                                        RTCEF_MEDIA |                                     
                                        RTCEF_BUDDY	|
                                        RTCEF_WATCHER );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CMainFrm::OnCreate - "
                                "put_EventFilter failed 0x%lx", hr));
                }
            }

            hr = g_CoreNotifySink.AdviseControl(m_pClientIntf, this);

            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "CMainFrm::OnCreate - "
                            "AdviseControl for core failed 0x%lx", hr));
            }

            IRTCClientPresence * pClientPresence = NULL;

            hr = m_pClientIntf->QueryInterface(
                IID_IRTCClientPresence,
                (void **)&pClientPresence);

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CMainFrm::OnCreate - "
                            "error (%x) returned by QI, exit", hr));
            }
            else
            {
                TCHAR * szAppData;
                TCHAR szDir[MAX_PATH];
                TCHAR szFile[MAX_PATH];

                szAppData = _tgetenv( _T("APPDATA") );

                _stprintf( szDir, _T("%s\\Microsoft\\Windows Messenger"), szAppData );
                _stprintf( szFile, _T("%s\\Microsoft\\Windows Messenger\\presence.xml"), szAppData );
        
                if (!CreateDirectory( szDir, NULL ) && (GetLastError() != ERROR_ALREADY_EXISTS))
                {
                    LOG((RTC_ERROR, "CMainFrm::OnCreate - "
                                    "CreateDirectory failed %d", GetLastError()));
                }

                hr = pClientPresence->EnablePresence(VARIANT_TRUE, CComVariant(szFile));

                RELEASE_NULLIFY( pClientPresence );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CMainFrm::OnCreate - "
                                "EnablePresence failed 0x%lx", hr));
                }
            }
        }
        else
        {
            LOG((RTC_ERROR, "CMainFrm::OnCreate - "
                            "GetClient failed 0x%lx", hr));
        }
    }
    else
    {
        LOG((RTC_ERROR, "CMainFrm::OnCreate - error (%x) when querying for control", hr));

        //
        // Almost sure the RTC control is not actually registered !
        //  And the instantiated control is actually a webbrowser
        //  Destroy the window 
        //
        m_hMainCtl.DestroyWindow();
    }               

    //
    // Create call setup area controls
    //

#ifdef MULTI_PROVIDER

    // provider text

    m_hProviderText.Create(m_hWnd, rcDummy, NULL, WS_CHILD, WS_EX_TRANSPARENT);

    LoadString(_Module.GetResourceInstance(), IDS_SELECT_PROVIDER, szString, 256);

    m_hProviderText.SetWindowText(szString);
    
    // provider combo

    m_hProviderCombo.Create(_T("COMBOBOX"), m_hWnd, rcDummy, NULL,
        WS_CHILD | CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP,
        WS_EX_TRANSPARENT, IDC_COMBO_SERVICE_PROVIDER);   
    

    // Get the "last" provider used

    BSTR bstrLastProfileKey = NULL;

    if(m_pClientIntf)
    {
        hr = get_SettingsString( 
                    SS_LAST_PROFILE,
                    &bstrLastProfileKey );      

        PopulateServiceProviderList(
                                    m_hWnd,
                                    m_pClientIntf,
                                    IDC_COMBO_SERVICE_PROVIDER,
                                    TRUE,
                                    NULL,
                                    bstrLastProfileKey,
                                    0xF,
                                    IDS_NONE
                                   );

        if ( SUCCEEDED(hr) )
        {
            SysFreeString( bstrLastProfileKey );
        }
    }

    // provider edit button
    LoadString(_Module.GetResourceInstance(), IDS_EDIT_LIST, szString, 256);

    m_hProviderEditList.Create(m_hWnd, rcDummy, szString, WS_TABSTOP,
        MAKEINTRESOURCE(IDB_SMALLBUTTON_NORM),
        MAKEINTRESOURCE(IDB_SMALLBUTTON_PRESS),
        MAKEINTRESOURCE(IDB_SMALLBUTTON_DIS),
        MAKEINTRESOURCE(IDB_SMALLBUTTON_HOT),
        NULL,
        ID_SERVICE_PROVIDER_EDIT);

    ti.cbSize = TTTOOLINFO_V1_SIZE;
    ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
    ti.hwnd = m_hWnd;
    ti.uId = (UINT_PTR)(HWND)m_hProviderEditList;
    ti.hinst = _Module.GetResourceInstance();
    ti.lpszText = MAKEINTRESOURCE(IDS_TIPS_SERVICE_PROVIDER_EDIT);

    m_hTooltip.SendMessage(TTM_ADDTOOL, 0,
            (LPARAM)(LPTOOLINFO)&ti);

#endif MULTI_PROVIDER

    // call from text

    m_hCallFromText.Create(m_hWnd, rcDummy, NULL, WS_CHILD, WS_EX_TRANSPARENT);

    LoadString(_Module.GetResourceInstance(), IDS_CALL_FROM, szString, 256);

    m_hCallFromText.SetWindowText(szString);
    
    // call from pc radio

    m_hCallFromRadioPC.Create(_T("BUTTON"), m_hWnd, rcDummy, NULL,
        WS_CHILD | BS_RADIOBUTTON | WS_TABSTOP,
        WS_EX_TRANSPARENT, IDC_RADIO_FROM_COMPUTER);

    m_hCallFromTextPC.Create(m_hWnd, rcDummy, NULL, WS_CHILD, WS_EX_TRANSPARENT);

    LoadString(_Module.GetResourceInstance(), IDS_MY_COMPUTER, szString, 256);

    m_hCallFromTextPC.SetWindowText(szString);

    SendMessage(
                m_hCallFromRadioPC,
                BM_SETCHECK,
                BST_CHECKED,
                0);

    // call from phone radio

    m_hCallFromRadioPhone.Create(_T("BUTTON"), m_hWnd, rcDummy, NULL,
        WS_CHILD | BS_RADIOBUTTON | WS_TABSTOP,
        WS_EX_TRANSPARENT, IDC_RADIO_FROM_PHONE);

    m_hCallFromTextPhone.Create(m_hWnd, rcDummy, NULL, WS_CHILD, WS_EX_TRANSPARENT);

    LoadString(_Module.GetResourceInstance(), IDS_PHONE, szString, 256);

    m_hCallFromTextPhone.SetWindowText(szString);
    
    // call from phone combo

    m_hCallFromCombo.Create(_T("COMBOBOX"), m_hWnd, rcDummy, NULL,
        WS_CHILD | CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP,
        WS_EX_TRANSPARENT, IDC_COMBO_CALL_FROM);
    
     // Get the "last" call from used

    BSTR bstrLastCallFrom = NULL;

    if(m_pClientIntf)
    {

        get_SettingsString(
                            SS_LAST_CALL_FROM,
                            &bstrLastCallFrom );

        PopulateCallFromList(m_hWnd, IDC_COMBO_CALL_FROM, TRUE, bstrLastCallFrom);

        if ( bstrLastCallFrom != NULL )
        {
            SysFreeString( bstrLastCallFrom );
            bstrLastCallFrom = NULL;
        }
    }


    // call from edit button

    LoadString(_Module.GetResourceInstance(), IDS_EDIT_LIST, szString, 256);

    m_hCallFromEditList.Create(m_hWnd, rcDummy, szString, WS_TABSTOP,
        MAKEINTRESOURCE(IDB_SMALLBUTTON_NORM),
        MAKEINTRESOURCE(IDB_SMALLBUTTON_PRESS),
        MAKEINTRESOURCE(IDB_SMALLBUTTON_DIS),
        MAKEINTRESOURCE(IDB_SMALLBUTTON_HOT),
        NULL,
        ID_CALL_FROM_EDIT);

    ti.cbSize = TTTOOLINFO_V1_SIZE;
    ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
    ti.hwnd = m_hWnd;
    ti.uId = (UINT_PTR)(HWND)m_hCallFromEditList;
    ti.hinst = _Module.GetResourceInstance();
    ti.lpszText = MAKEINTRESOURCE(IDS_TIPS_CALL_FROM_EDIT);

    m_hTooltip.SendMessage(TTM_ADDTOOL, 0,
            (LPARAM)(LPTOOLINFO)&ti);

    // call to text

    m_hCallToText.Create(m_hWnd, rcDummy, NULL, WS_CHILD, WS_EX_TRANSPARENT);

    LoadString(_Module.GetResourceInstance(), IDS_CALL_TO, szString, 256);

    m_hCallToText.SetWindowText(szString);

    // call to PC button

    m_hCallPCButton.Create(m_hWnd, rcDummy, NULL, WS_TABSTOP,
        MAKEINTRESOURCE(IDB_CALLPC_NORM),
        MAKEINTRESOURCE(IDB_CALLPC_PRESS),
        MAKEINTRESOURCE(IDB_CALLPC_DIS),
        MAKEINTRESOURCE(IDB_CALLPC_HOT),
        NULL,
        ID_CALLPC);

    ti.cbSize = TTTOOLINFO_V1_SIZE;
    ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
    ti.hwnd = m_hWnd;
    ti.uId = (UINT_PTR)(HWND)m_hCallPCButton;
    ti.hinst = _Module.GetResourceInstance();
    ti.lpszText = MAKEINTRESOURCE(IDS_TIPS_CALLPC);

    m_hTooltip.SendMessage(TTM_ADDTOOL, 0,
            (LPARAM)(LPTOOLINFO)&ti);

    // call to PC text

    m_hCallPCText.Create(m_hWnd, rcDummy, NULL, WS_CHILD, WS_EX_TRANSPARENT);
    m_hCallPCText.put_CenterHorizontal(TRUE);

    LoadString(_Module.GetResourceInstance(), IDS_CALL_PC, szString, 256);

    m_hCallPCText.SetWindowText(szString);

    // call to Phone button

    m_hCallPhoneButton.Create(m_hWnd, rcDummy, NULL, WS_TABSTOP,
        MAKEINTRESOURCE(IDB_CALLPHONE_NORM),
        MAKEINTRESOURCE(IDB_CALLPHONE_PRESS),
        MAKEINTRESOURCE(IDB_CALLPHONE_DIS),
        MAKEINTRESOURCE(IDB_CALLPHONE_HOT),
        NULL,
        ID_CALLPHONE);

    ti.cbSize = TTTOOLINFO_V1_SIZE;
    ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
    ti.hwnd = m_hWnd;
    ti.uId = (UINT_PTR)(HWND)m_hCallPhoneButton;
    ti.hinst = _Module.GetResourceInstance();
    ti.lpszText = MAKEINTRESOURCE(IDS_TIPS_CALLPHONE);

    m_hTooltip.SendMessage(TTM_ADDTOOL, 0,
            (LPARAM)(LPTOOLINFO)&ti);

    // call to Phone text

    m_hCallPhoneText.Create(m_hWnd, rcDummy, NULL, WS_CHILD, WS_EX_TRANSPARENT);
    m_hCallPhoneText.put_CenterHorizontal(TRUE);

    LoadString(_Module.GetResourceInstance(), IDS_CALL_PHONE, szString, 256);

    m_hCallPhoneText.SetWindowText(szString);

#ifdef WEBCONTROL
    //
    // Obtain the default URL for the web control
    WCHAR   szModulePath[MAX_PATH];

    szModulePath[0] = L'\0';
    GetModuleFileName(_Module.GetModuleInstance(), szModulePath, MAX_PATH);

    WCHAR   szUrl[MAX_PATH + 20];
    swprintf(szUrl, L"res://%s/wheader.htm", szModulePath);

    m_bstrDefaultURL = SysAllocString(szUrl);
    
    //
    // Create the web browser
    //
  
    LOG((RTC_TRACE, "CMainFrm::OnCreate - cocreating the WebBrowser"));

    hr = m_hBrowser.Create(m_bstrDefaultURL, m_hWnd);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CMainFrm::OnCreate - failed to create "
                        "browser control - 0x%08x",
                        hr));
    } 

    LOG((RTC_TRACE, "CMainFrm::OnCreate - WebBrowser created"));
#endif

    //
    // Load the accelerator for main window
    //

    m_hAccelTable = LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_ACCELERATOR_MAIN));
    if(!m_hAccelTable)
    {
        LOG((RTC_ERROR, "CMainFrm::OnCreate - couldn't load the accelerator table"));
    }

    //
    // Set the window region
    //

    SetUIMask();

    //
    // Register for TaskbarCreated notifications
    //  It's good for recreating the status icon after a shell crash
    //  (you don't know it from me)

    m_uTaskbarRestart = RegisterWindowMessage(TEXT("TaskbarCreated"));
 
    //
    // Create the shell icon
    //
    
    hr = CreateStatusIcon();
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CMainFrm::OnCreate - failed to create shell icon "
                        "- 0x%08x",
                        hr));
    }
    
    //
    //

    hNotifyMenu = LoadMenu(
                  _Module.GetResourceInstance(),
                  MAKEINTRESOURCE(IDC_NOTIFY_ICON)
                  );

    m_hNotifyMenu = GetSubMenu(hNotifyMenu, 0);

    
    //
    // Load the presence submenu and attach it to both m_hMenu and m_hNotifyMenu
    //
    HMENU   hPresenceMenu;

    m_hPresenceStatusMenu = LoadMenu(
                  _Module.GetResourceInstance(),
                  MAKEINTRESOURCE(IDC_PRESENCE_STATUSES)
                  );

    hPresenceMenu = GetSubMenu(m_hPresenceStatusMenu, 0);
    
    MENUITEMINFO        mii;

    ZeroMemory( &mii, sizeof(MENUITEMINFO) );

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_SUBMENU;
    mii.hSubMenu = hPresenceMenu;
    
    SetMenuItemInfo( m_hMenu, IDM_TOOLS_PRESENCE_STATUS, FALSE, &mii );
    SetMenuItemInfo( m_hNotifyMenu, IDM_TOOLS_PRESENCE_STATUS, FALSE, &mii );
    
    CheckMenuRadioItem(hPresenceMenu, IDM_PRESENCE_ONLINE, IDM_PRESENCE_CUSTOM_AWAY, IDM_PRESENCE_ONLINE, MF_BYCOMMAND);
    

    //
    // Load preferences
    //

    if ( m_pClientIntf != NULL )
    {
        DWORD dwValue;

        hr = get_SettingsDword( SD_AUTO_ANSWER, &dwValue );

        if ( SUCCEEDED(hr) )
        {
            m_bAutoAnswerMode = (dwValue == 1);

        }

        // these two are mutually exclusive
        if(m_bDoNotDisturb)
        {
            m_bAutoAnswerMode = FALSE;
        }
        
        CheckMenuItem(m_hMenu, IDM_CALL_DND, m_bDoNotDisturb ? MF_CHECKED : MF_UNCHECKED); 
        CheckMenuItem(m_hMenu, IDM_CALL_AUTOANSWER, m_bAutoAnswerMode ? MF_CHECKED : MF_UNCHECKED);
        CheckMenuItem(m_hNotifyMenu, IDM_CALL_DND, m_bDoNotDisturb ? MF_CHECKED : MF_UNCHECKED); 
        CheckMenuItem(m_hNotifyMenu, IDM_CALL_AUTOANSWER, m_bAutoAnswerMode ? MF_CHECKED : MF_UNCHECKED);

        // the items will be enabled/disabled in UpdateFrameVisual

        // Get the MinimizeOnClose value

        hr = get_SettingsDword( SD_MINIMIZE_ON_CLOSE, &dwValue );

        if ( SUCCEEDED(hr) )
        {
            m_fMinimizeOnClose = (dwValue == BST_CHECKED);
        }        

        // Place the window appropriately, based on what is there in registry.

        hr = PlaceWindowCorrectly();
    }

    //
    // Now load the ShellNotify menu and save it as a member variable here.
   
    //
    // Set fonts for combo boxes, at least
    //
    
    SendMessageToDescendants(WM_SETFONT, (WPARAM)m_hMessageFont, FALSE);

    //
    // pozition the controls/set the tab order
    //
    PlaceWindowsAtTheirInitialPosition();

    //
    // initialize any locale related info
    //
    UpdateLocaleInfo();

    //
    // Update visual state
    //

    UpdateFrameVisual();

    //
    // Update the buddy list
    //

    UpdateBuddyList();

    //
    // Create the redial menu
    //

    CreateRedialPopupMenu();

    //
    // Check if we are registered for sip and tel urls
    //  

    CheckURLRegistration(m_hWnd);

    //
    // Initialize keyboard shortcuts
    //
    SendMessage(m_hWnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0);

    // clear keyboard shortcuts
    SendMessage(m_hWnd, WM_CHANGEUISTATE,
                MAKEWPARAM(UIS_SET, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);
    

    // Create a window that will be used as notification icon's owner
    // window. We pass its handle to the Trackpopupmenu, and also use 
    // it to set the foreground window. 

    HWND hwndHiddenWindow;

    WNDCLASS wcHiddenWindow;

    ZeroMemory( &wcHiddenWindow, sizeof(WNDCLASS) );

    wcHiddenWindow.lpfnWndProc = HiddenWndProc;
    wcHiddenWindow.hInstance = _Module.GetModuleInstance();
    wcHiddenWindow.lpszClassName = _T("PhoenixHiddenWindowClass");

    RegisterClass( &wcHiddenWindow );

    hwndHiddenWindow = 
            CreateWindowEx( 
                    0,                      // no extended styles           
                    L"PhoenixHiddenWindowClass", // class name                   
                    L"PhoenixHiddenWindow", // window name                  
                    WS_OVERLAPPEDWINDOW,               // child window style
                    CW_USEDEFAULT,          // default horizontal position  
                    CW_USEDEFAULT,          // default vertical position    
                    CW_USEDEFAULT,          // default width                
                    CW_USEDEFAULT,          // default height               
                    (HWND) NULL,          // parent window    
                    (HMENU) NULL,           // class menu used              
                    _Module.GetModuleInstance(),   // instance handle              
                    m_hWnd);                  // pass main window handle      

    if (!hwndHiddenWindow)
    {
        LOG((RTC_ERROR, "CMainFrm::OnCreate - unable to create the hidden "
                        "window(%d)!", GetLastError()));
        
        // We proceed since we can always use the main window in its place. 
    }
    else
    {
        // Set it in our member variable.
        m_hwndHiddenWindow = hwndHiddenWindow;
    }

    // Post a message to ourselves which will be called 
    // right after init is done. 
    
    ::PostMessage(m_hWnd, WM_INIT_COMPLETED, NULL, NULL);
    
    LOG((RTC_TRACE, "CMainFrm::OnCreate - exit"));
    
    return 1;  // Let the system set the focus
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CMainFrm::SetCurvedEdges(HWND hwnd, int nCurveWidth, int nCurveHeight)
{
    RECT rect;
    ::GetWindowRect(hwnd, &rect);

    //set the rect to "client" coordinates
    rect.bottom = rect.bottom - rect.top;
    rect.right = rect.right - rect.left;
    rect.top = 0;
    rect.left = 0;

    HRGN region = CreateRoundRectRgn(
                                 rect.left,
                                 rect.top,
                                 rect.right+1,
                                 rect.bottom+1,
                                 nCurveWidth,
                                 nCurveHeight);

    ::SetWindowRgn(hwnd, region, TRUE);
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CMainFrm::SetUIMask()
{
    HRGN hTotal;
    HRGN hTemp;

    //
    // Center rectangle
    //

    //hTemp = CreateRoundRectRgn(179, 141, 429, 480, 12, 12);
    hTemp = CreateRoundRectRgn(177, 139, 424, 440, 12, 12);
    hTotal = hTemp;

    //
    // Ellipse cutout
    //

    //hTemp = CreateEllipticRgn(118, 436, 490, 600);
    hTemp = CreateEllipticRgn(106, 406, 494, 570);
    CombineRgn(hTotal, hTotal, hTemp, RGN_DIFF);

    //
    // Bottom-left edge rectangle
    //

    //hTemp = CreateRoundRectRgn(1, 436, 181, 479, 44, 44);
    hTemp = CreateRoundRectRgn(2, 404, 178, 439, 36, 36);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Bottom-right edge rectangle
    //

    //hTemp = CreateRoundRectRgn(428, 436, 608, 479, 44, 44);
    hTemp = CreateRoundRectRgn(423, 404, 599, 439, 36, 36);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Left rectangle
    //

    //hTemp = CreateRoundRectRgn(25, 141, 180, 464, 12, 12);
    hTemp = CreateRoundRectRgn(25, 139, 178, 432, 12, 12);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Right rectangle
    //

    //hTemp = CreateRoundRectRgn(428, 141, 583, 464, 12, 12);
    hTemp = CreateRoundRectRgn(423, 139, 576, 432, 12, 12);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Left triangle
    //

    POINT poly[3];

    //poly[0].x = 25; poly[0].y = 146;
    //poly[1].x = 1;  poly[1].y = 458;
    //poly[2].x = 25; poly[2].y = 458;
    poly[0].x = 25; poly[0].y = 144;
    poly[1].x = 1;  poly[1].y = 422;
    poly[2].x = 25; poly[2].y = 422;

    hTemp = CreatePolygonRgn(poly, 3, ALTERNATE);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Right triangle
    //

    //poly[0].x = 581; poly[0].y = 146;
    //poly[1].x = 581; poly[1].y = 458;
    //poly[2].x = 606; poly[2].y = 458;
    poly[0].x = 574; poly[0].y = 144;
    poly[1].x = 574; poly[1].y = 422;
    poly[2].x = 598; poly[2].y = 422;

    hTemp = CreatePolygonRgn(poly, 3, ALTERNATE);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Top rectangle
    //

    //hTemp = CreateRoundRectRgn(123, 1, 488, 127, 12, 12);
    hTemp = CreateRoundRectRgn(119, 1, 484, 127, 12, 12);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Top-left connector rectangle
    //

    //hTemp = CreateRectRgn(111, 8, 123, 119);
    hTemp = CreateRectRgn(107, 8, 119, 119);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Top-right connector rectangle
    //

    //hTemp = CreateRectRgn(487, 8, 499, 119);
    hTemp = CreateRectRgn(483, 8, 495, 119);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Top-left rectangle
    //

    //hTemp = CreateRoundRectRgn(33, 13, 118, 127, 12, 12);
    hTemp = CreateRoundRectRgn(29, 13, 114, 127, 12, 12);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Top-right rectangle
    //

    //hTemp = CreateRoundRectRgn(494, 13, 579, 127, 12, 12);
    hTemp = CreateRoundRectRgn(490, 13, 575, 127, 12, 12);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Top-left triangle
    //

    //poly[0].x = 36;  poly[0].y = 13;
    //poly[1].x = 111; poly[1].y = 13;
    //poly[2].x = 111;  poly[2].y = 1;
    poly[0].x = 32;  poly[0].y = 13;
    poly[1].x = 107; poly[1].y = 13;
    poly[2].x = 107;  poly[2].y = 1;

    hTemp = CreatePolygonRgn(poly, 3, ALTERNATE);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Top-right triangle
    //

    //poly[0].x = 499;  poly[0].y = 13;
    //poly[1].x = 572; poly[1].y = 13;
    //poly[2].x = 499;  poly[2].y = 1;
    poly[0].x = 495;  poly[0].y = 13;
    poly[1].x = 568; poly[1].y = 13;
    poly[2].x = 495;  poly[2].y = 1;

    hTemp = CreatePolygonRgn(poly, 3, ALTERNATE);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Top-left ellipse
    //

    //hTemp = CreateEllipticRgn(104, 2, 118, 25);
    hTemp = CreateEllipticRgn(100, 2, 114, 25);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Top-right ellipse
    //

    //hTemp = CreateEllipticRgn(494, 2, 508, 25);
    hTemp = CreateEllipticRgn(490, 2, 504, 25);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Left post
    //

    //hTemp = CreateRectRgn(68, 126, 95, 141);
    hTemp = CreateRectRgn(67, 126, 94, 141);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Right post
    //

    //hTemp = CreateRectRgn(516, 126, 542, 141);
    hTemp = CreateRectRgn(509, 126, 535, 141);
    CombineRgn(hTotal, hTotal, hTemp, RGN_OR);

    //
    // Offset the region for the window caption
    //

    OffsetRgn(hTotal, GetSystemMetrics(SM_CXFIXEDFRAME),
        GetSystemMetrics(SM_CYFIXEDFRAME) + GetSystemMetrics(SM_CYCAPTION));
    
    SetWindowRgn(hTotal, TRUE);
    DeleteObject(hTemp);
}

/////////////////////////////////////////////////////////////////////////////
//
//

HPALETTE CMainFrm::GeneratePalette()
{
    #define NUMPALCOLORS 128

    BYTE byVals[NUMPALCOLORS][3] = {
        255, 255, 255,
        252, 252, 252,
        251, 247, 255,
        246, 246, 246,
        242, 242, 242,
        239, 234, 240,
        235, 235, 235,
        231, 230, 231,
        231, 231, 222,
        230, 230, 230,
        255, 218, 222,
        229, 229, 229,
        229, 229, 225,
        228, 228, 228,
        227, 227, 227,
        227, 227, 225,
        224, 223, 228,
        231, 222, 206,
        222, 223, 218,
        222, 222, 222,
        222, 222, 221,
        222, 219, 222,
        220, 220, 220,
        217, 217, 217,
        214, 215, 235,
        214, 215, 214,
        234, 221, 112,
        214, 211, 214,
        211, 211, 210,
        212, 212, 198,
        206, 209, 228,
        214, 206, 206,
        207, 204, 230,
        206, 203, 238,
        207, 207, 207,
        242, 224,  18,
        206, 207, 206,
        206, 206, 206,
        216, 199, 211,
        205, 205, 205,
        206, 206, 206,
        204, 204, 204,
        203, 203, 203,
        202, 202, 202,
        201, 201, 201,
        200, 200, 200,
        199, 199, 199,
        198, 199, 198,
        198, 198, 198,
        197, 197, 197,
        198, 195, 198,
        196, 196, 196,
        195, 195, 195,
        194, 194, 194,
        193, 193, 193,
        192, 192, 192,
        162, 204, 209,
        191, 191, 191,
        190, 190, 190,
        189, 190, 189,
        189, 189, 189,
        183, 190, 198,
        188, 188, 188,
        189, 186, 189,
        187, 187, 187,
        186, 186, 186,
        185, 185, 185,
        184, 184, 184,
        183, 183, 183,
        181, 182, 190,
        181, 181, 181,
        147, 206, 133,
        180, 180, 179,
        181, 178, 181,
         97, 214, 214,
        171, 180, 187,
        177, 178, 177,
        154, 179, 220,
        176, 176, 176,
        160, 204,  64,
        175, 175, 174,
        173, 175, 173,
        173, 173, 173,
        171, 171, 171,
        171, 170, 174,
        167, 170, 182,
        182, 172, 122,
        169, 169, 169,
        166, 166, 166,
        165, 164, 165,
        161, 162, 165,
        161, 161, 161,
         30, 251,  28,
        170, 160, 129,
        158, 158, 158,
        156, 155, 156,
        153, 154, 156,
        150, 150, 150,
        148, 148, 146,
        143, 142, 143,
        140, 142, 146,
        187, 137,  43,
        132, 141, 153,
        132, 140, 140,
        136, 137, 133,
        113, 136, 139,
        127, 127, 131,
        124, 124, 124,
        118, 118, 117,
        111, 111, 111,
        122, 113,  35,
        255,   0, 255,
        103, 102,  97,
         88,  99, 123,
         85,  85,  85,
         75,  75,  75,
         55,  94,   6,
         69,  64,  44,
         34,  34,  49,
         24,  26,  17,
          0,   0, 132,
          0,   0, 128,
          0,   0, 117,
          0,   0,  71,
          0,   0,  64,
          0,   0,  63,
          0,   0,  46,
          0,   0,   0
    };  

    struct
    {
        LOGPALETTE lp;
        PALETTEENTRY ape[NUMPALCOLORS-1];
    } pal;

    HDC hdc = GetDC();

    int iRasterCaps;
    int iReserved;
    int iPalSize;

    iRasterCaps = GetDeviceCaps(hdc, RASTERCAPS);
    iRasterCaps = (iRasterCaps & RC_PALETTE) ? TRUE : FALSE;

    if (iRasterCaps)
    {
        iReserved = GetDeviceCaps(hdc, NUMRESERVED);
        iPalSize = GetDeviceCaps(hdc, SIZEPALETTE) - iReserved;

        ReleaseDC(hdc);

        LOG((RTC_INFO, "CMainFrm::GeneratePalette - Palette has %d reserved colors", iReserved));
        LOG((RTC_INFO, "CMainFrm::GeneratePalette - Palette has %d available colors", iPalSize));
    }
    else
    {
        LOG((RTC_WARN, "CMainFrm::GeneratePalette - Display is not palette capable"));

        ReleaseDC(hdc);

        return NULL;
    }

    if (iPalSize <= NUMPALCOLORS)
    {
        LOG((RTC_WARN, "CMainFrm::GeneratePalette - Not enough colors available in palette"));

        return NULL;
    }

    LOGPALETTE* pLP = (LOGPALETTE*)&pal;
    pLP->palVersion = 0x300;
    pLP->palNumEntries = NUMPALCOLORS;

    for (int i = 0; i < pLP->palNumEntries; i++)
    {
        pLP->palPalEntry[i].peRed = byVals[i][0];
        pLP->palPalEntry[i].peGreen = byVals[i][1];
        pLP->palPalEntry[i].peBlue = byVals[i][2];
        pLP->palPalEntry[i].peFlags = 0;
    }

    HPALETTE hPalette = CreatePalette(pLP);

    if (hPalette == NULL)
    {
        LOG((RTC_ERROR, "CMainFrm::GeneratePalette - Failed to create palette"));
    }

    return hPalette;
}

/////////////////////////////////////////////////////////////////////////////
//
//

BOOL CALLBACK ChildPaletteProc(HWND hwnd, LPARAM lParam)
{
    InvalidateRect(hwnd, NULL, TRUE);

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//
    
LRESULT CMainFrm::OnSysCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    bHandled = FALSE;

    switch (wParam)
    {
        case SC_SCREENSAVE:
            //LOG((RTC_INFO, "CMainFrm::OnSysCommand - SC_SCREENSAVE"));

            if ( m_nState != RTCAX_STATE_IDLE )
            {
                //LOG((RTC_INFO, "CMainFrm::OnSysCommand - not starting screen saver"));

                bHandled = TRUE;
            }
            break;
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//
    
LRESULT CMainFrm::OnPowerBroadcast(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnPowerBroadcast - enter"));

    switch (wParam)
    {
        case PBT_APMQUERYSUSPEND:
            LOG((RTC_INFO, "CMainFrm::OnPowerBroadcast - PBT_APMQUERYSUSPEND"));

            if ( m_nState != RTCAX_STATE_IDLE )
            {
                LOG((RTC_TRACE, "CMainFrm::OnPowerBroadcast - returning BROADCAST_QUERY_DENY"));

                return BROADCAST_QUERY_DENY;
            }
            break;
    }

    LOG((RTC_TRACE, "CMainFrm::OnPowerBroadcast - exit"));

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnQueryNewPalette(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnQueryNewPalette"));

    if (m_hPalette == NULL)
    {
        return FALSE;
    }

    HDC hdc = GetDC();

    SelectPalette(hdc, m_hPalette, m_bBackgroundPalette);
    RealizePalette(hdc);

    InvalidateRect(NULL, TRUE);
    
    EnumChildWindows(m_hWnd,ChildPaletteProc,0);  

    ReleaseDC(hdc);

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnPaletteChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnPaletteChanged"));

    if ( (m_hPalette == NULL) || ((HWND)wParam == NULL) )
    {
        return 0;
    }

    //
    // Did one of our children change the palette?
    //

    HWND hwnd = (HWND)wParam;

    if ( IsAncestorWindow(m_hWnd, hwnd) )
    {
        //
        // One of our children changed the palette. It was most likely a video window.
        // Put ourselves in background palette mode so the video will look good.
        //

        m_bBackgroundPalette = TRUE;

        if (m_pControlIntf != NULL)
        {
            m_pControlIntf->put_BackgroundPalette( m_bBackgroundPalette );
        }
    }

    //
    // Set the palette
    //

    HDC hdc = GetDC();

    SelectPalette(hdc, m_hPalette, m_bBackgroundPalette);
    RealizePalette(hdc);
    
    //UpdateColors(hdc);
    InvalidateRect(NULL, TRUE);
    
    EnumChildWindows(m_hWnd,ChildPaletteProc,0);  

    ReleaseDC(hdc);

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnDisplayChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnDisplayChange"));

    if (m_hPalette != NULL)
    {
        DeleteObject(m_hPalette);
        m_hPalette = NULL;
    }

    m_hPalette = GeneratePalette();

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

#define CH_PREFIX TEXT('&')

TCHAR GetAccelerator(LPCTSTR psz, BOOL bUseDefault)
{
    TCHAR ch = (TCHAR)-1;
    LPCTSTR pszAccel = psz;
    // then prefixes are allowed.... see if it has one
    do 
    {
        pszAccel = _tcschr(pszAccel, CH_PREFIX);
        if (pszAccel) 
        {
            pszAccel = CharNext(pszAccel);

            // handle having &&
            if (*pszAccel != CH_PREFIX)
                ch = *pszAccel;
            else
                pszAccel = CharNext(pszAccel);
        }
    } while (pszAccel && (ch == (TCHAR)-1));

    if ((ch == (TCHAR)-1) && bUseDefault)
    {
        // Since we're unicocde, we don't need to mess with MBCS
        ch = *psz;
    }

    return ch;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnNCPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // LOG((RTC_TRACE, "CMainFrm::OnNCPaint"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnNCHitTest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    //LOG((RTC_TRACE, "CMainFrm::OnNCHitTest"));

    POINT pt;
    RECT rc;

    pt.x = (short)LOWORD(lParam);
    pt.y = (short)HIWORD(lParam);

    //LOG((RTC_TRACE, "screen (%d,%d)", pt.x, pt.y));

    ::MapWindowPoints( NULL, m_hWnd, &pt, 1 );

    //LOG((RTC_TRACE, "client (%d,%d)", pt.x, pt.y));

    //
    // Check for sysmenu hit
    //
    
    rc.top = SYS_TOP;
    rc.bottom = SYS_BOTTOM;
    rc.left = SYS_LEFT;
    rc.right = SYS_RIGHT;

    if (PtInRect(&rc,pt))
    {
        return HTSYSMENU;
    }

    //
    // Check for caption hit
    //

    rc.top = TITLE_TOP;
    rc.bottom = TITLE_BOTTOM;
    rc.left = TITLE_LEFT;
    rc.right = TITLE_RIGHT;

    if (PtInRect(&rc,pt))
    {
        return HTCAPTION;
    }

    return HTCLIENT;
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CALLBACK SysMenuTimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    KillTimer(hwnd,idEvent);

    RECT rc;
    rc.top = SYS_TOP;
    rc.bottom = SYS_BOTTOM;
    rc.left = SYS_LEFT;
    rc.right = SYS_RIGHT;

    ::MapWindowPoints( hwnd, NULL, (LPPOINT)&rc, 2 );

    HMENU hSysMenu = GetSystemMenu(hwnd, FALSE);

    TPMPARAMS tpm;
    tpm.cbSize = sizeof(tpm);
    memcpy(&(tpm.rcExclude),&rc,sizeof(RECT));

    BOOL fResult;

    fResult = TrackPopupMenuEx(hSysMenu, TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_VERTICAL|TPM_RETURNCMD,             
                                  rc.left, rc.bottom, hwnd, &tpm);    
        
    if (fResult > 0)
    {
        SendMessage(hwnd, WM_SYSCOMMAND, fResult, MAKELPARAM(rc.left, rc.bottom));
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnNCLButton(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnNCLButton"));

    if ((int)wParam == HTSYSMENU)
    {
        ::SetTimer(m_hWnd,TID_SYS_TIMER,GetDoubleClickTime()+100,(TIMERPROC)SysMenuTimerProc);
    }
    else
    {
        bHandled = FALSE;
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnNCLButtonDbl(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnNCLButtonDbl"));

    KillTimer(TID_SYS_TIMER);

    bHandled = FALSE;

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnNCRButton(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnNCRButton"));

    if (((int)wParam == HTCAPTION) || ((int)wParam == HTSYSMENU))
    {
        POINTS pts = MAKEPOINTS(lParam);
        HMENU hSysMenu = GetSystemMenu(FALSE);

        BOOL fResult;

        fResult = TrackPopupMenu(hSysMenu,TPM_RETURNCMD,pts.x,pts.y,0,m_hWnd,NULL);

        if (fResult > 0)
        {
            SendMessage(m_hWnd, WM_SYSCOMMAND, fResult, MAKELPARAM(pts.x, pts.y));
        }
    }
    else
    {
        bHandled = FALSE;
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // LOG((RTC_TRACE, "CMainFrm::OnPaint"));
   
    PAINTSTRUCT ps;
    HDC hdc;
    
    hdc = BeginPaint(&ps);
    EndPaint(&ps);
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//
HRESULT CMainFrm::FillGradient(HDC hdc, LPCRECT prc, COLORREF rgbLeft, COLORREF rgbRight)
{
    TRIVERTEX avert[2];
    static GRADIENT_RECT auRect[1] = {0,1};
    #define GetCOLOR16(RGB, clr) ((COLOR16)(Get ## RGB ## Value(clr) << 8))

    avert[0].Red = GetCOLOR16(R, rgbLeft);
    avert[0].Green = GetCOLOR16(G, rgbLeft);
    avert[0].Blue = GetCOLOR16(B, rgbLeft);

    avert[1].Red = GetCOLOR16(R, rgbRight);
    avert[1].Green = GetCOLOR16(G, rgbRight);
    avert[1].Blue = GetCOLOR16(B, rgbRight);

    avert[0].x = prc->left;
    avert[0].y = prc->top;
    avert[1].x = prc->right;
    avert[1].y = prc->bottom;

    //only load once, when needed.  Freed in "CleanUp" call
    if (m_hImageLib == NULL)
    {
        m_hImageLib = LoadLibrary(TEXT("MSIMG32.DLL"));
        if (m_hImageLib!=NULL)
        {
            m_fnGradient = (GRADIENTPROC)GetProcAddress(m_hImageLib,"GradientFill");
        }
    }

    if (m_fnGradient!=NULL)
    {
        m_fnGradient(hdc, avert, 2, (PUSHORT)auRect, 1, 0x00000000);

        return S_OK;
    }

    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
//
//
void UIMaskBlt(HDC hdcDest, int x, int y, int width, int height, 
                        HDC hdcSource, int xs, int ys, 
                        HBITMAP hMask, int xm, int ym)
{
    HDC hdcMask = CreateCompatibleDC(hdcDest);
    if(hdcMask)
    {
        HBITMAP holdbmp = (HBITMAP)SelectObject(hdcMask,hMask);

        BitBlt(hdcDest, x, y, width, height, hdcSource, xs, ys, SRCINVERT);
        BitBlt(hdcDest, x, y, width, height, hdcMask, xm, ym, SRCAND);
        BitBlt(hdcDest, x, y, width, height, hdcSource, xs, ys, SRCINVERT);

        SelectObject(hdcMask,holdbmp);
        DeleteDC(hdcMask);
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//
void CMainFrm::DrawTitleBar(HDC memDC)
{
    HBRUSH hbrush;

    RECT rcMainWnd;
    RECT rcDest;

    HRESULT hr;

    //
    // Draw the title bar background
    //

    BOOL fActiveWindow = (m_hWnd == GetForegroundWindow());

    rcDest.left = TITLE_LEFT;
    rcDest.right = TITLE_RIGHT;
    rcDest.top = TITLE_TOP;
    rcDest.bottom = TITLE_BOTTOM;

    BOOL fGradient = FALSE;
    SystemParametersInfo(SPI_GETGRADIENTCAPTIONS,0,&fGradient,0);

    if (fGradient)
    {
        DWORD dwStartColor = GetSysColor(fActiveWindow ? COLOR_ACTIVECAPTION : COLOR_INACTIVECAPTION);
        DWORD dwFinishColor = GetSysColor(fActiveWindow ? COLOR_GRADIENTACTIVECAPTION : COLOR_GRADIENTINACTIVECAPTION);
        hr = FillGradient(memDC,&rcDest,dwStartColor,dwFinishColor);
    }
    
    if (!fGradient || FAILED(hr))
    {
        hbrush = CreateSolidBrush(GetSysColor(fActiveWindow ? COLOR_ACTIVECAPTION : COLOR_INACTIVECAPTION));
        FillRect(memDC,&rcDest,hbrush);
        DeleteObject(hbrush);
    }

    //
    // Draw the sysmenu bitmap
    // 

    HDC hdcSysMenu = CreateCompatibleDC(memDC);
    if(hdcSysMenu)
    {
        HBITMAP holdbmp = (HBITMAP)SelectObject(hdcSysMenu,m_hSysMenuNorm);

        UIMaskBlt(memDC, SYS_LEFT, SYS_TOP, SYS_WIDTH, SYS_HEIGHT, hdcSysMenu, 0, 0, m_hSysMenuMask, 0, 0);

        SelectObject(hdcSysMenu,holdbmp);
        DeleteDC(hdcSysMenu);
    }

    //
    // Draw the title bar text
    //

    TCHAR s[MAX_PATH];
    GetWindowText(s,MAX_PATH-1);

    SetBkMode(memDC,TRANSPARENT);
    SetTextColor(memDC, GetSysColor(fActiveWindow ? COLOR_CAPTIONTEXT : COLOR_INACTIVECAPTIONTEXT));

    // create title bar font
    NONCLIENTMETRICS metrics;
    metrics.cbSize = sizeof(metrics);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS,sizeof(metrics),&metrics,0);

    HFONT hTitleFont = CreateFontIndirect(&metrics.lfCaptionFont);
    HFONT hOrgFont = (HFONT)SelectObject(memDC, hTitleFont);

    // center text vertically
    SIZE size;
    GetTextExtentPoint32(memDC, s, _tcslen(s), &size);

    ExtTextOut(memDC, SYS_RIGHT + 6, rcDest.top + (TITLE_HEIGHT - size.cy) / 2, 0, NULL, s, _tcslen(s), NULL );

    SelectObject(memDC,hOrgFont);
    DeleteObject(hTitleFont);
}

/////////////////////////////////////////////////////////////////////////////
//
//
void CMainFrm::InvalidateTitleBar(BOOL bIncludingButtons)
{
    RECT    rc;

    rc.left = TITLE_LEFT;
    rc.right = bIncludingButtons ? TITLE_RIGHT : MINIMIZE_LEFT;
    rc.top = TITLE_TOP;
    rc.bottom = TITLE_BOTTOM;

    InvalidateRect(&rc, TRUE);
    
    if(bIncludingButtons)
    {
        m_hCloseButton.InvalidateRect(NULL, TRUE);
        m_hMinimizeButton.InvalidateRect(NULL, TRUE);
    }
}


/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // LOG((RTC_TRACE, "CMainFrm::OnEraseBkgnd"));

    HDC hdc = (HDC)wParam;

    HWND hwnd = WindowFromDC( hdc );

    if (m_hPalette)
    {
        SelectPalette(hdc, m_hPalette, m_bBackgroundPalette);
        RealizePalette(hdc);
    }

    HDC hdcMem = CreateCompatibleDC(hdc);
    if(!hdcMem)
    {
        // error
        return 1;
    }

    if (m_hPalette)
    {
        SelectPalette(hdcMem, m_hPalette, m_bBackgroundPalette);
        RealizePalette(hdcMem);
    }

    HBITMAP hBitmap = CreateCompatibleBitmap( hdc, UI_WIDTH, UI_HEIGHT);

    if(hBitmap)
    {
        HBITMAP hOldBitmap = (HBITMAP)SelectObject( hdcMem, hBitmap);

        DibBlt(hdcMem, 0, 0, -1, -1, m_hUIBkgnd, 0, 0, SRCCOPY, 0);

        if ((hwnd == m_hWnd) || (hwnd == m_hToolbarMenuCtl))
        {
            DrawTitleBar( hdcMem );

            BitBlt(hdc, 0, 0, UI_WIDTH, UI_HEIGHT, hdcMem, 0, 0, SRCCOPY);
        }
        else if ((hwnd == m_hBuddyList) || (hwnd == NULL))
        {
            // This is from the contact list
            BitBlt(hdc, 0, 0, BUDDIES_WIDTH, BUDDIES_HEIGHT, hdcMem, BUDDIES_LEFT, BUDDIES_TOP, SRCCOPY);
        }

        SelectObject( hdcMem, hOldBitmap );
        DeleteObject( hBitmap );
    }

    DeleteDC(hdcMem);
 
    return 1;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnActivate"));

    InvalidateTitleBar(TRUE);
    
    // clear keyboard shortcuts
    SendMessage(m_hWnd, WM_CHANGEUISTATE,
                MAKEWPARAM(UIS_SET, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);

    m_bWindowActive = (LOWORD(wParam) != WA_INACTIVE);
   
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::BrowseToUrl(
    IN   WCHAR * wszUrl
    )
{
    LOG((RTC_TRACE, "CMainFrm::BrowseToUrl <%S> - enter", wszUrl ? wszUrl : L"NULL"));

    if(wszUrl == NULL)
    {
        LOG((RTC_ERROR, "CMainFrm::BrowseToUrl - NULL URL !!"));

        return E_INVALIDARG;
    }

#ifdef WEBCONTROL

    HRESULT hr;

    if (m_bstrLastBrowse != NULL)
    {
        if (!KillTimer( TID_BROWSER_RETRY_TIMER ))
        {
            //
            // If we are not here because of a retry timer, then check to
            // make sure we are not browsing to what we already have
            // displayed.
            //

            if (wcscmp(wszUrl, m_bstrLastBrowse) == 0)
            {
                LOG((RTC_INFO, "CMainFrm::BrowseToUrl - already "
                            "browsing this page - exit S_FALSE"));

                return S_FALSE;
            }
        }

        SysFreeString( m_bstrLastBrowse );
        m_bstrLastBrowse = NULL;
    }    

    //
    // Get the IWebBrowser2 interface from the browser control.
    //

    IWebBrowser2 * pBrowser;

    hr = m_hBrowser.QueryControl(
        IID_IWebBrowser2,
        (void **) & pBrowser
        );

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CMainFrm::BrowseToUrl - failed to get "
                        "IWebBrowser2 interface - exit 0x%08x", hr));

        return hr;
    }

    //
    // Allocate a BSTR to pass the URL in.
    //

    m_bstrLastBrowse = SysAllocString( wszUrl );

    if ( m_bstrLastBrowse == NULL )
    {
        LOG((RTC_ERROR, "CMainFrm::BrowseToUrl - failed to allocate "
                        "URL BSTR - exit E_OUTOFMEMORY"));

        RELEASE_NULLIFY(pBrowser);
        
        return E_OUTOFMEMORY;
    }

    //
    // Tell the browser to navigate to this URL.
    //

    VARIANT     vtUrl;
    VARIANT     vtEmpty;

    vtUrl.vt = VT_BSTR;
    vtUrl.bstrVal = m_bstrLastBrowse;

    VariantInit(&vtEmpty);

    hr = pBrowser->Navigate2(
        &vtUrl,
        &vtEmpty,
        &vtEmpty,
        &vtEmpty,
        &vtEmpty
        );



    RELEASE_NULLIFY(pBrowser);

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CMainFrm::BrowseToUrl - failed to "
                        "Navigate - exit 0x%08x", hr));


        if ( (hr == RPC_E_CALL_REJECTED) ||
             (hr == HRESULT_FROM_WIN32(ERROR_BUSY)) )
        {
            //
            // The browser is busy. Save this string and retry later.
            //            

            SetTimer(TID_BROWSER_RETRY_TIMER, 1000);
        }

        return hr;
    }

#endif

    LOG((RTC_TRACE, "CMainFrm::BrowseToUrl - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnDestroy - enter"));

    // Empty the combo boxes
    CleanupListOrComboBoxInterfaceReferences(m_hWnd, IDC_COMBO_SERVICE_PROVIDER, TRUE);
    CleanupListOrComboBoxInterfaceReferences(m_hWnd, IDC_COMBO_CALL_FROM, TRUE);

    // Close the incoming call dialog box (if opened)
    ShowIncomingCallDlg(FALSE);

    // Release the buddy list
    ReleaseBuddyList();

    g_NotifySink.UnadviseControl();

    g_CoreNotifySink.UnadviseControl();

    if (m_pControlIntf != NULL)
    {
        m_pControlIntf.Release();
        m_pControlIntf = NULL;
    }

    if (m_pClientIntf != NULL)
    {
        m_pClientIntf.Release();
        m_pClientIntf = NULL;
    }
    
    // Close the MUTEX so that it is released as soon as the APP starts the 
    // shutdown.

    if (g_hMutex != NULL)
    {
        CloseHandle(g_hMutex);
        g_hMutex = NULL;
    }

    // destory the redial popup menu
    DestroyRedialPopupMenu();

    // destroy the shell status icon
    DeleteStatusIcon();

    // Destroy the toolbar control
    DestroyToolbarMenuControl();

    // stop browser retries
    KillTimer( TID_BROWSER_RETRY_TIMER );

    if (m_bstrLastBrowse != NULL)
    {
        SysFreeString( m_bstrLastBrowse );
        m_bstrLastBrowse = NULL;
    }

    if(m_bstrLastCustomStatus!=NULL)
    {
        SysFreeString(m_bstrLastCustomStatus);
        m_bstrLastCustomStatus = NULL;
    }

#ifdef WEBCONTROL

    // Destroy the browser
    m_hBrowser.Destroy();

#endif

    // Destroy windows objects

    if(m_hPresenceStatusMenu != NULL)
    {
        DestroyMenu( m_hPresenceStatusMenu );
        m_hPresenceStatusMenu = NULL;
    }

    if ( m_hNotifyMenu != NULL )
    {
        DestroyMenu( m_hNotifyMenu );
        m_hNotifyMenu = NULL;
    }

    if ( m_hMenu != NULL )
    {
        DestroyMenu(m_hMenu);
        m_hMenu = NULL;
    }

    if ( m_hIcon != NULL )
    {
        DeleteObject( m_hIcon );
        m_hIcon = NULL;
    }

    if ( m_hUIBkgnd != NULL )
    {
        //DeleteObject( m_hUIBkgnd );
        GlobalFree( m_hUIBkgnd );
        m_hUIBkgnd = NULL;
    }

    if ( m_hSysMenuNorm != NULL )
    {
        DeleteObject( m_hSysMenuNorm );
        m_hSysMenuNorm = NULL;
    }

    if ( m_hSysMenuMask != NULL )
    {
        DeleteObject( m_hSysMenuMask );
        m_hSysMenuMask = NULL;
    }

    if ( m_hMessageFont != NULL )
    {
        DeleteObject( m_hMessageFont );
        m_hMessageFont = NULL;
    }

    if ( m_hPalette != NULL )
    {
        DeleteObject( m_hPalette );
        m_hPalette = NULL;
    }

    PostQuitMessage(0); 
    
    LOG((RTC_TRACE, "CMainFrm::OnDestroy - exiting"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnOpen(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    ShowWindow(SW_RESTORE);

    SetForegroundWindow(m_hWnd);

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnClose - Enter"));
    LONG lMsgId;
    HRESULT hr;
    BOOL fProceed;
    BOOL fExit;

    // Pick the correct message to show based on what we are supposed to do.

    if (uMsg == WM_QUERYENDSESSION)
    {
        fExit = TRUE;
    }
    else
    {
        if (m_fMinimizeOnClose)
        {
            fExit = FALSE;
        }
        else
        {
            fExit = TRUE;
        }
    }

    // Show the message for dropping the active call, if any

    hr = ShowCallDropPopup(fExit, &fProceed);

    if (fProceed)
    {
        if ((uMsg == WM_QUERYENDSESSION) || (!m_fMinimizeOnClose))
        {
            //
            // Save the window position
            //

            SaveWindowPosition();

            //
            // Save combo box settings
            //

            if(m_pClientIntf)
            {
                IRTCProfile * pProfile = NULL;
                HRESULT hr;

                //
                // Save the profile to populate the 
                // combo next time
                // 

                hr = GetServiceProviderListSelection(
                    m_hWnd,
                    IDC_COMBO_SERVICE_PROVIDER,
                    TRUE,
                    &pProfile
                    );

                if ( SUCCEEDED(hr) )
                {
                    BSTR bstrProfileKey;

                    if ( pProfile != NULL )
                    {
                        hr = pProfile->get_Key( &bstrProfileKey );

                        if ( SUCCEEDED(hr) )
                        {
                            put_SettingsString( 
                                    SS_LAST_PROFILE,
                                    bstrProfileKey );

                            SysFreeString( bstrProfileKey );
                        }
                    }
                    else
                    {
                        DeleteSettingsString( SS_LAST_PROFILE );
                    }
                }                
            }

            //
            // Destroy the window
            //

            DestroyWindow();
        }
        else
        {
            //
            // Hide the window
            //

            ShowWindow(SW_HIDE);
        }        
    }

    LOG((RTC_TRACE, "CMainFrm::OnClose - Exit"));
    return fProceed;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnCancel - Enter"));

    SendMessage(WM_CLOSE, 0, 0);
    
    LOG((RTC_TRACE, "CMainFrm::OnCancel - Exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnMinimize(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnMinimize"));

    ShowWindow(SW_MINIMIZE);
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnCallFromSelect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnCallFromSelect"));

    if (wID == IDC_COMBO_SERVICE_PROVIDER)
    {
        //
        // Service provider selection was changed. Navigate the web
        // browser.
        //
   
        IRTCProfile * pProfile = NULL;

#ifdef MULTI_PROVIDER

        LRESULT lrIndex = SendMessage( m_hProviderCombo, CB_GETCURSEL, 0, 0 );

        if ( lrIndex != CB_ERR )
        {
            pProfile = (IRTCProfile *)SendMessage( m_hProviderCombo, CB_GETITEMDATA, lrIndex, 0 );
        }
       
        if ( pProfile != NULL )
        {
            //
            // If we got the IRTCProfile
            //

            BSTR bstrURI = NULL;
            HRESULT hr;

            hr = pProfile->get_ProviderURI(
                RTCPU_URIDISPLAYDURINGIDLE,
                & bstrURI
                );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CMainFrm::OnCallFromSelect - "
                                "cannot get profile URI 0x%x", hr));

                pProfile = NULL;
            }
            else
            {
                hr = BrowseToUrl( bstrURI );

                SysFreeString( bstrURI );
                bstrURI = NULL;
            }
        }

#endif MULTI_PROVIDER

        if ( pProfile == NULL )
        {
            //
            // If we don't have a valid profile, browse to the default page
            //

            BrowseToUrl( m_bstrDefaultURL );
        }
    }

    if ((wID == IDC_COMBO_CALL_FROM) && (m_pClientIntf != NULL))
    {
        //
        // Save the call from to populate the combo later
        //

        IRTCPhoneNumber   * pPhoneNumber = NULL;
        BSTR                bstrPhoneNumber = NULL;
        HRESULT             hr;

        hr = GetCallFromListSelection(
            m_hWnd,
            IDC_COMBO_CALL_FROM,
            TRUE,
            &pPhoneNumber
            );

        if ( SUCCEEDED(hr) )
        {          
            hr = pPhoneNumber->get_Canonical( &bstrPhoneNumber );
        
            if ( SUCCEEDED(hr) )
            {
                put_SettingsString( 
                                SS_LAST_CALL_FROM,
                                bstrPhoneNumber );  

                SysFreeString( bstrPhoneNumber );
                bstrPhoneNumber = NULL;
            }
        }
    }

    if ((wNotifyCode == BN_CLICKED) || (wNotifyCode == 1))
    {
        if (::IsWindowEnabled( GetDlgItem(wID) ))
        {
            //
            // A radio button was clicked. Change the check marks
            //

            if (wID == IDC_RADIO_FROM_PHONE)
            {
                SendMessage(
                        m_hCallFromRadioPhone,
                        BM_SETCHECK,
                        BST_CHECKED,
                        0);

                SendMessage(
                        m_hCallFromRadioPC,
                        BM_SETCHECK,
                        BST_UNCHECKED,
                        0);

                // Verify if the Combo has at least one entry in it
                DWORD dwNumItems = (DWORD) SendDlgItemMessage(
                    IDC_COMBO_CALL_FROM,
                    CB_GETCOUNT,
                    0,
                    0
                    );

                if( dwNumItems == 0 )
                {
                    // Display the CallFrom options
                    // simulate a button press
                    BOOL    bHandled;

                    OnCallFromOptions(BN_CLICKED, ID_CALL_FROM_EDIT, NULL, bHandled);
                }
            }
            else if (wID == IDC_RADIO_FROM_COMPUTER)
            {
                SendMessage(
                        m_hCallFromRadioPhone,
                        BM_SETCHECK,
                        BST_UNCHECKED,
                        0);

                SendMessage(
                        m_hCallFromRadioPC,
                        BM_SETCHECK,
                        BST_CHECKED,
                        0);
            }
        }
    }

    //
    // Enable disable controls as appropriate
    //

    BOOL bCallFromPCEnable;
    BOOL bCallFromPhoneEnable;
    BOOL bCallToPCEnable;
    BOOL bCallToPhoneEnable;
    
    EnableDisableCallGroupElements(
        m_hWnd,
        m_pClientIntf,
        0xF,
        IDC_RADIO_FROM_COMPUTER,
        IDC_RADIO_FROM_PHONE,
        IDC_COMBO_CALL_FROM,
        IDC_COMBO_SERVICE_PROVIDER,
        &bCallFromPCEnable,
        &bCallFromPhoneEnable,
        &bCallToPCEnable,
        &bCallToPhoneEnable
        );

    m_hCallFromTextPC.EnableWindow( bCallFromPCEnable );
    m_hCallFromTextPhone.EnableWindow( bCallFromPhoneEnable );
    
    m_hCallPCButton.EnableWindow( bCallToPCEnable );
    m_hCallPCText.EnableWindow( bCallToPCEnable );
    m_hCallPhoneButton.EnableWindow( bCallToPhoneEnable );
    m_hCallPhoneText.EnableWindow( bCallToPhoneEnable );

    EnableMenuItem(m_hMenu, IDM_CALL_CALLPC, bCallToPCEnable ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(m_hMenu, IDM_CALL_CALLPHONE, bCallToPhoneEnable ? MF_ENABLED : MF_GRAYED);  
    EnableMenuItem(m_hMenu, IDM_CALL_MESSAGE, bCallToPCEnable ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(m_hNotifyMenu, IDM_CALL_CALLPC, bCallToPCEnable ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(m_hNotifyMenu, IDM_CALL_CALLPHONE, bCallToPhoneEnable ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(m_hNotifyMenu, IDM_CALL_MESSAGE, bCallToPCEnable ? MF_ENABLED : MF_GRAYED);
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnExit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnExit - Enter"));

    //
    // Call on close to do the work. Using WM_QUERYENDSESSION will have the effect
    // of causing the app to exit
    //
    OnClose( WM_QUERYENDSESSION, 0, 0, bHandled);

    LOG((RTC_TRACE, "CMainFrm::OnExit - Exit"));
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnUpdateState(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CMainFrm::OnUpdateState - enter"));
    
    m_nState = (RTCAX_STATE)wParam;
    m_nStatusStringResID = (UINT)lParam;
    
    // if state == ALERTING open the incoming calls dialog
    if(m_nState == RTCAX_STATE_ALERTING) 
    {
        ATLASSERT(m_pControlIntf);

        if(!IsWindowEnabled())
        {
            // For busy frame, directly call Reject
            // don't call UpdateFrameVisual() here in order to avoid the flickering
            
            m_bVisualStateFrozen = TRUE;

            LOG((RTC_INFO, "CMainFrm::OnUpdateState, frame is busy, calling Reject"));
            
            m_pControlIntf->Reject(RTCTR_BUSY);
        }
        else if(m_bDoNotDisturb)
        {
            // For Do Not disturb mode, directly call Reject
            // don't call UpdateFrameVisual() here in order to avoid the flickering

            m_bVisualStateFrozen = TRUE;

            LOG((RTC_INFO, "CMainFrm::OnUpdateState, DND mode, calling Reject"));

            m_pControlIntf->Reject(RTCTR_DND);

        }
        else if (m_bAutoAnswerMode)
        {
            // For AutoAnswer mode answer automaticaly
            // don't call UpdateFrameVisual() here in order to avoid the flickering
                       
            //
            // Play a ring to alert the user
            //

            m_pClientIntf->PlayRing( RTCRT_PHONE, VARIANT_TRUE );

            LOG((RTC_INFO, "CMainFrm::OnUpdateState, AA mode, calling Accept"));

            m_pControlIntf->Accept();
        }
        else 
        {
            // update the visual state
            UpdateFrameVisual();
            
            // Display the dialog box.
            //
            hr = ShowIncomingCallDlg(TRUE);

            if(FAILED(hr))
            {
                // Reject the call !

                m_pControlIntf -> Reject(RTCTR_BUSY);
            }
        }
    }
    else
    {
        if(m_nState == RTCAX_STATE_ANSWERING) 
        {
            if(!IsWindowVisible())
            {
                ShowWindow(SW_SHOWNORMAL);
            }
        }
        // avoid the flickering:
        //  when an incoming call is automatically rejected
        
        if(!m_bVisualStateFrozen)
        {
            UpdateFrameVisual();
        }

        // reset the freezing state
        if(m_nState == RTCAX_STATE_IDLE) 
        {
            m_bVisualStateFrozen = FALSE;
        }
        
        if(m_pIncomingCallDlg)
        {
            // close the dialog box
            ShowIncomingCallDlg(FALSE);
        }
        //  See if we can place a pending call now.

        if (m_nState == RTCAX_STATE_IDLE)
        {
            hr = PlacePendingCall();
        }

    }

    LOG((RTC_TRACE, "CMainFrm::OnUpdateState - exit"));

    return 0;
}

LRESULT CMainFrm::OnCoreEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT     hr;

    //LOG((RTC_TRACE, "CMainFrm::OnCoreEvent - enter"));
    
    RTC_EVENT enEvent = (RTC_EVENT)wParam;
    IDispatch * pEvent = (IDispatch *)lParam;

    CComQIPtr<IRTCMediaEvent, &IID_IRTCMediaEvent>
            pRTCRTCMediaEvent;
    CComQIPtr<IRTCBuddyEvent, &IID_IRTCBuddyEvent>
            pRTCRTCBuddyEvent;
    CComQIPtr<IRTCWatcherEvent, &IID_IRTCWatcherEvent>
            pRTCRTCWatcherEvent;

    switch(enEvent)
    {
    case RTCE_MEDIA:
        pRTCRTCMediaEvent = pEvent;
        hr = OnMediaEvent(pRTCRTCMediaEvent);
        break;
    
    case RTCE_BUDDY:
        pRTCRTCBuddyEvent = pEvent;
        hr = OnBuddyEvent(pRTCRTCBuddyEvent);
        break;
    
    case RTCE_WATCHER:
        pRTCRTCWatcherEvent = pEvent;
        hr = OnWatcherEvent(pRTCRTCWatcherEvent);
        break;
    }

    //LOG((RTC_TRACE, "CMainFrm::OnCoreEvent - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::OnMediaEvent(IRTCMediaEvent * pEvent)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CMainFrm::OnMediaEvent - enter"));

    RTC_MEDIA_EVENT_TYPE enEventType;
    LONG        lMediaType;           

    if(!pEvent)
    {
        LOG((RTC_ERROR, "CMainFrm::OnMediaEvent, no interface ! - exit"));
        return E_UNEXPECTED;
    }
 
    // grab the event components
    //
    hr = pEvent->get_EventType(&enEventType);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnMediaEvent, error <%x> in get_EventType - exit", hr));
        return hr;
    }

    hr = pEvent->get_MediaType(&lMediaType);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnMediaEvent, error <%x> in get_MediaType - exit", hr));
        return hr;
    }
    
    LOG((RTC_TRACE, "CMainFrm::OnMediaEvent - media type %x, event type %x", lMediaType, enEventType));

    if(lMediaType & RTCMT_AUDIO_SEND)
    {
        hr = S_OK;                       

        if (enEventType == RTCMET_STARTED)
        {
            //
            // Enable the dialpad
            //

            m_hKeypad0.EnableWindow(TRUE);
            m_hKeypad1.EnableWindow(TRUE);
            m_hKeypad2.EnableWindow(TRUE);
            m_hKeypad3.EnableWindow(TRUE);
            m_hKeypad4.EnableWindow(TRUE);
            m_hKeypad5.EnableWindow(TRUE);
            m_hKeypad6.EnableWindow(TRUE);
            m_hKeypad7.EnableWindow(TRUE);
            m_hKeypad8.EnableWindow(TRUE);
            m_hKeypad9.EnableWindow(TRUE);
            m_hKeypadStar.EnableWindow(TRUE);
            m_hKeypadPound.EnableWindow(TRUE);
        }
        else if (enEventType == RTCMET_STOPPED)
        {
            //
            // Disable the dialpad
            //

            m_hKeypad0.EnableWindow(FALSE);
            m_hKeypad1.EnableWindow(FALSE);
            m_hKeypad2.EnableWindow(FALSE);
            m_hKeypad3.EnableWindow(FALSE);
            m_hKeypad4.EnableWindow(FALSE);
            m_hKeypad5.EnableWindow(FALSE);
            m_hKeypad6.EnableWindow(FALSE);
            m_hKeypad7.EnableWindow(FALSE);
            m_hKeypad8.EnableWindow(FALSE);
            m_hKeypad9.EnableWindow(FALSE);
            m_hKeypadStar.EnableWindow(FALSE);
            m_hKeypadPound.EnableWindow(FALSE);
        }
    }

    //
    // Are we streaming video?
    //

    if (m_pClientIntf != NULL)
    {
        long lMediaTypes = 0;

        hr = m_pClientIntf->get_ActiveMedia( &lMediaTypes );

        if ( SUCCEEDED(hr) )
        {
            m_bBackgroundPalette = 
                ( lMediaTypes & (RTCMT_VIDEO_SEND | RTCMT_VIDEO_RECEIVE) ) ? TRUE : FALSE;

            if (m_pControlIntf != NULL)
            {
                m_pControlIntf->put_BackgroundPalette( m_bBackgroundPalette );
            }
        }        
    }

    LOG((RTC_TRACE, "CMainFrm::OnMediaEvent - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::OnBuddyEvent(IRTCBuddyEvent * pEvent)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CMainFrm::OnBuddy - enter"));

    IRTCBuddy *pBuddy;
    
    if(!pEvent)
    {
        LOG((RTC_ERROR, "CMainFrm::OnBuddy, no interface ! - exit"));
        return E_UNEXPECTED;
    }
 
    // grab the event components
    //
    hr = pEvent->get_Buddy(&pBuddy);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnBuddy, error <%x> in get_Buddy - exit", hr));
        return hr;
    }

    if(pBuddy)
	{
		UpdateBuddyImageAndText(pBuddy);
	}

    RELEASE_NULLIFY(pBuddy);
    
    LOG((RTC_TRACE, "CMainFrm::OnBuddy - exit"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::UpdateBuddyImageAndText(
    IRTCBuddy  *pBuddy)
{
    HRESULT     hr;

    LVFINDINFO  lf = {0};

    lf.flags = LVFI_PARAM;
    lf.lParam = (LPARAM)pBuddy;

    int iItem;

    iItem = ListView_FindItem(m_hBuddyList, -1, &lf);
    if(iItem>=0)
    {
        //
        // Get the UI icon and text
        //
        
        int     iImage = ILI_BL_OFFLINE;    // XXX should we use "error" here ?
        BSTR    bstrName = NULL;

        hr = GetBuddyTextAndIcon(
                pBuddy,
                &iImage,
                &bstrName);

        if(SUCCEEDED(hr))
        {
            LVITEM              lv = {0};
 
            //
            // Change the contact in the list box
            //
 
            lv.mask = LVIF_TEXT | LVIF_IMAGE;
            lv.iItem = iItem;
            lv.iSubItem = 0;
            lv.iImage = iImage;
            lv.pszText = bstrName;

            ListView_SetItem(m_hBuddyList, &lv);

            SysFreeString( bstrName );
        }
        else
        {
            LOG((RTC_ERROR, "CMainFrm::UpdateBuddyImageAndText - "
                "GetBuddyTextAndIcon failed with error %x", hr));
        }
    }
    else
    {
           LOG((RTC_ERROR, "CMainFrm::UpdateBuddyImageAndText - "
               "Couldn't find the buddy in the contact list box"));
    }

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::OnWatcherEvent(IRTCWatcherEvent * pEvent)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CMainFrm::OnWatcherEvent - enter"));

    IRTCWatcher        * pWatcher = NULL;
    IRTCClientPresence * pClientPresence = NULL;
    
    if(!pEvent)
    {
        LOG((RTC_ERROR, "CMainFrm::OnWatcherEvent, no interface ! - exit"));
        return E_UNEXPECTED;
    }
 
    // grab the event components
    //
    hr = pEvent->get_Watcher(&pWatcher);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnWatcherEvent - "
                "error <%x> in get_Watcher, exit", hr));

        return hr;
    }
    
    hr = m_pClientIntf->QueryInterface(
        IID_IRTCClientPresence,
        (void **)&pClientPresence);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CMainFrm::OnWatcherEvent - "
                    "error (%x) returned by QI, exit", hr));

        RELEASE_NULLIFY(pWatcher);

        return hr;
    }

    //
    // Prepare the UI
    // 
    
    COfferWatcherDlgParam  Param;

    ZeroMemory(&Param, sizeof(Param));
    
    hr = pWatcher->get_PresentityURI(&Param.bstrPresentityURI);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnWatcherEvent - "
              "get_PresentityURI failed with error %x", hr));
    }

    hr = pWatcher->get_Name(&Param.bstrDisplayName);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnWatcherEvent - "
              "get_Name failed with error %x", hr));
    }

    COfferWatcherDlg        dlg;

    INT_PTR iRet = dlg.DoModal(m_hWnd, reinterpret_cast<LPARAM>(&Param));
    
    if (iRet == S_OK)
    {
        if (Param.bAllowWatcher)
        {
            hr = pWatcher->put_State(RTCWS_ALLOWED);
            
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CMainFrm::OnWatcherEvent - "
                            "put_State failed with error %x", hr));
            }
        }
        else
        {
            hr = pWatcher->put_State(RTCWS_BLOCKED);
            
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CMainFrm::OnWatcherEvent - "
                            "put_State failed with error %x", hr));
            }
        }

        if (Param.bAddBuddy)
        {
            hr = pClientPresence->AddBuddy( 
                        Param.bstrPresentityURI,
                        Param.bstrDisplayName,
                        NULL,
                        VARIANT_TRUE,
                        NULL,
                        0,
                        NULL
                        );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CMainFrm::OnWatcherEvent - "
                            "AddBuddy failed with error %x", hr));
            }
            else
            {
                ReleaseBuddyList();
                UpdateBuddyList();
            }
        }
    }
    else
    {
        hr = pClientPresence->RemoveWatcher( pWatcher );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CMainFrm::OnWatcherEvent - "
                        "RemoveWatcher failed with error %x", hr));
        }
    }

    RELEASE_NULLIFY(pWatcher);

    RELEASE_NULLIFY(pClientPresence);

    SysFreeString(Param.bstrDisplayName);
    SysFreeString(Param.bstrPresentityURI);

    LOG((RTC_TRACE, "CMainFrm::OnWatcherEvent - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    //LOG((RTC_TRACE, "CMainFrm::OnTimer - enter"));

    switch(wParam)
    {
    case TID_CALL_TIMER:

        // the GetTickCount() - m_dwTickCount difference wraps up after 49.7 days.
        //     
        SetTimeStatus(TRUE, (GetTickCount() - m_dwTickCount)/1000);

        break;
    
    case TID_MESSAGE_TIMER:

        // Clear the timer area
        //
        ClearCallTimer();

        // Set a redundant IDLE stae, it will clear any existing error message
        //
        if(m_pControlIntf)
        {
            m_pControlIntf->put_ControlState(RTCAX_STATE_IDLE);
        }

        KillTimer(TID_MESSAGE_TIMER);

        m_bMessageTimerActive = FALSE;

        break;

    case TID_BROWSER_RETRY_TIMER:
        {
            HRESULT hr;            

            hr = BrowseToUrl( m_bstrLastBrowse );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CMainFrm::OnTimer - "
                                "BrowseToURL failed - "
                                "exit 0x%08x", hr));

                return hr;
            } 
        }
        break;
    case TID_DBLCLICK_TIMER:
        {
            // Forward the message to the ShellNotify handler. 
            OnShellNotify(uMsg, TID_DBLCLICK_TIMER, WM_TIMER, bHandled);
        }
        break;

    case TID_KEYPAD_TIMER_BASE:
    case TID_KEYPAD_TIMER_BASE + 1:
    case TID_KEYPAD_TIMER_BASE + 2:
    case TID_KEYPAD_TIMER_BASE + 3:
    case TID_KEYPAD_TIMER_BASE + 4:
    case TID_KEYPAD_TIMER_BASE + 5:
    case TID_KEYPAD_TIMER_BASE + 6:
    case TID_KEYPAD_TIMER_BASE + 7:
    case TID_KEYPAD_TIMER_BASE + 8:
    case TID_KEYPAD_TIMER_BASE + 9:
    case TID_KEYPAD_TIMER_BASE + 10:
    case TID_KEYPAD_TIMER_BASE + 11:
        
        // depress the dialpad button
        ::SendMessage(GetDlgItem(ID_KEYPAD0 + (wParam - TID_KEYPAD_TIMER_BASE)) ,
            BM_SETSTATE, (WPARAM)FALSE, 0);
        KillTimer((UINT)wParam);
        break;
    }
    

    //LOG((RTC_TRACE, "CMainFrm::OnTimer - exit"));

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnSettingChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnSettingChange - enter"));

    //
    // Check if there is a locale-related change ...
    // 

    if(wParam == 0 && lParam != NULL && _tcscmp((TCHAR *)lParam, _T("intl"))==0)
    {
        // Update the info
        UpdateLocaleInfo();

        // clear any call timer, it will be displayed 
        // next time with the new format
        ClearCallTimer();
    }

    //
    // ... or a change of appearance
    // 

    else if (wParam == SPI_SETNONCLIENTMETRICS)
    {
        //
        // Cancel any menu
        //

        SendMessage(WM_CANCELMODE);

        //
        // Update all the controls with the new fonts
        //

        SendMessageToDescendants(uMsg, wParam, lParam, TRUE);
    }

    LOG((RTC_TRACE, "CMainFrm::OnSettingChange - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnSysColorChange - enter"));

    //
    // Send it to the children
    // 
    SendMessageToDescendants(uMsg, wParam, lParam, TRUE);
    
    LOG((RTC_TRACE, "CMainFrm::OnSysColorChange - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnInitMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnInitMenu"));
    
    HMENU hmenu = (HMENU)wParam;

    //always gray out
    EnableMenuItem(hmenu,SC_SIZE,    MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenu,SC_MAXIMIZE,MF_BYCOMMAND|MF_GRAYED);

    //always enable
    EnableMenuItem(hmenu,SC_CLOSE,MF_BYCOMMAND|MF_ENABLED);

    //enable or gray based on minimize state
    if (IsIconic())
    {
        EnableMenuItem(hmenu,SC_RESTORE, MF_BYCOMMAND|MF_ENABLED);
        EnableMenuItem(hmenu,SC_MOVE,    MF_BYCOMMAND|MF_GRAYED);
        EnableMenuItem(hmenu,SC_MINIMIZE,MF_BYCOMMAND|MF_GRAYED);
    }
    else
    {
        EnableMenuItem(hmenu,SC_RESTORE, MF_BYCOMMAND|MF_GRAYED);
        EnableMenuItem(hmenu,SC_MOVE,    MF_BYCOMMAND|MF_ENABLED);
        EnableMenuItem(hmenu,SC_MINIMIZE,MF_BYCOMMAND|MF_ENABLED);
    }
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnInitMenuPopup(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnInitMenuPopup - enter"));
    
    if(m_pClientIntf != NULL && 
       HIWORD(lParam) == FALSE &&                // main menu
       LOWORD(lParam) == IDM_POPUP_TOOLS &&     // Tools submenu
       m_nState != RTCAX_STATE_ERROR)
    {
        HRESULT     hr;
        LONG        lMediaCapabilities;
        LONG        lMediaPreferences;
        DWORD       dwVideoPreview;

        // read capabilities from core
        //
        hr = m_pClientIntf -> get_MediaCapabilities(&lMediaCapabilities);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CMainFrm::OnInitMenuPopup - "
                "error (%x) returned by get_MediaCapabilities, exit", hr));
        
            EnableMenuItem(m_hMenu, IDM_TOOLS_INCOMINGVIDEO, MF_GRAYED);
            EnableMenuItem(m_hMenu, IDM_TOOLS_OUTGOINGVIDEO, MF_GRAYED);
            EnableMenuItem(m_hMenu, IDM_TOOLS_VIDEOPREVIEW, MF_GRAYED);
            EnableMenuItem(m_hMenu, IDM_TOOLS_MUTE_SPEAKER, MF_GRAYED);
            EnableMenuItem(m_hMenu, IDM_TOOLS_MUTE_MICROPHONE, MF_GRAYED);
        
            return 0;
        }
        
        // read current preferences
        //
        hr = m_pClientIntf -> get_PreferredMediaTypes(&lMediaPreferences);
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CMainFrm::OnInitMenuPopup - "
                "error (%x) returned by get_PreferredMediaTypes, exit", hr));
        
            EnableMenuItem(m_hMenu, IDM_TOOLS_INCOMINGVIDEO, MF_GRAYED);
            EnableMenuItem(m_hMenu, IDM_TOOLS_OUTGOINGVIDEO, MF_GRAYED);
            EnableMenuItem(m_hMenu, IDM_TOOLS_VIDEOPREVIEW, MF_GRAYED);
            EnableMenuItem(m_hMenu, IDM_TOOLS_MUTE_SPEAKER, MF_GRAYED);
            EnableMenuItem(m_hMenu, IDM_TOOLS_MUTE_MICROPHONE, MF_GRAYED);
        
            return 0;
        }

        // get the video preview preference
        dwVideoPreview = (DWORD)TRUE;

        hr = get_SettingsDword(SD_VIDEO_PREVIEW, &dwVideoPreview);
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CMainFrm::OnInitMenuPopup - "
                "error (%x) returned by get_SettingsDword(SD_VIDEO_PREVIEW)", hr));
        }
        
        // Enable/disable the menu items based on capabilities
        //

        EnableMenuItem(m_hMenu, IDM_TOOLS_INCOMINGVIDEO, 
            (lMediaCapabilities & RTCMT_VIDEO_RECEIVE) ? MF_ENABLED : MF_GRAYED);
        CheckMenuItem(m_hMenu,  IDM_TOOLS_INCOMINGVIDEO,
            (lMediaPreferences & RTCMT_VIDEO_RECEIVE) ? MF_CHECKED : MF_UNCHECKED);
        
        EnableMenuItem(m_hMenu, IDM_TOOLS_OUTGOINGVIDEO, 
            (lMediaCapabilities & RTCMT_VIDEO_SEND) ? MF_ENABLED : MF_GRAYED);
        CheckMenuItem(m_hMenu,  IDM_TOOLS_OUTGOINGVIDEO,
            (lMediaPreferences & RTCMT_VIDEO_SEND) ? MF_CHECKED : MF_UNCHECKED);
        
        BOOL    bPreviewPossible =
            ((lMediaCapabilities & RTCMT_VIDEO_SEND) 
         &&  (lMediaPreferences & RTCMT_VIDEO_SEND));
        
        EnableMenuItem(m_hMenu, IDM_TOOLS_VIDEOPREVIEW, 
            bPreviewPossible ? MF_ENABLED : MF_GRAYED);

        CheckMenuItem(m_hMenu,  IDM_TOOLS_VIDEOPREVIEW,
            bPreviewPossible && dwVideoPreview ? MF_CHECKED : MF_UNCHECKED);
        
        EnableMenuItem(m_hMenu, IDM_TOOLS_MUTE_SPEAKER, 
            (lMediaCapabilities & RTCMT_AUDIO_RECEIVE) ? MF_ENABLED : MF_GRAYED);
        
        EnableMenuItem(m_hMenu, IDM_TOOLS_MUTE_MICROPHONE, 
            (lMediaCapabilities & RTCMT_AUDIO_SEND) ? MF_ENABLED : MF_GRAYED);


        // read mute status
        //
        VARIANT_BOOL    bMuted;

        if(lMediaCapabilities & RTCMT_AUDIO_RECEIVE)
        {
            hr = m_pClientIntf -> get_AudioMuted(RTCAD_SPEAKER, &bMuted);

            if(SUCCEEDED(hr))
            {
                CheckMenuItem(m_hMenu,  IDM_TOOLS_MUTE_SPEAKER,
                    bMuted ? MF_CHECKED : MF_UNCHECKED);

            }
            else
            {
                LOG((RTC_ERROR, "CMainFrm::OnInitMenuPopup - "
                    "error (%x) returned by get_AudioMuted(speaker)", hr));
        
                EnableMenuItem(m_hMenu, IDM_TOOLS_MUTE_SPEAKER, MF_GRAYED);
            }
        }

        if(lMediaCapabilities & RTCMT_AUDIO_SEND)
        {
            hr = m_pClientIntf -> get_AudioMuted(RTCAD_MICROPHONE, &bMuted);

            if(SUCCEEDED(hr))
            {
                CheckMenuItem(m_hMenu,  IDM_TOOLS_MUTE_MICROPHONE,
                    bMuted ? MF_CHECKED : MF_UNCHECKED);

            }
            else
            {
                LOG((RTC_ERROR, "CMainFrm::OnInitMenuPopup - "
                    "error (%x) returned by get_AudioMuted(microphone)", hr));
        
                EnableMenuItem(m_hMenu, IDM_TOOLS_MUTE_MICROPHONE, MF_GRAYED);
            }
        }
  
    }
    else
    {
        bHandled = FALSE;
    }
    
    LOG((RTC_TRACE, "CMainFrm::OnInitMenuPopup - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnMeasureItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // LOG((RTC_TRACE, "CMainFrm::OnMeasureItem - enter"));

    LPMEASUREITEMSTRUCT lpmis = (LPMEASUREITEMSTRUCT)lParam;

    if((wParam == 0) && (lpmis->itemID >= IDM_REDIAL) && (lpmis->itemID <= IDM_REDIAL_MAX))
    {
        //LOG((RTC_INFO, "CMainFrm::OnMeasureItem - "
        //    "IDM_REDIAL+%d", lpmis->itemID - IDM_REDIAL));

        lpmis->itemWidth = BITMAPMENU_DEFAULT_WIDTH + 2;
        lpmis->itemHeight = BITMAPMENU_DEFAULT_HEIGHT + 2;

        MENUITEMINFO mii;

        ZeroMemory( &mii, sizeof(MENUITEMINFO) );
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_TYPE;

        BOOL fResult;

        fResult = GetMenuItemInfo( m_hRedialPopupMenu, lpmis->itemID, FALSE, &mii );

        if ( fResult == FALSE )
        {           
            LOG((RTC_ERROR, "CMainFrm::OnMeasureItem - "
                "GetMenuItemInfo failed %d", GetLastError() ));
        }
        else
        {
            if (mii.cch == 0)
            {           
                LOG((RTC_ERROR, "CMainFrm::OnMeasureItem - "
                    "no string"));
            }
            else             
            {
                LPTSTR szText = (LPTSTR)RtcAlloc((mii.cch+1)*sizeof(TCHAR));
                
                if(szText)
                {
                    ZeroMemory(szText,(mii.cch+1)*sizeof(TCHAR));

                    GetMenuString( m_hRedialPopupMenu, lpmis->itemID, szText, mii.cch+1, MF_BYCOMMAND );

                    HWND hwnd = ::GetDesktopWindow();
                    HDC hdc = ::GetDC(hwnd);

                    if ( hdc == NULL )
                    {           
                        LOG((RTC_ERROR, "OnSettingChange::OnMeasureItem - "
                            "GetDC failed %d", GetLastError() ));
                    }
                    else
                    {
                        // Use the SystemParametersInfo function to get info about
                        // the current menu font.

                        NONCLIENTMETRICS ncm;
                        ncm.cbSize = sizeof(NONCLIENTMETRICS);
                        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS),(void*)&ncm, 0);

                        // Create a font based on the menu font and select it
                        // into our device context.

                        HFONT hFont;
                        hFont = ::CreateFontIndirect(&(ncm.lfMenuFont));

                        if ( hFont != NULL )
                        {
                            HFONT hOldFont = (HFONT)::SelectObject(hdc,hFont);

                            // Get the size of the text based on the current menu font.
                            if (szText)
                            {
                              SIZE size;
                              GetTextExtentPoint32(hdc,szText,_tcslen(szText),&size);

                              lpmis->itemWidth = size.cx + BITMAPMENU_TEXTOFFSET_X;
                              lpmis->itemHeight = (ncm.iMenuHeight > BITMAPMENU_DEFAULT_HEIGHT + 2
                                                    ? ncm.iMenuHeight + 2 : BITMAPMENU_DEFAULT_HEIGHT + 2);

                              // Look for tabs in menu item...
                              if ( _tcschr(szText, _T('\t')) )
                                lpmis->itemWidth += BITMAPMENU_TABOFFSET * 2;
                            }

                            // Reset the device context.
                            ::SelectObject(hdc,hOldFont);

                            //
                            // We should delete the resource hFont
                            //
                            ::DeleteObject( hFont );
                        }
                        ::ReleaseDC(hwnd,hdc);
                    }

                    RtcFree( szText );
                }
            }
        }
    }
    
    //LOG((RTC_TRACE, "CMainFrm::OnMeasureItem - exit"));

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnPlaceCall(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    BSTR bstrCallStringCopy = (BSTR)lParam;
    HRESULT hr;
    int nResult;

    LOG((RTC_TRACE, "CMainFrm::OnPlaceCall: Entered"));

    static LONG s_lInProgress = 0;

    if ( InterlockedExchange( &s_lInProgress, 1 ) == 1 )
    {
        LOG((RTC_WARN, "CMainFrm::OnPlaceCall: Another PlaceCall in progress"));
    }
    else
    {
        LOG((RTC_TRACE, "CMainFrm::OnPlaceCall: CallString is %S", bstrCallStringCopy));

        // Incoming bstr has been allocated for us and we have to free it before 
        // leaving this function if we haven't queued it for future calling.

        // Check if the current state is such that we can place a call..

        if ( m_pControlIntf == NULL || m_nState < RTCAX_STATE_IDLE )

        {
            // It is in initialization state.. but can't place a call.
            nResult = DisplayMessage(
                        _Module.GetResourceInstance(),
                        m_hWnd,
                        IDS_MESSAGE_CANTCALLINIT,
                        IDS_APPNAME,
                        MB_OK | MB_ICONEXCLAMATION);
        
            ::SysFreeString(bstrCallStringCopy);
        
            InterlockedExchange( &s_lInProgress, 0 );

            return E_FAIL;
        }

        if ((m_nState == RTCAX_STATE_UI_BUSY) ||
            (m_nState == RTCAX_STATE_DIALING) ||
            (m_nState == RTCAX_STATE_ALERTING)
           )

        {
            // It is busy with another dialog popped up.. can't place call.
            nResult = DisplayMessage(
                        _Module.GetResourceInstance(),
                        m_hWnd,
                        IDS_MESSAGE_CANTCALLBUSY,
                        IDS_APPNAME,
                        MB_OK | MB_ICONEXCLAMATION);
        
            ::SysFreeString(bstrCallStringCopy);
        
            InterlockedExchange( &s_lInProgress, 0 );

            return E_FAIL;
        }
        else if (
                    (m_nState == RTCAX_STATE_CONNECTING)    ||
                    (m_nState == RTCAX_STATE_CONNECTED)     ||
                    (m_nState == RTCAX_STATE_ANSWERING) 
                )

        {
            // It is in a call, so we can't place a call.without hanging the current

            nResult = DisplayMessage(
                        _Module.GetResourceInstance(),
                        m_hWnd,
                        IDS_MESSAGE_SHOULDHANGUP,
                        IDS_APPNAME,
                        MB_OKCANCEL | MB_ICONEXCLAMATION);

        
            if (nResult == IDOK)
            {
                // User wants to drop the current call, so do it. 
                // But the call may have been dropped in this time by the other
                // party. SO the new state can either be idle or disconnecting. 
                // In this case, we check if it is already idle, we need not call
                // hangup, we can place the call right then. If it is disconnecting
                // we queue the call.

                // I can't do anything if some dialog has popped up, so I am skipping
                // this test for m_bFramseIsBusy.


            
                if  (
                    (m_nState == RTCAX_STATE_CONNECTING)    ||
                    (m_nState == RTCAX_STATE_CONNECTED)     ||
                    (m_nState == RTCAX_STATE_ANSWERING) 
                    )
                {
                    // These states are safe for hangup, so go ahead and do it.
                    m_pControlIntf->HangUp();
                }

                // We reach here, either when we called hangup, or when the state
                // changed while we were in that dialog; in either case, processing
                // is same. 

                // Check if the state is idle now..
                if (m_nState == RTCAX_STATE_IDLE)
                {
                    hr = ParseAndPlaceCall(m_pControlIntf, bstrCallStringCopy);
                    ::SysFreeString(bstrCallStringCopy);
                    if ( FAILED( hr ) )
                    {
                        LOG((RTC_ERROR, "CMainFrm::OnPlaceCall: Failed to place call(hr=0x%x)", hr));

                        InterlockedExchange( &s_lInProgress, 0 );

                        return hr;
                    }
                }
                else
                {
                    // Queue the call, so that it can be placed later. 
                    // We do not need to check if a call has already been queued
                    // it will never be, since there can't be a queued call when 
                    // a call is on.

                    SetPendingCall(bstrCallStringCopy);

                    LOG((RTC_INFO, "CMainFrm::OnPlaceCall: Call queued. (string=%S)",
                                    bstrCallStringCopy));
                }

            }
            else
            {
                // User pressed cancel.
                // We need to free the copy of the string 
                ::SysFreeString(bstrCallStringCopy);
            }

        }
        else if (m_nState == RTCAX_STATE_IDLE)
        {
            // We can place the call right now.

            hr = ParseAndPlaceCall(m_pControlIntf, bstrCallStringCopy);
        
            ::SysFreeString(bstrCallStringCopy);
    
            if ( FAILED( hr ) )
            {
                LOG((RTC_ERROR, "CMainFrm::OnPlaceCall: Failed to place call(hr=0x%x)", hr));

                InterlockedExchange( &s_lInProgress, 0 );

                return hr;
            }

        }
        else if (m_nState == RTCAX_STATE_DISCONNECTING)
        {
            // We can place the call, but later, no need to show UI
            // We just update m_bstrCallParam
        
            // We show the UI if their is already a pending call and we
            // can't fulfil the current request.

            if (m_bstrCallParam != NULL)
            {
                nResult = DisplayMessage(
                            _Module.GetResourceInstance(),
                            m_hWnd,
                            IDS_MESSAGE_CANTCALL,
                            IDS_APPNAME,
                            MB_OK | MB_ICONEXCLAMATION);

                ::SysFreeString(bstrCallStringCopy);

                InterlockedExchange( &s_lInProgress, 0 );

                return E_FAIL;
            }
            else
            {

                SetPendingCall(bstrCallStringCopy);

                LOG((RTC_INFO, "CMainFrm::OnPlaceCall: Call queued. (string=%S)",
                                bstrCallStringCopy));

            }

        }

        InterlockedExchange( &s_lInProgress, 0 );
    }

    LOG((RTC_TRACE, "CMainFrm::OnPlaceCall: Exited"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnInitCompleted(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr;

    LOG((RTC_TRACE, "CMainFrm::OnInitCompleted: Entered"));
    
    // This message is processed right after InitDialog, so anything that should be 
    // done after init will be done here.

    // Check if we have to place a call that was passed to us on command line. 

    // Update the flag to TRUE

    m_fInitCompleted = TRUE;

    //
    // If m_pControlIntf is NULL, the RTC AXCTL couldn't be instantiated
    //
    
    if(!m_pControlIntf)
    {
        DisplayMessage(
            _Module.GetResourceInstance(),
            m_hWnd,
            IDS_MESSAGE_AXCTL_NOTFOUND,
            IDS_APPNAME,
            MB_OK | MB_ICONSTOP);
    }
    
    // AXCTL initialization failed. Display a generic error for now
    //
    else if (m_nState == RTCAX_STATE_ERROR)
    {
        DisplayMessage(
            _Module.GetResourceInstance(),
            m_hWnd,
            IDS_MESSAGE_AXCTL_INIT_FAILED,
            IDS_APPNAME,
            MB_OK | MB_ICONSTOP);
    }

    // Place the call if the current state is idle. 
    if (m_nState == RTCAX_STATE_IDLE)
    {
        hr = PlacePendingCall();
    }

    LOG((RTC_TRACE, "CMainFrm::OnInitCompleted: Exited"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//
void FillSolidRect(HDC hdc,int x, int y, int cx, int cy, COLORREF clr)
{
    ::SetBkColor(hdc, clr);
    RECT rect;
    rect.left = x;
    rect.top = y;
    rect.right = x + cx;
    rect.bottom = y + cy;
    ::ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
}

/////////////////////////////////////////////////////////////////////////////
//
//
void Draw3dRect(HDC hdc,int x, int y, int cx, int cy,
    COLORREF clrTopLeft, COLORREF clrBottomRight)
{
    FillSolidRect(hdc,x, y, cx - 1, 1, clrTopLeft);
    FillSolidRect(hdc,x, y, 1, cy - 1, clrTopLeft);
    FillSolidRect(hdc,x + cx, y, -1, cy, clrBottomRight);
    FillSolidRect(hdc,x, y + cy, cx, -1, clrBottomRight);
}

/////////////////////////////////////////////////////////////////////////////
//
//
void Draw3dRect(HDC hdc,RECT* lpRect,COLORREF clrTopLeft, COLORREF clrBottomRight)
{
    Draw3dRect(hdc,lpRect->left, lpRect->top, lpRect->right - lpRect->left,
        lpRect->bottom - lpRect->top, clrTopLeft, clrBottomRight);
}

////////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrm::OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    //LOG((RTC_TRACE, "CMainFrm::OnDrawItem - enter"));

    LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT)lParam;

    if (wParam == 0)
    {
        //
        // This was send by a menu
        //

        if ((lpdis->itemID >= IDM_REDIAL) && (lpdis->itemID <= IDM_REDIAL_MAX))
        {
            // LOG((RTC_TRACE, "CMainFrm::OnDrawItem - "
            //    "IDM_REDIAL+%d", lpdis->itemID - IDM_REDIAL));

            if (m_hPalette)
            {
                SelectPalette(lpdis->hDC, m_hPalette, m_bBackgroundPalette);
                RealizePalette(lpdis->hDC);
            }

            MENUITEMINFO mii;

            ZeroMemory( &mii, sizeof(MENUITEMINFO) );
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_TYPE;

            BOOL fResult;

            fResult = GetMenuItemInfo( m_hRedialPopupMenu, lpdis->itemID, FALSE, &mii );

            if ( fResult == FALSE )
            {           
                LOG((RTC_ERROR, "CMainFrm::OnDrawItem - "
                    "GetMenuItemInfo failed %d", GetLastError() ));
            }
            else
            {
                LPTSTR szText = NULL;

                if (mii.cch == 0)
                {           
                    LOG((RTC_ERROR, "CMainFrm::OnDrawItem - "
                        "no string"));
                }
                else             
                {
                    szText = (LPTSTR)RtcAlloc((mii.cch+1)*sizeof(TCHAR)); 

                    if (szText != NULL)
                    {
                        ZeroMemory(szText,(mii.cch+1)*sizeof(TCHAR));

                        GetMenuString( m_hRedialPopupMenu, lpdis->itemID, szText, mii.cch+1, MF_BYCOMMAND );
                    }
                }

                RTC_ADDRESS_TYPE enType;
                IRTCAddress * pAddress = (IRTCAddress *)lpdis->itemData;

                if ( pAddress != NULL )
                {
                    pAddress->get_Type( &enType );
                }

                HDC hdc = lpdis->hDC;

                if ((lpdis->itemState & ODS_SELECTED) &&
                    (lpdis->itemAction & (ODA_SELECT | ODA_DRAWENTIRE)))
                {
                    if ( pAddress != NULL )
                    {
                        // item has been selected - hilite frame
                        if ((lpdis->itemState & ODS_DISABLED) == FALSE)
                        {
                            RECT rcImage;
                            rcImage.left = lpdis->rcItem.left;
                            rcImage.top = lpdis->rcItem.top;
                            rcImage.right = lpdis->rcItem.left+BITMAPMENU_SELTEXTOFFSET_X;
                            rcImage.bottom = lpdis->rcItem.bottom;
                            Draw3dRect(hdc,&rcImage,GetSysColor(COLOR_BTNHILIGHT),GetSysColor(COLOR_BTNSHADOW));
                        }
                    }

                    RECT rcText;
                    ::CopyRect(&rcText,&lpdis->rcItem);
                    rcText.left += BITMAPMENU_SELTEXTOFFSET_X;

                    ::SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                    ::ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcText, NULL, 0, NULL);
                }

                if (!(lpdis->itemState & ODS_SELECTED) &&
                    (lpdis->itemAction & ODA_SELECT))
                {
                    // Item has been de-selected -- remove frame
                    ::SetBkColor(hdc, GetSysColor(COLOR_MENU));
                    ::ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &lpdis->rcItem, NULL, 0, NULL);
                }

                if ( (lpdis->itemAction & ODA_DRAWENTIRE) ||
                     (lpdis->itemAction & ODA_SELECT) )
                {
                    if ( pAddress != NULL )
                    {
                        if (lpdis->itemState & ODS_DISABLED)
                        {
                            if ( (m_hRedialDisabledImageList != NULL) )
                            {
                                ImageList_Draw(m_hRedialDisabledImageList,
                                               enType,
                                               hdc,
                                               lpdis->rcItem.left + 1,
                                               lpdis->rcItem.top + 1,
                                               ILD_TRANSPARENT);
                            }
                        }
                        else
                        {
                            if ( (m_hRedialImageList != NULL) )
                            {
                                ImageList_Draw(m_hRedialImageList,
                                               enType,
                                               hdc,
                                               lpdis->rcItem.left + 1,
                                               lpdis->rcItem.top + 1,
                                               ILD_TRANSPARENT);
                            }
                        }
                    }

                    RECT rcText;
                    ::CopyRect(&rcText,&lpdis->rcItem);
                    rcText.left += BITMAPMENU_TEXTOFFSET_X;

                    if (szText != NULL)
                    {
                        if (lpdis->itemState & ODS_DISABLED)
                        {
                            if (!(lpdis->itemState & ODS_SELECTED))
                            {
                                //Draw the text in white (or rather, the 3D highlight color) and then draw the
                                //same text in the shadow color but one pixel up and to the left.
                                ::SetTextColor(hdc,GetSysColor(COLOR_3DHIGHLIGHT));
                                rcText.left++;rcText.right++;rcText.top++;rcText.bottom++;

                                ::DrawText( hdc, szText, -1, &rcText, DT_SINGLELINE | DT_LEFT | DT_VCENTER | DT_EXPANDTABS );

                                rcText.left--;rcText.right--;rcText.top--;rcText.bottom--;
                            }

                            //DrawState() can do disabling of bitmap if this is desired
                            ::SetTextColor(hdc,GetSysColor(COLOR_3DSHADOW));
                            ::SetBkMode(hdc,TRANSPARENT);
                        }
                        else if (lpdis->itemState & ODS_SELECTED)
                        {
                            ::SetTextColor(hdc,GetSysColor(COLOR_HIGHLIGHTTEXT));
                        }
                        else
                        {
                            ::SetTextColor(hdc,GetSysColor(COLOR_MENUTEXT));
                        }

                        // Write menu, using tabs for accelerator keys
                        ::DrawText( hdc, szText, -1, &rcText, DT_SINGLELINE | DT_LEFT | DT_VCENTER | DT_EXPANDTABS);
                    }
                }

                if ( szText != NULL )
                {
                    RtcFree( szText );
                    szText = NULL;
                }
            }
        }
    }
    else
    {
        //
        // This was sent by a control
        // 

        if (lpdis->CtlType == ODT_BUTTON)
        {
            CButton::OnDrawItem(lpdis, m_hPalette, m_bBackgroundPalette);
        }
    }
    
    // LOG((RTC_TRACE, "CMainFrm::OnDrawItem - exit"));

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnColorTransparent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    return (LRESULT)GetStockObject( HOLLOW_BRUSH );
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    
    // LOG((RTC_TRACE, "CMainFrm::OnMenuSelect - enter"));
    
    // fake the IDM_REDIAL + xx ids to IDM_REDIAL
    // we don't want separate help strings for all the
    // redial addresses
    if ((HIWORD(wParam) & ( MF_SEPARATOR | MF_POPUP)) == 0 ) 
    {
        if(LOWORD(wParam)>=IDM_REDIAL && LOWORD(wParam)<=IDM_REDIAL_MAX)
        {
            wParam = MAKEWPARAM(IDM_REDIAL, HIWORD(wParam));
        }
    }

    //
    // Updates the status bar
    //

    if(!m_bHelpStatusDisabled)
    {
        if (HIWORD(wParam) == 0xFFFF)
        {
            //
            // Menu was closed, restore old text
            //

            // set the text
            m_hStatusText.SendMessage(
                WM_SETTEXT,
                (WPARAM)0,
                (LPARAM)m_szStatusText); 
        }
        else
        {
            HRESULT hr = MenuVerify((HMENU)lParam, LOWORD(wParam));

            if ( SUCCEEDED(hr) )
            {
                TCHAR * szStatusText;

                szStatusText = RtcAllocString( _Module.GetResourceInstance(), LOWORD(wParam) );

                if (szStatusText)
                {
                    // set the text
                    m_hStatusText.SendMessage(
                        WM_SETTEXT,
                        (WPARAM)0,
                        (LPARAM)szStatusText); 

                    RtcFree( szStatusText );
                }
            }
            else
            {
                // set the text
                m_hStatusText.SendMessage(
                    WM_SETTEXT,
                    (WPARAM)0,
                    (LPARAM)_T("")); 
            }
        }
    }
    
    // LOG((RTC_TRACE, "CMainFrm::OnMenuSelect - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::MenuVerify(HMENU hMenu, WORD wID)
{
    //go through all menu items, find the correct id
   UINT uMenuCount = ::GetMenuItemCount(hMenu);

   for (int i=0;i<(int)uMenuCount;i++)
   {
      MENUITEMINFO menuiteminfo;
      memset(&menuiteminfo,0,sizeof(MENUITEMINFO));
      menuiteminfo.fMask = MIIM_SUBMENU|MIIM_TYPE|MIIM_ID;
      menuiteminfo.cbSize = sizeof(MENUITEMINFO);
      if (::GetMenuItemInfo(hMenu,i,TRUE,&menuiteminfo))
      {   
         if ( menuiteminfo.wID == wID )
         {             
             // found a match

             if ( !(menuiteminfo.fType & MFT_SEPARATOR) ) // not a separator
             {
                 // success 
                 return S_OK;
             }
             else
             {                                           
                 return E_FAIL;
             }
         }

         if (menuiteminfo.hSubMenu)
         {
            //there is an submenu recurse in and look at that menu
            HRESULT hr = MenuVerify(menuiteminfo.hSubMenu, wID);

            if ( SUCCEEDED(hr) )
            {
                return S_OK;
            }
         }
      }
   }

   //we didn't find it
   return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::Call(BOOL bCallPhone,
                       BSTR pDestName,
                       BSTR pDestAddress,
                       BOOL bDestAddressEditable)
{
    HRESULT     hr;

    LOG((RTC_INFO, "CMainFrm::Call - enter"));

    ATLASSERT(m_pControlIntf.p);

    IRTCProfile * pProfile = NULL;
    IRTCPhoneNumber * pPhoneNumber = NULL;
    BSTR bstrPhoneNumber = NULL;
    BSTR bstrDestAddressChosen = NULL;

    hr = GetServiceProviderListSelection(
        m_hWnd,
        IDC_COMBO_SERVICE_PROVIDER,
        TRUE,
        &pProfile
        );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CMainFrm::Call - "
                    "GetServiceProviderListSelection failed 0x%x", hr ));

        return 0;
    }

    if (SendMessage(
                    m_hCallFromRadioPhone,
                    BM_GETCHECK,
                    0,
                    0) == BST_CHECKED)
    {
        hr = GetCallFromListSelection(
            m_hWnd,
            IDC_COMBO_CALL_FROM,
            TRUE,
            &pPhoneNumber
            );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CMainFrm::Call - "
                        "GetServiceProviderListSelection failed 0x%x", hr ));

            return hr;
        }

        hr = pPhoneNumber->get_Canonical( &bstrPhoneNumber );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CMainFrm::Call - "
                        "get_Canonical failed 0x%x", hr ));

            // continue
        }
    }

    hr = m_pControlIntf->Call(bCallPhone,           // bCallPhone
                              pDestName,            // pDestName
                              pDestAddress,         // pDestAddress
                              bDestAddressEditable, // bDestAddressEditable
                              bstrPhoneNumber,      // pLocalPhoneAddress,
                              TRUE,                 // bProfileSelected
                              pProfile,             // pProfile
                              &bstrDestAddressChosen// ppDestAddressChosen
                              );

    if ( bstrPhoneNumber != NULL )
    {
        SysFreeString(bstrPhoneNumber);
        bstrPhoneNumber = NULL;
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CMainFrm::Call - "
                    "m_pControlIntf->Call failed 0x%x", hr ));

        return hr;
    }

    // add to mru list
    IRTCAddress * pAddress = NULL;

    hr = CreateAddress( &pAddress );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "[%p] CMainFrm::Call: "
                "CreateAddress failed 0x%lx", this, hr));
    } 
    else
    {
        pAddress->put_Address( bstrDestAddressChosen );
        pAddress->put_Label( pDestName );
        pAddress->put_Type( bCallPhone ? RTCAT_PHONE : RTCAT_COMPUTER );

        hr = StoreMRUAddress( pAddress );

        RELEASE_NULLIFY(pAddress);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "[%p] CMainFrm::Call: "
                    "StoreMRUAddress failed 0x%lx", this, hr));
        }  
        
        CreateRedialPopupMenu();
    }

    if ( bstrDestAddressChosen != NULL )
    {
        SysFreeString(bstrDestAddressChosen);
        bstrDestAddressChosen = NULL;
    }
    
    LOG((RTC_INFO, "CMainFrm::Call - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::Message(
                       BSTR pDestName,
                       BSTR pDestAddress,
                       BOOL bDestAddressEditable)
{
    HRESULT     hr;

    LOG((RTC_INFO, "CMainFrm::Message - enter"));

    ATLASSERT(m_pControlIntf.p);

    BSTR bstrDestAddressChosen = NULL;

    hr = m_pControlIntf->Message(
                              pDestName,            // pDestName
                              pDestAddress,         // pDestAddress
                              bDestAddressEditable, // bDestAddressEditable   
                              &bstrDestAddressChosen// ppDestAddressChosen
                              );


    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CMainFrm::Message - "
                    "m_pControlIntf->Message failed 0x%x", hr ));

        return hr;
    }

    // add to mru list
    IRTCAddress * pAddress = NULL;

    hr = CreateAddress( &pAddress );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "[%p] CMainFrm::Message: "
                "CreateAddress failed 0x%lx", this, hr));
    } 
    else
    {
        pAddress->put_Address( bstrDestAddressChosen );
        pAddress->put_Label( pDestName );
        pAddress->put_Type( RTCAT_COMPUTER );

        hr = StoreMRUAddress( pAddress );

        RELEASE_NULLIFY(pAddress);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "[%p] CMainFrm::Message: "
                    "StoreMRUAddress failed 0x%lx", this, hr));
        } 
        
        CreateRedialPopupMenu();
    }

    if ( bstrDestAddressChosen != NULL )
    {
        SysFreeString(bstrDestAddressChosen);
        bstrDestAddressChosen = NULL;
    }
    
    LOG((RTC_INFO, "CMainFrm::Call - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnCallPC(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;

    LOG((RTC_INFO, "CMainFrm::OnCallPC - enter"));

    ShowWindow(SW_RESTORE);
    ::SetForegroundWindow(m_hWnd);

    hr = Call(FALSE,  // bCallPhone
              NULL,   // pDestName
              NULL,   // pDestAddress
              TRUE    // bDestAddressEditable
              );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CMainFrm::OnCallPC - "
                    "Call failed 0x%x", hr ));

        return 0;
    }
    
    LOG((RTC_INFO, "CMainFrm::OnCallPC - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnCallPhone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;

    LOG((RTC_INFO, "CMainFrm::OnCallPhone - enter"));

    ShowWindow(SW_RESTORE);
    ::SetForegroundWindow(m_hWnd);

    hr = Call(TRUE,   // bCallPhone
              NULL,   // pDestName
              NULL,   // pDestAddress
              TRUE    // bDestAddressEditable
              );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CMainFrm::OnCallPhone - "
                    "Call failed 0x%x", hr ));

        return 0;
    }
    
    LOG((RTC_INFO, "CMainFrm::OnCallPhone - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnMessage(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;

    LOG((RTC_INFO, "CMainFrm::OnMessage - enter"));

    ShowWindow(SW_RESTORE);
    ::SetForegroundWindow(m_hWnd);

    hr = Message(NULL,        // pDestName
                 NULL,        // pDestAddress
                 TRUE         // bDestAddressEditable
                 );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CMainFrm::OnMessage - "
                    "Call failed 0x%x", hr ));

        return 0;
    }
    
    LOG((RTC_INFO, "CMainFrm::OnMessage - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnHangUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;

    LOG((RTC_INFO, "CMainFrm::OnHangUp - enter"));

    ATLASSERT(m_pControlIntf.p);

    hr = m_pControlIntf->HangUp();
    
    LOG((RTC_INFO, "CMainFrm::OnHangUp - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnRedial(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;

    LOG((RTC_INFO, "CMainFrm::OnRedial - enter"));

    //
    // Create a popup menu for the MRU list
    //

    RECT        rc;
    TPMPARAMS   tpm;

    ::GetWindowRect(hWndCtl, &rc);                     

    tpm.cbSize = sizeof(TPMPARAMS);
    tpm.rcExclude.top    = rc.top;
    tpm.rcExclude.left   = rc.left;
    tpm.rcExclude.bottom = rc.bottom;
    tpm.rcExclude.right  = rc.right;       

    //
    // Show the menu
    //

    BOOL fResult;

    fResult = TrackPopupMenuEx(m_hRedialPopupMenu, TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_HORIZONTAL,             
                                  rc.right, rc.top, m_hWnd, &tpm);

    if ( fResult == FALSE )
    {           
        LOG((RTC_ERROR, "CMainFrm::OnRedial - "
                "TrackPopupMenuEx failed"));

        return 0;
    } 
    
    LOG((RTC_INFO, "CMainFrm::OnRedial - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnRedialSelect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;

    LOG((RTC_INFO, "CMainFrm::OnRedialSelect - enter"));

    ShowWindow(SW_RESTORE);
    ::SetForegroundWindow(m_hWnd);

    //
    // Sometimes we lose keyboard focus after using a redial menu, so
    // set the focus back
    //

    ::SetFocus(m_hWnd);

    ATLASSERT(m_pControlIntf.p);

    //
    // Get the IRTCAddress pointer for the menu item
    //

    MENUITEMINFO mii;
    BOOL         fResult;

    ZeroMemory( &mii, sizeof(MENUITEMINFO) );
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_DATA;

    fResult = GetMenuItemInfo( m_hRedialPopupMenu, wID, FALSE, &mii );  
    
    if ( fResult == TRUE )
    {    
        IRTCAddress       * pAddress = NULL;
        BSTR                bstrAddress = NULL;
        BSTR                bstrLabel = NULL;
        BSTR                bstrContactName = NULL;
        RTC_ADDRESS_TYPE    enType;

        pAddress = (IRTCAddress *)mii.dwItemData;

        //
        // Get the address string
        //

        hr = pAddress->get_Address(&bstrAddress);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CMainFrm::OnRedialSelect - "
                                "get_Address failed 0x%lx", hr));
        }
        else
        {
            //
            // Get the address type
            //

            hr = pAddress->get_Type(&enType);

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CMainFrm::OnRedialSelect - "
                                    "get_Type failed 0x%lx", hr));
            }
            else
            {                       
                //
                // Get the label (NULL is okay)
                //
         