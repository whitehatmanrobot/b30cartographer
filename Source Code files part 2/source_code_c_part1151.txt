D_PARAMETER;
                break;
            }
        }

        BufferSize = 0x1000;
        Status = ERROR_INSUFFICIENT_BUFFER;
        while (Status == ERROR_INSUFFICIENT_BUFFER)
        {
            Buffer = WmipAlloc(BufferSize);
            if (Buffer != NULL)
            {
                Status = WmipSendWmiKMRequest(NULL,
                                          IOCTL_WMI_RECEIVE_NOTIFICATIONS,
                                          RcvNotification,
                                          RcvNotificationSize,
                                          Buffer,
                                          BufferSize,
                                          &ReturnSize,
                                           NULL);

                if (Status == ERROR_SUCCESS)
                {
                    WnodeTooSmall = (PWNODE_TOO_SMALL)Buffer;
                    if ((ReturnSize == sizeof(WNODE_TOO_SMALL)) &&
                        (WnodeTooSmall->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL))
                    {
                        //
                        // The buffer passed to kernel mode was too small
                        // so we need to make it larger and then try the
                        // request again
                        //
                        BufferSize = WnodeTooSmall->SizeNeeded;
                        Status = ERROR_INSUFFICIENT_BUFFER;
                    } else {
                        //
                        // We got a buffer of notifications so lets go
                        // process them and callback the caller
                        //
                        Wnode = (PWNODE_HEADER)Buffer;
                        do
                        {
                            Linkage = Wnode->Linkage;
                            Wnode->Linkage = 0;

                            if (Wnode->Flags & WNODE_FLAG_INTERNAL)
                            {
                                //
                                // Go and process the internal
                                // notification
                                //
                                WmipInternalNotification(Wnode,
                                                         Callback,
                                                         DeliveryContext,
                                                         IsAnsi);
                            } else {
                                if (IsAnsi)
                                {
                                    //
                                    // Caller wants ansi notification - convert
                                    // instance names
                                      //
                                    WmipConvertEventToAnsi(Wnode);
                                }

                                //
                                // Now go and deliver this event
                                //
                                WmipExternalNotification(Callback,
                                                         DeliveryContext,
                                                         Wnode);
                            }
                            Wnode = (PWNODE_HEADER)OffsetToPtr(Wnode, Linkage);
                        } while (Linkage != 0);
                    }
                }
                WmipFree(Buffer);
            } else {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        WmipFree(RcvNotification);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    SetLastError(Status);
    return(Status);
}


void WmipMakeEventCallbacks(
    IN PWNODE_HEADER Wnode,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    )
{
    WmipAssert((Wnode->Flags & WNODE_FLAG_INTERNAL) == 0);
    
    if (Callback == NULL)
    {
        //
        // This event needs to be sent to all consumers
        //
        WmipDeliverAllEvents((PUCHAR)Wnode,
                             Wnode->BufferSize);
    } else {
        //
        // This event is targetted at a specific consumer
        //
        if (IsAnsi)
        {
            //
            // Caller wants ansi notification - convert
            // instance names
            //
            WmipConvertEventToAnsi(Wnode);        
        }
        
        //
        // Now go and deliver this event
        //
        WmipExternalNotification(Callback,
                                 DeliveryContext,
                                 Wnode);        
    }
}

void WmipClosePendingHandles(
    )
{
    PLIST_ENTRY GuidNotificationList, GuidNotificationListNext;
    PGUIDNOTIFICATION GuidNotification;
    ULONG i;
    PNOTIFYEE Notifyee;

    WmipEnterPMCritSection();

    GuidNotificationList = WmipGNHead.Flink;
    while (GuidNotificationList != &WmipGNHead)
    {
        GuidNotification = CONTAINING_RECORD(GuidNotificationList,
                                             GUIDNOTIFICATION,
                                             GNList);

        GuidNotificationListNext = GuidNotificationList->Flink;
        
        for (i = 0; i < GuidNotification->NotifyeeCount; i++)
        {
            Notifyee = &GuidNotification->Notifyee[i];

            if ((Notifyee->DeliveryInfo != NULL) &&
                (WmipIsNotifyeePendingClose(Notifyee)))
            {
                //
                // This notifyee is pending closure so we clean it up
                // now. We need to close the handle, reset the
                // DeliveryInfo field and unreference the
                // GuidNotification. Note that unreferencing may cause
                // the GuidNotification to go away
                //
                WmipDebugPrint(("WMI: [%x - %x] Pump closing handle 0x%x\n",
                                GetCurrentProcessId(), GetCurrentThreadId(),
                                Notifyee->GuidHandle));
                if (WmipCloseNotifyee(Notifyee,
                                      GuidNotification))
                {

                    //
                    // GuidNotification has been removed from the list.
                    // We jump out of all processing of this
                    // GuidNotification and move onto the next one
                    //
                    break;
                }
            }
        }
        GuidNotificationList = GuidNotificationListNext;
    }
    
    WmipLeavePMCritSection();
}

void WmipBuildReceiveNotification(
    PUCHAR *BufferPtr,
    ULONG *BufferSizePtr,
    ULONG *RequestSize,
    ULONG Action,
    HANDLE ProcessHandle
    )
{
    ULONG GuidCount;
    PUCHAR Buffer;
    ULONG BufferSize;
    PLIST_ENTRY GuidNotificationList;
    PGUIDNOTIFICATION GuidNotification;
    PWMIRECEIVENOTIFICATION ReceiveNotification;
    ULONG SizeNeeded;
    ULONG i;
    PNOTIFYEE Notifyee;
    ULONG ReturnSize;
    ULONG Status;
    BOOLEAN HoldCritSection;
    BOOLEAN HaveGroupHandle;

    Buffer = *BufferPtr;
    BufferSize = *BufferSizePtr;
    ReceiveNotification = (PWMIRECEIVENOTIFICATION)Buffer;

TryAgain:   
    GuidCount = 0;
    SizeNeeded = FIELD_OFFSET(WMIRECEIVENOTIFICATION, Handles);

    //
    // Loop over all guid notifications and build an ioctl request for
    // all of them
    //
    WmipEnterPMCritSection();

    GuidNotificationList = WmipGNHead.Flink;
    while (GuidNotificationList != &WmipGNHead)
    {
        GuidNotification = CONTAINING_RECORD(GuidNotificationList,
                                             GUIDNOTIFICATION,
                                             GNList);

        HaveGroupHandle = FALSE;
        for (i = 0; i < GuidNotification->NotifyeeCount; i++)
        {
            Notifyee = &GuidNotification->Notifyee[i];

            if ((Notifyee->DeliveryInfo != NULL) &&
                ( ! WmipIsNotifyeePendingClose(Notifyee)))
            {
                if (((! HaveGroupHandle) ||
                     ((Notifyee->Flags & NOTIFICATION_FLAG_GROUPED_EVENT) == 0)))
                {
                    //
                    // If there is an active handle in the notifyee slot
                    // and we either have not already inserted the group
                    // handle for this guid or the slot is not part of the
                    // guid group, then we insert the handle into the list
                    //
                    SizeNeeded += sizeof(HANDLE3264);
                    if (SizeNeeded > BufferSize)
                    {
                        //
                        // We need to grow the size of the buffer. Alloc a
                        // bigger buffer, copy over
                        //
                        BufferSize *= 2;
                        HoldCritSection = TRUE;
                        Buffer = WmipAllocDontFail(BufferSize, &HoldCritSection);

                        memcpy(Buffer, ReceiveNotification, *BufferSizePtr);

                        WmipFree(*BufferPtr);

                        *BufferPtr = Buffer;
                        *BufferSizePtr = BufferSize;
                        ReceiveNotification = (PWMIRECEIVENOTIFICATION)Buffer;

                        if (! HoldCritSection)
                        {
                            //
                            // Critical section was released within
                            // WmipAllocDontFail since we had to block. So
                            // everything could have changed. We need to go
                            // back and start over again
                            //
                            goto TryAgain;
                        }                   
                    }

                    WmipSetHandle3264(ReceiveNotification->Handles[GuidCount],
                                      Notifyee->GuidHandle);
                    GuidCount++;
                    WmipDebugPrint(("WMI: [%x - %x] Add Handle to request %x\n",
                             GetCurrentProcessId(), GetCurrentThreadId(),
                             Notifyee->GuidHandle));

                    if (Notifyee->Flags & NOTIFICATION_FLAG_GROUPED_EVENT)
                    {
                        //
                        // This was a guid group handle and we did insert
                        // it into the list so we don't want to insert it
                        // again
                        //
                        HaveGroupHandle = TRUE;
                    }
                }
            }
        }
        GuidNotificationList = GuidNotificationList->Flink;
    }

    WmipLeavePMCritSection();
    ReceiveNotification->HandleCount = GuidCount;
    ReceiveNotification->Action = Action;
    WmipSetPVoid3264(ReceiveNotification->UserModeCallback, WmipEventPumpFromKernel);
    WmipSetHandle3264(ReceiveNotification->UserModeProcess, ProcessHandle);
    *RequestSize = SizeNeeded;  
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)           // Not all control paths return (due to infinite loop)
#endif
ULONG WmipEventPump(
    PVOID Param
    )
{
    LPOVERLAPPED ActiveOverlapped, DeadOverlapped;
    LPOVERLAPPED PrimaryOverlapped;
    LPOVERLAPPED BackupOverlapped;
    PUCHAR ActiveBuffer, DeadBuffer;
    ULONG ActiveBufferSize, DeadBufferSize;
    PUCHAR PrimaryBuffer, BackupBuffer;
    ULONG PrimaryBufferSize, BackupBufferSize;
    ULONG ReturnSize, DeadReturnSize;
    ULONG Status, WaitStatus;
    HANDLE HandleArray[2];
    ULONG RequestSize;

    WmipDebugPrint(("WMI: [%x - %x] New pump thread is started\n",
                    GetCurrentProcessId(), GetCurrentThreadId()));
    
    //
    // We need to hold off on letting the thread into the routine until
    // the previous pump thread has had a chance to finish. This could
    // occur if a GN is added/removed while the previous thread is
    // finishing up or if an event is received as the previous thread
    // is finishing up.
    //
    while (WmipIsPumpStopping())
    {
        //
        // wait 50ms for the previous thread to finish up
        //
        WmipDebugPrint(("WMI: [%x - %x] waiting for pump to be stopped\n",
                        GetCurrentProcessId(), GetCurrentThreadId()));
        Sleep(50);
    }
    
    //
    // Next thing to do is to make sure that another pump thread isn't
    // already running. This can happen in the case that both a GN is
    // added or removed and an event reaches kernel and the kernel
    // creates a new thread too. Right here we only let one of them
    // win.
    //
    WmipEnterPMCritSection();
    if ((WmipPumpState != EVENT_PUMP_IDLE) &&
        (WmipPumpState != EVENT_PUMP_ZERO))
    {
        WmipDebugPrint(("WMI: [%x - %x] Exit pump since state is %d\n",
                        GetCurrentProcessId(), GetCurrentThreadId(),
                        WmipPumpState));
        
        WmipLeavePMCritSection();

        return(0);
    } else {
        WmipDebugPrint(("WMI: [%x - %x] pump thread now running\n",
                        GetCurrentProcessId(), GetCurrentThreadId()));                      
        WmipPumpState = EVENT_PUMP_RUNNING;
        WmipNewPumpThreadPending = FALSE;
        WmipLeavePMCritSection();
    }

    //
    // Make sure we have all resources we'll need to pump out events
    // since there is no way that we can return an error to the original
    // caller since we are on a new thread
    //
    WmipAssert(WmipEventDeviceHandle != NULL);
    WmipAssert(WmipPumpCommandEvent != NULL);
    WmipAssert(WmipMyProcessHandle != NULL);
    WmipAssert(WmipEventBuffer1 != NULL);
    WmipAssert(WmipEventBuffer2 != NULL);
    WmipAssert(WmipOverlapped1.hEvent != NULL);
    WmipAssert(WmipOverlapped2.hEvent != NULL);

    ActiveOverlapped = NULL;

    PrimaryOverlapped = &WmipOverlapped1;
    PrimaryBuffer = WmipEventBuffer1;
    PrimaryBufferSize = WmipEventBufferSize1;

    BackupOverlapped = &WmipOverlapped2;
    BackupBuffer = WmipEventBuffer2;
    BackupBufferSize = WmipEventBufferSize2;

    WmipDebugPrint(("WMI: [%x - %x] 1 buffer is %x, 2 buffer id %x\n",
                    GetCurrentProcessId(), GetCurrentThreadId(),
                    WmipEventBuffer1, WmipEventBuffer2));
    HandleArray[0] = WmipPumpCommandEvent;

    while(TRUE)
    {
        //
        // Build request to receive events for all guids that are
        // registered
        //
        WmipEnterPMCritSection();
        if (IsListEmpty(&WmipGNHead))
        {
            //
            // There are no events to be received so we cancel any
            // outstanding requests and quietly exit this thread. Note
            // that once we leave the critsec there could be another
            // pump thread running so all we can do after that is exit.
            //

            CancelIo(WmipEventDeviceHandle);

            
            //
            // Enter the idle state which implies that all of the
            // pump resources stay allocated when the thread is not
            // running
            //
            WmipEventBuffer1 = PrimaryBuffer;
            WmipEventBufferSize1 = PrimaryBufferSize;
            WmipEventBuffer2 = BackupBuffer;
            WmipEventBufferSize2 = BackupBufferSize;
                        
            WmipPumpState = EVENT_PUMP_IDLE;
            WmipDebugPrint(("WMI: [%x - %x] No more GN, pump exiting, pump state EVENT_PUMP_IDLE\n",
                           GetCurrentProcessId(), GetCurrentThreadId()));
            
            WmipLeavePMCritSection();
            
            return(0);
        }
        WmipLeavePMCritSection();

        if (ActiveOverlapped != NULL)
        {
            //
            // If there was a previously outstanding request then
            // we remember it and switch to the backup overlapped and
            // and data buffer
            //
            DeadOverlapped = ActiveOverlapped;
            DeadBuffer = ActiveBuffer;
            DeadBufferSize = ActiveBufferSize;

            //
            // The request being mooted should be the current primary
            //
            WmipAssert(DeadOverlapped == PrimaryOverlapped);
            WmipAssert(DeadBuffer == PrimaryBuffer);

            //
            // Use the backup request as the new primary
            //
            WmipAssert(BackupOverlapped != NULL);
            WmipAssert(BackupBuffer != NULL);

            PrimaryOverlapped = BackupOverlapped;
            PrimaryBuffer = BackupBuffer;
            PrimaryBufferSize = BackupBufferSize;

            BackupOverlapped = NULL;
            BackupBuffer = NULL;
        } else {
            //
            // If there is no outstanding request then we don't worry about
            // it
            //
            DeadOverlapped = NULL;
        }

        //
        // Build and send the request down to kernel to receive events
        //

RebuildRequest:     
        //
        // Make sure any handles that are pending closure are closed
        //
        WmipClosePendingHandles();      
        
        WmipBuildReceiveNotification(&PrimaryBuffer,
                                     &PrimaryBufferSize,
                                     &RequestSize,
                                     WmipIsPumpStopping() ? RECEIVE_ACTION_CREATE_THREAD :
                                                            RECEIVE_ACTION_NONE,
                                     WmipMyProcessHandle);

        ActiveOverlapped = PrimaryOverlapped;
        ActiveBuffer = PrimaryBuffer;
        ActiveBufferSize = PrimaryBufferSize;

        Status = WmipSendWmiKMRequest(WmipEventDeviceHandle,
                                      IOCTL_WMI_RECEIVE_NOTIFICATIONS,
                                      ActiveBuffer,
                                      RequestSize,
                                      ActiveBuffer,
                                      ActiveBufferSize,
                                      &ReturnSize,
                                      ActiveOverlapped);

        if (DeadOverlapped != NULL)
        {
            if ((Status != ERROR_SUCCESS) &&
                (Status != ERROR_IO_PENDING) &&
                (Status != ERROR_OPERATION_ABORTED))
            {
                //
                // There was a previous request which won't be cleared
                // unless the new request returns pending, cancelled
                // or success. So if the new request returns something
                // else then we need to retry the request
                //
                WmipDebugPrint(("WMI: Event Poll error %d\n", Status));
                Sleep(100);
                goto RebuildRequest;
            }

            //
            // The new request should have caused the old one to
            // be completed
            //
            if (GetOverlappedResult(WmipEventDeviceHandle,
                                    DeadOverlapped,
                                    &DeadReturnSize,
                                    TRUE))
            {
                //
                // The dead request did succeed and was not failed by
                // the receipt of the new request. This is a unlikely
                // race condition where the requests crossed paths. So we
                // need to process the events returned in the dead request.
                // Now if the buffer returned was a WNODE_TOO_SMALL we want
                // to ignore it at this point since we are not at a
                // good position to reallocate the buffers - the
                // primary buffer is already attached to the new
                // request. That request is also going to return a
                // WNODE_TOO_SMALL and in the processing of that one we will
                // grow the buffers. So it is safe to ignore here.
                // However we will still need to dispatch any real
                // events received as they have been purged from KM.
                //
                if (DeadReturnSize != 0)
                {
                    WmipDebugPrint(("WMI: [%x - %x] Process Dead overlapped %p events %p (0x%x)\n",
                                    GetCurrentProcessId(), GetCurrentThreadId(),
                                    DeadOverlapped, DeadBuffer, DeadReturnSize));
                    WmipProcessEventBuffer(DeadBuffer,
                                           DeadReturnSize,
                                           &PrimaryBuffer,
                                           &PrimaryBufferSize,
                                           &BackupBuffer,
                                           &BackupBufferSize,
                                           FALSE);
                } else {
                    WmipAssert(WmipIsPumpStopping());
                }
            }

            //
            // Now make the completed request the backup request
            //
            WmipAssert(BackupOverlapped == NULL);
            WmipAssert(BackupBuffer == NULL);

            BackupOverlapped = DeadOverlapped;
            BackupBuffer = DeadBuffer;
            BackupBufferSize = DeadBufferSize;
        }

        if (Status == ERROR_IO_PENDING)
        {
            //
            // if the ioctl pended then we wait until either an event
            // is returned or a command needs processed
            //
            HandleArray[1] = ActiveOverlapped->hEvent;
            WaitStatus = WaitForMultipleObjectsEx(2,
                                              HandleArray,
                                              FALSE,
                                              WmipEventNotificationWait,
                                              TRUE);
            WmipDebugPrint(("WMI: [%x - %x] Done Waiting for RCV or command -> %d\n",
                            GetCurrentProcessId(), GetCurrentThreadId(),
                            WaitStatus));
        } else {
            //
            // the ioctl completed immediately so we fake out the wait
            //
            WaitStatus = WAIT_OBJECT_0 + 1;
        }

        if (WaitStatus == WAIT_OBJECT_0 + 1)
        {
            if (Status == ERROR_IO_PENDING)
            {
                if (GetOverlappedResult(WmipEventDeviceHandle,
                                        ActiveOverlapped,
                                        &ReturnSize,
                                        TRUE))
                {
                    Status = ERROR_SUCCESS;
                } else {
                    Status = GetLastError();
                }
            }

            if (Status == ERROR_SUCCESS)
            {
                //
                // We received some events from KM so we want to go and
                // process them. If we got a WNODE_TOO_SMALL then the
                // primary and backup buffers will get reallocated with
                // the new size that is needed.
                //
                WmipDebugPrint(("WMI: [%x - %x] Process Active overlapped %p events %p (0x%x)\n",
                                GetCurrentProcessId(), GetCurrentThreadId(),
                                ActiveOverlapped, ActiveBuffer, ReturnSize));

                if (ReturnSize != 0)
                {
                    WmipProcessEventBuffer(ActiveBuffer,
                                           ReturnSize,
                                           &PrimaryBuffer,
                                           &PrimaryBufferSize,
                                           &BackupBuffer,
                                           &BackupBufferSize,
                                           TRUE);
                    //
                    // In the case that we are shutting down the event
                    // pump and the buffer passed to clear out all of
                    // the events was too small we need to call back
                    // down to the kernel to get the rest of the events
                    // since we cannot exit the thread with events that
                    // are not delivered. The kernel will not set the
                    // flag that a new thread is needed unless the irp
                    // clears all outstanding events
                    //
                } else {
                    WmipAssert(WmipIsPumpStopping());
                    if (WmipIsPumpStopping())
                    {
                        //
                        // The irp just completed should have not only
                        // just cleared all events out of kernel mode
                        // but also setup flags that new events should
                        // cause a new pump thread to be created. So
                        // there may be a new pump thread already created
                        // Also note there could be yet
                        // another event pump thread that was created
                        // if a GN was added or removed. Once we set
                        // the pump state to IDLE we are off to the
                        // races (See code at top of function)
                        //
                        WmipEnterPMCritSection();
                        
                        WmipPumpState = EVENT_PUMP_IDLE;
                        WmipDebugPrint(("WMI: [%x - %x] Pump entered IDLE\n",
                                        GetCurrentProcessId(), GetCurrentThreadId()));

                        WmipEventBuffer1 = PrimaryBuffer;
                        WmipEventBufferSize1 = PrimaryBufferSize;
                        WmipEventBuffer2 = BackupBuffer;
                        WmipEventBufferSize2 = BackupBufferSize;

                        //
                        // Before shutting down the pump we need to
                        // close any handles that are pending closure
                        //
                        WmipClosePendingHandles();
                        
                        WmipLeavePMCritSection();
                        
                        return(0);
                    }

                }
                
            } else {
                //
                // For some reason the request failed. All we can do is
                // wait a bit and hope that the problem will clear up.
                // If we are stopping the thread we still need to wait
                // and try again as all events may not have been
                // cleared from the kernel. We really don't know if the
                // irp even made it to the kernel.
                //
                WmipDebugPrint(("WMI: [%x - %x] Error %d from Ioctl\n",
                                GetCurrentProcessId(), GetCurrentThreadId(),
                                Status));
                Sleep(250);
            }

            //
            // Flag that there is no longer a request outstanding
            //
            ActiveOverlapped = NULL;
        } else if (WaitStatus == STATUS_TIMEOUT) {
            //
            // The wait for events timed out so we go into the thread
            // stopping state to indicate that we are going to terminate 
            // the thread once all events are cleared out of kernel. At
            // this point we are commited to stopping the thread. If any 
            // GN are added/removed after going into the stopping state, 
            // a new (and suspended) thread will be created. Right
            // before exiting we check if that thread is pending and if
            // so resume it.
            //
            WmipEnterPMCritSection();
            WmipDebugPrint(("WMI: [%x - %x] Pump thread entering EVENT_PUMP_STOPPING\n",
                           GetCurrentProcessId(), GetCurrentThreadId()));
            WmipPumpState = EVENT_PUMP_STOPPING;
            WmipLeavePMCritSection();
        }
    }

    //
    // Should never break out of infinite loop
    //
    WmipAssert(FALSE);
        
    return(0);
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


ULONG WmipEventPumpFromKernel(
    PVOID Param
    )
{
    //
    // Note that we MUST call ExitThread when we want to shutdown the
    // thread and not return() since the thread has been created by
    // kernel mode and there is nothing on the stack to return to, so
    // we'd just AV
    //


    //
    // Call into ntdll so that it marks our thread as a CSR thread
    //
    CsrNewThread();
    
    WmipEnterPMCritSection();
    if ((WmipNewPumpThreadPending == FALSE) &&
        (WmipPumpState == EVENT_PUMP_IDLE) ||
        (WmipPumpState == EVENT_PUMP_STOPPING))
    {
        //
        // If the pump is currently idle or stopping and there is not
        // another pump thread that is pending we want our thread
        // to be the one that gets the pump going again. We mark the
        // that there is a pump thread pending which means that no more 
        // pump threads will be created when adding/removing GN 
        // and any pump threads created by kernel will just exit quickly
        //
        WmipNewPumpThreadPending = TRUE;
        WmipDebugPrint(("WMI: [%x - %x] KM pump thread created and pump state now START PENDING\n",
                        GetCurrentProcessId(), GetCurrentThreadId()));
        WmipLeavePMCritSection();

        //
        // ISSUE: We cannot call WmipEventPump with Param (ie, the
        // parameter that is passed to this function) because when the
        // thread is created by a Win64 kernel on a x86 app running
        // under win64, Param is not actually passed on the stack since
        // the code that creates the context forgets to do so
        //
        ExitThread(WmipEventPump(0));
    }
    
    WmipDebugPrint(("WMI: [%x - %x] KM pump thread exiting since pump state %d, %s\n",
                        GetCurrentProcessId(), GetCurrentThreadId(),
                        WmipPumpState,
                        (WmipNewPumpThreadPending == TRUE) ?
                            "Pump Thread Pending" : "No Pump Thread Pending"));
                    
    WmipLeavePMCritSection();
    
    ExitThread(0);
}

ULONG WmipEstablishEventPump(
    )
{
#if DBG
    #define INITIALEVENTBUFFERSIZE 0x38
#else
    #define INITIALEVENTBUFFERSIZE 0x1000
#endif
    HANDLE ThreadHandle;
    ULONG ThreadId;
    ULONG Status;
    BOOL b;


#if DBG
    //
    // On checked builds update the length of time to wait before a
    // pump thread times out
    //
    WmipGetRegistryValue(PumpTimeoutRegValueText,
                         &WmipEventNotificationWait);
#endif
    
    //
    // Make sure the event pump thread is running. We check both the
    // pump state and that the device handle is not created since there
    // is a window after the handle is created and the thread starts
    // running and changes the pump state
    //
    WmipEnterPMCritSection();

    if ((WmipPumpState == EVENT_PUMP_ZERO) &&
        (WmipEventDeviceHandle == NULL))
    {
        //
        // Not only is pump not running, but the resources for it
        // haven't been allocated
        //
        WmipAssert(WmipPumpCommandEvent == NULL);
        WmipAssert(WmipMyProcessHandle == NULL);
        WmipAssert(WmipOverlapped1.hEvent == NULL);
        WmipAssert(WmipOverlapped2.hEvent == NULL);
        WmipAssert(WmipEventBuffer1 == NULL);
        WmipAssert(WmipEventBuffer2 == NULL);

        //
        // Preallocate all of the resources that the event pump will need
        // so that it has no excuse to fail
        //

        WmipEventDeviceHandle = CreateFile(WMIDataDeviceName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL |
                                      FILE_FLAG_OVERLAPPED,
                              NULL);

        if (WmipEventDeviceHandle == INVALID_HANDLE_VALUE)
        {
            Status = GetLastError();
            goto Cleanup;
        }

        WmipPumpCommandEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (WmipPumpCommandEvent == NULL)
        {
            Status = GetLastError();
            goto Cleanup;
        }

        b = DuplicateHandle(GetCurrentProcess(),
                            GetCurrentProcess(),
                            GetCurrentProcess(),
                            &WmipMyProcessHandle,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS);
        if (! b)
        {
            Status = GetLastError();
            goto Cleanup;
        }

        WmipOverlapped1.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (WmipOverlapped1.hEvent == NULL)
        {
            Status = GetLastError();
            goto Cleanup;
        }

        WmipOverlapped2.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (WmipOverlapped2.hEvent == NULL)
        {
            Status = GetLastError();
            goto Cleanup;
        }

        WmipEventBuffer1 = WmipAlloc(INITIALEVENTBUFFERSIZE);
        if (WmipEventBuffer1 == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        WmipEventBufferSize1 = INITIALEVENTBUFFERSIZE;

        WmipEventBuffer2 = WmipAlloc(INITIALEVENTBUFFERSIZE);
        if (WmipEventBuffer2 == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        WmipEventBufferSize2 = INITIALEVENTBUFFERSIZE;

        ThreadHandle = CreateThread(NULL,
                                    0,
                                    WmipEventPump,
                                    NULL,
                                    0,
                                    &ThreadId);

        if (ThreadHandle != NULL)
        {
            WmipNewPumpThreadPending = TRUE;
            WmipDebugPrint(("WMI: [%x] Created initiail pump thread %x\n",
                            GetCurrentProcessId(), ThreadId
                           ));
            CloseHandle(ThreadHandle);
        } else {
            //
            // Since we were able to allocate all of our pump
            // resources, but didn't get the pump thread started,
            // we will hang onto our resources and move the pump
            // state to idle. In this way when the pump is started
            // again we do not have to reallocate our resources
            //
            WmipPumpState = EVENT_PUMP_IDLE;
            Status = GetLastError();
            goto Done;
        }

        WmipLeavePMCritSection();
        return(ERROR_SUCCESS);
    } else {
        //
        // Pump resources should already be allocated
        //
        WmipAssert(WmipPumpCommandEvent != NULL);
        WmipAssert(WmipMyProcessHandle != NULL);
        WmipAssert(WmipOverlapped1.hEvent != NULL);
        WmipAssert(WmipOverlapped2.hEvent != NULL);
        WmipAssert(WmipEventBuffer1 != NULL);
        WmipAssert(WmipEventBuffer2 != NULL);
        if ((WmipNewPumpThreadPending == FALSE) &&
            (WmipPumpState == EVENT_PUMP_STOPPING) ||
            (WmipPumpState == EVENT_PUMP_IDLE))
        {
            //
            // If pump is stopping or is idle then we need to fire up a
            // new thread
            //
            ThreadHandle = CreateThread(NULL,
                                        0,
                                        WmipEventPump,
                                        NULL,
                                        0,
                                        &ThreadId);

            if (ThreadHandle != NULL)
            {
                WmipDebugPrint(("WMI: [%x] Created new pump thread %x (%d %d)\n",
                                GetCurrentProcessId(), ThreadId,
                                WmipPumpState, WmipNewPumpThreadPending
                               ));
                WmipNewPumpThreadPending = TRUE;
                CloseHandle(ThreadHandle);
            } else {
                Status = GetLastError();
                goto Done;
            }
        } else {
            WmipAssert((WmipPumpState == EVENT_PUMP_RUNNING) ||
                       (WmipNewPumpThreadPending == TRUE));
        }
        WmipLeavePMCritSection();
        return(ERROR_SUCCESS);
    }
Cleanup:
    if (WmipEventDeviceHandle != NULL)
    {
        CloseHandle(WmipEventDeviceHandle);
        WmipEventDeviceHandle = NULL;
    }

    if (WmipPumpCommandEvent != NULL)
    {
        CloseHandle(WmipPumpCommandEvent);
        WmipPumpCommandEvent = NULL;
    }
    
    if (WmipMyProcessHandle != NULL)
    {
        CloseHandle(WmipMyProcessHandle);
        WmipMyProcessHandle = NULL;
    }

    if (WmipOverlapped1.hEvent != NULL)
    {
        CloseHandle(WmipOverlapped1.hEvent);
        WmipOverlapped1.hEvent = NULL;
    }

    if (WmipOverlapped2.hEvent != NULL)
    {
        CloseHandle(WmipOverlapped2.hEvent);
        WmipOverlapped2.hEvent = NULL;
    }

    if (WmipEventBuffer1 != NULL)
    {
        WmipFree(WmipEventBuffer1);
        WmipEventBuffer1 = NULL;
    }

    if (WmipEventBuffer2 != NULL)
    {
        WmipFree(WmipEventBuffer2);
        WmipEventBuffer2 = NULL;
    }

Done:   
    WmipLeavePMCritSection();
    return(Status);
}

ULONG WmipAddHandleToEventPump(
    LPGUID Guid,
    PVOID DeliveryInfo,
    ULONG_PTR DeliveryContext,
    ULONG NotificationFlags,
    HANDLE GuidHandle
    )
{
    ULONG Status;

    Status = WmipAddToGNList(Guid,
                             DeliveryInfo,
                             DeliveryContext,
                             NotificationFlags,
                             GuidHandle);

    if (Status == ERROR_SUCCESS)
    {
        Status = WmipEstablishEventPump();
        
        if (Status == ERROR_SUCCESS)
        {
            WmipSendPumpCommand();
        } else {
            //
            // If we couldn't establish the event pump we want to
            // remove the handle from the GNList and propogate back the
            // error
            //
            WmipRemoveFromGNList(Guid,
                                 DeliveryInfo);
        }
    } else {
        //
        // If handle could not be added to the lists then we need to
        // close the handle to prevent leaks.
        //
        
        CloseHandle(GuidHandle);
    }

    
    return(Status);
}

ULONG
WmipNotificationRegistration(
    IN LPGUID InGuid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG64 LoggerContext,
    IN ULONG Flags,
    IN BOOLEAN IsAnsi
    )
{
    HANDLE GuidHandle;
    GUID Guid;
    PVOID NotificationDeliveryContext;
    PVOID NotificationDeliveryInfo;
    ULONG NotificationFlags;
    ULONG Status;
    HANDLE ThreadHandle;
    DWORD ThreadId;
    ULONG ReturnSize;

    WmipInitProcessHeap();

    //
    // Validate input parameters and flags
    //
    if (InGuid == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    try
    {
        Guid = *InGuid;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    if (Flags == NOTIFICATION_CHECK_ACCESS)
    {
        //
        // Caller just wants to check that he has does have permission
        // to enable the notification
        //
#ifdef MEMPHIS
        return(ERROR_SUCCESS);
#else
        Status = WmipCheckGuidAccess(&Guid, WMIGUID_NOTIFICATION);
        SetLastError(Status);
        return(Status);
#endif
    }

    //
    // Validate that flags are correct
    //
    if (Enable)
    {
        if ((Flags != NOTIFICATION_TRACE_FLAG) &&
            (Flags != NOTIFICATION_CALLBACK_DIRECT))
        {
            //
            // Invalid Flags were passed
            Status = ERROR_INVALID_PARAMETER;
        } else if (Flags == NOTIFICATION_TRACE_FLAG) {
            Status = ERROR_SUCCESS;
        } else if ((Flags == NOTIFICATION_CALLBACK_DIRECT) &&
                   (DeliveryInfo == NULL)) {
            //
            // Not a valid callback function
            Status = ERROR_INVALID_PARAMETER;
        } else {
            Status = ERROR_SUCCESS;
        }

        if (Status != ERROR_SUCCESS)
        {
            SetLastError(Status);
            return(Status);
        }
    }


    NotificationDeliveryInfo = (PVOID)DeliveryInfo;
    NotificationDeliveryContext = (PVOID)DeliveryContext;

    NotificationFlags = IsAnsi ? DCREF_FLAG_ANSI : 0;


    if (Flags & NOTIFICATION_TRACE_FLAG)
    {
        //
        // This is a tracelog enable/disable request so send it down the
        // fast lane to KM so it can be processed.
        //
        WMITRACEENABLEDISABLEINFO TraceEnableInfo;

        TraceEnableInfo.Guid = Guid;
        TraceEnableInfo.LoggerContext = LoggerContext;
        TraceEnableInfo.Enable = Enable;

        Status = WmipSendWmiKMRequest(NULL,
                                      IOCTL_WMI_ENABLE_DISABLE_TRACELOG,
                                       &TraceEnableInfo,
                                      sizeof(WMITRACEENABLEDISABLEINFO),
                                      NULL,
                                      0,
                                      &ReturnSize,
                                      NULL);

    } else {
        //
        // This is a WMI event enable/disable event request so fixup the
        // flags and send a request off to the event pump thread.
        //
        if (Flags & NOTIFICATION_CALLBACK_DIRECT) {
            NotificationFlags |= NOTIFICATION_FLAG_CALLBACK_DIRECT;
        } else {
            NotificationFlags |= Flags;
        }

        if (Enable)
        {
            //
            // Since we are enabling, make sure we have access to the
            // guid and then make sure we can get the notification pump
            // thread running.
            //
            Status = WmipOpenKernelGuid(&Guid,
                                         WMIGUID_NOTIFICATION,
                                         &GuidHandle,
                                         IOCTL_WMI_OPEN_GUID_FOR_EVENTS);


            if (Status == ERROR_SUCCESS)
            {

                Status = WmipAddHandleToEventPump(&Guid,
                                                    DeliveryInfo,
                                                  DeliveryContext,
                                                  NotificationFlags |
                                                  NOTIFICATION_FLAG_GROUPED_EVENT,
                                                  GuidHandle);
            }
        } else {
            Status = WmipRemoveFromGNList(&Guid,
                                          DeliveryInfo);
            if (Status == ERROR_SUCCESS)
            {
                WmipSendPumpCommand();
            }

            if (Status == ERROR_INVALID_PARAMETER)
            {
                CHAR s[MAX_PATH];
                WmipDebugPrint(("WMI: Invalid DeliveryInfo %x passed to unregister for notification %s\n",
                              DeliveryInfo,
                              GuidToStringA(s, &Guid)));
                Status = ERROR_WMI_ALREADY_DISABLED;
            }
        }
    }

    SetLastError(Status);
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\request.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    request.c

Abstract:

    Implements WMI requests to different data providers

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"

//
// This is the handle to the WMI kernel mode device
HANDLE WmipKMHandle;

//
// This is the one-deep Win32 event queue used to supply events for
// overlapped I/O to the WMI device.
HANDLE WmipWin32Event;


__inline HANDLE WmipAllocEvent(
    void
    )
{
    HANDLE EventHandle;

    EventHandle = (HANDLE)InterlockedExchangePointer((PVOID *)(&WmipWin32Event),
                                                     NULL);
    if (EventHandle == NULL)
    {
        //
        // If event in queue is in use then create a new one
        EventHandle = CreateEvent(NULL, FALSE, FALSE, NULL);
    }
    return(EventHandle);
}

__inline void WmipFreeEvent(
    HANDLE EventHandle
    )
{
    if (InterlockedCompareExchangePointer(&WmipWin32Event,
                                          EventHandle,
                                          NULL) != NULL)
    {
        //
        // If there is already a handle in the event queue then free this
        // handle
        CloseHandle(EventHandle);
    }
}

ULONG WmipSendWmiKMRequest(
    HANDLE DeviceHandle,
    ULONG Ioctl,
    PVOID InBuffer,
    ULONG InBufferSize,
    PVOID OutBuffer,
    ULONG MaxBufferSize,
    ULONG *ReturnSize,
    LPOVERLAPPED Overlapped
    )
/*+++

Routine Description:

    This routine does the work of sending WMI requests to the WMI kernel
    mode device.  Any retry errors returned by the WMI device are handled
    in this routine.

Arguments:

    Ioctl is the IOCTL code to send to the WMI device
    Buffer is the input buffer for the call to the WMI device
    InBufferSize is the size of the buffer passed to the device
    OutBuffer is the output buffer for the call to the WMI device
    MaxBufferSize is the maximum number of bytes that can be written
        into the buffer
    *ReturnSize on return has the actual number of bytes written in buffer
    Overlapped is an option OVERLAPPED struct that is used to make the 
        call async

Return Value:

    ERROR_SUCCESS or an error code
---*/
{
    OVERLAPPED StaticOverlapped;
    ULONG Status;
    BOOL IoctlSuccess;

    WmipEnterPMCritSection();
    if (WmipKMHandle == NULL)
    {
        //
        // If device is not open for then open it now. The
        // handle is closed in the process detach dll callout (DlllMain)
        WmipKMHandle = CreateFile(WMIDataDeviceName,
                                      GENERIC_READ | GENERIC_WRITE,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL |
                                      FILE_FLAG_OVERLAPPED,
                                      NULL);
        if (WmipKMHandle == (HANDLE)-1)
        {
            WmipKMHandle = NULL;
            WmipLeavePMCritSection();
            return(GetLastError());
        }
    }
    WmipLeavePMCritSection();

    if (Overlapped == NULL)
    {
        //
        // if caller didn't pass an overlapped structure then supply
        // our own and make the call synchronous
        //
        Overlapped = &StaticOverlapped;
    
        Overlapped->hEvent = WmipAllocEvent();
        if (Overlapped->hEvent == NULL)
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    
    if (DeviceHandle == NULL)
    {
        DeviceHandle = WmipKMHandle;
    }

    do
    {
        IoctlSuccess = DeviceIoControl(DeviceHandle,
                              Ioctl,
                              InBuffer,
                              InBufferSize,
                              OutBuffer,
                              MaxBufferSize,
                              ReturnSize,
                              Overlapped);

        if (!IoctlSuccess)
        {
            if (Overlapped == &StaticOverlapped)
            {
                //
                // if the call was successful and we are synchronous then
                // block until the call completes
                //
                if (GetLastError() == ERROR_IO_PENDING)
                {
                    IoctlSuccess = GetOverlappedResult(DeviceHandle,
                                               Overlapped,
                                               ReturnSize,
                                               TRUE);
                }
    
                if (! IoctlSuccess)
                {
                    Status = GetLastError();
                } else {
                    Status = ERROR_SUCCESS;
                }
            } else {
                Status = GetLastError();
            }
        } else {
            Status = ERROR_SUCCESS;
        }
    } while (Status == ERROR_WMI_TRY_AGAIN);

    if (Overlapped == &StaticOverlapped)
    {
        WmipFreeEvent(Overlapped->hEvent);
    }
    
    return(Status);
}

ULONG IoctlActionCode[WmiExecuteMethodCall+1] =
{
    IOCTL_WMI_QUERY_ALL_DATA,
    IOCTL_WMI_QUERY_SINGLE_INSTANCE,
    IOCTL_WMI_SET_SINGLE_INSTANCE,
    IOCTL_WMI_SET_SINGLE_ITEM,
    IOCTL_WMI_ENABLE_EVENT,
    IOCTL_WMI_DISABLE_EVENT,
    IOCTL_WMI_ENABLE_COLLECTION,
    IOCTL_WMI_DISABLE_COLLECTION,
    IOCTL_WMI_GET_REGINFO,
    IOCTL_WMI_EXECUTE_METHOD
};

ULONG WmipSendWmiRequest(
    ULONG ActionCode,
    PWNODE_HEADER Wnode,
    ULONG WnodeSize,
    PVOID OutBuffer,
    ULONG MaxWnodeSize,
    ULONG *RetSize
    )
/*+++

Routine Description:

    This routine does the work of sending WMI requests to the appropriate
    data provider. Note that this routine is called while the GuidHandle's
    critical section is held.

Arguments:


Return Value:

---*/
{
    ULONG Status = ERROR_SUCCESS;
    ULONG Ioctl;
    ULONG BusyRetries;

    //
    // Send the query down to kernel mode for execution
    //
    WmipAssert(ActionCode <= WmiExecuteMethodCall);
    Ioctl = IoctlActionCode[ActionCode];
    Status = WmipSendWmiKMRequest(NULL,
                                      Ioctl,
                                      Wnode,
                                      WnodeSize,
                                      OutBuffer,
                                      MaxWnodeSize,
                                      RetSize,
                                      NULL);
    return(Status);
}

ULONG WmipConvertWADToAnsi(
    PWNODE_ALL_DATA Wnode
    )
/*+++

Routine Description:

    This routine will convert the instance names in a WNODE_ALL_DATA to
    ansi. The conversion is done in place since we can assume that ansi
    strings are no longer than unicode strings.

Arguments:

    Wnode is the WNODE_ALL_DATA whose instance names are to be converted to
        ANSI

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    ULONG i;
    ULONG Linkage;
    ULONG InstanceCount;
    PULONG InstanceNameOffsets;
    PWCHAR Ptr;
    ULONG Status = ERROR_SUCCESS;

    WmipAssert(!(Wnode->WnodeHeader.Flags & WNODE_FLAG_ANSI_INSTANCENAMES));

    do
    {
        Wnode->WnodeHeader.Flags |= WNODE_FLAG_ANSI_INSTANCENAMES;

        InstanceCount = Wnode->InstanceCount;
        InstanceNameOffsets = (PULONG)(((PUCHAR)Wnode) +
                                            Wnode->OffsetInstanceNameOffsets);
        for (i = 0; i < InstanceCount; i++)
        {
            Ptr = (PWCHAR)(((PUCHAR)Wnode) + InstanceNameOffsets[i]);
            try
            {
                Status = WmipCountedUnicodeToCountedAnsi(Ptr, (PCHAR)Ptr);
            } except(EXCEPTION_EXECUTE_HANDLER) {
//                Wnode->WnodeHeader.Flags |= WNODE_FLAG_INVALID;
                return(ERROR_SUCCESS);
            }
            if (Status != ERROR_SUCCESS)
            {
                SetLastError(Status);
                goto Done;
            }
        }

        Linkage = Wnode->WnodeHeader.Linkage;
        Wnode = (PWNODE_ALL_DATA)(((PUCHAR)Wnode) + Linkage);
    } while (Linkage != 0);


Done:
    return(Status);
}


ULONG WmipRegisterGuids(
    IN LPGUID MasterGuid,
    IN ULONG RegistrationCookie,    
    IN PWMIREGINFOW RegInfo,
    IN ULONG GuidCount,
    OUT PTRACEGUIDMAP *GuidMapHandle,
    OUT ULONG64 *LoggerContext,
    OUT HANDLE *RegistrationHandle
	)
{
	ULONG Status;
	ULONG SizeNeeded, InSizeNeeded, OutSizeNeeded;
    WCHAR GuidObjectName[WmiGuidObjectNameLength+1];
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING GuidString;
	PWMIREGREQUEST WmiRegRequest;
	PTRACEGUIDMAP TraceGuidMap;
	PUCHAR Buffer;
	PUCHAR RegInfoBuffer;
	PWMIREGRESULTS WmiRegResults;
	ULONG ReturnSize;
	ULONG TraceGuidMapSize;
	
	//
	// Allocate a buffer large enough for all in and out parameters
	//
	TraceGuidMapSize = GuidCount * sizeof(TRACEGUIDMAP);
	InSizeNeeded = sizeof(WMIREGREQUEST) + RegInfo->BufferSize;
    OutSizeNeeded = TraceGuidMapSize + sizeof(WMIREGRESULTS);
	if (InSizeNeeded > OutSizeNeeded)
	{
		SizeNeeded = InSizeNeeded;
	} else {
		SizeNeeded = OutSizeNeeded;
	}
	
	Buffer = WmipAlloc(SizeNeeded);
	
	if (Buffer != NULL)
	{
        RtlZeroMemory(Buffer, SizeNeeded);
		//
		// Build the object attributes
		//
        WmiRegRequest = (PWMIREGREQUEST)Buffer;
    	WmiRegRequest->ObjectAttributes = &ObjectAttributes;
		WmiRegRequest->GuidCount = GuidCount;
        WmiRegRequest->WmiRegInfo32Size = sizeof(WMIREGINFOW);
        WmiRegRequest->WmiRegGuid32Size = sizeof(WMIREGGUIDW);
        
    	RegInfoBuffer = Buffer + sizeof(WMIREGREQUEST);
    	
    	Status = WmipBuildGuidObjectAttributes(MasterGuid,
                                               &ObjectAttributes,
                                               &GuidString,
                                               GuidObjectName);
    									   
        if (Status == ERROR_SUCCESS)
        {
			WmiRegRequest->Cookie = RegistrationCookie;
    	    RtlCopyMemory(RegInfoBuffer, RegInfo, RegInfo->BufferSize);
     	    Status = WmipSendWmiKMRequest(NULL,
                                         IOCTL_WMI_REGISTER_GUIDS,
                                         Buffer,
                                         InSizeNeeded,
                                         Buffer,
                                         OutSizeNeeded,
                                         &ReturnSize,
                                         NULL);
    								 
            if (Status == ERROR_SUCCESS)
    		{
				//
				// Successful call, return the out parameters
				//
				WmiRegResults = (PWMIREGRESULTS)((PUCHAR)Buffer + TraceGuidMapSize);
    			*RegistrationHandle = WmiRegResults->RequestHandle.Handle;
				*LoggerContext = WmiRegResults->LoggerContext;
				*GuidMapHandle = (PTRACEGUIDMAP)Buffer;
    		}
			
            //
			// Note that we do not free Buffer in this call. This will be
			// freed by the caller since it is returned in *GuidMapHandle
			//

        }
	} else {
		Status = ERROR_NOT_ENOUGH_MEMORY;
	}
	
	return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\srvmain.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    srvmain.c

Abstract:

    This routine is a service stub for WDM WMI service. This is for
    backward compatibility with Windows 2000 where other services
    were dependent on WDM WMI Service.  

Author:

    27-Mar-2001 Melur Raghuraman

Revision History:

--*/

#include "wmiump.h"

SERVICE_STATUS_HANDLE   WmiServiceStatusHandle;
SERVICE_STATUS          WmiServiceStatus;
HANDLE                  WmipTerminationEvent;

VOID
WmipUpdateServiceStatus (
    DWORD   dwState
    )
{
    WmipAssert(WmiServiceStatusHandle);

    WmiServiceStatus.dwCurrentState = dwState;
    SetServiceStatus (WmiServiceStatusHandle, &WmiServiceStatus);
}

VOID
WINAPI
WmiServiceCtrlHandler (
    DWORD dwOpcode)
{
    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        WmipUpdateServiceStatus (SERVICE_STOP_PENDING);
        NtSetEvent( WmipTerminationEvent, NULL );
        break;

    case SERVICE_CONTROL_PAUSE:
    case SERVICE_CONTROL_CONTINUE:
    case SERVICE_CONTROL_INTERROGATE:
    case SERVICE_CONTROL_SHUTDOWN:
    default:
        WmipAssert (WmiServiceStatusHandle);
        SetServiceStatus (WmiServiceStatusHandle, &WmiServiceStatus);
        break;
    }
}

VOID
WINAPI
WdmWmiServiceMain (
    DWORD   argc,
    PWSTR   argv[])
{
    NTSTATUS Status;

    RtlZeroMemory (&WmiServiceStatus, sizeof(WmiServiceStatus));
    WmiServiceStatus.dwServiceType      = SERVICE_WIN32_SHARE_PROCESS;
    WmiServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    WmiServiceStatusHandle = RegisterServiceCtrlHandler (L"Wmi", WmiServiceCtrlHandler);
    if (WmiServiceStatusHandle)
    {
        WmipUpdateServiceStatus (SERVICE_RUNNING);

        Status =  NtCreateEvent( &WmipTerminationEvent, 
                                  EVENT_ALL_ACCESS, 
                                  NULL, 
                                  SynchronizationEvent, 
                                  FALSE
                                 );
        if (!NT_SUCCESS(Status) ) {
            WmipDebugPrint(("WMI: CreateEvent Failed %d\n", GetLastError() ));
        }
        else {
            Status = NtWaitForSingleObject( WmipTerminationEvent, FALSE, NULL);
        }

        WmipUpdateServiceStatus (SERVICE_STOPPED);
    }
    else 
    {
        WmipDebugPrint( ( "WMI: RegisterServiceCtrlHandler failed %d\n", GetLastError() ));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\tracedc.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    tracedc.c

Abstract:

    Basic data consumer APIs to process trace data directly from buffers.


Author:

    15-Sep-1997 JeePang

Revision History:

    18-Apr-2001 insungp

        Added asynchronopus IO for reading log files.
        Also replaced WmiGetFirstTraceOffset() calls with sizeof(WMI_BUFFER_HEADER).

--*/

#ifndef MEMPHIS

#include "wmiump.h"
#include "traceump.h"
#include "evntrace.h"
#include "tracelib.h"

#define MAXSTR                          1024

extern ULONG WmiTraceAlignment;

#ifdef DBG
void
WmipDumpEvent(
    PEVENT_TRACE pEvent
    );
void
WmipDumpGuid(
    LPGUID
    );

void
WmipDumpCallbacks();
#endif
#define KERNEL_LOGGER_CAPTION           TEXT("NT Kernel Logger")
#define DEFAULT_LOG_BUFFER_SIZE         1024

#define MAXBUFFERS                      1024
#define MINBUFFERS                      8 
#define MAX_KERNEL_TRACE_EVENTS         22 // Look at \nt\base\published\ntwmi.w for the event groups

#define TRACE_HEADER_SYSTEM32 TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                            | (TRACE_HEADER_TYPE_SYSTEM32 << 16)
#define TRACE_HEADER_SYSTEM64 TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                            | (TRACE_HEADER_TYPE_SYSTEM64 << 16)
#define TRACE_HEADER_FULL   TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                            | (TRACE_HEADER_TYPE_FULL_HEADER << 16)
#define TRACE_HEADER_INSTANCE TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                            | (TRACE_HEADER_TYPE_INSTANCE << 16)



#define DEFAULT_REALTIME_BUFFER_SIZE    32768
#define MAXBUFFERS                      1024
#define MINBUFFERS                      8

//
// If the tracelog instance is a realtime data feed instead of from a
// tracefile, TRACELOG_REALTIME_CONTEXT is used to maintain the real time
// buffers in a buffer pool.
//

typedef struct _TRACE_BUFFER_SPACE {
    ULONG               Reserved;   // amount of memory reserved
    ULONG               Committed;
    PVOID               Space;
    LIST_ENTRY          FreeListHead;
} TRACE_BUFFER_SPACE, *PTRACE_BUFFER_SPACE;

typedef struct _TRACELOG_REALTIME_CONTEXT {
    ULONG           BuffersProduced;    // Number of Buffers to read
    ULONG           BufferOverflow;     // Number of Buffers missed by the consumer
    GUID            InstanceGuid;       // Logger Instance Guid
    HANDLE          MoreDataEvent;      // Event to signal there is more data in this stream
    PTRACE_BUFFER_SPACE WmipTraceBufferSpace;
    PWNODE_HEADER   RealTimeBufferPool[MAXBUFFERS];
} TRACELOG_REALTIME_CONTEXT, *PTRACELOG_REALTIME_CONTEXT;


//
// RealTime Free Buffer Pool is chained up as TRACE_BUFFER_HEADER
//

typedef struct _TRACE_BUFFER_HEADER {
    WNODE_HEADER Wnode;
    LIST_ENTRY   Entry;
} TRACE_BUFFER_HEADER, *PTRACE_BUFFER_HEADER;

typedef struct _TRACERT_BUFFER_LIST_ENTRY {
    ULONG Size;
    LIST_ENTRY Entry;
    LIST_ENTRY BufferListHead;
} TRACERT_BUFFER_LIST_ENTRY, *PTRACERT_BUFFER_LIST_ENTRY;



//
// This TraceHandleListHeadPtr should be the only real global 
// for ProcessTrace to be multithreaded
//

PLIST_ENTRY TraceHandleListHeadPtr = NULL;

//
// For kernel events we map the Grouptype to Guid transparently to the caller. 
// The mapping between GroupType and Guid is maintained by this structure. 
//

typedef struct _TRACE_GUID_MAP {        // used to map GroupType to Guid
    ULONG               GroupType;      // Group & Type
    GUID                Guid;           // Guid
} TRACE_GUID_MAP, *PTRACE_GUID_MAP;

PTRACE_GUID_MAP  EventMapList = NULL;  // Array mapping the Grouptype to Guids

typedef struct _EVENT_GUID_MAP {
    LIST_ENTRY          Entry;
    ULONGLONG           GuidHandle;
    GUID                Guid;
} EVENT_GUID_MAP, *PEVENT_GUID_MAP;

// List of Registered callbacks. One callback per Guid Only.

PLIST_ENTRY  EventCallbackListHead = NULL;

typedef struct _EVENT_TRACE_CALLBACK {
    LIST_ENTRY          Entry;
    GUID                Guid;
    PEVENT_CALLBACK     CallbackRoutine;
} EVENT_TRACE_CALLBACK, *PEVENT_TRACE_CALLBACK;


#define MAX_TRACE_BUFFER_CACHE_SIZE   29

typedef struct _TRACE_BUFFER_CACHE_ENTRY {
    LONG Index;
    PVOID Buffer;
} TRACE_BUFFER_CACHE_ENTRY, *PTRACE_BUFFER_CACHE_ENTRY;


struct _TRACE_BUFFER_LIST_ENTRY;

typedef struct _TRACE_BUFFER_LIST_ENTRY {
    struct _TRACE_BUFFER_LIST_ENTRY *Next;
    LONG        FileOffset;     // Offset in File of this Buffer
    ULONG       BufferOffset;   // Offset in Buffer for the current event
    ULONG       Flags;          // Flags on status of this buffer
    ULONG       EventSize;
    ULONG       ClientContext;  // Alignment, ProcessorNumber
    ULONG       TraceType;      // Current Event Type
    EVENT_TRACE Event;          // CurrentEvent of this Buffer
} TRACE_BUFFER_LIST_ENTRY, *PTRACE_BUFFER_LIST_ENTRY;


typedef struct _TRACELOG_CONTEXT {
    LIST_ENTRY          Entry;          // Keeps track of storage allocations.

    // Fields from HandleListEntry
    EVENT_TRACE_LOGFILEW Logfile;

    TRACEHANDLE     TraceHandle;
    ULONG           ConversionFlags;    // Flags indicating event processing options
    LONG            BufferBeingRead;
    OVERLAPPED      AsynchRead;

    //
    // Fields Below this will be reset upon ProcessTrace exit. 
    //

    BOOLEAN             fProcessed;
    USHORT              LoggerId;       // Logger Id of this DataFeed. 
    UCHAR               IsRealTime;     // Flag to tell if this feed is RT.
    UCHAR               fGuidMapRead;

    LIST_ENTRY   GuidMapListHead;   // This is LogFile specific property

    //
    // For using PerfClock, we need to save startTime, Freq 
    //

    ULONG   UsePerfClock; 
    ULONG   CpuSpeedInMHz;
    LARGE_INTEGER PerfFreq;             // Frequency from the LogFile
    LARGE_INTEGER StartTime;            // Start Wall clock time
    LARGE_INTEGER StartPerfClock;       // Start PerfClock value
    
    union 
       {
       HANDLE              Handle;         // NT handle to logfile
       PTRACELOG_REALTIME_CONTEXT RealTimeCxt; // Ptr to Real Time Context
       };

    ULONG EndOfFile;   // Flag to show whether this stream is still active.


    ULONG           BufferSize;
    ULONG           BufferCount;
    ULONG           InitialSize;
    ULONG           StartBuffer;

    PTRACE_BUFFER_LIST_ENTRY Root;
    PTRACE_BUFFER_LIST_ENTRY BufferList;
    PVOID  BufferCacheSpace;
    TRACE_BUFFER_CACHE_ENTRY BufferCache[MAX_TRACE_BUFFER_CACHE_SIZE];

} TRACELOG_CONTEXT, *PTRACELOG_CONTEXT;

//
// this structure is used only by WmipGetBuffersWrittenFromQuery() and
// WmipCheckForRealTimeLoggers()
//
typedef struct _ETW_QUERY_PROPERTIES {
    EVENT_TRACE_PROPERTIES TraceProp;
    WCHAR  LoggerName[MAXSTR];
    WCHAR  LogFileName[MAXSTR];
} ETW_QUERY_PROPERTIES, *PETW_QUERY_PROPERTIES; 

ETW_QUERY_PROPERTIES Properties;

ULONG
WmipConvertEnumToTraceType(
    WMI_HEADER_TYPE eTraceType
    );

WMI_HEADER_TYPE
WmipConvertTraceTypeToEnum(
                            ULONG TraceType
                          );

ULONG
WmipCheckForRealTimeLoggers(
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    ULONG Unicode
);

ULONG
WmipLookforRealTimeBuffers(
    PEVENT_TRACE_LOGFILEW logfile
    );
ULONG
WmipRealTimeCallback(
    IN PWNODE_HEADER Wnode,
    IN ULONG_PTR Context
    );
void
WmipFreeRealTimeContext(
    PTRACELOG_REALTIME_CONTEXT RTCxt
    );

ULONG
WmipSetupRealTimeContext(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount
    );

PVOID
WmipAllocTraceBuffer(
    PTRACELOG_REALTIME_CONTEXT RTCxt,
    ULONG BufferSize
    );

VOID
WmipFreeTraceBuffer(
    PTRACELOG_REALTIME_CONTEXT RTCxt,
    PVOID Buffer
    );

ULONG
WmipProcessRealTimeTraces(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    LONGLONG StartTime,
    LONGLONG EndTime,
    ULONG   Unicode
    );

//
// Routines used in this file only
//

ULONG
WmipDoEventCallbacks(
    PEVENT_TRACE_LOGFILEW logfile,
    PEVENT_TRACE pEvent
    );

ULONG
WmipCreateGuidMapping(void);

LPGUID
WmipGuidMapHandleToGuid(
    PLIST_ENTRY GuidMapListHeadPtr,
    ULONGLONG    GuidHandle
    );

void
WmipCleanupGuidMapList(
    PLIST_ENTRY GuidMapListHeadPtr
    );


void
WmipCleanupTraceLog(
    PTRACELOG_CONTEXT pEntry
    );

VOID
WmipGuidMapCallback(
    PLIST_ENTRY GuidMapListHeadPtr,
    PEVENT_TRACE pEvent
    );

ULONG
WmipProcessGuidMaps(
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    ULONG Unicode
    );

PEVENT_TRACE_CALLBACK
WmipGetCallbackRoutine(
    LPGUID pGuid
    );

VOID 
WmipFreeCallbackList();


ULONG
WmipProcessLogHeader(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    ULONG Unicode,
    ULONG bFree
    );

ULONG
WmipProcessTraceLog(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    LONGLONG StartTime,
    LONGLONG EndTime,
    ULONG   Unicode
    );

ULONG
WmipParseTraceEvent(
    IN PTRACELOG_CONTEXT pContext,
    IN PVOID LogBuffer,
    IN ULONG Offset,
    IN WMI_HEADER_TYPE HeaderType,
    IN OUT PVOID EventInfo,
    IN ULONG EventInfoSize
    );

ULONG
WmipGetBuffersWrittenFromQuery(
    LPWSTR LoggerName
    );

VOID
WmipCopyLogHeader (
    IN PTRACE_LOGFILE_HEADER pLogFileHeader,
    IN PVOID MofData,
    IN ULONG MofLength,
    IN PWCHAR *LoggerName,
    IN PWCHAR *LogFileName,
    IN ULONG  Unicode
    );

VOID
WmipInsertBuffer (
    PTRACE_BUFFER_LIST_ENTRY *Root,
    PTRACE_BUFFER_LIST_ENTRY NewEntry
    )
/*++

Routine Description:
    This routine inserts a buffer in a sorted list. The insertion 
    is done based on the timestamp of the BufferHeader. If two buffers
    have the same timestamp, then the BufferIndex is used to resolve the tie.

Arguments:
    Root - Pointer to the root of the LIST
    NewEntry - Entry being inserted

Returned Value:

    None

--*/
{
    PTRACE_BUFFER_LIST_ENTRY Current, Prev;
    //
    // If List is empty, make the new entry the Root and return.
    //

    if (NewEntry == NULL) {
        return;
    }

    if (*Root == NULL) {
        *Root = NewEntry;
        NewEntry->Next = NULL;
        return;
    }

    //
    // Traverse the list and insert the NewEntry in order
    //
    Prev = NULL;
    Current = *Root;

    while (Current != NULL) {
        if ((ULONGLONG)NewEntry->Event.Header.TimeStamp.QuadPart < (ULONGLONG)Current->Event.Header.TimeStamp.QuadPart) {
            if (Prev != NULL) {
                Prev->Next = NewEntry;
            }
            else {
                *Root = NewEntry;
            }
            NewEntry->Next = Current;
            return;
        }
        else if ((ULONGLONG)NewEntry->Event.Header.TimeStamp.QuadPart == (ULONGLONG)Current->Event.Header.TimeStamp.QuadPart) {
            if (NewEntry->FileOffset < Current->FileOffset) {
                if (Prev != NULL) {
                    Prev->Next = NewEntry;
                }
                else {
                    *Root = NewEntry;
                }
                NewEntry->Next = Current;
                return;
            }
        }
        Prev = Current;
        Current = Current->Next;
    }


    if (Prev != NULL) {
        Prev->Next = NewEntry;
        NewEntry->Next = NULL;
    }
#if DBG
    else {
        WmipAssert(Prev != NULL);
    }
#endif
    return;
}


PTRACE_BUFFER_LIST_ENTRY
WmipRemoveBuffer(
    PTRACE_BUFFER_LIST_ENTRY *Root
    )
{
    PTRACE_BUFFER_LIST_ENTRY OldEntry = *Root;

    if (OldEntry == NULL)
        return NULL;
    *Root = OldEntry->Next;
    OldEntry->Next = NULL;
    return OldEntry;
}

PVOID
WmipGetCurrentBuffer(
    PTRACELOG_CONTEXT pContext,
    PTRACE_BUFFER_LIST_ENTRY Current
    )
{
    NTSTATUS Status;

    LONG FileOffset = (ULONG)Current->FileOffset;
    ULONG nBytesRead;
    LONG TableIndex;

    HANDLE hFile = pContext->Handle;
    ULONG BufferSize = pContext->BufferSize;
    PVOID pBuffer;
    ULONGLONG Offset;

    DWORD BytesTransffered;

    //
    // Look for the buffer in cache.
    //
    TableIndex = FileOffset % MAX_TRACE_BUFFER_CACHE_SIZE;

    if (pContext->BufferCache[TableIndex].Index == FileOffset) {
        //
        // Check whether the buffer we want is still being read.
        // If so, we need to wait for it to finish.
        //
        if (pContext->BufferBeingRead == FileOffset) {
            if (GetOverlappedResult(hFile, &pContext->AsynchRead, &BytesTransffered, TRUE)) {
                pContext->BufferBeingRead = -1;
            }
            else { // getting the result failed
                return NULL;
            }
        }
        return pContext->BufferCache[TableIndex].Buffer;
    }

// 
// Do a synch read for the buffer we need. We still need to make sure the previous read
// has completed.
//
    pBuffer = pContext->BufferCache[TableIndex].Buffer;
    Offset = FileOffset * BufferSize;
    if (pContext->BufferBeingRead != -1) {
        if (!GetOverlappedResult(hFile, &pContext->AsynchRead, &BytesTransffered, TRUE) &&
            GetLastError() != ERROR_HANDLE_EOF) {
            WmipDebugPrint(("GetOverlappedResult failed with Status %d in GetCurrentBuffer\n", GetLastError()));
            // cannot determine the status of the previous read
            return NULL;
        }
    }
    pContext->AsynchRead.Offset = (DWORD)(Offset & 0xFFFFFFFF);
    pContext->AsynchRead.OffsetHigh = (DWORD)(Offset >> 32);
    Status = WmipSynchReadFile(hFile,
                    (LPVOID)pBuffer,
                    BufferSize,
                    &nBytesRead,
                    &pContext->AsynchRead);
    pContext->BufferBeingRead = -1;
    if (nBytesRead == 0) {
        return NULL;
    }
    //
    // Update the cache entry with the one just read in
    //

    pContext->BufferCache[TableIndex].Index = FileOffset;

    //
    // We need to account for event alignments when backtracking to get the MofPtr.
    // (BufferOffset - EventSize) backtracks to the start of the current event. 
    // Add EventHeaderSize and Subtract the MofLength gives the MofPtr. 
    //
    if (pContext->ConversionFlags & EVENT_TRACE_GET_RAWEVENT) {
        Current->Event.MofData = ((PUCHAR)pBuffer 
                                        + Current->BufferOffset 
                                        - Current->EventSize);
        if (pContext->UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {

            //
            // Need to override the timestamp with SystemTime
            //
            switch(Current->TraceType) {
                case TRACE_HEADER_TYPE_PERFINFO32:
                case TRACE_HEADER_TYPE_PERFINFO64:
                {
                    PPERFINFO_TRACE_HEADER   pPerf = (PPERFINFO_TRACE_HEADER)Current->Event.MofData;
                    pPerf->SystemTime = Current->Event.Header.TimeStamp;
                    break;
                }
                case TRACE_HEADER_TYPE_SYSTEM32:
                {
                    PSYSTEM_TRACE_HEADER pSystemHeader32 = (PSYSTEM_TRACE_HEADER) Current->Event.MofData;
                    pSystemHeader32->SystemTime = Current->Event.Header.TimeStamp;
                    break;
                }
                case TRACE_HEADER_TYPE_SYSTEM64:
                {
                    PSYSTEM_TRACE_HEADER pSystemHeader64 = (PSYSTEM_TRACE_HEADER) Current->Event.MofData;
                    pSystemHeader64->SystemTime = Current->Event.Header.TimeStamp;
                    break;
                }
                case TRACE_HEADER_TYPE_FULL_HEADER:
                {
                    PEVENT_TRACE_HEADER pWnodeHeader = (PEVENT_TRACE_HEADER) Current->Event.MofData;
                    pWnodeHeader->TimeStamp = Current->Event.Header.TimeStamp;
                    break;
                }
                case TRACE_HEADER_TYPE_INSTANCE:
                {
                    PEVENT_INSTANCE_HEADER pInstanceHeader = (PEVENT_INSTANCE_HEADER) Current->Event.MofData;
                    pInstanceHeader->TimeStamp = Current->Event.Header.TimeStamp;
                    break;
                }
                case TRACE_HEADER_TYPE_TIMED:
                {
                    PTIMED_TRACE_HEADER pTimedHeader = (PTIMED_TRACE_HEADER) Current->Event.MofData;
                    pTimedHeader->TimeStamp = Current->Event.Header.TimeStamp;
                    break;
                }
                case TRACE_HEADER_TYPE_WNODE_HEADER:
                case TRACE_HEADER_TYPE_MESSAGE:
                {
                    break;
                }
            }
        }
    }
    else {

        //
        // When The FileOffset is 0 (First Buffer) and the EventType is 
        // LOGFILE_HEADER
        // 

        if ( (FileOffset == 0) && 
             ((Current->BufferOffset - Current->EventSize) == sizeof(WMI_BUFFER_HEADER)) ) 
        {
            Current->Event.MofData = (PVOID)&pContext->Logfile.LogfileHeader;
        }
        else 
        {
            Current->Event.MofData = ((PUCHAR)pBuffer 
                                        + Current->BufferOffset 
                                        - Current->EventSize 
                                        + Current->Event.Header.Size 
                                        - Current->Event.MofLength );
        }
    }

    return pBuffer;
}

PTRACELOG_CONTEXT
WmipAllocateTraceHandle()
{
    PLIST_ENTRY Next, Head;
    PTRACELOG_CONTEXT NewHandleEntry, pEntry;

    WmipEnterPMCritSection();

    if (TraceHandleListHeadPtr == NULL) {
        TraceHandleListHeadPtr = WmipAlloc(sizeof(LIST_ENTRY));
        if (TraceHandleListHeadPtr == NULL) {
            WmipSetDosError(ERROR_OUTOFMEMORY);
            WmipLeavePMCritSection();
            return NULL;
        }
        InitializeListHead(TraceHandleListHeadPtr);
    }

    NewHandleEntry = WmipAlloc(sizeof(TRACELOG_CONTEXT));
    if (NewHandleEntry == NULL) {
        WmipSetDosError(ERROR_OUTOFMEMORY);
        WmipLeavePMCritSection();
        return NULL;
    }

    RtlZeroMemory(NewHandleEntry, sizeof(TRACELOG_CONTEXT));

    // AsynchRead initialization
    NewHandleEntry->BufferBeingRead = -1;
    NewHandleEntry->AsynchRead.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (NewHandleEntry->AsynchRead.hEvent == NULL) {
        WmipFree(NewHandleEntry);
        WmipLeavePMCritSection();
        return NULL;
    }


    InitializeListHead(&NewHandleEntry->GuidMapListHead);
    Head = TraceHandleListHeadPtr;
    Next = Head->Flink;
    if (Next == Head) {
       NewHandleEntry->TraceHandle = 1;
       InsertTailList(Head, &NewHandleEntry->Entry);
       WmipLeavePMCritSection();
       return NewHandleEntry;
    }

    while (Next != Head) {
        pEntry = CONTAINING_RECORD( Next, TRACELOG_CONTEXT, Entry );
        Next = Next->Flink;
        NewHandleEntry->TraceHandle++;
        if (NewHandleEntry->TraceHandle < pEntry->TraceHandle) {
            InsertTailList(&pEntry->Entry, &NewHandleEntry->Entry);
            WmipLeavePMCritSection();
            return NewHandleEntry;
        }
    }
    //
    // TODO: Need to optimize this case out first before searching...
    //
    NewHandleEntry->TraceHandle++;
    InsertTailList(Head, &NewHandleEntry->Entry);
    WmipLeavePMCritSection();
    return NewHandleEntry;

}

PTRACELOG_CONTEXT
WmipLookupTraceHandle(
    TRACEHANDLE TraceHandle
    )
{
     PLIST_ENTRY Head, Next;
     PTRACELOG_CONTEXT pEntry;

     WmipEnterPMCritSection();
     Head = TraceHandleListHeadPtr;

     if (Head == NULL) {
         WmipLeavePMCritSection();
         return NULL;
     }
     Next = Head->Flink;
     while (Next != Head) {
        pEntry = CONTAINING_RECORD( Next, TRACELOG_CONTEXT, Entry );
        Next = Next->Flink;

        if (TraceHandle == pEntry->TraceHandle) {
            WmipLeavePMCritSection();
            return pEntry;
        }
    }
    WmipLeavePMCritSection();
    return NULL;
}

ULONG
WmipFreeTraceHandle(
        TRACEHANDLE TraceHandle
        )
{
    PLIST_ENTRY Head, Next;
    PTRACELOG_CONTEXT pEntry;

    WmipEnterPMCritSection();

    Head = TraceHandleListHeadPtr;
    if (Head == NULL) {
        WmipLeavePMCritSection();
        return ERROR_INVALID_HANDLE;
    }
    Next = Head->Flink;

    while (Next != Head) {
       pEntry = CONTAINING_RECORD( Next, TRACELOG_CONTEXT, Entry );
       Next = Next->Flink;
       if (TraceHandle == pEntry->TraceHandle) {

           if (pEntry->fProcessed == TRUE)
           {
               WmipLeavePMCritSection();
               return ERROR_BUSY;
           }

           RemoveEntryList(&pEntry->Entry);

           // Free pEntry memory
           //
           if (pEntry->Logfile.LogFileName != NULL)
           {
               WmipFree(pEntry->Logfile.LogFileName);
           }
           if (pEntry->Logfile.LoggerName != NULL)
           {
               WmipFree(pEntry->Logfile.LoggerName);
           }
           CloseHandle(pEntry->AsynchRead.hEvent);
           WmipFree(pEntry);

           //
           // If the handle list is empty, then delete it.
           //
           if (Head == Head->Flink) {
                WmipFree(TraceHandleListHeadPtr);
                TraceHandleListHeadPtr = NULL;
           }
           WmipLeavePMCritSection();
           return ERROR_SUCCESS;
       }
   }
   WmipLeavePMCritSection();
   return ERROR_INVALID_HANDLE;
}


ULONG
WMIAPI
WmipCreateGuidMapping(void)
/*++

Routine Description:
    This routine is used to create the mapping array between GroupTypes and Guid
    for kernel events.

Arguments:
    None. 

Returned Value:

    None

--*/
{
    ULONG i = 0;
    ULONG listsize;

    if (EventMapList == NULL) { 
        listsize = sizeof(TRACE_GUID_MAP) * MAX_KERNEL_TRACE_EVENTS;
        EventMapList = (PTRACE_GUID_MAP) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, listsize);
        if (EventMapList == NULL) {
            return WmipSetDosError(ERROR_OUTOFMEMORY);
        }

        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_IO;
        RtlCopyMemory(&EventMapList[i++].Guid,&DiskIoGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_FILE;
        RtlCopyMemory(&EventMapList[i++].Guid, &FileIoGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_TCPIP;
        RtlCopyMemory(&EventMapList[i++].Guid, &TcpIpGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_UDPIP;
        RtlCopyMemory(&EventMapList[i++].Guid, &UdpIpGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_THREAD;
        RtlCopyMemory(&EventMapList[i++].Guid, &ThreadGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_PROCESS;
        RtlCopyMemory(&EventMapList[i++].Guid, &ProcessGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_MEMORY;
        RtlCopyMemory(&EventMapList[i++].Guid, &PageFaultGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_HEADER;
        RtlCopyMemory(&EventMapList[i++].Guid, &EventTraceGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_PROCESS +
                                       EVENT_TRACE_TYPE_LOAD;
        RtlCopyMemory(&EventMapList[i++].Guid, &ImageLoadGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_REGISTRY;
        RtlCopyMemory(&EventMapList[i++].Guid, &RegistryGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_DBGPRINT;
        RtlCopyMemory(&EventMapList[i++].Guid, &DbgPrintGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_CONFIG;
        RtlCopyMemory(&EventMapList[i++].Guid, &EventTraceConfigGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_POOL;
        RtlCopyMemory(&EventMapList[i++].Guid, &PoolGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_PERFINFO;
        RtlCopyMemory(&EventMapList[i++].Guid, &PerfinfoGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_HEAP;
        RtlCopyMemory(&EventMapList[i++].Guid, &HeapGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_OBJECT;
        RtlCopyMemory(&EventMapList[i++].Guid, &ObjectGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_MODBOUND;
        RtlCopyMemory(&EventMapList[i++].Guid, &ModBoundGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_DPC;
        RtlCopyMemory(&EventMapList[i++].Guid, &DpcGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_POWER;
        RtlCopyMemory(&EventMapList[i++].Guid, &PowerGuid, sizeof(GUID));
        EventMapList[i].GroupType    = EVENT_TRACE_GROUP_CRITSEC;
        RtlCopyMemory(&EventMapList[i++].Guid, &CritSecGuid, sizeof(GUID));
    }
    return WmipSetDosError(ERROR_SUCCESS);
}

LPGUID
WmipGuidMapHandleToGuid(
    PLIST_ENTRY GuidMapListHeadPtr,
    ULONGLONG    GuidHandle
    )
{
    PLIST_ENTRY Next, Head;
    PEVENT_GUID_MAP GuidMap;
    ULONG retry_count=0;

retry:
    
    WmipEnterPMCritSection();
    
    Head = GuidMapListHeadPtr;
    Next = Head->Flink;
    while (Next != Head) {
        GuidMap = CONTAINING_RECORD( Next, EVENT_GUID_MAP, Entry );
        if (GuidMap->GuidHandle == GuidHandle) {
            WmipLeavePMCritSection();
            return (&GuidMap->Guid);
        }
        Next = Next->Flink;
    }
    WmipLeavePMCritSection();

    //
    // At this point, assume that this is realtime feed and 
    // and try to dumpout guids and try again. 

    if ((WmipDumpGuidMaps(NULL, GuidMapListHeadPtr, TRUE) > 0) && 
        (retry_count++ < 1)) {
        goto retry;
    }
    
    return NULL;
}

ULONG
WmipAddGuidHandleToGuidMapList(
    IN PLIST_ENTRY GuidMapListHeadPtr,
    IN ULONGLONG   GuidHandle,
    IN LPGUID      Guid
    )
{
    PEVENT_GUID_MAP GuidMap;

    if (GuidMapListHeadPtr != NULL)  {
        GuidMap = WmipAlloc(sizeof(EVENT_GUID_MAP));
        if (GuidMap == NULL)
            return WmipSetDosError(ERROR_OUTOFMEMORY);

        RtlZeroMemory(GuidMap, sizeof(EVENT_GUID_MAP));

        GuidMap->GuidHandle = GuidHandle;
        GuidMap->Guid = *Guid;
        WmipEnterPMCritSection();
        InsertTailList(GuidMapListHeadPtr, &GuidMap->Entry);
        WmipLeavePMCritSection();
    }
    return WmipSetDosError(ERROR_SUCCESS);
}

void
WmipCleanupGuidMapList(
        PLIST_ENTRY GuidMapListHeadPtr
    )
{
    PLIST_ENTRY Next, Head;
    PEVENT_GUID_MAP GuidMap;
    WmipEnterPMCritSection();
    if (GuidMapListHeadPtr != NULL) {

    Head = GuidMapListHeadPtr;
    Next = Head->Flink;
    while (Next != Head) {
        GuidMap = CONTAINING_RECORD( Next, EVENT_GUID_MAP, Entry );
        Next = Next->Flink;
        RemoveEntryList(&GuidMap->Entry);
        WmipFree(GuidMap);
    }
        GuidMapListHeadPtr = NULL;
    }
    WmipLeavePMCritSection();
}

LPGUID
WmipGroupTypeToGuid(
    ULONG GroupType
    )
/*++

Routine Description:
    This routine returns the GUID corresponding to a given GroupType.
    The mapping is static and is defined by the kernel provider.

Arguments:
    GroupType           The GroupType of the kernel event. 

Returned Value:

    Pointer to the GUID representing the given GroupType.  

--*/
{
    ULONG i;
    for (i = 0; i < MAX_KERNEL_TRACE_EVENTS; i++) {
        if (EventMapList[i].GroupType == GroupType) 
            return (&EventMapList[i].Guid);
    }
    return NULL;
}

VOID
WmipFreeCallbackList()
/*++

Routine Description:
    This routine removes all event callbacks and frees the storage. 

Arguments:
    None

Returned Value:

    None. 

--*/
{
    PLIST_ENTRY Next, Head;
    PEVENT_TRACE_CALLBACK EventCb;


    if (EventCallbackListHead == NULL) 
        return;
    
    WmipEnterPMCritSection();

    Head = EventCallbackListHead;
    Next = Head->Flink;
    while (Next != Head) {
        EventCb = CONTAINING_RECORD( Next, EVENT_TRACE_CALLBACK, Entry );
        Next = Next->Flink;
        RemoveEntryList(&EventCb->Entry);
        WmipFree(EventCb);
    }

    WmipFree(EventCallbackListHead);
    EventCallbackListHead = NULL;

    WmipLeavePMCritSection();
}


PEVENT_TRACE_CALLBACK
WmipGetCallbackRoutine(
    LPGUID pGuid
    )
/*++

Routine Description:
    This routine returns the callback function for a given Guid. 
    If no callback was registered for the Guid, returns NULL. 

Arguments:
    pGuid           pointer to the Guid.

Returned Value:

    Event Trace Callback Function. 

--*/
{
    PLIST_ENTRY head, next;
    PEVENT_TRACE_CALLBACK pEventCb = NULL;

    if (pGuid == NULL)
        return NULL;

    WmipEnterPMCritSection();

    if (EventCallbackListHead == NULL) {
        WmipLeavePMCritSection();
        return NULL;
    }

    head = EventCallbackListHead;
    next = head->Flink;
    while (next != head) {
        pEventCb = CONTAINING_RECORD( next, EVENT_TRACE_CALLBACK, Entry);
        if (IsEqualGUID(pGuid, &pEventCb->Guid)) {
            WmipLeavePMCritSection();
            return (pEventCb);
        }
        next = next->Flink;
    }

    WmipLeavePMCritSection();
    return NULL;
    
}


ULONG 
WMIAPI
SetTraceCallback(
    IN LPCGUID pGuid,
    IN PEVENT_CALLBACK EventCallback
    )
/*++

Routine Description:

    This routine is used to wire a callback function for Guid. The 
    callback function is called when an Event with this Guid is found in
    the subsequent ProcessTraceLog Call. 

Arguments:

    pGuid           Pointer to the Guid.

    func            Callback Function Address. 


Return Value:
    ERROR_SUCCESS   Callback function is wired
    


--*/
{
    PEVENT_TRACE_CALLBACK pEventCb;
    PLIST_ENTRY head, next;
    GUID FilterGuid;
    ULONG Checksum;
    ULONG Status;

    WmipInitProcessHeap();
    
    if ((pGuid == NULL) || (EventCallback == NULL) || 
        (EventCallback == (PEVENT_CALLBACK) -1 ) ) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }

    //
    // Capture the Guid first
    //
    try {
        FilterGuid = *pGuid;
        Checksum = *((PULONG)EventCallback);
        if (Checksum) {
            Status = Checksum;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipSetDosError(ERROR_NOACCESS);
    }

    WmipEnterPMCritSection();

    if (EventCallbackListHead == NULL) {
        EventCallbackListHead = (PLIST_ENTRY) WmipAlloc(sizeof(LIST_ENTRY));
        if (EventCallbackListHead == NULL) {
            WmipLeavePMCritSection();
            return WmipSetDosError(ERROR_OUTOFMEMORY);
        }
        InitializeListHead(EventCallbackListHead);
    }

    //
    // If there is a callback wired for this Guid, simply update the function.
    //

    head = EventCallbackListHead;
    next = head->Flink;
    while (next != head) {
        pEventCb = CONTAINING_RECORD( next, EVENT_TRACE_CALLBACK, Entry);
        if (IsEqualGUID(&FilterGuid, &pEventCb->Guid)) {
            pEventCb->CallbackRoutine = EventCallback;
            WmipLeavePMCritSection();
            return WmipSetDosError(ERROR_SUCCESS);
        }
        next = next->Flink;
    }

    //
    // Create a new entry in the EventCallbackList for this Guid.
    //
    pEventCb = (PEVENT_TRACE_CALLBACK) WmipAlloc (sizeof(EVENT_TRACE_CALLBACK));
    if (pEventCb == NULL) {
        WmipLeavePMCritSection();
        return WmipSetDosError(ERROR_OUTOFMEMORY);
    }
    RtlZeroMemory(pEventCb, sizeof(EVENT_TRACE_CALLBACK));
    pEventCb->Guid = FilterGuid;
    pEventCb->CallbackRoutine = EventCallback;

    InsertTailList(EventCallbackListHead, &pEventCb->Entry);

    WmipLeavePMCritSection();
    Status = ERROR_SUCCESS;
    return WmipSetDosError(Status);
    
}

ULONG
WMIAPI
RemoveTraceCallback(
    IN LPCGUID pGuid
    )
/*++

Routine Description:

    This routine removes a callback function for a given Guid. 

Arguments:

    pGuid           Pointer to the Guid for which the callback routine needs
                    to be deleted. 

Return Value:

    ERROR_SUCCESS               Successfully deleted the callback routine. 
    ERROR_INVALID_PARAMETER     Could not find any callbacks for the Guid. 
--*/
{
    PLIST_ENTRY next, head;
    PEVENT_TRACE_CALLBACK EventCb;
    GUID RemoveGuid;
    ULONG errorCode;
#ifdef DBG
    CHAR GuidStr[64];
#endif

    WmipInitProcessHeap();
    
    if ((pGuid == NULL) || (EventCallbackListHead == NULL))
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    //
    // Capture the Guid into a local variable first
    //
    try {
        RemoveGuid = *pGuid;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipSetDosError(ERROR_NOACCESS);
    }

    errorCode = ERROR_WMI_GUID_NOT_FOUND;

    WmipEnterPMCritSection();

    head = EventCallbackListHead;
    next = head->Flink;
    while (next != head) {
        EventCb = CONTAINING_RECORD( next, EVENT_TRACE_CALLBACK, Entry);
        next = next->Flink;
        if (IsEqualGUID(&EventCb->Guid, &RemoveGuid)) {
            RemoveEntryList(&EventCb->Entry);
            WmipFree(EventCb);
            errorCode = ERROR_SUCCESS;
        }
    }

    WmipLeavePMCritSection();
    return WmipSetDosError(errorCode);
}

#ifdef DBG
void
WmipDumpEvent(
    PEVENT_TRACE pEvent
    )
{
    DbgPrint("\tSize              %d\n", pEvent->Header.Size);
    DbgPrint("\tThreadId          %X\n", pEvent->Header.ThreadId);
    DbgPrint("\tTime Stamp        %I64u\n", pEvent->Header.TimeStamp.QuadPart);
}

void
WmipDumpGuid(
    LPGUID pGuid
    )
{
    DbgPrint("Guid=%x,%x,%x,\n\t{%x,%x,%x,%x,%x,%x,%x}\n",
        pGuid->Data1, pGuid->Data2, pGuid->Data3,
        pGuid->Data4[0], pGuid->Data4[1], pGuid->Data4[2], pGuid->Data4[3],
        pGuid->Data4[5], pGuid->Data4[6], pGuid->Data4[7], pGuid->Data4[8]);
}

void WmipDumpCallbacks()
{
    PLIST_ENTRY next, head;
    PEVENT_TRACE_CALLBACK EventCb;

    if (EventCallbackListHead == NULL)
        return;
    WmipEnterPMCritSection();
    head = EventCallbackListHead;
    next = head->Flink;
    while (next != head) {
        EventCb = CONTAINING_RECORD(next, EVENT_TRACE_CALLBACK, Entry);
        WmipDumpGuid(&EventCb->Guid);
        next = next->Flink;
    }
    WmipLeavePMCritSection();
}

#endif

VOID
WmipCalculateCurrentTime (
    OUT PLARGE_INTEGER    DestTime,
    IN  PLARGE_INTEGER    TimeValue,
    IN  PTRACELOG_CONTEXT pContext
    )
{
    ULONG64 StartPerfClock;
    ULONG64 CurrentTime, TimeStamp;
    ULONG64 Delta;
    double dDelta;

    if (pContext == NULL) {
        Move64(TimeValue, DestTime);
        return;
    }

    if (pContext->ConversionFlags & EVENT_TRACE_GET_RAWEVENT) {
        Move64(TimeValue, DestTime);
        return;
    }

    Move64(TimeValue, (PLARGE_INTEGER) &TimeStamp);

    if ((pContext->UsePerfClock == EVENT_TRACE_CLOCK_SYSTEMTIME) ||
        (pContext->UsePerfClock == EVENT_TRACE_CLOCK_RAW)) {
        //
        // System time, just return the time stamp.
        //
        Move64(TimeValue, DestTime);
        return;
    } 
    else if (pContext->UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
        if (pContext->PerfFreq.QuadPart == 0) {
            Move64(TimeValue, DestTime);
            return;
        }
        StartPerfClock = pContext->StartPerfClock.QuadPart;
        if (TimeStamp > StartPerfClock) {
            Delta = (TimeStamp - StartPerfClock);
            dDelta =  ((double) Delta) *  (10000000.0 / (double)pContext->PerfFreq.QuadPart);
            Delta = (ULONG64)dDelta;
            CurrentTime = pContext->StartTime.QuadPart + Delta;
        }
        else {
            Delta = StartPerfClock - TimeStamp;
            dDelta =  ((double) Delta) *  (10000000.0 / (double)pContext->PerfFreq.QuadPart);
            Delta = (ULONG64)dDelta;
            CurrentTime = pContext->StartTime.QuadPart - Delta;
        }
        Move64((PLARGE_INTEGER) &CurrentTime, DestTime);
        return;
    } 
    else {
        if (pContext->CpuSpeedInMHz == 0) {
            Move64(TimeValue, DestTime);
            return;
        }
        StartPerfClock = pContext->StartPerfClock.QuadPart;
        if (TimeStamp > StartPerfClock) {
            Delta = (TimeStamp - StartPerfClock);
            dDelta =  ((double) Delta) *  (10.0 / (double)pContext->CpuSpeedInMHz);
            Delta = (ULONG64)dDelta;
            CurrentTime = pContext->StartTime.QuadPart + Delta;
        }
        else {
            Delta = StartPerfClock - TimeStamp;
            dDelta =  ((double) Delta) *  (10.0 / (double)pContext->CpuSpeedInMHz);
            Delta = (ULONG64)dDelta;
            CurrentTime = pContext->StartTime.QuadPart - Delta;
        }
        Move64((PLARGE_INTEGER) &CurrentTime, DestTime);
        return;
    }

}

ULONG
WmipCopyCurrentEvent(
    PTRACELOG_CONTEXT   pContext,
    PVOID               pHeader,
    PEVENT_TRACE        pEvent,
    ULONG               TraceType,
    PWMI_BUFFER_HEADER  LogBuffer
    )
/*++

Routine Description:
    This routine copies the Current Event from the logfile buffer stream to 
    the CurrentEvent structure provided by the caller. The routine takes
    care of the differences between kernel event and user events by mapping
    all events uniformly to the EVENT_TRACE_HEADER structure. 

Arguments:
    pHeader           Pointer to the datablock in the input stream (logfile).
    pEvent            Current Event to which the data is copied.
    TraceType         Enum indicating the header type. 
    LogBuffer         The buffer 

Returned Value:

    Status indicating success or failure. 

--*/
{
    PEVENT_TRACE_HEADER pWnode;
    PEVENT_TRACE_HEADER  pWnodeHeader;
    ULONG nGroupType;
    LPGUID pGuid;
    ULONG UsePerfClock = 0;
    ULONG UseBasePtr = 0;
    ULONG PrivateLogger=0;

    if (pHeader == NULL || pEvent == NULL)
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    if (pContext != NULL) {
        UsePerfClock = pContext->UsePerfClock;
        UseBasePtr = pContext->ConversionFlags & EVENT_TRACE_GET_RAWEVENT;
        PrivateLogger = (pContext->Logfile.LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE);
    }

    switch(TraceType) {
        //
        // ISSUE: Need to split the two so we can process cross platform.
        //        shsiao 03/22/2000
        //
        case TRACE_HEADER_TYPE_PERFINFO32:
        case TRACE_HEADER_TYPE_PERFINFO64:
        {
            PPERFINFO_TRACE_HEADER pPerfHeader;
            pPerfHeader = (PPERFINFO_TRACE_HEADER) pHeader;
            nGroupType = pPerfHeader->Packet.Group << 8;
            if ((nGroupType == EVENT_TRACE_GROUP_PROCESS) &&
                (pPerfHeader->Packet.Type == EVENT_TRACE_TYPE_LOAD)) {
                nGroupType += pPerfHeader->Packet.Type;
            }
            RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
            pWnode = (PEVENT_TRACE_HEADER) &pEvent->Header;

            pGuid = WmipGroupTypeToGuid(nGroupType);
            if (pGuid != NULL)
                RtlCopyMemory(&pWnode->Guid, pGuid, sizeof(GUID));

            pWnode->Size                = pPerfHeader->Packet.Size;
            pWnode->Class.Type          = pPerfHeader->Packet.Type;
            pWnode->Class.Version       = pPerfHeader->Version;

            WmipCalculateCurrentTime( &pWnode->TimeStamp, 
                                      &pPerfHeader->SystemTime,
                                      pContext );

            //
            // PERFINFO headers does not have ThreadId or CPU Times
            //

            if( LogBuffer->Flags & WNODE_FLAG_THREAD_BUFFER ){

                pWnode->ThreadId = LogBuffer->CurrentOffset;

            } else {

                pWnode->ProcessId = -1;
                pWnode->ThreadId = -1;

            }
            

            if (UseBasePtr) {
                pEvent->MofData = (PVOID) pHeader;
                pEvent->MofLength = pWnode->Size;
                //
                // Override the Timestamp with SystemTime from PERFCounter. 
                // If rdtsc is used no conversion is done. 
                //
                if (UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
                    pPerfHeader->SystemTime = pWnode->TimeStamp;
                }
            }
            else if (pWnode->Size > FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data)) {
                pEvent->MofData       = (PVOID) ((char*) pHeader +
                                              FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data));
                pEvent->MofLength = pWnode->Size - FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);
            }
            pEvent->Header.FieldTypeFlags = EVENT_TRACE_USE_NOCPUTIME;
            
            break;
        }
        case TRACE_HEADER_TYPE_SYSTEM32:
        {
            PSYSTEM_TRACE_HEADER pSystemHeader32;
            pSystemHeader32 = (PSYSTEM_TRACE_HEADER) pHeader;
            nGroupType = pSystemHeader32->Packet.Group << 8;
            if ((nGroupType == EVENT_TRACE_GROUP_PROCESS) &&
                (pSystemHeader32->Packet.Type == EVENT_TRACE_TYPE_LOAD)) {
                nGroupType += pSystemHeader32->Packet.Type;
            }
            RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
            pWnode = (PEVENT_TRACE_HEADER) &pEvent->Header;
            pGuid = WmipGroupTypeToGuid(nGroupType);
            if (pGuid != NULL)
                RtlCopyMemory(&pWnode->Guid, pGuid, sizeof(GUID));
            pWnode->Size            = pSystemHeader32->Packet.Size;
            pWnode->ThreadId        = pSystemHeader32->ThreadId;
            pWnode->ProcessId       = pSystemHeader32->ProcessId;
            pWnode->KernelTime      = pSystemHeader32->KernelTime;
            pWnode->UserTime        = pSystemHeader32->UserTime;
            pWnode->Class.Type      = pSystemHeader32->Packet.Type;
            pWnode->Class.Version   = pSystemHeader32->Version;

            WmipCalculateCurrentTime( &pWnode->TimeStamp, 
                                      &pSystemHeader32->SystemTime,
                                      pContext );

            if (UseBasePtr) {
                pEvent->MofData = (PVOID) pHeader;
                pEvent->MofLength = pWnode->Size;
                if (UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
                    pSystemHeader32->SystemTime = pWnode->TimeStamp;
                }
            }
            else {
                pWnode->FieldTypeFlags = 0;
                if (pWnode->Size > sizeof(SYSTEM_TRACE_HEADER)) {
                    pEvent->MofData       = (PVOID) ((char*) pHeader +
                                                  sizeof(SYSTEM_TRACE_HEADER));
                    pEvent->MofLength = pWnode->Size - sizeof(SYSTEM_TRACE_HEADER); 
                }
            }
            break;
        }
        case TRACE_HEADER_TYPE_SYSTEM64:
        {
            PSYSTEM_TRACE_HEADER pSystemHeader64;
            pSystemHeader64 = (PSYSTEM_TRACE_HEADER) pHeader;

            nGroupType = pSystemHeader64->Packet.Group << 8;
            if ((nGroupType == EVENT_TRACE_GROUP_PROCESS) &&
                (pSystemHeader64->Packet.Type == EVENT_TRACE_TYPE_LOAD)) {
                nGroupType += pSystemHeader64->Packet.Type;
            }
            RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
            pWnode = (PEVENT_TRACE_HEADER) &pEvent->Header;
            pGuid = WmipGroupTypeToGuid(nGroupType);
            if (pGuid != NULL)
                RtlCopyMemory(&pWnode->Guid, pGuid, sizeof(GUID));
            pWnode->Size            = pSystemHeader64->Packet.Size;
            pWnode->ThreadId        = pSystemHeader64->ThreadId;
            pWnode->ProcessId       = pSystemHeader64->ProcessId;
            pWnode->KernelTime      = pSystemHeader64->KernelTime;
            pWnode->UserTime        = pSystemHeader64->UserTime;
            pWnode->Class.Type      = pSystemHeader64->Packet.Type;
            pWnode->Class.Version   = pSystemHeader64->Version;

            WmipCalculateCurrentTime( &pWnode->TimeStamp, 
                                      &pSystemHeader64->SystemTime,
                                      pContext );

            if (UseBasePtr) {
                pEvent->MofData = (PVOID) pHeader;
                pEvent->MofLength = pWnode->Size;
                if (UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
                    pSystemHeader64->SystemTime = pWnode->TimeStamp;
                }
            }
            else {
                pWnode->FieldTypeFlags = 0;
                if (pWnode->Size > sizeof(SYSTEM_TRACE_HEADER)) {

                    pEvent->MofData       = (PVOID) ((char*) pHeader +
                                                  sizeof(SYSTEM_TRACE_HEADER));
                    pEvent->MofLength = pWnode->Size - sizeof(SYSTEM_TRACE_HEADER);
                }
            }
            break;
        }
        case TRACE_HEADER_TYPE_FULL_HEADER:
        {
            pWnodeHeader = (PEVENT_TRACE_HEADER) pHeader;
            RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
            pWnode = (PEVENT_TRACE_HEADER) &pEvent->Header;
            RtlCopyMemory(pWnode,
                          pWnodeHeader, 
                          sizeof(EVENT_TRACE_HEADER)
                          );
            WmipCalculateCurrentTime( &pWnode->TimeStamp, 
                                      &pWnodeHeader->TimeStamp, 
                                      pContext );

            if (UseBasePtr) {
                pEvent->Header.Size = pWnodeHeader->Size;
                pEvent->MofData =  (PVOID)pHeader;
                pEvent->MofLength = pWnodeHeader->Size;
                if (UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
                    pWnodeHeader->TimeStamp = pWnode->TimeStamp;
                }
            }
            else {
            //
            // If the data came from Process Private Logger, then
            // mark the ProcessorTime field as valid
            //
                pEvent->Header.FieldTypeFlags = (PrivateLogger) ? EVENT_TRACE_USE_PROCTIME : 0;

                if (pWnodeHeader->Size > sizeof(EVENT_TRACE_HEADER)) {

                    pEvent->MofData = (PVOID) ((char*)pWnodeHeader +
                                                        sizeof(EVENT_TRACE_HEADER));
                    pEvent->MofLength = pWnodeHeader->Size - 
                                        sizeof(EVENT_TRACE_HEADER);
                }
            }
            break;
        }
        case TRACE_HEADER_TYPE_INSTANCE:
        {
            PEVENT_INSTANCE_HEADER pInstanceHeader;
            pInstanceHeader = (PEVENT_INSTANCE_HEADER) pHeader;
            RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
            pWnode = (PEVENT_TRACE_HEADER) &pEvent->Header;
            RtlCopyMemory(pWnode,
                          pInstanceHeader,
                          sizeof(EVENT_INSTANCE_HEADER)
                          );
            WmipCalculateCurrentTime( &pWnode->TimeStamp, 
                                      &pInstanceHeader->TimeStamp, 
                                      pContext );

            pEvent->InstanceId = pInstanceHeader->InstanceId;
            pEvent->ParentInstanceId = pInstanceHeader->ParentInstanceId;

            pGuid = WmipGuidMapHandleToGuid(&pContext->GuidMapListHead, pInstanceHeader->RegHandle);
            if (pGuid != NULL) {
              pEvent->Header.Guid = *pGuid;
            }
            else {
                RtlZeroMemory(&pEvent->Header.Guid, sizeof(GUID));
            }

            if (pInstanceHeader->ParentRegHandle != (ULONGLONG)0) {
                pGuid =  WmipGuidMapHandleToGuid(
                                            &pContext->GuidMapListHead, 
                                            pInstanceHeader->ParentRegHandle);
                if (pGuid != NULL) {
                    pEvent->ParentGuid = *pGuid;
                }
#ifdef DBG
                else {
                    WmipAssert(pGuid != NULL);
                }
#endif
            }


            if (UseBasePtr) {
                pEvent->Header.Size = pInstanceHeader->Size;
                pEvent->MofData =  (PVOID)pHeader;
                pEvent->MofLength = pInstanceHeader->Size;
                if (UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
                    pInstanceHeader->TimeStamp = pWnode->TimeStamp;
                }
            }
            else {
                pEvent->Header.FieldTypeFlags = (PrivateLogger) ? EVENT_TRACE_USE_PROCTIME : 0;
                if (pInstanceHeader->Size > sizeof(EVENT_INSTANCE_HEADER)) {

                    pEvent->MofData = (PVOID) ((char*)pInstanceHeader +
                                                sizeof(EVENT_INSTANCE_HEADER));
                    pEvent->MofLength = pInstanceHeader->Size -
                                        sizeof(EVENT_INSTANCE_HEADER);
                }
            }
            break;
        }
        case TRACE_HEADER_TYPE_TIMED:
        {
            PTIMED_TRACE_HEADER pTimedHeader;
            pTimedHeader = (PTIMED_TRACE_HEADER) pHeader;

            RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
            pWnode = (PEVENT_TRACE_HEADER) &pEvent->Header;
            pWnode->Size                = pTimedHeader->Size;
            pWnode->Version             = pTimedHeader->EventId;
            WmipCalculateCurrentTime( &pWnode->TimeStamp, 
                                      &pTimedHeader->TimeStamp,
                                      pContext );

            pWnode->ThreadId = -1;
            pWnode->ProcessId = -1;

            if (UseBasePtr) {
                pEvent->MofData =  (PVOID)pHeader;
                pEvent->MofLength = pTimedHeader->Size;
                if (UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
                    pTimedHeader->TimeStamp = pWnode->TimeStamp;
                }
            }
            else if (pWnode->Size > sizeof(TIMED_TRACE_HEADER)) {

                pEvent->MofData       = (PVOID) ((char*) pHeader +
                                              sizeof(TIMED_TRACE_HEADER));
                pEvent->MofLength = pWnode->Size - sizeof(TIMED_TRACE_HEADER);
            }
            pEvent->Header.FieldTypeFlags = EVENT_TRACE_USE_NOCPUTIME;
            break;
        }
        case TRACE_HEADER_TYPE_WNODE_HEADER:
        {
            PWNODE_HEADER pWnode = (PWNODE_HEADER) pHeader;
            RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
            RtlCopyMemory(&pEvent->Header,  pWnode,  sizeof(WNODE_HEADER));
            pEvent->MofData   = (PVOID) pWnode;
            pEvent->MofLength = pWnode->BufferSize;
            break;
        }
    case TRACE_HEADER_TYPE_MESSAGE:
        {
            PMESSAGE_TRACE pMsg = (PMESSAGE_TRACE) pHeader ;
            RtlZeroMemory(pEvent, sizeof(EVENT_TRACE));
            RtlCopyMemory(&pEvent->Header, pMsg, sizeof(MESSAGE_TRACE_HEADER)) ;
            if (UseBasePtr) {
                pEvent->MofData = (PVOID)pHeader;
                pEvent->MofLength = pMsg->MessageHeader.Size;
            }
            else {
                pEvent->MofData = (PVOID)&(pMsg->Data) ;
                pEvent->MofLength = pMsg->MessageHeader.Size - sizeof(MESSAGE_TRACE_HEADER) ;
            }
            break;
        }
        default:                            // Assumed to be REAL WNODE
            break;
        }

    return WmipSetDosError(ERROR_SUCCESS);
}



ULONG 
WmipGetNextEventOffsetType(
    PUCHAR pBuffer,
    ULONG Offset,    
    PULONG RetSize
    )
{
    ULONG    nSize;
    ULONG   TraceMarker;
    ULONG   TraceType = 0;


    PWMI_BUFFER_HEADER Header = (PWMI_BUFFER_HEADER)pBuffer;

    ULONG Alignment =  Header->ClientContext.Alignment;
    ULONG BufferSize = Header->Wnode.BufferSize;


    *RetSize = 0;

    //
    // Check for end of buffer (w/o End of Buffer Marker case...)
    //
    if ( Offset >= (BufferSize - sizeof(long)) ){
        return 0;
    }

    TraceMarker =  *((PULONG)(pBuffer + Offset));

    if (TraceMarker == 0xFFFFFFFF) {
        return 0;
    }

    if (TraceMarker & TRACE_HEADER_FLAG) {
    //
    // If the first bit is set, then it is either TRACE or PERF record.
    //
        if (TraceMarker & TRACE_HEADER_EVENT_TRACE) {   // One of Ours.
            TraceType = (TraceMarker & TRACE_HEADER_ENUM_MASK) >> 16;
            switch(TraceType) {
                //
                // ISSUE: Need to split the two so we can process cross platform.
                //        shsiao 03/22/2000
                //
                case TRACE_HEADER_TYPE_PERFINFO32:
                case TRACE_HEADER_TYPE_PERFINFO64:
                {
                    PUSHORT Size;
                    Size = (PUSHORT) (pBuffer + Offset + sizeof(ULONG));
                    nSize = *Size;
                    break;
                }
                case TRACE_HEADER_TYPE_SYSTEM32:
                case TRACE_HEADER_TYPE_SYSTEM64:
                {
                    PUSHORT Size;
                    Size = (PUSHORT) (pBuffer + Offset + sizeof(ULONG));
                    nSize = *Size;
                    break;
                }
                case TRACE_HEADER_TYPE_FULL_HEADER:
                case TRACE_HEADER_TYPE_INSTANCE:
                {
                   PUSHORT Size;
                   Size = (PUSHORT)(pBuffer + Offset);
                   nSize = *Size;
                   break;
                }
                default:
                {
                    return 0;
                }
            }

        } 

        else if ((TraceMarker & TRACE_HEADER_ULONG32_TIME) ==
                            TRACE_HEADER_ULONG32_TIME) {
            PUSHORT Size;
            Size = (PUSHORT) (pBuffer + Offset);
            nSize = *Size;
            TraceType = TRACE_HEADER_TYPE_TIMED;
        }
        else if ((TraceMarker & TRACE_HEADER_ULONG32) ==
                            TRACE_HEADER_ULONG32) {
            PUSHORT Size;
            Size = (PUSHORT) (pBuffer + Offset);
            nSize = *Size;
            TraceType = TRACE_HEADER_TYPE_ULONG32;
        }
        else if ((TraceMarker & TRACE_MESSAGE) ==
                                TRACE_MESSAGE) {
            PUSHORT Size;
            Size = (PUSHORT) (pBuffer + Offset) ;
            nSize = *Size;
            TraceType = TRACE_HEADER_TYPE_MESSAGE;
        }
        else {
            return 0;
        }
    }
    else {  // Must be WNODE_HEADER
        PUSHORT Size;
        Size = (PUSHORT) (pBuffer + Offset);
        nSize = *Size;
        TraceType = TRACE_HEADER_TYPE_WNODE_HEADER;
    }
    //
    // Check for End Of Buffer Marker
    //
    if (nSize == 0xFFFFFFFF) {
        return 0;
    }

    //
    // Check for larger than BufferSize
    //

    if (nSize >= BufferSize) {
        return 0;
    }
    if (Alignment != 0) {
        nSize = (ULONG) ALIGN_TO_POWER2(nSize, Alignment);
    }

    *RetSize = nSize;

    return TraceType;
}


ULONG
WmipReadGuidMapRecords(
    PEVENT_TRACE_LOGFILEW logfile,
    PVOID  pBuffer,
    BOOLEAN bLogFileHeader
    )
{
    PEVENT_TRACE pEvent;
    EVENT_TRACE EventTrace;
    ULONG BufferSize;
    ULONG Status;
    WMI_HEADER_TYPE HeaderType = WMIHT_NONE;
    ULONG Size;
    ULONG Offset;
    PTRACELOG_CONTEXT pContext = logfile->Context;

    Offset = sizeof(WMI_BUFFER_HEADER);

    while (TRUE) {
        pEvent = &EventTrace;
        RtlZeroMemory(pEvent, sizeof(EVENT_TRACE) );
        HeaderType = WmiGetTraceHeader(pBuffer, Offset, &Size);
        if ( (HeaderType == WMIHT_NONE) ||
             (HeaderType == WMIHT_WNODE) ||
             (Size == 0)
           ) {
                break;
        }
        Status = WmipParseTraceEvent(pContext, pBuffer, Offset, HeaderType, pEvent, sizeof(EVENT_TRACE));
        Offset += Size;

        if (IsEqualGUID(&pEvent->Header.Guid, &EventTraceGuid)
            && (pEvent->Header.Class.Type == EVENT_TRACE_TYPE_GUIDMAP))
        {
            WmipGuidMapCallback(&pContext->GuidMapListHead, pEvent);
            //
            // If we are processing the events in raw base pointer mode,
            // we fire callbacks for guid maps also. Note that only the
            // GuidMaps at the start of the file are triggered. The ones at the 
            // end are ignored. This is because the time order needs to be 
            // preserved when firing callbacks to the user.
            //
            if (bLogFileHeader && (pContext->ConversionFlags & EVENT_TRACE_GET_RAWEVENT)) {
               Status = WmipDoEventCallbacks( logfile, pEvent);
               if (Status != ERROR_SUCCESS) {
                   break;
               }
            }

        }
        else {
            if (bLogFileHeader) {
                Status = WmipDoEventCallbacks( logfile, pEvent);
                if (Status != ERROR_SUCCESS) {
                    break;
                }
            }
            else {
                return ERROR_INVALID_DATA;
            }
        }
    }
    return ERROR_SUCCESS;
}




ULONG
WmipProcessGuidMaps(
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    ULONG Unicode
    )
{
    long i;
    NTSTATUS Status;
    PTRACELOG_CONTEXT pContext;
    PEVENT_TRACE_LOGFILEW logfile;
    ULONG BuffersWritten;
    ULONG BufferSize, nBytesRead;
    ULONGLONG SizeWritten, ReadPosition;
    PVOID pBuffer;

    for (i=0; i<(long)LogfileCount; i++) {

        logfile = Logfiles[i];
        if (Logfiles[i]->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
            continue;
        }

        if (logfile->IsKernelTrace) {
            continue;
        }

        pContext = (PTRACELOG_CONTEXT) logfile->Context;
        if (pContext == NULL) {
            continue;
        }

        // 
        // We now start reading the GuidMaps at the end of file. 
        // 
        if (!(Logfiles[i]->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR))
        {
            pContext->fGuidMapRead = FALSE;
        }

        BuffersWritten = logfile->LogfileHeader.BuffersWritten; 
        BufferSize     = pContext->BufferSize;
        SizeWritten    = BuffersWritten * BufferSize;

        if (Logfiles[i]->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
            ULONGLONG maxFileSize = (logfile->LogfileHeader.MaximumFileSize 
                                     * 1024 * 1024);
            if ( (maxFileSize > 0) && (SizeWritten > maxFileSize) ) {
                SizeWritten = maxFileSize;
            }
        }

        pBuffer = WmipAlloc(BufferSize);
        if (pBuffer == NULL) {
            return WmipSetDosError(ERROR_OUTOFMEMORY);
        }


        RtlZeroMemory(pBuffer, BufferSize);

        ReadPosition = SizeWritten;
        while (TRUE) {
            if (!GetOverlappedResult(pContext->Handle, &pContext->AsynchRead, &nBytesRead, TRUE) &&
                GetLastError() != ERROR_HANDLE_EOF) {
                WmipDebugPrint(("GetOverlappedResult failed with Status %d in ProcessGuidMaps\n", GetLastError()));
                break;
            }
            pContext->AsynchRead.Offset = (DWORD)(ReadPosition & 0xFFFFFFFF);
            pContext->AsynchRead.OffsetHigh = (DWORD)(ReadPosition >> 32);
            Status = WmipSynchReadFile(pContext->Handle,
                            (LPVOID)pBuffer,
                            BufferSize,
                            &nBytesRead,
                            &pContext->AsynchRead);
            if (nBytesRead == 0) {
                break;
            }
            Status = WmipReadGuidMapRecords(Logfiles[i], pBuffer, FALSE);
            if (Status != ERROR_SUCCESS) {
                break;
//                WmipFree(pBuffer);
//                return Status;
            }
            ReadPosition += BufferSize;
        }

        //
        // End of File was reached. Now set the File Pointer back to 
        // the top of the file and process it. 

        pContext->StartBuffer = 0;
        ReadPosition = 0;
        while (TRUE) {
            BOOLEAN bLogFileHeader;
            if (!GetOverlappedResult(pContext->Handle, &pContext->AsynchRead, &nBytesRead, TRUE) &&
                GetLastError() != ERROR_HANDLE_EOF) {
                WmipDebugPrint(("GetOverlappedResult failed with Status %d in ProcessGuidMaps\n", GetLastError()));
                break;
            }
            pContext->AsynchRead.Offset = (DWORD)(ReadPosition & 0xFFFFFFFF);
            pContext->AsynchRead.OffsetHigh = (DWORD)(ReadPosition >> 32);
            Status = WmipSynchReadFile(pContext->Handle,
                            (LPVOID)pBuffer,
                            BufferSize,
                            &nBytesRead,
                            &pContext->AsynchRead);
            if (nBytesRead == 0) {
                break;
            }
            bLogFileHeader = (pContext->StartBuffer == 0);
            Status = WmipReadGuidMapRecords(Logfiles[i], pBuffer, bLogFileHeader );
            if (Status != ERROR_SUCCESS){
                break;
            }
            pContext->StartBuffer++;
            ReadPosition += BufferSize;
        }

        WmipFree(pBuffer);
    }
    return ERROR_SUCCESS;
}

ULONG
WmipGetBuffersWrittenFromQuery(
    LPWSTR LoggerName
    )
/*++

Routine Description:
    This routine returns the number of buffers written by querying a logger.
    In case of an array of LogFiles, this routine should be called individually for
    each one.

Arguments:
    LogFile - pointer to EVENT_TRACE_LOGFILEW under consideration
    Unicode - whether the logger name is in unicode or not

Returned Value:

    The number of buffers written.

--*/
{
    TRACEHANDLE LoggerHandle = 0;
    ULONG Status;
    RtlZeroMemory(&Properties, sizeof(Properties));
    Properties.TraceProp.Wnode.BufferSize = sizeof(Properties);

    Status = ControlTraceW(LoggerHandle,
                      LoggerName,
                      &Properties.TraceProp,
                      EVENT_TRACE_CONTROL_QUERY);

    if (Status == ERROR_SUCCESS) {
        return Properties.TraceProp.BuffersWritten;
    }
    else {
        SetLastError(Status);
        return 0;
    }
}

VOID
WmipCopyLogHeader (
    IN PTRACE_LOGFILE_HEADER pOutHeader,
    IN PVOID MofData,
    IN ULONG MofLength,
    IN PWCHAR *LoggerName,
    IN PWCHAR *LogFileName,
    IN ULONG  Unicode
    )
{
    PUCHAR Src, Dest;

    PTRACE_LOGFILE_HEADER pInHeader;
    ULONG PointerSize;
    ULONG SizeToCopy;
    ULONG Offset;

    pInHeader = (PTRACE_LOGFILE_HEADER) MofData; 
    PointerSize = pInHeader->PointerSize;   // This is the PointerSize in File

    if ( (PointerSize != 4) && (PointerSize != 8) ) {
#ifdef DBG
    WmipDebugPrint(("WMI: Invalid PointerSize in File %d\n",PointerSize));
#endif
        return;
    }

    //
    // We have Two pointers (LPWSTR) in the middle of the LOGFILE_HEADER
    // structure. So We copy upto the Pointer Fields first, skip over
    // the pointers and copy the remaining stuff. We come back and fixup 
    // the pointers appropriately. 
    //

    SizeToCopy = FIELD_OFFSET(TRACE_LOGFILE_HEADER, LoggerName);

    RtlCopyMemory(pOutHeader, pInHeader, SizeToCopy);

    //
    // Skip over the Troublesome pointers in both Src and Dest
    //

    Dest = (PUCHAR)pOutHeader  + SizeToCopy + 2 * sizeof(LPWSTR);

    Src = (PUCHAR)pInHeader + SizeToCopy + 2 * PointerSize;

    //
    // Copy the Remaining fields at the tail end of the LOGFILE_HEADER 
    //

    SizeToCopy =  sizeof(TRACE_LOGFILE_HEADER)  -
                  FIELD_OFFSET(TRACE_LOGFILE_HEADER, TimeZone);

    RtlCopyMemory(Dest, Src, SizeToCopy); 

    //
    // Adjust the pointer fields now
    //
    Offset =  sizeof(TRACE_LOGFILE_HEADER) - 
              2 * sizeof(LPWSTR)           + 
              2 * PointerSize;

    *LoggerName  = (PWCHAR) ((PUCHAR)pInHeader + Offset);
    pOutHeader->LoggerName = *LoggerName;

}

ULONG
WmipProcessLogHeader(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    ULONG Unicode,
    ULONG bFree
    )
/*++

Routine Description:
    This routine processes the header of an array of logfiles. 

Arguments:

    LogFile                     Array of Logfiles being processed.
        LogFileCount    Number of Logfiles in the Array. 
    Unicode                     Unicode Flag.

Returned Value:

    Status Code.

--*/
{
    HANDLE hFile;
    PTRACELOG_CONTEXT pContext = NULL;
    PVOID pBuffer;
    PEVENT_TRACE pEvent;
    long i;
    WMI_HEADER_TYPE HeaderType = WMIHT_NONE;
    ULONG Size;
    ULONG Offset;
    LPWSTR loggerName, logFileName;
    ULONG BufferSize, nBytesRead;
    PTRACE_LOGFILE_HEADER logfileHeader;
    ULONG Status = ERROR_SUCCESS;


    //
    // Open the Log File for shared Read
    //
    BufferSize = DEFAULT_LOG_BUFFER_SIZE;  // Log file header must be smaller than 1K

    pBuffer = WmipAlloc(BufferSize);
    if (pBuffer == NULL) {
        return WmipSetDosError(ERROR_OUTOFMEMORY);
    }


    for (i=0; i<(long)LogfileCount; i++) {
        EVENT_TRACE EventTrace;
        ULONG SavedConversionFlags;
        OVERLAPPED LogHeaderOverlapped;
        //
        // Caller can pass in Flags to fetch the timestamps in raw mode.
        // Since LogFileHeader gets overwritten from with data from the logfile
        // we need to save the passed in value here. 
        //

        SavedConversionFlags = Logfiles[i]->LogfileHeader.ReservedFlags;
        if (Unicode) {
            hFile = CreateFileW(
                        (LPWSTR) Logfiles[i]->LogFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                        NULL
                        );
        }
        else {
            hFile = CreateFileA(
                        (LPSTR) Logfiles[i]->LogFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                        NULL
                        );
        }

        if (hFile == INVALID_HANDLE_VALUE) {
            Status = WmipSetDosError(ERROR_BAD_PATHNAME);
            break;
        }

        BufferSize = DEFAULT_LOG_BUFFER_SIZE; 
        RtlZeroMemory(pBuffer, BufferSize);

        LogHeaderOverlapped.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
        if (LogHeaderOverlapped.hEvent == NULL) {
            // cannot create event for file read
            break;
        }
        LogHeaderOverlapped.Offset = 0;
        LogHeaderOverlapped.OffsetHigh = 0;
        Status = WmipSynchReadFile(hFile,
                        (LPVOID)pBuffer,
                        BufferSize,
                        &nBytesRead,
                        &LogHeaderOverlapped);
        if (nBytesRead == 0) {
            NtClose(hFile);
            Status = WmipSetDosError(ERROR_FILE_CORRUPT);
            break;
        }
        CloseHandle(LogHeaderOverlapped.hEvent);

        Offset = sizeof(WMI_BUFFER_HEADER);

        pEvent = &EventTrace;
        RtlZeroMemory(pEvent, sizeof(EVENT_TRACE) );
        HeaderType = WmiGetTraceHeader(pBuffer, Offset, &Size);
        if ( (HeaderType == WMIHT_NONE) ||
             (HeaderType == WMIHT_WNODE) ||
             (Size == 0) 
           ) {
                NtClose(hFile);
                Status = WmipSetDosError(ERROR_FILE_CORRUPT);
                break;
        }
        Status = WmipParseTraceEvent(NULL, pBuffer, Offset, HeaderType, pEvent, sizeof(EVENT_TRACE));

        //
        // Set up the header structure properly
        //
        if ((Status == ERROR_SUCCESS) && (pEvent->MofLength > 0)) {
            ULONG PointerSize;

            logfileHeader = &Logfiles[i]->LogfileHeader;

            //
            // We are relying on the fact that the PointerSize field
            // will not shift between platforms. 
            //

            PointerSize = ((PTRACE_LOGFILE_HEADER)(pEvent->MofData))->PointerSize;

            if (PointerSize == sizeof(PUCHAR) ) {

                RtlCopyMemory(&Logfiles[i]->LogfileHeader, pEvent->MofData,
                              sizeof(TRACE_LOGFILE_HEADER));
    
                loggerName = (LPWSTR) ( (char*)pEvent->MofData +
                                        sizeof(TRACE_LOGFILE_HEADER) );

//              logFileName = (LPWSTR) ( (char*)pEvent->MofData +
//                                        sizeof(TRACE_LOGFILE_HEADER) +
//                                      sizeof(WCHAR)* wcslen(loggerName));
            }
            else {

                //
                // Ugly thunking going on here. Close your eyes...
                //

                WmipCopyLogHeader(&Logfiles[i]->LogfileHeader, 
                                        pEvent->MofData, 
                                        pEvent->MofLength,
                                        &loggerName, 
                                        &logFileName, 
                                        Unicode);
                pEvent->MofData = (PVOID)&Logfiles[i]->LogfileHeader;
            }
        }
        else {
            NtClose(hFile);
            Status = WmipSetDosError(ERROR_FILE_CORRUPT);
            break;
        }

        Logfiles[i]->IsKernelTrace = !wcscmp(loggerName, KERNEL_LOGGER_CAPTION);

        Logfiles[i]->LogFileMode = (logfileHeader->LogFileMode &
                                ~(EVENT_TRACE_REAL_TIME_MODE));

#ifdef DBG
        DbgPrint("Dumping Logfile Header\n");
        DbgPrint("\tStart Time           %I64u\n",
                       pEvent->Header.TimeStamp);
        DbgPrint("\tLogger Thread Id     %X\n",
                        pEvent->Header.ThreadId);
        DbgPrint("\tHeader Size          %d\n",
                        pEvent->Header.Size);
        DbgPrint("\tBufferSize           %d\n",
                        logfileHeader->BufferSize);
        DbgPrint("\tVersion              %d\n",
                        logfileHeader->Version);
        DbgPrint("\tProviderVersion      %d\n",
                        logfileHeader->ProviderVersion);
        DbgPrint("\tEndTime              %I64u\n",
                        logfileHeader->EndTime);
        DbgPrint("\tTimer Resolution     %d\n",
                        logfileHeader->TimerResolution);
        DbgPrint("\tMaximum File Size    %d\n",
                        logfileHeader->MaximumFileSize);
        DbgPrint("\tBuffers  Written     %d\n",
                        logfileHeader->BuffersWritten);
        DbgPrint("\tEvents  Lost     %d\n",
                        logfileHeader->EventsLost);
        DbgPrint("\tBuffers  Lost     %d\n",
                        logfileHeader->BuffersLost);
        DbgPrint("\tStart Buffers%d\n",
                        logfileHeader->StartBuffers);
        DbgPrint("\tReserved Flags   %x\n",
                        logfileHeader->ReservedFlags);
        DbgPrint("\tFrequency %I64u\n",
                        logfileHeader->PerfFreq.QuadPart);
        DbgPrint("\tLogger Name          %ls\n",
                        loggerName);
        DbgPrint("\tStartTime          %I64u\n",
                        logfileHeader->StartTime.QuadPart);
//        DbgPrint("\tLogfile Name         %ls\n",
//                        logFileName);

        DbgPrint("\tLogfile Mode         %X\n",
                        logfileHeader->LogFileMode);
        DbgPrint("\tProcessorCount          %d\n",
                        logfileHeader->NumberOfProcessors);
#endif
        if (Logfiles[i]->IsKernelTrace)
            WmipDebugPrint(("\tLogfile contains kernel trace\n"));

        BufferSize = logfileHeader->BufferSize;

        WmipAssert(BufferSize > 0);

        if ( (BufferSize/1024 == 0) ||
             (((BufferSize/1024)*1024) != BufferSize)  ) {
            NtClose(hFile);
            Status = WmipSetDosError(ERROR_FILE_CORRUPT);
            break;
        }


        if (Logfiles[i]->IsKernelTrace)
            WmipDebugPrint(("\tLogfile contains kernel trace\n"));

        if  (bFree) {
            NtClose(hFile);
        }
        else {
            //
            // At this point, the logfile is opened successfully
            // Initialize the internal context now
            //
            pContext = WmipLookupTraceHandle(HandleArray[i]);
            if (pContext == NULL) {
                NtClose(hFile); 
// TODO: Find an appropriate eerror code here?
                Status = WmipSetDosError(ERROR_OUTOFMEMORY);
                break;
            }

            Logfiles[i]->Context = pContext;
            pContext->Handle = hFile;


            //
            // If the EndTime is 0, then compute the BuffersWritten from
            // FileSize and BufferSize. 
            //
            // However, an on-going session with a preallocated log file 
            // will use QueryTrace() to get BuffersWritten.
            //
            if (logfileHeader->EndTime.QuadPart == 0) {
                if (logfileHeader->LogFileMode & EVENT_TRACE_FILE_MODE_PREALLOCATE) {
                    ULONG QueriedBuffersWritten = WmipGetBuffersWrittenFromQuery(loggerName);

                    if (QueriedBuffersWritten) {
                         logfileHeader->BuffersWritten = QueriedBuffersWritten;
                    }
                }
                else {
                    FILE_STANDARD_INFORMATION FileInfo;
                    NTSTATUS NtStatus;
                    IO_STATUS_BLOCK           IoStatus;

                    NtStatus = NtQueryInformationFile(
                                                hFile,
                                                &IoStatus,
                                                &FileInfo,
                                                sizeof(FILE_STANDARD_INFORMATION),
                                                FileStandardInformation
                                                );
                    if (NT_SUCCESS(NtStatus)) {
                        ULONG64 FileSize = FileInfo.AllocationSize.QuadPart; 
                        ULONG64 BuffersWritten = FileSize / (ULONG64) BufferSize;
                        logfileHeader->BuffersWritten = (ULONG) BuffersWritten;
                    }
                }
            }

            pContext->BufferCount = logfileHeader->BuffersWritten;
            pContext->BufferSize =  logfileHeader->BufferSize;
            pContext->InitialSize = Size;



            //
            // Save the flags from OpenTrace at this time before the first
            // buffer callback which will erase it.
            //

            pContext->ConversionFlags = SavedConversionFlags;


            //
            // Make the header the current Event   ...
            // and the callbacks for the header are handled by ProcessTraceLog. 

            pContext->UsePerfClock = logfileHeader->ReservedFlags;
            pContext->StartTime = logfileHeader->StartTime;
            pContext->PerfFreq = logfileHeader->PerfFreq;
            pContext->CpuSpeedInMHz = logfileHeader->CpuSpeedInMHz;

            //
            // If the conversion flags are set, adjust UsePerfClock accordingly.
            //
            if (pContext->ConversionFlags & EVENT_TRACE_USE_RAWTIMESTAMP) {
                pContext->UsePerfClock = EVENT_TRACE_CLOCK_RAW;
            }

            if ((pContext->UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) ||
                (pContext->UsePerfClock == EVENT_TRACE_CLOCK_CPUCYCLE) ) {
                pContext->StartPerfClock = pEvent->Header.TimeStamp;
                Logfiles[i]->CurrentTime    = pContext->StartTime.QuadPart;
                pEvent->Header.TimeStamp.QuadPart = pContext->StartTime.QuadPart;
            }
            else {
                Logfiles[i]->CurrentTime = pEvent->Header.TimeStamp.QuadPart;
            }
        }
    }

    WmipFree(pBuffer);
    return Status;
}

ULONG
WmipDoEventCallbacks( 
    PEVENT_TRACE_LOGFILEW logfile, 
    PEVENT_TRACE pEvent
    )
{
    NTSTATUS Status;
    PEVENT_TRACE_CALLBACK pCallback;

    //
    // First the Generic Event Callback is called.
    //
    if ( logfile->EventCallback ) {
        try {
            (*logfile->EventCallback)(pEvent);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
#ifdef DBG
            WmipDebugPrint(("TRACE: EventCallback threw exception %X\n",
                                Status));
#endif
            return WmipSetDosError(WmipNtStatusToDosError(Status));
        }
    }

    //
    // Now Call the event specific callback.
    //
    pCallback = WmipGetCallbackRoutine( &pEvent->Header.Guid );
    if ( pCallback != NULL ) {
        try {
            (*pCallback->CallbackRoutine)(pEvent);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
#ifdef DBG
            WmipDebugPrint(("EventCallback %X threw exception %X\n",
                       pCallback->CallbackRoutine, Status));
#endif

            return WmipSetDosError(WmipNtStatusToDosError(Status));
        }
    }
    logfile->CurrentTime = pEvent->Header.TimeStamp.QuadPart;
    return ERROR_SUCCESS;
}


ULONG 
WmipAdvanceToNewEvent(
    PEVENT_TRACE_LOGFILEW logfile,
    BOOL EventInRange
    )
{
    ULONG Status = ERROR_SUCCESS;
    PEVENT_TRACE pEvent;
    PTRACELOG_CONTEXT pContext;
    PVOID pBuffer;
    PTRACE_BUFFER_LIST_ENTRY Current;
    ULONG Size;
    WMI_HEADER_TYPE HeaderType = WMIHT_NONE; 

    pContext = logfile->Context;
    if (pContext == NULL) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }
 
    Current = WmipRemoveBuffer(&pContext->Root);
    if (Current == NULL)  {
        pContext->EndOfFile = TRUE;
        return ERROR_SUCCESS;
    }

    //
    // Advance Event for current buffer
    //
    pEvent = &Current->Event;

    //
    // Before we make the callbacks, we need to restore the 
    // raw buffer, so that MofData will be pointing to the right data.
    //
    pBuffer = WmipGetCurrentBuffer(pContext, Current);
    if (pBuffer == NULL) {
        //
        // This condition could happen when the file we are reading 
        // gets overwritten.
        //
        return ERROR_SHARING_VIOLATION;
    }
  
    if (EventInRange) {
        Status = WmipDoEventCallbacks( logfile, pEvent);
        if (Status != ERROR_SUCCESS) {
            return Status;
        }
    }

    Size = 0;
    if ((HeaderType = WmiGetTraceHeader(pBuffer, Current->BufferOffset, &Size)) != WMIHT_NONE) {
        if (Size > 0) {
            Status = WmipParseTraceEvent(pContext, pBuffer, Current->BufferOffset, HeaderType, pEvent, sizeof(EVENT_TRACE));
            Current->BufferOffset += Size;
            Current->TraceType = WmipConvertEnumToTraceType(HeaderType);
        }
    }
    Current->EventSize = Size;

    if ( ( Size > 0) && (Status == ERROR_SUCCESS) ) {
        WmipInsertBuffer(&pContext->Root, Current);
    }
    else {
        DWORD BytesTransffered;
        //
        // When the current buffer is exhausted, make the 
        // BufferCallback
        //
        if (logfile->BufferCallback) {
            ULONG bRetVal;
            PWMI_BUFFER_HEADER pHeader = (PWMI_BUFFER_HEADER)pBuffer;
            logfile->Filled     = (ULONG)pHeader->Offset;
            logfile->EventsLost = pHeader->EventsLost;
            try {
                bRetVal = (*logfile->BufferCallback) (logfile);
                if (!bRetVal) {
                    return ERROR_CANCELLED;
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                pContext->EndOfFile = TRUE;        
                Status = GetExceptionCode();
#ifdef DBG
                WmipDebugPrint(("TRACE: BufferCallback threw exception %X\n",
                                        Status));
#endif
                WmipSetDosError(WmipNtStatusToDosError(Status));
                return ERROR_CANCELLED; // so that realtime also cleans up.
            }
        }
        //
        // Issue another asynch read on this buffer cache slot if there are no outstanding reads
        // at this point.
        // GetOverlappedResult() returns FALSE if IO is still pending.
        //
        if (pContext->BufferBeingRead == -1 || 
            GetOverlappedResult(pContext->Handle, &pContext->AsynchRead, &BytesTransffered, FALSE)) {

            LONG FileOffset = Current->FileOffset + MAX_TRACE_BUFFER_CACHE_SIZE;
            if ((ULONG)FileOffset < pContext->BufferCount) {
                ULONGLONG Offset = FileOffset * pContext->BufferSize;
                ResetEvent(pContext->AsynchRead.hEvent);
                pContext->AsynchRead.Offset = (DWORD)(Offset & 0xFFFFFFFF);
                pContext->AsynchRead.OffsetHigh = (DWORD)(Offset >> 32);

                Status = ReadFile(pContext->Handle,
                            (LPVOID)pBuffer,
                            pContext->BufferSize,
                            NULL,
                            &pContext->AsynchRead);
                if (Status || GetLastError() == ERROR_IO_PENDING) {
                    ULONG TableIndex = FileOffset % MAX_TRACE_BUFFER_CACHE_SIZE;
                    pContext->BufferBeingRead = FileOffset;
                    pContext->BufferCache[TableIndex].Index = FileOffset;
                }
                else { // Issuing asynch IO failed. Not a fatal error. Just continue for now.
                    SetEvent(pContext->AsynchRead.hEvent);
                    pContext->BufferBeingRead = -1;
                }
            }
        }
    }
    //
    // The File reaches end of file when the Root is NULL
    //
    if (pContext->Root == NULL) {
        pContext->EndOfFile = TRUE;
    }
    else {
        logfile->CurrentTime = pContext->Root->Event.Header.TimeStamp.QuadPart;
    }

    return ERROR_SUCCESS;
}


ULONG 
WmipBuildEventTable(
    PTRACELOG_CONTEXT pContext
    )
{
    ULONG i, nBytesRead;
    PVOID pBuffer;
    ULONG BufferSize = pContext->BufferSize;
    PEVENT_TRACE pEvent;
    ULONG TotalBuffersRead;
    NTSTATUS Status;
    ULONGLONG ReadPosition;


    //
    // File is already open.
    // Reset the file pointer and continue. 
    // TODO: If we start at bottom of file and insert
    // it might be more efficient. 
    //
    ReadPosition = pContext->StartBuffer * BufferSize;
    TotalBuffersRead = pContext->StartBuffer;

    //
    // If there are no other buffers except header and guidmaps, EOF is true
    //

    if (TotalBuffersRead == pContext->BufferCount) {
        pContext->EndOfFile = TRUE;
        pContext->Root = NULL;
        return ERROR_SUCCESS;
    }

    do {
        WMI_HEADER_TYPE HeaderType = WMIHT_NONE;
        ULONG Size;
        ULONG Offset;
        ULONG TableIndex;

        TableIndex = TotalBuffersRead % MAX_TRACE_BUFFER_CACHE_SIZE ; 
        pBuffer = pContext->BufferCache[TableIndex].Buffer;

        if (!GetOverlappedResult(pContext->Handle, &pContext->AsynchRead, &nBytesRead, TRUE) &&
            GetLastError() != ERROR_HANDLE_EOF) {
            WmipDebugPrint(("GetOverlappedResult failed with Status %d in BuildEventTable\n", GetLastError()));
            break;
        }
        pContext->AsynchRead.Offset = (DWORD)(ReadPosition & 0xFFFFFFFF);
        pContext->AsynchRead.OffsetHigh = (DWORD)(ReadPosition >> 32);

        Status = WmipSynchReadFile(pContext->Handle,
                  (LPVOID)pBuffer,
                  BufferSize,
                  &nBytesRead,
                  &pContext->AsynchRead);

        if (nBytesRead == 0)
            break;

        ReadPosition += BufferSize;
        Offset = sizeof(WMI_BUFFER_HEADER);

        pEvent = &pContext->BufferList[TotalBuffersRead].Event;

        HeaderType = WmiGetTraceHeader(pBuffer, Offset, &Size);
        if ( (HeaderType == WMIHT_NONE) || (HeaderType == WMIHT_WNODE) || (Size == 0) ) {
            TotalBuffersRead++;
            continue;
        }
        Status = WmipParseTraceEvent(pContext, pBuffer, Offset, HeaderType, pEvent, sizeof(EVENT_TRACE));

        //
        // Set up the header structure properly
        //
        if (Status != ERROR_SUCCESS) {
            TotalBuffersRead++;
            continue;
        }

        Offset += Size;
        pContext->BufferList[TotalBuffersRead].BufferOffset = Offset;
        pContext->BufferList[TotalBuffersRead].FileOffset = TotalBuffersRead;
        pContext->BufferList[TotalBuffersRead].EventSize = Size;
        pContext->BufferList[TotalBuffersRead].TraceType = WmipConvertEnumToTraceType(HeaderType);
        WmipInsertBuffer(&pContext->Root, &pContext->BufferList[TotalBuffersRead]);

        TotalBuffersRead++;
        if (TotalBuffersRead >= pContext->BufferCount)  {
            break;
        }
    } while (1); 

    return ERROR_SUCCESS;
}


ULONG
WmipProcessTraceLog(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    LONGLONG StartTime,
    LONGLONG EndTime,
    ULONG   Unicode
    )
/*++

Routine Description:
    This routine processes an array of traces (from file or realtime input 
    stream). If the trace is from a file, goes through each event till the 
    end of file, firing event callbacks (if any) along the way. If the trace
    is from realtime, it waits for event notification about buffer delivery 
    from the realtime callback and processes the buffer delivered in the 
    same way. It handles circular logfiles and windowing of data (with the 
    given start and end times) correctly. When more than one trace it
    provides the callback in chronological order. 

Arguments:

    Logfiles        Array of traces
    LogfileCount    Number of traces
    StartTime       Starting Time of the window of analysis
    EndTime         Ending Time of the window of analysis
    Unicode         Unicode Flag. 

Returned Value:

    Status Code.

--*/
{
    PEVENT_TRACE_LOGFILE logfile;
    ULONG Status;
    PEVENT_TRACE pEvent;
    PTRACELOG_CONTEXT pContext;
    EVENT_TRACE_PROPERTIES Properties;
    ULONG RealTimeDataFeed, LogFileDataFeed;
    USHORT LoggerId;
    TRACEHANDLE LoggerHandle = 0;
    ULONG i, j;
    BOOL Done = FALSE;
    ACCESS_MASK DesiredAccess = TRACELOG_ACCESS_REALTIME;

//    ContextListHeadPtr = &ContextListHead;
//    InitializeListHead(ContextListHeadPtr);

    Status = WmipCreateGuidMapping();
    if (Status != ERROR_SUCCESS) {
        return Status;
    }

    // 
    // After reading the First Buffer, determine the BufferSize, 
    // Number of Buffers written, filesize, kernel or non-kernel logger
    // Set a flag to strip out the GuidMap at the end. 
    //

    Status = WmipProcessLogHeader( HandleArray, Logfiles, LogfileCount, Unicode, FALSE );
    if (Status != ERROR_SUCCESS) {
        goto Cleanup;
    }
    Status = WmipProcessGuidMaps( Logfiles, LogfileCount, Unicode );
    if (Status != ERROR_SUCCESS) {
        goto Cleanup;
    }

    // 
    // Set up storage 
    //
    for (i=0; i < LogfileCount; i++) {
       ULONG BufferSize, BufferCount;
       ULONG SizeNeeded;
       PUCHAR Space;
       PTRACE_BUFFER_LIST_ENTRY Current;


       pContext = (PTRACELOG_CONTEXT)Logfiles[i]->Context;

       BufferSize = pContext->BufferSize; 
       BufferCount = pContext->BufferCount;

       SizeNeeded = BufferCount * sizeof(TRACE_BUFFER_LIST_ENTRY);
       pContext->BufferList = WmipMemCommit( NULL, SizeNeeded );

       if (pContext->BufferList == NULL) {
            Status = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }

        RtlZeroMemory(pContext->BufferList, SizeNeeded);

        //
        // Allocate Buffer Cache
        //
        SizeNeeded = MAX_TRACE_BUFFER_CACHE_SIZE * BufferSize;
        Space = WmipMemCommit( NULL, SizeNeeded );
        if (Space == NULL) {
            Status = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }

        for (j=0; j<MAX_TRACE_BUFFER_CACHE_SIZE; j++) {
           pContext->BufferCache[j].Index = -1;
           pContext->BufferCache[j].Buffer = (PVOID)(Space + j * BufferSize); 
       }
       pContext->BufferCacheSpace = Space;
       Status = WmipBuildEventTable(pContext);
       if (Status != ERROR_SUCCESS) {
            goto Cleanup;
       }


       Current = pContext->Root;
       if (Current != NULL) {
          Logfiles[i]->CurrentTime = Current->Event.Header.TimeStamp.QuadPart;
       }
       else {
          pContext->EndOfFile = TRUE;
       }
   }

   // 
   // Make the Second Pass and get the events. 
   //

#ifdef DBG
    WmipDumpCallbacks();
#endif
   while (!Done) {
        LONGLONG nextTimeStamp;
        BOOL EventInRange;
        //
        // Check to see if end of file has been reached on all the 
        // files.
        //

        logfile = NULL;
        nextTimeStamp = 0;

        for (j=0; j < LogfileCount; j++) {
           pContext = (PTRACELOG_CONTEXT)Logfiles[j]->Context;

           if (pContext->EndOfFile)
                continue;
           if (nextTimeStamp == 0) {
               nextTimeStamp = Logfiles[j]->CurrentTime;
               logfile = Logfiles[j];
           }
           else if (nextTimeStamp > Logfiles[j]->CurrentTime) {
               nextTimeStamp = Logfiles[j]->CurrentTime;
               logfile = Logfiles[j];
           }
        }

        if (logfile == NULL) {
            break;
        }
        //
        // if the Next event timestamp is not within the window of
        // analysis, we do not fire the event callbacks. 
        //

        EventInRange = TRUE;

        if ((StartTime != 0) && (StartTime > nextTimeStamp))
            EventInRange = FALSE;
        if ((EndTime != 0) && (EndTime < nextTimeStamp))
            EventInRange = FALSE;

        //
        // Now advance to next event. 
        //

        Status = WmipAdvanceToNewEvent(logfile, EventInRange);
        Done = (Status == ERROR_CANCELLED);
    }
Cleanup:
    for (i=0; i < LogfileCount; i++) {
        pContext = (PTRACELOG_CONTEXT)Logfiles[i]->Context;
        if (pContext != NULL) {
            WmipCleanupTraceLog(pContext);
        }
    }
    return Status;

}


ULONG
WmipCopyLogfileInfo(
                    PTRACELOG_CONTEXT HandleEntry,
                    PEVENT_TRACE_LOGFILEW   Logfile,
                    ULONG Unicode
                    )
{
    ULONG bufSize;
    PWCHAR ws;
    //
    // Allocate LogfileName and LoggerName as well
    //
    RtlCopyMemory(&HandleEntry->Logfile,
                  Logfile,
                  sizeof(EVENT_TRACE_LOGFILEW));

    HandleEntry->Logfile.LogFileName = NULL;
    HandleEntry->Logfile.LoggerName = NULL;    

    if (Logfile->LogFileName != NULL) {
        if (Unicode) 
            bufSize = (wcslen(Logfile->LogFileName) + 1) * sizeof(WCHAR);
        else 
            bufSize = (strlen((PUCHAR)(Logfile->LogFileName)) + 1)
                      * sizeof(WCHAR);
        
        ws = WmipAlloc( bufSize );
        if (ws == NULL)
            return ERROR_OUTOFMEMORY;

        if (Unicode) {
            wcscpy(ws, Logfile->LogFileName);
        }
        else {
            MultiByteToWideChar(CP_ACP, 
                                0, 
                                (LPCSTR)Logfile->LogFileName, 
                                -1, 
                                (LPWSTR)ws, 
                                bufSize);
        }
        HandleEntry->Logfile.LogFileName = ws;
    }
    if (Logfile->LoggerName != NULL) {
        if (Unicode)
            bufSize = (wcslen(Logfile->LoggerName) + 1) * sizeof(WCHAR);
        else
            bufSize = (strlen((PUCHAR)(Logfile->LoggerName)) + 1) 
                      * sizeof(WCHAR);

        ws = WmipAlloc( bufSize );
        if (ws == NULL)
            return ERROR_OUTOFMEMORY;

        if (Unicode)
            wcscpy(ws, Logfile->LoggerName);
        else {
           MultiByteToWideChar(CP_ACP,
                               0,
                               (LPCSTR)Logfile->LoggerName,
                               -1,
                               (LPWSTR)ws,
                               bufSize);
        }
        HandleEntry->Logfile.LoggerName = ws;
    }
    return ERROR_SUCCESS;
}



TRACEHANDLE
WMIAPI
OpenTraceA(
    IN PEVENT_TRACE_LOGFILEA Logfile
    )
/*++

Routine Description:
    This is the  Ansi version of the ProcessTracelogHeader routine.


Arguments:

    LogFile     Trace Input



Returned Value:

    TraceHandle

--*/
{
    ULONG status = ERROR_INVALID_PARAMETER;
    PTRACELOG_CONTEXT HandleEntry = NULL;
    TRACEHANDLE TraceHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;

    WmipInitProcessHeap();

    if (Logfile != NULL) {
        HandleEntry = WmipAllocateTraceHandle();
        if (HandleEntry == NULL) {
            status = ERROR_OUTOFMEMORY;
        }
        else {
            //
            // Copy the LogFileStructure over. Converts strings to Unicode
            //
            TraceHandle = HandleEntry->TraceHandle;
            try {
                status = WmipCopyLogfileInfo(
                                             HandleEntry,
                                             (PEVENT_TRACE_LOGFILEW)Logfile,
                                             FALSE
                                            );
                if (status == ERROR_SUCCESS) {
                    //
                    // For RealTime, handle is a place holder until ProcessTrace.
                    //
                    if ( (Logfile->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) 
                                               != EVENT_TRACE_REAL_TIME_MODE ) {
                        status = WmipCreateGuidMapping();
                        if (status == ERROR_SUCCESS) {
                            status = WmipProcessLogHeader(
                                                          &HandleEntry->TraceHandle, 
                                                          (PEVENT_TRACE_LOGFILEW*)&Logfile, 
                                                          1, 
                                                          FALSE, 
                                                          TRUE
                                                         );
                        }
                    }
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                status = WmipNtStatusToDosError( GetExceptionCode() );
            }
        }
    }

    if ( (status != ERROR_SUCCESS) && (HandleEntry != NULL) ) {
        WmipFreeTraceHandle(TraceHandle);
        TraceHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;
    }

    WmipSetDosError(status);
    return TraceHandle;
}

TRACEHANDLE
WMIAPI
OpenTraceW(
    IN PEVENT_TRACE_LOGFILEW Logfile
    )
/*++

Routine Description:
    This routine processes a trace input and returns the tracelog header.
    Only for logfiles. For realtime traces, the header may not be available.

Arguments:

    Logfile     Trace input.



Returned Value:

    Pointer to Tracelog header.

--*/
{
    ULONG status = ERROR_INVALID_PARAMETER;
    PTRACELOG_CONTEXT HandleEntry = NULL;
    TRACEHANDLE TraceHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;

    WmipInitProcessHeap();

    if (Logfile != NULL) {
        HandleEntry = WmipAllocateTraceHandle();
        if (HandleEntry == NULL) {
            status = ERROR_OUTOFMEMORY;
        }
        else {
            TraceHandle = HandleEntry->TraceHandle;
            try {
                status = WmipCopyLogfileInfo(
                                             HandleEntry,
                                             (PEVENT_TRACE_LOGFILEW)Logfile,
                                             TRUE
                                            );
                if (status == ERROR_SUCCESS) {
                    if ( (Logfile->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) 
                                               != EVENT_TRACE_REAL_TIME_MODE ) {
                        status = WmipCreateGuidMapping();
                        if (status == ERROR_SUCCESS) {
                            status = WmipProcessLogHeader(
                                                          &HandleEntry->TraceHandle,
                                                          (PEVENT_TRACE_LOGFILEW*)&Logfile,
                                                          1,
                                                          TRUE,
                                                          TRUE
                                                         );
                        }
                    }
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                status = WmipNtStatusToDosError( GetExceptionCode() );
            }
        }
    }

    if ( (status != ERROR_SUCCESS) && (HandleEntry != NULL) ) {
        WmipFreeTraceHandle(TraceHandle);
        TraceHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;
    }

    WmipSetDosError(status);
    return TraceHandle;
}

ULONG
WMIAPI
ProcessTrace(
    IN PTRACEHANDLE HandleArray,
    IN ULONG   HandleCount,
    IN LPFILETIME StartTime,
    IN LPFILETIME EndTime
    )
{

    PEVENT_TRACE_LOGFILEW Logfiles[MAXLOGGERS];
    PLIST_ENTRY Head, Next;
    PTRACELOG_CONTEXT pHandleEntry, pEntry;
    ULONG i, Status;
    LONGLONG sTime, eTime;
    TRACEHANDLE SavedArray[MAXLOGGERS];

    PEVENT_TRACE_LOGFILE logfile;
    PEVENT_TRACE pEvent;
    PTRACELOG_CONTEXT pContext;
    PEVENT_TRACE_PROPERTIES Properties;
    ULONG  szProperties;
    ULONG RealTimeDataFeed, LogFileDataFeed;
    USHORT LoggerId;
    TRACEHANDLE LoggerHandle = 0;
    ULONG j;
    BOOL Done = FALSE;
    ACCESS_MASK DesiredAccess = TRACELOG_ACCESS_REALTIME;

    WmipInitProcessHeap();

    if ((HandleCount == 0) || (HandleCount >= MAXLOGGERS)) {
        return ERROR_BAD_LENGTH;
    }
    if (HandleArray == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    RtlZeroMemory(Logfiles, MAXLOGGERS*sizeof(PEVENT_TRACE_LOGFILEW) );
    szProperties = sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAXSTR * sizeof(WCHAR);
    Properties = WmipAlloc(szProperties);
    if (Properties == NULL) {
        return ERROR_OUTOFMEMORY;
    }


    WmipEnterPMCritSection();

    eTime = 0;
    sTime = 0;

    try {
        if (StartTime != NULL)
            sTime = *((PLONGLONG) StartTime);
        if (EndTime != NULL)
            eTime = *((PLONGLONG) EndTime);

        if ((eTime != 0) && (eTime < sTime) ) {
            WmipLeavePMCritSection();
            Status = ERROR_INVALID_TIME;
            goto Cleanup;
        }

        for (i=0; i<HandleCount; i++) {
            SavedArray[i] = HandleArray[i];
            if (SavedArray[i] == (TRACEHANDLE) INVALID_HANDLE_VALUE) {
                WmipLeavePMCritSection();
                Status = ERROR_INVALID_HANDLE;
                goto Cleanup;
            }
        }

        for (i=0; i< HandleCount; i++) {
            pHandleEntry = NULL;
            Head = TraceHandleListHeadPtr;
            if (Head != NULL) {
                Next = Head->Flink;
                while (Next != Head) {
                    pEntry = CONTAINING_RECORD(Next, 
                                               TRACELOG_CONTEXT, 
                                               Entry);
                    Next = Next->Flink;
                    if (SavedArray[i] == pEntry->TraceHandle) {
                        if (pEntry->fProcessed == FALSE) {
                            pHandleEntry = pEntry;
                            pHandleEntry->fProcessed = TRUE;
                        }
                        break;
                    }
                }
            }
            if (pHandleEntry == NULL) {
                Status = ERROR_INVALID_HANDLE;
                WmipLeavePMCritSection();
                goto Cleanup;
            }
            Logfiles[i] = &pHandleEntry->Logfile;
        }

        WmipLeavePMCritSection();

        //
        // Scan the Logfiles list and decide it's realtime or 
        // Logfile Proceessing. 
        //
        for (i=0; i < HandleCount; i++) {
            RealTimeDataFeed = FALSE;
            LogFileDataFeed  = FALSE;
            //
            // Check to see if this is a RealTime Datafeed
            //
            if (Logfiles[i]->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
                if (Logfiles[i]->LoggerName == NULL) {
                    Status = WmipSetDosError(ERROR_INVALID_NAME);
                    goto Cleanup;
                }
                //
                // Using the LoggerName, Query the Logger to determine
                // whether this is a Kernel or Usermode realtime logger.
                //
                RtlZeroMemory(Properties, szProperties);
                Properties->Wnode.BufferSize = szProperties;


                Status = ControlTraceW(LoggerHandle,
                                      (LPWSTR)Logfiles[i]->LoggerName,
                                      Properties,
                                      EVENT_TRACE_CONTROL_QUERY);

                if (Status != ERROR_SUCCESS) {
                    goto Cleanup;
                }

                if (!(Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
                    Status = ERROR_WMI_INSTANCE_NOT_FOUND;
                    goto Cleanup;
                }

                Logfiles[i]->IsKernelTrace =
                    IsEqualGUID(&Properties->Wnode.Guid, &SystemTraceControlGuid);

                LoggerId = WmiGetLoggerId(Properties->Wnode.HistoricalContext);

                if (LoggerId == KERNEL_LOGGER_ID) 
                    LoggerId = 0;
                Logfiles[i]->Filled = LoggerId; // Temporarily stash it away 
                Logfiles[i]->LogfileHeader.LogInstanceGuid = Properties->Wnode.Guid;

                //
                // If the Logger is using UsePerfClock for TimeStamps, make a reference 
                // timestamp now. 
                //

                Logfiles[i]->LogfileHeader.ReservedFlags = Properties->Wnode.ClientContext;

                //
                // Save the BuffferSize for Realtime Buffer Pool Allocation
                //
                Logfiles[i]->BufferSize = Properties->BufferSize * 1024;

                //
                // This is the place to do security check on this Guid.
                //


                Status = WmipCheckGuidAccess( &Properties->Wnode.Guid,
                                              DesiredAccess );

                if (Status != ERROR_SUCCESS) {
                    goto Cleanup;
                }
                RealTimeDataFeed = TRUE;
            }
            //
            // Check to see if this is a Logfile datafeed.
            //


            if (!(Logfiles[i]->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
                if (Logfiles[i]->LogFileName == NULL) {
                    Status = WmipSetDosError(ERROR_BAD_PATHNAME);
                    goto Cleanup;
                }

                if ( wcslen((LPWSTR)Logfiles[i]->LogFileName) <= 0 ) {
                        Status = WmipSetDosError(ERROR_BAD_PATHNAME);
                        goto Cleanup;
                }

                LogFileDataFeed = TRUE;
            }

            //
            // We don't support both RealTimeFeed and LogFileDataFeed.
            //

            if (RealTimeDataFeed && LogFileDataFeed) {
                Status = WmipSetDosError(ERROR_INVALID_PARAMETER);
                goto Cleanup;
            }
        }

        
        if (LogFileDataFeed) {
            Status = WmipProcessTraceLog(&SavedArray[0], Logfiles, 
                                     HandleCount, 
                                     sTime, 
                                     eTime,
                                     TRUE);
        }
        else {
            Status = WmipProcessRealTimeTraces(&SavedArray[0], Logfiles,
                                     HandleCount,
                                     sTime,
                                     eTime,
                                     TRUE);
        }


    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
#ifdef DBG
        WmipDebugPrint(("TRACE: WmipProcessTraceLog threw exception %X\n",
                            Status));
#endif
        Status = WmipSetDosError(WmipNtStatusToDosError(Status));
    }

    try {
    WmipEnterPMCritSection();
    for (i=0; i< HandleCount; i++) {
        pHandleEntry = NULL;
        Head = TraceHandleListHeadPtr;
        WmipAssert(Head);
        Next = Head->Flink;
        while (Next != Head) {
            pEntry = CONTAINING_RECORD(Next, TRACELOG_CONTEXT, Entry);
            Next = Next->Flink;

            if (SavedArray[i] == pEntry->TraceHandle) {
                pEntry->fProcessed = FALSE;
                break;
            }
        }
    }
    WmipLeavePMCritSection();
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
#ifdef DBG
        WmipDebugPrint(("TRACE: WmipProcessTraceLog threw exception %X\n",
                            Status));
#endif
        Status = WmipSetDosError(WmipNtStatusToDosError(Status));
    }

Cleanup:

    WmipFree(Properties);
    return Status;
}

ULONG
WMIAPI
CloseTrace(
    IN TRACEHANDLE TraceHandle
       )
{
    WmipInitProcessHeap();
    if ((TraceHandle == 0) || 
        (TraceHandle == (TRACEHANDLE)INVALID_HANDLE_VALUE))
        return ERROR_INVALID_HANDLE;
    return WmipFreeTraceHandle(TraceHandle);
}

VOID
WmipGuidMapCallback(
        PLIST_ENTRY GuidMapListHeadPtr,
        PEVENT_TRACE pEvent
        )
{
    PTRACEGUIDMAP GuidMap;

    WmipInitProcessHeap();
    
    if (pEvent == NULL)
        return;

    GuidMap = (PTRACEGUIDMAP) pEvent->MofData;
    if (GuidMap != NULL) {
        WmipAddGuidHandleToGuidMapList(GuidMapListHeadPtr, GuidMap->GuidMapHandle, &GuidMap->Guid);
    }

}


void
WmipCleanupTraceLog(
    PTRACELOG_CONTEXT pContext
    )
{
    ULONG Size;

    //
    // Free up the realtime context arrays and buffers
    //

    WmipEnterPMCritSection();

    if (pContext->IsRealTime) {
        if (pContext->Root != NULL) {
            WmipFree(pContext->Root);
        }
        WmipFreeRealTimeContext(pContext->RealTimeCxt);
    }
    else {
        if (pContext->Handle != NULL) {
            NtClose(pContext->Handle);
            pContext->Handle = NULL;
        }
    }

    if (pContext->BufferList != NULL) {
        WmipMemFree(pContext->BufferList);
    }
    if (pContext->BufferCacheSpace != NULL) {
        WmipMemFree(pContext->BufferCacheSpace);
    }

    WmipCleanupGuidMapList(&pContext->GuidMapListHead);

    //
    // The following fields need to be reset since the caller
    // may call ProcessTrace again with the same handle
    // 
    Size = sizeof(TRACELOG_CONTEXT) - FIELD_OFFSET(TRACELOG_CONTEXT, fProcessed);
    RtlZeroMemory(&pContext->fProcessed, Size);
    InitializeListHead (&pContext->GuidMapListHead);

    WmipLeavePMCritSection();
    

    //
    // TODO: We need to use a ref count mechanism before deleting the
    // EventMapList and CallbackLists
    //


//    if (EventMapList != NULL) {
//        HeapFree(GetProcessHeap(), 0, EventMapList);
//        EventMapList = NULL;
//    }
//    WmipFreeCallbackList();

}



ULONG
WMIAPI
WmiGetFirstTraceOffset(
    IN  PWMIBUFFERINFO BufferInfo
    )
/*++

Routine Description:
    This is the private API for buffer walking for cluster/
    debugger support.

    Returns the Offset to the first event.

Arguments: 


Returned Value:

    Status code

--*/
{
    PVOID pBuffer;
    PWMI_BUFFER_HEADER pHeader;
    PLONG LastByte;

    if (BufferInfo == NULL) {
        return 0;
    }
    pBuffer = BufferInfo->Buffer;

    if (pBuffer == NULL) {
        return 0;
    }
    pHeader = (PWMI_BUFFER_HEADER) pBuffer;

    switch(BufferInfo->BufferSource) {
        case WMIBS_CURRENT_LIST:
        {
// TODO: Fix GlennP's debugger problem in 2195
// 
//            ULONG lMask = ~((ULONG)0);
            pHeader->Wnode.BufferSize = BufferInfo->BufferSize;
            pHeader->ClientContext.Alignment = (UCHAR)BufferInfo->Alignment;
//            if (BufferInfo->ProcessorNumber < lMask) {
//                pHeader->ClientContext.ProcessorNumber  = (UCHAR)BufferInfo->ProcessorNumber;
//            }
            pHeader->Offset = pHeader->CurrentOffset;
            break;
        }
        case WMIBS_FREE_LIST:
        {
            pHeader->Offset = pHeader->CurrentOffset;

            if (pHeader->SavedOffset > 0)
                pHeader->Offset = pHeader->SavedOffset;

            if (pHeader->Offset == 0) {
                pHeader->Offset = sizeof(WMI_BUFFER_HEADER);
            }

            pHeader->Wnode.BufferSize = BufferInfo->BufferSize;
            break;
        }
        case WMIBS_TRANSITION_LIST:
        {
            if (pHeader->SavedOffset > 0) {
                pHeader->Offset = pHeader->SavedOffset;
            }
            break;
        }
        case WMIBS_FLUSH_LIST:
        {
            if (pHeader->SavedOffset > 0) {
                pHeader->Offset = pHeader->SavedOffset;
            }
            pHeader->Wnode.BufferSize = BufferInfo->BufferSize;
            break;
        }
        case WMIBS_LOG_FILE: 
        {
            break;
        }
    }

    if (BufferInfo->BufferSource != WMIBS_LOG_FILE) {
        LastByte = (PLONG) ((PUCHAR)pHeader+ pHeader->Offset);
        if (pHeader->Offset <= (BufferInfo->BufferSize - sizeof(ULONG)) ) {

            *LastByte = -1;
        }
    }

    return  sizeof(WMI_BUFFER_HEADER);
}

ULONG 
WmipConvertEnumToTraceType(
    WMI_HEADER_TYPE eTraceType
    )
{
    switch(eTraceType) {
        case WMIHT_SYSTEM32:
            return TRACE_HEADER_TYPE_SYSTEM32;
        case WMIHT_SYSTEM64:
            return TRACE_HEADER_TYPE_SYSTEM64;
        case WMIHT_EVENT_TRACE:
            return TRACE_HEADER_TYPE_FULL_HEADER;
        case WMIHT_EVENT_INSTANCE:
            return TRACE_HEADER_TYPE_INSTANCE;
        case WMIHT_TIMED:
            return TRACE_HEADER_TYPE_TIMED;
        case WMIHT_ULONG32:
            return TRACE_HEADER_TYPE_ULONG32;
        case WMIHT_WNODE:
            return TRACE_HEADER_TYPE_WNODE_HEADER;
        case WMIHT_MESSAGE:
            return TRACE_HEADER_TYPE_MESSAGE;
        case WMIHT_PERFINFO32:
            return TRACE_HEADER_TYPE_PERFINFO32;
        case WMIHT_PERFINFO64:
            return TRACE_HEADER_TYPE_PERFINFO64;
        default:
            return 0;
    }
}

WMI_HEADER_TYPE
WmipConvertTraceTypeToEnum( 
                            ULONG TraceType 
                          )
{
    switch(TraceType) {
        case TRACE_HEADER_TYPE_SYSTEM32:
            return WMIHT_SYSTEM32;
        case TRACE_HEADER_TYPE_SYSTEM64:
            return WMIHT_SYSTEM64;
        case TRACE_HEADER_TYPE_FULL_HEADER:
            return WMIHT_EVENT_TRACE;
        case TRACE_HEADER_TYPE_INSTANCE:
            return WMIHT_EVENT_INSTANCE;
        case TRACE_HEADER_TYPE_TIMED:
            return WMIHT_TIMED;
        case TRACE_HEADER_TYPE_ULONG32:
            return WMIHT_ULONG32;
        case TRACE_HEADER_TYPE_WNODE_HEADER:
            return WMIHT_WNODE;
        case TRACE_HEADER_TYPE_MESSAGE:
            return WMIHT_MESSAGE;
        case TRACE_HEADER_TYPE_PERFINFO32:
            return WMIHT_PERFINFO32;
        case TRACE_HEADER_TYPE_PERFINFO64:
            return WMIHT_PERFINFO64;
        default: 
            return WMIHT_NONE;
    }
}
                    

WMI_HEADER_TYPE
WMIAPI
WmiGetTraceHeader(
    IN  PVOID  LogBuffer,
    IN  ULONG  Offset,
    OUT ULONG  *Size
    )
{
    ULONG Status = ERROR_SUCCESS;
    ULONG TraceType;

    try {

        TraceType = WmipGetNextEventOffsetType(
                                            (PUCHAR)LogBuffer,
                                            Offset,
                                            Size
                                          );

        return WmipConvertTraceTypeToEnum(TraceType);


    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
#ifdef DBG
        WmipDebugPrint(("TRACE: WmiGetTraceHeader threw exception %X\n",
                            Status));
#endif
        Status = WmipSetDosError(WmipNtStatusToDosError(Status));
    }

    return 0;
}


ULONG
WMIAPI
WmiParseTraceEvent(
    IN PVOID LogBuffer,
    IN ULONG Offset,
    IN WMI_HEADER_TYPE HeaderType,
    IN OUT PVOID EventInfo,
    IN ULONG EventInfoSize
    )
{

    return WmipParseTraceEvent(NULL, LogBuffer, Offset, HeaderType, EventInfo, EventInfoSize);
}



ULONG
WmipParseTraceEvent(
    IN PTRACELOG_CONTEXT pContext,
    IN PVOID LogBuffer,
    IN ULONG Offset,
    IN WMI_HEADER_TYPE HeaderType,
    IN OUT PVOID EventInfo,
    IN ULONG EventInfoSize
    )
{
    PWMI_BUFFER_HEADER Header = (PWMI_BUFFER_HEADER)LogBuffer;
    ULONG Status = ERROR_SUCCESS;
    PVOID pEvent;

    if ( (LogBuffer == NULL) ||
         (EventInfo == NULL) ||
         (EventInfoSize < sizeof(EVENT_TRACE_HEADER)) )
    {
        return (ERROR_INVALID_PARAMETER);
    } 

    Status = WmipCreateGuidMapping();
    if (Status != ERROR_SUCCESS) {
        return Status;
    }

    try {

        RtlZeroMemory(EventInfo, sizeof(EVENT_TRACE));

        pEvent = (void*) ((PUCHAR)LogBuffer + Offset);

        WmipCopyCurrentEvent(pContext,
                         pEvent,
                         EventInfo,
                         WmipConvertEnumToTraceType(HeaderType),
                         (PWMI_BUFFER_HEADER)LogBuffer
                         );

        ( (PEVENT_TRACE)EventInfo)->ClientContext = Header->Wnode.ClientContext;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
#ifdef DBG
        WmipDebugPrint(("TRACE: WmipParseTraceEvent threw exception %X\n",
                            Status));
#endif
        Status = WmipSetDosError(WmipNtStatusToDosError(Status));
    }

    return Status;
}

//
//  RealTime Routines
//


PVOID
WmipAllocTraceBuffer(
    PTRACELOG_REALTIME_CONTEXT RTCxt,
    ULONG BufferSize
    )
{
    PVOID Buffer = NULL;
    PTRACE_BUFFER_HEADER Header;
    PLIST_ENTRY Head, Next;
    PTRACERT_BUFFER_LIST_ENTRY ListEntry;
    PTRACE_BUFFER_SPACE WmipTraceBufferSpace;

    WmipEnterPMCritSection();
    WmipTraceBufferSpace = RTCxt->WmipTraceBufferSpace;
    Head = &WmipTraceBufferSpace->FreeListHead;
    Next = Head->Flink;
    while (Head != Next)  {
        ListEntry = CONTAINING_RECORD(Next, TRACERT_BUFFER_LIST_ENTRY, Entry);
        Next = Next->Flink;
        if (ListEntry->Size == BufferSize) {
            goto foundList;
        }
    }
    //
    // No list for this bufferSize was  found. So go Ahead and allocate one.
    //
    ListEntry = WmipAlloc(sizeof(TRACERT_BUFFER_LIST_ENTRY));
    if (ListEntry == NULL) {
        WmipSetDosError(ERROR_OUTOFMEMORY);
        WmipLeavePMCritSection();
        return NULL;
    }
    RtlZeroMemory(ListEntry, sizeof(TRACERT_BUFFER_LIST_ENTRY));
    ListEntry->Size = BufferSize;
    InitializeListHead(&ListEntry->BufferListHead);
    InsertHeadList(&WmipTraceBufferSpace->FreeListHead, &ListEntry->Entry);

foundList:
    //
    // Now look for a free buffer in this list
    //
    Head = &ListEntry->BufferListHead;
    Next = Head->Flink;
    while (Head != Next) {
        Header = CONTAINING_RECORD( Next, TRACE_BUFFER_HEADER, Entry );
        if (((PWNODE_HEADER)Header)->BufferSize == BufferSize) {
            RemoveEntryList(&Header->Entry);
            Buffer = (PVOID)Header;
            break;
        }
        Next = Next->Flink;
    }
    WmipLeavePMCritSection();
    //
    // If No Free Buffers are found we try to allocate one and return.
    //
    if (Buffer == NULL) {
        PVOID Space;
        ULONG SizeLeft = WmipTraceBufferSpace->Reserved -
                         WmipTraceBufferSpace->Committed;
        if (SizeLeft < BufferSize) {
            WmipSetDosError(ERROR_OUTOFMEMORY);
            return NULL;
        }

        Space = (PVOID)( (PCHAR)WmipTraceBufferSpace->Space +
                                WmipTraceBufferSpace->Committed );

        Buffer =  WmipMemCommit( Space, BufferSize );

        if (Buffer != NULL)  {
            WmipTraceBufferSpace->Committed += BufferSize;
        }

    }
    return (Buffer);
}
VOID
WmipFreeTraceBuffer(
    PTRACELOG_REALTIME_CONTEXT RTCxt,
    PVOID Buffer
    )
{
    PTRACE_BUFFER_HEADER Header = (PTRACE_BUFFER_HEADER)Buffer;
    PLIST_ENTRY Head, Next;
    ULONG BufferSize = Header->Wnode.BufferSize;
    PTRACERT_BUFFER_LIST_ENTRY ListEntry;
    PLIST_ENTRY BufferList = NULL;
    PTRACE_BUFFER_SPACE WmipTraceBufferSpace;

    WmipEnterPMCritSection();
    WmipTraceBufferSpace = RTCxt->WmipTraceBufferSpace;
    Head = &WmipTraceBufferSpace->FreeListHead;
    Next = Head->Flink;
    while (Head != Next) {
        ListEntry = CONTAINING_RECORD(Next, TRACERT_BUFFER_LIST_ENTRY, Entry);
        Next = Next->Flink;
        if (ListEntry->Size == BufferSize) {
            BufferList = &ListEntry->BufferListHead;
            break;
        }
    }
    if (BufferList != NULL) {

       InsertHeadList(BufferList, &Header->Entry);
    }
    else {

        //  We shoule not get here. If we do the buffer->Size is
        // Corrupted.
        WmipAssert(BufferList == NULL);
    }
    WmipLeavePMCritSection();
}


//
// TODO: If two threads called processtrace for the same RT stream, how can we fire
// two callbacks 
//


ULONG
WmipRealTimeCallback(
    IN PWNODE_HEADER Wnode,
    IN ULONG_PTR RTContext //LogFileIndex
    )
/*++

Routine Description:
    This routine is called when a real time buffer becomes available.
    The buffer delivered by WMI is copied to a local pool of ring buffers.
    Each realtime data feed maintains its own pool of ring buffers and the
    LogFileIndex passed back via the Wnode (ProviderId field)
    identifies the stream to which the buffer is destined.


Arguments:

    Wnode           Buffer
    LogFileIndex    Index of the Input stream from which this buffer came.

Returned Value:

    Status Code.

--*/
{
    ULONG index;
    PTRACELOG_REALTIME_CONTEXT Context = (PTRACELOG_REALTIME_CONTEXT) RTContext;
    PWNODE_HEADER pHeader;
    PWMI_CLIENT_CONTEXT ClientContext;

    //
    // Assumes that the number of LogFiles is less than the MAXLOGGERS.
    //
    // Get the LogFileIndex to which this buffer is destined through the
    // Logger Historical Context.

    ClientContext = (PWMI_CLIENT_CONTEXT)&Wnode->ClientContext;
    //
    // If we can't use this buffer for  whatever reason, we return and
    // the return code is always ERROR_SUCCESS.
    //


    //
    // Circular FIFO  queue of MAXBUFFERS to hold the buffers.
    // Producer to Fill it and Consumer to Null it.
    //

    index =  (Context->BuffersProduced % MAXBUFFERS);
    if (Context->RealTimeBufferPool[index] == NULL) {  //Empty slot found.
        pHeader = (PWNODE_HEADER) WmipAllocTraceBuffer(Context, Wnode->BufferSize);
        if (pHeader == NULL) {
            return ERROR_SUCCESS;
        }
        RtlCopyMemory(pHeader, Wnode, Wnode->BufferSize); // One more copy!?
        Context->RealTimeBufferPool[index] = pHeader;
        Context->BuffersProduced++;
        NtSetEvent(Context->MoreDataEvent, NULL);  //Signal the dc there's more data.
    }
    else {                              // No Empty Slots found.
        Context->BufferOverflow++;      // Simply let the buffer go.
    }

    //
    // wmi service maintains only the Delta buffersLost since the last time
    // it was reported. The Count is zeroed once it is reported in a delivered
    // buffer. This means I can add it directly.
    //
    Context->BufferOverflow += Wnode->CountLost;

    return ERROR_SUCCESS;
}



ULONG
WmipSetupRealTimeContext(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount
    )
/*++

Routine Description:
    This routine sets up the context to process real time buffers.
    The real time buffers delivered will be copied and kept in a circular
    buffer pool until the ProcessTracelog routine can consume it.

Arguments:

    LogFile         Array of Logfiles being processed.
    LogFileCount    Number of Logfiles in the Array.

Returned Value:

    Status Code.

--*/
{
    ULONG i;
    ULONG Status;
    USHORT LoggerId;
    ULONG TotalBufferSize = 0;
    SYSTEM_BASIC_INFORMATION SystemInfo;
    ULONG RealTimeRegistered = FALSE;


    Status = WmipCreateGuidMapping();
    if (Status != ERROR_SUCCESS) {
        return Status;
    }


    for (i=0; i < LogfileCount; i++) {
        if (Logfiles[i]->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
            TotalBufferSize += Logfiles[i]->BufferSize; // * SystemInfo.NumberOfProcessors;
         }
    }
    if (TotalBufferSize == 0)
        TotalBufferSize =  DEFAULT_REALTIME_BUFFER_SIZE;

    //
    // Initialize the real time data feed Structures.
    //

    for (i=0; i < LogfileCount; i++) {
        PTRACELOG_REALTIME_CONTEXT RTCxt;
        PTRACELOG_CONTEXT pContext;
        PTRACE_BUFFER_LIST_ENTRY pListEntry;
        LARGE_INTEGER Frequency;
        ULONGLONG Counter = 0;


        if (Logfiles[i]->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {

            pContext = WmipLookupTraceHandle(HandleArray[i]);
            if (pContext == NULL) {
                return WmipSetDosError(ERROR_OUTOFMEMORY);
            }
            pContext->IsRealTime = TRUE;
            pContext->Handle = NULL;
            Logfiles[i]->Context = pContext;
            Logfiles[i]->BuffersRead = 0;

            pContext->EndOfFile = TRUE;


            //
            // Save the flags from OpenTrace at this time before the first
            // buffer callback which will erase it.
            //

            pContext->ConversionFlags = Logfiles[i]->LogfileHeader.ReservedFlags;

            pContext->UsePerfClock = Logfiles[i]->LogfileHeader.ReservedFlags;

            //
            // If the conversion flags are set, adjust UsePerfClock accordingly.
            //
            if (pContext->ConversionFlags & EVENT_TRACE_USE_RAWTIMESTAMP ) {
                pContext->UsePerfClock = EVENT_TRACE_CLOCK_RAW;
            }

            //
            // Fill in the StartTime, Frequency and StartPerfClock fields
            //

            Status = NtQueryPerformanceCounter((PLARGE_INTEGER)&Counter,
                                                &Frequency);
            pContext->StartPerfClock.QuadPart = Counter;
            pContext->PerfFreq.QuadPart = Frequency.QuadPart;
            pContext->StartTime.QuadPart = WmipGetSystemTime();
            
            RTCxt = (PTRACELOG_REALTIME_CONTEXT)WmipAlloc(
                                             sizeof(TRACELOG_REALTIME_CONTEXT));

            if (RTCxt == NULL) {
                return WmipSetDosError(ERROR_OUTOFMEMORY);
            }

            RtlZeroMemory(RTCxt, sizeof(TRACELOG_REALTIME_CONTEXT));

            RTCxt->MoreDataEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (RTCxt->MoreDataEvent == NULL) {
                return WmipSetDosError(ERROR_OBJECT_NOT_FOUND);
            }

            //
            // Save the RTCxt in a global pContext array so that the
            // notification callback from WMI can get at it through the
            // logfile index i.
            //
            LoggerId = (USHORT)Logfiles[i]->Filled; // get the stashed LoggerId.
            pContext->LoggerId = LoggerId;

            pContext->RealTimeCxt = RTCxt;

            RTCxt->InstanceGuid = Logfiles[i]->LogfileHeader.LogInstanceGuid;

            //
            // Allocate the buffer space to receive the ral time buffers
            //

            if ( !RealTimeRegistered) {
                ULONG SizeReserved;
                PVOID BufferSpace;

                //
                // Right before starting to receive the realtime buffers
                // get a dump of the GuidMaps if any.
                ///

                WmipDumpGuidMaps(NULL, &pContext->GuidMapListHead, TRUE);

                RealTimeRegistered =  TRUE;

                RTCxt->WmipTraceBufferSpace = (PTRACE_BUFFER_SPACE)WmipAlloc(
                                            sizeof(TRACE_BUFFER_SPACE));

                if (RTCxt->WmipTraceBufferSpace == NULL) {
                    return ERROR_OUTOFMEMORY;
                }
                RtlZeroMemory(RTCxt->WmipTraceBufferSpace, sizeof(TRACE_BUFFER_SPACE));
                InitializeListHead(&RTCxt->WmipTraceBufferSpace->FreeListHead);

                SizeReserved = MAXBUFFERS *
                               TotalBufferSize;


                BufferSpace = WmipMemReserve( SizeReserved );
                if (BufferSpace == NULL) {
                    return ERROR_OUTOFMEMORY;
                }

                RTCxt->WmipTraceBufferSpace->Reserved = SizeReserved;
                RTCxt->WmipTraceBufferSpace->Space = BufferSpace;

            }
            //
            // For Every Logger Stream we need to register with WMI
            // for buffer notification with its Security Guid.
            //
            Status = WmiNotificationRegistration(
                            (const LPGUID) &RTCxt->InstanceGuid,
                            TRUE,
                            WmipRealTimeCallback, 
                            (ULONG_PTR)RTCxt,
                            NOTIFICATION_CALLBACK_DIRECT
                            );
            if (Status != ERROR_SUCCESS) {
                return Status;
            }
            //
            // Allocate Room to process one event
            //

            pListEntry = (PTRACE_BUFFER_LIST_ENTRY) WmipAlloc( sizeof(TRACE_BUFFER_LIST_ENTRY) );
            if (pListEntry == NULL) {
                return ERROR_OUTOFMEMORY;
            }
            RtlZeroMemory(pListEntry, sizeof(TRACE_BUFFER_LIST_ENTRY) );

            pContext->Root = pListEntry;

        }
    }

    return ERROR_SUCCESS;
}

ULONG
WmipLookforRealTimeBuffers(
    PEVENT_TRACE_LOGFILEW logfile
    )
/*++

Routine Description:
    This routine checks to see if there are any real time buffers
    ready for consumption.  If so, it sets up the CurrentBuffer and
    the CurrentEvent for this logfile stream. If no buffers are available
    simply sets the EndOfFile to be true.

Arguments:

    logfile         Current Logfile being processed.

Returned Value:

    ERROR_SUCCESS       Successfully moved to the next event.

--*/
{
    ULONG index;
    ULONG BuffersRead;
    PVOID pBuffer;
    PEVENT_TRACE pEvent;
    PTRACELOG_CONTEXT pContext;
    PTRACELOG_REALTIME_CONTEXT RTCxt;
    PWMI_BUFFER_HEADER pHeader;
    WMI_HEADER_TYPE HeaderType = WMIHT_NONE;
    ULONG Size;
    ULONG Offset;
    ULONG Status;


    if (logfile == NULL) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }
    pContext = logfile->Context;

    RTCxt = pContext->RealTimeCxt;

    if (RTCxt == NULL) {
        return WmipSetDosError(ERROR_INVALID_DATA);
    }


    if (pContext->EndOfFile != TRUE) {

        pBuffer = pContext->BufferCache[0].Buffer;
        pEvent = &pContext->Root->Event;
        Status = ERROR_SUCCESS;
        Size = 0;
        if ((HeaderType = WmiGetTraceHeader(pBuffer, pContext->Root->BufferOffset, &Size)) != WMIHT_NONE) {
            if (Size > 0) {
                Status = WmipParseTraceEvent(pContext, pBuffer, pContext->Root->BufferOffset, HeaderType, pEvent, sizeof(EVENT_TRACE));
                pContext->Root->BufferOffset += Size;
            }
        }
        pContext->Root->EventSize = Size;

        if ( ( Size > 0) && (Status == ERROR_SUCCESS) ) {
            logfile->CurrentTime = pEvent->Header.TimeStamp.QuadPart;
            return ERROR_SUCCESS;
        }
        else {
            //
            // When the current buffer is exhausted, make the
            // BufferCallback
            //
            if (logfile->BufferCallback) {
                ULONG bRetVal;
                try {
                    bRetVal = (*logfile->BufferCallback) (logfile);
                    if (!bRetVal) {
                        return ERROR_CANCELLED;
                    }
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    pContext->EndOfFile = TRUE;
                    Status = GetExceptionCode();
#ifdef DBG
                    WmipDebugPrint(("TRACE: BufferCallback threw exception %X\n",
                                            Status));
#endif
                    WmipSetDosError(WmipNtStatusToDosError(Status));
                    return ERROR_CANCELLED; // so that realtime also cleans up.
                }
            }
            WmipFreeTraceBuffer(RTCxt, pBuffer);
        }
    }

    pContext->EndOfFile = TRUE;
    logfile->CurrentTime = 0;

    BuffersRead = logfile->BuffersRead;
    // Check to see if there are more  buffers to consume.
    if (BuffersRead < RTCxt->BuffersProduced) {
        pContext->EndOfFile = FALSE;
        index = (BuffersRead % MAXBUFFERS);
        if ( RTCxt->RealTimeBufferPool[index] != NULL) {
            PWMI_CLIENT_CONTEXT ClientContext;
            PWNODE_HEADER Wnode;

            pBuffer = (char*) (RTCxt->RealTimeBufferPool[index]);
            pContext->BufferCache[0].Buffer = pBuffer;
            RTCxt->RealTimeBufferPool[index] = NULL; 

            Wnode = (PWNODE_HEADER)pContext->BufferCache[0].Buffer;

            pHeader = (PWMI_BUFFER_HEADER)pContext->BufferCache[0].Buffer;

            Offset = sizeof(WMI_BUFFER_HEADER);

            pEvent = &pContext->Root->Event;

            if ((HeaderType = WmiGetTraceHeader(pBuffer, Offset, &Size)) != WMIHT_NONE) {
                if (Size == 0)
                    return ERROR_INVALID_DATA;
                Status = WmipParseTraceEvent(pContext, pBuffer, Offset, HeaderType, pEvent, sizeof(EVENT_TRACE));

                if (Status != ERROR_SUCCESS) {
                    return Status;
                } 
            }

            Offset += Size;

            pContext->Root->BufferOffset = Offset;
            pContext->Root->EventSize = Size;

            logfile->CurrentTime = pEvent->Header.TimeStamp.QuadPart;

            // Since the RealTime Logger may have started after
            // the consumer started, we have to get the buffersize
            // like this.
            logfile->BufferSize = Wnode->BufferSize;
            logfile->Filled     = (ULONG)pHeader->Offset;
            logfile->EventsLost = pHeader->EventsLost;

            logfile->BuffersRead++;
        }
    }
    return ERROR_SUCCESS;
}

ULONG
WmipCheckForRealTimeLoggers(
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    ULONG Unicode)
{
    ULONG Status;
    TRACEHANDLE LoggerHandle = 0;
    ULONG i;

    for (i=0; i < LogfileCount; i++) {
        //
        // Check to see if this is a RealTime Datafeed
        //
        if (Logfiles[i]->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
            //
            // Using the LoggerName, Query the Logger to determine
            // whether this is a Kernel or Usermode realtime logger.
            //
            RtlZeroMemory(&Properties, sizeof(Properties) );
            Properties.TraceProp.Wnode.BufferSize = sizeof(Properties);


            if (Unicode)
                Status = ControlTraceW(LoggerHandle,
                                  (LPWSTR)Logfiles[i]->LoggerName,
                                  &Properties.TraceProp,
                                  EVENT_TRACE_CONTROL_QUERY);
            else
                Status = ControlTraceA(LoggerHandle,
                                  (LPSTR)Logfiles[i]->LoggerName,
                                  (PEVENT_TRACE_PROPERTIES)&Properties,
                                  EVENT_TRACE_CONTROL_QUERY);
            //
            // If the Logger is still around  and the Real Time bit
            // is still set continue processing. Otherwise quit.
            //
            if ((Status == ERROR_SUCCESS) && (Properties.TraceProp.LogFileMode & EVENT_TRACE_REAL_TIME_MODE) ){
                return TRUE;
            }
        }
    }
#ifdef DBG
    //
    // We are expecting to see ERROR_WMI_INSTANCE_NOT_FOUND when the logger has gone away.
    // Any other error is abnormal. 
    //
    if ( Status != ERROR_WMI_INSTANCE_NOT_FOUND ) {
        WmipDebugPrint(("WET: WmipCheckForRealTimeLoggers abnormal failure. Status %X\n", Status));
    }
#endif

    return FALSE;
}


void
WmipFreeRealTimeContext(
    PTRACELOG_REALTIME_CONTEXT RTCxt
    )
{
    ULONG Status;
    PTRACERT_BUFFER_LIST_ENTRY ListEntry;
    PLIST_ENTRY Head, Next;

    if (RTCxt != NULL) {
        Status = WmiNotificationRegistration(
            (const LPGUID) &RTCxt->InstanceGuid,
            FALSE,
            WmipRealTimeCallback,
            0,
            NOTIFICATION_CALLBACK_DIRECT
            );
    }

    if (RTCxt->MoreDataEvent != NULL) {
        NtClose(RTCxt->MoreDataEvent);
    }

    if (RTCxt->WmipTraceBufferSpace != NULL) {
        WmipMemFree(RTCxt->WmipTraceBufferSpace->Space);
        Head = &RTCxt->WmipTraceBufferSpace->FreeListHead;
        Next = Head->Flink;
        while (Head != Next) {
            ListEntry = CONTAINING_RECORD(Next, TRACERT_BUFFER_LIST_ENTRY, Entry);
            Next = Next->Flink;
            RemoveEntryList(&ListEntry->Entry);
            WmipFree(ListEntry);
        }
        WmipFree(RTCxt->WmipTraceBufferSpace);
        RTCxt->WmipTraceBufferSpace = NULL;
    }

    WmipFree(RTCxt);
}

ULONG
WmipProcessRealTimeTraces(
    PTRACEHANDLE HandleArray,
    PEVENT_TRACE_LOGFILEW *Logfiles,
    ULONG LogfileCount,
    LONGLONG StartTime,
    LONGLONG EndTime,
    ULONG   Unicode
    )
/*++

Routine Description:
    Main entry point to process RealTime trace data streams.


Arguments:

    Logfiles            Array of logfile structures with LoggerNames of the RT stream
    LogfileCount        Number of RealTime trace streams to process
    StartTime           StartTime for windowing data
    EndTime             EndTime for windowing data


Returned Value:

    ERROR_SUCCESS       Successfully processed data from realtime trace stream

--*/
{
    ULONG Status;
    BOOL Done = FALSE;
    ULONG i, j;
    PTRACELOG_CONTEXT pContext;
    HANDLE  EventArray[MAXLOGGERS];
    NTSTATUS NtStatus;
    LARGE_INTEGER timeout = {(ULONG)(-1 * 10 * 1000 * 1000 * 10), -1};   // Wait for 10 seconds

    //
    // Register for RealTime Callbacks
    //

    Status = WmipSetupRealTimeContext( HandleArray, Logfiles, LogfileCount);
    if (Status != ERROR_SUCCESS) {
        goto DoCleanup;
    }

    //
    // Build the Handle Array
    //

    for (j=0; j < LogfileCount; j++) {
        pContext = (PTRACELOG_CONTEXT)Logfiles[j]->Context;
        EventArray[j] = pContext->RealTimeCxt->MoreDataEvent;
    }


    //
    // Event Processing Loop
    //

    while (!Done) {

        LONGLONG nextTimeStamp;
        BOOL EventInRange;
        PEVENT_TRACE_LOGFILEW logfile;
        ULONG j;
        PTRACELOG_CONTEXT pContext;
        //
        // Check to see if end of file has been reached on all the
        // files.
        //

        logfile = NULL;
        nextTimeStamp = 0;

        for (j=0; j < LogfileCount; j++) {
           pContext = (PTRACELOG_CONTEXT)Logfiles[j]->Context;

           if ((pContext->EndOfFile) &&
               (Logfiles[j]->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
                WmipLookforRealTimeBuffers(Logfiles[j]);
            }

           if (pContext->EndOfFile)
                continue;
           if (nextTimeStamp == 0) {
               nextTimeStamp = Logfiles[j]->CurrentTime;
               logfile = Logfiles[j];
           }
           else if (nextTimeStamp > Logfiles[j]->CurrentTime) {
               nextTimeStamp = Logfiles[j]->CurrentTime;
               logfile = Logfiles[j];
           }
        }

        if (logfile == NULL) {
            //
            // If no logfile with events found, wait on the realtime event.
            // If no realtime datafeed, then we are done.
            //

            NtStatus = NtWaitForMultipleObjects(LogfileCount, &EventArray[0], WaitAny, FALSE,  &timeout);

            if (NtStatus == STATUS_TIMEOUT) {
            //
            // If we timed out, then check to see if the loggers have gone away. 
            //
                if  ( !WmipCheckForRealTimeLoggers(Logfiles, LogfileCount, Unicode) ) { 
                    break;
                }
            }
            continue;
            break;
        }

        //
        // if the Next event timestamp is not within the window of
        // analysis, we do not fire the event callbacks.
        //

        EventInRange = TRUE;

        if ((StartTime != 0) && (StartTime > nextTimeStamp))
            EventInRange = FALSE;
        if ((EndTime != 0) && (EndTime < nextTimeStamp))
            EventInRange = FALSE;

        //
        // Make the Event Callbacks
        //

        if (EventInRange) {
            PEVENT_TRACE pEvent = &pContext->Root->Event;
            Status = WmipDoEventCallbacks( logfile, pEvent);
            if (Status != ERROR_SUCCESS) {
                return Status;
            }
        }

        //
        // Now advance to next event.
        //

        Status = WmipLookforRealTimeBuffers(logfile);
        Done = (Status == ERROR_CANCELLED);
    }

DoCleanup:
    for (i=0; i < LogfileCount; i++) {
        pContext = (PTRACELOG_CONTEXT)Logfiles[i]->Context;
        if (pContext != NULL) {
            WmipCleanupTraceLog(pContext);
        }
    }
    return Status;
}

ULONG
WMIAPI
WmiOpenTraceWithCursor(
    IN PWMI_MERGE_ETL_CURSOR LogCursor
    )
/*++

Routine Description:
    Main entry point to process Merged ETL file.


Arguments:

    LogCursor           pointer to WMI_MERGE_ETL_CURSOR

Returned Value:

    Status

--*/
{
    ULONG DosStatus = ERROR_INVALID_PARAMETER;
    NTSTATUS Status;
    PTRACELOG_CONTEXT HandleEntry = NULL;
    TRACEHANDLE TraceHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;
    PEVENT_TRACE_LOGFILEW Logfile;
    PTRACELOG_CONTEXT pContext;
    ULONG BufferSize;
    PWMI_BUFFER_HEADER BufferHeader;
    ULONG CpuNum;
    BOOLEAN CpuBufferFound;

    WmipInitProcessHeap();

    if (LogCursor != NULL) {
        LogCursor->Base = NULL;
        LogCursor->TraceMappingHandle = NULL;
        LogCursor->CursorVersion = WMI_MERGE_ETL_CURSOR_VERSION;

        Logfile = &LogCursor->Logfile;
        HandleEntry = WmipAllocateTraceHandle();
        if (HandleEntry == NULL) {
            DosStatus = ERROR_OUTOFMEMORY;
        } else {
            TraceHandle = HandleEntry->TraceHandle;
            try {
                DosStatus = WmipCopyLogfileInfo( HandleEntry,
                                              Logfile,
                                              TRUE
                                            );
                if (DosStatus == ERROR_SUCCESS) {
                    DosStatus = WmipCreateGuidMapping();
                    if (DosStatus == ERROR_SUCCESS) {
                        DosStatus = WmipProcessLogHeader( &HandleEntry->TraceHandle,
                                                       &Logfile,
                                                       1,
                                                       TRUE,
                                                       FALSE
                                                       );
                    }
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                DosStatus = WmipNtStatusToDosError( GetExceptionCode() );
            }
        }
    }

    if (DosStatus == ERROR_SUCCESS) {
        //
        // Now Make sure the bit was set, indicating a MERGED ETL
        //

        if ((LogCursor->Logfile.LogFileMode & EVENT_TRACE_RELOG_MODE) == 0) {
            //
            // It is not Merged ETL.
            //
            DosStatus = ERROR_BAD_FORMAT;
        } else {
            //
            // Now find out the number of CPU's, Current event, etc.
            //
            pContext = LogCursor->Logfile.Context;
            //
            // Now Create a file Mapping
            //
            LogCursor->TraceMappingHandle = 
                CreateFileMapping(pContext->Handle,
                                  0,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL
                    );

            if (LogCursor->TraceMappingHandle == NULL) {
                DosStatus = GetLastError();
                return DosStatus;
            }

            //
            // MapView of the file
            //
            LogCursor->Base = MapViewOfFile(LogCursor->TraceMappingHandle, 
                                            FILE_MAP_READ, 
                                            0, 
                                            0, 
                                            0);
            if (LogCursor->Base == NULL) {
                DosStatus = GetLastError();
                return DosStatus;
            }
    
            //
            // Now find the first event of each CPU
            //
            pContext = LogCursor->Logfile.Context;
            BufferSize = pContext->BufferSize;
            LogCursor->CurrentCpu = 0;

            for (CpuNum = 0; CpuNum < LogCursor->Logfile.LogfileHeader.NumberOfProcessors; CpuNum++) {
                CpuBufferFound = FALSE;
                while (CpuBufferFound == FALSE) {
                    BufferHeader = (PWMI_BUFFER_HEADER)
                                   ((UCHAR*) LogCursor->Base + 
                                    LogCursor->BufferCursor[CpuNum].CurrentBufferOffset.QuadPart);

                    if (BufferHeader->ClientContext.ProcessorNumber == CpuNum) {
                        CpuBufferFound = TRUE;
                        LogCursor->BufferCursor[CpuNum].BufferHeader = BufferHeader;
                    } else {
                        LogCursor->BufferCursor[CpuNum].CurrentBufferOffset.QuadPart += BufferSize;
                        if ((LogCursor->BufferCursor[CpuNum].CurrentBufferOffset.QuadPart/BufferSize) >=
                            LogCursor->Logfile.LogfileHeader.BuffersWritten) {
                            //
                            // Scanned the whole file;
                            //
                            LogCursor->BufferCursor[CpuNum].NoMoreEvents = TRUE;
                            break;
                        }
                    }
                }
                if (CpuBufferFound) {
                    //
                    // Found the buffer, set the offset
                    //
                    ULONG Size;
                    WMI_HEADER_TYPE HeaderType = WMIHT_NONE;
                    PVOID pBuffer;

                    LogCursor->BufferCursor[CpuNum].BufferHeader = BufferHeader;
                    LogCursor->BufferCursor[CpuNum].CurrentEventOffset = sizeof(WMI_BUFFER_HEADER);

                    //
                    // Initialize the first event in each CPU Stream.
                    //
                    pBuffer = LogCursor->BufferCursor[CpuNum].BufferHeader;

                    HeaderType = WmiGetTraceHeader(pBuffer, 
                                                   LogCursor->BufferCursor[CpuNum].CurrentEventOffset, 
                                                   &Size);

                    if (HeaderType != WMIHT_NONE) {
                        WmipParseTraceEvent(pContext,
                                            pBuffer,
                                            LogCursor->BufferCursor[CpuNum].CurrentEventOffset,
                                            HeaderType,
                                            &LogCursor->BufferCursor[CpuNum].CurrentEvent,
                                            sizeof(EVENT_TRACE));

                        LogCursor->BufferCursor[CpuNum].CurrentEventOffset += Size;
                        LogCursor->CurrentCpu = CpuNum;

                    } else {
                        //
                        // There is no event in this buffer.
                        //
                        DosStatus = ERROR_FILE_CORRUPT;
                        return DosStatus;
                    }

                }
            }
            for (CpuNum = 0; CpuNum < LogCursor->Logfile.LogfileHeader.NumberOfProcessors; CpuNum++) {
                //
                // Find the first event for whole trace.
                //
                if (LogCursor->BufferCursor[CpuNum].NoMoreEvents == FALSE) {
                    if (LogCursor->BufferCursor[LogCursor->CurrentCpu].CurrentEvent.Header.TimeStamp.QuadPart >
                        LogCursor->BufferCursor[CpuNum].CurrentEvent.Header.TimeStamp.QuadPart) {
                        LogCursor->CurrentCpu = CpuNum;
                    }
                }
            }
        }
    } else if ( HandleEntry != NULL) {
        WmipFreeTraceHandle(TraceHandle);
        TraceHandle = (TRACEHANDLE)INVALID_HANDLE_VALUE;
    }

    WmipSetDosError(DosStatus);
    return DosStatus;
}


ULONG
WMIAPI
WmiCloseTraceWithCursor(
    IN PWMI_MERGE_ETL_CURSOR LogCursor
    )
{
    ULONG     Status = ERROR_INVALID_PARAMETER;

    if (LogCursor != NULL) {
        if (LogCursor->Base != NULL) {
            if (UnmapViewOfFile(LogCursor->Base) == FALSE) {
                Status = GetLastError();
                return Status;
            } else {
                Status = ERROR_SUCCESS;
            }
        } else {
            Status = ERROR_INVALID_PARAMETER;
        }

        if (Status != ERROR_SUCCESS) {
            return Status;
        }

        if (LogCursor->TraceMappingHandle != NULL) {
            if (CloseHandle(LogCursor->TraceMappingHandle) == FALSE) {
                Status = GetLastError();
                return Status;
            } else {
                Status = ERROR_SUCCESS;
            }
        } else {
            Status = ERROR_INVALID_PARAMETER;
        }
    }

    return Status;
}


VOID
WMIAPI
WmiConvertTimestamp(
    OUT PLARGE_INTEGER DestTime,
    IN PLARGE_INTEGER  SrcTime,
    IN PWMI_MERGE_ETL_CURSOR LogCursor
    )
{
    WmipCalculateCurrentTime(DestTime, SrcTime, LogCursor->Logfile.Context);
}


ULONG
WMIAPI
WmiGetNextEvent(
    IN PWMI_MERGE_ETL_CURSOR LogCursor
    )
{
    ULONG CurrentCpu = LogCursor->CurrentCpu;
    ULONG Size;
    WMI_HEADER_TYPE HeaderType = WMIHT_NONE;
    PVOID pBuffer;
    PWMI_BUFFER_HEADER BufferHeader;
    ULONG BufferSize;
    PTRACELOG_CONTEXT pContext;
    ULONG CpuNum;
    NTSTATUS Status;
    ULONG i;
    BOOLEAN CpuBufferFound = FALSE;
    BOOLEAN MoreEvents = FALSE;

    if (LogCursor == NULL) {
        return MoreEvents;
    }

    //
    // Advance to the next event of this current CPU
    //
retry:

    pBuffer = LogCursor->BufferCursor[CurrentCpu].BufferHeader;

    HeaderType = WmiGetTraceHeader(pBuffer, 
                                   LogCursor->BufferCursor[CurrentCpu].CurrentEventOffset, 
                                   &Size);

    pContext = LogCursor->Logfile.Context;
    if (HeaderType == WMIHT_NONE) {
        //
        // End of current buffer, advance to the next buffer for this CPU
        //
        BufferSize = pContext->BufferSize;

        LogCursor->BufferCursor[CurrentCpu].CurrentBufferOffset.QuadPart
            = LogCursor->BufferCursor[CurrentCpu].CurrentBufferOffset.QuadPart 
              + BufferSize;

        if ((LogCursor->BufferCursor[CurrentCpu].CurrentBufferOffset.QuadPart/BufferSize) >=
                    LogCursor->Logfile.LogfileHeader.BuffersWritten) {
            //
            // Scanned the whole file;
            //
            LogCursor->BufferCursor[CurrentCpu].NoMoreEvents = TRUE;
        } else {
            while (CpuBufferFound == FALSE) {
                BufferHeader = (PWMI_BUFFER_HEADER)
                               ((UCHAR*) LogCursor->Base + 
                                LogCursor->BufferCursor[CurrentCpu].CurrentBufferOffset.QuadPart);

                if (BufferHeader->ClientContext.ProcessorNumber == CurrentCpu) {
                    CpuBufferFound = TRUE;
                } else {
                    LogCursor->BufferCursor[CurrentCpu].CurrentBufferOffset.QuadPart += BufferSize;
                    if ((LogCursor->BufferCursor[CurrentCpu].CurrentBufferOffset.QuadPart/BufferSize) >=
                        LogCursor->Logfile.LogfileHeader.BuffersWritten) {
                        //
                        // Scanned the whole file;
                        //
                        LogCursor->BufferCursor[CurrentCpu].NoMoreEvents = TRUE;
                        break;
                    }
                }
            }
        }
        if (CpuBufferFound) {
            //
            // Found the buffer, set the offset
            //
            LogCursor->BufferCursor[CurrentCpu].BufferHeader = BufferHeader;
            LogCursor->BufferCursor[CurrentCpu].CurrentEventOffset = sizeof(WMI_BUFFER_HEADER);
            goto retry;
        } else {
            //
            // No more buffer in this CPU stream.
            //
            LogCursor->BufferCursor[CurrentCpu].NoMoreEvents = TRUE;
        }
    } else {
        WmipParseTraceEvent(pContext, 
                            pBuffer,
                            LogCursor->BufferCursor[CurrentCpu].CurrentEventOffset,
                            HeaderType,
                            &LogCursor->BufferCursor[CurrentCpu].CurrentEvent,
                            sizeof(EVENT_TRACE));

        LogCursor->BufferCursor[CurrentCpu].CurrentEventOffset += Size;

        MoreEvents = TRUE;
    }

    //
    // No more events in current CPU.
    //
    if (MoreEvents == FALSE) {
        for (CurrentCpu=0; CurrentCpu<LogCursor->Logfile.LogfileHeader.NumberOfProcessors; CurrentCpu++) {
            if (LogCursor->BufferCursor[CurrentCpu].NoMoreEvents == FALSE) {
                LogCursor->CurrentCpu = CurrentCpu;
                MoreEvents = TRUE;
                break;
            }
        }
    }

    //
    //  Now find the CPU that has the next event
    //
    if (MoreEvents == TRUE) {
        for (i=0; i<LogCursor->Logfile.LogfileHeader.NumberOfProcessors; i++) {
            if (LogCursor->BufferCursor[i].NoMoreEvents == FALSE) {
                if (LogCursor->BufferCursor[LogCursor->CurrentCpu].CurrentEvent.Header.TimeStamp.QuadPart >
                    LogCursor->BufferCursor[i].CurrentEvent.Header.TimeStamp.QuadPart) {
                    LogCursor->CurrentCpu = i;
                }
            }
        }
    }
    //
    // Finish finding the next event.
    //
    return MoreEvents;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\tracehw.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tracehw.c

Abstract:

    This routine dumps the hardware configuration of the machine to the
    logfile.

Author:

    04-Jul-2000 Melur Raghuraman
    09-Sep-2001 Nitin Choubey

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>          // for ntutrl.h
#include <nturtl.h>         // for RTL_CRITICAL_SECTION in winbase.h/wtypes.h
#include <wtypes.h>         // for LPGUID in wmium.h
#include <mountmgr.h>
#include <winioctl.h>
#include <ntddvol.h>
#include <ntddscsi.h>
#include <regstr.h>
#include <iptypes.h>

#include "wmiump.h"
#include "evntrace.h"
#include "traceump.h"

#define DEFAULT_ALLOC_SIZE 4096

extern
PVOID
WmipGetTraceBuffer(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PSYSTEM_THREAD_INFORMATION pThread,
    IN ULONG GroupType,
    IN ULONG RequiredSize
    );

__inline ULONG WmipSetDosError(IN ULONG DosError);

#define WmipNtStatusToDosError(Status) \
    ((ULONG)((Status == STATUS_SUCCESS)?ERROR_SUCCESS:RtlNtStatusToDosError(Status)))

#define COMPUTERNAME_ROOT \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"

#define CPU_ROOT \
    L"\\Registry\\Machine\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor"

#define COMPUTERNAME_VALUE_NAME \
    L"ComputerName"

#define NETWORKCARDS_ROOT \
    L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards"

#define MHZ_VALUE_NAME \
    L"~MHz"

#define NIC_VALUE_NAME \
    L"Description"

#define REG_PATH_VIDEO_DEVICE_MAP \
    L"\\Registry\\Machine\\Hardware\\DeviceMap\\Video"

#define REG_PATH_VIDEO_HARDWARE_PROFILE \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles\\Current\\System\\CurrentControlSet\\Control\\Video"

#define REG_PATH_SERVICES \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Video"

typedef BOOL WINAPI T_EnumDisplayDevicesW( LPWSTR lpDevice, 
                                           DWORD iDevNum, 
                                           PDISPLAY_DEVICEW lpDisplayDevice, 
                                           DWORD dwFlags );

typedef DWORD WINAPI T_GetNetworkParams( PFIXED_INFO pFixedInfo, 
                                         PULONG pOutBufLen );

typedef DWORD T_GetAdaptersInfo( PIP_ADAPTER_INFO pAdapterInfo, 
                                 PULONG pOutBufLen );

typedef DWORD T_GetPerAdapterInfo( ULONG IfIndex, 
                                   PIP_PER_ADAPTER_INFO pPerAdapterInfo, 
                                   PULONG pOutBufLen );

NTSTATUS 
WmipRegOpenKey(
    IN LPWSTR lpKeyName,
    OUT PHANDLE KeyHandle
    )
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      KeyName;
    RtlInitUnicodeString( &KeyName, lpKeyName );
    RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));

    InitializeObjectAttributes(
                &ObjectAttributes,
                &KeyName,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL
                );

    return NtOpenKey( KeyHandle, KEY_READ, &ObjectAttributes );
}


NTSTATUS
WmipRegQueryValueKey(
    IN HANDLE KeyHandle,
    IN LPWSTR lpValueName,
    IN ULONG  Length,
    OUT PVOID KeyValue,
    OUT PULONG ResultLength
    )
{
    UNICODE_STRING ValueName;
    ULONG BufferLength;
    NTSTATUS Status;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    RtlInitUnicodeString( &ValueName, lpValueName );

    BufferLength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + Length;
    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) 
                          RtlAllocateHeap (RtlProcessHeap(),0,BufferLength);
    if (KeyValueInformation == NULL) {
        return STATUS_NO_MEMORY;
    }

    Status = NtQueryValueKey(
                KeyHandle,

                &ValueName,
                KeyValuePartialInformation,
                KeyValueInformation,
                BufferLength,
                ResultLength
                );
    if (NT_SUCCESS(Status)) {

        RtlCopyMemory(KeyValue, 
                      KeyValueInformation->Data, 
                      KeyValueInformation->DataLength
                     );

        *ResultLength = KeyValueInformation->DataLength;
        if (KeyValueInformation->Type == REG_SZ) {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > Length) {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            ((PUCHAR)KeyValue)[KeyValueInformation->DataLength++] = 0;
            ((PUCHAR)KeyValue)[KeyValueInformation->DataLength] = 0;
            *ResultLength = KeyValueInformation->DataLength + sizeof(WCHAR);
        }
    }
    RtlFreeHeap(RtlProcessHeap(),0,KeyValueInformation);
    return Status;
}


BOOL
WmipIsVolumeName(
    LPWSTR Name
    )
{
    if (Name[0] == '\\' &&
        (Name[1] == '?' || Name[1] == '\\') &&
        Name[2] == '?' &&
        Name[3] == '\\' &&
        Name[4] == 'V' &&
        Name[5] == 'o' &&
        Name[6] == 'l' &&
        Name[7] == 'u' &&
        Name[8] == 'm' &&
        Name[9] == 'e' &&
        Name[10] == '{' &&
        Name[19] == '-' &&
        Name[24] == '-' &&
        Name[29] == '-' &&
        Name[34] == '-' &&
        Name[47] == '}' ) {

        return TRUE;
        }
    return FALSE;
}

NTSTATUS
WmipGetCpuSpeed(
    OUT DWORD* CpuNum,
    OUT DWORD* CpuSpeed
    )
{
    PWCHAR Buffer = NULL;
    NTSTATUS Status;
    ULONG DataLength;
    DWORD Size = MAXSTR;
    HANDLE Handle = INVALID_HANDLE_VALUE;

    Buffer = RtlAllocateHeap (RtlProcessHeap(),0,DEFAULT_ALLOC_SIZE);
    if (Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    swprintf(Buffer, L"%ws\\%u", CPU_ROOT, *CpuNum);
    Status = WmipRegOpenKey((LPWSTR)Buffer, &Handle);

    if (NT_SUCCESS(Status)) {
        swprintf(Buffer, MHZ_VALUE_NAME);
        Size = sizeof(DWORD);
        Status = WmipRegQueryValueKey(Handle,
                                   (LPWSTR) Buffer,
                                   Size,
                                   CpuSpeed,
                                   &DataLength
                                   );
        NtClose(Handle);
        if(Buffer) {
            RtlFreeHeap (RtlProcessHeap(),0,Buffer);
        }
        return Status;
    }

    *CpuSpeed = 0;
    if(Buffer) {
        RtlFreeHeap (RtlProcessHeap(),0,Buffer);
    }

    return STATUS_UNSUCCESSFUL;
}

ULONG
WmipGetCpuConfig(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    PWCHAR Buffer = NULL;
    WCHAR ComputerName[MAXSTR];
    ULONG CpuNum;
    ULONG CpuSpeed;
    DWORD Size = MAXSTR;
    SYSTEM_INFO SysInfo;
    MEMORYSTATUS MemStatus;
    NTSTATUS Status;
    HANDLE Handle;
    ULONG DataLength;
    ULONG StringSize;
    ULONG SizeNeeded;
    PCPU_CONFIG_RECORD CpuConfig = NULL;
    PFIXED_INFO pFixedInfo = NULL;
    DWORD ErrorCode;
    ULONG NetworkParamsSize;
    T_GetNetworkParams *pfnGetNetworkParams = NULL;
    HINSTANCE hIphlpapiDll = NULL;


    Buffer = RtlAllocateHeap (RtlProcessHeap(),0,DEFAULT_ALLOC_SIZE);
    if (Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    GlobalMemoryStatus(&MemStatus);


    swprintf(Buffer, COMPUTERNAME_ROOT);

    Status = WmipRegOpenKey((LPWSTR)Buffer, &Handle);

    if (!NT_SUCCESS(Status)) {
        goto CpuCleanup;
    }

    swprintf(Buffer, COMPUTERNAME_VALUE_NAME);
    Size = (MAX_DEVICE_ID_LENGTH) * sizeof (WCHAR);

CpuQuery:
    Status = WmipRegQueryValueKey(Handle,
                               (LPWSTR) Buffer,
                               Size,
                               ComputerName,
                               &StringSize
                               );

    if (Status == STATUS_BUFFER_OVERFLOW) {
        RtlFreeHeap (RtlProcessHeap(),0,Buffer);
        Buffer = RtlAllocateHeap (RtlProcessHeap(),0,StringSize);
        if (Buffer == NULL) {
            NtClose(Handle);
            return STATUS_NO_MEMORY;
        }
        goto CpuQuery;
    }

    NtClose(Handle);
    if (!NT_SUCCESS(Status) ) {
        goto CpuCleanup;
    }

    //
    // Get Architecture Type, Processor Type and Level Stepping...
    //
    CpuNum = 0;
    WmipGetCpuSpeed(&CpuNum, &CpuSpeed);

    GetSystemInfo(&SysInfo);

    //
    // Get the Hostname and DomainName
    //

    // delay load iphlpapi.lib to Get network params
    hIphlpapiDll = LoadLibraryW(L"iphlpapi.dll");
    if (hIphlpapiDll == NULL) {
       goto CpuCleanup;
    }
    pfnGetNetworkParams = (T_GetNetworkParams*) GetProcAddress(hIphlpapiDll, "GetNetworkParams");
    if(pfnGetNetworkParams == NULL) {
        goto CpuCleanup;
    }

    pfnGetNetworkParams(NULL, &NetworkParamsSize);
    pFixedInfo = (PFIXED_INFO)RtlAllocateHeap (RtlProcessHeap(),0,NetworkParamsSize);
    if(pFixedInfo == NULL) {
        goto CpuCleanup;
    }

    ErrorCode = pfnGetNetworkParams(pFixedInfo, &NetworkParamsSize);

    if(ErrorCode != ERROR_SUCCESS) {
        goto CpuCleanup;
    }

    //
    // Create EventTrace record for CPU configuration and write it
    //

    SizeNeeded = sizeof(CPU_CONFIG_RECORD) + StringSize + (CONFIG_MAX_DOMAIN_NAME_LEN);

    CpuConfig = (PCPU_CONFIG_RECORD) WmipGetTraceBuffer(LoggerContext,
                                                NULL,
                                                EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_CPU,
                                                SizeNeeded);
    if (CpuConfig == NULL) {
        Status = STATUS_NO_MEMORY;
        goto CpuCleanup;
    }

    CpuConfig->NumberOfProcessors = SysInfo.dwNumberOfProcessors;
    CpuConfig->ProcessorSpeed = CpuSpeed;
    CpuConfig->MemorySize = (ULONG)(((MemStatus.dwTotalPhys + 512) / 1024) + 512) / 1024;
    CpuConfig->PageSize = SysInfo.dwPageSize;
    CpuConfig->AllocationGranularity = SysInfo.dwAllocationGranularity;

    MultiByteToWideChar(CP_ACP,
                            0,
                            pFixedInfo->DomainName,
                            -1,
                            CpuConfig->DomainName,
                            CONFIG_MAX_DOMAIN_NAME_LEN);

    RtlCopyMemory(&CpuConfig->ComputerName, ComputerName, StringSize);
    CpuConfig->ComputerName[StringSize/2] = 0;

CpuCleanup:
    if (Buffer != NULL) {
        RtlFreeHeap (RtlProcessHeap(),0,Buffer);
    }
    if(pFixedInfo) {
        RtlFreeHeap (RtlProcessHeap(),0,pFixedInfo);
    }
    if(hIphlpapiDll) {
        FreeLibrary(hIphlpapiDll);
    }

    return Status;
}


// Function to get logical disk
NTSTATUS
GetIoFixedDrive(
    OUT PLOGICAL_DISK_EXTENTS* ppFdi,
    IN WCHAR* DriveLetterString
    )
{
    DWORD i,dwLastError;
    WCHAR DeviceName[MAXSTR];
    BOOLEAN IsVolume = FALSE;
    PARTITION_INFORMATION PartitionInfo;
    STORAGE_DEVICE_NUMBER StorageDeviceNum;
    HANDLE VolumeHandle;
    ULONG BytesTransferred;     
    WCHAR DriveRootName[CONFIG_DRIVE_LETTER_LEN];
    PLOGICAL_DISK_EXTENTS pFdi = NULL;
    INT FixedDiskInfoSize;
    BOOL bRet;
    DWORD bytes;
    ULONG BufSize;
    CHAR* pBuf = NULL;
    CHAR* pNew = NULL;
    PVOLUME_DISK_EXTENTS pVolExt = NULL;
    PDISK_EXTENT pDiskExt = NULL;
    ULARGE_INTEGER TotalBytes;
    ULARGE_INTEGER TotalFreeBytes;  
    ULARGE_INTEGER FreeBytesToCaller;
    ULONG TotalClusters;
    ULONG TotalFreeClusters;
    PUCHAR VolumeExtPtr = NULL;

    FixedDiskInfoSize = sizeof(LOGICAL_DISK_EXTENTS);
    //
    // First, we must calculate the size of FixedDiskInfo structure
    // non-partition logical drives have different size
    //
    swprintf(DeviceName, L"\\\\.\\%s",DriveLetterString);
    VolumeHandle = CreateFileW(DeviceName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        INVALID_HANDLE_VALUE);

    if (VolumeHandle == INVALID_HANDLE_VALUE) {
        dwLastError = GetLastError();
        goto ErrorExit;
    }

    bRet = DeviceIoControl(VolumeHandle,
                           IOCTL_STORAGE_GET_DEVICE_NUMBER,
                           NULL,
                           0,
                           &StorageDeviceNum,
                           sizeof(StorageDeviceNum),
                           &bytes,
                           NULL);
    if (!bRet)
    {
        //
        // This is Volume
        // 
        BufSize = 2048;
        pBuf = RtlAllocateHeap (RtlProcessHeap(),0,BufSize);
        if (pBuf == NULL) {
            dwLastError = GetLastError();
            goto ErrorExit;
        }

        //
        // Well, the drive letter is for a volume.
        //
retry:
        bRet = DeviceIoControl(VolumeHandle,
                            IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                            NULL,
                            0,
                            pBuf,
                            BufSize,
                            &bytes,
                            NULL);

        dwLastError = GetLastError();
        if (!bRet && dwLastError == ERROR_INSUFFICIENT_BUFFER)
        {
            BufSize = bytes;
            if(pBuf) {
                RtlFreeHeap (RtlProcessHeap(),0,pBuf);
            }
            pNew = RtlAllocateHeap (RtlProcessHeap(),0,BufSize);
            //
            // We can not reallocate memory, exit.
            //
            if (pNew == NULL){
                dwLastError = GetLastError();
                goto ErrorExit;
            }
            else
                pBuf = pNew;

            goto retry;
        }

        if (!bRet) {
            goto ErrorExit;
        }
        pVolExt = (PVOLUME_DISK_EXTENTS)pBuf;
        IsVolume=TRUE;
        FixedDiskInfoSize += sizeof(VOLUME_DISK_EXTENTS) + (pVolExt->NumberOfDiskExtents) * sizeof(DISK_EXTENT);
    }

    pFdi = (PLOGICAL_DISK_EXTENTS) RtlAllocateHeap (RtlProcessHeap(),0,FixedDiskInfoSize);
    if (pFdi == NULL) {
       goto ErrorExit;
    }
    pFdi->VolumeExt = 0;
    pFdi->Size = FixedDiskInfoSize;

    if (IsVolume) {
        pFdi->DriveType = CONFIG_DRIVE_VOLUME;
        //
        // Volume can span multiple hard disks, so here we set the DriverNumber to -1
        //
        pFdi->DiskNumber = (ULONG)(-1);
        pFdi->PartitionNumber = 1;

        pFdi->VolumeExt = FIELD_OFFSET (LOGICAL_DISK_EXTENTS, VolumeExt);
        VolumeExtPtr = (PUCHAR) OffsetToPtr (pFdi, pFdi->VolumeExt);
        RtlCopyMemory(VolumeExtPtr, 
                      pVolExt,
                      sizeof(VOLUME_DISK_EXTENTS) + (pVolExt->NumberOfDiskExtents) * sizeof(DISK_EXTENT));
    }
    else {
        pFdi->DriveType = CONFIG_DRIVE_PARTITION;
        pFdi->DiskNumber = StorageDeviceNum.DeviceNumber;
        pFdi->PartitionNumber = StorageDeviceNum.PartitionNumber;
    }

    pFdi->DriveLetterString[0] = DriveLetterString[0];
    pFdi->DriveLetterString[1] = DriveLetterString[1];
    pFdi->DriveLetterString[2] = DriveLetterString[2];
    
    DriveRootName[0] = pFdi->DriveLetterString[0];
    DriveRootName[1] = pFdi->DriveLetterString[1];
    DriveRootName[2] = L'\\';
    DriveRootName[3] = UNICODE_NULL; 

    pFdi->SectorsPerCluster = 0;
    pFdi->BytesPerSector = 0;
    pFdi->NumberOfFreeClusters = 0;
    pFdi->TotalNumberOfClusters = 0;

    //
    // Get partition information.
    //
    if ( !DeviceIoControl(VolumeHandle,
                          IOCTL_DISK_GET_PARTITION_INFO,
                          NULL,
                          0,
                          &PartitionInfo,
                          sizeof( PartitionInfo ),
                          &BytesTransferred,
                          NULL ) ) {

        dwLastError = GetLastError();
        goto ErrorExit;
    }
    CloseHandle(VolumeHandle);
    VolumeHandle = NULL;
    if (pBuf) {
        RtlFreeHeap (RtlProcessHeap(),0,pBuf);
    }
    pBuf = NULL;

    //
    // Get the information of the logical drive
    //
    if (!GetDiskFreeSpaceW(DriveRootName,
                          &pFdi->SectorsPerCluster,
                          &pFdi->BytesPerSector,
                          &TotalFreeClusters,
                          &TotalClusters)) {

        dwLastError = GetLastError();
        if(dwLastError == ERROR_UNRECOGNIZED_VOLUME) {
            //
            // This could be a partition that has been assigned drive letter but not yet formatted
            //
            goto SkipFreeSpace;
        }
        goto ErrorExit;
    }

    if (!GetDiskFreeSpaceExW(DriveRootName,
                            &FreeBytesToCaller,
                            &TotalBytes,
                            &TotalFreeBytes)) {

        dwLastError = GetLastError();
        if(dwLastError == ERROR_UNRECOGNIZED_VOLUME) {
            //
            // This could be a partition that has been assigned drive letter but not yet formatted
            //
            goto SkipFreeSpace;
        }
        goto ErrorExit;
    }

    pFdi->NumberOfFreeClusters = TotalFreeBytes.QuadPart / (pFdi->BytesPerSector * pFdi->SectorsPerCluster);
    pFdi->TotalNumberOfClusters = TotalBytes.QuadPart / (pFdi->BytesPerSector * pFdi->SectorsPerCluster);

SkipFreeSpace:
    pFdi->StartingOffset = PartitionInfo.StartingOffset.QuadPart;
    pFdi->PartitionSize = (ULONGLONG)(((ULONGLONG)pFdi->TotalNumberOfClusters) *
                               ((ULONGLONG)pFdi->SectorsPerCluster) *
                               ((ULONGLONG)pFdi->BytesPerSector));

    //
    // Get the file system type of the logical drive
    //
    if (!GetVolumeInformationW(DriveRootName,
                              NULL,
                              0,
                              NULL,
                              NULL,
                              NULL,
                              pFdi->FileSystemType,
                              sizeof(pFdi->FileSystemType))
                             )
    {
        wcscpy(pFdi->FileSystemType, L"(unknown)");
    }

    *ppFdi = pFdi;

    if (VolumeHandle != INVALID_HANDLE_VALUE) {
        CloseHandle( VolumeHandle );
    }

    return STATUS_SUCCESS;

ErrorExit:

    if (VolumeHandle != INVALID_HANDLE_VALUE) {
        CloseHandle( VolumeHandle );
        VolumeHandle = INVALID_HANDLE_VALUE;
    }
    if (pFdi) {
        RtlFreeHeap (RtlProcessHeap(),0,pFdi);
    }
    if (pBuf) {
        RtlFreeHeap (RtlProcessHeap(),0,pBuf);
    }

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
WmipGetDiskInfo(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    PUCHAR Buffer = NULL;
    STORAGE_DEVICE_NUMBER Number;
    PMOUNTMGR_MOUNT_POINTS mountPoints = NULL;
    MOUNTMGR_MOUNT_POINT mountPoint;
    ULONG returnSize, success;
    SYSTEM_DEVICE_INFORMATION DevInfo;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG NumberOfDisks;
    PWCHAR deviceNameBuffer;
    ULONG i;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatus;

    DISK_GEOMETRY disk_geometry;
    PDISK_CACHE_INFORMATION disk_cache = NULL;
    PSCSI_ADDRESS scsi_address = NULL;
    PWCHAR KeyName = NULL;
    HANDLE              hDisk = INVALID_HANDLE_VALUE;
    UNICODE_STRING      UnicodeName;

    PPHYSICAL_DISK_RECORD Disk = NULL;
    PLOGICAL_DISK_EXTENTS pLogicalDisk = NULL;
    PLOGICAL_DISK_EXTENTS pDiskExtents = NULL;
    ULONG SizeNeeded;
    WCHAR  LogicalDrives[MAXSTR];
    LPWSTR Drive = NULL;
    DWORD  Chars;
    ULONG BufferDataLength;

    Buffer = RtlAllocateHeap (RtlProcessHeap(),0,DEFAULT_ALLOC_SIZE);
    if (Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    //  Get the Number of Physical Disks
    //

    RtlZeroMemory(&DevInfo, sizeof(DevInfo));

    Status = NtQuerySystemInformation(
                 SystemDeviceInformation,
                 &DevInfo, sizeof (DevInfo), NULL);

    if (!NT_SUCCESS(Status)) {
        goto DiskCleanup;
    }

    NumberOfDisks = DevInfo.NumberOfDisks;

    //
    // Open Each Physical Disk and get Disk Layout information
    //
    for (i=0; i < NumberOfDisks; i++) {

        DISK_CACHE_INFORMATION cacheInfo;
        HANDLE PartitionHandle;
        HANDLE KeyHandle;
        ULONG DataLength;
        WCHAR BootDrive[MAX_PATH];
        WCHAR BootDriveLetter;
        WCHAR  DriveBuffer[MAXSTR];
        PDRIVE_LAYOUT_INFORMATION pDriveLayout = NULL;
        ULONG PartitionCount;
        ULONG j;
        BOOL bSuccess = FALSE;
        DWORD BufSize;
        ULONG Size = DEFAULT_ALLOC_SIZE;
        BOOL bValidDiskCacheInfo = FALSE;

        RtlZeroMemory(&disk_geometry, sizeof(DISK_GEOMETRY));        
        RtlZeroMemory(&cacheInfo, sizeof(DISK_CACHE_INFORMATION));
        PartitionCount = 0;
        BootDriveLetter = UNICODE_NULL;

        //
        // Get Boot Drive Letter
        //
        if(GetSystemDirectoryW(BootDrive, MAX_PATH)) {
            BootDriveLetter = BootDrive[0];
        }

        swprintf(DriveBuffer, L"\\\\.\\PhysicalDrive%d", i);

        hDisk = CreateFileW(DriveBuffer,
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);
        if(hDisk == INVALID_HANDLE_VALUE) {
            goto DiskCleanup;
        }

        //
        // Get Partition0 handle to get the Disk layout 
        //
        deviceNameBuffer = (PWCHAR) Buffer;
        swprintf(deviceNameBuffer, L"\\Device\\Harddisk%d\\Partition0", i);

        RtlInitUnicodeString(&UnicodeName, deviceNameBuffer);

        InitializeObjectAttributes(
                   &ObjectAttributes,
                   &UnicodeName,
                   OBJ_CASE_INSENSITIVE,
                   NULL,
                   NULL
                   );
        Status = NtOpenFile(
                &PartitionHandle,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatus,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                );

        if (!NT_SUCCESS(Status)) {
            goto DiskCleanup;
        }

        //
        // Get geomerty information
        //
        Status = NtDeviceIoControlFile(PartitionHandle,
                       0,
                       NULL,
                       NULL,
                       &IoStatus,
                       IOCTL_DISK_GET_DRIVE_GEOMETRY,
                       NULL,
                       0,
                       &disk_geometry,
                       sizeof (DISK_GEOMETRY)
                       );
        
        if (!NT_SUCCESS(Status)) {
            NtClose(PartitionHandle);
            goto SkipPartition;
        }

        //
        // Get the scci information
        //
        scsi_address = (PSCSI_ADDRESS) Buffer;
        Status = NtDeviceIoControlFile(PartitionHandle,
                        0,
                        NULL,
                        NULL,
                        &IoStatus,
                        IOCTL_SCSI_GET_ADDRESS,
                        NULL,
                        0,
                        scsi_address,
                        sizeof (SCSI_ADDRESS)
                        );
        NtClose(PartitionHandle);

        if (!NT_SUCCESS(Status)) {
            goto DiskCleanup;
        }

        //
        // Get Manufacturer's name from Registry
        // We need to get the SCSI Address and then query the Registry with it.
        //
        KeyName = (PWCHAR) Buffer;
        swprintf(KeyName, 
                 L"\\Registry\\Machine\\Hardware\\DeviceMap\\Scsi\\Scsi Port %d\\Scsi Bus %d\\Target ID %d\\Logical Unit Id %d",
                 scsi_address->PortNumber, scsi_address->PathId, scsi_address->TargetId, scsi_address->Lun
                );
        Status = WmipRegOpenKey(KeyName, &KeyHandle);
        if (!NT_SUCCESS(Status)) {
            goto DiskCleanup;
        }

        Size = DEFAULT_ALLOC_SIZE;
        RtlZeroMemory(Buffer, Size);
DiskQuery:
        Status = WmipRegQueryValueKey(KeyHandle,
                                      L"Identifier",
                                      Size,
                                      Buffer, &BufferDataLength);
        if (Status == STATUS_BUFFER_OVERFLOW) {
            RtlFreeHeap (RtlProcessHeap(),0,Buffer);
            Buffer = RtlAllocateHeap (RtlProcessHeap(),0,BufferDataLength);
            if (Buffer == NULL) {
                NtClose(KeyHandle);
                Status = STATUS_NO_MEMORY;
                goto DiskCleanup;
            }
            goto DiskQuery;
        }

        NtClose(KeyHandle);
        if (!NT_SUCCESS(Status) ) {
            goto DiskCleanup;
        }

        //
        // Get the total partitions on the drive
        //
        BufSize = 2048;
        pDriveLayout = (PDRIVE_LAYOUT_INFORMATION)RtlAllocateHeap (RtlProcessHeap(),0,BufSize);
        if(pDriveLayout == NULL) {
            goto DiskCleanup;
        }
        RtlZeroMemory(pDriveLayout, BufSize);
        bSuccess = DeviceIoControl (
                            hDisk,
                            IOCTL_DISK_GET_DRIVE_LAYOUT,
                            NULL,
                            0,
                            pDriveLayout,
                            BufSize,
                            &DataLength,
                            NULL
                            );
        if(bSuccess == FALSE && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        BufSize = DataLength;
        if(pDriveLayout) {
            RtlFreeHeap (RtlProcessHeap(),0,pDriveLayout);
        }
        pDriveLayout = RtlAllocateHeap (RtlProcessHeap(),0,BufSize);
        if(pDriveLayout == NULL) {
            Status = STATUS_NO_MEMORY;
            goto DiskCleanup;
        }
        else {
            bSuccess = DeviceIoControl (
                            hDisk,
                            IOCTL_DISK_GET_DRIVE_LAYOUT,
                            NULL,
                            0,
                            pDriveLayout,
                            BufSize,
                            &DataLength,
                            NULL
                            );
            }
        }

        if(bSuccess == FALSE) {
            //
            // If media type is not fixed media and device is not ready then dont query partition info.
            //
            if(disk_geometry.MediaType != FixedMedia && GetLastError() == ERROR_NOT_READY) {
                goto SkipPartition;
            }

            if(pDriveLayout) {
                RtlFreeHeap (RtlProcessHeap(),0,pDriveLayout);
                pDriveLayout = NULL;
            }
            continue;
        }

        //
        // Get Partition count for the current disk
        //
        PartitionCount = 0;
        j = 0;
        while (j < pDriveLayout->PartitionCount) {
            if (pDriveLayout->PartitionEntry[j].PartitionNumber != 0) {
                PartitionCount++;
            }
            j++;
        }

        //
        // Get cache info - IOCTL_DISK_GET_CACHE_INFORMATION
        //
        bValidDiskCacheInfo = DeviceIoControl(hDisk,
                                              IOCTL_DISK_GET_CACHE_INFORMATION,
                                              NULL,
                                              0,
                                              &cacheInfo,
                                              sizeof(DISK_CACHE_INFORMATION),
                                              &DataLength,
                                              NULL);

        NtClose(hDisk);
        hDisk = INVALID_HANDLE_VALUE;

        //
        // Free drivelayout structure
        //
        if(pDriveLayout) {
            RtlFreeHeap (RtlProcessHeap(),0,pDriveLayout);
            pDriveLayout = NULL;
        }

SkipPartition:

        //
        // Package all information about this disk and write an event record
        //

        SizeNeeded = sizeof(PHYSICAL_DISK_RECORD) + BufferDataLength;

        Disk = (PPHYSICAL_DISK_RECORD) WmipGetTraceBuffer( LoggerContext, 
                                                           NULL,
                                                           EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_PHYSICALDISK,
                                                           SizeNeeded);

        if (Disk == NULL) {
            Status = STATUS_NO_MEMORY;
            goto DiskCleanup;
        }

        Disk->DiskNumber =  i;
        Disk->BytesPerSector = disk_geometry.BytesPerSector;
        Disk->SectorsPerTrack = disk_geometry.SectorsPerTrack;
        Disk->TracksPerCylinder = disk_geometry.TracksPerCylinder;
        Disk->Cylinders = disk_geometry.Cylinders.QuadPart;
        Disk->SCSIPortNumber = scsi_address->PortNumber;
        Disk->SCSIPathId = scsi_address->PathId;
        Disk->SCSITargetId = scsi_address->TargetId;
        Disk->SCSILun = scsi_address->Lun;
        Disk->BootDriveLetter[0] = BootDriveLetter;
        if (bValidDiskCacheInfo && cacheInfo.WriteCacheEnabled) {
            Disk->WriteCacheEnabled = TRUE;
        }
        Disk->PartitionCount = PartitionCount;
        if(BufferDataLength > MAX_DEVICE_ID_LENGTH) BufferDataLength = MAX_DEVICE_ID_LENGTH;
        RtlCopyMemory(Disk->Manufacturer, Buffer, BufferDataLength);
        Disk->Manufacturer[BufferDataLength/2] = 0;
    }

    //
    // Retrieve the logical drive strings from the system.
    //
    Chars = GetLogicalDriveStringsW(MAXSTR, LogicalDrives);
    Drive = LogicalDrives;
   
    //
    // How many logical drives in physical disks exist?
    //
    while ( *Drive ) {
        WCHAR  DriveLetter[CONFIG_BOOT_DRIVE_LEN];

        DriveLetter[ 0 ] = Drive [ 0 ];
        DriveLetter[ 1 ] = Drive [ 1 ];
        DriveLetter[ 2 ] = UNICODE_NULL;

        if(GetDriveTypeW( Drive ) == DRIVE_FIXED) {
            //
            // If this is a logical drive which resides in a hard disk
            // we need to allocate a FixedDiskInfo structure for it.
            //
            if(GetIoFixedDrive(&pLogicalDisk, DriveLetter) == STATUS_SUCCESS) {
                SizeNeeded = pLogicalDisk->Size;

                //
                // Package all information about this disk and write an event record
                //
                pDiskExtents = (PLOGICAL_DISK_EXTENTS) WmipGetTraceBuffer( LoggerContext, 
                                                           NULL,
                                                           EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_LOGICALDISK,
                                                           SizeNeeded);
                if(pDiskExtents == NULL) {
                    Status = STATUS_NO_MEMORY;
                    goto DiskCleanup;
                }
                
                RtlCopyMemory(pDiskExtents, pLogicalDisk, SizeNeeded);
                RtlFreeHeap (RtlProcessHeap(),0,pLogicalDisk);
                pLogicalDisk = NULL;
            }
        }

        Drive += wcslen( Drive ) + 1;
    }

DiskCleanup:
    if (Buffer != NULL) {
        RtlFreeHeap (RtlProcessHeap(),0,Buffer);
    }
    if(hDisk != INVALID_HANDLE_VALUE) {
        NtClose(hDisk);
    }

    return Status;
}


NTSTATUS
WmipGetVideoAdapters(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    PVIDEO_RECORD Video = NULL;
    VIDEO_RECORD VideoRecord;
    HANDLE hVideoDeviceMap;
    HANDLE hVideoDriver;
    HANDLE hHardwareProfile;
    ULONG DeviceId = 0;
    PWCHAR Device = NULL;
    PWCHAR HardwareProfile = NULL;
    PWCHAR Driver = NULL;
    PWCHAR Buffer = NULL;
    PWCHAR DriverRegistryPath = NULL;

    ULONG ResultLength;
    PCHAR ValueBuffer = NULL;
    ULONG Length;
    BOOLEAN IsAdapter;
    ULONG SizeNeeded;
    NTSTATUS Status;
    INT i;

    DWORD iDevice = 0;
    DISPLAY_DEVICEW dd;
    HINSTANCE hUser32Dll  = NULL;
    T_EnumDisplayDevicesW *pfnEnumDisplayDevicesW = NULL;

    LPWSTR ChipsetInfo[6] = {
        L"HardwareInformation.MemorySize",
        L"HardwareInformation.ChipType",
        L"HardwareInformation.DacType",
        L"HardwareInformation.AdapterString",
        L"HardwareInformation.BiosString",
        L"Device Description"
    };

    LPWSTR SettingInfo[4] = {
        L"DefaultSettings.BitsPerPel",
        L"DefaultSettings.VRefresh",
        L"DefaultSettings.XResolution",
        L"DefaultSettings.YResolution",
    };


    RtlZeroMemory(&dd, sizeof(dd));
    dd.cb = sizeof(dd);

    //
    // Enumerate all the video devices in the system
    //
    Status = WmipRegOpenKey(REG_PATH_VIDEO_DEVICE_MAP, &hVideoDeviceMap);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Allocate memory for local variables on heap
    //
    Device = RtlAllocateHeap (RtlProcessHeap(), 0, DEFAULT_ALLOC_SIZE);
    HardwareProfile = RtlAllocateHeap (RtlProcessHeap(), 0, DEFAULT_ALLOC_SIZE);
    Driver = RtlAllocateHeap (RtlProcessHeap(), 0, DEFAULT_ALLOC_SIZE);
    Buffer = RtlAllocateHeap (RtlProcessHeap(), 0, DEFAULT_ALLOC_SIZE);

    while (TRUE) {
        RtlZeroMemory(&VideoRecord, sizeof(VideoRecord));

        //
        // Open video device
        //
        swprintf(Device, L"\\Device\\Video%d", DeviceId++);

        Status = WmipRegQueryValueKey(hVideoDeviceMap,
                    Device,
                    DEFAULT_ALLOC_SIZE * sizeof(WCHAR),
                    Buffer,
                    &ResultLength
                    );

        if (!NT_SUCCESS(Status)) {
            Status = STATUS_SUCCESS;
            break;
        }

        //
        // Open the driver registry key
        //
        Status = WmipRegOpenKey(Buffer, &hVideoDriver);
        if (!NT_SUCCESS(Status)) {
            continue;
        }

        //
        // Get Video adapter information.
        //
        IsAdapter = TRUE;
        for (i = 0; i < 6; i++) {
            switch (i ) {
                case 0:
                    ValueBuffer = (PCHAR)&VideoRecord.MemorySize;
                    Length = sizeof(VideoRecord.MemorySize);
                    break;

                case 1:
                    ValueBuffer = (PCHAR)&VideoRecord.ChipType;
                    Length = sizeof(VideoRecord.ChipType);
                    break;

                case 2:
                    ValueBuffer = (PCHAR)&VideoRecord.DACType;
                    Length = sizeof(VideoRecord.DACType);
                    break;

                case 3:
                    ValueBuffer = (PCHAR)&VideoRecord.AdapterString;
                    Length = sizeof(VideoRecord.AdapterString);
                    break;

                case 4:
                    ValueBuffer = (PCHAR)&VideoRecord.BiosString;
                    Length = sizeof(VideoRecord.BiosString);
                    break;

                case 5:
                    ValueBuffer = (PCHAR)&VideoRecord.DeviceId;
                    Length = sizeof(VideoRecord.DeviceId);
                    break;
            }

            //
            // Query the size of the data
            //
            Status = WmipRegQueryValueKey(hVideoDriver,
                                    ChipsetInfo[i],
                                    Length,
                                    ValueBuffer,
                                    &ResultLength);
            //
            // If we can not get the hardware information, this
            // is  not adapter
            //
            if (!NT_SUCCESS(Status)) {
                IsAdapter = FALSE;
                break;
            }
        }
        
        NtClose(hVideoDriver);
        if (IsAdapter == FALSE) {
            continue;
        }

        DriverRegistryPath = wcsstr(Buffer, L"{");
        if(DriverRegistryPath == NULL) {
            continue;
        }

        swprintf(HardwareProfile, L"%s\\%s", REG_PATH_VIDEO_HARDWARE_PROFILE, DriverRegistryPath);
        Status = WmipRegOpenKey(HardwareProfile, &hHardwareProfile);
        if (!NT_SUCCESS(Status)) {
            continue;
        }

        for (i = 0; i < 4; i++) {
            switch (i ) {
                case 0:
                    ValueBuffer = (PCHAR)&VideoRecord.BitsPerPixel;
                    Length = sizeof(VideoRecord.BitsPerPixel);
                    break;

                case 1:
                    ValueBuffer = (PCHAR)&VideoRecord.VRefresh;
                    Length = sizeof(VideoRecord.VRefresh);
                    break;

                case 2:
                    ValueBuffer = (PCHAR)&VideoRecord.XResolution;
                    Length = sizeof(VideoRecord.XResolution);
                    break;

                case 3:
                    ValueBuffer = (PCHAR)&VideoRecord.YResolution;
                    Length = sizeof(VideoRecord.YResolution);
                    break;
            }

            //
            // Query the size of the data
            //
            Status = WmipRegQueryValueKey(hHardwareProfile,
                                    SettingInfo[i],
                                    Length,
                                    ValueBuffer,
                                    &ResultLength);
        }

        NtClose(hHardwareProfile);

        //
        // delay load user32.lib to enum display devices function
        //
        hUser32Dll = LoadLibraryW(L"user32.dll");
        if (hUser32Dll == NULL) {
            break;
        }
        pfnEnumDisplayDevicesW = (T_EnumDisplayDevicesW *) GetProcAddress(hUser32Dll, "EnumDisplayDevicesW");
        if(pfnEnumDisplayDevicesW == NULL) {
            break;
        }

        while (pfnEnumDisplayDevicesW(NULL, iDevice++, &dd, 0)) {    
            if (_wcsicmp(VideoRecord.DeviceId, dd.DeviceString) == 0) {
                if (dd.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) {
                    VideoRecord.StateFlags = (ULONG)dd.StateFlags;
                }
                break;
                iDevice = 0;
            }
       }

        //
        // Package all information about this disk and write an event record
        //

        SizeNeeded = sizeof(VIDEO_RECORD);

        Video = (PVIDEO_RECORD) WmipGetTraceBuffer( LoggerContext,
                                                   NULL,
                                                   EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_VIDEO,
                                                   SizeNeeded);

        if (Video == NULL) {
            Status = STATUS_NO_MEMORY;
            break;
        }
        RtlCopyMemory(Video, &VideoRecord, sizeof(VIDEO_RECORD));
    }

    NtClose(hVideoDeviceMap);
    if (hUser32Dll) {
        FreeLibrary(hUser32Dll);
    }

    //
    // Free local variables allocated on heap
    //
    if(Device) {
        RtlFreeHeap (RtlProcessHeap(), 0, Device);
    }

    if(HardwareProfile) {
        RtlFreeHeap (RtlProcessHeap(), 0, HardwareProfile);
    }
    
    if(Driver) {
        RtlFreeHeap (RtlProcessHeap(), 0, Driver);
    }

    if(Buffer) {
        RtlFreeHeap (RtlProcessHeap(), 0, Buffer);
    }

    return Status;
}



NTSTATUS 
WmipGetNetworkAdapters(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    DWORD  IfNum;
    DWORD  Ret;
    PIP_ADAPTER_INFO pAdapterList = NULL, pAdapterListHead = NULL;
    PIP_PER_ADAPTER_INFO pPerAdapterInfo = NULL;
    PFIXED_INFO pFixedInfo = NULL;
    PIP_ADDR_STRING pIpAddressList = NULL;
    ULONG OutBufLen = 0;
    INT i;
    NIC_RECORD AdapterInfo;
    PNIC_RECORD pAdapterInfo = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    INT IpAddrLen = 0;
    T_GetAdaptersInfo *pfnGetAdaptersInfo = NULL;
    T_GetPerAdapterInfo *pfnGetPerAdapterInfo = NULL;
    HINSTANCE hIphlpapiDll = NULL;
    PUCHAR IpDataPtr = NULL;

    // delay load iphlpapi.lib to Get network params
    hIphlpapiDll = LoadLibraryW(L"iphlpapi.dll");
    if (hIphlpapiDll == NULL) {
        goto IpCleanup;
    }
    pfnGetAdaptersInfo = (T_GetAdaptersInfo*) GetProcAddress(hIphlpapiDll, "GetAdaptersInfo");
    if(pfnGetAdaptersInfo == NULL) {
        goto IpCleanup;
    }
    
    pfnGetPerAdapterInfo = (T_GetPerAdapterInfo*) GetProcAddress(hIphlpapiDll, "GetPerAdapterInfo");
    if(pfnGetPerAdapterInfo == NULL) {
        goto IpCleanup;
    }

    //
    // Get number of adapters
    //
    pfnGetAdaptersInfo(NULL, &OutBufLen);

TryAgain:
    pAdapterList = (PIP_ADAPTER_INFO)RtlAllocateHeap (RtlProcessHeap(),0,OutBufLen);
    if (pAdapterList == NULL) {
        Status = STATUS_NO_MEMORY;
        goto IpCleanup;
    }

    Ret = pfnGetAdaptersInfo(pAdapterList, &OutBufLen);
    if (Ret == ERROR_BUFFER_OVERFLOW) {
        RtlFreeHeap (RtlProcessHeap(),0,pAdapterList);
        Status = !STATUS_SUCCESS;
        goto TryAgain;
    }
    else if (Ret != ERROR_SUCCESS) {
        if (pAdapterList != NULL) {
            RtlFreeHeap (RtlProcessHeap(),0,pAdapterList);
        }
        Status = !STATUS_SUCCESS;
        goto IpCleanup;
    }

    //
    // Calculate the total length for all the IP Addresses
    //
    IpAddrLen = sizeof(IP_ADDRESS_STRING) * CONFIG_MAX_DNS_SERVER; // Length of 4 DNS Server IP Address
    IpAddrLen += sizeof(IP_ADDRESS_STRING); // Length of IP Address
    IpAddrLen += sizeof(IP_ADDRESS_STRING); // Length of IP Mask
    IpAddrLen += sizeof(IP_ADDRESS_STRING); // Length of DHCP Server IP Address
    IpAddrLen += sizeof(IP_ADDRESS_STRING); // Length of Gateway IP Address
    IpAddrLen += sizeof(IP_ADDRESS_STRING); // Length of Primary Wins Server IP Address
    IpAddrLen += sizeof(IP_ADDRESS_STRING); // Length of Secondary Wins Server IP Address

    //
    // Allocate memory for NIC_RECORD
    //
    RtlZeroMemory(&AdapterInfo, sizeof(AdapterInfo));

    //
    // Fill out the information per adapter
    //
    pAdapterListHead = pAdapterList;
    while (pAdapterList ) {
        MultiByteToWideChar(CP_ACP,
                            0,
                            (LPCSTR)pAdapterList->Description,
                            -1,
                            (LPWSTR)AdapterInfo.NICName,
                            MAX_DEVICE_ID_LENGTH);

        AdapterInfo.Index = (ULONG)pAdapterList->Index;

        //
        // Copy the Physical address of NIC
        //
        AdapterInfo.PhysicalAddrLen = pAdapterList->AddressLength;
        RtlCopyMemory(AdapterInfo.PhysicalAddr, pAdapterList->Address, pAdapterList->AddressLength);

        //
        // Set the size of the Data
        //
        AdapterInfo.Size = IpAddrLen;

        //
        // Get DNS server list for this adapter
        // 
        pfnGetPerAdapterInfo(pAdapterList->Index, NULL, &OutBufLen);

        pPerAdapterInfo = (PIP_PER_ADAPTER_INFO)RtlAllocateHeap (RtlProcessHeap(),0,OutBufLen);
        if (!pPerAdapterInfo) {
            Status = STATUS_NO_MEMORY;
            goto IpCleanup;
        }

        pfnGetPerAdapterInfo(pAdapterList->Index, pPerAdapterInfo, &OutBufLen);

        //
        // Package all information about this NIC and write an event record
        //
        pAdapterInfo = (PNIC_RECORD) WmipGetTraceBuffer( LoggerContext,
                                                           NULL,
                                                           EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_NIC,
                                                           sizeof(NIC_RECORD) + IpAddrLen);

        
        if(!pAdapterInfo) {
            Status = STATUS_NO_MEMORY;
            goto IpCleanup;
        }

        RtlCopyMemory(pAdapterInfo, 
                      &AdapterInfo, 
                      sizeof(NIC_RECORD) + IpAddrLen);

        //
        // Copy the IP Address and Subnet mask
        //
        if (pAdapterList->CurrentIpAddress) {
            pAdapterInfo->IpAddress = FIELD_OFFSET(NIC_RECORD, Data);
            RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->IpAddress), 
                          &(pAdapterList->CurrentIpAddress->IpAddress), 
                          sizeof(IP_ADDRESS_STRING));

            pAdapterInfo->SubnetMask = pAdapterInfo->IpAddress + sizeof(IP_ADDRESS_STRING);
            RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->SubnetMask), 
                          &(pAdapterList->CurrentIpAddress->IpMask), 
                          sizeof(IP_ADDRESS_STRING));
        }
        else {
            pAdapterInfo->IpAddress = FIELD_OFFSET(NIC_RECORD, Data);
            RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->IpAddress), 
                          &(pAdapterList->IpAddressList.IpAddress), 
                          sizeof(IP_ADDRESS_STRING));

            pAdapterInfo->SubnetMask = pAdapterInfo->IpAddress + sizeof(IP_ADDRESS_STRING);
            RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->SubnetMask), 
                          &(pAdapterList->IpAddressList.IpMask), 
                          sizeof(IP_ADDRESS_STRING));
        }

        //
        // Copy the Dhcp Server IP Address
        //
        pAdapterInfo->DhcpServer = pAdapterInfo->SubnetMask + sizeof(IP_ADDRESS_STRING);
        RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->DhcpServer), 
                      &(pAdapterList->DhcpServer.IpAddress), 
                      sizeof(IP_ADDRESS_STRING));

        //
        // Copy the Gateway IP Address
        //
        pAdapterInfo->Gateway = pAdapterInfo->DhcpServer + sizeof(IP_ADDRESS_STRING);
        RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->Gateway), 
                      &(pAdapterList->GatewayList.IpAddress), 
                      sizeof(IP_ADDRESS_STRING));

        //
        // Copy the Primary Wins Server IP Address
        //
        pAdapterInfo->PrimaryWinsServer = pAdapterInfo->Gateway + sizeof(IP_ADDRESS_STRING);
        RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->PrimaryWinsServer), 
                      &(pAdapterList->PrimaryWinsServer.IpAddress), 
                      sizeof(IP_ADDRESS_STRING));

        //
        // Copy the Secondary Wins Server IP Address
        //
        pAdapterInfo->SecondaryWinsServer = pAdapterInfo->PrimaryWinsServer + sizeof(IP_ADDRESS_STRING);
        RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->SecondaryWinsServer),
                      &(pAdapterList->SecondaryWinsServer.IpAddress), 
                      sizeof(IP_ADDRESS_STRING));
        
        //
        // Hardcoded entries for DNS server(limited upto 4);
        //
        pIpAddressList = &pPerAdapterInfo->DnsServerList;
        pAdapterInfo->DnsServer[0] = pAdapterInfo->SecondaryWinsServer + sizeof(IP_ADDRESS_STRING);
        for (i = 0; pIpAddressList && i < CONFIG_MAX_DNS_SERVER; i++) {

            RtlCopyMemory((PVOID)((ULONG_PTR)pAdapterInfo + pAdapterInfo->DnsServer[i]), 
                          &(pIpAddressList->IpAddress), 
                          sizeof(IP_ADDRESS_STRING));
            
            if(i < CONFIG_MAX_DNS_SERVER - 1) {
                pAdapterInfo->DnsServer[i + 1] = pAdapterInfo->DnsServer[i] + sizeof(IP_ADDRESS_STRING);
            }

            pIpAddressList = pIpAddressList->Next;
        }

        //
        // Free the DNS server list
        //
        RtlFreeHeap (RtlProcessHeap(),0,pPerAdapterInfo);

        //
        // increment the AdapterInfo buffer position for next record
        //
        pAdapterList = pAdapterList->Next;
    }

IpCleanup:
    if (pAdapterListHead) {
        RtlFreeHeap (RtlProcessHeap(),0,pAdapterListHead);
    }

    return Status;
}


NTSTATUS 
WmipGetServiceInfo(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    DWORD dwServicesNum = 0;
    SC_HANDLE hScm = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PSYSTEM_PROCESS_INFORMATION pProcInfo = NULL;
    PSYSTEM_PROCESS_INFORMATION ppProcInfo = NULL;
    PUCHAR pBuffer = NULL;
    ULONG ulBufferSize = 64*1024;
    ULONG TotalOffset;
    ULONG TotalTasks = 0;
    ULONG j;

    //
    // Get the process Info
    //
retry:

    if(pBuffer == NULL) {
        pBuffer = RtlAllocateHeap (RtlProcessHeap(),0,ulBufferSize);
    }
    if(pBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }
    Status = NtQuerySystemInformation(
                SystemProcessInformation,
                pBuffer,
                ulBufferSize,
                NULL
                );

    if (Status == STATUS_INFO_LENGTH_MISMATCH) {
        ulBufferSize += 8192;
        RtlFreeHeap (RtlProcessHeap(),0,pBuffer);
        pBuffer = NULL;
        goto retry;
    }
    
    pProcInfo = (PSYSTEM_PROCESS_INFORMATION) pBuffer;

    //
    // Connect to the service controller.
    //
    hScm = OpenSCManager(
                NULL,
                NULL,
                SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE
                );

    if (hScm) {
        LPENUM_SERVICE_STATUS_PROCESSW pInfo    = NULL;
        LPENUM_SERVICE_STATUS_PROCESSW ppInfo   = NULL;
        DWORD                         cbInfo   = 4 * 1024;
        DWORD                         dwErr    = ERROR_SUCCESS;
        DWORD                         dwResume = 0;
        DWORD                         cLoop    = 0;
        const DWORD                   cLoopMax = 2;
        WMI_SERVICE_INFO              ServiceInfo;
        PWMI_SERVICE_INFO             pServiceInfo = NULL;
        SERVICE_STATUS_PROCESS        ServiceProcess;
        PWCHAR p = NULL;
        DWORD dwRemainBytes;

        //
        // First pass through the loop allocates from an initial guess. (4K)
        // If that isn't sufficient, we make another pass and allocate
        // what is actually needed.  (We only go through the loop a
        // maximum of two times.)
        //
        do {
            if (pInfo) {
                RtlFreeHeap (RtlProcessHeap(),0,pInfo);
            }
            pInfo = (LPENUM_SERVICE_STATUS_PROCESSW)RtlAllocateHeap (RtlProcessHeap(),0,cbInfo);
            if (!pInfo) {
                dwErr = ERROR_OUTOFMEMORY;
                break;
            }

            dwErr = ERROR_SUCCESS;
            if (!EnumServicesStatusExW(
                    hScm,
                    SC_ENUM_PROCESS_INFO,
                    SERVICE_WIN32,
                    SERVICE_ACTIVE,
                    (PBYTE)pInfo,
                    cbInfo,
                    &dwRemainBytes,
                    &dwServicesNum,
                    &dwResume,
                    NULL)) 
            {
                dwErr = GetLastError();
                cbInfo += dwRemainBytes;
                dwResume = 0;
            }
        } while ((ERROR_MORE_DATA == dwErr) && (++cLoop < cLoopMax));

        if ((ERROR_SUCCESS == dwErr) && dwServicesNum) {
            //
            // Process each service and send an event
            //
            ppInfo = pInfo;
            Status = STATUS_SUCCESS;
            while(dwServicesNum) {

                RtlZeroMemory(&ServiceInfo, sizeof(WMI_SERVICE_INFO));

                wcscpy(ServiceInfo.ServiceName, ppInfo->lpServiceName);

                wcscpy(ServiceInfo.DisplayName, ppInfo->lpDisplayName);

                ServiceInfo.ProcessId = ppInfo->ServiceStatusProcess.dwProcessId;

                //
                // Get the process name
                //
                ppProcInfo = pProcInfo;
                TotalOffset = 0;
                while(TRUE) {
                    if((DWORD)(DWORD_PTR)ppProcInfo->UniqueProcessId == ServiceInfo.ProcessId) {
                        if(ppProcInfo->ImageName.Buffer) {
                            p = wcschr(ppProcInfo->ImageName.Buffer, L'\\');
                            if ( p ) {
                                p++;
                            } else {
                                p = ppProcInfo->ImageName.Buffer;
                            }
                        }
                        else {
                            p = L"System Process";
                        }
                        wcscpy(ServiceInfo.ProcessName, p);
                    }
                    if (ppProcInfo->NextEntryOffset == 0) {
                        break;
                    }
                    TotalOffset += ppProcInfo->NextEntryOffset;
                    ppProcInfo   = (PSYSTEM_PROCESS_INFORMATION)((PBYTE)pProcInfo+TotalOffset);
                }

                //
                // Package all information about this NIC and write an event record
                //
                pServiceInfo = NULL;
                pServiceInfo = (PWMI_SERVICE_INFO) WmipGetTraceBuffer( LoggerContext,
                                                           NULL,
                                                           EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_SERVICES,
                                                           sizeof(WMI_SERVICE_INFO));
                if(pServiceInfo == NULL) {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }

                RtlCopyMemory(pServiceInfo, &ServiceInfo, sizeof(WMI_SERVICE_INFO));

                dwServicesNum--;
                ppInfo++;
            }
        }

        if (pInfo) {
            RtlFreeHeap (RtlProcessHeap(),0,pInfo);
        }

        CloseServiceHandle(hScm);
    }

    if(pBuffer) {
        RtlFreeHeap (RtlProcessHeap(),0,pBuffer);
    }

    return Status;
}

NTSTATUS
WmipGetPowerInfo(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    NTSTATUS Status;
    SYSTEM_POWER_CAPABILITIES Cap;
    WMI_POWER_RECORD Power;
    PWMI_POWER_RECORD pPower = NULL;

    RtlZeroMemory(&Power, sizeof(WMI_POWER_RECORD));

    Status = NtPowerInformation (SystemPowerCapabilities,
                                 NULL,
                                 0,
                                 &Cap,
                                 sizeof (Cap));
    if(!NT_SUCCESS(Status)) {
        Status = STATUS_UNSUCCESSFUL;
        goto PowerCleanup;
    }

    Power.SystemS1 = Cap.SystemS1;
    Power.SystemS2 = Cap.SystemS2;
    Power.SystemS3 = Cap.SystemS3;
    Power.SystemS4 = Cap.SystemS4;
    Power.SystemS5 = Cap.SystemS5;

    //
    // Package all Power information and write an event record
    //
    pPower = (PWMI_POWER_RECORD) WmipGetTraceBuffer(LoggerContext,
                                                    NULL,
                                                    EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_POWER,
                                                    sizeof(WMI_POWER_RECORD));


    if(!pPower) {
        Status = STATUS_NO_MEMORY;
        goto PowerCleanup;
    }

    RtlCopyMemory(pPower,
                  &Power,
                  sizeof(WMI_POWER_RECORD));

PowerCleanup:
    return Status;
}

//
// This routine records the hardware configuration in the
// logfile during RunDown
//

ULONG
WmipDumpHardwareConfig(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    Status = WmipGetCpuConfig(LoggerContext);

    if (!NT_SUCCESS(Status) )
        return WmipSetDosError(WmipNtStatusToDosError(Status));

    Status = WmipGetVideoAdapters(LoggerContext);

    if (!NT_SUCCESS(Status) )
        return WmipSetDosError(WmipNtStatusToDosError(Status));

    Status = WmipGetDiskInfo(LoggerContext);

    if (!NT_SUCCESS(Status) )
        return WmipSetDosError(WmipNtStatusToDosError(Status));

    Status = WmipGetNetworkAdapters(LoggerContext);

    if (!NT_SUCCESS(Status) )
        return WmipSetDosError(WmipNtStatusToDosError(Status));

    Status = WmipGetServiceInfo(LoggerContext);

    if (!NT_SUCCESS(Status) )
        return WmipSetDosError(WmipNtStatusToDosError(Status));

    Status = WmipGetPowerInfo(LoggerContext);

    if (!NT_SUCCESS(Status) )
        return WmipSetDosError(WmipNtStatusToDosError(Status));

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\wmicore_client.c ===
#include "wmicore_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\tracelib.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tracelib.h

Abstract:

    Private headers for user-mode trace library

Author:

    15-Aug-2000 JeePang

Revision History:

--*/

#ifndef _TRACELIB_H_
#define _TRACELIB_H_

#define WmipNtStatusToDosError(Status) ((ULONG)((Status == STATUS_SUCCESS)?ERROR_SUCCESS:RtlNtStatusToDosError(Status)))

__inline Assign64(
    IN  LONGLONG       qwSrc,
    OUT PLARGE_INTEGER pqwDest
    )
{
    PLARGE_INTEGER pqwSrc = (PLARGE_INTEGER) &qwSrc;
    pqwDest->LowPart  = pqwSrc->LowPart;
    pqwDest->HighPart = pqwSrc->HighPart;
}

__inline Move64(
    IN  PLARGE_INTEGER pSrc,
    OUT PLARGE_INTEGER pDest
    )
{
    pDest->LowPart = pSrc->LowPart;
    pDest->HighPart = pSrc->HighPart;
}

#if defined(_IA64_)
#include <ia64reg.h>
#endif

//
// NTDLL cannot call GetSystemTimeAsFileTime
//
__inline __int64 WmipGetSystemTime()
{
    LARGE_INTEGER SystemTime;

    //
    // Read system time from shared region.
    //

    do {
        SystemTime.HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        SystemTime.LowPart = USER_SHARED_DATA->SystemTime.LowPart;
    } while (SystemTime.HighPart != USER_SHARED_DATA->SystemTime.High2Time);

    return SystemTime.QuadPart;
}

//
// GetCycleCounts
//
// Since we do not want to make a kernel mode  transition to get the
// thread CPU Times, we settle for just getting the CPU Cycle counts.
// We use the following macros from BradW to get the CPU cycle count.
// This method may be inaccurate if the clocks are not synchronized
// between processors.
//

#if defined(_X86_)
__inline
LONGLONG
WmipGetCycleCount(
    )
{
    __asm{
        RDTSC
    }
}
#elif defined(_AMD64_)
#define WmipGetCycleCount() ReadTimeStampCounter()
#elif defined(_IA64_)
#define WmipGetCycleCount() __getReg(CV_IA64_ApITC)
#else
#error "perf: a target architecture must be defined."
#endif

__inline 
ULONG
WmipSetDosError(
    IN ULONG DosError
    )
{
    if (DosError != ERROR_SUCCESS) {
        SetLastError(DosError);
    }
    return DosError;
}

PVOID
WmipMemReserve(
    IN SIZE_T Size
    );

PVOID
WmipMemCommit(
    IN PVOID Buffer,
    IN SIZE_T Size
    );

ULONG
WmipMemFree(
    IN PVOID Buffer
    );

HANDLE
WmipCreateFile(
    LPCWSTR     lpFileName,
    DWORD       dwDesiredAccess,
    DWORD       dwShareMode,
    DWORD       dwCreationDisposition,
    DWORD       dwCreateFlags
    );

NTSTATUS
WmipGetCpuSpeed(
    OUT DWORD* CpuNum,
    OUT DWORD* CpuSpeed
    );

BOOL
WmipSynchReadFile(
    HANDLE LogFile, 
    LPVOID Buffer, 
    DWORD NumberOfBytesToRead, 
    LPDWORD NumberOfBytesRead,
    LPOVERLAPPED Overlapped 
    );

#endif // _TRACELIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\umlog.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    umlog.c

Abstract:

    Process Private Logger.

Author:

    20-Oct-1998 Melur Raghuraman

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>          // for ntutrl.h
#include <nturtl.h>         // for RTL_CRITICAL_SECTION in winbase.h/wtypes.h
#include <wtypes.h>         // for LPGUID in wmium.h
#include "wmiump.h"
#include "evntrace.h"
#include "traceump.h"
#include "tracelib.h"

//
// The following structures must match what's in ntos\wmi\tracelog.c
//
#define DEFAULT_BUFFER_SIZE               4096
#define MAXSTR                            1024
#define BUFFER_STATE_UNUSED     0               // Buffer is empty, not used
#define BUFFER_STATE_DIRTY      1               // Buffer is being used
#define BUFFER_STATE_FULL       2               // Buffer is filled up
#define BUFFER_STATE_FLUSH      4               // Buffer ready for flush
#define SEMAPHORE_LIMIT      1024
#define DEFAULT_AGE_LIMIT      15
#define ERROR_RETRY_COUNT       10
#define ROUND_TO_PAGES(Size, Page)  (((ULONG)(Size) + Page-1) & ~(Page-1))
#define BYTES_PER_MB              1048576       // Conversion for FileSizeLimit

extern ULONG WmiTraceAlignment;

LONG  WmipLoggerCount = 0;                     // Use to refcount UM Log
ULONG WmipGlobalSequence = 0;
RTL_CRITICAL_SECTION UMLogCritSect;

#define WmipEnterUMCritSection() RtlEnterCriticalSection(&UMLogCritSect)
#define WmipLeaveUMCritSection() RtlLeaveCriticalSection(&UMLogCritSect)

#define WmipIsLoggerOn() \
        (WmipLoggerContext != NULL) && \
        (WmipLoggerContext != (PWMI_LOGGER_CONTEXT) &WmipLoggerContext)
//
// Increase refcount on a logger context
#define WmipLockLogger() \
            InterlockedIncrement(&WmipLoggerCount)

// Decrease refcount on a logger context
#define WmipUnlockLogger() InterlockedDecrement(&WmipLoggerCount)

PWMI_LOGGER_CONTEXT WmipLoggerContext = NULL; // Global pointer to LoggerContext
LARGE_INTEGER       OneSecond = {(ULONG)(-1 * 1000 * 1000 * 10), -1};

// #define WmipReleaseTraceBuffer(BufferResource) \
//         InterlockedDecrement(&((BufferResource)->ReferenceCount))
LONG
FASTCALL
WmipReleaseTraceBuffer(
    IN PWMI_BUFFER_HEADER BufferResource
    );

#pragma warning( disable: 4035 )    /* Don't complain about lack of ret value */
#pragma warning( disable: 4127 )
#pragma warning( default: 4035 )
#pragma warning( default: 4127 )

#if DBG
#define TraceDebug(x)    DbgPrint x
#else
#define TraceDebug(x)
#endif

ULONG
WmipReceiveReply(
    HANDLE ReplyHandle,
    ULONG ReplyCount,
    ULONG ReplyIndex,
    PVOID OutBuffer,
    ULONG OutBufferSize
    );


VOID
WmipLogger(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

ULONG
WmipStopUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
WmipQueryUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
WmipUpdateUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG 
WmipFlushUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

PWMI_LOGGER_CONTEXT
WmipInitLoggerContext(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
WmipAllocateTraceBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

ULONG
WmipFlushBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER Buffer
    );

ULONG
WmipFlushAllBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext);

PWMI_BUFFER_HEADER
FASTCALL
WmipSwitchBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER OldBuffer,
    IN ULONG Processor
    );

ULONG
WmipFreeLoggerContext(
    PWMI_LOGGER_CONTEXT LoggerContext
    );

BOOLEAN
FASTCALL
WmipIsPrivateLoggerOn()
{
    if (!WmipIsLoggerOn())
        return FALSE;
    return (WmipLoggerContext->CollectionOn == TRUE);
}

ULONG
WmipSendUmLogRequest(
    IN WMITRACECODE RequestCode,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This routine send a UserMode Logger Request (Start/Stop/Query).

Arguments:

    RequestCode - Request Code
    LoggerInfo  - Logger Information necessary for the request


Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    ULONG Status;
    ULONG SizeNeeded;
    PWMICREATEUMLOGGER   UmRequest;
    ULONG RetSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING GuidString;
    WCHAR GuidObjectName[WmiGuidObjectNameLength+1];
    PUCHAR Buffer;
    PWNODE_HEADER Wnode;

    SizeNeeded = sizeof(WMICREATEUMLOGGER) + ((PWNODE_HEADER)LoggerInfo)->BufferSize;

    SizeNeeded = (SizeNeeded +7) & ~7;

    Buffer = WmipAlloc(SizeNeeded);
    if (Buffer == NULL) {
        return ERROR_OUTOFMEMORY;
    }

    UmRequest = (PWMICREATEUMLOGGER) Buffer;

    UmRequest->ObjectAttributes = &ObjectAttributes;
    UmRequest->ControlGuid = LoggerInfo->Wnode.Guid;

    Status = WmipBuildGuidObjectAttributes(&UmRequest->ControlGuid,
                                        &ObjectAttributes,
                                        &GuidString,
                                        GuidObjectName);

    if (Status == ERROR_SUCCESS) {
        Wnode = (PWNODE_HEADER)((PUCHAR)Buffer + sizeof(WMICREATEUMLOGGER));
        memcpy(Wnode, LoggerInfo, LoggerInfo->Wnode.BufferSize);

        Wnode->ProviderId = RequestCode;   // This Wnode is part of the Message.

        Status = WmipSendWmiKMRequest(NULL,
                                  IOCTL_WMI_CREATE_UM_LOGGER,
                                  Buffer,
                                  SizeNeeded,
                                  Buffer,
                                  SizeNeeded,
                                  &RetSize,
                                  NULL);

        if (Status == ERROR_SUCCESS) {

            Status = WmipReceiveReply(UmRequest->ReplyHandle.Handle,
                                      UmRequest->ReplyCount,
                                      Wnode->Version,
                                      LoggerInfo,
                                      LoggerInfo->Wnode.BufferSize);

            NtClose(UmRequest->ReplyHandle.Handle);

        }
    }

    WmipFree(Buffer);

    return Status;
}

void
WmipAddInstanceIdToNames(
    PWMI_LOGGER_INFORMATION LoggerInfo,
    PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    ULONG Offset;

    Offset = sizeof(WMI_LOGGER_INFORMATION);
    LoggerInfo->LoggerName.Buffer = (PVOID)((char*)LoggerInfo + Offset);


    Offset += LoggerInfo->LoggerName.MaximumLength;
    LoggerInfo->LogFileName.Buffer = (PVOID)((char*)LoggerInfo + Offset);
    WmipInitString(&LoggerContext->LoggerName, NULL, 0);

    RtlCreateUnicodeString(&LoggerContext->LoggerName,
                         LoggerInfo->LoggerName.Buffer);

    WmipInitString(&LoggerContext->LogFileName, NULL, 0);

    if (LoggerInfo->InstanceCount == 1) {
        RtlCreateUnicodeString(&LoggerContext->LogFileName,
                              LoggerInfo->LogFileName.Buffer);

    }
    else {
        WCHAR TempStr[MAXSTR];

        LoggerInfo->InstanceId = GetCurrentProcessId();

        if (LoggerInfo->LogFileName.MaximumLength <= MAXSTR) {
            swprintf(TempStr, L"%s_%d",
                     LoggerInfo->LogFileName.Buffer,
                     LoggerInfo->InstanceId);
        }
        else {
            RtlCopyMemory((PVOID)TempStr,
                           LoggerInfo->LogFileName.Buffer,
                           MAXSTR);
            TempStr[MAXSTR/2] = '\0';
        }

        RtlCreateUnicodeString (&LoggerContext->LogFileName, TempStr);
    }

    LoggerInfo->LoggerName = LoggerContext->LoggerName;
    LoggerInfo->LogFileName = LoggerContext->LogFileName;
}

ULONG
WmipQueryUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    ULONG Offset;
    PWMI_LOGGER_CONTEXT LoggerContext;
#if DBG
    LONG RefCount;

    RefCount =
#endif
    WmipLockLogger();

    TraceDebug(("QueryUm: %d->%d\n", RefCount-1, RefCount));

    if (!WmipIsLoggerOn()) {
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("QueryUm: %d->%d OBJECT_NOT_FOUND\n", RefCount+1,RefCount));
        return ERROR_OBJECT_NOT_FOUND;
    }

    LoggerContext = WmipLoggerContext;

    *SizeUsed = 0;
    *SizeNeeded = sizeof(WMI_LOGGER_INFORMATION);
    if (WnodeSize < *SizeNeeded) {
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("QueryUm: %d->%d ERROR_MORE_DATA\n", RefCount+1, RefCount));
        return ERROR_MORE_DATA;
    }

    LoggerInfo->Wnode.Guid      = LoggerContext->InstanceGuid;
    LoggerInfo->LogFileMode     = LoggerContext->LogFileMode;
    LoggerInfo->MaximumFileSize = LoggerContext->MaximumFileSize;
    LoggerInfo->FlushTimer      = (ULONG)(LoggerContext->FlushTimer.QuadPart
                                           / OneSecond.QuadPart);
    LoggerInfo->BufferSize      = LoggerContext->BufferSize / 1024;
    LoggerInfo->NumberOfBuffers = LoggerContext->NumberOfBuffers;
    LoggerInfo->MinimumBuffers  = LoggerContext->MinimumBuffers;
    LoggerInfo->MaximumBuffers  = LoggerContext->MaximumBuffers;
    LoggerInfo->EventsLost      = LoggerContext->EventsLost;
    LoggerInfo->FreeBuffers     = LoggerContext->BuffersAvailable;
    LoggerInfo->BuffersWritten  = LoggerContext->BuffersWritten;
    LoggerInfo->LogBuffersLost  = LoggerContext->LogBuffersLost;
    LoggerInfo->RealTimeBuffersLost = LoggerContext->RealTimeBuffersLost;
    LoggerInfo->AgeLimit        = (ULONG)(LoggerContext->BufferAgeLimit.QuadPart
                                        / OneSecond.QuadPart / 60);
    LoggerInfo->LoggerThreadId = LoggerContext->LoggerThreadId;
    LoggerInfo->Wnode.ClientContext = LoggerContext->UsePerfClock;
    WmiSetLoggerId(1,
            (PTRACE_ENABLE_CONTEXT) &LoggerInfo->Wnode.HistoricalContext);

    // Copy LogFileName and LoggerNames into Buffer, if space is available
    //
    Offset = sizeof(WMI_LOGGER_INFORMATION);
    if ((Offset + LoggerContext->LoggerName.MaximumLength) < WnodeSize) {
        LoggerInfo->LoggerName.Buffer = (PVOID)((char*)LoggerInfo + Offset);
        if (LoggerInfo->LoggerName.MaximumLength == 0) {
            LoggerInfo->LoggerName.MaximumLength =
                    LoggerContext->LoggerName.MaximumLength;
        }
        else {
            LoggerInfo->LoggerName.MaximumLength =
                            __min(LoggerInfo->LoggerName.MaximumLength,
                                  LoggerContext->LoggerName.MaximumLength);
        }
        RtlCopyUnicodeString(&LoggerInfo->LoggerName,
                                 &LoggerContext->LoggerName);

        *SizeNeeded += LoggerContext->LoggerName.MaximumLength;
    }


    Offset += LoggerContext->LoggerName.MaximumLength;
    if ((Offset + LoggerContext->LogFileName.MaximumLength) < WnodeSize) {
        LoggerInfo->LogFileName.Buffer = (PVOID)((char*)LoggerInfo
                                                  + Offset);
        if (LoggerInfo->LogFileName.MaximumLength == 0) {
            LoggerInfo->LogFileName.MaximumLength =
                    LoggerContext->LogFileName.MaximumLength;
        }
        else {

            LoggerInfo->LogFileName.MaximumLength =
                            __min(LoggerInfo->LogFileName.MaximumLength,
                                  LoggerContext->LogFileName.MaximumLength);
        }
        RtlCopyUnicodeString(&LoggerInfo->LogFileName,
                              &LoggerContext->LogFileName);
        *SizeNeeded += LoggerContext->LogFileName.MaximumLength;
    }
    *SizeUsed = *SizeNeeded;
#if DBG
        RefCount =
#endif
    WmipUnlockLogger();
    TraceDebug(("QueryUm: %d->%d ERROR_SUCCESS\n", RefCount+1, RefCount));
    return ERROR_SUCCESS;
}

ULONG
WmipUpdateUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    ULONG Status = ERROR_SUCCESS;
    PWMI_LOGGER_CONTEXT LoggerContext;

    //
    // Check for parameters first
    //
    *SizeUsed = 0;
    *SizeNeeded = sizeof(WMI_LOGGER_INFORMATION);
    if (WnodeSize < * SizeNeeded) {
        return ERROR_MORE_DATA;
    }

    if (LoggerInfo->BufferSize != 0 || LoggerInfo->MinimumBuffers != 0
                                    || LoggerInfo->MaximumBuffers != 0
                                    || LoggerInfo->MaximumFileSize != 0
                                    || LoggerInfo->EnableFlags != 0
                                    || LoggerInfo->AgeLimit != 0) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Lock logger down if it is running
    //
    WmipLockLogger();
    if (!WmipIsLoggerOn()) {
        WmipUnlockLogger();
        return ERROR_OBJECT_NOT_FOUND;
    }

    LoggerContext = WmipLoggerContext;

    if (((LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) &&
         (LoggerContext->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL))
        || ((LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL)
            && (LoggerContext->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR))
        || (LoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
        WmipUnlockLogger();
        return (ERROR_INVALID_PARAMETER);
    }

    LoggerInfo->LoggerName.Buffer = (PWCHAR)
            (((PCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION));
    LoggerInfo->LogFileName.Buffer = (PWCHAR)
            (((PCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION)
                                  + LoggerInfo->LoggerName.MaximumLength);

    if (LoggerInfo->FlushTimer > 0) {
        LoggerContext->FlushTimer.QuadPart = LoggerInfo->FlushTimer
                                               * OneSecond.QuadPart;
    }

    if (LoggerInfo->LogFileName.Length > 0) {
        if (LoggerContext->LogFileHandle != NULL) {
            PWMI_LOGGER_INFORMATION WmipLoggerInfo = NULL;
            ULONG                   lSizeUsed;
            ULONG                   lSizeNeeded = 0;

            lSizeUsed = sizeof(WMI_LOGGER_INFORMATION)
                      + 2 * MAXSTR * sizeof(WCHAR);
            WmipLoggerInfo = (PWMI_LOGGER_INFORMATION) WmipAlloc(lSizeUsed);
            if (WmipLoggerInfo == NULL) {
                Status = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }
            RtlZeroMemory(WmipLoggerInfo, lSizeUsed);
            WmipLoggerInfo->Wnode.BufferSize  = lSizeUsed;
            WmipLoggerInfo->Wnode.Flags      |= WNODE_FLAG_TRACED_GUID;
            Status = WmipQueryUmLogger(
                            WmipLoggerInfo->Wnode.BufferSize,
                            & lSizeUsed,
                            & lSizeNeeded,
                            WmipLoggerInfo);
            if (Status != ERROR_SUCCESS) {
                WmipFree(WmipLoggerInfo);
                goto Cleanup;
            }
            NtClose(LoggerContext->LogFileHandle);
            Status = WmipFinalizeLogFileHeader(WmipLoggerInfo);
            if (Status != ERROR_SUCCESS) {
                WmipFree(WmipLoggerInfo);
                goto Cleanup;
            }
            WmipFree(WmipLoggerInfo);
        }

        LoggerInfo->BufferSize      = LoggerContext->BufferSize / 1024;
        LoggerInfo->MaximumFileSize = LoggerContext->MaximumFileSize;
        LoggerInfo->LogFileMode     = LoggerContext->LogFileMode;

        if (LoggerContext->LogFileName.Buffer != NULL) {
            RtlFreeUnicodeString(& LoggerContext->LogFileName);
        }
        WmipAddInstanceIdToNames(LoggerInfo, LoggerContext);
        Status = WmipAddLogHeaderToLogFile(LoggerInfo, NULL, TRUE);
        if (Status != ERROR_SUCCESS) {
            goto Cleanup;
        }
        LoggerContext->LogFileHandle = LoggerInfo->LogFileHandle;

        RtlCreateUnicodeString(&LoggerContext->LogFileName,
                               LoggerInfo->LogFileName.Buffer);
    }

Cleanup:
    if (Status == ERROR_SUCCESS) {
        Status = WmipQueryUmLogger(WnodeSize, SizeUsed, SizeNeeded, LoggerInfo);
    }
    WmipUnlockLogger();
    return (Status);
}

ULONG 
WmipFlushUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This routine flushes active buffers. Effectively this is accomplished by
    putting all the buffers in the FlushList. If there is no available buffer
    for switching ERROR_OUTOFMEMORY is returned.

Arguments:

    WnodeSize   - Size of Wnode 
    SizeUsed    - Used only to pass to QueryLogger()
    SizeNeeded  - Used only for LoggerInfo size checking.
    LoggerInfo  - Logger Information. It will be updated.


Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    ULONG Status = ERROR_SUCCESS;
    PWMI_LOGGER_CONTEXT LoggerContext;
    PWMI_BUFFER_HEADER Buffer, OldBuffer;
    ULONG Offset, i;

#if DBG
    LONG RefCount;

    RefCount =
#endif
    WmipLockLogger();

    TraceDebug(("FlushUm: %d->%d\n", RefCount-1, RefCount));

    if (!WmipIsLoggerOn()) {
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("FlushUm: %d->%d OBJECT_NOT_FOUND\n", RefCount+1,RefCount));
        return ERROR_OBJECT_NOT_FOUND;
    }

    LoggerContext = WmipLoggerContext;

    *SizeUsed = 0;
    *SizeNeeded = sizeof(WMI_LOGGER_INFORMATION);
    if (WnodeSize < *SizeNeeded) {
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("FlushUm: %d->%d ERROR_MORE_DATA\n", RefCount+1, RefCount));
        return ERROR_MORE_DATA;
    }
    //
    // Go through each buffer, mark it "FULL", and put it in the FlushList.
    //
    WmipEnterUMCritSection();
    for (i = 0; i < (ULONG)LoggerContext->NumberOfProcessors; i++) {
        Buffer = (PWMI_BUFFER_HEADER)LoggerContext->ProcessorBuffers[i];
        if (Buffer == NULL)
            continue;

        if (Buffer->CurrentOffset == sizeof(WMI_BUFFER_HEADER)) {
            Buffer->Flags = BUFFER_STATE_UNUSED;
            continue;
        }
        if (Buffer->Flags == BUFFER_STATE_UNUSED) {
            continue;
        }
        else {
            Buffer->Flags = BUFFER_STATE_FULL;
        }
        // Increment the refcount so that the buffer doesn't go away
        InterlockedIncrement(&Buffer->ReferenceCount);
        Offset = Buffer->CurrentOffset; 
        if (Offset <LoggerContext->BufferSize) {
            Buffer->SavedOffset = Offset;       // save this for FlushBuffer
        }
        // We need a free buffer for switching. If no buffer is available, exit. 
        if ((LoggerContext->NumberOfBuffers == LoggerContext->MaximumBuffers)
             && (LoggerContext->BuffersAvailable == 0)) {
            InterlockedDecrement(&Buffer->ReferenceCount);
            Status = ERROR_OUTOFMEMORY;
            TraceDebug(("FlushUm: %d->%d ERROR_OUTOFMEMORY\n", RefCount+1, RefCount));
            break;
        }
        OldBuffer = Buffer;
        Buffer = WmipSwitchBuffer(LoggerContext, OldBuffer, i);
        if (Buffer == NULL) {
            // Switching failed. Exit. 
            Buffer = OldBuffer;
            InterlockedDecrement(&Buffer->ReferenceCount);
            Status = ERROR_OUTOFMEMORY;
            TraceDebug(("FlushUm: %d->%d ERROR_OUTOFMEMORY\n", RefCount+1, RefCount));
            break;
        }
        // Decrement the refcount back.
        InterlockedDecrement(&OldBuffer->ReferenceCount);
        Buffer->ClientContext.ProcessorNumber = (UCHAR)i;
        // Now wake up the logger thread.
        NtReleaseSemaphore(LoggerContext->Semaphore, 1, NULL);
    }
    WmipLeaveUMCritSection();

    if (Status == ERROR_SUCCESS) {
        Status = WmipQueryUmLogger(WnodeSize, SizeUsed, SizeNeeded, LoggerInfo);
    }
    WmipUnlockLogger();
    return (Status);
}

ULONG
WmipStartUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    NTSTATUS Status;
    ULONG ErrorCode;
    LARGE_INTEGER TimeOut = {(ULONG)(-2000 * 1000 * 10), -1};  // 2 secs
    UNICODE_STRING SavedLoggerName;
    UNICODE_STRING SavedLogFileName;
    PTRACE_ENABLE_CONTEXT pContext;

    PWNODE_HEADER Wnode = (PWNODE_HEADER)&LoggerInfo->Wnode;
    PVOID RequestAddress;
    PVOID RequestContext;
    ULONG RequestCookie;
    ULONG BufferSize;
    PWMI_LOGGER_CONTEXT LoggerContext;
#if DBG
    LONG RefCount;
#endif
    if (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        return ERROR_INVALID_PARAMETER;

    if ( (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) &&
         (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( (LoggerInfo->LogFileMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) &&
         (LoggerInfo->LogFileMode & EVENT_TRACE_USE_LOCAL_SEQUENCE) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if (WmipLoggerContext != NULL) {
        return ERROR_WMI_ALREADY_ENABLED;
    }

#if DBG
    RefCount =
#endif
    WmipLockLogger();
    TraceDebug(("StartUm: %d->%d\n", RefCount-1, RefCount));

    if (InterlockedCompareExchangePointer(&WmipLoggerContext,
                                          &WmipLoggerContext,
                                          NULL
                                         )  != NULL) {
#if DBG
    RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("StartUm: %d->%d ALREADY_ENABLED\n", RefCount+1, RefCount));
        return ERROR_WMI_ALREADY_ENABLED;
    }

    LoggerContext = WmipInitLoggerContext(LoggerInfo);
    if (LoggerContext == NULL) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // The LogFileName and LoggerNames are passed in as offset to the
    // LOGGER_INFORMATION structure. Reassign the Pointers for UNICODE_STRING
    //

    SavedLoggerName = LoggerInfo->LoggerName;
    SavedLogFileName = LoggerInfo->LogFileName;

    //
    // Since there may multiple processes registering for the same control guid
    // we want to make sure a start logger call from all of them do not
    // collide on the same file. So we tag on a InstanceId to the file name.
    //

    if (LoggerInfo->LogFileMode & EVENT_TRACE_RELOG_MODE) {
        PSYSTEM_TRACE_HEADER RelogProp;

        RelogProp = (PSYSTEM_TRACE_HEADER) ((PUCHAR)LoggerInfo +
                                         sizeof(WMI_LOGGER_INFORMATION) +
                                         LoggerInfo->LoggerName.MaximumLength +
                                         LoggerInfo->LogFileName.MaximumLength);

        WmipAddInstanceIdToNames(LoggerInfo, LoggerContext);
        ErrorCode = WmipRelogHeaderToLogFile( LoggerInfo, RelogProp );
    }
    else {
        WmipAddInstanceIdToNames(LoggerInfo, LoggerContext);
        ErrorCode = WmipAddLogHeaderToLogFile(LoggerInfo, NULL, FALSE);
    }
    if (ErrorCode != ERROR_SUCCESS) {
        goto Cleanup;
    }
    else
    {
        ULONG Min_Buffers, Max_Buffers;
        ULONG NumberProcessors;

        NumberProcessors = LoggerInfo->NumberOfProcessors;
        LoggerContext->NumberOfProcessors = NumberProcessors;

        // EventsLost is UNIONed to NumberOfProcessors in WMI_LOGGER_INFORMATION
        // in UM case. Need to reset EventsLost back to 0
        //
        LoggerInfo->EventsLost = 0;

        Min_Buffers            = NumberProcessors + 2;
        Max_Buffers            = 1024;

        if (LoggerInfo->MaximumBuffers >= Min_Buffers ) {
            LoggerContext->MaximumBuffers = LoggerInfo->MaximumBuffers;
        }
        else {
            LoggerContext->MaximumBuffers = Min_Buffers + 22;
        }

        if (LoggerInfo->MinimumBuffers >= Min_Buffers &&
            LoggerInfo->MinimumBuffers <= LoggerContext->MaximumBuffers) {
            LoggerContext->MinimumBuffers = LoggerInfo->MinimumBuffers;
        }
        else {
            LoggerContext->MinimumBuffers = Min_Buffers;
        }

        if (LoggerContext->MaximumBuffers > Max_Buffers)
            LoggerContext->MaximumBuffers = Max_Buffers;
        if (LoggerContext->MinimumBuffers > Max_Buffers)
            LoggerContext->MinimumBuffers = Max_Buffers;
        LoggerContext->NumberOfBuffers  = LoggerContext->MinimumBuffers;
    }

    LoggerContext->LogFileHandle       = LoggerInfo->LogFileHandle;
    LoggerContext->BufferSize          = LoggerInfo->BufferSize * 1024;
    LoggerContext->BuffersWritten      = LoggerInfo->BuffersWritten;
    LoggerContext->ByteOffset.QuadPart = LoggerInfo->BuffersWritten
                                           * LoggerInfo->BufferSize * 1024;
    // For a kernel logger, FirstBufferOffset is set in the kernel.
    // For a private logger, we need to do it here.
    LoggerContext->FirstBufferOffset.QuadPart = 
                                            LoggerContext->ByteOffset.QuadPart;
    LoggerContext->InstanceGuid        = LoggerInfo->Wnode.Guid;
    LoggerContext->MaximumFileSize     = LoggerInfo->MaximumFileSize;

    LoggerContext->UsePerfClock = LoggerInfo->Wnode.ClientContext;

    ErrorCode = WmipAllocateTraceBuffers(LoggerContext);
    if (ErrorCode != ERROR_SUCCESS) {
        goto Cleanup;
    }

    LoggerInfo->NumberOfBuffers = LoggerContext->NumberOfBuffers;
    LoggerInfo->MaximumBuffers  = LoggerContext->MaximumBuffers;
    LoggerInfo->MinimumBuffers  = LoggerContext->MinimumBuffers;
    LoggerInfo->FreeBuffers     = LoggerContext->BuffersAvailable;

    pContext = (PTRACE_ENABLE_CONTEXT)&LoggerInfo->Wnode.HistoricalContext;

    pContext->InternalFlag |= EVENT_TRACE_INTERNAL_FLAG_PRIVATE;
    pContext->LoggerId = 1;
    if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) {
        WmipGlobalSequence = 0;
        LoggerContext->SequencePtr = &WmipGlobalSequence;
    }
    else if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_LOCAL_SEQUENCE)
        LoggerContext->SequencePtr = &LoggerContext->LocalSequence;

    //
    // Initialize Events,  Semaphores and Crit Sections
    //

    Status = NtCreateEvent(
                &LoggerContext->LoggerEvent,
                EVENT_ALL_ACCESS,
                NULL,
                SynchronizationEvent,
                FALSE);
    if (!NT_SUCCESS(Status)) {
        ErrorCode = ERROR_OBJECT_NOT_FOUND;
        goto Cleanup;
    }

// TODO:
// This requires a private routine to create initial stack and
// call NtCreateThread
//
    LoggerContext->hThread = CreateThread(NULL,
                                 0,
                                 (LPTHREAD_START_ROUTINE) &WmipLogger,
                                 (LPVOID)LoggerContext,
                                 0,
                                 (LPDWORD)&LoggerContext->LoggerThreadId);


    if ( (LoggerContext->hThread == NULL) || (LoggerContext->LoggerThreadId == 0) ) {
        ErrorCode = GetLastError();
        goto Cleanup;
    }
    else {

    //
    // Elevate the priority of the Logging thread to highest
    //
        SetThreadPriority(LoggerContext->hThread, THREAD_PRIORITY_HIGHEST);
    }

    Status = STATUS_TIMEOUT;
    while (Status == STATUS_TIMEOUT) {
        Status = NtWaitForSingleObject(
                    LoggerContext->LoggerEvent, FALSE, &TimeOut);
#if DBG
        WmipAssert(Status != STATUS_TIMEOUT);
#endif
    }

    NtClearEvent(LoggerContext->LoggerEvent);
    WmipLoggerContext = LoggerContext;

    //
    // Look to see if this Provider is currently enabled.
    //

    RequestCookie = Wnode->ClientContext;

    if ( (RequestCookie != 0)  &&
         (WmipLookupCookie(RequestCookie,
                             &Wnode->Guid,
                             &RequestAddress,
                             &RequestContext)) ) {

            WmipDebugPrint(("WMI: LookUpCookie %d  RequestAddress %X\n",
                             RequestCookie, RequestAddress));

    }
    else {
        WmipDebugPrint(("WMI: LOOKUP COOKIE FAILED\n"));
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("StartUm: %d->%d DP_FAILED\n", RefCount+1, RefCount));
        return(ERROR_WMI_DP_FAILED);
    }
    try
    {
        PGUIDMAPENTRY pControlGMEntry = RequestAddress;
        PTRACE_REG_INFO pTraceRegInfo = NULL;
        WMIDPREQUEST WmiDPRequest = NULL;

        BufferSize = Wnode->BufferSize;

        if (RequestAddress != NULL)
            pTraceRegInfo  = pControlGMEntry->pControlGuidData;
        if (pTraceRegInfo != NULL) {
            RequestAddress = pTraceRegInfo->NotifyRoutine;
            if (pTraceRegInfo->EnabledState)
                WmiDPRequest = (WMIDPREQUEST)RequestAddress;
        }

        if (*WmiDPRequest != NULL) {
            ErrorCode = (*WmiDPRequest)(WMI_ENABLE_EVENTS,
                                 RequestContext,
                                 &BufferSize,
                                 Wnode);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
#if DBG
        ErrorCode = GetExceptionCode();
        WmipDebugPrint(("WMI: Service request call caused an exception %d\n",
                        Status));
#endif
        ErrorCode = ERROR_WMI_DP_FAILED;
    }

Cleanup:
    LoggerInfo->LogFileName = SavedLogFileName;
    LoggerInfo->LoggerName = SavedLoggerName;

    if (ErrorCode != ERROR_SUCCESS) {
        if (LoggerInfo->LogFileHandle) {
            NtClose(LoggerInfo->LogFileHandle);
            LoggerInfo->LogFileHandle = NULL;
            if (LoggerContext != NULL) {
                LoggerContext->LogFileHandle = NULL;
            }
        }
#if DBG
        RefCount =
#endif
        WmipLockLogger();
        TraceDebug(("StartUm: %d->%d %d Freeing\n", RefCount-1, RefCount));
        WmipFreeLoggerContext(LoggerContext);
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("StartUm: %d->%d %d\n", RefCount+1, RefCount, ErrorCode));
    }
    else {
        *SizeUsed = LoggerInfo->Wnode.BufferSize;
        *SizeNeeded = LoggerInfo->Wnode.BufferSize;
        // Logger remains locked with refcount = 1
    }
    return ErrorCode;
}

ULONG
WmipStopLoggerInstance(
    VOID
    )
{
    ULONG LoggerOn;
    NTSTATUS Status;
    LARGE_INTEGER TimeOut = {(ULONG)(-1000 * 1000 * 10), -1}; // 1sec
    PWMI_LOGGER_CONTEXT LoggerContext = WmipLoggerContext;

    if (LoggerContext == NULL) {
        return  ERROR_OBJECT_NOT_FOUND;
    }

    LoggerOn = InterlockedExchange(&LoggerContext->CollectionOn, FALSE);
    if (LoggerOn == FALSE) {
        return ERROR_OBJECT_NOT_FOUND;
    }
    NtReleaseSemaphore(LoggerContext->Semaphore, 1, NULL);

    Status = STATUS_TIMEOUT;
    while (Status == STATUS_TIMEOUT) {
        Status = NtWaitForSingleObject(
                    LoggerContext->LoggerEvent, FALSE, &TimeOut);
#if DBG
        WmipAssert(Status != STATUS_TIMEOUT);
#endif
    }

    NtClearEvent(LoggerContext->LoggerEvent);

    return ERROR_SUCCESS;
}

ULONG
WmipDisableTraceProvider(
    PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    WMIDPREQUEST WmiDPRequest;
    PVOID RequestAddress;
    PVOID RequestContext;
    WNODE_HEADER Wnode;
    ULONG Cookie;
    ULONG BufferSize;
    ULONG Status = ERROR_SUCCESS;

    BufferSize = sizeof(WNODE_HEADER);
    RtlCopyMemory(&Wnode, &LoggerInfo->Wnode, BufferSize);

    Wnode.BufferSize = BufferSize;

    Wnode.ProviderId =  WMI_DISABLE_EVENTS;

    Cookie = Wnode.CountLost;

    if (WmipLookupCookie(Cookie,
                 &Wnode.Guid,
                 &RequestAddress,
                 &RequestContext)) {
        WmiDPRequest = (WMIDPREQUEST)RequestAddress;
        try
        {
            WmipGenericTraceEnable(Wnode.ProviderId, &Wnode, (PVOID*)&WmiDPRequest);

            if (*WmiDPRequest != NULL) {
                Status = (*WmiDPRequest)(Wnode.ProviderId,
                                     RequestContext,
                                     &BufferSize,
                                     &Wnode);
            }
            else
                Status = ERROR_WMI_DP_NOT_FOUND;
        } except (EXCEPTION_EXECUTE_HANDLER) {
#if DBG
            Status = GetExceptionCode();
            WmipDebugPrint(("WMI: Service request call caused an exception %d\n",
                            Status));
#endif
            Status = ERROR_WMI_DP_FAILED;
        }
    }

    return Status;
}


ULONG
WmipStopUmLogger(
        IN ULONG WnodeSize,
        IN OUT ULONG *SizeUsed,
        OUT ULONG *SizeNeeded,
        IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    ULONG Status = ERROR_SUCCESS;
#if DBG
    LONG RefCount;

    RefCount =
#endif
    WmipLockLogger();
    TraceDebug(("StopUm: %d->%d\n", RefCount-1, RefCount));
    if (!WmipIsLoggerOn()) {
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("StopUm: %d->%d INSTANCE_NOT_FOUND\n",RefCount+1,RefCount));
        return (ERROR_WMI_INSTANCE_NOT_FOUND);
    }
    Status = WmipStopLoggerInstance();

    if (Status == ERROR_SUCCESS) {
        Status = WmipQueryUmLogger(WnodeSize, SizeUsed, SizeNeeded, LoggerInfo);
    }
    if (Status != ERROR_SUCCESS) {
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("StopUm: %d->%d %d\n", RefCount+1, RefCount, Status));
        SetLastError(Status);
        return(Status);
    }

    //
    // Finalize LogHeader ?
    //
    if (Status == ERROR_SUCCESS) {
        LoggerInfo->BuffersWritten = WmipLoggerContext->BuffersWritten;
        LoggerInfo->LogFileMode = WmipLoggerContext->LogFileMode;
        LoggerInfo->EventsLost = WmipLoggerContext->EventsLost;
        Status = WmipFinalizeLogFileHeader(LoggerInfo);
    }

    WmipFreeLoggerContext(WmipLoggerContext);
    WmipDisableTraceProvider(LoggerInfo);

    return Status;
}

ULONG
WmipProcessUMRequest(
    PWMI_LOGGER_INFORMATION LoggerInfo,
    PVOID DeliveryContext,
    ULONG ReplyIndex
    )
{
    ULONG Status;
    PWMIMBREPLY Reply;
    ULONG BufferSize;
    PUCHAR Buffer = NULL;
    ULONG WnodeSize = 0;
    ULONG SizeUsed, SizeNeeded;
    ULONG RequestCode = 0;
    ULONG RetSize;
    struct {
        WMIMBREPLY MBreply;
        ULONG      Status;
    }     DefaultReply;
    Reply = (PWMIMBREPLY) &DefaultReply;

    Reply->Handle.Handle = (HANDLE)DeliveryContext;
    Reply->ReplyIndex = ReplyIndex;

    BufferSize = sizeof(DefaultReply);

    if ( (LoggerInfo==NULL) ||
         (DeliveryContext == NULL) ) {
        DefaultReply.Status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    RequestCode = LoggerInfo->Wnode.ProviderId;
    WnodeSize = LoggerInfo->Wnode.BufferSize;
    SizeUsed = 0;
    SizeNeeded = 0;
    switch (RequestCode) {
        case WmiStartLoggerCode:
                Status = WmipStartUmLogger(WnodeSize,
                                            &SizeUsed,
                                            &SizeNeeded,
                                            LoggerInfo);
                break;

        case WmiStopLoggerCode:
                Status = WmipStopUmLogger(WnodeSize,
                                            &SizeUsed,
                                            &SizeNeeded,
                                            LoggerInfo);
                break;
        case WmiQueryLoggerCode:
                Status = WmipQueryUmLogger(WnodeSize,
                                            &SizeUsed,
                                            &SizeNeeded,
                                            LoggerInfo);
                break;
        case WmiUpdateLoggerCode:
            Status = WmipUpdateUmLogger(WnodeSize,
                                     &SizeUsed,
                                     &SizeNeeded,
                                     LoggerInfo);
                break;
        case WmiFlushLoggerCode:
            Status = WmipFlushUmLogger(WnodeSize,
                                     &SizeUsed,
                                     &SizeNeeded,
                                     LoggerInfo);
                break;
        default:
                Status = ERROR_INVALID_PARAMETER;
                break;
    }

    BufferSize += WnodeSize;

    Buffer = WmipAlloc(BufferSize);
    if (Buffer == NULL) {
        BufferSize = sizeof(DefaultReply);
        DefaultReply.Status = ERROR_OUTOFMEMORY;
    }
    else {
        RtlZeroMemory(Buffer, BufferSize);
        Reply = (PWMIMBREPLY) Buffer;
        Reply->Handle.Handle = (HANDLE)DeliveryContext;
        Reply->ReplyIndex = ReplyIndex;

        if (LoggerInfo != NULL)
        {
            memcpy(Reply->Message, LoggerInfo, LoggerInfo->Wnode.BufferSize);
        }
    }

cleanup:
    Status = WmipSendWmiKMRequest(NULL,
                              IOCTL_WMI_MB_REPLY,
                              Reply,
                              BufferSize,
                              Reply,
                              BufferSize,
                              &RetSize,
                              NULL);

   if (Buffer != NULL) {
       WmipFree(Buffer);
   }
   return Status;

}

PWMI_LOGGER_CONTEXT
WmipInitLoggerContext(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    PWMI_LOGGER_CONTEXT LoggerContext;
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION SystemInfo;

    LoggerContext = (PWMI_LOGGER_CONTEXT) WmipAlloc(sizeof(WMI_LOGGER_CONTEXT));
    if (LoggerContext == NULL) {
        return LoggerContext;
    }

    RtlZeroMemory(LoggerContext, sizeof(WMI_LOGGER_CONTEXT));

    if (LoggerInfo->BufferSize > 0) {
        LoggerContext->BufferSize = LoggerInfo->BufferSize * 1024;
    }
    else {
        LoggerContext->BufferSize       = DEFAULT_BUFFER_SIZE;
    }
    LoggerInfo->BufferSize = LoggerContext->BufferSize / 1024;


    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       &SystemInfo,
                                       sizeof (SystemInfo),
                                       NULL);

    if (!NT_SUCCESS(Status)) {
        WmipFree(LoggerContext);
        return NULL;
    }

    //
    // Round the Buffer Size to page size multiple and save it
    // for allocation later.
    //

    LoggerContext->BufferPageSize = ROUND_TO_PAGES(LoggerContext->BufferSize,
                                       SystemInfo.PageSize);

    LoggerContext->LogFileHandle = LoggerInfo->LogFileHandle;
    LoggerContext->ByteOffset.QuadPart = LoggerInfo->BuffersWritten
                                         * LoggerInfo->BufferSize * 1024;


    LoggerContext->LogFileMode      = EVENT_TRACE_PRIVATE_LOGGER_MODE;
    if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
        LoggerContext->LogFileMode |= EVENT_TRACE_FILE_MODE_CIRCULAR;
    else
        LoggerContext->LogFileMode |= EVENT_TRACE_FILE_MODE_SEQUENTIAL;

    if (LoggerInfo->LogFileMode & EVENT_TRACE_RELOG_MODE) {
        LoggerContext->LogFileMode |= EVENT_TRACE_RELOG_MODE; 
    }

    LoggerContext->EventsLost       = 0;
    LoggerContext->BuffersWritten   = LoggerInfo->BuffersWritten;
    LoggerContext->BuffersAvailable = LoggerContext->NumberOfBuffers;

    LoggerContext->ProcessorBuffers = NULL;

    LoggerContext->StartTime.QuadPart = WmipGetSystemTime();

    InitializeListHead(&LoggerContext->FreeList);
    InitializeListHead(&LoggerContext->FlushList);

    LoggerContext->BufferAgeLimit.QuadPart =
            15 * OneSecond.QuadPart * 60 * DEFAULT_AGE_LIMIT;
    if (LoggerInfo->AgeLimit > 0) {
        LoggerContext->BufferAgeLimit.QuadPart =
            LoggerInfo->AgeLimit * OneSecond.QuadPart * 60;
    }
    else if (LoggerInfo->AgeLimit < 0)
        LoggerContext->BufferAgeLimit.QuadPart = 0;

    Status = NtCreateSemaphore(
                &LoggerContext->Semaphore,
                SEMAPHORE_ALL_ACCESS,
                NULL,
                0,
                SEMAPHORE_LIMIT);

    if (!NT_SUCCESS(Status)) {
        WmipFree(LoggerContext);
        return NULL;
    }

    RtlInitializeCriticalSection(&UMLogCritSect);

    return LoggerContext;
}

PWMI_BUFFER_HEADER
FASTCALL
WmipGetFreeBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    PWMI_BUFFER_HEADER Buffer = NULL;

    if (IsListEmpty(&LoggerContext->FreeList)) {
        ULONG BufferSize = LoggerContext->BufferPageSize;
        ULONG MaxBuffers = LoggerContext->MaximumBuffers;
        ULONG NumberOfBuffers = LoggerContext->NumberOfBuffers;

        if (NumberOfBuffers < MaxBuffers) {
            Buffer = (PWMI_BUFFER_HEADER)
                        WmipMemCommit(
                            (PVOID)((char*)LoggerContext->BufferSpace +
                                     BufferSize *  NumberOfBuffers),
                            BufferSize);
            if (Buffer != NULL) {
                RtlZeroMemory(Buffer, sizeof(WMI_BUFFER_HEADER));
                Buffer->CurrentOffset       = sizeof(WMI_BUFFER_HEADER);
                Buffer->Flags               = BUFFER_STATE_DIRTY;
                Buffer->ReferenceCount      = 0;
                Buffer->SavedOffset         = 0;
                Buffer->Wnode.ClientContext = 0;
                InterlockedIncrement(&LoggerContext->NumberOfBuffers);
            }
        }
    }
    else {
        PLIST_ENTRY pEntry = RemoveHeadList(&LoggerContext->FreeList);
        if (pEntry != NULL) {
            Buffer = CONTAINING_RECORD(pEntry, WMI_BUFFER_HEADER, Entry);
            InterlockedDecrement(&LoggerContext->BuffersAvailable);
            Buffer->CurrentOffset       = sizeof(WMI_BUFFER_HEADER);
            Buffer->Flags               = BUFFER_STATE_DIRTY;
            Buffer->SavedOffset         = 0;
            Buffer->ReferenceCount      = 0;
            Buffer->Wnode.ClientContext = 0;
        }
    }
    return Buffer;
}


ULONG
WmipAllocateTraceBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
/*++

Routine Description:

    This routine is called to allocate the necessary buffers for user-mode
    only logging.

Arguments:

    None

Return Value:

    Status of allocating the buffers
--*/

{
    ULONG Processors;
    ULONG BufferSize;
    ULONG BufferPageSize;
    ULONG NumberOfBuffers;
    ULONG i;
    PVOID BufferSpace;
    PWMI_BUFFER_HEADER Buffer;

    Processors = LoggerContext->NumberOfProcessors;
    if (Processors == 0)
        Processors = 1;
    BufferSize = LoggerContext->BufferSize;
    if (BufferSize < 1024)
        BufferSize = 4096;

    NumberOfBuffers = LoggerContext->NumberOfBuffers;
    if (NumberOfBuffers < Processors+1)
        NumberOfBuffers = Processors + 1;

    //
    // Determine the number of processors first
    //
    LoggerContext->ProcessorBuffers = WmipAlloc( Processors
                                                 * sizeof(PWMI_BUFFER_HEADER));
    if (LoggerContext->ProcessorBuffers == NULL) {
        return ERROR_OUTOFMEMORY;
    }
    BufferSpace = WmipMemReserve( LoggerContext->MaximumBuffers *
                                  LoggerContext->BufferPageSize );
    if (BufferSpace == NULL) {
        WmipFree(LoggerContext->ProcessorBuffers);
        LoggerContext->ProcessorBuffers = NULL;
        return ERROR_OUTOFMEMORY;
    }

    LoggerContext->BufferSpace = BufferSpace;

    for (i=0; i<NumberOfBuffers; i++) {
        Buffer = (PWMI_BUFFER_HEADER)
                    WmipMemCommit(
                        (PVOID)((char*)BufferSpace + i * LoggerContext->BufferPageSize),
                        BufferSize);
        if (Buffer == NULL) {
            WmipMemFree(LoggerContext->BufferSpace);
            WmipFree(LoggerContext->ProcessorBuffers);
            LoggerContext->ProcessorBuffers = NULL;
            LoggerContext->BufferSpace = NULL;
            return ERROR_OUTOFMEMORY;
        }
        RtlZeroMemory(Buffer, sizeof(WMI_BUFFER_HEADER));
        Buffer->TimeStamp.QuadPart = WmipGetSystemTime();
        Buffer->CurrentOffset = sizeof(WMI_BUFFER_HEADER);
        Buffer->Wnode.Flags = BUFFER_STATE_DIRTY;
        InsertTailList(&LoggerContext->FreeList, & (Buffer->Entry));
    }
    LoggerContext->NumberOfBuffers  = NumberOfBuffers;
    LoggerContext->BuffersAvailable = NumberOfBuffers;
    for (i=0; i<Processors; i++) {
        Buffer = (PWMI_BUFFER_HEADER) WmipGetFreeBuffer(LoggerContext);
        LoggerContext->ProcessorBuffers[i] = Buffer;
        if (Buffer != NULL) {
            Buffer->ClientContext.ProcessorNumber = (UCHAR) i;
        }
        else {
            WmipMemFree(LoggerContext->BufferSpace);
            WmipFree(LoggerContext->ProcessorBuffers);
            LoggerContext->ProcessorBuffers = NULL;
            LoggerContext->BufferSpace = NULL;
            return ERROR_OUTOFMEMORY;
        }
    }

    return ERROR_SUCCESS;
}

VOID
WmipLogger(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )

/*++

Routine Description:
    This function is the logger itself. It is started as a separate thread.
    It will not return until someone has stopped data collection or it
    is not successful is flushing out a buffer (e.g. disk is full).

Arguments:

    None.

Return Value:

    The status of running the buffer manager

--*/

{
    PWMI_BUFFER_HEADER Buffer;
    NTSTATUS Status;
    ULONG    i, ErrorCount;
    PLIST_ENTRY pEntry;

    Status = STATUS_SUCCESS;

    LoggerContext->LoggerStatus = Status;
    if (NT_SUCCESS(Status)) {
//
// This is the only place where CollectionOn will be turn on!!!
//
        LoggerContext->CollectionOn = TRUE;
        NtSetEvent(LoggerContext->LoggerEvent, NULL);
    }
    else {
        NtSetEvent(LoggerContext->LoggerEvent, NULL);
        return;
    }

    ErrorCount = 0;
// by now, the caller has been notified that the logger is running

//
// Loop and wait for buffers to be filled until someone turns off CollectionOn
//
    while (LoggerContext->CollectionOn) {
        ULONG Counter;
        ULONG DelayFlush;
        PLARGE_INTEGER FlushTimer;

        if (LoggerContext->FlushTimer.QuadPart == 0) {
            FlushTimer = NULL;
        }
        else {
            FlushTimer = &LoggerContext->FlushTimer;
        }

        Status = NtWaitForSingleObject( LoggerContext->Semaphore, FALSE,
                                      FlushTimer);

        DelayFlush = FALSE;
        if ( Status == WAIT_TIMEOUT) {
//
// FlushTimer used, and we just timed out. Go through per processor buffer
// and mark each as FULL so that it will get flushed next time
//
            for (i=0; i<(ULONG)LoggerContext->NumberOfProcessors; i++) {
                Buffer = (PWMI_BUFFER_HEADER)LoggerContext->ProcessorBuffers[i];
                if (Buffer == NULL)
                    continue;

                if (Buffer->CurrentOffset == sizeof(WMI_BUFFER_HEADER))
                    Buffer->Flags = BUFFER_STATE_UNUSED;
                if (Buffer->Flags != BUFFER_STATE_UNUSED) {
                    Buffer->Flags = BUFFER_STATE_FULL;
                    DelayFlush = TRUE; // let ReserveTraceBuffer send semaphore
                }
            }
        }

        if (DelayFlush)    // will only be TRUE if FlushTimer is used
            continue;

        LoggerContext->TransitionBuffer = LoggerContext->FlushList.Flink;
        WmipEnterUMCritSection();
        pEntry = IsListEmpty(& LoggerContext->FlushList)
               ? NULL
               : RemoveHeadList(& LoggerContext->FlushList);
        WmipLeaveUMCritSection();

        if (pEntry == NULL) {  // should not happen normally
            continue;
        }

        Buffer = CONTAINING_RECORD(pEntry, WMI_BUFFER_HEADER, Entry);
        if (Buffer->Flags == BUFFER_STATE_UNUSED) {
            Buffer->Flags = BUFFER_STATE_DIRTY; // Let FlushBuffer deal with it
        }

        Status = WmipFlushBuffer(LoggerContext, Buffer);

        WmipEnterUMCritSection();
        if (LoggerContext->BufferAgeLimit.QuadPart == 0) {
            InsertTailList(&LoggerContext->FreeList, &Buffer->Entry);
        }
        else {
            InsertHeadList(&LoggerContext->FreeList, &Buffer->Entry);
        }
        WmipLeaveUMCritSection();
        LoggerContext->TransitionBuffer = NULL;

        if ((Status == STATUS_LOG_FILE_FULL) ||
           (Status == STATUS_NO_DATA_DETECTED) ||
           (Status == STATUS_SEVERITY_WARNING)) {
           if (Status == STATUS_LOG_FILE_FULL)
               ErrorCount++;
           else ErrorCount = 0;    // reset to zero otherwise
           if (ErrorCount <= ERROR_RETRY_COUNT)
               continue;       // for now. Should raise WMI event
        }

        if (!NT_SUCCESS(Status)) {
#if DBG
            LONG RefCount;
#endif
            Status = NtClose(LoggerContext->LogFileHandle);
            LoggerContext->LogFileHandle = NULL;

            WmipStopLoggerInstance();
#if DBG
            RefCount =
#endif
            WmipLockLogger();
            TraceDebug(("WmipLogger: %d->%d\n", RefCount-1, RefCount));
            WmipFreeLoggerContext (LoggerContext);
            WmipSetDosError(WmipNtStatusToDosError(Status));
            return;
        }
    } // while loop

    // if a normal collection end, flush out all the buffers before stopping
    //
    WmipFlushAllBuffers(LoggerContext);

    NtSetEvent(LoggerContext->LoggerEvent, NULL);
    RtlDeleteCriticalSection(&UMLogCritSect);
    return; // check to see if this thread terminate itself with this
}


ULONG
WmipFlushBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER Buffer
    )
/*++

Routine Description:
    This function is responsible for flushing a filled buffer out to
    disk, or to a real time consumer.

Arguments:

    LoggerContext       Context of the logger

Return Value:

    The status of flushing the buffer

--*/
{
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    PWMI_BUFFER_HEADER OldBuffer;
    ULONG BufferSize;

//
// Grab the buffer to be flushed
//
    BufferSize = LoggerContext->BufferSize;
//
// Put end of record marker in buffer if available space
//
    if (Buffer->SavedOffset > 0) {
        Buffer->Offset = Buffer->SavedOffset;
    }
    else {
        Buffer->Offset = Buffer->CurrentOffset;
    }

    if (Buffer->Offset < BufferSize) {
        RtlFillMemory(
                (char *) Buffer + Buffer->Offset,
                BufferSize - Buffer->Offset,
                0xFF);
    }
    if (Buffer->Offset < sizeof(WMI_BUFFER_HEADER)) { // should not happen
        Status = STATUS_INVALID_PARAMETER;
        goto ResetTraceBuffer;
    }
    if (Buffer->Offset == sizeof(WMI_BUFFER_HEADER)) { // empty buffer
        Status = STATUS_NO_DATA_DETECTED;
        goto ResetTraceBuffer;
    }
    Status = STATUS_SUCCESS;
    Buffer->Wnode.BufferSize       = BufferSize;
    Buffer->ClientContext.LoggerId = (USHORT) LoggerContext->LoggerId;

    Buffer->ClientContext.Alignment = (UCHAR) WmiTraceAlignment;
    RtlCopyMemory(&Buffer->Wnode.Guid, &EventTraceGuid, sizeof(GUID));
    Buffer->Wnode.Flags = WNODE_FLAG_TRACED_GUID;

    Buffer->Wnode.TimeStamp.QuadPart = WmipGetSystemTime();

    if (LoggerContext->LogFileHandle == NULL) {
        goto ResetTraceBuffer;
    }

    if (LoggerContext->MaximumFileSize > 0) { // if quota given
        ULONG64 FileSize = LoggerContext->LastFlushedBuffer * BufferSize;
        ULONG64 FileLimit = LoggerContext->MaximumFileSize * BYTES_PER_MB;
        if ( FileSize >= FileLimit ) { // reaches maximum file size
           ULONG LoggerMode = LoggerContext->LogFileMode & 0X000000FF;
           LoggerMode &= ~EVENT_TRACE_FILE_MODE_APPEND;
           LoggerMode &= ~EVENT_TRACE_FILE_MODE_PREALLOCATE;

            switch (LoggerMode) {


            case EVENT_TRACE_FILE_MODE_SEQUENTIAL :
                // do not write to logfile anymore
                Status = STATUS_LOG_FILE_FULL; // control needs to stop logging
                // need to fire up a Wmi Event to control console
                break;

            case EVENT_TRACE_FILE_MODE_CIRCULAR   :
            {
                // reposition file

                LoggerContext->ByteOffset
                    = LoggerContext->FirstBufferOffset;
                LoggerContext->LastFlushedBuffer = (ULONG)
                      (LoggerContext->FirstBufferOffset.QuadPart
                        / LoggerContext->BufferSize);
                break;
            }
            default :
                break;
            }
        }
    }

    if (NT_SUCCESS(Status)) {
        Status = NtWriteFile(
                    LoggerContext->LogFileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    Buffer,
                    BufferSize,
                    &LoggerContext->ByteOffset,
                    NULL);
    }

    if (NT_SUCCESS(Status)) {
        LoggerContext->ByteOffset.QuadPart += BufferSize;
    }

 ResetTraceBuffer:

    if (NT_SUCCESS(Status)) {
        LoggerContext->BuffersWritten++;
        LoggerContext->LastFlushedBuffer++;
    }
    else {
        if ((Status != STATUS_NO_DATA_DETECTED) &&
            (Status != STATUS_SEVERITY_WARNING))
            LoggerContext->LogBuffersLost++;
    }

//
// Reset the buffer state
//

    Buffer->EventsLost     = 0;
    Buffer->SavedOffset    = 0;
    Buffer->ReferenceCount = 0;
    Buffer->Flags          = BUFFER_STATE_UNUSED;

//
// Try and remove an unused buffer if it has not been used for a while
//

    InterlockedIncrement(& LoggerContext->BuffersAvailable);
    return Status;
}

PVOID
FASTCALL
WmipReserveTraceBuffer(
    IN  ULONG RequiredSize,
    OUT PWMI_BUFFER_HEADER *BufferResource
    )
{
    PWMI_BUFFER_HEADER Buffer, OldBuffer;
    PVOID       ReservedSpace;
    ULONG       Offset;
    ULONG       fCircularBufferOnly = FALSE; // tracelog.c v39->v40
    ULONG Processor = (ULONG) (NtCurrentTeb()->IdealProcessor);
    PWMI_LOGGER_CONTEXT LoggerContext = WmipLoggerContext;

    //
    // NOTE: This routine assumes that the caller has verified that
    // WmipLoggerContext is valid and is locked
    //
    if (Processor >= LoggerContext->NumberOfProcessors) {
        Processor = LoggerContext->NumberOfProcessors-1;
    }


    *BufferResource = NULL;

    RequiredSize = (ULONG) ALIGN_TO_POWER2(RequiredSize, WmiTraceAlignment);

  TryFindSpace:
//
// Get the processor specific buffer pool
//
    Buffer = LoggerContext->ProcessorBuffers[Processor];
    if (Buffer == NULL) {
        return NULL;
    }

    //
    // Increment refcount to buffer first to prevent it from going away
    //
    InterlockedIncrement(&Buffer->ReferenceCount);
    if ((Buffer->Flags != BUFFER_STATE_FULL) &&
        (Buffer->Flags != BUFFER_STATE_UNUSED)) {
//
// This should happen 99% of the time. Offset will have the old value
//
        Offset = (ULONG) InterlockedExchangeAdd(
                                & Buffer->CurrentOffset, RequiredSize);

//
// First, check to see if there is enough space. If not, it will
//   need to get another fresh buffer, and have the current buffer flushed
//
        if (Offset+RequiredSize < WmipLoggerContext->BufferSize) {
//
// Found the space so return it. This should happen 99% of the time
//
            ReservedSpace = (PVOID) (Offset +  (char*)Buffer);
            if (LoggerContext->SequencePtr) {
                *((PULONG) ReservedSpace) =
                    InterlockedIncrement(LoggerContext->SequencePtr);
            }
            goto FoundSpace;
        }
    }
    else {
        Offset = Buffer->CurrentOffset; // Initialize Local Variable
                                        // tracelog.c v40 -> v41
    }
    if (Offset <LoggerContext->BufferSize) {
        Buffer->SavedOffset = Offset;       // save this for FlushBuffer
    }

//  if there is absolutely no more buffers, then return quickly
//
    if ((LoggerContext->NumberOfBuffers == LoggerContext->MaximumBuffers)
         && (LoggerContext->BuffersAvailable == 0)) {
        goto LostEvent;
    }

// Out of buffer space. Need to take the long route to find a buffer
//
    Buffer->Flags = BUFFER_STATE_FULL;

    OldBuffer = Buffer;
    Buffer = WmipSwitchBuffer(LoggerContext, OldBuffer, Processor);
    if (Buffer == NULL) {
        Buffer = OldBuffer;
        goto LostEvent;
    }

    //
    // Decrement the refcount that we blindly incremented earlier
    // so that it can be flushed by the logger thread
    //
    InterlockedDecrement(&OldBuffer->ReferenceCount);
    Buffer->ClientContext.ProcessorNumber = (UCHAR) (Processor);

    if (!fCircularBufferOnly) {
        NtReleaseSemaphore(LoggerContext->Semaphore, 1, NULL);
    }

    goto TryFindSpace;

LostEvent:
//
// Will get here if we are throwing away events.
// from tracelog.c v36->v37
//
    LoggerContext->EventsLost ++;
    Buffer->EventsLost ++;
    InterlockedDecrement(& Buffer->ReferenceCount);
    Buffer        = NULL;
    ReservedSpace = NULL;
    if (LoggerContext->SequencePtr) {
        InterlockedIncrement(LoggerContext->SequencePtr);
    }

FoundSpace:
//
// notify the logger after critical section
//
    *BufferResource = Buffer;

    return ReservedSpace;
}



//
// This Routine is called to Relog an event for straigtening out an ETL
// in time order. This will result in two events being, one for Processor
// number and the actual event  without any modifications.
//

ULONG
FASTCALL
WmipRelogEvent(
    IN PWNODE_HEADER Wnode
    )
{
    PWMI_BUFFER_HEADER BufferResource = NULL;
    PEVENT_TRACE pEvent = (PEVENT_TRACE) Wnode;
    PWMI_LOGGER_CONTEXT LoggerContext;

    PUCHAR BufferSpace;
    PULONG Marker;
    ULONG Size;
    ULONG MaxSize;
    ULONG SavedProcessor = (ULONG)NtCurrentTeb()->IdealProcessor;
    ULONG Processor;
    ULONG Mask;
    ULONG status;

    if (pEvent->Header.Size < sizeof(EVENT_TRACE) ) {
        return ERROR_INVALID_PARAMETER;
    }
    LoggerContext = WmipLoggerContext;
    Processor = ((PWMI_CLIENT_CONTEXT)&pEvent->ClientContext)->ProcessorNumber;

    Size = pEvent->MofLength;
    MaxSize = LoggerContext->BufferSize - sizeof(WMI_BUFFER_HEADER);
    if ((Size == 0) || (Size > MaxSize)) {
        LoggerContext->EventsLost++;
        return ERROR_BUFFER_OVERFLOW;
    }
    NtCurrentTeb()->IdealProcessor = (BOOLEAN)Processor;
    BufferSpace = (PUCHAR)
        WmipReserveTraceBuffer(
            Size,
            &BufferResource
            );
    NtCurrentTeb()->IdealProcessor = (BOOLEAN)SavedProcessor;

    if (BufferSpace == NULL) {
        return ERROR_OUTOFMEMORY;
    }


    RtlCopyMemory(BufferSpace, pEvent->MofData, Size);
    WmipReleaseTraceBuffer( BufferResource );

    return ERROR_SUCCESS;
}



ULONG
FASTCALL
WmiTraceUmEvent(
    IN PWNODE_HEADER Wnode
    )
/*++

Routine Description:

    This routine is used by WMI data providers to trace events.
    It expects the user to pass in the handle to the logger.
    Also, the user cannot ask to log something that is larger than
    the buffer size (minus buffer header).

Arguments:

    Wnode           The WMI node header that will be overloaded


Return Value:

    STATUS_SUCCESS  if the event trace is recorded successfully

--*/
{
    PEVENT_TRACE_HEADER TraceRecord = (PEVENT_TRACE_HEADER) Wnode;
    ULONG WnodeSize, Size, Flags, HeaderSize;
    PWMI_BUFFER_HEADER BufferResource = NULL;
    PWMI_LOGGER_CONTEXT LoggerContext;
    ULONG Marker;
    MOF_FIELD MofFields[MAX_MOF_FIELDS];
    long MofCount = 0;
    PCLIENT_ID Cid;
#if DBG
    LONG RefCount;
#endif


    HeaderSize = sizeof(WNODE_HEADER);  // same size as EVENT_TRACE_HEADER
    Size = Wnode->BufferSize;     // take the first DWORD flags
    Marker = Size;
    if (Marker & TRACE_HEADER_FLAG) {
        if ( ((Marker & TRACE_HEADER_ENUM_MASK) >> 16)
                == TRACE_HEADER_TYPE_INSTANCE )
            HeaderSize = sizeof(EVENT_INSTANCE_HEADER);
        Size = TraceRecord->Size;
    }
    WnodeSize = Size;           // WnodeSize is for the contiguous block
                                    // Size is for what we want in buffer

    Flags = Wnode->Flags;
    if (!(Flags & WNODE_FLAG_LOG_WNODE) &&
        !(Flags & WNODE_FLAG_TRACED_GUID))
        return ERROR_INVALID_PARAMETER;

#if DBG
    RefCount =
#endif
    WmipLockLogger();
#if DBG
    TraceDebug(("TraceUm: %d->%d\n", RefCount-1, RefCount));
#endif

    if (!WmipIsLoggerOn()) {
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
#if DBG
        TraceDebug(("TraceUm: %d->%d INVALID_HANDLE\n",
                        RefCount+1, RefCount));
#endif
        return ERROR_INVALID_HANDLE;
    }

    LoggerContext = WmipLoggerContext;

    if (Flags & WNODE_FLAG_NO_HEADER) {
        ULONG Status;

        Status = WmipRelogEvent( Wnode );
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();

#if DBG
        if (Status != ERROR_SUCCESS) {
            TraceDebug(("TraceUm: %d->%d Relog Error \n",
                            RefCount+1, RefCount));
        }
#endif
        return Status;

    }

    if (Flags & WNODE_FLAG_USE_MOF_PTR) {
    //
    // Need to compute the total size required, since the MOF fields
    // in Wnode merely contains pointers
    //
        long i;
        PCHAR Offset = ((PCHAR)Wnode) + HeaderSize;
        ULONG MofSize, MaxSize;

        MaxSize = LoggerContext->BufferSize - sizeof(WMI_BUFFER_HEADER);
        MofSize = WnodeSize - HeaderSize;
        // allow only the maximum
        if (MofSize > (sizeof(MOF_FIELD) * MAX_MOF_FIELDS))
            return ERROR_INVALID_DATA;

        // TODO: Do we need to zero memory here?
        RtlZeroMemory( MofFields, MAX_MOF_FIELDS * sizeof(MOF_FIELD));
        if (MofSize > 0) {
            RtlCopyMemory(MofFields, Offset, MofSize);
        }
        Size = HeaderSize;

        MofCount = MofSize / sizeof(MOF_FIELD);
        for (i=0; i<MofCount; i++) {
            MofSize = MofFields[i].Length;
            if (MofSize > (MaxSize - Size)) {
#if DBG
                RefCount =
#endif
                WmipUnlockLogger();
#if DBG
                TraceDebug(("TraceUm: %d->%d BUF_OVERFLOW1\n",
                            RefCount+1, RefCount));
#endif
                return ERROR_BUFFER_OVERFLOW;
            }

            Size += MofSize;
            if ((Size > MaxSize) || (Size < MofSize)) {
#if DBG
                RefCount =
#endif
                WmipUnlockLogger();
#if DBG
                TraceDebug(("TraceUm: %d->%d BUF_OVERFLOW2\n",
                            RefCount+1, RefCount));
#endif
                return ERROR_BUFFER_OVERFLOW;
            }
        }
    }
    if (Size > LoggerContext->BufferSize - sizeof(WMI_BUFFER_HEADER)) {
        LoggerContext->EventsLost++;
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
#if DBG
        TraceDebug(("TraceUm: %d->%d BUF_OVERFLOW3\n",
                    RefCount+1, RefCount));
#endif
        return ERROR_BUFFER_OVERFLOW;
    }

// So, now reserve some space in logger buffer and set that to TraceRecord

    TraceRecord = (PEVENT_TRACE_HEADER)
        WmipReserveTraceBuffer(
            Size,
            &BufferResource
            );

    if (TraceRecord == NULL) {
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
#if DBG
        TraceDebug(("TraceUm: %d->%d NO_MEMORY\n", RefCount+1, RefCount));
#endif
        return ERROR_OUTOFMEMORY;
    }

    if (Flags & WNODE_FLAG_USE_MOF_PTR) {
    //
    // Now we need to probe and copy all the MOF data fields
    //
        PVOID MofPtr;
        ULONG MofLen;
        long i;
        PCHAR TraceOffset = ((PCHAR) TraceRecord) + HeaderSize;

        RtlCopyMemory(TraceRecord, Wnode, HeaderSize);
        TraceRecord->Size = (USHORT)Size;           // reset to Total Size
        for (i=0; i<MofCount; i++) {
            MofPtr = (PVOID) MofFields[i].DataPtr;
            MofLen = MofFields[i].Length;

            if (MofPtr == NULL || MofLen == 0)
                continue;

            RtlCopyMemory(TraceOffset, MofPtr, MofLen);
            TraceOffset += MofLen;
        }
    }
    else {
        RtlCopyMemory(TraceRecord, Wnode, Size);
    }
    if (Flags & WNODE_FLAG_USE_GUID_PTR) {
        PVOID GuidPtr = (PVOID) ((PEVENT_TRACE_HEADER)Wnode)->GuidPtr;

        RtlCopyMemory(&TraceRecord->Guid, GuidPtr, sizeof(GUID));
    }

    //
    // By now, we have reserved space in the trace buffer
    //

    if (Marker & TRACE_HEADER_FLAG) {
        if (! (WNODE_FLAG_USE_TIMESTAMP & TraceRecord->MarkerFlags) )
            TraceRecord->ProcessorTime = WmipGetCycleCount();

        if (LoggerContext->UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
            TraceRecord->TimeStamp.QuadPart = TraceRecord->ProcessorTime;
        }
        else {
            TraceRecord->TimeStamp.QuadPart = WmipGetSystemTime();
        }
        Cid = &NtCurrentTeb()->ClientId;
        TraceRecord->ThreadId = HandleToUlong(Cid->UniqueThread);
        TraceRecord->ProcessId = HandleToUlong(Cid->UniqueProcess);
    }

    WmipReleaseTraceBuffer( BufferResource );
#if DBG
    RefCount =
#endif
    WmipUnlockLogger();

#if DBG
    TraceDebug(("TraceUm: %d->%d\n", RefCount+1, RefCount));
#endif

    return ERROR_SUCCESS;
}

PWMI_BUFFER_HEADER
FASTCALL
WmipSwitchBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER OldBuffer,
    IN ULONG Processor
    )
{
    PWMI_BUFFER_HEADER Buffer;
    ULONG CircularBufferOnly = FALSE;

    if ( (LoggerContext->LogFileMode & EVENT_TRACE_BUFFERING_MODE) &&
         (LoggerContext->BufferAgeLimit.QuadPart == 0) &&
         (LoggerContext->LogFileHandle == NULL) ) {
        CircularBufferOnly = TRUE;
    }
    WmipEnterUMCritSection();
    if (OldBuffer != LoggerContext->ProcessorBuffers[Processor]) {
        WmipLeaveUMCritSection();
        return OldBuffer;
    }
    Buffer = WmipGetFreeBuffer(LoggerContext);
    if (Buffer == NULL) {
        WmipLeaveUMCritSection();
        return NULL;
    }
    LoggerContext->ProcessorBuffers[Processor] = Buffer;
    if (CircularBufferOnly) {
        InsertTailList(&LoggerContext->FreeList, &OldBuffer->Entry);
    }
    else {
        InsertTailList(&LoggerContext->FlushList, &OldBuffer->Entry);
    }
    WmipLeaveUMCritSection();

    return Buffer;
}

ULONG
WmipFreeLoggerContext(
    PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    LONG RefCount;
    if (LoggerContext != NULL) {
        LARGE_INTEGER Timeout = {(ULONG)(-300 * 1000 * 10), -1};  // 300ms
        RefCount = WmipUnlockLogger();
#if DBG
        TraceDebug(("FreeLogger: %d->%d\n", RefCount+1, RefCount));
#endif
        if (RefCount > 1) {
            LONG count = 0;
            NTSTATUS Status = STATUS_TIMEOUT;

            while (Status == STATUS_TIMEOUT) {
                count ++;
                Status = NtWaitForSingleObject(
                            WmipLoggerContext->LoggerEvent, FALSE, &Timeout);
                if (WmipLoggerCount <= 1)
                    break;
                if (WmipLoggerCount == RefCount) {
#if DBG
                    TraceDebug(("FreeLogger: RefCount remained at %d\n",
                                 RefCount));
                    WmipAssert(Status != STATUS_TIMEOUT);
#endif
                    if (count >= 10)
                        WmipLoggerCount = 1;
                }
            }
        }
        if (LoggerContext->BufferSpace != NULL) {
            WmipMemFree(LoggerContext->BufferSpace);
        }
        if (LoggerContext->ProcessorBuffers != NULL) {
            WmipFree(LoggerContext->ProcessorBuffers);
        }
        if (LoggerContext->LoggerName.Buffer != NULL) {
            RtlFreeUnicodeString(&LoggerContext->LoggerName);
        }
        if (LoggerContext->LogFileName.Buffer != NULL) {
            RtlFreeUnicodeString(&LoggerContext->LogFileName);
        }
        WmipLoggerContext = NULL;
        WmipFree(LoggerContext);
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("FreeLogger: %d->%d\n", RefCount+1, RefCount));

        RtlDeleteCriticalSection(&UMLogCritSect);
    }
    return ERROR_SUCCESS;
}

ULONG
WmipFlushAllBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    NTSTATUS           Status = STATUS_SUCCESS;
    ULONG              i;
    ULONG              NumberOfBuffers;
    PLIST_ENTRY        pEntry;
    PWMI_BUFFER_HEADER Buffer;
    ULONG RetryCount;

    WmipEnterUMCritSection();

    // First, move the per processor buffer out to FlushList
    //
    for (i = 0; i < LoggerContext->NumberOfProcessors; i ++) {
        Buffer = (PWMI_BUFFER_HEADER) LoggerContext->ProcessorBuffers[i];
        LoggerContext->ProcessorBuffers[i] = NULL;
        if (Buffer != NULL) {

            //
            // Check to see if the Buffer ReferenceCount is 0. If Yes,
            // no one is writing to this buffer and it's okay to flush it.
            // If No, we need to wait until the other thread is done
            // writing to this buffer before flushing.
            //
            RetryCount = 0;
            while (Buffer->ReferenceCount != 0) {
                Sleep (250);  // Retry every 1/4 second.
                RetryCount++;
                if (RetryCount > 300) {
                    //
                    // Since there is no guarantee that the ReferenceCount
                    // will ever go down to zero, we try this for over a minute.
                    // After that time we continue and free the buffer
                    // instead of spinning for ever.
#if DBG
                    TraceDebug(("WmipFlushAllBuffer: RetryCount %d exceeds limit", RetryCount));
#endif
                    break;
                }
            }
            InsertTailList(& LoggerContext->FlushList, & Buffer->Entry);
        }
    }
    NumberOfBuffers = LoggerContext->NumberOfBuffers;

    while (   NT_SUCCESS(Status)
           && NumberOfBuffers > 0
           && (  LoggerContext->BuffersAvailable
               < LoggerContext->NumberOfBuffers))
    {
        pEntry = IsListEmpty(& LoggerContext->FlushList)
               ? NULL
               : RemoveHeadList(& LoggerContext->FlushList);

        if (pEntry == NULL)
            break;

        Buffer = CONTAINING_RECORD(pEntry, WMI_BUFFER_HEADER, Entry);
        Status = WmipFlushBuffer(LoggerContext, Buffer);
        InsertHeadList(& LoggerContext->FreeList, & Buffer->Entry);
        NumberOfBuffers --;
    }
    // Note that LoggerContext->LogFileObject needs to remain set
    // for QueryLogger to work after close
    //
    Status = NtClose(LoggerContext->LogFileHandle);

    LoggerContext->LogFileHandle = NULL;
    LoggerContext->LoggerStatus = Status;

    WmipLeaveUMCritSection();

    return ERROR_SUCCESS;
}

ULONG
WmipFlushUmLoggerBuffer()
{
    ULONG Status = ERROR_SUCCESS;
#if DBG
    LONG RefCount;

    RefCount =
#endif
    WmipLockLogger();
    TraceDebug(("FlushUm: %d->%d\n", RefCount-1, RefCount));

    if (WmipIsLoggerOn()) {
        WmipLoggerContext->CollectionOn = FALSE;
        Status = WmipFlushAllBuffers(WmipLoggerContext);
        if (Status == ERROR_SUCCESS) {
            PWMI_LOGGER_INFORMATION WmipLoggerInfo = NULL;
            ULONG                   lSizeUsed;
            ULONG                   lSizeNeeded = 0;

            lSizeUsed = sizeof(WMI_LOGGER_INFORMATION)
                      + 2 * MAXSTR * sizeof(WCHAR);
            WmipLoggerInfo = (PWMI_LOGGER_INFORMATION) WmipAlloc(lSizeUsed);
            if (WmipLoggerInfo == NULL) {
                Status = ERROR_OUTOFMEMORY;
            }
            else {
                RtlZeroMemory(WmipLoggerInfo, lSizeUsed);
                WmipLoggerInfo->Wnode.BufferSize  = lSizeUsed;
                WmipLoggerInfo->Wnode.Flags      |= WNODE_FLAG_TRACED_GUID;
                Status = WmipQueryUmLogger(
                                WmipLoggerInfo->Wnode.BufferSize,
                                & lSizeUsed,
                                & lSizeNeeded,
                                WmipLoggerInfo);

                if (Status == ERROR_SUCCESS) {
                    Status = WmipFinalizeLogFileHeader(WmipLoggerInfo);
                }
                WmipFree(WmipLoggerInfo);
            }
        }
        WmipFreeLoggerContext(WmipLoggerContext);
    }

    return Status;
}

LONG
FASTCALL
WmipReleaseTraceBuffer(
    IN PWMI_BUFFER_HEADER BufferResource
    )
{
    ULONG RefCount;

    if (BufferResource == NULL)
        return 0;

    RefCount = InterlockedDecrement(&BufferResource->ReferenceCount);
    if ((RefCount == 0) && (BufferResource->Flags == BUFFER_STATE_FULL)) {
        NtReleaseSemaphore(WmipLoggerContext->Semaphore, 1, NULL);
    }
    return RefCount;
}


ULONG
WmipReceiveReply(
    HANDLE ReplyHandle,
    ULONG  ReplyCount,
    ULONG ReplyIndex,
    PVOID OutBuffer,
    ULONG OutBufferSize
    )
{
    ULONG Status = ERROR_SUCCESS;
    ULONG ReturnSize;
    PWMIRECEIVENOTIFICATION RcvNotification;
    ULONG RcvNotificationSize;
    PUCHAR Buffer;
    ULONG BufferSize;
    PWNODE_TOO_SMALL WnodeTooSmall;
    PWNODE_HEADER Wnode;
    ULONG Linkage;
    ULONG RcvCount = 0;
    struct {
        WMIRECEIVENOTIFICATION Notification;
        HANDLE3264 Handle;
    } NotificationInfo;


    RcvNotificationSize = sizeof(WMIRECEIVENOTIFICATION) +
                          sizeof(HANDLE3264);

    RcvNotification = (PWMIRECEIVENOTIFICATION) &NotificationInfo;

    Status = ERROR_SUCCESS;

    RcvNotification->Handles[0].Handle64 = 0;
    RcvNotification->Handles[0].Handle = ReplyHandle;
    RcvNotification->HandleCount = 1;
    RcvNotification->Action = RECEIVE_ACTION_NONE;
    WmipSetPVoid3264(RcvNotification->UserModeCallback, NULL);

    BufferSize = 0x1000;
    Status = ERROR_INSUFFICIENT_BUFFER;
    while ( (Status == ERROR_INSUFFICIENT_BUFFER) ||
            ((Status == ERROR_SUCCESS) && (RcvCount < ReplyCount)) )
    {
        Buffer = WmipAlloc(BufferSize);
        if (Buffer != NULL)
        {
            Status = WmipSendWmiKMRequest(NULL,
                                      IOCTL_WMI_RECEIVE_NOTIFICATIONS,
                                      RcvNotification,
                                      RcvNotificationSize,
                                      Buffer,
                                      BufferSize,
                                      &ReturnSize,
                                      NULL);

             if (Status == ERROR_SUCCESS)
             {
                 WnodeTooSmall = (PWNODE_TOO_SMALL)Buffer;
                 if ((ReturnSize == sizeof(WNODE_TOO_SMALL)) &&
                     (WnodeTooSmall->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL))
                 {
                    //
                    // The buffer passed to kernel mode was too small
                    // so we need to make it larger and then try the
                    // request again
                    //
                    BufferSize = WnodeTooSmall->SizeNeeded;
                    Status = ERROR_INSUFFICIENT_BUFFER;
                 } else {
                    //
                    // We got a buffer of notifications so lets go
                    // process them and callback the caller
                    //
                    PUCHAR Result = (PUCHAR)OutBuffer;
                    ULONG SizeNeeded = 0;
                    ULONG SizeUsed = 0;
                    Wnode = (PWNODE_HEADER)Buffer;


                    do
                    {
                        Linkage = Wnode->Linkage;
                        Wnode->Linkage = 0;

                        if (Wnode->Flags & WNODE_FLAG_INTERNAL)
                        {
                             // If this is the Reply copy it to the buffer
                             PWMI_LOGGER_INFORMATION LoggerInfo;

                             RcvCount++;

                             LoggerInfo = (PWMI_LOGGER_INFORMATION)((PUCHAR)Wnode + sizeof(WNODE_HEADER));
                             SizeNeeded = LoggerInfo->Wnode.BufferSize;

                             if ((SizeUsed + SizeNeeded) <= OutBufferSize) {
                                 memcpy(Result, LoggerInfo, LoggerInfo->Wnode.BufferSize);
                                 Result += SizeNeeded;
                                 SizeUsed += SizeNeeded;
                             }
                             else Status = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        Wnode = (PWNODE_HEADER)OffsetToPtr(Wnode, Linkage);
                     } while (Linkage != 0);
                 }
             }
             WmipFree(Buffer);
         } else {
             Status = ERROR_NOT_ENOUGH_MEMORY;
         }
     }

     return Status;
}
NTSTATUS
WmipTraceUmMessage(
    IN ULONG    Size,
    IN ULONG64  LoggerHandle,
    IN ULONG    MessageFlags,
    IN LPGUID   MessageGuid,
    IN USHORT   MessageNumber,
    va_list     MessageArgList
)
/*++
Routine Description:
Arguments:
Return Value:
--*/
{
    PMESSAGE_TRACE_HEADER Header;
    char * pMessageData ;
    PWMI_BUFFER_HEADER BufferResource = NULL ;
    ULONG SequenceNumber ;
    PWMI_LOGGER_CONTEXT LoggerContext;

    WmipLockLogger();                           // Lock the logger
    if (!WmipIsLoggerOn()) {
        WmipUnlockLogger();
        return STATUS_INVALID_HANDLE;
    }
    LoggerContext = WmipLoggerContext;

    try {
         // Figure the total size of the message including the header
         Size += (MessageFlags&TRACE_MESSAGE_SEQUENCE ? sizeof(ULONG):0) +
                 (MessageFlags&TRACE_MESSAGE_GUID ? sizeof(GUID):0) +
                 (MessageFlags&TRACE_MESSAGE_COMPONENTID ? sizeof(ULONG):0) +
                 (MessageFlags&(TRACE_MESSAGE_TIMESTAMP | TRACE_MESSAGE_PERFORMANCE_TIMESTAMP) ? sizeof(LARGE_INTEGER):0) +
                 (MessageFlags&TRACE_MESSAGE_SYSTEMINFO ? 2 * sizeof(ULONG):0) +
                 sizeof (MESSAGE_TRACE_HEADER) ;

        //
        // Allocate Space in the Trace Buffer
        //
         if (Size > LoggerContext->BufferSize - sizeof(WMI_BUFFER_HEADER)) {
             LoggerContext->EventsLost++;
             WmipUnlockLogger();
             return STATUS_BUFFER_OVERFLOW;
         }

        if ((Header = (PMESSAGE_TRACE_HEADER)WmipReserveTraceBuffer(Size, &BufferResource)) == NULL) {
            WmipUnlockLogger();
            return STATUS_NO_MEMORY;
        }
        //
        // Sequence Number is returned in the Marker field of the buffer
        //
        SequenceNumber = Header->Marker ;

        //
        // Now copy the necessary information into the buffer
        //

        Header->Marker = TRACE_MESSAGE | TRACE_HEADER_FLAG ;
        //
        // Fill in Header.
        //
        Header->Size = (USHORT)(Size & 0xFFFF) ;
        Header->Packet.OptionFlags = ((USHORT)MessageFlags &
                                      (TRACE_MESSAGE_SEQUENCE |
                                      TRACE_MESSAGE_GUID |
                                      TRACE_MESSAGE_COMPONENTID |
                                      TRACE_MESSAGE_TIMESTAMP |
                                      TRACE_MESSAGE_PERFORMANCE_TIMESTAMP |
                                      TRACE_MESSAGE_SYSTEMINFO)) &
                                      TRACE_MESSAGE_FLAG_MASK ;
        // Message Number
        Header->Packet.MessageNumber =  MessageNumber ;

        //
        // Now add in the header options we counted.
        //
        pMessageData = &(((PMESSAGE_TRACE)Header)->Data);


        //
        // Note that the order in which these are added is critical New entries must
        // be added at the end!
        //
        // [First Entry] Sequence Number
        if (MessageFlags&TRACE_MESSAGE_SEQUENCE) {
            RtlCopyMemory(pMessageData, &SequenceNumber, sizeof(ULONG)) ;
            pMessageData += sizeof(ULONG) ;
        }

        // [Second Entry] GUID ? or CompnentID ?
        if (MessageFlags&TRACE_MESSAGE_COMPONENTID) {
            RtlCopyMemory(pMessageData,MessageGuid,sizeof(ULONG)) ;
            pMessageData += sizeof(ULONG) ;
        } else if (MessageFlags&TRACE_MESSAGE_GUID) { // Can't have both
            RtlCopyMemory(pMessageData,MessageGuid,sizeof(GUID));
            pMessageData += sizeof(GUID) ;
        }

        // [Third Entry] Timestamp?
        if (MessageFlags&TRACE_MESSAGE_TIMESTAMP) {
            LARGE_INTEGER Perfcount ;
            if (MessageFlags&TRACE_MESSAGE_PERFORMANCE_TIMESTAMP) {
                LARGE_INTEGER Frequency ;
                NTSTATUS Status ;
                Status = NtQueryPerformanceCounter(&Perfcount, &Frequency);
            } else {
                Perfcount.QuadPart = WmipGetSystemTime();
            };
            RtlCopyMemory(pMessageData,&Perfcount,sizeof(LARGE_INTEGER));
            pMessageData += sizeof(LARGE_INTEGER);
        }


        // [Fourth Entry] System Information?
        if (MessageFlags&TRACE_MESSAGE_SYSTEMINFO) {
            PCLIENT_ID Cid;
            ULONG Id;     // match with NTOS version

            Cid = &NtCurrentTeb()->ClientId;
            *((PULONG)pMessageData) = HandleToUlong(Cid->UniqueThread);
            pMessageData += sizeof(ULONG) ;
            *((PULONG)pMessageData) = HandleToUlong(Cid->UniqueProcess);
            pMessageData += sizeof(ULONG) ;
        }

        //
        // Add New Header Entries immediately before this comment!
        //

        //
        // Now Copy in the Data.
        //
        { // Allocation Block
            va_list ap;
            PCHAR source;
            ap = MessageArgList ;
            while ((source = va_arg (ap, PVOID)) != NULL) {
                size_t elemBytes;
                elemBytes = va_arg (ap, size_t);
                RtlCopyMemory (pMessageData, source, elemBytes);
                pMessageData += elemBytes;
            }
        } // Allocation Block

        //
        // Buffer Complete, Release
        //
        WmipReleaseTraceBuffer( BufferResource );
        WmipUnlockLogger();
        //
        // Return Success
        //
        return (STATUS_SUCCESS);

    } except  (EXCEPTION_EXECUTE_HANDLER) {
        if (BufferResource != NULL) {
               WmipReleaseTraceBuffer ( BufferResource );   // also unlocks the logger
        }
        WmipUnlockLogger();
        return GetExceptionCode();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\drt\tracelog\evntrace\ansi\makefile.inc ===
copyexe:
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\tracelib.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tracelib.c

Abstract:

    Private trace libraries and stubs that allows user-mode to reside in NTDLL.

Author:

    15-Aug-2000 JeePang

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "tracelib.h"

PVOID
WmipMemReserve(
    IN SIZE_T   Size
    )
{
    NTSTATUS Status;
    PVOID    lpAddress = NULL;

    try {
        Status = NtAllocateVirtualMemory(
                    NtCurrentProcess(),
                    &lpAddress,
                    0,
                    &Size,
                    MEM_RESERVE,
                    PAGE_READWRITE);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
    if (NT_SUCCESS(Status)) {
        return lpAddress;
    }
    else {
        WmipSetDosError(WmipNtStatusToDosError(Status));
        return NULL;
    }
}

PVOID
WmipMemCommit(
    IN PVOID Buffer,
    IN SIZE_T Size
    )
{
    NTSTATUS Status;

    try {
        Status = NtAllocateVirtualMemory(
                    NtCurrentProcess(),
                    &Buffer,
                    0,
                    &Size,
                    MEM_COMMIT,
                    PAGE_READWRITE);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
    if (NT_SUCCESS(Status)) {
        return Buffer;
    }
    else {
        WmipSetDosError(WmipNtStatusToDosError(Status));
        return NULL;
    }
}

ULONG
WmipMemFree(
    IN PVOID Buffer
    )
{
    NTSTATUS Status;
    SIZE_T Size = 0;
    HANDLE hProcess = NtCurrentProcess();

    if (Buffer == NULL) {
        WmipSetDosError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    try {
        Status = NtFreeVirtualMemory( hProcess, &Buffer, &Size, MEM_RELEASE);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
    if (NT_SUCCESS(Status)) {
        return TRUE;
    }
    else {
        if (Status == STATUS_INVALID_PAGE_PROTECTION) {
            if (RtlFlushSecureMemoryCache(Buffer, Size)) {
                Status = NtFreeVirtualMemory(
                            hProcess, Buffer, &Size, MEM_RELEASE);
                if (NT_SUCCESS(Status)) {
                    return TRUE;
                }
            }
        }
        WmipSetDosError(WmipNtStatusToDosError(Status));
        return FALSE;
    }
}

HANDLE
WmipCreateFile(
    LPCWSTR     lpFileName,
    DWORD       dwDesiredAccess,
    DWORD       dwShareMode,
    DWORD       dwCreationDisposition,
    DWORD       dwCreateFlags
    )
{
    UNICODE_STRING FileName;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    SECURITY_QUALITY_OF_SERVICE SQos;

    RtlInitUnicodeString(&FileName, lpFileName);
    if (!RtlDosPathNameToNtPathName_U(
                lpFileName,
                &FileName,
                NULL,
                &RelativeName)) {
        WmipSetDosError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
    }
    FreeBuffer = FileName.Buffer;
    if (RelativeName.RelativeName.Length) {
        FileName = *(PUNICODE_STRING) &RelativeName.RelativeName;
    }
    else {
        RelativeName.ContainingDirectory = NULL;
    }
    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL,
        );
    SQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SQos.ImpersonationLevel = SecurityImpersonation;
    SQos.EffectiveOnly = TRUE;
    SQos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    ObjectAttributes.SecurityQualityOfService = &SQos;

    Status = NtCreateFile(
                &FileHandle,
                (ACCESS_MASK) dwDesiredAccess
                    | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &ObjectAttributes,
                &Iosb,
                NULL,
                FILE_ATTRIBUTE_NORMAL
                    & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                dwCreationDisposition,
                dwCreateFlags | FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0);
    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_OBJECT_NAME_COLLISION) {
            WmipSetDosError(ERROR_FILE_EXISTS);
        }
        else {
            WmipSetDosError(WmipNtStatusToDosError(Status));
        }
        FileHandle = INVALID_HANDLE_VALUE;
    }
    if (lpFileName != FreeBuffer && FreeBuffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    }
    return FileHandle;
}

BOOL
WmipSynchReadFile(
    HANDLE LogFile, 
    LPVOID Buffer, 
    DWORD NumberOfBytesToRead, 
    LPDWORD NumberOfBytesRead,
    LPOVERLAPPED Overlapped
    ) 
/*++

Routine Description:
    This routine performs synchronous read on a given file. Since logfile is opened for
    asychronous IO, current file position is not available. Thus, for synch read, we need 
    to use this.

Arguments:
    LogFile - handle to file
    Buffer - data buffer
    NumberOfBytesToRead - number of bytes to read
    NumberOfBytesRead - number of bytes read
    Overlapped - overlapped structure

Returned Value:

    TRUE if succeeded.

--*/
{
    BOOL ReadSuccess;
    if (Overlapped == NULL || Overlapped->hEvent == NULL || Overlapped->hEvent == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    if (!ResetEvent(Overlapped->hEvent)) {
        return FALSE;
    }
    ReadSuccess = ReadFile(LogFile,
                        Buffer,
                        NumberOfBytesToRead,
                        NULL,
                        Overlapped);
    if (ReadSuccess || GetLastError() == ERROR_IO_PENDING) {
        ReadSuccess = GetOverlappedResult(LogFile, Overlapped, NumberOfBytesRead, TRUE);
        if (!ReadSuccess && GetLastError() == ERROR_HANDLE_EOF) {
            *NumberOfBytesRead = 0;
            SetEvent(Overlapped->hEvent);
        }
        return ReadSuccess;
    }
    else {
        *NumberOfBytesRead = 0;
        SetEvent(Overlapped->hEvent);
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\drt\tracelog\evntrace\sources.inc ===
USE_CRTDLL=1

MAJORCOMP=sdktools
MINORCOMP=evntrace

NTTARGETFILES=copyexe

TARGETNAME=evntrace
TARGETTYPE=PROGRAM
TARGETPATH=obj

SOURCES= evntrace.c 

UMTYPE=console
UMAPPL=evntrace

LINKLIBS=$(BASEDIR)\public\sdk\lib\*\user32.lib \
         $(BASEDIR)\public\sdk\lib\*\advapi32.lib 

C_DEFINES=-DWIN32 -DNT -DSDK_CODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\drt\tracelog\evntrace\unicode\makefile.inc ===
copyexe:
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\drt\tracelog\evntrace\evntrace.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    tracelog.c

Abstract:

    Sample trace control program. Allows user to start, stop event tracing

Author:

    Jee Fung Pang (jeepang) 03-Dec-1997

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <tchar.h>
#include <wmistr.h>
#include <initguid.h>
#include <guiddef.h>
#include <evntrace.h>

#define MAXSTR                          1024
#define DEFAULT_LOGFILE_NAME            _T("C:\\LogFile.Evm")
#define NT_LOGGER                       _T("NT Kernel Logger")
#define MAXIMUM_LOGGERS                 16
#define MAXGUIDS                        128

#define ACTION_QUERY                    0
#define ACTION_START                    1
#define ACTION_STOP                     2
#define ACTION_UPDATE                   3
#define ACTION_LIST			4
#define ACTION_ENABLE                   5

#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))

void
SplitCommandLine( 
    LPTSTR CommandLine, 
    LPTSTR* pArgv 
    );

void
PrintLoggerStatus(
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
    IN ULONG Status
    );

LPTSTR
DecodeStatus(
    IN ULONG Status
    );

ULONG
GetGuids(LPTSTR GuidFile, LPGUID *GuidArray);

void   StringToGuid(TCHAR *str, LPGUID guid);

ULONG ahextoi(TCHAR *s);

TCHAR ErrorMsg[MAXSTR];

FILE  *fp;

int __cdecl _tmain(int argc, _TCHAR ** argv)
{
    ULONG GuidCount, i, j;
    USHORT Action = 0;
    ULONG Status = 0;
    LPTSTR LoggerName;
    LPTSTR LogFileName;
    TCHAR GuidFile[MAXSTR];
    PEVENT_TRACE_PROPERTIES pLoggerInfo;
    TRACEHANDLE LoggerHandle = 0;
    LPTSTR *commandLine;
    LPTSTR *targv;
    int targc;
    LPGUID *GuidArray;
    char *Space;
    char *save;
    BOOL bKill = FALSE;
    BOOL bEnable = TRUE;
    ULONG iLevel = 0;
    ULONG iFlags = 0;
    ULONG SizeNeeded = 0;



    // Very important!!!
    // Initialize structure first
    //
    SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + 2 * MAXSTR * sizeof(TCHAR);
    pLoggerInfo = (PEVENT_TRACE_PROPERTIES) malloc(SizeNeeded);
    if (pLoggerInfo == NULL) {
        exit(ERROR_OUTOFMEMORY);
    }


    fp = _tfopen(_T("evntrace.log"), _T("a+"));
    if (fp == NULL) {
        _tprintf(_T("evntrace.log file open failed. quit!\n"));
        return (1);
    }

    _ftprintf(fp, _T("\n----------Start evntrace.exe--------\n\n"));
    _tprintf(_T("\n----------Start evntrace.exe--------\n\n"));
#ifdef DEBUG
    for(i=0; i<(ULONG)argc; i++) {
        _tprintf(_T("argv[%d]=%s\n"), i, argv[i]);
        _ftprintf(fp, _T("argv[%d]=%s\n"), i, argv[i]);
    }
    _tprintf(_T("\n"));
    _ftprintf(fp, _T("\n"));
#endif
    

    RtlZeroMemory(pLoggerInfo, SizeNeeded);

    pLoggerInfo->Wnode.BufferSize = SizeNeeded;
    pLoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
    pLoggerInfo->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    pLoggerInfo->LogFileNameOffset = pLoggerInfo->LoggerNameOffset 
                                     + MAXSTR * sizeof(TCHAR);

    LoggerName = (LPTSTR)((char*)pLoggerInfo + pLoggerInfo->LoggerNameOffset);
    LogFileName = (LPTSTR)((char*)pLoggerInfo + pLoggerInfo->LogFileNameOffset);
    _tcscpy(LoggerName, NT_LOGGER);

    Space = (char*) malloc( (MAXGUIDS * sizeof(GuidArray)) +
                            (MAXGUIDS * sizeof(GUID) ));
    if (Space == NULL) {
        free(pLoggerInfo);
        exit(ERROR_OUTOFMEMORY);
    }
    save = Space;
    GuidArray = (LPGUID *) Space;
    Space += MAXGUIDS * sizeof(GuidArray);

    for (GuidCount=0; GuidCount<MAXGUIDS; GuidCount++) {
        GuidArray[GuidCount] = (LPGUID) Space;
        Space += sizeof(GUID);
    }
    GuidCount = 0;

    targc = argc;
    commandLine = (LPTSTR*)malloc( argc * sizeof(LPTSTR) );
    if (commandLine == NULL) {
        free(Space);
        free(pLoggerInfo);
        exit(ERROR_OUTOFMEMORY);
    }
    for(i=0;i<(ULONG)argc;i++){
        commandLine[i] = (LPTSTR)malloc(MAXSTR * sizeof(TCHAR));
        if (commandLine[i] == NULL) {
            for (j=0; j < i; j++)
                free(commandLine[j]);
            free(commandLine);
            free(pLoggerInfo);
            free(Space);
        }
    }
    
    SplitCommandLine( GetCommandLine(), commandLine );
    targv = commandLine;

    //
    // Add default flags. Should consider options to control this independently
    //
    while (--argc > 0) {
        ++targv;
        if (**targv == '-' || **targv == '/') {  // argument found
            if(targv[0][0] == '/' ) targv[0][0] = '-';
            if (!_tcsicmp(targv[0], _T("-start"))) {
                Action = ACTION_START;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-enable"))) {
                Action = ACTION_ENABLE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-disable"))) {
                Action = ACTION_ENABLE;
                bEnable = FALSE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-stop"))) {
                Action = ACTION_STOP;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-update"))) {
                Action = ACTION_UPDATE;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-q"))) {
                Action = ACTION_QUERY;
                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        ++targv; --argc;
                        _tcscpy(LoggerName, targv[0]);
                    }
                }
            }
            else if (!_tcsicmp(targv[0], _T("-f"))) {
                if (argc > 1) {
                    _tfullpath(LogFileName, targv[1], MAXSTR);
                    ++targv; --argc;

                    _ftprintf(fp, _T("Setting log file to:    '%s'\n"), 
                              LogFileName);
                    _tprintf(_T("Setting log file to: %s\n"), LogFileName);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-guid"))) {

                if (argc > 1) {
                    if (targv[1][0] != '-' && targv[1][0] != '/') {
                        StringToGuid(targv[1], GuidArray[0]);
                        ++targv; --argc;
                        GuidCount=1;
                    }
                }

            }
            else if (!_tcsicmp(targv[0], _T("-seq"))) {
                if (argc > 1) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_SEQUENTIAL;
                    pLoggerInfo->MaximumFileSize = _ttoi(targv[1]);
                    ++targv; --argc;
                    _ftprintf(fp, _T("Setting maximum sequential logfile size to: %d Mbytes\n"), pLoggerInfo->MaximumFileSize);
                    _tprintf(_T("Setting maximum sequential logfile size to: %d\n"),
                        pLoggerInfo->MaximumFileSize);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-cir"))) {
                if (argc > 1) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_FILE_MODE_CIRCULAR;
                    pLoggerInfo->MaximumFileSize = _ttoi(targv[1]);
                    ++targv; --argc;
                    _ftprintf(fp, _T("Setting maximum circular logfile size to: %d Mbytes\n"), pLoggerInfo->MaximumFileSize);
                    _tprintf(_T("Setting maximum circular logfile size to: %d\n"),
                        pLoggerInfo->MaximumFileSize);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-b"))) {
                if (argc > 1) {
                    pLoggerInfo->BufferSize = _ttoi(targv[1]);
                    ++targv; --argc;
                    _ftprintf(fp, _T("Changing buffer size to %d\n"), pLoggerInfo->BufferSize);
                    _tprintf(_T("Changing buffer size to %d\n"),
                        pLoggerInfo->BufferSize);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-flag"))) {
                if (argc > 1) {
                    pLoggerInfo->EnableFlags |= _ttoi(targv[1]);
                    ++targv; --argc;
                    _tprintf(_T("Setting logger flags to %d\n"),
                        pLoggerInfo->EnableFlags );
                }
            }
            else if (!_tcsicmp(targv[0], _T("-min"))) {
                if (argc > 1) {
                    pLoggerInfo->MinimumBuffers = _ttoi(targv[1]);
                    ++targv; --argc;
                    _ftprintf(fp, _T("Changing Minimum Number of Buffers to %d\n "), pLoggerInfo->MinimumBuffers);
                    _tprintf(_T("Changing Minimum Number of Buffers to %d\n"),
                        pLoggerInfo->MinimumBuffers);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-max"))) {
                if (argc > 1) {
                    pLoggerInfo->MaximumBuffers = _ttoi(targv[1]);
                    ++targv; --argc;
                    _ftprintf(fp, _T("Changing Maximum Number of Buffers to %d\n "),pLoggerInfo->MaximumBuffers);
                    _tprintf(_T("Changing Maximum Number of Buffers to %d\n"),
                        pLoggerInfo->MaximumBuffers);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-level"))) {
                if (argc > 1) {
                    iLevel = _ttoi(targv[1]);
                    ++targv; --argc;
                    _tprintf(_T("Setting tracing level to %d\n"), iLevel);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-flags"))) {
                if (argc > 1) {
                    iFlags = _ttoi(targv[1]);
                    ++targv; --argc;
                    _tprintf(_T("Setting command to %d\n"), iFlags);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-ft"))) {
                if (argc > 1) {
                    pLoggerInfo->FlushTimer = _ttoi(targv[1]);
                    ++targv; --argc;
                    _tprintf(_T("Setting buffer flush timer to %d seconds\n"),
                        pLoggerInfo->FlushTimer);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-um"))) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_PRIVATE_LOGGER_MODE;
                    _ftprintf(fp, _T("Setting Private Logger Flags\n"));
                    _tprintf(_T("Setting Private Logger Flags\n"));
            }
            else if (!_tcsicmp(targv[0], _T("-rt"))) {
                    pLoggerInfo->LogFileMode |= EVENT_TRACE_REAL_TIME_MODE;
                _ftprintf(fp, _T("Setting real time mode\n"));
                _tprintf(_T("Setting real time mode\n"));
               if (argc > 1) {
                   if (targv[1][0] != '-' && targv[1][0] != '/') {
                       ++targv; --argc;
                       if (targv[1][0] == 'b')
                           pLoggerInfo->LogFileMode |= EVENT_TRACE_BUFFERING_MODE;
                   }
               }
            }
            else if (!_tcsicmp(targv[0], _T("-age"))) {
                if (argc > 1) {
                    pLoggerInfo->AgeLimit = _ttoi(targv[1]);
                    ++targv; --argc;
                    _tprintf(_T("Changing Aging Decay Time to %d\n"),
                        pLoggerInfo->AgeLimit);
                }
            }
            else if (!_tcsicmp(targv[0], _T("-l"))) {
        		Action = ACTION_LIST;
            }
            else if (!_tcsicmp(targv[0], _T("-x"))) {
        		Action = ACTION_LIST;
        		bKill = TRUE;
            }
            else if (!_tcsicmp(targv[0], _T("-fio"))) {
                pLoggerInfo->EnableFlags |= EVENT_TRACE_FLAG_DISK_FILE_IO;
            }
            else if (!_tcsicmp(targv[0], _T("-pf"))) {
                pLoggerInfo->EnableFlags |= EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS;
            }
            else if (!_tcsicmp(targv[0], _T("-hf"))) {
                pLoggerInfo->EnableFlags |= EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS;
            }
            else if (!_tcsicmp(targv[0], _T("-img"))) {
                pLoggerInfo->EnableFlags |= EVENT_TRACE_FLAG_IMAGE_LOAD;
            }
            else if ( targv[0][1] == 'h' || targv[0][1] == 'H' || targv[0][1] == '?'){

                _tprintf( 
                    _T("Usage: tracelog [options] | [-h | -help | -?]\n")
                    _T("\t-start     Starts up a trace session\n")
                    _T("\t-stop      Stops a trace session\n")
                    _T("\t-update    Updates a trace session\n")
                    _T("\t-b   <n>   Sets buffer size to <n> Kbytes\n")
                    _T("\t-min <n>   Sets minimum buffers\n")
                    _T("\t-max <n>   Sets maximum buffers\n")
                    _T("\t-x         Stops all active trace sessions\n")
                    _T("\t-q         Queries the status of trace session\n")
                    _T("\t-f name    Log to file <name>\n")
                    _T("\t-seq [n]   Sequential logfile of up to n Mbytes\n")
                    _T("\t-cir n     Circular logfile of n Mbytes\n")
                    _T("\t-nf  n     Sequentially to new file every n Mb\n")
                    _T("\t-ft n      Set flush timer to n seconds\n")
                    _T("\t-fio       Enable file I/O tracing\n")
                    _T("\t-pf        Enable page faults tracing\n")
                    _T("\t-hf        Enable hard faults tracing\n")
                    _T("\t-img       Enable image load tracing\n")
                    _T("\t-um        Enable Process Private tracing\n")
                    _T("\t-guid <file> Start tracing for providers in file\n")
                    _T("\t-rt [b]    Enable tracing in real time mode\n")
                    _T("\t-age n     Modify aging decay time\n")
                    _T("\t-level n\n")
                    _T("\t-flags n\n")
                    _T("\t-h\n")
                    _T("\t-help\n")
                    _T("\t-?         Prints this information\n")
                    _T("NOTE: The default with no options is -q\n") 
                    );

                return 0;
            }
            else Action = 0;
        }
        else { // get here if "-" or "/" given
            _tprintf(_T("Invalid option given: %s\n"), targv[0]);
            return 0;
        }
    }
    if (!_tcscmp(LoggerName, NT_LOGGER)) {
        pLoggerInfo->EnableFlags |= (EVENT_TRACE_FLAG_PROCESS |
                                   EVENT_TRACE_FLAG_THREAD |
                                   EVENT_TRACE_FLAG_DISK_IO |
                                   EVENT_TRACE_FLAG_NETWORK_TCPIP);
        pLoggerInfo->Wnode.Guid = SystemTraceControlGuid;   // default to OS tracing
    }

    if ( !(pLoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) ) {
        if ( _tcslen(LogFileName) <= 0   && 
             ((Action == ACTION_START) || (Action == ACTION_UPDATE))) {
            _tcscpy(LogFileName, DEFAULT_LOGFILE_NAME); // for now...
        }
    }

    switch (Action) {
        case  ACTION_START:
           if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
               if (GuidCount != 1) {
                    _ftprintf(fp, _T("Need exactly one GUID for PRIVATE loggers\n"));
                   _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                   return 0;
               }
               pLoggerInfo->Wnode.Guid = *GuidArray[0];
           }

            Status = StartTrace(&LoggerHandle, LoggerName, pLoggerInfo);

            if (Status != ERROR_SUCCESS) {
                _ftprintf(fp, _T("Could not start logger: %s\nOperation Status = %uL, %s"), LoggerName, Status, DecodeStatus(Status));
                _tprintf(_T("Could not start logger: %s\n") 
                         _T("Operation Status:       %uL\n")
                         _T("%s\n"),
                         LoggerName,
                         Status,
                         DecodeStatus(Status));

                return Status;
            }
            _ftprintf(fp, _T("Logger %s Started...\n"), LoggerName);
            _tprintf(_T("Logger Started...\n"));


        case ACTION_ENABLE:

            if (Action == ACTION_ENABLE) {
                if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
                {
                    if (GuidCount != 1) {
                       _ftprintf(fp, _T("Need exactly one GUID for PRIVATE loggers\n"));
                        _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                        return 0;
                    }
                    pLoggerInfo->Wnode.Guid = *GuidArray[0];
                }
                Status = QueryTrace( (TRACEHANDLE)0, LoggerName, pLoggerInfo );
                if (Status != ERROR_SUCCESS) {
                    _ftprintf(fp,
                              _T("ERROR: Logger %s not started\nOperation Status= %d, %s"),
                              LoggerName,
                              Status,
                              DecodeStatus(Status));
                    _tprintf( _T("ERROR: Logger not started\n")
                              _T("Operation Status:    %uL\n")
                              _T("%s\n"),
                              Status,
                              DecodeStatus(Status));
                    exit(0);
                }
                LoggerHandle = pLoggerInfo->Wnode.HistoricalContext;
            }

            if ((GuidCount > 0) && 
                (!IsEqualGUID(&pLoggerInfo->Wnode.Guid, &SystemTraceControlGuid)))
            {

                _ftprintf(fp, _T("Enabling trace to logger %d\n"), LoggerHandle);
                _tprintf(_T("Enabling trace to logger %d\n"), LoggerHandle);
                for (i = 0; i < GuidCount; i ++) {
                    Status = EnableTrace (
                                    bEnable,
                                    iFlags,
                                    iLevel,
                                    GuidArray[i], 
                                    LoggerHandle);
                    if (Status != ERROR_SUCCESS && Status != 4317) {
                        _ftprintf(fp, _T("ERROR: Failed to enable Guid [%d]...\n Operation Status= %d, %s"), i, Status, DecodeStatus(Status));
                        _tprintf(_T("ERROR: Failed to enable Guid [%d]...\n"), i);
                        _tprintf(_T("Operation Status:       %uL\n"), Status);
                        _tprintf(_T("%s\n"),DecodeStatus(Status));
                        return Status;
                    }
                }
            }
            else {
                if (GuidCount > 0)
                _ftprintf(fp, _T("ERROR: System Logger does not accept application guids...GuidCount=%d\n"), GuidCount);
                    _tprintf(_T("ERROR: System Logger does not accept application guids...\n"));
            }
            break;

        case ACTION_STOP :

            if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
                if (GuidCount != 1) {
                    _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                    return 0;
                }
                pLoggerInfo->Wnode.Guid = *GuidArray[0];
            }

            if (!IsEqualGUID(&pLoggerInfo->Wnode.Guid, &SystemTraceControlGuid)) {
                if ((pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)) {
                    Status = QueryTrace(
                            (TRACEHANDLE) 0, LoggerName, pLoggerInfo);
                    LoggerHandle = pLoggerInfo->Wnode.HistoricalContext;
                    Status = EnableTrace( FALSE,
                                          EVENT_TRACE_PRIVATE_LOGGER_MODE,
                                          0,
                                          GuidArray[0],
                                          LoggerHandle );
                }
                else {
                    Status = QueryTrace( (TRACEHANDLE)0, LoggerName, pLoggerInfo );
                    LoggerHandle = pLoggerInfo->Wnode.HistoricalContext;

                    for (i=0; i<GuidCount; i++) {
                        Status = EnableTrace( FALSE,
                                              0,
                                              0,
                                              GuidArray[i],
                                              LoggerHandle);
                    }

                }
            }

            Status = StopTrace((TRACEHANDLE)0, LoggerName, pLoggerInfo);
            break;

        case ACTION_UPDATE :
        case ACTION_QUERY:
            if (pLoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
                if (GuidCount != 1) {
                    _tprintf(_T("Need exactly one GUID for PRIVATE loggers\n"));
                    return 0;
                }
                pLoggerInfo->Wnode.Guid = *GuidArray[0];
            }
            if (Action == ACTION_UPDATE)
                Status = UpdateTrace(LoggerHandle, LoggerName, pLoggerInfo);
            else
                Status = QueryTrace(LoggerHandle, LoggerName, pLoggerInfo);

            break;
        case ACTION_LIST :
        {
            ULONG i, returnCount ;
            ULONG SizeNeeded;
            PEVENT_TRACE_PROPERTIES pLoggerInfo[MAXIMUM_LOGGERS];
            PEVENT_TRACE_PROPERTIES pStorage;
            PVOID Storage;

            SizeNeeded = MAXIMUM_LOGGERS * (sizeof(EVENT_TRACE_PROPERTIES)
                                          + 2 * MAXSTR * sizeof(TCHAR));

            Storage =  malloc(SizeNeeded);
            if (Storage == NULL)
                return ERROR_OUTOFMEMORY;
            RtlZeroMemory(Storage, SizeNeeded);

            pStorage = (PEVENT_TRACE_PROPERTIES)Storage;
            for (i=0; i<MAXIMUM_LOGGERS; i++) {
                pStorage->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES)
                                             + 2 * MAXSTR * sizeof(TCHAR);
                pStorage->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES)
                                            + MAXSTR * sizeof(TCHAR);
                pStorage->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
                pLoggerInfo[i] = pStorage;
                pStorage = (PEVENT_TRACE_PROPERTIES) (
                                     (char*)pStorage +
                                      pStorage->Wnode.BufferSize);
            }

            Status = QueryAllTraces(pLoggerInfo,
                                    MAXIMUM_LOGGERS,
                                    & returnCount);

            if (Status == ERROR_SUCCESS)
            {
                for (j= 0; j < returnCount; j++)
                {
                    if (bKill)
                    {
                        LPTSTR LoggerName;
                        LoggerName = (LPTSTR) ((char*)pLoggerInfo[j] +
                                      pLoggerInfo[j]->LoggerNameOffset);

                        if (!IsEqualGUID(& pLoggerInfo[j]->Wnode.Guid,
                                         & SystemTraceControlGuid))
                        {
                            LoggerHandle = pLoggerInfo[j]->Wnode.HistoricalContext;
                            Status = EnableTrace(
                                          FALSE,
                                          (pLoggerInfo[j]->LogFileMode &
                                              EVENT_TRACE_PRIVATE_LOGGER_MODE)
                                          ? (EVENT_TRACE_PRIVATE_LOGGER_MODE)
                                          : (0),
                                          0,
                                          & pLoggerInfo[j]->Wnode.Guid,
                                          LoggerHandle);
                        }
                        Status = StopTrace((TRACEHANDLE) 0,
                                            LoggerName,
                                            pLoggerInfo[j]);
                    }
                    PrintLoggerStatus(pLoggerInfo[j], Status);
                }
            }
            else
                printf("Error: Query failed with Status %d\n", Status);

            i = 0;
            free(Storage);

            return 0;
        }
        default :
            Status = QueryTrace(LoggerHandle, LoggerName, pLoggerInfo);
            break;
    }
    PrintLoggerStatus(pLoggerInfo, Status);


    for(i=0;i<(ULONG)targc;i++){
        free(commandLine[i]);
    }
    free(commandLine);
    free(pLoggerInfo);
    free(save);
    _ftprintf(fp, _T("\nEnd evntrace.exe, status = %d, %s\n"), Status, DecodeStatus(Status));
    fclose(fp);

    exit(Status);
}

void
SplitCommandLine( LPTSTR CommandLine, LPTSTR* pArgv )
{

    LPTSTR arg;
    int i = 0;
    arg = _tcstok( CommandLine, _T(" \t"));
    while( arg != NULL ){
        _tcscpy(pArgv[i++], arg); 
        arg = _tcstok(NULL, _T(" \t"));
    }
}


void
PrintLoggerStatus(
    IN PEVENT_TRACE_PROPERTIES LoggerInfo,
    IN ULONG Status
    )
{
    LPTSTR LoggerName, LogFileName;
    
    if ((LoggerInfo->LoggerNameOffset > 0) &&
        (LoggerInfo->LoggerNameOffset  < LoggerInfo->Wnode.BufferSize)) {
        LoggerName = (LPTSTR) ((char*)LoggerInfo +
                                LoggerInfo->LoggerNameOffset);
    }
    else LoggerName = NULL;

    if ((LoggerInfo->LogFileNameOffset > 0) &&
        (LoggerInfo->LogFileNameOffset  < LoggerInfo->Wnode.BufferSize)) {
        LogFileName = (LPTSTR) ((char*)LoggerInfo +
                                LoggerInfo->LogFileNameOffset);
    }
    else LogFileName = NULL;


    //write to log file
    _ftprintf(fp, _T("Operation Status:       %uL, %s"), Status, DecodeStatus(Status));
    _ftprintf(fp, _T("Logger Name:            %s\n"),
        (LoggerName == NULL) ?
            _T(" ") : LoggerName);
    _ftprintf(fp, _T("Logger Id:              %d\n"), LoggerInfo->Wnode.Linkage);
    _ftprintf(fp, _T("Logger Thread Id:       %d\n"), LoggerInfo->Wnode.ProviderId);
    if (Status != 0)
    {
        _ftprintf(fp, _T("Logger status error: check messages above\n"));
        return;
    }

    _ftprintf(fp, _T("Buffer Size:            %d Kb\n"), LoggerInfo->BufferSize);
    _ftprintf(fp, _T("Maximum Buffers:        %d\n"), LoggerInfo->MaximumBuffers);
    _ftprintf(fp, _T("Minimum Buffers:        %d\n"), LoggerInfo->MinimumBuffers);
    _ftprintf(fp, _T("Number of Buffers:      %d\n"), LoggerInfo->NumberOfBuffers);
    _ftprintf(fp, _T("Free Buffers:           %d\n"), LoggerInfo->FreeBuffers);
    _ftprintf(fp, _T("Buffers Written:        %d\n"), LoggerInfo->BuffersWritten );
    _ftprintf(fp, _T("Events Lost:            %d\n"), LoggerInfo->EventsLost);
    _ftprintf(fp, _T("Log Buffers Lost:       %d\n"), LoggerInfo->LogBuffersLost );
    _ftprintf(fp, _T("Real Time Buffers Lost: %d\n"), LoggerInfo->RealTimeBuffersLost);

    if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
        _ftprintf(fp, _T("Log File Mode:          Circular\n"));
    }
    else if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
        _ftprintf(fp, _T("Log File Mode:          Sequential\n"));
    }
    else {
        _ftprintf(fp, _T("Log File Mode:          \n"));
    }
    if (LoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
        _ftprintf(fp, _T("Real Time mode enabled\n"));
    }

    if (LoggerInfo->MaximumFileSize > 0)
        _ftprintf(fp, _T("Maximum File Size:      %d Mb\n"), LoggerInfo->MaximumFileSize);

    if (LoggerInfo->FlushTimer > 0)
        _ftprintf(fp, _T("Buffer Flush Timer:     %d secs\n"), LoggerInfo->FlushTimer);

    if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_PROCESS)
        _ftprintf(fp, _T("Enabled tracing:        Process\n"));
    if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_THREAD)
        _ftprintf(fp, _T("Enabled tracing:        Thread\n"));
    if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
        _ftprintf(fp, _T("Enabled tracing:        ImageLoad\n"));
    if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
        _ftprintf(fp, _T("Enabled tracing:        Disk\n"));
    if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
        _ftprintf(fp, _T("Enabled tracing:        File\n"));
    if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
        _ftprintf(fp, _T("Enabled tracing:        SoftFaults\n"));
    if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
        _ftprintf(fp, _T("Enabled tracing:        HardFaults\n"));
    if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
        _ftprintf(fp, _T("Enabled tracing:        TcpIp\n"));

    _ftprintf(fp, _T("EnableFlags:            0x%08x\n"), LoggerInfo->EnableFlags);

    _ftprintf(fp, _T("Log Filename:           %s\n"),
          (LogFileName == NULL) ?
           _T(" ") : LogFileName);

    _tprintf(_T("Operation Status:       %uL\n"), Status);
    _tprintf(_T("%s\n"), DecodeStatus(Status));

    _tprintf(_T("Logger Name:            %s\n"),
        (LoggerName == NULL) ?
            _T(" ") : LoggerName);
    _tprintf(_T("Logger Id:         %I64x\n"), LoggerInfo->Wnode.HistoricalContext);
    _tprintf(_T("Logger Thread Id:       %d\n"), HandleToUlong(LoggerInfo->LoggerThreadId));
    if (Status != 0)
        return;

    _tprintf(_T("Buffer Size:            %d Kb\n"), LoggerInfo->BufferSize);
    _tprintf(_T("Maximum Buffers:        %d\n"), LoggerInfo->MaximumBuffers);
    _tprintf(_T("Minimum Buffers:        %d\n"), LoggerInfo->MinimumBuffers);
    _tprintf(_T("Number of Buffers:      %d\n"), LoggerInfo->NumberOfBuffers);
    _tprintf(_T("Free Buffers:           %d\n"), LoggerInfo->FreeBuffers);
    _tprintf(_T("Buffers Written:        %d\n"), LoggerInfo->BuffersWritten);
    _tprintf(_T("Events Lost:            %d\n"), LoggerInfo->EventsLost);
    _tprintf(_T("Log Buffers Lost:       %d\n"), LoggerInfo->LogBuffersLost);
    _tprintf(_T("Real Time Buffers Lost: %d\n"), LoggerInfo->RealTimeBuffersLost);

    _tprintf(_T("Log File Mode:          "));
    if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
        _tprintf(_T("Circular\n"));
    }
    else if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
        _tprintf(_T("Sequential\n"));
    }
    else {
        _tprintf(_T("\n"));
    }
    if (LoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
        _tprintf(_T("Real Time mode enabled\n"));
    }

    if (LoggerInfo->MaximumFileSize > 0)
        _tprintf(_T("Maximum File Size:      %d Mb\n"), LoggerInfo->MaximumFileSize);

    if (LoggerInfo->FlushTimer > 0)
        _tprintf(_T("Buffer Flush Timer:     %d secs\n"), LoggerInfo->FlushTimer);

    if (LoggerInfo->EnableFlags != 0) {
        _tprintf(_T("Enabled tracing:        "));

        if ((LoggerName != NULL) && (!_tcscmp(LoggerName,NT_LOGGER))) {

            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_PROCESS)
                _tprintf(_T("Process "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_THREAD)
                _tprintf(_T("Thread "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_IO)
                _tprintf(_T("Disk "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
                _tprintf(_T("File "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS)
                _tprintf(_T("PageFaults "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS)
                _tprintf(_T("HardFaults "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD)
                _tprintf(_T("ImageLoad "));
            if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP)
                _tprintf(_T("TcpIp "));
        }else{
            _tprintf(_T("0x%08x"), LoggerInfo->EnableFlags );
        }
        _tprintf(_T("\n"));
    }
    _tprintf(_T("Log Filename:           %s\n"),
          (LogFileName == NULL) ?
              _T(" ") : LogFileName);

}

LPTSTR
DecodeStatus(
    IN ULONG Status
    )
{
    memset( ErrorMsg, 0, MAXSTR );
    FormatMessage(     
        FORMAT_MESSAGE_FROM_SYSTEM |     
        FORMAT_MESSAGE_IGNORE_INSERTS,    
        NULL,
        Status,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) ErrorMsg,
        MAXSTR,
        NULL );

    return ErrorMsg;
}

ULONG
GetGuids(LPTSTR GuidFile, LPGUID *GuidArray)
{
    FILE *f;
    TCHAR line[MAXSTR], arg[MAXSTR];
    LPGUID Guid;
    int i, n;

    f = _tfopen((TCHAR*)GuidFile, _T("r"));

    if (f == NULL)
        return 0;

    n = 0;
    while ( _fgetts(line, MAXSTR, f) != NULL ) {
        if (_tcslen(line) < 36)
            continue;
        if (line[0] == ';'  || 
            line[0] == '\0' || 
            line[0] == '#' || 
            line[0] == '/')
            continue;
        Guid = (LPGUID) GuidArray[n];
        n ++;

        _tcsncpy(arg, line, 8);
        arg[8] = 0;
        Guid->Data1 = ahextoi(arg);
        _tcsncpy(arg, &line[9], 4);
        arg[4] = 0;
        Guid->Data2 = (USHORT) ahextoi(arg);
        _tcsncpy(arg, &line[14], 4);
        arg[4] = 0;
        Guid->Data3 = (USHORT) ahextoi(arg);

        for (i=0; i<2; i++) {
            _tcsncpy(arg, &line[19 + (i*2)], 2);
            arg[2] = 0;
            Guid->Data4[i] = (UCHAR) ahextoi(arg);
        }
        for (i=2; i<8; i++) {
            _tcsncpy(arg, &line[20 + (i*2)], 2);
            arg[2] = 0;
            Guid->Data4[i] = (UCHAR) ahextoi(arg);
        }
    }
    return (ULONG)n;
}

ULONG ahextoi(TCHAR *s)
{
    int len;
    ULONG num, base, hex;

    len = _tcslen(s);
    hex = 0; base = 1; num = 0;
    while (--len >= 0) {
        if ( (s[len] == 'x' || s[len] == 'X') &&
             (s[len-1] == '0') )
            break;
        if (s[len] >= '0' && s[len] <= '9')
            num = s[len] - '0';
        else if (s[len] >= 'a' && s[len] <= 'f')
            num = (s[len] - 'a') + 10;
        else if (s[len] >= 'A' && s[len] <= 'F')
            num = (s[len] - 'A') + 10;
        else 
            continue;

        hex += num * base;
        base = base * 16;
    }
    return hex;
}

void StringToGuid(TCHAR *str, LPGUID guid)
{
    TCHAR temp[10];
    int i, n;

    temp[8]=_T('\0');
    _tcsncpy(temp, str, 8);
    _stscanf(temp, _T("%x"), &(guid->Data1));

    temp[4]=_T('\0');
    _tcsncpy(temp, &str[9], 4);
    _stscanf(temp, _T("%x"), &(guid->Data2));

    _tcsncpy(temp, &str[14], 4);
    _stscanf(temp, _T("%x"), &(guid->Data3));

    temp[2]='\0';
    for(i=0;i<8;i++)
    {
        temp[0]=str[19+((i<2)?2*i:2*i+1)]; // to accomodate the minus sign after
        temp[1]=str[20+((i<2)?2*i:2*i+1)]; // the first two chars
        _stscanf(temp, _T("%x"), &n);      // if directly used more than byte alloc
        guid->Data4[i]=(unsigned char)n;                  // causes overrun of memory
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\drt\tracelog\provider\ansi\makefile.inc ===
copyexe:
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\drt\tracelog\provider\unicode\makefile.inc ===
copyexe:
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\drt\tracelog\provider\sources.inc ===
USE_CRTDLL=1

MAJORCOMP=sdktools
MINORCOMP=provider

#NTTARGETFILES=copyexe

TARGETNAME=provider
TARGETTYPE=PROGRAM
TARGETPATH=obj

SOURCES=provider.c provider.rc provider.mof

UMTYPE=console
UMAPPL=provider

LINKLIBS=$(BASEDIR)\public\sdk\lib\*\user32.lib \
         $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib  \
         $(BASEDIR)\public\sdk\lib\*\advapi32.lib 

C_DEFINES=-DWIN32 -DNT -DSDK_CODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\enumgdlg.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

--*/

// EnumGuidDlg.cpp : implementation file
//

#include "stdafx.h"
#include "EnumGuid.h"
#include "EnumGDlg.h"

#pragma warning (once : 4200)
#include <wmium.h>

#include "DspDataDlg.h"
#include "SelName.h"
#include "SelData.h"
#include "SelDataM.h"
#include "wmihlp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

#define MAX_DATA 200

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEnumGuidDlg dialog

CEnumGuidDlg::CEnumGuidDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CEnumGuidDlg::IDD, pParent), guids(0)
{
	//{{AFX_DATA_INIT(CEnumGuidDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

CEnumGuidDlg::~CEnumGuidDlg()
{
    if (guids)
        delete[] guids;
}

void CEnumGuidDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEnumGuidDlg)
	DDX_Control(pDX, IDC_GUID_LIST, guidList);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CEnumGuidDlg, CDialog)
	//{{AFX_MSG_MAP(CEnumGuidDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_QUERY_FULL, OnQueryFull)
	ON_BN_CLICKED(IDC_QUERY_SINGLE, OnQuerySingle)
	ON_BN_CLICKED(IDC_SET_SINGLE_INSTANCE, OnSetSingleInstance)
	ON_BN_CLICKED(IDC_SET_SINGLE_ITEM, OnSetSingleItem)
	ON_BN_CLICKED(IDC_REENUMERATE_GUIDS, OnReenumerateGuids)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEnumGuidDlg message handlers

BOOL CEnumGuidDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
    OnReenumerateGuids();

	return TRUE;  
}

void CEnumGuidDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CEnumGuidDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CEnumGuidDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

int CEnumGuidDlg::EnumerateGuids()
{
    GUID  guid;
	DWORD ret;
    CString msg;

	if (guids)
		delete[] guids;

	guidsCount = 0;

	//
	//  Determine the present number of guids registered
	//
	ret = WmiEnumerateGuids(&guid,
						    &guidsCount);

	if (ret != ERROR_MORE_DATA) {
        msg.Format(_T("Call to determine number of Guids failed. (%u)\n"), ret);
        MessageBox(msg);
        return (0);
	}


	//  Return if there are no guids registered
	//
	if (guidsCount != 0) {

		//  Allocate buffer for Guids.  Note:  we will allocate room for
		//  and extra 10 Guids in case new Guids were registed between the
		//  previous call to WMIMofEnumeratGuid, and the next call.
		//
		guidsCount += 10;
		guids = new GUID[guidsCount];
		if (!guids) {
			MessageBox(_T("Out of Memory Failure.  Unable to allocate memory for guid list array\n"));
			return (0);
		}


		//  Get the list of Guids
		//
		ret = WmiEnumerateGuids(guids,
							    &guidsCount);
		if ((ret != ERROR_SUCCESS) && (ret != ERROR_MORE_DATA)) {
			msg.Format(_T("Failure to get guid list. (%u)\n"), ret);
            MessageBox(msg);
			return (0);
		}
	}

	return guidsCount;
}

void CEnumGuidDlg::ListGuids()
{
	CString line;
	DWORD tmp1, tmp2, tmp3, tmp4, tmp5;

	for (ULONG i = 0; i < guidsCount; i++) {
		line.Empty();

		tmp1  = guids[i].Data2;
		tmp2 = guids[i].Data3;
		tmp3 = guids[i].Data4[0] << 8 | guids[i].Data4[1];
		tmp4 = guids[i].Data4[2] << 8 | guids[i].Data4[3];
        memcpy(&tmp5, &guids[i].Data4[4],  sizeof(DWORD));
        tmp5 = guids[i].Data4[4] << 24 | 
               guids[i].Data4[5] << 16 | 
               guids[i].Data4[6] << 8  | 
               guids[i].Data4[7];

		line.Format(_T("{%.8X-%.4X-%.4X-%.4X-%.4X%.8X}"), 
					   guids[i].Data1, 
					   tmp1,
					   tmp2,
					   tmp3,
                       tmp4,
                       tmp5);
        
        guidList.AddString(line);
    }
}

void CEnumGuidDlg::OnQueryFull() 
{
    HANDLE          hDataBlock;
    DWORD           dwRet;
    PBYTE           Buffer;
    ULONG           dwBufferSize = 0;
    PWNODE_ALL_DATA pWnode;
    LPGUID          lpGuid = GetSelectedGuid();
    CString         msg;


    //  Open the wnode
    //
    dwRet = WmiOpenBlock(lpGuid, 0, &hDataBlock);
    if (dwRet != ERROR_SUCCESS) {
        msg.Format(_T("Unable to open data block (%u)\n"), dwRet);
        MessageBox(msg);
        return;
    }
	    
    //  Query the data block
    //
    dwRet = WmiQueryAllData(hDataBlock, 
                            &dwBufferSize,
                            NULL);
    if (dwRet == ERROR_INSUFFICIENT_BUFFER) {
        #ifdef DBG
        printf("Initial buffer too small reallocating to %u\n", dwBufferSize);
        #endif
        Buffer = new BYTE[dwBufferSize];
        if (Buffer != NULL) {
            dwRet = WmiQueryAllData(hDataBlock,
                                    &dwBufferSize,
                                    Buffer);
        }
        else {
            MessageBox(_T("Reallocation failed\n"));
        }
        
        if (dwRet == ERROR_SUCCESS) {
            pWnode = (PWNODE_ALL_DATA) Buffer;

            CDisplayDataDlg dlg(pWnode, this);
            dlg.DoModal();
    
            delete[] Buffer;
            // WmiCloseBlock(hDataBlock);
        }
        else {
            msg.Format(_T("WMIQueryAllData returned error: %d\n"), dwRet);
            MessageBox(msg);
        }
    }
    else {
        msg.Format(_T("Out of Memory Error.  Unable to allocate buffer of size %u\n"),
                   dwBufferSize);
        MessageBox(msg);
    }

    
    WmiCloseBlock( hDataBlock );
}

void CEnumGuidDlg::OnQuerySingle() 
{
    HANDLE   hDataBlock;
    DWORD    dwRet;
    TCHAR    Buffer[0x4000];
    DWORD    dwBufferSize = 0x4000;
    LPTSTR   lpInstanceName;
    PWNODE_SINGLE_INSTANCE  pWnode;
    LPGUID   lpGuid = GetSelectedGuid();
    CString  tmp;
    CSelectInstanceName sin(lpGuid, Buffer, &dwBufferSize, this);
    
    dwRet = sin.Select();

    if (dwRet != ERROR_SUCCESS) {
        return;
    }

    lpInstanceName = new TCHAR[dwBufferSize];
    if (lpInstanceName == NULL) {
        MessageBox(_T("Out of Memory Error"));
        return;
    }
    else {
        _tcscpy(lpInstanceName, Buffer);
        dwBufferSize = 0x4000;
    }

    //  Open the wnode
    //
    dwRet = WmiOpenBlock(lpGuid,
                         0,
                         &hDataBlock);
    if (dwRet != ERROR_SUCCESS) {
        tmp.Format(_T("Unable to open data block (%u)"), dwRet);
        MessageBox(tmp);
        return;
    }


    //  Query the data block
    //
    dwRet = WmiQuerySingleInstance(hDataBlock,
                                   lpInstanceName,
                                   &dwBufferSize,
                                   Buffer);
    if (dwRet != ERROR_SUCCESS) {
        tmp.Format(_T("WmiQuerySingleInstance returned error: %d"), dwRet);
        MessageBox(tmp);
        WmiCloseBlock( hDataBlock );
        return;
    }

    pWnode = (PWNODE_SINGLE_INSTANCE) Buffer;

    CDisplayDataDlg dlg(pWnode);
    dlg.DoModal();

    delete[] lpInstanceName;

    WmiCloseBlock(hDataBlock);

    return;
}

void CEnumGuidDlg::OnSetSingleInstance() 
{
    DWORD    dwRet;
    DWORD    dwVersionNumber;
    DWORD    dwData[MAX_DATA];
    DWORD    dwDataSize = MAX_DATA;
    UINT     iLoop;
    LPTSTR   lpInstanceName;
    TCHAR    Buffer[1024];
    DWORD    dwBufferSize = 1024;
    HANDLE   hDataBlock;
    LPGUID   lpGuid = GetSelectedGuid();

    CString tmp, msg;
    CSelectInstanceName sin(lpGuid, Buffer, &dwBufferSize, this);
    CSelectInstanceDataMany sid(&dwVersionNumber,
                                &dwDataSize,
                                dwData,
                                MAX_DATA,
                                this);

    //  Get the instance to set
    //
    dwRet = sin.Select();

    if (dwRet != ERROR_SUCCESS) {
        return;
    }

    sid.DoModal();

    lpInstanceName = new TCHAR[dwBufferSize];
    _tcscpy(lpInstanceName, Buffer);

    //  Open the wnode
    //
    dwRet = WmiOpenBlock(lpGuid,
                         0,
                         &hDataBlock);
    if (dwRet != ERROR_SUCCESS) {
        msg.Format(_T("Unable to open data block (%u)"), dwRet);
        MessageBox(msg);
        delete[] lpInstanceName;
        return;
    }

    //  Set the data
    //
    msg.Format(_T("Setting Instance: %s\nData: "), lpInstanceName);
    for (iLoop = 0; iLoop < dwDataSize; iLoop++) {
        tmp.Format(_T("0x%x "), dwData[iLoop]);
        msg += tmp;
    }

    msg += _T("\n\n");

    dwRet = WmiSetSingleInstance( hDataBlock,
                 lpInstanceName,
                 dwVersionNumber, 
                 dwDataSize * sizeof(DWORD),
                 dwData);

    if ( dwRet != ERROR_SUCCESS) {
        tmp.Format(_T("WMISetSingleInstance returned error: %d"), dwRet);
    }
    else {
        tmp = _T("Set Success!!!");
    }
    msg += tmp;
    MessageBox(msg);

    WmiCloseBlock( hDataBlock );
    delete[] lpInstanceName;
}

void CEnumGuidDlg::OnSetSingleItem() 
{
    DWORD    dwRet;
    DWORD    dwVersionNumber;
    DWORD    dwItemNumber;
    DWORD    dwData;
    LPTSTR   lpInstanceName;
    TCHAR    Buffer[1024];
    DWORD    dwBufferSize = 1024;
    HANDLE   hDataBlock;
    LPGUID   lpGuid = GetSelectedGuid();
    
    CSelectInstanceName sin(lpGuid, Buffer, &dwBufferSize, this);
    CSelectInstanceData sid(&dwData, &dwVersionNumber, &dwItemNumber, this);

    CString msg;
    dwRet = sin.Select();

    if (dwRet != ERROR_SUCCESS) {
        return;
    }

    lpInstanceName = new TCHAR[dwBufferSize];
    _tcscpy( lpInstanceName, Buffer );
    dwBufferSize = 4096;

    sid.DoModal();

    //  Open the wnode
    //
    dwRet = WmiOpenBlock(lpGuid, 0, &hDataBlock);
    if (dwRet != ERROR_SUCCESS) {
        msg.Format(_T("Unable to open data block (%u)"), dwRet);
        MessageBox(msg);
        delete[] lpInstanceName;
        return;
    }

    //  Set the data
    //
    msg.Format(_T("Setting Instance: %s\nData: 0x%x\n\n"), 
               lpInstanceName, dwData);
    dwRet = WmiSetSingleItem(hDataBlock,
                     lpInstanceName,
                     dwItemNumber,
                     dwVersionNumber, 
                     sizeof(DWORD),
                     &dwData);

    if (dwRet != ERROR_SUCCESS) {
        CString tmp;
        tmp.Format(_T("WMISetSingleInstance returned error: %d"), dwRet);
        msg += tmp;
    }
    else {
        msg += ("Set Success!!!");
    }

    MessageBox(msg);

    WmiCloseBlock( hDataBlock );
    delete[] lpInstanceName;
}

void CEnumGuidDlg::OnReenumerateGuids() 
{
    guidList.ResetContent();
    
	if (EnumerateGuids()) {
		ListGuids();

        // make sure there is a selection, makes for a saner life later on
        guidList.SetCurSel(0);
	}

}

LPGUID CEnumGuidDlg::GetSelectedGuid()
{
    return guids + guidList.GetCurSel();    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\dspdatadlg.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

Abstract:

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#if !defined(AFX_DisplayDataDlg_H__CB4E370B_8DD5_11D1_9905_006008C3A19A__INCLUDED_)
#define AFX_DisplayDataDlg_H__CB4E370B_8DD5_11D1_9905_006008C3A19A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DisplayDataDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDisplayDataDlg dialog

#pragma warning (once : 4200)
#include <wmistr.h>

class CDisplayDataDlg : public CDialog
{
// Construction
public:
	CDisplayDataDlg(PWNODE_ALL_DATA pwNode, CWnd* pParent = NULL);   // standard constructor
	CDisplayDataDlg(PWNODE_SINGLE_INSTANCE pwNode, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDisplayDataDlg)
	enum { IDD = IDD_ALL_DATA };
	CEdit	txtData;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDisplayDataDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void DisplayAllData(PWNODE_ALL_DATA Wnode);
    void DisplaySingleInstance(PWNODE_SINGLE_INSTANCE Wnode);

    PWNODE_ALL_DATA pwNode;
    PWNODE_SINGLE_INSTANCE pwSingleNode;

	// Generated message map functions
	//{{AFX_MSG(CDisplayDataDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


#endif // !defined(AFX_DisplayDataDlg_H__CB4E370B_8DD5_11D1_9905_006008C3A19A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\drt\tracelog\provider\provider.c ===
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <ole2.h>
#include <wmistr.h>
#include <evntrace.h>
#include <time.h>
#include <tchar.h>

#define DEBUG

#define MAXEVENTS                       5000
#define MAXSTR                          1024

TRACEHANDLE LoggerHandle;
#define ResourceName _T("MofResource")
TCHAR ImagePath[MAXSTR];

GUID TransactionGuid[2] =
{ 
    {0xce5b1020, 0x8ea9, 0x11d0, 0xa4, 0xec, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10},
	{0xf684e86f, 0xba1d, 0x11d2, 0x8b, 0xbf, 0x00, 0x00, 0xf8, 0x06, 0xef, 0xe0}
};
GUID   ControlGuid[2]  =
{
	{0xd58c126f, 0xb309, 0x11d1, 0x96, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa5, 0xbc},
	{0x7c6a708a, 0xba1e, 0x11d2, 0x8b, 0xbf, 0x00, 0x00, 0xf8, 0x06, 0xef, 0xe0}
};

TRACE_GUID_REGISTRATION TraceGuidReg[2] =
{
    { (LPGUID)&TransactionGuid[0],
      NULL
    },
    { (LPGUID)&TransactionGuid[1],
      NULL
    }
};

typedef struct _USER_EVENT {
    EVENT_TRACE_HEADER    Header;
    MOF_FIELD             mofData;
} USER_EVENT, *PUSER_EVENT;

typedef struct _USER_INSTANCE_EVENT {
    EVENT_INSTANCE_HEADER    Header;
    MOF_FIELD                mofData;
} USER_INSTANCE_EVENT, *PUSER_INSTANCE_EVENT;

TRACEHANDLE RegistrationHandle[2];
BOOLEAN RegistrationSuccess;
ULONG EnableLevel = 0;
ULONG EnableFlags = 0;

ULONG InitializeTrace(
    IN LPTSTR ExePath, FILE* fp
    );

ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

GUID StringToGuid(TCHAR *str);

LPTSTR Decodestatus(IN ULONG Status);

HANDLE ghTraceOnEvent;
ULONG  TraceOnFlag;
UINT   nSleepTime = 0;
TCHAR  ErrorMsg[MAXSTR];
ULONG  gnMultiReg=1;

int __cdecl _tmain(int argc, _TCHAR **argv)
{
	ULONG    status;
    USER_EVENT UserEvent;
    USER_INSTANCE_EVENT UserInstanceEvent;
    EVENT_INSTANCE_INFO InstInfo;
    ULONG    i;
    ULONG    MaxEvents;
    //ULONG    InstanceId;
    PWNODE_HEADER Wnode;
    TCHAR    *str;
    int      err;
    BOOL     bInstanceTrace=0, bUseGuidPtr=0, bUseMofPtr=0;
    BOOL     bIncorrect  = FALSE;
    BOOL     bUseNullPtr = FALSE;

    PMOF_FIELD mofField;
    TCHAR      strMofData[MAXSTR];

    FILE *fp; 
    fp = _tfopen(_T("provider.log"), _T("a+")); if(fp==NULL) {_tprintf(_T("pf=NULL\n"));};

    MaxEvents = MAXEVENTS;
    TraceOnFlag = 0;

    if (argc > 1)
        MaxEvents = _ttoi(argv[1]);

    if(argc > 2)
        ControlGuid[0] = StringToGuid(argv[2]);

    if(argc > 3)
        nSleepTime = _ttoi(argv[3]);

    err = UuidToString(&ControlGuid[0], &str);

    if(RPC_S_OK == err)
        _tprintf(_T("The ControlGuid is : %s\n"), str);
    else
        _tprintf(_T("Error(%d) converting uuid\n"), err);

    _ftprintf(fp, _T("The ControlGuid is : %s\n"), str);

    if(argc > 4) {
        if(!_tcscmp(_T("TraceInstance"), argv[4]))
            bInstanceTrace = TRUE;        
    }

    if(argc > 5) {
        if(!_tcscmp(_T("GuidPtr"), argv[5]))
            bUseGuidPtr = TRUE;
        else if(!_tcscmp(_T("MofPtr"), argv[5]))
            bUseMofPtr = TRUE;
        else if(!_tcscmp(_T("GuidPtrMofPtr"), argv[5])) {
            bUseGuidPtr = TRUE;
            bUseMofPtr  = TRUE;
        }
        else if (!_tcscmp(_T("InCorrectMofPtr"), argv[5])) {
            bUseMofPtr  = TRUE;
            bIncorrect  = TRUE;
        }
        else if (!_tcscmp(_T("NullMofPtr"), argv[5])) {
            bUseMofPtr  = TRUE;
            bUseNullPtr = TRUE;
            bIncorrect  = TRUE;
        }
    }

    if(argc > 6) {
        if(!_tcscmp(_T("MultiReg"), argv[6]))
	        gnMultiReg=2;   //use 2 registrations for now
    }

    status = InitializeTrace(_T("tracedp.exe"), fp);
    if (status != ERROR_SUCCESS) {
        _ftprintf(fp, _T("InitializeTrace failed, status=%d, %s\n"), status, Decodestatus(status));
       return 0;
    }

    _tprintf(_T("Testing Logger with %d events\n"), MaxEvents);

    RtlZeroMemory(&UserEvent, sizeof(UserEvent));
    Wnode = (PWNODE_HEADER) &UserEvent;
    UserEvent.Header.Size  = sizeof(USER_EVENT);
    UserEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;
	if(bUseGuidPtr) {
        _tprintf(_T("\n********Use Guid Pointer**********\n"));
        UserEvent.Header.Flags  |= WNODE_FLAG_USE_GUID_PTR;
        UserEvent.Header.GuidPtr = (ULONGLONG)&TransactionGuid[0];
    }
    else
        UserEvent.Header.Guid  =  TransactionGuid[0];

    RtlZeroMemory(&UserInstanceEvent, sizeof(UserInstanceEvent));
    UserInstanceEvent.Header.Size  = sizeof(USER_INSTANCE_EVENT);
    UserInstanceEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;

	if(bUseMofPtr) {
        _tprintf(_T("\n=======Use Mof Pointer========\n"));
        _tcscpy(strMofData, str);

        UserEvent.Header.Flags         |= WNODE_FLAG_USE_MOF_PTR;
        mofField = (PMOF_FIELD) & UserEvent.mofData;
        if (bUseNullPtr)
            mofField->DataPtr = (ULONGLONG) (NULL);
        else
            mofField->DataPtr = (ULONGLONG) (strMofData);
        if (bIncorrect)
            mofField->Length  = sizeof(TCHAR) * (_tcslen(strMofData) + 1000);
        else
            mofField->Length  = sizeof(TCHAR) * (_tcslen(strMofData) + 1);

        UserInstanceEvent.Header.Flags |= WNODE_FLAG_USE_MOF_PTR;
        mofField = (PMOF_FIELD) & UserInstanceEvent.mofData;
        if (bUseNullPtr)
            mofField->DataPtr = (ULONGLONG) (NULL);
        else
            mofField->DataPtr = (ULONGLONG) (strMofData);
        if (bIncorrect)
            mofField->Length  = sizeof(TCHAR) * (_tcslen(strMofData) + 10000);
        else
            mofField->Length  = sizeof(TCHAR) * (_tcslen(strMofData) + 1);
    }

    if(bInstanceTrace) {
        status = CreateTraceInstanceId((PVOID)TraceGuidReg[0].RegHandle, &InstInfo);
        _tprintf(_T("\n-------TraceEventInstance-----\n"));
        if (status != ERROR_SUCCESS) {
            _ftprintf(fp, _T("CreatTraceInstanceId() failed. status=%d,  %s\n"), status, Decodestatus(status));
        }
    }

    _ftprintf(fp, _T("%d Events, %s, %s, %s, %s, sleep time=%d\n"), MaxEvents, 
              bInstanceTrace? _T("TraceEventInstance"): _T("TraceEvent"), 
              bUseGuidPtr? _T("Use GuidPtr"): _T("Use Guid"), 
              bUseMofPtr? _T("Use MofPtr"): _T("Not use MofPtr"), 
              gnMultiReg==1 ? _T("Single Registration"): _T("Multiple Registrations"), 
              nSleepTime);

    i = 0;

    while (1) {
        if(WAIT_FAILED == WaitForSingleObject(ghTraceOnEvent, INFINITE))
        {
            _tprintf(_T("Error(%d) waiting for ghTraceOnEvent object\n"), GetLastError());
        }
        if (TraceOnFlag == 1 && i < MaxEvents) {
            i++;
            if (i == ((i/2) * 2) ) {
                UserEvent.Header.Class.Type = EVENT_TRACE_TYPE_START;
                UserInstanceEvent.Header.Class.Type = EVENT_TRACE_TYPE_START;
            }
            else {
                UserEvent.Header.Class.Type = EVENT_TRACE_TYPE_END;
                UserInstanceEvent.Header.Class.Type = EVENT_TRACE_TYPE_END;
            }

            if(bInstanceTrace) {
                status = TraceEventInstance(LoggerHandle, (PEVENT_INSTANCE_HEADER)&UserInstanceEvent, &InstInfo, NULL);
                if (status != ERROR_SUCCESS) {
                    _tprintf(_T("%d TraceEventInstance() failed, status=%d  %s\n"), i, status, Decodestatus(status));
                    _ftprintf(fp, _T("\ni=%d TraceEventInstance() failed, break! status=%d  %s\n"), i, status, Decodestatus(status));
                    return 0;
                }
            }
            else {
                status = TraceEvent(LoggerHandle, (PEVENT_TRACE_HEADER) &UserEvent);
                if (status != ERROR_SUCCESS) {
                    fprintf(stderr, "Error(%d) while writing event.\n", status);
                    _ftprintf(fp, _T("\ni=%d TraceEvent() failed, break!\nstatus=%d  %s\n"), i, status, Decodestatus(status));
                    return 0;
                }
            }

            if (i >= MaxEvents) {
                _ftprintf(fp, _T("\ni=%d  MaxEvents=%d break!\n\n"), i, MaxEvents);
			}
            else if (!(i % 100)) {
                _ftprintf(fp, _T("."));
                _tprintf(_T("."));

                if(nSleepTime)
                    _sleep(nSleepTime);
            }
        }
        if (TraceOnFlag == 2) {
            _ftprintf(fp, _T("\ni=%d TraceOnFlag == 2 break!\n\n"), i);
            break;
		}
    }

    fclose(fp);
    CloseHandle(ghTraceOnEvent);
    for(i=0; i<	gnMultiReg; i++)
        UnregisterTraceGuids(RegistrationHandle[i]);
	return (0);
}


ULONG InitializeTrace(
    IN LPTSTR ExePath, FILE* fp
    )
{
    ULONG Status;
    ULONG i, j;

    Status = GetModuleFileName(NULL, &ImagePath[0], MAXSTR*sizeof(TCHAR));
    if (Status == 0) {
        return (ERROR_FILE_NOT_FOUND);
    }

    ghTraceOnEvent = CreateEvent(
                        NULL,           // security attributes
                        TRUE,           // manual reset
                        FALSE,          // initial state
                        NULL            // pointer to event-object
                    );        

    if(NULL == ghTraceOnEvent)
    {
        Status=GetLastError();
        _tprintf(_T("Error(%d) creating TraceOnEvent\n"), Status);
        return Status;
    }

    for (i=0; i<gnMultiReg; i++) {
		Status = RegisterTraceGuids(
					(WMIDPREQUEST)ControlCallback,   //use same callback function
					(PVOID)(INT_PTR)(0x12345678+i),  // RequestContext
					(LPCGUID)&ControlGuid[i],
					1,
					&TraceGuidReg[i],
					(LPCTSTR)&ImagePath[0],
					(LPCTSTR)ResourceName,
					&RegistrationHandle[i]);

		if (Status != ERROR_SUCCESS) {
			_tprintf(_T("Trace registration failed\n"));
			RegistrationSuccess = FALSE;
            if(i>0)
                for (j=0; j<i; j++)
                    UnregisterTraceGuids(RegistrationHandle[i]);
       _ftprintf(fp, _T("InitializeTrace failed. i=%d, status=%d, %s\n"), i, Status, Decodestatus(Status));
            return(Status);
		}
		else {
			_tprintf(_T("Trace registered successfully\n"));
			RegistrationSuccess = TRUE;
		}
	}
    return(Status);
}

ULONG
ControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    ULONG Status;
    ULONG RetSize;

    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            RetSize = 0;
            LoggerHandle = GetTraceLoggerHandle( Buffer );
            EnableLevel = GetTraceEnableLevel(LoggerHandle);
            EnableFlags = GetTraceEnableFlags(LoggerHandle);
            _tprintf(_T("Logging enabled to %I64u\n"), LoggerHandle);
            TraceOnFlag = 1;
            SetEvent(ghTraceOnEvent);
            break;
        }

        case WMI_DISABLE_EVENTS:
        {
            TraceOnFlag = 2;
            RetSize = 0;
            LoggerHandle = 0;
            _tprintf(_T("\nLogging Disabled\n"));
            SetEvent(ghTraceOnEvent);
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = RetSize;
    return(Status);
}


GUID StringToGuid(TCHAR *str)
{
    GUID  guid;
    TCHAR temp[10];
    int   i, n;

    _tprintf(_T("sizeof GUID = %d  GUID=%s\n"), sizeof(guid), str);

    temp[8]=_T('\0');
    _tcsncpy(temp, str, 8);
    _stscanf(temp, _T("%x"), &(guid.Data1));
    
    temp[4]=_T('\0');
    _tcsncpy(temp, &str[9], 4);
    _stscanf(temp, _T("%x"), &(guid.Data2));

    _tcsncpy(temp, &str[14], 4);
    _stscanf(temp, _T("%x"), &(guid.Data3));

    temp[2]=_T('\0');
    for(i=0;i<8;i++)
    {
        temp[0]=str[19+((i<2)?2*i:2*i+1)]; // to accomodate the minus sign after
        temp[1]=str[20+((i<2)?2*i:2*i+1)]; // the first two chars
        _stscanf(temp, _T("%x"), &n);      // if directly used more than byte alloc
        guid.Data4[i]=(unsigned char)n;                   // causes overrun of memory
    }
    
    return guid;
}

LPTSTR
Decodestatus(
    IN ULONG Status
    )
{
    memset( ErrorMsg, 0, MAXSTR );
    FormatMessage(     
        FORMAT_MESSAGE_FROM_SYSTEM |     
        FORMAT_MESSAGE_IGNORE_INSERTS,    
        NULL,
        Status,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) ErrorMsg,
        MAXSTR,
        NULL );

    return ErrorMsg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\enumguid.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Revision History:

--*/

// EnumGuid.h : main header file for the ENUMGUID application
//

#if !defined(AFX_ENUMGUID_H__272A54EB_8D57_11D1_9904_006008C3A19A__INCLUDED_)
#define AFX_ENUMGUID_H__272A54EB_8D57_11D1_9904_006008C3A19A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CEnumGuidApp:
// See EnumGuid.cpp for the implementation of this class
//

class CEnumGuidApp : public CWinApp
{
public:
	CEnumGuidApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEnumGuidApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CEnumGuidApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ENUMGUID_H__272A54EB_8D57_11D1_9904_006008C3A19A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\enumguid.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Revision History:

--*/


// EnumGuid.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "EnumGuid.h"
#include "EnumGDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEnumGuidApp

BEGIN_MESSAGE_MAP(CEnumGuidApp, CWinApp)
	//{{AFX_MSG_MAP(CEnumGuidApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEnumGuidApp construction

CEnumGuidApp::CEnumGuidApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CEnumGuidApp object

CEnumGuidApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CEnumGuidApp initialization

BOOL CEnumGuidApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CEnumGuidDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = (int)dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\dspdatadlg.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    dspdatadlg.c

Abstract:

    

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

// DisplayDataDlg.cpp : implementation file
//

#include "stdafx.h"
#include "EnumGuid.h"
#include "DspDataDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDisplayDataDlg dialog
#include "wmihlp.h"



CDisplayDataDlg::CDisplayDataDlg(PWNODE_ALL_DATA pwNode,
                                       CWnd* pParent /*=NULL*/)
	: CDialog(CDisplayDataDlg::IDD, pParent), pwNode(pwNode), pwSingleNode(0)
{
	//{{AFX_DATA_INIT(CDisplayDataDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CDisplayDataDlg::CDisplayDataDlg(PWNODE_SINGLE_INSTANCE pwNode,
                                 CWnd* pParent /*=NULL*/)
	: CDialog(CDisplayDataDlg::IDD, pParent), pwNode(0),
    pwSingleNode(pwNode) {}

void CDisplayDataDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDisplayDataDlg)
	DDX_Control(pDX, IDC_DATA, txtData);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDisplayDataDlg, CDialog)
	//{{AFX_MSG_MAP(CDisplayDataDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDisplayDataDlg message handlers

BOOL CDisplayDataDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    if (pwNode)
        DisplayAllData(pwNode);
    else if (pwSingleNode)
        DisplaySingleInstance(pwSingleNode);
    
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDisplayDataDlg::DisplayAllData(PWNODE_ALL_DATA Wnode)
{
    DWORD    dwInstanceNum;
    DWORD    dwByteCount;
    DWORD    dwFlags;
    DWORD    dwStructureNum = 1;
    DWORD    dwTemp;
    DWORD    dwInstanceSize;
    LPDWORD  lpdwNameOffsets;
    PBYTE    lpbyteData;
    BOOL     bFixedSize = FALSE;

    CString output, tmp;


    do {
        tmp.Format(_T("\r\nWNODE_ALL_DATA structure %d.\r\n"), dwStructureNum++);
        output += tmp;
    
        PrintHeader(Wnode->WnodeHeader, output);

        dwFlags = Wnode->WnodeHeader.Flags;

        if ( ! (dwFlags & WNODE_FLAG_ALL_DATA)) {
            txtData.SetWindowText(_T("Not a WNODE_ALL_DATA structure\r\n"));
            return;
        }
	
        // Check for fixed instance size
        //
        bFixedSize = FALSE;
        if ( dwFlags & WNODE_FLAG_FIXED_INSTANCE_SIZE ) {
            dwInstanceSize = Wnode->FixedInstanceSize;
            bFixedSize = TRUE;
            lpbyteData = OffsetToPtr((PBYTE)Wnode, Wnode->DataBlockOffset);
            tmp.Format(_T("Fixed size: 0x%x\r\n"), dwInstanceSize);
            output += tmp;
        }


        //  Get a pointer to the array of offsets to the instance names
        //
        lpdwNameOffsets = (LPDWORD) OffsetToPtr(Wnode, Wnode->OffsetInstanceNameOffsets);


        //  Print out each instance name and data.  The name will always be
        //  in UNICODE so it needs to be translated to ASCII before it can be
        //  printed out.
        //
        for ( dwInstanceNum = 0; dwInstanceNum < Wnode->InstanceCount; dwInstanceNum++) {
            tmp.Format(_T("Instance %d\r\n"), 1 + dwInstanceNum);
            output += tmp;
            
            PrintCountedString( (LPTSTR)
                                OffsetToPtr( Wnode,
                                lpdwNameOffsets[dwInstanceNum]),
                                output);

            //  Length and offset for variable data
            //
            if ( !bFixedSize) {
                dwInstanceSize = Wnode->OffsetInstanceDataAndLength[dwInstanceNum].
                    LengthInstanceData;
                tmp.Format(_T("Data size 0x%x\r\n"), dwInstanceSize);
                output += tmp;
                lpbyteData = (PBYTE) OffsetToPtr((PBYTE)Wnode,
                                                  Wnode->OffsetInstanceDataAndLength[dwInstanceNum].
                                                  OffsetInstanceData);
            }

            output += _T(" Data:");

            for ( dwByteCount = 0; dwByteCount < dwInstanceSize; ) {

                //  Print data in groups of DWORDS but allow for single bytes.
                //
                if ( (dwByteCount % 16) == 0) {
                    output += _T("\r\n");
                }

                if ( (dwByteCount % 4) == 0) {
                    output += _T(" "); // _T(" 0x");
                }

                dwTemp = *((LPDWORD)lpbyteData);
                tmp.Format(_T("%.8x"), dwTemp );
                output += tmp;
                lpbyteData += sizeof(DWORD);
                dwByteCount += sizeof(DWORD);
            }  // for cByteCount

            output += _T("\r\n\r\n");

        }     // for cInstanceNum

        //  Update Wnode to point to next node
        //
        if ( Wnode->WnodeHeader.Linkage != 0) {
            Wnode = (PWNODE_ALL_DATA) OffsetToPtr( Wnode, Wnode->WnodeHeader.Linkage);
        }
        else {
            Wnode = 0;
        }

    } while(Wnode != 0);

    txtData.SetWindowText(output);
}

void CDisplayDataDlg::DisplaySingleInstance(PWNODE_SINGLE_INSTANCE Wnode)
{
    DWORD    dwByteCount;
    DWORD    dwFlags;
    LPDWORD  lpdwData;
    USHORT   usNameLength;
    CString  tmp, output;

    dwFlags = Wnode->WnodeHeader.Flags;

    if ( ! (dwFlags & WNODE_FLAG_SINGLE_INSTANCE)) {
        txtData.SetWindowText(_T("Not a WNODE_SINGLE_INSTANCE structure"));
        return;
    }

    output = _T("WNODE_SINGLE_INSTANCE.\r\n");
    PrintHeader(Wnode->WnodeHeader, output);



    // Print name or index number
    //
    if ( dwFlags & WNODE_FLAG_STATIC_INSTANCE_NAMES ) {
        tmp.Format(_T("Instance index: %d\r\n"), Wnode->InstanceIndex);
        output += tmp;
    }

    usNameLength = * (USHORT *) OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
    tmp.Format(_T("Name length 0x%x\r\n"), usNameLength);
    output += tmp;
    usNameLength /= 2;
    PrintCountedString( (LPTSTR) OffsetToPtr( Wnode,
                         Wnode->OffsetInstanceName), output );


    //   wcscpy(lpNameW, (LPWSTR) (OffsetToPtr(Wnode, Wnode->OffsetInstanceName )
    //                                     + sizeof(USHORT)));
    //   wcsncpy( lpNameW + usNameLength, L" ", 2);
    //   wcstombs( lpName, lpNameW, 300);
    //   printf("%s\r\n", lpName);



    //  Print out the Data
    //
    tmp.Format(_T(" Data:\r\nData Size: 0x%x\r\n"), Wnode->SizeDataBlock);
    output += tmp;
    lpdwData = (PULONG) OffsetToPtr(Wnode, Wnode->DataBlockOffset);

    for ( dwByteCount = 0; dwByteCount < Wnode->SizeDataBlock; dwByteCount+= sizeof(ULONG)) {
        if ( (dwByteCount % 16) == 0) {
            output += _T("\r\n");
        }

        tmp.Format(_T("0x%.8x "), *lpdwData);
        output += tmp;
        lpdwData++;
    }

    txtData.SetWindowText(output);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\print.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Revision History:

--*/
/****************************************************************************
*
*  print.h
*  --------
*
*  Header file WMI printout funcions
*
*  Modification History:
*
*    drewm - April, 22, 1997 - Original Source
*
****************************************************************************/

#ifndef _WMI_PRINT_INC
#define _WMI_PRINT_INC

#ifndef OffsetToPtr
#define OffsetToPtr(Base, Offset)     ((PBYTE) ((PBYTE)Base + Offset))
#endif

#define MAX_NAME_LENGTH 500

VOID
PrintGuid(
   LPGUID         lpGuid
   );
/*
VOID
PrintClassInfoHeader(
   PMOFCLASSINFO  pMofClassInfo
   );

VOID
PrintDataItem(
   PMOFDATAITEM   lpDataItem
   );

VOID
PrintDataType(
   MOFDATATYPE    E_DataType
   );

VOID
PrintClassQualifier(
   LPTSTR         lpQualifier,
   MOFHANDLE      hMofHandle
   );
*/

VOID
ClearScreen(
   VOID
   );

VOID
WaitForUser(
   VOID
   );

VOID PrintDescription(
   LPGUID   lpGuid
   );

VOID
PrintAllData(
   IN  PWNODE_ALL_DATA Wnode
   );

VOID
PrintHeader(
   IN  WNODE_HEADER Header
   );

VOID PrintSingleInstance(
   IN  PWNODE_SINGLE_INSTANCE Wnode
   );

VOID
PrintCountedString(
   LPTSTR   lpString
   );

BOOL
MyIsTextUnicode(
   PVOID    string
   );


#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\print.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Revision History:

--*/

/************STARTDOC*********************************************************
*
*   print.c
*
*   This file contains the functions print specific WMI structures
*   out to stdout.
*
*
*   Modification History:
*   --------------------
*
*     Drew McDaniel (drewm)  - Sept. 16, 1997 - Original Source
*
*
*************ENDDOC**********************************************************/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ole2.h>
#include <wmium.h>
#include <tchar.h>
#include "print.h"

//  Defined constants
//

//  Modular Data
//


//  Function Prototypes
//


//+----------------------------------------------------------
//
//  Function:  PrintGuid
//
//  Descrip:   Prints a singe guid.  Does not print the end
//             new line or cariage return
//
//  Returns:   VOID
//
//  Notes:     Does not print end cariage return or new line
//
//  History:   09/16/97 drewm Created
//-----------------------------------------------------------
VOID
PrintGuid(
   LPGUID lpGuid
   )
{
      printf("0x%x 0x%x 0x%x  0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x",
                  lpGuid->Data1,
	               lpGuid->Data2,
	               lpGuid->Data3,
	               lpGuid->Data4[0],
	               lpGuid->Data4[1],
	               lpGuid->Data4[2],
	               lpGuid->Data4[3],
	               lpGuid->Data4[4],
	               lpGuid->Data4[5],
	               lpGuid->Data4[6],
	               lpGuid->Data4[7]);
}

/*
VOID
PrintClassInfoHeader(
   PMOFCLASSINFO  pMofClassInfo
   )
{
   printf("Guid: ");
   PrintGuid(&(pMofClassInfo->Guid));
   printf("\n");

   _tprintf(__T("Name: %s\n"), pMofClassInfo->Name);
   _tprintf(__T("Description: %s\n"), pMofClassInfo->Description);
   printf("Language ID: %u\n", pMofClassInfo->Language);
   printf("Flags: 0x%x\n", pMofClassInfo->Flags);
   printf("Version: %u\n", pMofClassInfo->Version);
   printf("\n");
}




VOID
PrintDataItem(
   PMOFDATAITEM   lpDataItem
   )
{
   _tprintf(__T("Name: %s\n"), lpDataItem->Name);
   _tprintf(__T("Description: %s\n"), lpDataItem->Description);
   printf("Data Type: ");
   PrintDataType(lpDataItem->DataType);
   printf("\n");
   printf("Version: %u\n", lpDataItem->Version);
   printf("Size: 0x%x\n", lpDataItem->SizeInBytes);
   printf("Flags: 0x%x\n", lpDataItem->Flags);
   printf("Embedded Class Guid: ");
   PrintGuid(&(lpDataItem->EmbeddedClassGuid));
   printf("\n");
   if (lpDataItem->Flags & MOFDI_FLAG_FIXED_ARRAY)
   {
      printf("Fixed array elements: %u\n", lpDataItem->FixedArrayElements);
   }
   if (lpDataItem->Flags & MOFDI_FLAG_VARIABLE_ARRAY)
   {
      printf("Variable length size ID: %u\n", lpDataItem->VariableArraySizeId);
   }


}

VOID
PrintClassQualifier(
   LPTSTR      lpQualifier,
   MOFHANDLE   hMofHandle
   )
{
   BYTE  Buffer[MAX_NAME_LENGTH];
   DWORD dwBufferSize = MAX_NAME_LENGTH;
   DWORD dwRet;
   MOFDATATYPE MofDataType;

   dwRet = WmiMofQueryClassQualifier( hMofHandle,
                                      lpQualifier,
                                      &MofDataType,
                                      &dwBufferSize,
                                      Buffer);
   if (dwRet != ERROR_SUCCESS)
   {
      printf("WmiMofQueryClassQualifier failed. (%u)\n", dwRet);
      exit (0);
   }

   switch( MofDataType )
   {
   case MOFInt32:
   case MOFUInt32:
   case MOFInt64:
   case MOFUInt64:
   case MOFInt16:
   case MOFUInt16:
      _tprintf(__T("%s: %u\n"), lpQualifier, Buffer);
      break;
   case MOFChar:
   case MOFString:
   case MOFWChar:
      _tprintf(__T("%s: %s\n"), lpQualifier, Buffer);
      break;
   case MOFByte:
      _tprintf(__T("%s: Unsupported type MOFByte\n"), lpQualifier);
      break;
   case MOFDate:
      _tprintf(__T("%s: Unsupported type MOFDate\n"), lpQualifier);
      break;
   case MOFBoolean:
      if (*Buffer == TRUE)
      {
         _tprintf(__T("%s: TRUE\n"), lpQualifier);
      }
      else
      {
         _tprintf(__T("%s: FALSE\n"), lpQualifier);
      }
      break;
   case MOFEmbedded:
      _tprintf(__T("%s: Unsupported type MOFEmbedded\n"), lpQualifier);
      break;
   case MOFUnknown:
      _tprintf(__T("%s: Unsupported type MOFUnknown\n"), lpQualifier);
      break;
   default:
      printf("Invalid Data Type\n");
   }


}

VOID
PrintDataType(
   MOFDATATYPE E_DataType
   )
{
   switch( E_DataType )
   {
   case MOFInt32:
      printf("MOFInt32");
      break;
   case MOFUInt32:
      printf("MOFUInt32");
      break;
   case MOFInt64:
      printf("MOFInt64");
      break;
   case MOFUInt64:
      printf("MOFUInt64");
      break;
   case MOFInt16:
      printf("MOFInt16");
      break;
   case MOFUInt16:
      printf("MOFUInt16");
      break;
   case MOFChar:
      printf("MOFChar");
      break;
   case MOFByte:
      printf("MOFByte");
      break;
   case MOFWChar:
      printf("MOFWChar");
      break;
   case MOFDate:
      printf("MOFDate");
      break;
   case MOFBoolean:
      printf("MOFBoolean");
      break;
   case MOFEmbedded:
      printf("MOFEmbedded");
      break;
   case MOFString:
      printf("MOFString");
      break;
   case MOFUnknown:
      printf("Unknown");
      break;
   default:
      printf("Invalid Data Type\n");
   }
}
*/

VOID ClearScreen()
{
   UINT  i;

   for (i = 0; i < 40; i++)
   {
      printf("\n");
   }
}



VOID
WaitForUser()
{
   printf("Hit Enter to Continue\n");
   getchar ();
   getchar ();
}



/*
//+----------------------------------------------------------
//
//  Function:  PrintDescription
//
//  Descrip:   Prints the description of the selected guid
//
//  Returns:   VOID
//
//  Notes:     If there is an error in opening or printing
//             the description, an error message an error
//             code will be printed instead of the description.
//
//  History:   09/16/97 drewm Created
//-----------------------------------------------------------
VOID PrintDescription(
   LPGUID   lpGuid
   )
{
   DWORD          dwRet;
   USHORT         LangID;
   PMOFCLASSINFO  pMofClassInfo;
   MOFHANDLE      MofClassHandle;


   //  Make the language ID
   //
//   LangID = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US);
   LangID = MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL);


   //  Get the class ID
   //
   dwRet = WmiMofOpenClassInfo( lpGuid,
                                LangID,
                                &(pMofClassInfo),
                                &MofClassHandle);
   if (dwRet != ERROR_SUCCESS)
   {
      printf("Unable to open MofClassInfo handle (%u)\n", dwRet);
      return;
   }

   _tprintf(__T("%s\n"), pMofClassInfo->Description);

   WmiMofCloseClassInfo( MofClassHandle, pMofClassInfo );
}
*/





//+----------------------------------------------------------
//
//  Function: PrintHeader
//
//  Descrip:  Prints a wnode header structure.
//
//  Returns:  VOID
//
//  Notes:    None
//
//  History:  04/08/97 drewm Created
//-----------------------------------------------------------
VOID
PrintHeader(
   IN  WNODE_HEADER Header
   )
{
   SYSTEMTIME   sysTime;
   FILETIME     fileTime;
   FILETIME     localFileTime;


   //  Convert the file time
   //
   fileTime.dwLowDateTime = Header.TimeStamp.LowPart;
   fileTime.dwHighDateTime = Header.TimeStamp.HighPart;
   
   FileTimeToLocalFileTime( &fileTime,
                            &localFileTime );

   FileTimeToSystemTime( &localFileTime,
                         &sysTime);


   //  Print the info
   //
   printf("Buffer Size:  0x%x\n"
          "Provider Id:  0x%x\n"
          "Version    :  %u\n"
          "Linkage    :  0x%x\n"
          "Time Stamp :  %u:%02u %u\\%u\\%u\n"
          "Guid       :  0x%x 0x%x 0x%x  0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n"
          "Flags      :  0x%02x\n",
	Header.BufferSize,
	Header.ProviderId,
	Header.Version,
	Header.Linkage,
	sysTime.wHour,
    sysTime.wMinute,
    sysTime.wMonth,
    sysTime.wDay,
	sysTime.wYear,
	Header.Guid.Data1,
	Header.Guid.Data2,
	Header.Guid.Data3,
	Header.Guid.Data4[0],
	Header.Guid.Data4[1],
	Header.Guid.Data4[2],
	Header.Guid.Data4[3],
	Header.Guid.Data4[4],
	Header.Guid.Data4[5],
	Header.Guid.Data4[6],
	Header.Guid.Data4[7],
    Header.Flags );

   //  Print readable flags
   //
   if (Header.Flags & WNODE_FLAG_ALL_DATA)
   {
       printf("WNODE_FLAG_ALL_DATA\n");
   }
   
   if (Header.Flags & WNODE_FLAG_SINGLE_INSTANCE)
   {
       printf("WNODE_FLAG_SINGLE_INSTANCE\n");
   }
   
   if (Header.Flags & WNODE_FLAG_SINGLE_ITEM)
   {
       printf("WNODE_FLAG_SINGLE_ITEM\n");
   }
   
   if (Header.Flags & WNODE_FLAG_EVENT_ITEM)
   {
       printf("WNODE_FLAG_EVENT_ITEM\n");
   }
   
   if (Header.Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE)
   {
       printf("WNODE_FLAG_FIXED_INSTANCE_SIZE\n");
   }
   
   if (Header.Flags & WNODE_FLAG_TOO_SMALL)
   {
       printf("WNODE_FLAG_TOO_SMALL\n");
   }
   
   if (Header.Flags & WNODE_FLAG_INSTANCES_SAME)
   {
       printf("WNODE_FLAG_INSTANCES_SAME\n");
   }
   
   if (Header.Flags & WNODE_FLAG_INTERNAL)
   {
       printf("WNODE_FLAG_INTERNAL\n");
   }
   
   if (Header.Flags & WNODE_FLAG_USE_TIMESTAMP)
   {
       printf("WNODE_FLAG_USE_TIMESTAMP\n");
   }

   if (Header.Flags & WNODE_FLAG_TRACED_GUID)
   {
       printf("WNODE_FLAG_TRACED_GUID\n");
   }

   if (Header.Flags & WNODE_FLAG_EVENT_REFERENCE)
   {
       printf("WNODE_FLAG_EVENT_REFERENCE\n");
   }

   if (Header.Flags & WNODE_FLAG_ANSI_INSTANCENAMES)
   {
       printf("WNODE_FLAG_ANSI_INSTANCENAMES\n");
   }

   if (Header.Flags & WNODE_FLAG_METHOD_ITEM)
   {
       printf("WNODE_FLAG_METHOD_ITEM\n");
   }

   if (Header.Flags & WNODE_FLAG_PDO_INSTANCE_NAMES)
   {
       printf("WNODE_FLAG_PDO_INSTANCE_NAMES\n");
   }

   
   printf("\n");
}





//+----------------------------------------------------------
//
//  Function: PrintAllData
//
//  Descrip:  Prints a WNODE_ALL_DATA structure.
//
//  Returns:  VOID
//
//  Notes:    None
//
//  History:  04/08/97 drewm Created
//-----------------------------------------------------------
VOID
PrintAllData(
   IN  PWNODE_ALL_DATA Wnode
   )
{
DWORD    dwInstanceNum;
DWORD    dwByteCount;
DWORD    dwFlags;
DWORD    dwStructureNum = 1;
DWORD    dwTemp;
DWORD    dwInstanceSize;
LPDWORD  lpdwNameOffsets;
PBYTE    lpbyteData;
BOOL     bFixedSize = FALSE;
USHORT   usNameLength;
WCHAR    lpNameW[MAX_NAME_LENGTH];
CHAR     lpName[MAX_NAME_LENGTH];




   printf("\n\n");

   do{
      printf("\n\nPrinting WNODE_ALL_DATA structure %d.\n", dwStructureNum++);
      PrintHeader(Wnode->WnodeHeader);


      dwFlags = Wnode->WnodeHeader.Flags;
      if ( ! (dwFlags & WNODE_FLAG_ALL_DATA)) {
         printf("Not a WNODE_ALL_DATA structure\n");
         return;
      }
       
      // Check for fixed instance size
      //
      if ( dwFlags & WNODE_FLAG_FIXED_INSTANCE_SIZE )
      {
         dwInstanceSize = Wnode->FixedInstanceSize;
         bFixedSize = TRUE;
         lpbyteData = OffsetToPtr((PBYTE)Wnode, Wnode->DataBlockOffset);
         printf("Fixed size: 0x%x\n", dwInstanceSize);
      }


      //  Get a pointer to the array of offsets to the instance names
      //
      lpdwNameOffsets = (LPDWORD) OffsetToPtr(Wnode, Wnode->OffsetInstanceNameOffsets);


      //  Print out each instance name and data.  The name will always be
      //  in UNICODE so it needs to be translated to ASCII before it can be
      //  printed out.
      //
      for ( dwInstanceNum = 0; dwInstanceNum < Wnode->InstanceCount; dwInstanceNum++)
      {
         printf("Instance %d\n", 1 + dwInstanceNum);
         PrintCountedString( (LPTSTR)
                              OffsetToPtr( Wnode,
                                           lpdwNameOffsets[dwInstanceNum]) );

         //  Length and offset for variable data
         //
         if ( !bFixedSize)
         {
            dwInstanceSize = Wnode->OffsetInstanceDataAndLength[dwInstanceNum].
                                    LengthInstanceData;
            printf("Data size 0x%x\n", dwInstanceSize);
            lpbyteData = (PBYTE) OffsetToPtr(
                              (PBYTE)Wnode,
                              Wnode->OffsetInstanceDataAndLength[dwInstanceNum].
                                 OffsetInstanceData);
         }

         printf("Data:");

         for ( dwByteCount = 0; dwByteCount < dwInstanceSize;)
         {

            //  Print data in groups of DWORDS but allow for single bytes.
            //
            if ( (dwByteCount % 16) == 0)
            {
               printf("\n");
            }

            if ( (dwByteCount % 4) == 0)
            {
               printf(" 0x");
            }

            dwTemp = *((LPDWORD)lpbyteData);
            printf("%08x", dwTemp );
            lpbyteData += sizeof(DWORD);
            dwByteCount += sizeof(DWORD);

         }  // for cByteCount

         printf("\n\n");

      }     // for cInstanceNum


      //  Update Wnode to point to next node
      //
      if ( Wnode->WnodeHeader.Linkage != 0)
      {
         Wnode = (PWNODE_ALL_DATA) OffsetToPtr( Wnode, Wnode->WnodeHeader.Linkage);
      }
      else
      {
         Wnode = 0;
      }

   }while(Wnode != 0);

}






//+----------------------------------------------------------
//
//  Function: PrintSingleInstance
//
//  Descrip:  Prints a WNODE_SINGLE_INSTANCE structure.
//
//  Returns:  VOID
//
//  Notes:    None
//
//  History:  04/08/97 drewm Created
//-----------------------------------------------------------
VOID PrintSingleInstance(
   IN  PWNODE_SINGLE_INSTANCE Wnode
   )
{
DWORD    dwByteCount;
DWORD    dwFlags;
LPDWORD  lpdwData;
USHORT   usNameLength;
WCHAR    lpNameW[MAX_NAME_LENGTH];
CHAR     lpName[MAX_NAME_LENGTH];

   dwFlags = Wnode->WnodeHeader.Flags;


   if ( ! (dwFlags & WNODE_FLAG_SINGLE_INSTANCE))
   {
      printf("Not a WNODE_SINGLE_INSTANCE structure\n");
      return;
   }

   printf("\nPrinting WNODE_SINGLE_INSTANCE.\n");
   PrintHeader(Wnode->WnodeHeader);



   // Print name or index number
   //
   if ( dwFlags & WNODE_FLAG_STATIC_INSTANCE_NAMES )
   {
      printf("Instance index: %d\n", Wnode->InstanceIndex);
   }
   usNameLength = * (USHORT *) OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
   printf("Name length 0x%x\n", usNameLength);
   usNameLength /= 2;
   PrintCountedString( (LPTSTR) OffsetToPtr( Wnode,
                                             Wnode->OffsetInstanceName) );


//   wcscpy(lpNameW, (LPWSTR) (OffsetToPtr(Wnode, Wnode->OffsetInstanceName )
//                                     + sizeof(USHORT)));
//   wcsncpy( lpNameW + usNameLength, L" ", 2);
//   wcstombs( lpName, lpNameW, 300);
//   printf("%s\n", lpName);



   //  Print out the Data
   //
   printf("Data:\n");
   printf("Data Size: 0x%x\n", Wnode->SizeDataBlock);
   lpdwData = (PULONG) OffsetToPtr(Wnode, Wnode->DataBlockOffset);

   for ( dwByteCount = 0; dwByteCount < Wnode->SizeDataBlock; dwByteCount+= sizeof(ULONG))
   {
      if ( (dwByteCount % 16) == 0)
      {
         printf("\n");
      }

      printf("0x%08x ", *lpdwData );
      lpdwData++;

   }


   printf("\n");


}  //  PrintSingleInstance

VOID
PrintCountedString(
   LPTSTR   lpString
   )
{
   SHORT    usNameLength;
   LPTSTR   lpStringPlusNull;

   usNameLength = * (USHORT *) lpString;

   lpStringPlusNull = (LPTSTR) malloc ( usNameLength + sizeof(TCHAR) );
   if (lpStringPlusNull != NULL)
   {
      lpString = (LPTSTR) ((PBYTE)lpString + sizeof(USHORT));
      if (MyIsTextUnicode(lpString))
      {
         usNameLength /= 2;
      }
      _tcsncpy( lpStringPlusNull, lpString, usNameLength );

      _tcscpy( lpStringPlusNull + usNameLength, __T("") );
      _tprintf(__T("%s\n"), lpStringPlusNull);

      free(lpStringPlusNull);
   }

}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\enumgdlg.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Revision History:

--*/

// EnumGuidDlg.h : header file
//

#if !defined(AFX_ENUMGUIDDLG_H__272A54ED_8D57_11D1_9904_006008C3A19A__INCLUDED_)
#define AFX_ENUMGUIDDLG_H__272A54ED_8D57_11D1_9904_006008C3A19A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CEnumGuidDlg dialog

class CEnumGuidDlg : public CDialog
{
// Construction
public:
	CEnumGuidDlg(CWnd* pParent = NULL);	// standard constructor
	virtual  ~CEnumGuidDlg();

// Dialog Data
	//{{AFX_DATA(CEnumGuidDlg)
	enum { IDD = IDD_ENUMGUID_DIALOG };
	CListBox	guidList;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEnumGuidDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	LPGUID GetSelectedGuid();
	void ListGuids();
	int EnumerateGuids();

	HICON m_hIcon;
	LPGUID guids;
	ULONG guidsCount;

	// Generated message map functions
	//{{AFX_MSG(CEnumGuidDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnQueryFull();
	afx_msg void OnQuerySingle();
	afx_msg void OnSetSingleInstance();
	afx_msg void OnSetSingleItem();
	afx_msg void OnReenumerateGuids();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ENUMGUIDDLG_H__272A54ED_8D57_11D1_9904_006008C3A19A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\resource.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Revision History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by EnumGuid.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_ENUMGUID_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDD_ALL_DATA                    129
#define IDD_SELECT_INSTANCE             131
#define IDD_SET_INSTANCE_DATA           132
#define IDD_SET_INSTANCE_DATA_MANY      133
#define IDC_GUID_LIST                   1000
#define IDC_QUERY_FULL                  1001
#define IDC_QUERY_SINGLE                1002
#define IDC_SET_SINGLE_INSTANCE         1003
#define IDC_SET_SINGLE_ITEM             1004
#define IDC_REENUMERATE_GUIDS           1005
#define IDC_DATA                        1006
#define IDC_INSTANCE_LIST               1007
#define IDC_VERSION                     1009
#define IDC_ITEM                        1010

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\eguid.c ===
/************STARTDOC*********************************************************
*
* Copyright (c) 1997-1999  Microsoft Corporation
*   mofcall.c
*
*   This file contains the functions used to gather infomation about
*   the various wmi providers registered with the system.  Infomation
*   can be gathered from the .mof file.  Then this information can be
*   used to query the actual provider.
*
*
*   Modification History:
*   --------------------
*
*     Drew McDaniel (drewm)  - Sept. 16, 1997 - Original Source
*
*
*************ENDDOC**********************************************************/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ole2.h>
#include <wmium.h>
#include <tchar.h>
#include "print.h"

//  Defined constants
//
#define MAX_DATA 200


//  Modular Data
//


//  Function Prototypes
//
extern ULONG
WMIAPI
WmiEnumerateGuids(
    OUT LPGUID GuidList,
    IN OUT ULONG *GuidCount
    );


BOOL
PrintAllGuids(
   LPGUID *GuidList,
   LPDWORD lpdwGuidCount
   );

DWORD
GetGuidList(
   OUT LPGUID *ppGuidList
   );

VOID
UseGuid(
   LPGUID   lpGuid
   );

VOID
QueryWnodeAllData(
   LPGUID   lpGuid
   );

VOID
QueryWnodeSingleInstance(
   LPGUID   lpGuid
   );

VOID
SetWnodeSingleInstance(
   LPGUID   lpGuid
   );

VOID
SetWnodeSingleItem(
   LPGUID   lpGuid
   );


//+----------------------------------------------------------
//
//  Function:  Main
//
//  Descrip:   This is the starting function.  It will call
//             a routine to print all of the guids and a short
//             description.  Then the user may select one of
//             the guids and get more mof infomation, call one
//             of the WMI query APIs, or call one of the WMI set
//             APIs
//
//  Returns:   Only returns upon program exit
//
//  Notes:     Initially this is just going to be a text based
//             tool.  The hope is that this could later be
//             modified into a (possibly more useful) GUI based
//             tool.
//
//  History:   09/16/97 drewm Created
//-----------------------------------------------------------
int _cdecl main(int argc, LPSTR *argv[])
{
   DWORD    dwRet = 0;
   LPGUID   GuidList = NULL;
   DWORD    dwGuidCount = 0;
   DWORD    dwResponse = 0;
   DWORD    dwGuidIndex = 0;
   BOOL     bContinue = TRUE;


   while (bContinue == TRUE)
   {
      //  Print all of the registered guids
      //
      PrintAllGuids(&GuidList, &dwGuidCount);


      //  Check to see which guid to query
      //
      printf("\n\nSelect a guid to examine (0 to exit): ");
      scanf("%u", &dwResponse);
      printf("\n\n");

      if (dwResponse == 0)
      {
         bContinue = FALSE;
      }
      else
      {
         dwGuidIndex = dwResponse - 1;

         if (dwGuidIndex < dwGuidCount)
         {
            //  Clear screen and then allow the user to play
            //  with the selected guid.
            //
            UseGuid( &(GuidList[dwGuidIndex]) );
         }
         else
         {
            printf("Invalid guid %u\n", dwResponse);
            Sleep (2000);
            ClearScreen();
         }
      }


      //  Free the list of guids to clean up for the next call
      //
      if (GuidList != NULL)
      {
         free(GuidList);
         GuidList = NULL;
      }

   }

   return(TRUE);

}





//+----------------------------------------------------------
//
//  Function:  PrintAllGuids
//
//  Descrip:   First we get a list of all of the guids register
//             with the system.  This list is based on the
//             information that a provider exposes in its .mof
//             file.  If a providers .mof file is incorrect or
//             if the provider does not have a .mof file then
//             its guids will not be accessable by this program.
//
//  Returns:   TRUE always
//
//  Notes:     If no guids are registered then this app will
//             be terminated.
//
//  History:   09/16/97 drewm Created
//-----------------------------------------------------------
BOOL
PrintAllGuids(
   LPGUID *GuidList,
   LPDWORD lpdwGuidCount
   )
{
   UINT  index;


   //  Get the list of guids.  Exit if no guids are registered.
   //
   *lpdwGuidCount = GetGuidList( GuidList );
   if (*lpdwGuidCount == 0)
   {
      printf("No Guids are registered\n");
      exit(0);
   }


   //  Print each guid index, actual guid, and the description
   //  of the guid.
   //
   for (index = 0; index < *lpdwGuidCount; index++)
   {
      printf("Guid %u: ", index + 1);
      PrintGuid(&((*GuidList)[index]));
      printf("\n");
//No Mof Stuff
//      PrintDescription(&((*GuidList)[index]));
      printf("\n");
   }

   return (TRUE);
}





//+----------------------------------------------------------
//
//  Function:  GetGuidList
//
//  Descrip:   This function will first query to determine how
//             many WMI guids are currently registered.  Then
//             it will allocate space for the guids and query
//             the system for the actual list of guids.
//
//  Returns:   The number of guids registered on the system based
//             on the infomation provided in each providers .mof
//             file.
//
//  Notes:     None
//
//  History:   09/16/97 drewm Created
//-----------------------------------------------------------
DWORD
GetGuidList(
   OUT LPGUID *ppGuidList
   )
{
   DWORD    dwGuidCount = 0;
   DWORD    dwRet;
   GUID     Guid;

   //  Determine the present number of guids registered
   //
   dwRet = WmiEnumerateGuids( &Guid,
                              &dwGuidCount);
   if (dwRet != ERROR_MORE_DATA)
   {
      printf("Call to determine number of Guids failed. (%u)\n", dwRet);
      return (0);
   }


   //  Return if there are no guids registered
   //
   if (dwGuidCount != 0)
   {
      //  Allocate buffer for Guids.  Note:  we will allocate room for
      //  and extra 10 Guids in case new Guids were registed between the
      //  previous call to WMIMofEnumeratGuid, and the next call.
      //
      dwGuidCount += 10;
      *ppGuidList = (LPGUID) malloc (dwGuidCount * sizeof(GUID));
      if (*ppGuidList == NULL)
      {
         printf("Out of Memory Failure.  Unable to allocate memory"
                     " for guid list array\n");
         return (0);
      }


      //  Get the list of Guids
      //
      dwRet = WmiEnumerateGuids( *ppGuidList,
                                 &dwGuidCount);
      if ((dwRet != ERROR_SUCCESS) && (dwRet != ERROR_MORE_DATA))
      {
         printf("Failure to get guid list. (%u)\n", dwRet);
         return 0;
      }
   }

   return (dwGuidCount);

}  //  GetGuidList




//+----------------------------------------------------------
//
//  Function:  UseGuid
//
//  Descrip:   This function will ask the user what operation
//             they would like to do to the selected guid.
//
//  Returns:   VOID
//
//  Notes:     None
//
//  History:   09/16/97 drewm Created
//-----------------------------------------------------------
VOID
UseGuid(
   LPGUID   lpGuid
   )
{
   DWORD    dwSelection = 0;



   while (1)
   {
      ClearScreen();

      printf("Guid: ");
      PrintGuid( lpGuid );
      printf("\n");

      printf("1.) Query for the full Wnode\n");
      printf("2.) Query a single instance\n");
      printf("3.) Set a single instance\n");
      printf("4.) Set a single item\n");
      printf("0.) Back to previous screen\n");

      printf("\nMake selection: ");
      scanf("%u", &dwSelection );
      printf("\n");


      switch (dwSelection)
      {
      case 0:
         ClearScreen();
         return;

      case 1:
         ClearScreen();
         QueryWnodeAllData( lpGuid );
         break;

      case 2:
         ClearScreen();
         QueryWnodeSingleInstance( lpGuid );
         break;

      case 3:
         ClearScreen();
         SetWnodeSingleInstance( lpGuid );
         break;

      case 4:
         ClearScreen();
         SetWnodeSingleItem( lpGuid );
         break;

      default:
         printf("Invalid Selection.\n");
         WaitForUser();
         break;
      }
   }
}  //  UseGuid






//+----------------------------------------------------------
//
//  Function:  SelectInstanceName
//
//  Descrip:   This function will prompt the user to select one of the
//             instances of the guid to use.
//
//  Returns:   VOID
//
//  Notes:     None
//
//  History:   09/16/97 drewm Created
//-----------------------------------------------------------
SelectInstanceName(
   LPGUID   lpGuid,
   LPTSTR   lpInstanceName,
   LPDWORD  lpdwNameSize
   )
{
   HANDLE   hDataBlock;
   BYTE     Buffer[4096];
   DWORD    dwBufferSize = 4096;
   DWORD    dwRet;
   DWORD    dwInstanceNumber;
   LPDWORD  NameOffsets;
   BOOL     bContinue = TRUE;
   USHORT   usNameSize;
   UINT     iLoop;
   LPTSTR   lpStringLocal;
   PWNODE_ALL_DATA   pWnode;

   //  Get the entire Wnode
   //
   dwRet = WmiOpenBlock( lpGuid,
                         0,
                         &hDataBlock
                       );
   if (dwRet == ERROR_SUCCESS)
   {
      dwRet = WmiQueryAllData( hDataBlock,
                               &dwBufferSize,
                               Buffer);
      if ( dwRet == ERROR_SUCCESS)
      {
         WmiCloseBlock(hDataBlock);
      }
      else
      {
         printf("WMIQueryAllData returned error: %d\n", dwRet);
      }
   }
   else
   {
      printf("Unable to open data block (%u)\n", dwRet);
   }


   if (dwRet != ERROR_SUCCESS)
   {
      return (dwRet);
   }


   //  Print Each Instance
   //
   pWnode = (PWNODE_ALL_DATA) Buffer;
   NameOffsets = (LPDWORD) OffsetToPtr( pWnode, 
                                        pWnode->OffsetInstanceNameOffsets );
   for (iLoop = 0; iLoop < pWnode->InstanceCount; iLoop++)
   {
      printf("Instance %u: ", iLoop);
      PrintCountedString( (LPTSTR) OffsetToPtr( pWnode, NameOffsets[iLoop]) );
   }


   //  Select a specific instance
   //
   while (bContinue == TRUE)
   {
      printf("Select an instance: ");
      scanf("%u", &dwInstanceNumber);
      printf("\n");

      if (dwInstanceNumber >= iLoop)
      {
         printf("Invalid selection\n\n");
         WaitForUser();
         printf("\n\n");
      }
      else
      {
         bContinue = FALSE;
      }
   }


   //  Check the size of the input buffer
   //
   lpStringLocal = (LPTSTR) OffsetToPtr( pWnode, NameOffsets[dwInstanceNumber] );
   usNameSize = * ((USHORT *) lpStringLocal);
   lpStringLocal = (LPTSTR) ((PBYTE)lpStringLocal + sizeof(USHORT));
   if (*lpdwNameSize < (usNameSize + sizeof(TCHAR)))
   {
      *lpdwNameSize = usNameSize + sizeof(TCHAR);
      return (ERROR_INSUFFICIENT_BUFFER);
   }


   //  Copy the instance name over to the output parameter.
   //  Also, a null character needs to be added to the end of
   //  the string because the counted string may not contain a
   //  NULL character.
   //
   if (MyIsTextUnicode(lpStringLocal))
   {
      usNameSize /= 2;
   }
   _tcsncpy( lpInstanceName, lpStringLocal, usNameSize );
   lpInstanceName += usNameSize;
   _tcscpy( lpInstanceName, __T(""));

   return (ERROR_SUCCESS);

}  //  SelectInstanceName




//+----------------------------------------------------------
//
//  Function:  QueryWnodeAllData
//
//  Descrip:   This function will query the wnode and then
//             print out the wnode.
//
//  Returns:   VOID
//
//  Notes:     None
//
//  History:   09/16/97 drewm Created
//-----------------------------------------------------------
VOID
QueryWnodeAllData(
   LPGUID   lpGuid
   )
{
  HANDLE          hDataBlock;
  DWORD           dwRet;
  PBYTE           Buffer;
  ULONG           dwBufferSize = 4096;
  PWNODE_ALL_DATA pWnode;


   //  Open the wnode
   //
   dwRet = WmiOpenBlock( lpGuid,
                         0,
                         &hDataBlock
                       );
   if (dwRet != ERROR_SUCCESS)
   {
      printf("Unable to open data block (%u)\n", dwRet);
      WaitForUser();
      return;
   }

   //  Allocate an initial buffer
   //
   Buffer = (PBYTE) malloc ( dwBufferSize );
   if (Buffer != NULL)
   {
      //  Query the data block
      //
      dwRet = WmiQueryAllData( hDataBlock,
                               &dwBufferSize,
                               Buffer);
      if (dwRet == ERROR_INSUFFICIENT_BUFFER)
      {
         #ifdef DBG
         printf("Initial buffer too small reallocating to %u\n", dwBufferSize);
         #endif
         Buffer = (PBYTE) realloc (Buffer, dwBufferSize);
         if (Buffer != NULL)
         {
            dwRet = WmiQueryAllData( hDataBlock,
                                     &dwBufferSize,
                                     Buffer);

         }
         else
         {
             printf("Reallocation failed\n");
         }
      }
      if ( dwRet == ERROR_SUCCESS )
      {
         pWnode = (PWNODE_ALL_DATA) Buffer;

         PrintAllData(pWnode);
         WmiCloseBlock(hDataBlock);
      }
      else
      {
         printf("WMIQueryAllData returned error: %d\n", dwRet);
      }
   }
   else
   {
      printf("Out of Memory Error.  Unable to allocate buffer of size %u\n",
                  dwBufferSize );
   }

   WmiCloseBlock( hDataBlock );
   WaitForUser ();
   return;

}  //  QueryWnodeAllData





//+----------------------------------------------------------
//
//  Function:  QueryWnodeSingleInstance
//
//  Descrip:   This function will query the wnode and then
//             print out the wnode.
//
//  Returns:   VOID
//
//  Notes:     None
//
//  History:   09/16/97 drewm Created
//-----------------------------------------------------------
VOID
QueryWnodeSingleInstance(
   LPGUID   lpGuid
   )
{
   HANDLE   hDataBlock;
   DWORD    dwRet;
   TCHAR    Buffer[MAX_PATH];
   DWORD    dwBufferSize = MAX_PATH;
   LPTSTR   lpInstanceName;
   PWNODE_SINGLE_INSTANCE  pWnode;


   //  Have the user select one of the instances of a particular guid to use.
   //
   dwRet = SelectInstanceName( lpGuid,
                               Buffer,
                               &dwBufferSize
                             );
   if (dwRet != ERROR_SUCCESS)
   {
      return;
   }


   lpInstanceName = (TCHAR *) malloc (dwBufferSize * sizeof(TCHAR));
   if (lpInstanceName == NULL)
   {
      printf("Out of Memory Error\n");
      WaitForUser();
      return;
   }
   else
   {
      _tcscpy( lpInstanceName, Buffer );
      dwBufferSize = 4096;
   }


   //  Open the wnode
   //
   dwRet = WmiOpenBlock( lpGuid,
                         0,
                         &hDataBlock
                       );
   if (dwRet != ERROR_SUCCESS)
   {
      printf("Unable to open data block (%u)\n", dwRet);
      WaitForUser();
      return;
   }


   //  Query the data block
   //
   dwRet = WmiQuerySingleInstance( hDataBlock,
                                   lpInstanceName,
                                   &dwBufferSize,
                                   Buffer);
   if ( dwRet != ERROR_SUCCESS)
   {
      printf("WmiQuerySingleInstance returned error: %d\n", dwRet);
      WmiCloseBlock( hDataBlock );
      WaitForUser();
      return;
   }

   pWnode = (PWNODE_SINGLE_INSTANCE) Buffer;

   PrintSingleInstance(pWnode);
   WaitForUser();

   WmiCloseBlock(hDataBlock);

   return;

}





//+----------------------------------------------------------
//
//  Function:  SetWnodeSingleInstance
//
//  Descrip:   This function will query the wnode and then
//             print out the wnode.
//
//  Returns:   VOID
//
//  Notes:     None
//
//  History:   09/16/97 drewm Created
//-----------------------------------------------------------
VOID
SetWnodeSingleInstance(
   LPGUID   lpGuid
   )
{
   DWORD    dwRet;
   DWORD    dwVersionNumber;
   DWORD    dwData[MAX_DATA];
   DWORD    dwDataSize;
   UINT     iLoop;
   LPTSTR   lpInstanceName;
   TCHAR    Buffer[MAX_PATH];
   DWORD    dwBufferSize = MAX_PATH;
   HANDLE   hDataBlock;

   

   //  Get the instance to set
   //
   dwRet = SelectInstanceName( lpGuid,
                               Buffer,
                               &dwBufferSize
                             );
   if (dwRet != ERROR_SUCCESS)
   {
      return;
   }

   lpInstanceName = (TCHAR *) _alloca (dwBufferSize * sizeof(TCHAR));
   _tcscpy( lpInstanceName, Buffer );
   dwBufferSize = 4096;
   


   //  Get the version number
   //
   printf("What is the version number you would like to use? ");
   scanf("%u", &dwVersionNumber);
   printf("\n");

   
   //  Get the size of the data to set
   //
   printf("How many dwords is your data? ");
   scanf("%u", &dwDataSize);
   printf("\n");

   if (dwDataSize > MAX_DATA)
   {
      printf("Unable to handle large data\n");
      return;
   }


   //  Get the data
   //
   for (iLoop = 0; iLoop < dwDataSize; iLoop++)
   {
      printf("Enter DWORD %u, in hex: ", iLoop);
      scanf("%x", &(dwData[iLoop]));
      printf("\n");
   }
   printf("\n");


   //  Open the wnode
   //
   dwRet = WmiOpenBlock( lpGuid,
                         0,
                         &hDataBlock
                       );
   if (dwRet != ERROR_SUCCESS)
   {
      printf("Unable to open data block (%u)\n", dwRet);
      WaitForUser();
      return;
   }


   //  Set the data
   //
   printf("Setting Instance: %s\n", lpInstanceName);
   printf("Data: ");
   for (iLoop = 0; iLoop < dwDataSize; iLoop++)
   {
      printf("0x%x ", dwData[iLoop]);
   }
   printf("\n");

   dwRet = WmiSetSingleInstance( hDataBlock,
                                 lpInstanceName,
                                 dwVersionNumber, 
                                 dwDataSize * sizeof(DWORD),
                                 dwData );

   if ( dwRet != ERROR_SUCCESS)
   {
      printf("WMISetSingleInstance returned error: %d\n", dwRet);
   }
   else
   {
      printf("Set Success\n\n");
   }

   WmiCloseBlock( hDataBlock );

   WaitForUser();
  
}





//+----------------------------------------------------------
//
//  Function:  SetWnodeSingleItem
//
//  Descrip:   This function will query the wnode and then
//             print out the wnode.
//
//  Returns:   VOID
//
//  Notes:     None
//
//  History:   09/16/97 drewm Created
//-----------------------------------------------------------
VOID
SetWnodeSingleItem(
   LPGUID   lpGuid
   )
{

   DWORD    dwRet;
   DWORD    dwVersionNumber;
   DWORD    dwItemNumber;
   DWORD    dwData;
   DWORD    dwDataSize;
   UINT     iLoop;
   LPTSTR   lpInstanceName;
   TCHAR    Buffer[MAX_PATH];
   DWORD    dwBufferSize = MAX_PATH;
   HANDLE   hDataBlock;

   

   //  Get the instance to set
   //
   dwRet = SelectInstanceName( lpGuid,
                               Buffer,
                               &dwBufferSize
                             );
   if (dwRet != ERROR_SUCCESS)
   {
      return;
   }

   lpInstanceName = (TCHAR *) _alloca (dwBufferSize * sizeof(TCHAR));
   _tcscpy( lpInstanceName, Buffer );
   dwBufferSize = 4096;
   


   //  Get the version number
   //
   printf("What is the version number you would like to use? ");
   scanf("%u", &dwVersionNumber);
   printf("\n");


   //  Get the item number
   //
   printf("What is the item number you would like to set? ");
   scanf("%u", &dwItemNumber);
   printf("\n");


   
   //  Get the data
   //
   printf("Enter data (must be a DWORD in hex): ");
   scanf("%x", &dwData);
   printf("\n");
   printf("\n");


   //  Open the wnode
   //
   dwRet = WmiOpenBlock( lpGuid,
                         0,
                         &hDataBlock
                       );
   if (dwRet != ERROR_SUCCESS)
   {
      printf("Unable to open data block (%u)\n", dwRet);
      WaitForUser();
      return;
   }


   //  Set the data
   //
   printf("Setting Instance: %s\n", lpInstanceName);
   printf("Data: 0x%x\n\n", dwData);
   dwRet = WmiSetSingleItem( hDataBlock,
                             lpInstanceName,
                             dwItemNumber,
                             dwVersionNumber, 
                             sizeof(DWORD),
                             &dwData );

   if ( dwRet != ERROR_SUCCESS)
   {
      printf("WMISetSingleInstance returned error: %d\n", dwRet);
   }
   else
   {
      printf("Set Success\n\n");
   }

   WmiCloseBlock( hDataBlock );

   WaitForUser();
  
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\seldatam.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Revision History:

--*/

// SelectInstanceDataMany.cpp : implementation file
//

#include "stdafx.h"
#include "EnumGuid.h"
#include "SelDataM.h"

#include "wmihlp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSelectInstanceDataMany dialog


CSelectInstanceDataMany::CSelectInstanceDataMany(LPDWORD lpVersion, 
    LPDWORD lpDataSize, LPDWORD dwData, DWORD dwDataSize, CWnd* pParent /*=NULL*/)
	: CDialog(CSelectInstanceDataMany::IDD, pParent), lpVersion(lpVersion),
    lpDataSize(lpDataSize), dwData(dwData), dwDataSize(dwDataSize)
{
	//{{AFX_DATA_INIT(CSelectInstanceDataMany)
	valVersion = 0;
	//}}AFX_DATA_INIT
}


void CSelectInstanceDataMany::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectInstanceDataMany)
	DDX_Control(pDX, IDC_DATA, txtData);
	DDX_Text(pDX, IDC_VERSION, valVersion);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectInstanceDataMany, CDialog)
	//{{AFX_MSG_MAP(CSelectInstanceDataMany)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectInstanceDataMany message handlers

void CSelectInstanceDataMany::OnOK() 
{
    CString txt, msg;
    TCHAR   buf[1024];
    int i, numLines, nullLoc;

    UpdateData();
    *lpVersion = valVersion;

    if ((DWORD)(numLines = txtData.GetLineCount()) > dwDataSize) {
        msg.Format(_T("You have entered too many DWORDS.  Up to %d are allowed\n"),
                   dwDataSize);
        MessageBox(msg);
        return;
    }

    for (i = 0; i < numLines; i++) {
        nullLoc = txtData.GetLine(i, buf);
        buf[nullLoc] = 0;

        txt = buf;
        if (!ValidHexText(this, txt, dwData + i, i+1)) 
            return;
    }

    *lpDataSize = (DWORD) numLines;
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\seldata.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Revision History:

--*/

#if !defined(AFX_SELECTINSTANCEDATA_H__7945EB37_8E04_11D1_9906_006008C3A19A__INCLUDED_)
#define AFX_SELECTINSTANCEDATA_H__7945EB37_8E04_11D1_9906_006008C3A19A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SelectInstanceData.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSelectInstanceData dialog

class CSelectInstanceData : public CDialog
{
// Construction
public:
	CSelectInstanceData(LPDWORD lpData, LPDWORD lpItem, LPDWORD lpVersion, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSelectInstanceData)
	enum { IDD = IDD_SET_INSTANCE_DATA };
	CEdit	txtData;
	UINT	valItem;
	UINT	valVersion;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectInstanceData)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	LPDWORD lpData;
	LPDWORD lpItem;
	LPDWORD lpVersion;

	// Generated message map functions
	//{{AFX_MSG(CSelectInstanceData)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SELECTINSTANCEDATA_H__7945EB37_8E04_11D1_9906_006008C3A19A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\seldatam.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Revision History:

--*/

#if !defined(AFX_SELECTINSTANCEDATAMANY_H__7945EB38_8E04_11D1_9906_006008C3A19A__INCLUDED_)
#define AFX_SELECTINSTANCEDATAMANY_H__7945EB38_8E04_11D1_9906_006008C3A19A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SelectInstanceDataMany.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSelectInstanceDataMany dialog

class CSelectInstanceDataMany : public CDialog
{
// Construction
public:
	CSelectInstanceDataMany(LPDWORD lpVersion, LPDWORD lpDataSize, LPDWORD dwData,
                            DWORD dwDataSize, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSelectInstanceDataMany)
	enum { IDD = IDD_SET_INSTANCE_DATA_MANY };
	CEdit	txtData;
	long	valVersion;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectInstanceDataMany)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	DWORD dwDataSize;
	LPDWORD dwData;
	LPDWORD lpVersion;
	LPDWORD lpDataSize;

	// Generated message map functions
	//{{AFX_MSG(CSelectInstanceDataMany)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SELECTINSTANCEDATAMANY_H__7945EB38_8E04_11D1_9906_006008C3A19A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\selname.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Revision History:

--*/

// SelectInstanceName.cpp : implementation file
//

#include "stdafx.h"
#include "EnumGuid.h"
#include "SelName.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "wmihlp.h"

/////////////////////////////////////////////////////////////////////////////
// CSelectInstanceName dialog


CSelectInstanceName::CSelectInstanceName(LPGUID   lpGuid,
   PTCHAR lpInstanceName, LPDWORD  lpSize, CWnd* pParent /*=NULL*/)
	: CDialog(CSelectInstanceName::IDD, pParent), lpGuid(lpGuid),
    buffer(lpInstanceName), lpSize(lpSize)
{
	//{{AFX_DATA_INIT(CSelectInstanceName)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CSelectInstanceName::~CSelectInstanceName()
{
    lpGuid = 0;
    buffer = 0;
    lpSize = 0;
}

void CSelectInstanceName::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectInstanceName)
	DDX_Control(pDX, IDC_INSTANCE_LIST, lstInstance);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectInstanceName, CDialog)
	//{{AFX_MSG_MAP(CSelectInstanceName)
	ON_LBN_DBLCLK(IDC_INSTANCE_LIST, OnDblclkInstanceList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectInstanceName message handlers

BOOL CSelectInstanceName::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	EnumerateInstances();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

DWORD CSelectInstanceName::Select()
{
    DoModal();

    return dwError;
}

void CSelectInstanceName::EnumerateInstances()
{
    HANDLE   hDataBlock;
    BYTE     *BufferPtr;
    DWORD    dwBufferSize = 0x8000;
    UINT     iLoop;
    CString  tmp;
    UINT     iCount = 0;

    //  Get the entire Wnode
    //
    dwError = WmiOpenBlock(lpGuid, 0, &hDataBlock);

    if (dwError == ERROR_SUCCESS) {
        dwError = WmiQueryAllData(hDataBlock,
                                  &dwBufferSize,
                                  XyzBuffer);
        if (dwError == ERROR_SUCCESS) {
            WmiCloseBlock(hDataBlock);
        }
        else {
            tmp.Format(_T("WMIQueryAllData returned error: %d"), dwError);
            lstInstance.AddString(tmp);
        }
    }
    else {
        tmp.Format(_T("Unable to open data block (%u)"), dwError);
        lstInstance.AddString(tmp);
    }


    if (dwError != ERROR_SUCCESS) {
        return;
    }

    BufferPtr = XyzBuffer;
    while (BufferPtr != NULL)
    {
        //  Print Each Instance
        //
        pWnode = (PWNODE_ALL_DATA) BufferPtr;
        nameOffsets = (LPDWORD) OffsetToPtr(pWnode, 
                                        pWnode->OffsetInstanceNameOffsets);
        for (iLoop = 0; iLoop < pWnode->InstanceCount; iLoop++) {
            tmp.Format(_T("Instance %u: "), iCount);
            PrintCountedString( (LPTSTR) OffsetToPtr( pWnode, nameOffsets[iLoop]), tmp );
	    namePtr[iCount++] = (LPTSTR)OffsetToPtr( pWnode, nameOffsets[iLoop]);
            lstInstance.AddString(tmp);
        }
	if (pWnode->WnodeHeader.Linkage == 0) 
	{
            BufferPtr = NULL;
	} else {
            BufferPtr += pWnode->WnodeHeader.Linkage;
	}
    }

    lstInstance.SetCurSel(0);
}

void CSelectInstanceName::OnOK() 
{
    USHORT   usNameSize;
    LPTSTR   lpStringLocal;

    if (dwError == ERROR_SUCCESS) {
        //  Check the size of the input buffer
        //
        lpStringLocal = (LPTSTR) namePtr[lstInstance.GetCurSel()];
        usNameSize = * ((USHORT *) lpStringLocal);
        lpStringLocal = (LPTSTR) ((PBYTE)lpStringLocal + sizeof(USHORT));
        
        if (*lpSize < (usNameSize + sizeof(TCHAR))) {
            *lpSize = usNameSize + sizeof(TCHAR);
            dwError = ERROR_INSUFFICIENT_BUFFER;
        }


        //  Copy the instance name over to the output parameter.
        //  Also, a null character needs to be added to the end of
        //  the string because the counted string may not contain a
        //  NULL character.
        //
        if (MyIsTextUnicode(lpStringLocal)) {
            usNameSize /= 2;
        }

        _tcsncpy(buffer, lpStringLocal, usNameSize );
        buffer += usNameSize;
        _tcscpy(buffer, __T(""));
    }

    CDialog::OnOK();
}

void CSelectInstanceName::OnDblclkInstanceList() 
{
    OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\selname.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Revision History:

--*/

#if !defined(AFX_SELECTINSTANCENAME_H__CB4E370C_8DD5_11D1_9905_006008C3A19A__INCLUDED_)
#define AFX_SELECTINSTANCENAME_H__CB4E370C_8DD5_11D1_9905_006008C3A19A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SelectInstanceName.h : header file
//

#pragma warning (once : 4200)
#include <wmium.h>

/////////////////////////////////////////////////////////////////////////////
// CSelectInstanceName dialog

class CSelectInstanceName : public CDialog
{
// Construction
public:
	virtual  ~CSelectInstanceName();
	LPDWORD nameOffsets;
	LPTSTR namePtr[0x100];
        BYTE     XyzBuffer[0x8000];
	DWORD Select();
	CSelectInstanceName(LPGUID lpGuid, PTCHAR lpInstanceName, LPDWORD  lpSize, CWnd* pParent /*=NULL*/);

// Dialog Data
	//{{AFX_DATA(CSelectInstanceName)
	enum { IDD = IDD_SELECT_INSTANCE };
	CListBox	lstInstance;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectInstanceName)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	PWNODE_ALL_DATA pWnode;
	void EnumerateInstances();
	DWORD dwError;
	PTCHAR buffer;
	LPGUID lpGuid;
	LPDWORD lpSize;

	// Generated message map functions
	//{{AFX_MSG(CSelectInstanceName)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnDblclkInstanceList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SELECTINSTANCENAME_H__CB4E370C_8DD5_11D1_9905_006008C3A19A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\seldata.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Revision History:

--*/

// SelectInstanceData.cpp : implementation file
//

#include "stdafx.h"
#include "EnumGuid.h"
#include "SelData.h"
#include "wmihlp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSelectInstanceData dialog


CSelectInstanceData::CSelectInstanceData(LPDWORD lpData, LPDWORD lpItem, LPDWORD lpVersion, CWnd* pParent /*=NULL*/)
	: CDialog(CSelectInstanceData::IDD, pParent), lpData(lpData), lpItem(lpItem), lpVersion(lpVersion)
{
	//{{AFX_DATA_INIT(CSelectInstanceData)
	valItem = 0;
	valVersion = 0;
	//}}AFX_DATA_INIT
}


void CSelectInstanceData::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectInstanceData)
	DDX_Control(pDX, IDC_DATA, txtData);
	DDX_Text(pDX, IDC_ITEM, valItem);
	DDV_MinMaxUInt(pDX, valItem, 0, 255);
	DDX_Text(pDX, IDC_VERSION, valVersion);
	DDV_MinMaxUInt(pDX, valVersion, 0, 255);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectInstanceData, CDialog)
	//{{AFX_MSG_MAP(CSelectInstanceData)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectInstanceData message handlers

void CSelectInstanceData::OnOK() 
{
    CString txt;

    UpdateData(TRUE);
    *lpVersion = valVersion;
    *lpItem = valItem;

    txtData.GetWindowText(txt);
    if (!ValidHexText(this, txt, lpData))
        return;

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\stdafx.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Revision History:

--*/

// stdafx.cpp : source file that includes just the standard includes
//	EnumGuid.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\stdafx.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Revision History:

--*/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__272A54EF_8D57_11D1_9904_006008C3A19A__INCLUDED_)
#define AFX_STDAFX_H__272A54EF_8D57_11D1_9904_006008C3A19A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__272A54EF_8D57_11D1_9904_006008C3A19A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\fchba\driver\power.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    power.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"



NTSTATUS VA_Power(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for Power IRPs (MajorFunction == IRP_MJ_Power)

    Note: We may or may not have set the DO_POWER_PAGABLE bit
          for the filter device object in AddDevice().
          Therefore, we don't know whether or not this function
          can be called at DISPATCH_LEVEL; so the power-handling
          code must be locked.

Arguments:

    devExt - device extension for targetted device object
    irp - Io Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    irpSp = IoGetCurrentIrpStackLocation(irp);

    DBGOUT(("VA_Power, minorFunc = %d ", (ULONG)irpSp->MinorFunction)); 


    switch (irpSp->MinorFunction){

        case IRP_MN_SET_POWER:

            switch (irpSp->Parameters.Power.Type) {

                case SystemPowerState:
                    /*
                     *  For system power states, just pass the IRP down.
                     */
                    break;

                case DevicePowerState:

                    switch (irpSp->Parameters.Power.State.DeviceState) {

                        case PowerDeviceD0:
                            /*
                             *  Resume from APM Suspend
                             *
                             *  Do nothing here; 
                             *  Send down the read IRPs in the completion
                             *  routine for this (the power) IRP.
                             */
                            break;

                        case PowerDeviceD1:
                        case PowerDeviceD2:
                        case PowerDeviceD3:
                            /*
                             *  Suspend
                             */
                            if (devExt->state == STATE_STARTED){
                                devExt->state = STATE_SUSPENDED;
                            }
                            break;

                    }
                    break;

            }
            break;

    }


    /*
     *  Whether we are completing or relaying this power IRP,
     *  we must call PoStartNextPowerIrp.
     */
    PoStartNextPowerIrp(irp);

    /*
     *  Send the IRP down the driver stack,
     *  using PoCallDriver (not IoCallDriver, as for non-power irps).
     */
    IoCopyCurrentIrpStackLocationToNext(irp);
    IncrementPendingActionCount(devExt);
    IoSetCompletionRoutine( irp, 
                            VA_PowerComplete, 
                            (PVOID)devExt,  // context
                            TRUE, 
                            TRUE, 
                            TRUE);
    status = PoCallDriver(devExt->physicalDevObj, irp);

    return status;
}


NTSTATUS VA_PowerComplete(
                            IN PDEVICE_OBJECT devObj, 
                            IN PIRP irp, 
                            IN PVOID context)
/*++

Routine Description:

      Completion routine for Power IRPs (MajorFunction == IRP_MJ_Power)

Arguments:

    devObj - targetted device object
    irp - Io Request Packet
    context - context value passed to IoSetCompletionRoutine by VA_Power

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    struct DEVICE_EXTENSION *devExt = (struct DEVICE_EXTENSION *)context;

    ASSERT(devExt);
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE); 

    irpSp = IoGetCurrentIrpStackLocation(irp);
    ASSERT(irpSp->MajorFunction == IRP_MJ_POWER);

    if (NT_SUCCESS(irp->IoStatus.Status)){
        switch (irpSp->MinorFunction){

            case IRP_MN_SET_POWER:

                switch (irpSp->Parameters.Power.Type){

                    case DevicePowerState:
                        switch (irpSp->Parameters.Power.State.DeviceState){
                            case PowerDeviceD0:
                                if (devExt->state == STATE_SUSPENDED){
                                    devExt->state = STATE_STARTED;
                                }
                                break;
                        }
                        break;

                }
                break;
        }

    }

    /*
     *  Decrement the pendingActionCount, which we incremented in VA_Power.
     */
    DecrementPendingActionCount(devExt);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\exe\sources.inc ===
!IF 0

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Alan Warwick

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF


TARGETNAME=wmiexe

MAJORCOMP=wmi
MINORCOMP=exe

TARGETTYPE=PROGRAM

INCLUDES=..;                                \
         ..\..\inc;                         \
         ..\..\..\..\inc;                   \
         $(PROJECT_ROOT)\published\wmi\inc; \
         $(BASE_INC_PATH);                  \

C_DEFINES=$(C_DEFINES) -D__MIDL_USER_DEFINED


SOURCES_LIST= \
	..\wmiexe.rc \
	..\wmiexe.c

USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\wmihlp.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Revision History:

--*/

#ifndef _WMIHLP_H
#define _WMIHLP_H

#pragma warning (once : 4200)
#include <wmium.h>

#define MAX_NAME_LENGTH 500
#ifndef OffsetToPtr
#define OffsetToPtr(Base, Offset)     ((PBYTE) ((PBYTE)Base + Offset))
#endif

void PrintHeader(WNODE_HEADER Header, CString & output);
void PrintCountedString(LPTSTR   lpString, CString & output);
extern "C" {
BOOL MyIsTextUnicode(PVOID string);
};
BOOL ValidHexText(CWnd *parent, const CString &txt, LPDWORD lpData, UINT line = -1);

#endif //  _WMIHLP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\enumguid\wmihlp.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Revision History:

--*/

#include "stdafx.h"
#include "wmihlp.h"

void PrintHeader(WNODE_HEADER Header, CString & output)
{
    SYSTEMTIME   sysTime;
    FILETIME     fileTime;
    FILETIME     localFileTime;
    CString      tmp;

    //  Convert the file time
    //
    fileTime.dwLowDateTime = Header.TimeStamp.LowPart;
    fileTime.dwHighDateTime = Header.TimeStamp.HighPart;

    FileTimeToLocalFileTime(&fileTime,
                            &localFileTime );

    FileTimeToSystemTime(&localFileTime,
                         &sysTime);


    //  Print the info
    //
    tmp.Format(_T("Buffer Size:  0x%x\r\n")
          _T("Provider Id:  0x%x\r\n")
          _T("Version    :  %u\r\n")
          _T("Linkage    :  0x%x\r\n")
          _T("Time Stamp :  %u:%02u %u\\%u\\%u\r\n")
          _T("Guid       :  0x%x 0x%x 0x%x  0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n")
          _T("Flags      :  0x%02x\r\n"),
          Header.BufferSize,
          Header.ProviderId,
          Header.Version,
          Header.Linkage,
          sysTime.wHour,
          sysTime.wMinute,
          sysTime.wMonth,
          sysTime.wDay,
          sysTime.wYear,
          Header.Guid.Data1,
          Header.Guid.Data2,
          Header.Guid.Data3,
          Header.Guid.Data4[0],
          Header.Guid.Data4[1],
          Header.Guid.Data4[2],
          Header.Guid.Data4[3],
          Header.Guid.Data4[4],
          Header.Guid.Data4[5],
          Header.Guid.Data4[6],
          Header.Guid.Data4[7],
          Header.Flags );

    //  Print readable flags
    //
    if (Header.Flags & WNODE_FLAG_ALL_DATA)
    {
       output += _T("WNODE_FLAG_ALL_DATA\r\n");
    }

    if (Header.Flags & WNODE_FLAG_SINGLE_INSTANCE)
    {
       output += _T("WNODE_FLAG_SINGLE_INSTANCE\r\n");
    }

    if (Header.Flags & WNODE_FLAG_SINGLE_ITEM)
    {
       output += _T("WNODE_FLAG_SINGLE_ITEM\r\n");
    }

    if (Header.Flags & WNODE_FLAG_EVENT_ITEM)
    {
       output += _T("WNODE_FLAG_EVENT_ITEM\r\n");
    }

    if (Header.Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE)
    {
       output += _T("WNODE_FLAG_FIXED_INSTANCE_SIZE\r\n");
    }

    if (Header.Flags & WNODE_FLAG_TOO_SMALL)
    {
       output += _T("WNODE_FLAG_TOO_SMALL\r\n");
    }

    if (Header.Flags & WNODE_FLAG_INSTANCES_SAME)
    {
       output += _T("WNODE_FLAG_INSTANCES_SAME\r\n");
    }

    if (Header.Flags & WNODE_FLAG_INTERNAL)
    {
       output += _T("WNODE_FLAG_INTERNAL\r\n");
    }

    if (Header.Flags & WNODE_FLAG_USE_TIMESTAMP)
    {
       output += _T("WNODE_FLAG_USE_TIMESTAMP\r\n");
    }

    if (Header.Flags & WNODE_FLAG_TRACED_GUID)
    {
       output += _T("WNODE_FLAG_TRACED_GUID\r\n");
    }

    if (Header.Flags & WNODE_FLAG_EVENT_REFERENCE)
    {
       output += _T("WNODE_FLAG_EVENT_REFERENCE\r\n");
    }

    if (Header.Flags & WNODE_FLAG_ANSI_INSTANCENAMES)
    {
       output += _T("WNODE_FLAG_ANSI_INSTANCENAMES\r\n");
    }

    if (Header.Flags & WNODE_FLAG_METHOD_ITEM)
    {
       output += _T("WNODE_FLAG_METHOD_ITEM\r\n");
    }

    if (Header.Flags & WNODE_FLAG_PDO_INSTANCE_NAMES)
    {
       output += _T("WNODE_FLAG_PDO_INSTANCE_NAMES\r\n");
    }

    output += _T("\r\n");
}

VOID
PrintCountedString(
   LPTSTR   lpString,
   CString & output
   )
{
   SHORT    usNameLength;
   LPTSTR   lpStringPlusNull;

   usNameLength = * (USHORT *) lpString;

   lpStringPlusNull = (LPTSTR) new TCHAR[usNameLength + sizeof(TCHAR)];

   if (lpStringPlusNull != NULL) {
      lpString = (LPTSTR) ((PBYTE)lpString + sizeof(USHORT));
      if (MyIsTextUnicode(lpString)) {
         usNameLength /= 2;
      }

      _tcsncpy( lpStringPlusNull, lpString, usNameLength );

      _tcscpy( lpStringPlusNull + usNameLength, __T("") );

      output += lpStringPlusNull;
      // _tprintf(__T("%s\n"), lpStringPlusNull);

      delete[] lpStringPlusNull;
   }
}

BOOL MyIsTextUnicode(PVOID string)
{
   if (*((USHORT*)string) <= 0xff)
   {
      return TRUE;
   }
   else
   {
      return FALSE;
   }
}

BOOL ValidHexText(CWnd *parent, const CString &txt, LPDWORD lpData, UINT line)
{
    int i, len;
    TCHAR *stop;
    CString msg;

    if ((len = txt.GetLength()) > 8) {
        parent->MessageBox(_T("Must enter a value of 8 or less characters!"));
        return FALSE;
    }

    for (i = 0; i < len; i++) {
        if (!_istxdigit(txt[i])) {
            if (line == -1) 
                msg.Format(_T("All digits must be hex! (digit #%d isn't)"), i+1);
            else
                msg.Format(_T("All digits must be hex!\n(digit #%d on line #%d isn't)"), i+1, line);
            parent->MessageBox(msg);
            return FALSE;
        }
    }

    *lpData = (DWORD) _tcstol(txt, &stop, 16);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\exe\wmiexe.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

	wmiexe.c

Abstract:
    
    WMI exe scaffolding

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"

#if DBG
BOOLEAN WmipLoggingEnabled;
#endif

#ifdef MEMPHIS

typedef (*RSPAPI)(DWORD, DWORD);
#define RSP_SIMPLE_SERVICE       1
#define RSP_UNREGISTER_SERVICE   0

int WinMain(
    HINSTANCE hInstance,	
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
    ULONG Status;
    HMODULE Module;
    RSPAPI RspApi;
    HANDLE HackEvent;
    HANDLE EventHandle;

    HackEvent = CreateEvent(NULL,
                                TRUE,
                                FALSE,
                                "WMI_UNIQUE_EVENT_NAME");
    if (HackEvent == NULL)
    {
        Status = GetLastError();
        WmipDebugPrint(("WMI: Couldn't create WMI_UNIQUE_EVENT_NAME %d\n",
	                Status));
        return(Status);
	
    }
    
    if ((HackEvent != NULL) &&
        (GetLastError() == ERROR_ALREADY_EXISTS))
    {
        CloseHandle(HackEvent);
        WmipDebugPrint(("WMI: Previous instance of WMIEXE running, exiting...\n"));
#ifndef RUN_AS_SERVICE
        MessageBox(NULL, "Another copy of WMIEXE.EXE is already running\n",
                   "WMI", MB_OK);
#endif
        return(0);
    }
    
    Status = WmiInitializeService();
    if (Status != ERROR_SUCCESS)
    {
        WmipDebugPrint(("WMI: WmiInitializeService failed %d\n", Status));
    } else {
        EventHandle = (HANDLE)atoi(lpCmdLine);
	if (EventHandle != NULL)
	{
            SetEvent(EventHandle);
	    CloseHandle(EventHandle);
	}
#ifdef RUN_AS_SERVICE	
        Module = GetModuleHandle("Kernel32");
        if (Module == NULL)
        {
            WmipDebugPrint(("WMI: Kernel32 not loaded\n"));
            return(GetLastError());
        }
        RspApi = (RSPAPI)GetProcAddress(Module, "RegisterServiceProcess");
        if (RspApi == NULL)
        {
            WmipDebugPrint(("WMI: RspApi not loaded\n"));
            return(GetLastError());
        }

        (*RspApi)(GetCurrentProcessId(), RSP_SIMPLE_SERVICE);
#endif
        Status = WmiRunService(
		              0
#ifdef MEMPHIS				      
                              , hInstance
#endif				      
			      );

        if (Status != ERROR_SUCCESS)
        {
            WmipDebugPrint(("WMI: WmiRunService failed %d\n", Status));
        }
        WmiDeinitializeService();
    }    
    
    CloseHandle(HackEvent);
    return(Status);
}
#else

void 
WmiServiceMain(
    DWORD argc, 
    LPWSTR *argv
    );

void 
WmiServiceCtrlHandler(
    DWORD Opcode
    );

SERVICE_STATUS          WmiServiceStatus;  
SERVICE_STATUS_HANDLE   WmiServiceStatusHandle; 

int _cdecl main(int argc, WCHAR *argv[])
{
#ifdef RUN_AS_SERVICE	
    SERVICE_TABLE_ENTRY   DispatchTable[] = 
    { 
        { L"Wmi", WmiServiceMain  }, 
        { NULL,   NULL            } 
    }; 
		     
	
    if (!StartServiceCtrlDispatcher( DispatchTable)) 
    { 
        WmipDebugPrint(("WMI: StartServiceCtrlDispatcher error = %d\n", 
                        GetLastError()));
    } 
    return(0);
#else
    DWORD Status; 
 
    //
    // Initialize the WMI service
    Status = WmiInitializeService(); 
 
    if (Status != ERROR_SUCCESS) 
    { 
        return(Status); 
    } 
 
    //
    // All set to start doing the real work of the service
    Status = WmiRunService(0);


    WmiDeinitializeService();

    return(Status);
 
#endif
}


void WmiServiceMain(DWORD argc, LPWSTR *argv)  
{ 
    DWORD Status; 
 
    WmiServiceStatus.dwServiceType        = SERVICE_WIN32; 
    WmiServiceStatus.dwCurrentState       = SERVICE_START_PENDING; 
    WmiServiceStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP;
    WmiServiceStatus.dwWin32ExitCode      = 0; 
    WmiServiceStatus.dwServiceSpecificExitCode = 0; 
    WmiServiceStatus.dwCheckPoint         = 0; 
    WmiServiceStatus.dwWaitHint           = 0; 
 
    WmiServiceStatusHandle = RegisterServiceCtrlHandler(L"Wmi", 
                                                       WmiServiceCtrlHandler);
 
    if (WmiServiceStatusHandle == (SERVICE_STATUS_HANDLE)NULL) 
    { 
        WmipDebugPrint(("WMI: RegisterServiceCtrlHandler failed %d\n", GetLastError())); 
        return; 
    } 
    
    //
    // Initialize the WMI service
    Status = WmiInitializeService(); 
 
    if (Status != ERROR_SUCCESS) 
    { 
        //
        // If an error occurs we just stop ourselves
        WmiServiceStatus.dwCurrentState       = SERVICE_STOPPED; 
        WmiServiceStatus.dwCheckPoint         = 0; 
        WmiServiceStatus.dwWaitHint           = 0; 
        WmiServiceStatus.dwWin32ExitCode      = Status; 
        WmiServiceStatus.dwServiceSpecificExitCode = Status; 
 
        SetServiceStatus (WmiServiceStatusHandle, &WmiServiceStatus); 
        return; 
    } 
 
    // Initialization complete - report running status. 
    WmiServiceStatus.dwCurrentState       = SERVICE_RUNNING; 
    WmiServiceStatus.dwCheckPoint         = 0; 
    WmiServiceStatus.dwWaitHint           = 0; 
 
    if (!SetServiceStatus (WmiServiceStatusHandle, &WmiServiceStatus)) 
    { 
        Status = GetLastError(); 
        WmipDebugPrint(("WMI: SetServiceStatus error %ld\n",Status)); 
    } 

    //
    // All set to start doing the real work of the service
    Status = WmiRunService(0);

    WmiDeinitializeService();

    WmiServiceStatus.dwCurrentState       = SERVICE_STOPPED; 
    WmiServiceStatus.dwCheckPoint         = 0; 
    WmiServiceStatus.dwWaitHint           = 0; 
    WmiServiceStatus.dwWin32ExitCode      = Status; 
    WmiServiceStatus.dwServiceSpecificExitCode = Status; 
 
    SetServiceStatus (WmiServiceStatusHandle, &WmiServiceStatus); 
 
    return; 
} 


void WmiServiceCtrlHandler (DWORD Opcode)  
{ 
    ULONG Status; 
 
    switch(Opcode) 
    { 
        case SERVICE_CONTROL_PAUSE: 
        {
            WmipDebugPrint(("WMI: service does not support Pause\n"));
            break; 
        }
 
        case SERVICE_CONTROL_CONTINUE: 
        {
            WmipDebugPrint(("WMI: service does not support Continue\n"));
            break; 
        }
 
        case SERVICE_CONTROL_STOP: 
        {
            // TODO: Do something to stop main service thread
            WmiServiceStatus.dwWin32ExitCode = 0; 
            WmiServiceStatus.dwCurrentState  = SERVICE_STOP_PENDING; 
            WmiServiceStatus.dwCheckPoint    = 0; 
            WmiServiceStatus.dwWaitHint      = 0; 
 
            if (!SetServiceStatus (WmiServiceStatusHandle, 
                &WmiServiceStatus))
            { 
                Status = GetLastError(); 
                WmipDebugPrint(("WMI: SetServiceStatus error %ld\n", Status));
            } 

	    WmiTerminateService();
	    
            WmipDebugPrint(("WMI: Leaving Service\n")); 
            return; 
        }
 
        case SERVICE_CONTROL_INTERROGATE: 
        {
            // Fall through to send current status. 
            break; 
        }
 
        default: 
        {
            WmipDebugPrint(("WMI: Unrecognized opcode %ld\n", Opcode)); 
            break;
        }
    } 

    //
    // Send current status. 
    if (!SetServiceStatus (WmiServiceStatusHandle,  &WmiServiceStatus)) 
    { 
        Status = GetLastError(); 
        WmipDebugPrint(("WMI: SetServiceStatus error %ld\n",Status)); 
    } 
    
    return; 
} 
 


#endif

#ifdef MEMPHIS
#if DBG
void __cdecl DebugOut(char *Format, ...)
{
    char Buffer[1024]; 
    va_list pArg;
    ULONG i;
    
    va_start(pArg, Format);
    i = _vsnprintf(Buffer, sizeof(Buffer), Format, pArg);
    OutputDebugString(Buffer);
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\fchba\driver\filter.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    filter.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(INIT, DriverEntry)
        #pragma alloc_text(PAGE, VA_AddDevice)
        #pragma alloc_text(PAGE, VA_DriverUnload)
#endif

UNICODE_STRING FilterRegistryPath;

NTSTATUS DriverEntry(
                        IN PDRIVER_OBJECT DriverObject, 
                        IN PUNICODE_STRING RegistryPath
                    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    ULONG i;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(RegistryPath);

    DBGOUT(("DriverEntry")); 

    /*
     *  Route all IRPs on device objects created by this driver
     *  to our IRP dispatch routine.
     */
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++){
        DriverObject->MajorFunction[i] = VA_Dispatch; 
    }

    DriverObject->DriverExtension->AddDevice = VA_AddDevice;
    DriverObject->DriverUnload = VA_DriverUnload;

    //
    // Remember registry path since it is needed for WMI registration
    FilterRegistryPath.Length = 0;
    FilterRegistryPath.MaximumLength = RegistryPath->Length;
    FilterRegistryPath.Buffer = ExAllocatePoolWithTag(PagedPool, 
                                                RegistryPath->Length+2,
                                                FILTER_TAG);
    RtlCopyUnicodeString(&FilterRegistryPath, RegistryPath);

    
    return STATUS_SUCCESS;
}


NTSTATUS VA_AddDevice(
                        IN PDRIVER_OBJECT driverObj, 
                        IN PDEVICE_OBJECT physicalDevObj
                     )
/*++

Routine Description:

    The PlugPlay subsystem is handing us a brand new 
    PDO (Physical Device Object), for which we
    (by means of INF registration) have been asked to filter.

    We need to determine if we should attach or not.
    Create a filter device object to attach to the stack
    Initialize that device object
    Return status success.

    Remember: we can NOT actually send ANY non pnp IRPS to the given driver
    stack, UNTIL we have received an IRP_MN_START_DEVICE.

Arguments:

    driverObj - pointer to a device object.

    physicalDevObj -    pointer to a physical device object pointer 
                        created by the  underlying bus driver.

Return Value:

    NT status code.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT filterDevObj = NULL;
    
    PAGED_CODE();

    DBGOUT(("VA_AddDevice: drvObj=%ph, pdo=%ph", driverObj, physicalDevObj)); 

    status = IoCreateDevice(    driverObj, 
                                sizeof(struct DEVICE_EXTENSION),
                                NULL,           // name for this device
                                FILE_DEVICE_UNKNOWN, 
                                FILE_AUTOGENERATED_DEVICE_NAME,                // device characteristics
                                FALSE,          // not exclusive
                                &filterDevObj); // our device object

    if (NT_SUCCESS(status)){
        struct DEVICE_EXTENSION *devExt;

        ASSERT(filterDevObj);

        /*
         *  Initialize device extension for new device object
         */
        devExt = (struct DEVICE_EXTENSION *)filterDevObj->DeviceExtension;
        RtlZeroMemory(devExt, sizeof(struct DEVICE_EXTENSION));
        devExt->signature = DEVICE_EXTENSION_SIGNATURE;
        devExt->state = STATE_INITIALIZED;
        devExt->filterDevObj = filterDevObj;
        devExt->physicalDevObj = physicalDevObj;
        
        devExt->pendingActionCount = 0;
        KeInitializeEvent(&devExt->removeEvent, NotificationEvent, FALSE);

        /*
         *  Clear the initializing bit from the new device object's flags.
         */
        filterDevObj->Flags &= ~DO_DEVICE_INITIALIZING;

        /*
         *  The DO_POWER_PAGABLE bit of a device object
         *  indicates to the kernel that the power-handling
         *  code of the corresponding driver is pageable, and
         *  so must be called at IRQL 0.
         *  As a filter driver, we do not want to change the power
         *  behavior of the driver stack in any way; therefore,
         *  we copy this bit from the lower device object.
         */
        ASSERT(!(filterDevObj->Flags & DO_POWER_PAGABLE)); 
        filterDevObj->Flags |= (physicalDevObj->Flags & DO_POWER_PAGABLE);

        /*
         *  Attach the new device object to the top of the device stack.
         */
        devExt->topDevObj = IoAttachDeviceToDeviceStack(filterDevObj, physicalDevObj);

        ASSERT(devExt->topDevObj);
        DBGOUT(("created filterDevObj %ph attached to %ph.", filterDevObj, devExt->topDevObj));

        /*
         *  This is a do-nothing call to a sample function which
         *  demonstrates how to read the device's registry area.
         *  Note that you cannot make this call on devExt->filterDevObj
         *  because a filter device object does not have a devNode.
         *  We pass devExt->physicalDevObj, which is the device object
         *  for which this driver is a filter driver.
         */
        RegistryAccessSample(devExt->physicalDevObj);

        /*
         * WMI specific initialization
        */
		TestInitializeWmilibContext(&devExt->WmiLib);
		IoWMIRegistrationControl(filterDevObj, WMIREG_ACTION_REGISTER);
    } 

    ASSERT(NT_SUCCESS(status));
    return status;
}


VOID VA_DriverUnload(IN PDRIVER_OBJECT DriverObject)
/*++

Routine Description:

    Free all the allocated resources, etc.

    Note:  Although the DriverUnload function often does nothing,
           the driver must set a DriverUnload function in 
           DriverEntry; otherwise, the kernel will never unload
           the driver.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    PAGED_CODE();

    DBGOUT(("VA_DriverUnload")); 
    
    //
    // Free memory used by registry path
    ExFreePool(FilterRegistryPath.Buffer);
}


NTSTATUS VA_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    Common entrypoint for all Io Request Packets

Arguments:

    DeviceObject - pointer to a device object.
    Irp - Io Request Packet

Return Value:

    NT status code.

--*/

{
    struct DEVICE_EXTENSION *devExt;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN passIrpDown = TRUE;
    UCHAR majorFunc, minorFunc;
    NTSTATUS status;

    devExt = DeviceObject->DeviceExtension;
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE);

    InterlockedIncrement(&devExt->TotalIrpCount);
    
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Get major/minor function codes in private variables
     *  so we can access them after the IRP is completed.
     */
    majorFunc = irpSp->MajorFunction;
    minorFunc = irpSp->MinorFunction;

    DBGOUT(("VA_Dispatch: majorFunc=%d, minorFunc=%d", 
            (ULONG)majorFunc, (ULONG)minorFunc)); 

    /*
     *  For all IRPs except REMOVE, we increment the PendingActionCount
     *  across the dispatch routine in order to prevent a race condition with
     *  the REMOVE_DEVICE IRP (without this increment, if REMOVE_DEVICE
     *  preempted another IRP, device object and extension might get
     *  freed while the second thread was still using it).
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        IncrementPendingActionCount(devExt);
    }

    if ((majorFunc != IRP_MJ_PNP) &&
        (majorFunc != IRP_MJ_CLOSE) &&
        ((devExt->state == STATE_REMOVING) ||
         (devExt->state == STATE_REMOVED))){

        /*
         *  While the device is being removed, 
         *  we only pass down the PNP and CLOSE IRPs.
         *  We fail all other IRPs.
         */
        status = Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        passIrpDown = FALSE;
    }
    else {
        switch (majorFunc){

            case IRP_MJ_PNP:
                status = VA_PnP(devExt, Irp);
                passIrpDown = FALSE;
                break;

            case IRP_MJ_POWER:
                status = VA_Power(devExt, Irp);
                passIrpDown = FALSE;
                break;

            case IRP_MJ_SYSTEM_CONTROL:
                status = TestSystemControl(DeviceObject, Irp);
				passIrpDown = FALSE;
                break;
                
            case IRP_MJ_CREATE:
            case IRP_MJ_CLOSE:
            case IRP_MJ_DEVICE_CONTROL:
            case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            default:
                /*
                 *  For unsupported IRPs, we simply send the IRP
                 *  down the driver stack.
                 */
                break;
        }
    }

    if (passIrpDown){
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = IoCallDriver(devExt->topDevObj, Irp);
    }

    /*
     *  Balance the increment to PendingActionCount above.
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        DecrementPendingActionCount(devExt);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\fchba\driver\filter.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    filter.h

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <wmilib.h>


enum deviceState {
        STATE_INITIALIZED,
        STATE_STARTING,
        STATE_STARTED,
        STATE_START_FAILED,
        STATE_STOPPED,  // implies device was previously started successfully
        STATE_SUSPENDED,
        STATE_REMOVING,
        STATE_REMOVED
};

//
// Data structures for storing WMI data



#define DEVICE_EXTENSION_SIGNATURE 'rtlF'

typedef struct DEVICE_EXTENSION {

    /*
     *  Memory signature of a device extension, for debugging.
     */
    ULONG signature;

    /*
     *  Plug-and-play state of this device object.
     */
    enum deviceState state;

    /*
     *  The device object that this filter driver created.
     */
    PDEVICE_OBJECT filterDevObj;

    /*
     *  The device object created by the next lower driver.
     */
    PDEVICE_OBJECT physicalDevObj;

    /*
     *  The device object at the top of the stack that we attached to.
     *  This is often (but not always) the same as physicalDevObj.
     */
    PDEVICE_OBJECT topDevObj;

    /*
     *  deviceCapabilities includes a
     *  table mapping system power states to device power states.
     */
    DEVICE_CAPABILITIES deviceCapabilities;

    /*
     *  pendingActionCount is used to keep track of outstanding actions.
     *  removeEvent is used to wait until all pending actions are
     *  completed before complete the REMOVE_DEVICE IRP and let the
     *  driver get unloaded.
     */
    LONG pendingActionCount;
    KEVENT removeEvent;

    ULONG TotalIrpCount;
    ULONG WmiIrpCount;
    
    /*
     * WMILIB callbacks and guid list
     */
    WMILIB_CONTEXT WmiLib;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


/*
 *  Memory tag for memory blocks allocated by this driver
 *  (used in ExAllocatePoolWithTag() call).
 *  This DWORD appears as "Filt" in a little-endian memory byte dump.
 */
#define FILTER_TAG (ULONG)'tliF'


#if DBG
    #define DBGOUT(params_in_parentheses)   \
        {                                               \
            DbgPrint("'FILTER> "); \
            DbgPrint params_in_parentheses; \
            DbgPrint("\n"); \
        }
    #define TRAP(msg)  \
        {   \
            DBGOUT(("TRAP at file %s, line %d: '%s'.", __FILE__, __LINE__, msg)); \
            DbgBreakPoint(); \
        }
#else
    #define DBGOUT(params_in_parentheses)
    #define TRAP(msg)
#endif


/*
 *  Function externs
 */
NTSTATUS    DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
NTSTATUS    VA_AddDevice(IN PDRIVER_OBJECT driverObj, IN PDEVICE_OBJECT pdo);
VOID        VA_DriverUnload(IN PDRIVER_OBJECT DriverObject);
NTSTATUS    VA_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    VA_PnP(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    VA_Power(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    VA_PowerComplete(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS    VA_SystemControl(struct DEVICE_EXTENSION *devExt, PIRP irp, PBOOLEAN passIrpDown);
NTSTATUS    GetDeviceCapabilities(struct DEVICE_EXTENSION *devExt);
NTSTATUS    CallNextDriverSync(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp);
NTSTATUS    CallDriverSyncCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID Context);
VOID        IncrementPendingActionCount(struct DEVICE_EXTENSION *devExt);
VOID        DecrementPendingActionCount(struct DEVICE_EXTENSION *devExt);
VOID        RegistryAccessSample(PDEVICE_OBJECT devObj);
NTSTATUS    FilterInitializeWmiDataBlocks(struct DEVICE_EXTENSION *devExt);
void FilterWmiCleanup(
    struct DEVICE_EXTENSION *devExt
    );

extern UNICODE_STRING FilterRegistryPath;

NTSTATUS
TestInitializeWmilibContext(
    IN PWMILIB_CONTEXT WmilibContext
    );

NTSTATUS TestSystemControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\fchba\driver\pnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pnp.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, VA_PnP)
        #pragma alloc_text(PAGE, GetDeviceCapabilities)
#endif

            
NTSTATUS VA_PnP(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for PnP IRPs (MajorFunction == IRP_MJ_PNP)

Arguments:

    devExt - device extension for the targetted device object
    irp - IO Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN completeIrpHere = FALSE;
    BOOLEAN justReturnStatus = FALSE;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    DBGOUT(("VA_PnP, minorFunc = %d ", (ULONG)irpSp->MinorFunction)); 

    switch (irpSp->MinorFunction){

        case IRP_MN_START_DEVICE:
            DBGOUT(("START_DEVICE")); 

            devExt->state = STATE_STARTING;

            /*
             *  First, send the START_DEVICE irp down the stack
             *  synchronously to start the lower stack.
             *  We cannot do anything with our device object
             *  before propagating the START_DEVICE this way.
             */
            IoCopyCurrentIrpStackLocationToNext(irp);
            status = CallNextDriverSync(devExt, irp);

            if (NT_SUCCESS(status)){
                /*
                 *  Now that the lower stack is started,
                 *  do any initialization required by this device object.
                 */
                status = GetDeviceCapabilities(devExt);
                if (NT_SUCCESS(status)){
                    devExt->state = STATE_STARTED;
                    /*
                     * Now that device is started, register with WMI
                    */
                    IoWMIRegistrationControl(devExt->filterDevObj,
                                             WMIREG_ACTION_REGISTER);
                }
                else {
                    devExt->state = STATE_START_FAILED;
                }
            }
            else {
                devExt->state = STATE_START_FAILED;
            }
            completeIrpHere = TRUE;
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            break;

        case IRP_MN_STOP_DEVICE:
            if (devExt->state == STATE_SUSPENDED){
                status = STATUS_DEVICE_POWER_FAILURE;
                completeIrpHere = TRUE;
            }
            else {
                /*
                 *  Only set state to STOPPED if the device was
                 *  previously started successfully.
                 */
                if (devExt->state == STATE_STARTED){
                    devExt->state = STATE_STOPPED;
                }
            }
            break;
      
        case IRP_MN_QUERY_REMOVE_DEVICE:
            /*
             *  We will pass this IRP down the driver stack.
             *  However, we need to change the default status
             *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
             */
            irp->IoStatus.Status = STATUS_SUCCESS;
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            DBGOUT(("SURPRISE_REMOVAL")); 

            /*
             *  We will pass this IRP down the driver stack.
             *  However, we need to change the default status
             *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
             */
            irp->IoStatus.Status = STATUS_SUCCESS;

            /*
             *  For now just set the STATE_REMOVING state so that
             *  we don't do any more IO.  We are guaranteed to get
             *  IRP_MN_REMOVE_DEVICE soon; we'll do the rest of
             *  the remove processing there.
             */
            devExt->state = STATE_REMOVING;

            break;

        case IRP_MN_REMOVE_DEVICE:
            /*
             *  Check the current state to guard against multiple
             *  REMOVE_DEVICE IRPs.
             */
            DBGOUT(("REMOVE_DEVICE")); 
            if (devExt->state != STATE_REMOVED){

                devExt->state = STATE_REMOVED;

                /*
                 *  Send the REMOVE IRP down the stack asynchronously.
                 *  Do not synchronize sending down the REMOVE_DEVICE
                 *  IRP, because the REMOVE_DEVICE IRP must be sent
                 *  down and completed all the way back up to the sender
                 *  before we continue.
                 */
                IoCopyCurrentIrpStackLocationToNext(irp);
                status = IoCallDriver(devExt->physicalDevObj, irp);
                justReturnStatus = TRUE;

                DBGOUT(("REMOVE_DEVICE - waiting for %d irps to complete...",
                        devExt->pendingActionCount));  

                /*
                 *  We must for all outstanding IO to complete before
                 *  completing the REMOVE_DEVICE IRP.
                 *
                 *  First do an extra decrement on the pendingActionCount.
                 *  This will cause pendingActionCount to eventually
                 *  go to -1 once all asynchronous actions on this
                 *  device object are complete.
                 *  Then wait on the event that gets set when the
                 *  pendingActionCount actually reaches -1.
                 */
                DecrementPendingActionCount(devExt);
                KeWaitForSingleObject(  &devExt->removeEvent,
                                        Executive,      // wait reason
                                        KernelMode,
                                        FALSE,          // not alertable
                                        NULL );         // no timeout

                DBGOUT(("REMOVE_DEVICE - ... DONE waiting. ")); 

                /*
                 *  Now that the device is going away unregister with WMI
                 *  Note that we wait until all WMI irps are completed
                 *  before unregistering since unregistering will block
                 *  until all WMI irps are completed.
                 */
                IoWMIRegistrationControl(devExt->filterDevObj,
                                             WMIREG_ACTION_DEREGISTER);
	
                /*
                 *  Detach our device object from the lower 
                 *  device object stack.
                 */
                IoDetachDevice(devExt->topDevObj);

                /*
                 *  Delete our device object.
                 *  This will also delete the associated device extension.
                 */
                IoDeleteDevice(devExt->filterDevObj);
            }
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
        default:
            break;


    }

    if (justReturnStatus){
        /*
         *  We've already sent this IRP down the stack asynchronously.
         */
    }
    else if (completeIrpHere){
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
    else {
        IoCopyCurrentIrpStackLocationToNext(irp);
        status = IoCallDriver(devExt->physicalDevObj, irp);
    }

    return status;
}





NTSTATUS GetDeviceCapabilities(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

    Function retrieves the DEVICE_CAPABILITIES descriptor from the device

Arguments:

    devExt - device extension for targetted device object

Return Value:

    NT status code

--*/
{
    NTSTATUS status;
    PIRP irp;

    PAGED_CODE();

    irp = IoAllocateIrp(devExt->physicalDevObj->StackSize, FALSE);
    if (irp){
        PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(irp);

        nextSp->MajorFunction = IRP_MJ_PNP;
        nextSp->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
        RtlZeroMemory(  &devExt->deviceCapabilities, 
                        sizeof(DEVICE_CAPABILITIES));
        nextSp->Parameters.DeviceCapabilities.Capabilities = 
                        &devExt->deviceCapabilities;

        /*
         *  For any IRP you create, you must set the default status
         *  to STATUS_NOT_SUPPORTED before sending it.
         */
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        status = CallNextDriverSync(devExt, irp);

        IoFreeIrp(irp);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\fchba\driver\test.c ===
//
// Test.c - Code generated by wmimofck tool
//
// Finish code by doing all TODO: sections
//

#include <wdm.h>
#include <wmistr.h>
#include <wmiguid.h>
#include <wmilib.h>

#include "filter.h"

//
// Include data header for classes
#include "hbadata.h"



#define NUMBEROFPORTS   8



//
// TODO: Place the contents in this device extension into the driver's
//       actual device extension. It is only defined here to supply
//       a device extension so that this file can be compiled on its own
//
#ifdef MAKE_THIS_COMPILE
typedef struct DEVICE_EXTENSION
{
    WMILIB_CONTEXT WmiLib;
    PDEVICE_OBJECT physicalDevObj;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;
#endif

NTSTATUS
TestFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    );

NTSTATUS
TestExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
TestSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
TestQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
TestQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,TestQueryWmiRegInfo)
#pragma alloc_text(PAGE,TestQueryWmiDataBlock)
#pragma alloc_text(PAGE,TestSetWmiDataBlock)
#pragma alloc_text(PAGE,TestExecuteWmiMethod)
#pragma alloc_text(PAGE,TestFunctionControl)
#pragma alloc_text(PAGE,TestInitializeWmilibContext)
#endif

//
// TODO: Decide if your MOF is going to be part of your driver as a resource
//       attached to it. If this is done then all MOF in the resource will be
//       added to the schema. If this is the case be sure that 
//       USE_BINARY_MOF_RESOURCE is defined. MOF can also be reported at 
//       runtime via a query to the driver. This can be useful if you want
//       the MOF reported to the schema to be dynamic. If MOF is reported via
//       a query then USE_BINARY_MOF_QUERY should be defined.

#define USE_BINARY_MOF_RESOURCE

#ifdef USE_BINARY_MOF_QUERY
//
// MOF data can be reported by a device driver via a resource attached to
// the device drivers image file or in response to a query on the binary
// mof data guid. Here we define global variables containing the binary mof
// data to return in response to a binary mof guid query. Note that this
// data is defined to be in a PAGED data segment since it does not need to
// be in nonpaged memory. Note that instead of a single large mof file
// we could have broken it into multiple individual files. Each file would
// have its own binary mof data buffer and get reported via a different
// instance of the binary mof guid. By mixing and matching the different
// sets of binary mof data buffers a "dynamic" composite mof would be created.

#ifdef ALLOC_DATA_PRAGMA
   #pragma data_seg("PAGED")
#endif

UCHAR TestBinaryMofData[] =
{
    #include "test.x"
};
#ifdef ALLOC_DATA_PRAGMA
   #pragma data_seg()
#endif
#endif

//
// Define symbolic names for the guid indexes
#define MSFC_FibrePortHBAStatisticsGuidIndex    0
#define MSFC_FibrePortHBAAttributesGuidIndex    1
#define MSFC_FibrePortHBAMethodsGuidIndex    2
#define MSFC_FCAdapterHBAAttributesGuidIndex    3
#define MSFC_HBAFC3MgmtInfoGuidIndex    4
#define MSFC_HBAPortMethodsGuidIndex    5
#define MSFC_HBAFc3MgmtMethodsGuidIndex    6
#define MSFC_HBAFCPInfoGuidIndex    7
#ifdef USE_BINARY_MOF_QUERY
#define BinaryMofGuidIndex   8
#endif
//
// List of guids supported

GUID MSFC_FibrePortHBAStatisticsGUID = MSFC_FibrePortHBAStatisticsGuid;
GUID MSFC_FibrePortHBAAttributesGUID = MSFC_FibrePortHBAAttributesGuid;
GUID MSFC_FibrePortHBAMethodsGUID = MSFC_FibrePortHBAMethodsGuid;
GUID MSFC_FCAdapterHBAAttributesGUID = MSFC_FCAdapterHBAAttributesGuid;
GUID MSFC_HBAFC3MgmtInfoGUID = MSFC_HBAFC3MgmtInfoGuid;
GUID MSFC_HBAPortMethodsGUID = MSFC_HBAPortMethodsGuid;
GUID MSFC_HBAFc3MgmtMethodsGUID = MSFC_HBAFc3MgmtMethodsGuid;
GUID MSFC_HBAFCPInfoGUID = MSFC_HBAFCPInfoGuid;
#ifdef USE_BINARY_MOF_QUERY
GUID TestBinaryMofGUID =         BINARY_MOF_GUID;
#endif

//
// TODO: Make sure the instance count and flags are set properly for each
//       guid
WMIGUIDREGINFO TestGuidList[] =
{
    {
        &MSFC_FibrePortHBAStatisticsGUID,                        // Guid
        NUMBEROFPORTS,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_FibrePortHBAAttributesGUID,                        // Guid
        NUMBEROFPORTS,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_FibrePortHBAMethodsGUID,                        // Guid
        NUMBEROFPORTS,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_FCAdapterHBAAttributesGUID,                        // Guid
        1,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_HBAFC3MgmtInfoGUID,                        // Guid
        1,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_HBAPortMethodsGUID,                        // Guid
        1,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_HBAFc3MgmtMethodsGUID,                        // Guid
        1,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_HBAFCPInfoGUID,                        // Guid
        1,                               // # of instances in each device
        0                                // Flags
    },
#ifdef USE_BINARY_MOF_QUERY
    {
        &TestBinaryMofGUID,
        1,
        0
    }
#endif
};

#define TestGuidCount (sizeof(TestGuidList) / sizeof(WMIGUIDREGINFO))

//
// We need to hang onto the registry path passed to our driver entry so that
// we can return it in the QueryWmiRegInfo callback. Be sure to store a copy
// of it into TestRegistryPath in the DriverEntry routine
//
extern UNICODE_STRING FilterRegistryPath;

NTSTATUS TestSystemControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for System Control IRPs (MajorFunction == IRP_MJ_SYSTEM_CONTROL)

Arguments:

    DeviceObject 
    Irp

Return Value:

    NT status code

--*/
{
    PWMILIB_CONTEXT wmilibContext;
    NTSTATUS status;
    SYSCTL_IRP_DISPOSITION disposition;
    PDEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;

    //
    // TODO: Point at the WMILIB context within the device extension
    wmilibContext = &devExt->WmiLib;

    //
    // Call Wmilib helper function to crack the irp. If this is a wmi irp
    // that is targetted for this device then WmiSystemControl will callback
    // at the appropriate callback routine.
    //
    status = WmiSystemControl(wmilibContext,
                              DeviceObject,
                              Irp,
                              &disposition);

    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }

        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now.
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }

        case IrpForward:
        case IrpNotWmi:
        default:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.

            // TODO: Forward IRP down the device stack to the next device
            //       Or if this is a PDO then just complete the irp without
            //       touching it.
            break;
        }

    }

    return(status);
}
NTSTATUS
TestQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

gArguments:

    DeviceObject is the device whose registration info is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. The caller
         does NOT free this buffer.

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL. The caller does NOT free this
        buffer.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;

    //
    // Return the registry path for this driver. This is required so WMI
    // can find your driver image and can attribute any eventlog messages to
    // your driver.
    *RegistryPath = &FilterRegistryPath;
        
#ifndef USE_BINARY_MOF_RESOURCE
    //
    // Return the name specified in the .rc file of the resource which
    // contains the bianry mof data. By default WMI will look for this
    // resource in the driver image (.sys) file, however if the value
    // MofImagePath is specified in the driver's registry key
    // then WMI will look for the resource in the file specified there.
    RtlInitUnicodeString(MofResourceName, L"MofResourceName");
#endif

	*RegFlags = WMIREG_FLAG_INSTANCE_PDO;
	*Pdo = devExt->physicalDevObj;
	
    return(STATUS_SUCCESS);
}

#define CopyString(field, string, length) \
{ \
    PWCHAR p = field; \
    *p++ = length*sizeof(WCHAR); \
    wcsncpy(p, string, length); \
}

NTSTATUS
TestQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. If the driver can satisfy the query within
    the callback it should call WmiCompleteRequest to complete the irp before
    returning to the caller. Or the driver can return STATUS_PENDING if the
    irp cannot be completed immediately and must then call WmiCompleteRequest
    once the query is satisfied.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;
    ULONG SizeNeeded;
    ULONG i, LastIndex, InstanceSize;

    switch(GuidIndex)
    {
        case MSFC_FibrePortHBAStatisticsGuidIndex:
        {
            PMSFC_FibrePortHBAStatistics PortStats;
            
            //
            // First thing to do is verify if there is enough room in
            // the output buffer to return all data requested
            //
            InstanceSize = (sizeof(MSFC_FibrePortHBAStatistics)+7)&~7;          
            SizeNeeded = InstanceCount * InstanceSize;
            
            if (BufferAvail >= SizeNeeded)
            {
                //
                // Yes, loop over all instances for the data block and
                // fill in the values for them
                //
                LastIndex = InstanceIndex + InstanceCount;
                for (i = InstanceIndex; i < LastIndex; i++)
                {
                    PortStats = (PMSFC_FibrePortHBAStatistics)Buffer;

                    //
                    // TODO: Initialize values in PortStats for the port
                    //
                    memset(Buffer, (CHAR)i, InstanceSize);

                    //
                    // Establish a unique value for the port
                    //
                    PortStats->UniquePortId = ((ULONGLONG)DeviceObject) + i;
                    
                    Buffer += InstanceSize;
                    *InstanceLengthArray++ = sizeof(MSFC_FibrePortHBAStatistics);
                }
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            
            
            break;
        }

        case MSFC_FibrePortHBAAttributesGuidIndex:
        {
            PMSFC_FibrePortHBAAttributes PortAttributes;
            
            //
            // First thing to do is verify if there is enough room in
            // the output buffer to return all data requested
            //
            InstanceSize = (sizeof(MSFC_FibrePortHBAAttributes)+7)&~7;          
            SizeNeeded = InstanceCount * InstanceSize;
            
            if (BufferAvail >= SizeNeeded)
            {
                //
                // Yes, loop over all instances for the data block and
                // fill in the values for them
                //
                LastIndex = InstanceIndex + InstanceCount;
                for (i = InstanceIndex; i < LastIndex; i++)
                {
                    PortAttributes = (PMSFC_FibrePortHBAAttributes)Buffer;

                    //
                    // TODO: initialize port attribute values properly
                    //
                    memset(Buffer, (CHAR)i, InstanceSize);

#define PORTNAME L"FibrePortName"
                    CopyString(PortAttributes->Attributes.PortSymbolicName,
                               PORTNAME,
                               256);

#define OSDEVICENAME L"OsDeviceName"
                    CopyString(PortAttributes->Attributes.OSDeviceName,
                               OSDEVICENAME,
                               256);

                    //
                    // Establish a unique value for the port
                    //
                    PortAttributes->UniquePortId = ((ULONGLONG)DeviceObject) + i;
                    
                    Buffer += InstanceSize;
                    *InstanceLengthArray++ = sizeof(MSFC_FibrePortHBAAttributes);
                }
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }

        case MSFC_FCAdapterHBAAttributesGuidIndex:
        {
            PMSFC_FCAdapterHBAAttributes AdapterAttributes;
            
            //
            // First thing to do is verify if there is enough room in
            // the output buffer to return all data requested
            //
            SizeNeeded = (sizeof(MSFC_FCAdapterHBAAttributes));
            
            if (BufferAvail >= SizeNeeded)
            {
                //
                // We know there is always only 1 instance for this
                // guid
                //
                AdapterAttributes = (PMSFC_FCAdapterHBAAttributes)Buffer;

                //
                // TODO: initialize adapter attribute values properly
                //
                memset(Buffer, (CHAR)7, SizeNeeded);
                AdapterAttributes->NumberOfPorts = 8;

#define  MANUFACTURER L"FibreAdapter Manufacturer"
                CopyString(AdapterAttributes->Manufacturer,
                           MANUFACTURER,
                           64);

#define SERIALNUMBER L"FibreAdapter SerialNumber"
                CopyString(AdapterAttributes->SerialNumber,
                           SERIALNUMBER,
                           64);

#define MODEL L"FibreAdapter Model"
                CopyString(AdapterAttributes->Model,
                           MODEL,
                           256);

#define MODELDESCRIPTION L"FibreAdapter ModelDescription"
                CopyString(AdapterAttributes->ModelDescription,
                           MODELDESCRIPTION,
                           256);

#define NODESYMBOLICNAME L"FibreAdapter NodeSymbolicName"
                CopyString(AdapterAttributes->NodeSymbolicName,
                           NODESYMBOLICNAME,
                           256);

#define HARDWAREVERSION L"FibreAdapter HardwareVersion"
                CopyString(AdapterAttributes->HardwareVersion,
                           HARDWAREVERSION,
                           256);

#define DRIVERVERSION L"FibreAdapter DriverVersion"
                CopyString(AdapterAttributes->DriverVersion,
                           DRIVERVERSION,
                           256);

#define OPTIONROMVERSION L"FibreAdapter OptionROMVersion"
                CopyString(AdapterAttributes->OptionROMVersion,
                           OPTIONROMVERSION,
                           256);

#define FIRMWAREVERSION L"FibreAdapter FirmwareVersion"
                CopyString(AdapterAttributes->FirmwareVersion,
                           FIRMWAREVERSION,
                           256);

#define DRIVERNAME L"FibreAdapter DriverName"
                CopyString(AdapterAttributes->DriverName,
                           DRIVERNAME,
                           256);

                
                //
                // Establish a unique value for the Adapter
                //
                AdapterAttributes->UniqueAdapterId = ((ULONGLONG)DeviceObject);

                *InstanceLengthArray = sizeof(MSFC_FCAdapterHBAAttributes);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }

        case MSFC_HBAFC3MgmtInfoGuidIndex:
        {
            PMSFC_HBAFC3MgmtInfo Fc3MgmtInfo;
            
            //
            // First thing to do is verify if there is enough room in
            // the output buffer to return all data requested
            //
            SizeNeeded = sizeof(MSFC_HBAFC3MgmtInfo);
            
            if (BufferAvail >= SizeNeeded)
            {
                //
                // We know there is always only 1 instance for this
                // guid
                //
                Fc3MgmtInfo = (PMSFC_HBAFC3MgmtInfo)Buffer;

                //
                // TODO: initialize adapter fc3 values properly
                //
                memset(Buffer, (CHAR)4, SizeNeeded);

                *InstanceLengthArray = sizeof(MSFC_HBAFC3MgmtInfo);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }

        case MSFC_HBAFCPInfoGuidIndex:
        case MSFC_HBAFc3MgmtMethodsGuidIndex:
        case MSFC_FibrePortHBAMethodsGuidIndex:
        case MSFC_HBAPortMethodsGuidIndex:
        {
            //
            // Methods don't return data per se, but must respond to
            // queries with an empty data block. We know that all of
            // these method guids only have one instance
            //
            SizeNeeded = sizeof(ULONG);
            
            if (BufferAvail >= SizeNeeded)
            {
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }


#ifdef USE_BINARY_MOF_QUERY
        case BinaryMofGuidIndex:
        {
            //
            // TODO: If the driver supports reporting MOF dynamically, 
            //       change this code to handle multiple instances of the
            //       binary mof guid and return only those instances that
            //       should be reported to the schema
            //
            SizeNeeded = sizeof(TestBinaryMofData);

            if (BufferAvail < SizeNeeded)
            {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                RtlCopyMemory(Buffer, TestBinaryMofData, SizeNeeded);
                *InstanceLengthArray = SizeNeeded;
                status = STATUS_SUCCESS;
            }
            break;
        }
#endif

        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    }

    //
    // Complete the irp. If there was not enough room in the output buffer
    // then status is STATUS_BUFFER_TOO_SMALL and sizeNeeded has the size
    // needed to return all of the data. If there was enough room then
    // status is STATUS_SUCCESS and sizeNeeded is the actual number of bytes
    // being returned.
    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     SizeNeeded,
                                     IO_NO_INCREMENT);

    return(status);
}
NTSTATUS
TestExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. If
    the driver can complete the method within the callback it should
    call WmiCompleteRequest to complete the irp before returning to the
    caller. Or the driver can return STATUS_PENDING if the irp cannot be
    completed immediately and must then call WmiCompleteRequest once the
    data is changed.

Arguments:

    DeviceObject is the device whose method is being executed

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer is filled with the input buffer on entry and returns with
         the output data block

Return Value:

    status

--*/
{
    ULONG sizeNeeded = 0;
    NTSTATUS status;
    ULONG i;

    switch(GuidIndex)
    {            
        case MSFC_FibrePortHBAMethodsGuidIndex:
        {
            switch(MethodId)
            {
                //
                //     void ResetStatistics();
                //
                case ResetStatistics:
                {
                    //
                    // No input or output buffers expected so no
                    // validation needed. InstanceIndex has the Port
                    // Index
                    //

                    //
                    // TODO: Do what is needed to reset port
                    //       statistics. The index to the port is the
                    //       InstanceIndex parameter
                    //
                    sizeNeeded = 0;
                    status = STATUS_SUCCESS;
                    break;
                }

                default:
                {
                    status = STATUS_WMI_ITEMID_NOT_FOUND;
                    break;
                }
            }
            break;
        }

        case MSFC_HBAPortMethodsGuidIndex:
        {
            switch(MethodId)
            {

                //              
                //    void GetDiscoveredPortAttributes(
                //            [in
                //             ] uint32 PortIndex,
                //
                //             [in] uint32 DiscoveredPortIndex,
                //
                //             [out,
                //              HBAType("HBA_PORTATTRIBUTES")
                //             ] MSFC_HBAPortAttributesResults PortAttributes);
                //
                case GetDiscoveredPortAttributes:
                {
                    //
                    // Validate that the input buffer is the correct
                    // size and the output buffer is large enough
                    //
                    if (InBufferSize >= sizeof(GetDiscoveredPortAttributes_IN))
                    {
                        sizeNeeded = sizeof(GetDiscoveredPortAttributes_OUT);
                        if (OutBufferSize >= sizeNeeded)
                        {
                            PGetDiscoveredPortAttributes_IN In;
                            PGetDiscoveredPortAttributes_OUT Out;

                            In = (PGetDiscoveredPortAttributes_IN)Buffer;
                            Out = (PGetDiscoveredPortAttributes_OUT)Buffer;

                            //
                            // TODO: Examine In->PortIndex and
                            //       In->DiscoveredPortIndex and
                            //       validate that they are correct.
                            //

                            //
                            // TODO: Fill Out->PortAttributes with
                            //       correct values.
                            //
                            memset(&Out->PortAttributes,
                                   3,
                                   sizeof(MSFC_HBAPortAttributesResults));
                            
                            CopyString(Out->PortAttributes.PortSymbolicName,
                                       PORTNAME,
                                       256);

                            CopyString(Out->PortAttributes.OSDeviceName,
                                       OSDEVICENAME,
                                       256);

                            status = STATUS_SUCCESS;
                        } else {
                            status = STATUS_BUFFER_TOO_SMALL;
                        }
                    } else {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    break;
                }

                case GetPortAttributesByWWN:
                {            
                    //
                    // Validate that the input buffer is the correct
                    // size and the output buffer is large enough
                    //
                    if (InBufferSize >= sizeof(GetPortAttributesByWWN_IN))
                    {
                        sizeNeeded = sizeof(GetPortAttributesByWWN_OUT);
                        if (OutBufferSize >= sizeNeeded)
                        {
                            PGetPortAttributesByWWN_IN In;
                            PGetPortAttributesByWWN_OUT Out;

                            In = (PGetPortAttributesByWWN_IN)Buffer;
                            Out = (PGetPortAttributesByWWN_OUT)Buffer;

                            //
                            // TODO: Examine In->wwn to                         //       In->DiscoveredPortIndex and
                            //       validate that it is correct.
                            //

                            //
                            // TODO: Fill Out->PortAttributes with
                            //       correct values.
                            //
                            memset(&Out->PortAttributes,
                                   3,
                                   sizeof(MSFC_HBAPortAttributesResults));
                            
                            CopyString(Out->PortAttributes.PortSymbolicName,
                                       PORTNAME,
                                       256);

                            CopyString(Out->PortAttributes.OSDeviceName,
                                       OSDEVICENAME,
                                       256);

                            status = STATUS_SUCCESS;
                        } else {
                            status = STATUS_BUFFER_TOO_SMALL;
                        }
                    } else {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    break;
                }

                default:
                {
                    status = STATUS_WMI_ITEMID_NOT_FOUND;
                    break;
                }
            }
            break;
        }

        case MSFC_HBAFc3MgmtMethodsGuidIndex:
        {
            switch(MethodId)
            {
                case SendCTPassThru:
                {
                    PSendCTPassThru_IN In;
                    PSendCTPassThru_OUT Out;
                    ULONG RequestCount, ResponseCount;
                    ULONG InSizeNeeded;
                    
                    //
                    // Validate that the input buffer is the correct
                    // size and the output buffer is large enough
                    //
                    if (InBufferSize >= sizeof(ULONG))
                    {
                        In = (PSendCTPassThru_IN)Buffer;
                        
                        RequestCount = In->RequestBufferCount;
                        InSizeNeeded = sizeof(SendCTPassThru_IN) - 1 + RequestCount;
                        if (InBufferSize >= InSizeNeeded)
                        {
#define RESPONSE_BUFFER_SIZE 0x1000
                            ResponseCount = RESPONSE_BUFFER_SIZE;
                            sizeNeeded = sizeof(SendCTPassThru_OUT) - 1 + ResponseCount;
                            
                            if (OutBufferSize >= sizeNeeded)
                            {
                                Out = (PSendCTPassThru_OUT)Buffer;

                                //
                                // TODO: Do the CT Pass thru
                                //

                                //
                                // TODO: Fill the output buffer with
                                //       results
                                //
                                Out->ResponseBufferCount = ResponseCount;
                                memset(Out->ResponseBuffer,
                                       7,
                                       ResponseCount);
                            

                                status = STATUS_SUCCESS;
                            } else {
                                status = STATUS_BUFFER_TOO_SMALL;
                            }
                        } else {
                            status = STATUS_INVALID_PARAMETER;
                        }
                    } else {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    break;
                }

                case SendRNID:
                {            
                    PSendRNID_IN In;
                    PSendRNID_OUT Out;
                    ULONG ResponseCount;
                    ULONG InSizeNeeded;
                    
                    //
                    // Validate that the input buffer is the correct
                    // size and the output buffer is large enough
                    //
                    if (InBufferSize >= sizeof(SendRNID_IN))
                    {

                        ResponseCount = RESPONSE_BUFFER_SIZE;
                        sizeNeeded = sizeof(SendRNID_OUT) - 1 + ResponseCount;

                        if (OutBufferSize >= sizeNeeded)
                        {
                            In = (PSendRNID_IN)Buffer;
                            Out = (PSendRNID_OUT)Buffer;

                            //
                            // TODO: Do the SendRNID
                            //

                            //
                            // TODO: Fill the output buffer with
                            //       results
                            //
                            Out->ResponseBufferCount = ResponseCount;
                            memset(Out->ResponseBuffer,
                                   7,
                                   ResponseCount);


                            status = STATUS_SUCCESS;
                        } else {
                            status = STATUS_BUFFER_TOO_SMALL;
                        }
                    } else {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    break;
                }

                default:
                {
                    status = STATUS_WMI_ITEMID_NOT_FOUND;
                    break;
                }
            }
            break;
        }

        case MSFC_HBAFCPInfoGuidIndex:
        {
            switch(MethodId)
            {
                case GetFcpTargetMapping:
                {
                    PGetFcpTargetMapping_OUT Out;
                    
                    //
                    // TODO: Change this code to return the correct
                    //       number of mappings and the correct
                    //       mappings
                    //
#define FCPTargetMappingCount 0x20                  
                    sizeNeeded = sizeof(GetFcpTargetMapping_OUT) -
                                 sizeof(HBAFCPScsiEntry) +
                                 FCPTargetMappingCount * sizeof(HBAFCPScsiEntry);
                    if (OutBufferSize > sizeNeeded)
                    {
                        Out = (PGetFcpTargetMapping_OUT)Buffer;
                        Out->EntryCount = FCPTargetMappingCount;
                        for (i = 0; i < FCPTargetMappingCount; i++)
                        {
                            memset(&Out->Entry[i],
                                   3,
                                   sizeof(HBAFCPScsiEntry));
                            
                            CopyString(Out->Entry[i].ScsiId.OSDeviceName,
                                       OSDEVICENAME,
                                       256);
                        }
                    }
                    break;
                }

                case GetFcpPersistentBinding:
                {
                    PGetFcpPersistentBinding_OUT Out;
                    
                    //
                    // TODO: Change this code to return the correct
                    //       number of mappings and the correct
                    //       mappings
                    //
#define FCPPersistentBindingCount 0x20                  
                    sizeNeeded = sizeof(GetFcpPersistentBinding_OUT) -
                                 sizeof(HBAFCPBindingEntry) +
                                 FCPPersistentBindingCount * sizeof(HBAFCPBindingEntry);
                    if (OutBufferSize > sizeNeeded)
                    {
                        Out = (PGetFcpPersistentBinding_OUT)Buffer;
                        Out->EntryCount = FCPPersistentBindingCount;
                        for (i = 0; i < FCPPersistentBindingCount; i++)
                        {
                            memset(&Out->Entry[i],
                                   3,
                                   sizeof(HBAFCPBindingEntry));
                            
                            CopyString(Out->Entry[i].ScsiId.OSDeviceName,
                                       OSDEVICENAME,
                                       256);
                        }
                    }
                    break;
                }

                default:
                {
                    status = STATUS_WMI_ITEMID_NOT_FOUND;
                    break;
                }
            }
            break;
        }

        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     sizeNeeded,
                                     IO_NO_INCREMENT);

    return(status);
}


NTSTATUS
TestSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to change the contents of
    a data block. If the driver can change the data block within
    the callback it should call WmiCompleteRequest to complete the irp before
    returning to the caller. Or the driver can return STATUS_PENDING if the
    irp cannot be completed immediately and must then call WmiCompleteRequest
    once the data is changed.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    ULONG sizeNeeded = 0;
    NTSTATUS status;

    switch(GuidIndex)
    {
        case MSFC_HBAFC3MgmtInfoGuidIndex:
        {
            PMSFC_HBAFC3MgmtInfo FC3MgmtInfo;
            
            if (BufferSize >= sizeof(MSFC_HBAFC3MgmtInfo))
            {
                FC3MgmtInfo = (PMSFC_HBAFC3MgmtInfo)Buffer;
                
                //
                // TODO: Extract informtion from FC3MgmtInfo and
                //       process it appropriately
                //
                status = STATUS_SUCCESS;
            }
            break;
        }

        case MSFC_HBAFCPInfoGuidIndex:
        case MSFC_HBAFc3MgmtMethodsGuidIndex:
        case MSFC_FibrePortHBAMethodsGuidIndex:
        case MSFC_HBAPortMethodsGuidIndex:
        case MSFC_FibrePortHBAAttributesGuidIndex:
        case MSFC_FCAdapterHBAAttributesGuidIndex:
        case MSFC_FibrePortHBAStatisticsGuidIndex:
        {
            //
            // These are read only
            //
            status = STATUS_WMI_READ_ONLY;
            break;
        }
        
        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    }

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    return(status);


}


    
NTSTATUS
TestFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it. If the driver can complete enabling/disabling within the callback it
    should call WmiCompleteRequest to complete the irp before returning to
    the caller. Or the driver can return STATUS_PENDING if the irp cannot be
    completed immediately and must then call WmiCompleteRequest once the
    data is changed.

Arguments:

    DeviceObject is the device object

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function specifies which functionality is being enabled or disabled

    Enable is TRUE then the function is being enabled else disabled

Return Value:

    status

--*/
{
    NTSTATUS status;

    switch(GuidIndex)
    {
        case MSFC_FibrePortHBAStatisticsGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_FibrePortHBAAttributesGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_FibrePortHBAMethodsGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_FCAdapterHBAAttributesGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_HBAFC3MgmtInfoGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_HBAPortMethodsGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_HBAFc3MgmtMethodsGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_HBAFCPInfoGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        
        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    }
    
    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     STATUS_SUCCESS,
                                     0,
                                     IO_NO_INCREMENT);
    return(status);
}
NTSTATUS
TestInitializeWmilibContext(
    IN PWMILIB_CONTEXT WmilibContext
    )
/*++

Routine Description:

    This routine will initialize the wmilib context structure with the
    guid list and the pointers to the wmilib callback functions. This routine
    should be called before calling IoWmiRegistrationControl to register
    your device object.

Arguments:

    WmilibContext is pointer to the wmilib context.

Return Value:

    status

--*/
{
    RtlZeroMemory(WmilibContext, sizeof(WMILIB_CONTEXT));
    
    WmilibContext->GuidCount = TestGuidCount;
    WmilibContext->GuidList = TestGuidList;    
    
    WmilibContext->QueryWmiRegInfo = TestQueryWmiRegInfo;
    WmilibContext->QueryWmiDataBlock = TestQueryWmiDataBlock;
    WmilibContext->ExecuteWmiMethod = TestExecuteWmiMethod;
    WmilibContext->WmiFunctionControl = TestFunctionControl;
    WmilibContext->SetWmiDataBlock = TestSetWmiDataBlock;

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\fchba\hbaapi\getdata.c ===
//***************************************************************************
//
//  getdata.c
// 
//  Module: Windows HBA API implmentation
//
//  Purpose: Contains routines for getting and setting data
//
//  Copyright (c) 2001 Microsoft Corporation
//
//***************************************************************************

#include "hbaapip.h"

HBA_STATUS HBA_GetAdapterAttributesX(
	HBA_HANDLE HbaHandle,
	HBA_ADAPTERATTRIBUTES *HbaAdapterAttributes,
    BOOLEAN IsAnsi
)
{
	HANDLE Handle;
	PADAPTER_HANDLE HandleData;
	ULONG Status;
	HBA_STATUS HbaStatus = HBA_STATUS_ERROR;
	PWNODE_SINGLE_INSTANCE Buffer;
	PUCHAR Data;
	ULONG DataLength;
	PHBA_ADAPTERATTRIBUTES HbaAdapterAttributesA;

	HandleData = GetDataByHandle(HbaHandle);
	if (HandleData != NULL)
	{

		Status = WmiOpenBlock((LPGUID)&MSFC_FCAdapterHBAAttributes_GUID,
							  GENERIC_READ,
							  &Handle);

		if (Status == ERROR_SUCCESS)
		{
			//
			// Validate adapter name by querying for that adapter name as a
			// WMI instance name
			//
			Status = QuerySingleInstance(Handle,
										 HandleData->InstanceName,
										 &Buffer);

			if (Status == ERROR_SUCCESS)
			{
				Status = ParseSingleInstance(Buffer,
											 NULL,
											 &Data,
											 &DataLength);
				if (Status == ERROR_SUCCESS)
				{
					//
					// Skip over AdapterId as it is not needed for HBA
					//
					Data += sizeof(ULONGLONG);

                    //
					// Get the HBA status returned from the miniport.
					// If the miniport returns HBA_STATUS_OK then all
					// data is filled in the data block. If any other
					// HBA status is returned then the miniport is
					// reporting an error and we want to return that
					// HBA error code to the caller
					//
					HbaStatus = *(HBA_STATUS *)Data;
					Data += sizeof(HBA_STATUS);

					if (HbaStatus == HBA_STATUS_OK)
					{

						//
						// We have got our adapter attributes, so copy them
						// over to the output buffer
						//
						if (IsAnsi)
						{
							HbaAdapterAttributesA = HbaAdapterAttributes;

							GetDataFromDataBlock(HbaAdapterAttributesA,
												 NodeWWN,
												 HBA_WWN,
												 Data);

							GetDataFromDataBlock(HbaAdapterAttributesA,
												 VendorSpecificID,
												 HBA_UINT32,
												 Data);

							GetDataFromDataBlock(HbaAdapterAttributesA,
												 NumberOfPorts,
												 HBA_UINT32,
												 Data);

							CopyString(&HbaAdapterAttributesA->Manufacturer,
										&Data,
										64,
										IsAnsi);

							CopyString(&HbaAdapterAttributesA->SerialNumber,
										&Data,
										64,
										IsAnsi);

							CopyString(&HbaAdapterAttributesA->Model,
										&Data,
										256,
									   IsAnsi);

							CopyString(&HbaAdapterAttributesA->ModelDescription,
										&Data,
										256,
									   IsAnsi);

							CopyString(&HbaAdapterAttributesA->NodeSymbolicName,
										&Data,
										256,
									   IsAnsi);

							CopyString(&HbaAdapterAttributesA->HardwareVersion,
										&Data,
										256,
									   IsAnsi);

							CopyString(&HbaAdapterAttributesA->DriverVersion,
										&Data,
										256,
									   IsAnsi);

							CopyString(&HbaAdapterAttributesA->OptionROMVersion,
										&Data,
										256,
									   IsAnsi);

							CopyString(&HbaAdapterAttributesA->FirmwareVersion,
										&Data,
										256,
									   IsAnsi);

							CopyString(&HbaAdapterAttributesA->DriverName,
										&Data,
										256,
									   IsAnsi);

						} else {
							GetDataFromDataBlock(HbaAdapterAttributes,
												 NodeWWN,
												 HBA_WWN,
												 Data);

							GetDataFromDataBlock(HbaAdapterAttributes,
												 VendorSpecificID,
												 HBA_UINT32,
												 Data);

							GetDataFromDataBlock(HbaAdapterAttributes,
												 NumberOfPorts,
												 HBA_UINT32,
												 Data);

							CopyString(&HbaAdapterAttributes->Manufacturer,
										&Data,
										64,
										IsAnsi);

							CopyString(&HbaAdapterAttributes->SerialNumber,
										&Data,
										64,
										IsAnsi);

							CopyString(&HbaAdapterAttributes->Model,
										&Data,
										256,
									   IsAnsi);

							CopyString(&HbaAdapterAttributes->ModelDescription,
										&Data,
										256,
									   IsAnsi);

							CopyString(&HbaAdapterAttributes->NodeSymbolicName,
										&Data,
										256,
									   IsAnsi);

							CopyString(&HbaAdapterAttributes->HardwareVersion,
										&Data,
										256,
									   IsAnsi);

							CopyString(&HbaAdapterAttributes->DriverVersion,
										&Data,
										256,
									   IsAnsi);

							CopyString(&HbaAdapterAttributes->OptionROMVersion,
										&Data,
										256,
									   IsAnsi);

							CopyString(&HbaAdapterAttributes->FirmwareVersion,
										&Data,
										256,
									   IsAnsi);

							CopyString(&HbaAdapterAttributes->DriverName,
										&Data,
										256,
									   IsAnsi);
						}
					}
				}
				
				FreeMemory(Buffer);
			}
			WmiCloseBlock(Handle);
		}
	} else {
		HbaStatus = HBA_STATUS_ERROR_INVALID_HANDLE;
	}
	return(HbaStatus);
	
}

HBA_STATUS HBA_API HBA_GetAdapterAttributes(
	HBA_HANDLE HbaHandle,
	HBA_ADAPTERATTRIBUTES *HbaAdapterAttributes
)
{
	return(HBA_GetAdapterAttributesX(HbaHandle,
							  HbaAdapterAttributes,
							  TRUE));
}

HBA_STATUS HBA_GetAdapterPortAttributesX(
	HBA_HANDLE HbaHandle,
	HBA_UINT32 PortIndex,
	HBA_PORTATTRIBUTES *PortAttributes,
    BOOLEAN IsAnsi
)
{
	HANDLE Handle;
	PADAPTER_HANDLE HandleData;
	ULONG Status;
	HBA_STATUS HbaStatus = HBA_STATUS_ERROR;
	PWNODE_SINGLE_INSTANCE Buffer;
	PUCHAR Data;
	ULONG DataLength;
	PWCHAR InstanceName;

	HandleData = GetDataByHandle(HbaHandle);
	if (HandleData != NULL)
	{

		Status = WmiOpenBlock((LPGUID)&MSFC_FibrePortHBAAttributes_GUID,
							  GENERIC_READ,
							  &Handle);

		if (Status == ERROR_SUCCESS)
		{
			InstanceName = CreatePortInstanceNameW(HandleData->InstanceName,
				                                  PortIndex);
			if (InstanceName != NULL)
			{
				Status = QuerySingleInstance(Handle,
											 InstanceName,
											 &Buffer);

				if (Status == ERROR_SUCCESS)
				{
					Status = ParseSingleInstance(Buffer,
												 NULL,
												 &Data,
												 &DataLength);
					if (Status == ERROR_SUCCESS)
					{
	
						//
						// Skip over AdapterId as it is not needed for HBA
						//
						Data += sizeof(ULONGLONG);

						//
						// Get the HBA status returned from the miniport.
						// If the miniport returns HBA_STATUS_OK then all
						// data is filled in the data block. If any other
						// HBA status is returned then the miniport is
						// reporting an error and we want to return that
						// HBA error code to the caller
						//
						HbaStatus = *(HBA_STATUS *)Data;
						Data += sizeof(HBA_STATUS);

						if (HbaStatus == HBA_STATUS_OK)
						{
							CopyPortAttributes(PortAttributes,
											   Data,
											   IsAnsi);
						}
					}
					FreeMemory(Buffer);					
				}
				FreeMemory(InstanceName);					
			}
			WmiCloseBlock(Handle);
		}
	} else {
		HbaStatus = HBA_STATUS_ERROR_INVALID_HANDLE;
	}
	return(HbaStatus);
	
}

HBA_STATUS HBA_API HBA_GetAdapterPortAttributes(
	HBA_HANDLE HbaHandle,
	HBA_UINT32 PortIndex,
	HBA_PORTATTRIBUTES *PortAttributes
)
{
	return(HBA_GetAdapterPortAttributesX(HbaHandle,
										 PortIndex,
										 PortAttributes,
										 TRUE));
}



HBA_STATUS HBA_API HBA_GetPortStatistics(
	HBA_HANDLE HbaHandle,
	HBA_UINT32 PortIndex,
	HBA_PORTSTATISTICS *HbaPortStatistics
)
{
	HANDLE Handle;
	PADAPTER_HANDLE HandleData;
	ULONG Status;
	HBA_STATUS HbaStatus = HBA_STATUS_ERROR;
	PUCHAR Data;
	ULONG DataLength;
	PWCHAR InstanceName;
	PWNODE_SINGLE_INSTANCE Buffer;

	HandleData = GetDataByHandle(HbaHandle);
	if (HandleData != NULL)
	{

		Status = WmiOpenBlock((LPGUID)&MSFC_FibrePortHBAStatistics_GUID,
							  GENERIC_READ,
							  &Handle);

		if (Status == ERROR_SUCCESS)
		{
			InstanceName = CreatePortInstanceNameW(HandleData->InstanceName,
				                                  PortIndex);
			if (InstanceName != NULL)
			{
				Status = QuerySingleInstance(Handle,
											 InstanceName,
											 &Buffer);

				if (Status == ERROR_SUCCESS)
				{
					Status = ParseSingleInstance(Buffer,
												 NULL,
												 &Data,
												 &DataLength);
					if (Status == ERROR_SUCCESS)
					{
	
						//
						// Skip over AdapterId as it is not needed for HBA
						//
						Data += sizeof(ULONGLONG);

						//
						// Get the HBA status returned from the miniport.
						// If the miniport returns HBA_STATUS_OK then all
						// data is filled in the data block. If any other
						// HBA status is returned then the miniport is
						// reporting an error and we want to return that
						// HBA error code to the caller
						//
						HbaStatus = *(HBA_STATUS *)Data;
						Data += sizeof(HBA_STATUS);

						//
						// Since the data block goes from ULONG to
						// ULONGLONG, we need to account for 4 bytes of
						// padding
						//
						Data += 4;

						if (HbaStatus == HBA_STATUS_OK)
						{
							//
							// We have got our port statistics, so copy them
							// over to the output buffer
							//

							GetDataFromDataBlock(HbaPortStatistics,
												 SecondsSinceLastReset,
												 HBA_INT64,
												 Data);

							GetDataFromDataBlock(HbaPortStatistics,
												 TxFrames,
												 HBA_INT64,
												 Data);

							GetDataFromDataBlock(HbaPortStatistics,
												 TxWords,
												 HBA_INT64,
												 Data);

							GetDataFromDataBlock(HbaPortStatistics,
												 RxFrames,
												 HBA_INT64,
												 Data);

							GetDataFromDataBlock(HbaPortStatistics,
												 RxWords,
												 HBA_INT64,
												 Data);

							GetDataFromDataBlock(HbaPortStatistics,
												 LIPCount,
												 HBA_INT64,
												 Data);

							GetDataFromDataBlock(HbaPortStatistics,
												 NOSCount,
												 HBA_INT64,
												 Data);

							GetDataFromDataBlock(HbaPortStatistics,
												 ErrorFrames,
												 HBA_INT64,
												 Data);

							GetDataFromDataBlock(HbaPortStatistics,
												 DumpedFrames,
												 HBA_INT64,
												 Data);

							GetDataFromDataBlock(HbaPortStatistics,
												 LinkFailureCount,
												 HBA_INT64,
												 Data);

							GetDataFromDataBlock(HbaPortStatistics,
												 LossOfSyncCount,
												 HBA_INT64,
												 Data);

							GetDataFromDataBlock(HbaPortStatistics,
												 LossOfSignalCount,
												 HBA_INT64,
												 Data);

							GetDataFromDataBlock(HbaPortStatistics,
												 PrimitiveSeqProtocolErrCount,
												 HBA_INT64,
												 Data);

							GetDataFromDataBlock(HbaPortStatistics,
												 InvalidTxWordCount,
												 HBA_INT64,
												 Data);

							GetDataFromDataBlock(HbaPortStatistics,
												 InvalidCRCCount,
												 HBA_INT64,
												 Data);
						}
					}
					
					FreeMemory(Buffer);
				}
				FreeMemory(InstanceName);
			}
			WmiCloseBlock(Handle);
		}
	} else {
		HbaStatus = HBA_STATUS_ERROR_INVALID_HANDLE;
	}
	return(HbaStatus);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\fchba\hbaapi\method.c ===
//***************************************************************************
//
//  method.c
// 
//  Module: Windows HBA API implmentation
//
//  Purpose: Contains routines for doing things
//
//  Copyright (c) 2001 Microsoft Corporation
//
//***************************************************************************

#include "hbaapip.h"

HBA_STATUS HBA_GetDiscoveredPortAttributesX(
	HBA_HANDLE HbaHandle,
	HBA_UINT32 PortIndex,
	HBA_UINT32 DiscoveredPortIndex,
	HBA_PORTATTRIBUTES *HbaPortAttributes,
    BOOLEAN IsAnsi
)
{
	HANDLE Handle;
	PADAPTER_HANDLE HandleData;
	ULONG Status;
	HBA_STATUS HbaStatus = HBA_STATUS_ERROR;
	PUCHAR Buffer;
	ULONG DataLength;
	GetDiscoveredPortAttributes_IN InData;
	PGetDiscoveredPortAttributes_OUT OutData;

	HandleData = GetDataByHandle(HbaHandle);
	if (HandleData != NULL)
	{

		Status = WmiOpenBlock((LPGUID)&MSFC_HBAPortMethods_GUID,
							  GENERIC_READ | GENERIC_EXECUTE,
							  &Handle);

		if (Status == ERROR_SUCCESS)
		{
			DataLength = sizeof(GetDiscoveredPortAttributes_OUT);
			Buffer = AllocMemory(DataLength);
			if (Buffer != NULL)
			{
				InData.PortIndex = PortIndex;
				InData.DiscoveredPortIndex = DiscoveredPortIndex;
				OutData = (PGetDiscoveredPortAttributes_OUT)Buffer;

				Status = WmiExecuteMethodW(Handle,
										  HandleData->InstanceName,
										  GetDiscoveredPortAttributes,
										  sizeof(GetDiscoveredPortAttributes_IN),
										  &InData,
										  &DataLength,
                                          OutData);
				
				if (Status == ERROR_SUCCESS)
				{
					//
					// Copy port attribs from buffer into 
					//

					//
					// Get the HBA status returned from the miniport.
					// If the status is HBA_STATUS_OK then the miniport
					// has successfully completed the operation and has
					// returned results to us. If the status is not
					// HBA_STATUS_OK then the miniport is returning an
					// HBA api error which we will in turn return to
					// the caller. In this case the additional results
					// are not valid.
					//
					HbaStatus = OutData->HBAStatus;

					if (HbaStatus == HBA_STATUS_OK)
					{
						CopyPortAttributes(HbaPortAttributes,
										   (PUCHAR)&OutData->PortAttributes,
										  IsAnsi);
					}
				}
				
				FreeMemory(Buffer);
			}
			WmiCloseBlock(Handle);
		}
	}
	
    return(HbaStatus);		
}


HBA_STATUS HBA_API HBA_GetDiscoveredPortAttributes(
	HBA_HANDLE HbaHandle,
	HBA_UINT32 PortIndex,
	HBA_UINT32 DiscoveredPortIndex,
	HBA_PORTATTRIBUTES *HbaPortAttribute
)
{
	return(HBA_GetDiscoveredPortAttributesX(HbaHandle,
										   PortIndex,
										   DiscoveredPortIndex,
										   HbaPortAttribute,
										   TRUE));
}




HBA_STATUS HBA_GetPortAttributesByWWNX(
	HBA_HANDLE HbaHandle,
	HBA_WWN PortWWN,
	HBA_PORTATTRIBUTES *HbaPortAttributes,
    BOOLEAN IsAnsi
)
{
	HANDLE Handle;
	PADAPTER_HANDLE HandleData;
	ULONG Status;
	HBA_STATUS HbaStatus = HBA_STATUS_ERROR;
	PUCHAR Buffer;
	ULONG DataLength;
	PGetPortAttributesByWWN_IN InData;
	PGetPortAttributesByWWN_OUT OutData;

	HandleData = GetDataByHandle(HbaHandle);
	if (HandleData != NULL)
	{

		Status = WmiOpenBlock((LPGUID)&MSFC_HBAPortMethods_GUID,
							  GENERIC_READ | GENERIC_EXECUTE,
							  &Handle);

		if (Status == ERROR_SUCCESS)
		{
			DataLength = sizeof(GetPortAttributesByWWN_OUT);
			Buffer = (PUCHAR)AllocMemory(DataLength);
			if (Buffer != NULL)
			{
				InData = (PGetPortAttributesByWWN_IN)&PortWWN;
				OutData = (PGetPortAttributesByWWN_OUT)Buffer;

				Status = WmiExecuteMethodW(Handle,
										  HandleData->InstanceName,
										  GetPortAttributesByWWN,
										  sizeof(GetPortAttributesByWWN_IN),
										  InData,
										  &DataLength,
                                          OutData);
				
				if (Status == ERROR_SUCCESS)
				{
					//
					// Copy port attribs from buffer into 
					//
					
					//
					// Get the HBA status returned from the miniport.
					// If the status is HBA_STATUS_OK then the miniport
					// has successfully completed the operation and has
					// returned results to us. If the status is not
					// HBA_STATUS_OK then the miniport is returning an
					// HBA api error which we will in turn return to
					// the caller. In this case the additional results
					// are not valid.
					//
					HbaStatus = OutData->HBAStatus;

					if (HbaStatus == HBA_STATUS_OK)
					{
						CopyPortAttributes(HbaPortAttributes,
										   (PUCHAR)&OutData->PortAttributes,
										   IsAnsi);
					}
				}
				
				FreeMemory(Buffer);
			}
			WmiCloseBlock(Handle);
		}
	}
	
    return(HbaStatus);		
}

HBA_STATUS HBA_API HBA_GetPortAttributesByWWN(
	HBA_HANDLE HbaHandle,
	HBA_WWN PortWWN,
	HBA_PORTATTRIBUTES *HbaPortAttributes
)
{
	return(HBA_GetPortAttributesByWWNX(HbaHandle,
									  PortWWN,
									  HbaPortAttributes,
									  TRUE));
									  
}


HBA_STATUS HBA_API HBA_SendCTPassThru(
	HBA_HANDLE HbaHandle,
	void * pReqBuffer,
	HBA_UINT32 ReqBufferSize,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize
)
{
	HANDLE Handle;
	PADAPTER_HANDLE HandleData;
	ULONG Status;
	HBA_STATUS HbaStatus = HBA_STATUS_ERROR;
	PUCHAR Buffer;
	ULONG DataLength, InDataLength, OutDataLength;
	PSendCTPassThru_OUT OutData;
	PSendCTPassThru_IN InData;

	HandleData = GetDataByHandle(HbaHandle);
	if (HandleData != NULL)
	{

		Status = WmiOpenBlock((LPGUID)&MSFC_HBAFc3MgmtMethods_GUID,
							  GENERIC_READ | GENERIC_EXECUTE,
							  &Handle);

		if (Status == ERROR_SUCCESS)
		{
			if (ReqBufferSize > RspBufferSize)
			{
				DataLength = ReqBufferSize;
			} else {
				DataLength = RspBufferSize;
			}

			DataLength += sizeof(SendCTPassThru_OUT);
			Buffer = AllocMemory(DataLength);
			if (Buffer != NULL)
			{
				InData = (PSendCTPassThru_IN)Buffer;
				OutData = (PSendCTPassThru_OUT)Buffer;

				InDataLength = sizeof(SendCTPassThru_IN) + ReqBufferSize - 1;
				InData->RequestBufferCount = ReqBufferSize;
				memcpy(InData->RequestBuffer,
					   pReqBuffer,
					   ReqBufferSize);

				OutDataLength = sizeof(SendCTPassThru_OUT) + RspBufferSize - 1;
				Status = WmiExecuteMethodW(Handle,
										  HandleData->InstanceName,
										  SendCTPassThru,
										  InDataLength,
										  InData,
										  &OutDataLength,
                                          OutData);
				
				if (Status == ERROR_SUCCESS)
				{
					if (OutData->ResponseBufferCount <= RspBufferSize)
					{
						RspBufferSize = OutData->ResponseBufferCount;
					} else {
						DebugPrint(("HBAAPI: Response size from SendCTPass is %d and is larger than %d\n",
								  OutData->ResponseBufferCount,
								  RspBufferSize));
					}
					
					//
					// Get the HBA status returned from the miniport.
					// If the status is HBA_STATUS_OK then the miniport
					// has successfully completed the operation and has
					// returned results to us. If the status is not
					// HBA_STATUS_OK then the miniport is returning an
					// HBA api error which we will in turn return to
					// the caller. In this case the additional results
					// are not valid.
					//
					HbaStatus = OutData->HBAStatus;

					if ((HbaStatus == HBA_STATUS_OK) ||
                        (HbaStatus == HBA_STATUS_ERROR_MORE_DATA))
					{
						memcpy(pRspBuffer,
							   OutData->ResponseBuffer,
							   RspBufferSize);
					}
				}
				
				FreeMemory(Buffer);
			}
			WmiCloseBlock(Handle);
		}
	}
	
    return(HbaStatus);	
}


HBA_STATUS HBA_API HBA_SendRNID(
	HBA_HANDLE HbaHandle,
	HBA_WWN wwn,
	HBA_WWNTYPE wwntype,
	void * pRspBuffer,
	HBA_UINT32 *RspBufferSize
)
{
	HANDLE Handle;
	PADAPTER_HANDLE HandleData;
	ULONG Status;
	HBA_STATUS HbaStatus = HBA_STATUS_ERROR;
	PUCHAR Buffer;
	ULONG DataLength;
	SendRNID_IN InData;
	PSendRNID_OUT OutData;

	HandleData = GetDataByHandle(HbaHandle);
	if (HandleData != NULL)
	{

		Status = WmiOpenBlock((LPGUID)&MSFC_HBAFc3MgmtMethods_GUID,
							  GENERIC_READ | GENERIC_EXECUTE,
							  &Handle);

		if (Status == ERROR_SUCCESS)
		{
			DataLength = sizeof(SendRNID_OUT) -1 + *RspBufferSize;
			Buffer = AllocMemory(DataLength);
			if (Buffer != NULL)
			{
				memcpy(InData.wwn,
					   &wwn.wwn,
					   sizeof(HBA_WWN));
				InData.wwntype = (ULONG)wwntype;
				OutData = (PSendRNID_OUT)Buffer;

				Status = WmiExecuteMethodW(Handle,
										  HandleData->InstanceName,
										  SendRNID,
										  sizeof(SendRNID_IN),
										  &InData,
										  &DataLength,
                                          OutData);
				
				if (Status == ERROR_SUCCESS)
				{
					//
					// Get the HBA status returned from the miniport.
					// If the status is HBA_STATUS_OK then the miniport
					// has successfully completed the operation and has
					// returned results to us. If the status is not
					// HBA_STATUS_OK then the miniport is returning an
					// HBA api error which we will in turn return to
					// the caller. In this case the additional results
					// are not valid.
					//
					HbaStatus = OutData->HBAStatus;

					if ((HbaStatus == HBA_STATUS_OK) ||
						(HbaStatus == HBA_STATUS_ERROR_MORE_DATA))
					{
						if (OutData->ResponseBufferCount <= *RspBufferSize)
						{
							*RspBufferSize = OutData->ResponseBufferCount;
						} else {
							DebugPrint(("HBAAPI: Response size from SendRNID is %d and is larger than %d\n",
									  OutData->ResponseBufferCount,
									  *RspBufferSize));
						}

						memcpy(pRspBuffer,
							   OutData->ResponseBuffer,
							   *RspBufferSize);
					}
				}
				
				FreeMemory(Buffer);
			}
			WmiCloseBlock(Handle);
		}
	}
	
    return(HbaStatus);		
}

_inline void CopyScsiId(
    PHBA_SCSIID HbaScsiId,
    PHBAScsiID WmiScsiId,
    BOOLEAN IsAnsi
    )
{
	PUCHAR p;

	p = (PUCHAR)WmiScsiId->OSDeviceName;
	CopyString(HbaScsiId->OSDeviceName,
				&p,
				256,
				IsAnsi);
					
	HbaScsiId->ScsiBusNumber = WmiScsiId->ScsiBusNumber;
	HbaScsiId->ScsiTargetNumber = WmiScsiId->ScsiTargetNumber;
	HbaScsiId->ScsiOSLun = WmiScsiId->ScsiOSLun;
	
}

_inline void CopyFcpId(
    PHBA_FCPID HbaFcpId,
    PHBAFCPID WmiFcpId
    )
{
	HbaFcpId->FcId = WmiFcpId->Fcid;
	HbaFcpId->FcpLun = WmiFcpId->FcpLun;
	memcpy(&HbaFcpId->NodeWWN,
		   &WmiFcpId->NodeWWN,
		   sizeof(HBA_WWN));
	memcpy(&HbaFcpId->PortWWN,
		   &WmiFcpId->PortWWN,
		   sizeof(HBA_WWN));	
}

HBA_STATUS HBA_GetFcpTargetMappingX (
    HBA_HANDLE HbaHandle,
    PHBA_FCPTARGETMAPPING Mapping,
    BOOLEAN IsAnsi
)
{
	HANDLE Handle;
	PADAPTER_HANDLE HandleData;
	ULONG Status;
	HBA_STATUS HbaStatus = HBA_STATUS_ERROR;
	ULONG DataLength;
	PGetFcpTargetMapping_OUT OutData;
	ULONG MapCount, ActualCount, i;
	PHBA_FCPSCSIENTRY MapEntry;
	PHBAFCPScsiEntry OutEntry;

	HandleData = GetDataByHandle(HbaHandle);
	if (HandleData != NULL)
	{

		Status = WmiOpenBlock((LPGUID)&(MSFC_HBAFCPInfo_GUID),
							  GENERIC_READ | GENERIC_EXECUTE,
							  &Handle);

		if (Status == ERROR_SUCCESS)
		{
			Status = ExecuteMethod(Handle,
								   HandleData->InstanceName,
								   GetFcpTargetMapping,
								   0,
								   NULL,
								   &DataLength,
								   (PUCHAR *)&OutData);
			
			if (Status == ERROR_SUCCESS)
			{
				//
				// Get the HBA status returned from the miniport.
				// If the status is HBA_STATUS_OK then the miniport
				// has successfully completed the operation and has
				// returned results to us. If the status is not
				// HBA_STATUS_OK then the miniport is returning an
				// HBA api error which we will in turn return to
				// the caller. In this case the additional results
				// are not valid.
				//
				HbaStatus = OutData->HBAStatus;

				if (HbaStatus == HBA_STATUS_OK)
				{

					MapCount = Mapping->NumberOfEntries;
					ActualCount = OutData->EntryCount;

					Mapping->NumberOfEntries = ActualCount;

					if (MapCount > ActualCount)
					{
						MapCount = ActualCount;
						HbaStatus = HBA_STATUS_ERROR_MORE_DATA;
					}

					for (i = 0; i < MapCount; i++)
					{
						MapEntry = &Mapping->entry[i];
						OutEntry = &OutData->Entry[i];

						CopyScsiId(&MapEntry->ScsiId,
								   &OutEntry->ScsiId,
								   IsAnsi);

						CopyFcpId(&MapEntry->FcpId,
								  &OutEntry->FCPId);

					}
				}
				
				FreeMemory(OutData);
			}
			WmiCloseBlock(Handle);
		}
	}
	
    return(HbaStatus);		
}

HBA_STATUS HBA_API HBA_GetFcpTargetMapping (
    HBA_HANDLE HbaHandle,
    PHBA_FCPTARGETMAPPING Mapping
)
{
	return(HBA_GetFcpTargetMappingX(HbaHandle,
									Mapping,
									TRUE));
}


HBA_STATUS HBA_GetFcpPersistentBindingX (
    HBA_HANDLE HbaHandle,
    PHBA_FCPBINDING binding,
    BOOLEAN IsAnsi
)
{
	HANDLE Handle;
	PADAPTER_HANDLE HandleData;
	ULONG Status;
	HBA_STATUS HbaStatus = HBA_STATUS_ERROR;
	ULONG DataLength;
	PGetFcpPersistentBinding_OUT OutData;
	ULONG MapCount, ActualCount, i;
	PHBA_FCPBINDINGENTRY MapEntry;
	PHBAFCPBindingEntry OutEntry;

	HandleData = GetDataByHandle(HbaHandle);
	if (HandleData != NULL)
	{

		Status = WmiOpenBlock((LPGUID)&MSFC_HBAFCPInfo_GUID,
							  GENERIC_READ | GENERIC_EXECUTE,
							  &Handle);

		if (Status == ERROR_SUCCESS)
		{
			Status = ExecuteMethod(Handle,
								   HandleData->InstanceName,
								   GetFcpTargetMapping,
								   0,
								   NULL,
								   &DataLength,
								   (PUCHAR *)&OutData);
			
			if (Status == ERROR_SUCCESS)
			{
				//
				// Get the HBA status returned from the miniport.
				// If the status is HBA_STATUS_OK then the miniport
				// has successfully completed the operation and has
				// returned results to us. If the status is not
				// HBA_STATUS_OK then the miniport is returning an
				// HBA api error which we will in turn return to
				// the caller. In this case the additional results
				// are not valid.
				//
				HbaStatus = OutData->HBAStatus;

				if (HbaStatus == HBA_STATUS_OK)
				{				
					MapCount = binding->NumberOfEntries;
					ActualCount = OutData->EntryCount;

					binding->NumberOfEntries = ActualCount;

					if (MapCount > ActualCount)
					{
						MapCount = ActualCount;
						HbaStatus = HBA_STATUS_ERROR_MORE_DATA;
					}

					for (i = 0; i < MapCount; i++)
					{
						MapEntry = &binding->entry[i];
						OutEntry = &OutData->Entry[i];

						MapEntry->type = OutEntry->Type;

						CopyScsiId(&MapEntry->ScsiId,
								   &OutEntry->ScsiId,
								   IsAnsi);

						CopyFcpId(&MapEntry->FcpId,
								  &OutEntry->FCPId);

					}
				}
				
				FreeMemory(OutData);
			}
			WmiCloseBlock(Handle);
		}
	}
	
    return(HbaStatus);		
}

HBA_STATUS HBA_API HBA_GetFcpPersistentBinding (
    HBA_HANDLE handle,
    PHBA_FCPBINDING binding
)
{
	return(HBA_GetFcpPersistentBindingX(handle,
										binding,
										TRUE));
}

void HBA_API HBA_ResetStatistics(
    HBA_HANDLE HbaHandle,
	HBA_UINT32 PortIndex
    )
{
	HANDLE Handle;
	PADAPTER_HANDLE HandleData;
	ULONG Status;
	PWCHAR InstanceName;
	ULONG DataLength;

	HandleData = GetDataByHandle(HbaHandle);
	if (HandleData != NULL)
	{

		Status = WmiOpenBlock((LPGUID)&MSFC_FibrePortHBAMethods_GUID,
							  GENERIC_READ | GENERIC_EXECUTE,
							  &Handle);

		if (Status == ERROR_SUCCESS)
		{
			InstanceName = CreatePortInstanceNameW(HandleData->InstanceName,
				                                  PortIndex);
			if (InstanceName != NULL)
			{
				DataLength = 0;
				Status = WmiExecuteMethodW(Handle,
										  InstanceName,
										  ResetStatistics,
										  0,
										  NULL,
										  &DataLength,
                                          NULL);
#if DBG
				if (Status != ERROR_SUCCESS)
				{
					DebugPrint(("HBAAPI: ResetStatistics method failed %d\n",
								Status));
				}
#endif
								
				FreeMemory(InstanceName);
			}
			WmiCloseBlock(Handle);
		}
	}	
}

HBA_STATUS HBA_API HBA_SetRNIDMgmtInfo(
	HBA_HANDLE HbaHandle,
	HBA_MGMTINFO *HbaMgmtInfo
    )
{
	HANDLE Handle;
	PADAPTER_HANDLE HandleData;
	ULONG Status;
	HBA_STATUS HbaStatus = HBA_STATUS_ERROR;
	ULONG DataLength;
	SetFC3MgmtInfo_IN InData;
	SetFC3MgmtInfo_OUT OutData;

	HandleData = GetDataByHandle(HbaHandle);
	if (HandleData != NULL)
	{

		Status = WmiOpenBlock((LPGUID)&MSFC_HBAFc3MgmtMethods_GUID,
							  GENERIC_EXECUTE,
							  &Handle);

		if (Status == ERROR_SUCCESS)
		{

			//
			// We have got our Management info, so copy them
			// over to the input buffer
			//
			memcpy(InData.MgmtInfo.wwn,
				   &HbaMgmtInfo->wwn,
				   sizeof(HBA_WWN));
			InData.MgmtInfo.unittype = HbaMgmtInfo->unittype;
			InData.MgmtInfo.PortId = HbaMgmtInfo->PortId;
			InData.MgmtInfo.NumberOfAttachedNodes = HbaMgmtInfo->NumberOfAttachedNodes;
			InData.MgmtInfo.IPVersion = HbaMgmtInfo->IPVersion;
			InData.MgmtInfo.UDPPort = HbaMgmtInfo->UDPPort;
			memcpy(InData.MgmtInfo.IPAddress,
				   HbaMgmtInfo->IPAddress,
				   16);
			InData.MgmtInfo.reserved = HbaMgmtInfo->reserved;
			InData.MgmtInfo.TopologyDiscoveryFlags = HbaMgmtInfo->TopologyDiscoveryFlags;
			
			DataLength = sizeof(SetFC3MgmtInfo_OUT);
			Status = WmiExecuteMethodW(Handle,
									  HandleData->InstanceName,
									  SetFC3MgmtInfo,
									  sizeof(SetFC3MgmtInfo_IN),
									  &InData,
									  &DataLength,
									  &OutData);

			if (Status == ERROR_SUCCESS)
			{
				//
				// Get the HBA status returned from the miniport.
				// If the miniport returns HBA_STATUS_OK then all
				// data is filled in the data block. If any other
				// HBA status is returned then the miniport is
				// reporting an error and we want to return that
				// HBA error code to the caller
				//
				HbaStatus = OutData.HBAStatus;
			}
			WmiCloseBlock(Handle);
		}
	} else {
		HbaStatus = HBA_STATUS_ERROR_INVALID_HANDLE;
	}
	return(HbaStatus);
}

HBA_STATUS HBA_API HBA_GetRNIDMgmtInfo(
	HBA_HANDLE HbaHandle,
	HBA_MGMTINFO *HbaMgmtInfo
    )
{
	HANDLE Handle;
	PADAPTER_HANDLE HandleData;
	ULONG Status;
	HBA_STATUS HbaStatus = HBA_STATUS_ERROR;
	ULONG DataLength;
	GetFC3MgmtInfo_OUT OutData;

	HandleData = GetDataByHandle(HbaHandle);
	if (HandleData != NULL)
	{

		Status = WmiOpenBlock((LPGUID)&MSFC_HBAFc3MgmtMethods_GUID,
							  GENERIC_EXECUTE,
							  &Handle);

		if (Status == ERROR_SUCCESS)
		{
			DataLength = sizeof(GetFC3MgmtInfo_OUT);
			Status = WmiExecuteMethodW(Handle,
									  HandleData->InstanceName,
									  GetFC3MgmtInfo,
									  0,
									  NULL,
									  &DataLength,
									  &OutData);

			if (Status == ERROR_SUCCESS)
			{
				//
				// Get the HBA status returned from the miniport.
				// If the miniport returns HBA_STATUS_OK then all
				// data is filled in the data block. If any other
				// HBA status is returned then the miniport is
				// reporting an error and we want to return that
				// HBA error code to the caller
				//
				HbaStatus = OutData.HBAStatus;
				
				if (HbaStatus == HBA_STATUS_OK)
				{

					//
					// We have got our Management info, so copy them
					// over to the output buffer
					//
					memcpy(&HbaMgmtInfo->wwn,
						   OutData.MgmtInfo.wwn,
						   sizeof(HBA_WWN));
					HbaMgmtInfo->unittype = OutData.MgmtInfo.unittype;
					HbaMgmtInfo->PortId = OutData.MgmtInfo.PortId;
					HbaMgmtInfo->NumberOfAttachedNodes = OutData.MgmtInfo.NumberOfAttachedNodes;
					HbaMgmtInfo->IPVersion = OutData.MgmtInfo.IPVersion;
				    HbaMgmtInfo->UDPPort = OutData.MgmtInfo.UDPPort;
				    memcpy(HbaMgmtInfo->IPAddress,
						   OutData.MgmtInfo.IPAddress,
						   16);
				    HbaMgmtInfo->reserved = OutData.MgmtInfo.reserved;
					HbaMgmtInfo->TopologyDiscoveryFlags = OutData.MgmtInfo.TopologyDiscoveryFlags;
				}
					
			}
			WmiCloseBlock(Handle);
		}
	} else {
		HbaStatus = HBA_STATUS_ERROR_INVALID_HANDLE;
	}
	return(HbaStatus);
}


void HBA_API HBA_RefreshInformation(
    HBA_HANDLE HbaHandle
	)
{
	HANDLE Handle;
	PADAPTER_HANDLE HandleData;
	ULONG Status;
	ULONG DataLength;

	HandleData = GetDataByHandle(HbaHandle);
	if (HandleData != NULL)
	{

		Status = WmiOpenBlock((LPGUID)&MSFC_HBAPortMethods_GUID,
							  GENERIC_READ | GENERIC_EXECUTE,
							  &Handle);

		if (Status == ERROR_SUCCESS)
		{
			DataLength = 0;
			Status = WmiExecuteMethodW(Handle,
									   HandleData->InstanceName,
									   RefreshInformation,
									   0,
									   NULL,
									   &DataLength,
									   NULL);
#if DBG
			if (Status != ERROR_SUCCESS)
			{
				DebugPrint(("HBAAPI: RefreshInformation method failed %d\n",
							Status));
			}
#endif
			WmiCloseBlock(Handle);
		}
	}		
}


//
// Not implemented yet
//
HBA_STATUS HBA_API HBA_GetEventBuffer(
	HBA_HANDLE handle,
	PHBA_EVENTINFO EventBuffer,
	HBA_UINT32 *EventCount
    )
{
	return(HBA_STATUS_ERROR_NOT_SUPPORTED);
}


//
// SCSI apis are not supported by design
//
HBA_STATUS HBA_API HBA_SendScsiInquiry (
	HBA_HANDLE handle,
	HBA_WWN PortWWN,
	HBA_UINT64 fcLUN,
	HBA_UINT8 EVPD,
	HBA_UINT32 PageCode,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize)
{
	return(HBA_STATUS_ERROR_NOT_SUPPORTED);
}

HBA_STATUS HBA_API HBA_SendReportLUNs (
	HBA_HANDLE handle,
	HBA_WWN portWWN,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize
)
{
	return(HBA_STATUS_ERROR_NOT_SUPPORTED);
}

HBA_STATUS HBA_API HBA_SendReadCapacity (
	HBA_HANDLE handle,
	HBA_WWN portWWN,
	HBA_UINT64 fcLUN,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize
)
{
	return(HBA_STATUS_ERROR_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\fchba\hbaapi\hbaapip.h ===
//***************************************************************************
//
//  hbaapip.h
// 
//  Module: HBA API private header
//
//  Purpose: Private header
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#ifndef _HBAAPIP_
#define _HBAAPIP_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <wmistr.h>
#include <wmium.h>

#include "hbaapi.h"
#include "hbadata.h"

#if DBG
#define HbaapiAssert(x) if (! (x) ) { \
    DebugPrint(( "HBAAPI Assertion: "#x" at %s %d\n", __FILE__, __LINE__)); \
    DebugBreak(); }
#else
#define HbaapiAssert(x)
#endif


//
// Debug support
//
#ifdef DebugPrint
#undef DebugPrint
#endif

#if DBG

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

#define DEBUG_BUFFER_LENGTH 256

#define DebugPrint(x) HbaapiDebugPrint x

#else

#define DebugPrint(x)

#endif // DBG

VOID
HbaapiDebugPrint(
    PCHAR DebugMessage,
    ...
    );



#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)(Base) + (Offset)))

extern ULONG HbaHandleCounter;
extern LIST_ENTRY HbaHandleList;

typedef struct _ADAPTER_HANDLE
{
	LIST_ENTRY List;
	ULONG HbaHandle;
	PWCHAR InstanceName;
} ADAPTER_HANDLE, *PADAPTER_HANDLE;

extern HANDLE Mutex;

#define EnterCritSection() WaitForSingleObject(Mutex, INFINITE)
#define LeaveCritSection() ReleaseMutex(Mutex)


#define GetDataFromDataBlock(struct, field, type, data) \
{ \
    struct->field = *(type *)data; \
	data += sizeof(type); \
}
					
#define SetDataInDataBlock(struct, field, type, data) \
{ \
    *(type *)data = struct->field; \
	data += sizeof(type); \
}


PVOID AllocMemory(
    ULONG SizeNeeded
    );

void FreeMemory(
    PVOID Pointer
    );


PADAPTER_HANDLE GetDataByHandle(
    HBA_HANDLE HbaHandle
    );

ULONG QueryAllData(
    HANDLE Handle,
    PWNODE_ALL_DATA *Wnode
    );

ULONG QuerySingleInstance(
    HANDLE Handle,
    PWCHAR InstanceName,
    PWNODE_SINGLE_INSTANCE *Wnode
    );

ULONG ExecuteMethod(
    HANDLE Handle,
    PWCHAR InstanceName,
    ULONG MethodId,
    ULONG InBufferSize,
    PUCHAR InBuffer,
    ULONG *OutBufferSize,
    PUCHAR *OutBuffer
    );

ULONG ParseAllData(
    PWNODE_ALL_DATA Wnode,
    ULONG *CountPtr,
    PUSHORT **InstanceNamesPtr,
    PUCHAR **DataBlocksPtr,
	PULONG *DataLengths
    );

ULONG ParseSingleInstance(
    PWNODE_SINGLE_INSTANCE SingleInstance,
    PUSHORT *InstanceNamePtr,
    PUCHAR *DataPtr,
	ULONG *DataLenPtr
    );

PWCHAR CreatePortInstanceNameW(
	PWCHAR AdapterInstanceName,
	ULONG PortIndex
    );


void CopyString(
    PVOID Destination,
    PUCHAR *CountedString,
    ULONG MaxLenInChar,
    BOOLEAN IsAnsi);

ULONG AnsiToUnicode(
    LPCSTR pszA,
    LPWSTR pszW,
    ULONG MaxLen
    );

ULONG UnicodeToAnsi(
    LPCWSTR pszW,
    LPSTR pszA,
    ULONG MaxLen
    );

void CopyPortAttributes(
    PHBA_PORTATTRIBUTES HbaPortAttributes,
	PUCHAR Data,
    BOOLEAN IsAnsi
    );


#endif _HBAAPIP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\fchba\hbaapi\misc.c ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WINMGMT class provider sample code
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#include <initguid.h>

#include "hbaapip.h"


//
// This is an increasing counter that is used to assign Hba handles in
// response to HbaOpenAdapter calls.
//
ULONG HbaHandleCounter = 1;

//
// This maintains a list of all of the open Hba Handles.
//
LIST_ENTRY HbaHandleList = { &HbaHandleList, &HbaHandleList };

//
// This is the mutex object we use for our critical section
//
HANDLE Mutex;


PADAPTER_HANDLE GetDataByHandle(
    HBA_HANDLE HbaHandle
    )
{
	PADAPTER_HANDLE HandleData;
	PADAPTER_HANDLE TargetHandleData = NULL;
	PLIST_ENTRY HandleList;
	
	EnterCritSection();
	HandleList = HbaHandleList.Flink;
	while (HandleList != &HbaHandleList)
	{
		HandleData = CONTAINING_RECORD(HandleList,
									   ADAPTER_HANDLE,
									   List);
		if (HandleData->HbaHandle == HbaHandle)
		{
			TargetHandleData = HandleData;
			break;
		}
	}
	LeaveCritSection();
	return(TargetHandleData);
}

#define ALL_DATA_SIZE_GUESS  0x1000

ULONG QueryAllData(
    HANDLE Handle,
    PWNODE_ALL_DATA *Wnode
    )
{
	ULONG SizeNeeded;
	PUCHAR Buffer;
	ULONG Status;

	SizeNeeded = ALL_DATA_SIZE_GUESS;
	Buffer = AllocMemory(SizeNeeded);
	if (Buffer != NULL)
	{
		Status = WmiQueryAllDataW(Handle,
								 &SizeNeeded,
								 Buffer);
		if (Status == ERROR_INSUFFICIENT_BUFFER)
		{
			FreeMemory(Buffer);
			Buffer = AllocMemory(SizeNeeded);
			if (Buffer != NULL)
			{
				Status = WmiQueryAllDataW(Handle,
										 &SizeNeeded,
										 Buffer);
			} else {
				Status = ERROR_NOT_ENOUGH_MEMORY;
			}
		}
	} else {
		Status = ERROR_NOT_ENOUGH_MEMORY;
	}

	if ((Status != ERROR_SUCCESS) &&
        (Status != ERROR_NOT_ENOUGH_MEMORY))
	{
		FreeMemory(Buffer);
	}

	*Wnode = (PWNODE_ALL_DATA)Buffer;
	
	return(Status);
}

#define EXEC_METHOD_GUESS 0x400
ULONG ExecuteMethod(
    HANDLE Handle,
    PWCHAR InstanceName,
    ULONG MethodId,
    ULONG InBufferSize,
    PUCHAR InBuffer,
    ULONG *OutBufferSize,
    PUCHAR *OutBuffer
    )
{
	ULONG SizeNeeded;
	PUCHAR Buffer;
	ULONG Status;
	
	SizeNeeded = EXEC_METHOD_GUESS;
	Buffer = AllocMemory(SizeNeeded);
	if (Buffer != NULL)
	{
		Status = WmiExecuteMethodW(Handle,
								   InstanceName,
								   MethodId,
								   InBufferSize,
								   InBuffer,
								   &SizeNeeded,
								   Buffer);
		if (Status == ERROR_INSUFFICIENT_BUFFER)
		{
			FreeMemory(Buffer);
			Buffer = AllocMemory(SizeNeeded);
			if (Buffer != NULL)
			{
				Status = WmiExecuteMethodW(Handle,
									   InstanceName,
									   MethodId,
									   InBufferSize,
									   InBuffer,
									   &SizeNeeded,
									   Buffer);
				if (Status != ERROR_SUCCESS)
				{
					FreeMemory(Buffer);
				} else {
					*OutBufferSize = SizeNeeded;
					*OutBuffer = Buffer;
				}
			} else {
				Status = ERROR_NOT_ENOUGH_MEMORY;
			}
		} else if (Status == ERROR_SUCCESS) {
			*OutBufferSize = SizeNeeded;
			*OutBuffer = Buffer;
		} else {
			FreeMemory(Buffer);
		}
	} else {
		Status = ERROR_NOT_ENOUGH_MEMORY;
	}
	return(Status);
}

#define SINGLE_INSTANCE_SIZE_GUESS	0x400

ULONG QuerySingleInstance(
    HANDLE Handle,
    PWCHAR InstanceName,
    PWNODE_SINGLE_INSTANCE *Wnode
    )
{
	ULONG SizeNeeded;
	PUCHAR Buffer;
	ULONG Status;

	SizeNeeded = SINGLE_INSTANCE_SIZE_GUESS;
	Buffer = AllocMemory(SizeNeeded);
	if (Buffer != NULL)
	{
		Status = WmiQuerySingleInstanceW(Handle,
										InstanceName,
										&SizeNeeded,
										Buffer);
		if (Status == ERROR_INSUFFICIENT_BUFFER)
		{
			FreeMemory(Buffer);
			Buffer = AllocMemory(SizeNeeded);
			if (Buffer != NULL)
			{
				Status = WmiQuerySingleInstanceW(Handle,
												InstanceName,
												&SizeNeeded,
												Buffer);
			} else {
				Status = ERROR_NOT_ENOUGH_MEMORY;
			}
		}
	} else {
		Status = ERROR_NOT_ENOUGH_MEMORY;
	}

	if ((Status != ERROR_SUCCESS) &&
        (Status != ERROR_NOT_ENOUGH_MEMORY))
	{
		FreeMemory(Buffer);
	}

	*Wnode = (PWNODE_SINGLE_INSTANCE)Buffer;
	
	return(Status);
}

ULONG ParseAllData(
    PWNODE_ALL_DATA Wnode,
    ULONG *CountPtr,
    PUSHORT **InstanceNamesPtr,
    PUCHAR **DataBlocksPtr,
	PULONG *DataLengthsPtr
    )
{
	PUCHAR *DataBlocks;
	PUSHORT *Names;
	PULONG DataLengths;
	PWNODE_ALL_DATA WAD;
	ULONG Count, i, Linkage, j;
	BOOLEAN IsFixedInstance;
	ULONG FixedDataSize;
	PUCHAR FixedDataPtr;
	PULONG InstanceNameOffsets;
	POFFSETINSTANCEDATAANDLENGTH DataOffsetAndLength;
	
	//
	// TODO: Validate WNODE being returned
	//

	
	//
	// Count up all of the instances in the wnodes
	//
	Linkage = 0;				
	Count = 0;
	WAD = Wnode;
	do
	{
		WAD = (PWNODE_ALL_DATA)OffsetToPtr(WAD, Linkage);
		Linkage = WAD->WnodeHeader.Linkage;
		Count += WAD->InstanceCount;
		
	} while (Linkage != 0);

		
	Names = (PUSHORT *)AllocMemory(Count * sizeof(PUSHORT));
	if (Names == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

	DataBlocks = (PUCHAR *)AllocMemory(Count * sizeof(PUCHAR));
	if (DataBlocks == NULL)
	{
		FreeMemory(Names);
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

	DataLengths = (ULONG *)AllocMemory(Count * sizeof(ULONG));
	if (DataLengths == NULL)
	{
		FreeMemory(Names);
		FreeMemory(DataBlocks);
		return(ERROR_NOT_ENOUGH_MEMORY);
	}
				  

	WAD = Wnode;
	Linkage = 0;				
	i = 0;
	do
	{
		WAD = (PWNODE_ALL_DATA)OffsetToPtr(WAD, Linkage);
			
		InstanceNameOffsets = (PULONG)OffsetToPtr(WAD, WAD->OffsetInstanceNameOffsets);
		IsFixedInstance = (WAD->WnodeHeader.Flags &
				              WNODE_FLAG_FIXED_INSTANCE_SIZE) == WNODE_FLAG_FIXED_INSTANCE_SIZE;

		if (IsFixedInstance)
		{
			FixedDataSize = (WAD->FixedInstanceSize + 7) & ~7;
			FixedDataPtr = (PUCHAR)OffsetToPtr(WAD, WAD->DataBlockOffset);
		} else {
			DataOffsetAndLength = WAD->OffsetInstanceDataAndLength;
		}
		
        for (j = 0; j < WAD->InstanceCount; j++, i++)
        {
			HbaapiAssert(i < Count);
			
        	Names[i] = (PUSHORT)OffsetToPtr(WAD, InstanceNameOffsets[j]);

			if (IsFixedInstance)
			{
				DataBlocks[i] = OffsetToPtr(WAD, (FixedDataSize * j));
				DataLengths[i] = WAD->FixedInstanceSize;
			} else {
				DataBlocks[i] = OffsetToPtr(WAD, DataOffsetAndLength[j].OffsetInstanceData);
				DataLengths[i] = DataOffsetAndLength[j].LengthInstanceData;
			}
		}
			
		Linkage = WAD->WnodeHeader.Linkage;

	} while (Linkage != 0);

	*CountPtr = Count;
	
	if (InstanceNamesPtr != NULL)
	{
		*InstanceNamesPtr = Names;
	} else {
		FreeMemory(Names);
	}

	if (DataBlocksPtr != NULL)
	{
		*DataBlocksPtr = DataBlocks;
	} else {
		FreeMemory(DataBlocks);
	}

	if (DataLengthsPtr != NULL)
	{
		*DataLengthsPtr = DataLengths;
	} else {
		FreeMemory(DataLengths);
	}
	
	
	return(ERROR_SUCCESS);
}

ULONG ParseSingleInstance(
    PWNODE_SINGLE_INSTANCE SingleInstance,
    PUSHORT *InstanceNamePtr,
    PUCHAR *DataPtr,
	ULONG *DataLenPtr
    )
{
	ULONG DataLen;
	PUCHAR Data;
	PUSHORT InstanceName;
	
	//
	// TODO: Validate WNODE being returned
	//


	Data = OffsetToPtr(SingleInstance, SingleInstance->DataBlockOffset);
	DataLen = SingleInstance->SizeDataBlock;
	InstanceName = (PUSHORT)OffsetToPtr(SingleInstance, SingleInstance->OffsetInstanceName);

	if (DataPtr != NULL)
	{
		*DataPtr = Data;
	}

	if (InstanceNamePtr != NULL)
	{
		*InstanceNamePtr = InstanceName;
	}

	if (DataLenPtr != NULL)
	{
		*DataLenPtr = DataLen;
	}

	return (ERROR_SUCCESS);
}

PWCHAR CreatePortInstanceNameW(
	PWCHAR AdapterInstanceName,
	ULONG PortIndex
    )
{
	PWCHAR PortName;
	PWCHAR AdapterPrefix;
	PWCHAR Name = NULL;
	ULONG Len, AllocLen;
	PWCHAR p;
	ULONG i;

	Len = wcslen(AdapterInstanceName);
	AllocLen = (Len + 1) * sizeof(WCHAR);
	AdapterPrefix = AllocMemory(AllocLen);
	if (AdapterPrefix != NULL)
	{
		wcscpy(AdapterPrefix, AdapterInstanceName);
		p = AdapterPrefix + Len;
		while (p > AdapterPrefix)
		{
			if (*p == L'_')
			{
				*p = 0;
				break;
			}
			p--;		
		}

		Name = AllocMemory(AllocLen + (10*sizeof(WCHAR)));
		if (Name != NULL)
		{
			wsprintfW(Name,
					  L"%ws_%d",
					  AdapterPrefix,
					  PortIndex);
		} 

		FreeMemory(AdapterPrefix);
	}

	
	return(Name);
}

ULONG UnicodeToAnsi(
    LPCWSTR pszW,
    LPSTR pszA,
    ULONG MaxLen
    )
/*++

Routine Description:

    Convert Unicode string into its ansi equivalent

Arguments:

    pszW is unicode string to convert

    pszA on entry has a pointer to buffer to write ansi string 

Return Value:

    Error code

--*/
{
    ULONG cCharacters;
    ULONG Status;
    ULONG cbAnsiUsed;

    //
    // If input is null then just return empty
    if (pszW == NULL)
    {
        *pszA = 0;
        return(ERROR_SUCCESS);
    }

	cCharacters = wcslen(pszW)+1;


    // Convert to ANSI.
	cbAnsiUsed = WideCharToMultiByte(CP_ACP,
									 0,
									 pszW,
									 cCharacters,
									 pszA,
									 MaxLen,
									 NULL,
									 NULL);

    if (0 == cbAnsiUsed)
    {
        Status = GetLastError();
    } else {
		Status = ERROR_SUCCESS;
	}

    return(Status);

}


ULONG AnsiToUnicode(
    LPCSTR pszA,
    LPWSTR pszW,
    ULONG MaxLen
    )
/*++

Routine Description:

    Convert Ansi string into its Unicode equivalent

Arguments:

    pszA is ansi string to convert

    pszW retruns with the string converted to unicode
    
Return Value:

    Error code

--*/
{
    ULONG cCharacters;
    ULONG Status;
    ULONG cbUnicodeUsed;

    //
    // If input is null then just return the same.
    if (pszA == NULL)
    {
        *pszW = 0;
        return(ERROR_SUCCESS);
    }


    // Convert to Unicode
	cbUnicodeUsed = MultiByteToWideChar(CP_ACP,
										0,
										pszA,
										-1,
										pszW,
										MaxLen);

	if (0 == cbUnicodeUsed)
    {
        Status = GetLastError();
    } else {
		Status = ERROR_SUCCESS;
	}

    return(Status);

}


void CopyString(
    PVOID Destination,
    PUCHAR *CountedString,
    ULONG MaxLenInChar,
    BOOLEAN IsAnsi
    )
{
	PWCHAR DestinationW;
	PCHAR DestinationA;
	PUSHORT StringPtr = (PUSHORT)(*CountedString);
	ULONG Len, MaxLen;
	ULONG Status;
	
	Len = *StringPtr++;
	
	*CountedString += (Len + sizeof(USHORT));

	if (IsAnsi)
	{
		DestinationA = (PCHAR)Destination;
		
		DestinationW = (PWCHAR)AllocMemory((Len+1) * sizeof(WCHAR));
		if (DestinationW != NULL)
		{
			wcsncpy(DestinationW,
					StringPtr,
					Len);
			
			DestinationW[Len] = 0;

			Status = UnicodeToAnsi(DestinationW,
								   DestinationA,
								   MaxLenInChar);
								   
            if (Status != ERROR_SUCCESS)
			{
				*DestinationA = 0;
			}

			FreeMemory(DestinationW);			
		} else {
			*DestinationA = 0;
		}
	} else {
		//
		// Unicode strings get copied right out of the buffer into the
		// return structure
		//
		DestinationW = (PWCHAR)Destination;
		
		MaxLen = MaxLenInChar * sizeof(WCHAR);
		
		if (Len > MaxLen)
		{
			Len = MaxLen;
		}
		wcsncpy(DestinationW,
				StringPtr,
				Len);
		DestinationW[Len] = 0;
	}
}

void CopyPortAttributes(
    PHBA_PORTATTRIBUTES HbaPortAttributes,
	PUCHAR Data,
    BOOLEAN IsAnsi
    )
{
	PHBA_PORTATTRIBUTES HbaPortAttributesA;
	
	//
	// We have got our adapter attributes, so copy them
	// over to the output buffer
	//
	if (IsAnsi)
	{
		HbaPortAttributesA = HbaPortAttributes;
		
		GetDataFromDataBlock(HbaPortAttributesA,
							 NodeWWN,
							 HBA_WWN,
							 Data);

		GetDataFromDataBlock(HbaPortAttributesA,
							 PortWWN,
							 HBA_WWN,
							 Data);

		GetDataFromDataBlock(HbaPortAttributesA,
							 PortFcId,
							 HBA_UINT32,
							 Data);

		GetDataFromDataBlock(HbaPortAttributesA,
							 PortType,
							 HBA_UINT32,
							 Data);

		GetDataFromDataBlock(HbaPortAttributesA,
							 PortState,
							 HBA_UINT32,
							 Data);

		GetDataFromDataBlock(HbaPortAttributesA,
							 PortSupportedClassofService,
							 HBA_UINT32,
							 Data);

		GetDataFromDataBlock(HbaPortAttributesA,
							 PortSupportedFc4Types,
							 HBA_FC4TYPES,
							 Data);

		GetDataFromDataBlock(HbaPortAttributesA,
							 PortActiveFc4Types,
							 HBA_FC4TYPES,
							 Data);

		GetDataFromDataBlock(HbaPortAttributesA,
							 PortSupportedSpeed,
							 HBA_PORTSPEED,
							 Data);

		GetDataFromDataBlock(HbaPortAttributesA,
							 PortSpeed,
							 HBA_PORTSPEED,
							 Data);

		GetDataFromDataBlock(HbaPortAttributesA,
							 PortMaxFrameSize,
							 HBA_UINT32,
							 Data);

		GetDataFromDataBlock(HbaPortAttributesA,
							 FabricName,
							 HBA_WWN,
							 Data);

		GetDataFromDataBlock(HbaPortAttributesA,
							 NumberofDiscoveredPorts,
							 HBA_UINT32,
							 Data);

		CopyString(&HbaPortAttributesA->PortSymbolicName,
					&Data,
					256,
					IsAnsi);

		CopyString(&HbaPortAttributesA->OSDeviceName,
					&Data,
					256,
					IsAnsi);
	} else {
		GetDataFromDataBlock(HbaPortAttributes,
							 NodeWWN,
							 HBA_WWN,
							 Data);

		GetDataFromDataBlock(HbaPortAttributes,
							 PortWWN,
							 HBA_WWN,
							 Data);

		GetDataFromDataBlock(HbaPortAttributes,
							 PortFcId,
							 HBA_UINT32,
							 Data);

		GetDataFromDataBlock(HbaPortAttributes,
							 PortType,
							 HBA_UINT32,
							 Data);

		GetDataFromDataBlock(HbaPortAttributes,
							 PortState,
							 HBA_UINT32,
							 Data);

		GetDataFromDataBlock(HbaPortAttributes,
							 PortSupportedClassofService,
							 HBA_UINT32,
							 Data);

		GetDataFromDataBlock(HbaPortAttributes,
							 PortSupportedFc4Types,
							 HBA_FC4TYPES,
							 Data);

		GetDataFromDataBlock(HbaPortAttributes,
							 PortActiveFc4Types,
							 HBA_FC4TYPES,
							 Data);

		GetDataFromDataBlock(HbaPortAttributes,
							 PortSupportedSpeed,
							 HBA_PORTSPEED,
							 Data);

		GetDataFromDataBlock(HbaPortAttributes,
							 PortSpeed,
							 HBA_PORTSPEED,
							 Data);

		GetDataFromDataBlock(HbaPortAttributes,
							 PortMaxFrameSize,
							 HBA_UINT32,
							 Data);

		GetDataFromDataBlock(HbaPortAttributes,
							 FabricName,
							 HBA_WWN,
							 Data);

		GetDataFromDataBlock(HbaPortAttributes,
							 NumberofDiscoveredPorts,
							 HBA_UINT32,
							 Data);

		CopyString(&HbaPortAttributes->PortSymbolicName,
					&Data,
					256,
					IsAnsi);

		CopyString(&HbaPortAttributes->OSDeviceName,
					&Data,
					256,
					IsAnsi);
	}

}


PVOID AllocMemory(
    ULONG SizeNeeded
    )
{
	PVOID p;
	
	p = LocalAlloc(LPTR,
				   SizeNeeded);
	return(p);
}

void FreeMemory(
    PVOID Pointer
    )
{
	LocalFree(Pointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\fchba\driver\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, CallNextDriverSync)
        #pragma alloc_text(PAGE, CallDriverSync)
#endif


NTSTATUS CallNextDriverSync(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

        Pass the IRP down to the next device object in the stack
        synchronously, and bump the pendingActionCount around
        the call to prevent the current device object from getting
        removed before the IRP completes.

Arguments:

    devExt - device extension of one of our device objects
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    IncrementPendingActionCount(devExt);
    status = CallDriverSync(devExt->physicalDevObj, irp);
    DecrementPendingActionCount(devExt);

    return status;
}



NTSTATUS CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp)
/*++

Routine Description:

      Call IoCallDriver to send the irp to the device object;
      then, synchronize with the completion routine.
      When CallDriverSync returns, the action has completed
      and the irp again belongs to the current driver.

      NOTE:  In order to keep the device object from getting freed
             while this IRP is pending, you should call
             IncrementPendingActionCount() and 
             DecrementPendingActionCount()
             around the CallDriverSync call.

Arguments:

    devObj - targetted device object
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine( irp, 
                            CallDriverSyncCompletion, 
                            &event,     // context
                            TRUE, TRUE, TRUE);

    status = IoCallDriver(devObj, irp);

    KeWaitForSingleObject(  &event,
                            Executive,      // wait reason
                            KernelMode,
                            FALSE,          // not alertable
                            NULL );         // no timeout

    status = irp->IoStatus.Status;

    ASSERT(NT_SUCCESS(status));

    return status;
}


NTSTATUS CallDriverSyncCompletion(
                                    IN PDEVICE_OBJECT devObjOrNULL, 
                                    IN PIRP irp, 
                                    IN PVOID context)
/*++

Routine Description:

      Completion routine for CallDriverSync.

Arguments:

    devObjOrNULL - 
            Usually, this is this driver's device object.
             However, if this driver created the IRP, 
             there is no stack location in the IRP for this driver;
             so the kernel has no place to store the device object;
             ** so devObj will be NULL in this case **.

    irp - completed Io Request Packet
    context - context passed to IoSetCompletionRoutine by CallDriverSync. 

    
Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    PKEVENT event = context;

    ASSERT(irp->IoStatus.Status != STATUS_IO_TIMEOUT);

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID IncrementPendingActionCount(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

      Increment the pendingActionCount for a device object.
      This keeps the device object from getting freed before
      the action is completed.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(devExt->pendingActionCount >= 0);
    InterlockedIncrement(&devExt->pendingActionCount);    
}



VOID DecrementPendingActionCount(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

      Decrement the pendingActionCount for a device object.
      This is called when an asynchronous action is completed
      AND ALSO when we get the REMOVE_DEVICE IRP.
      If the pendingActionCount goes to -1, that means that all
      actions are completed and we've gotten the REMOVE_DEVICE IRP;
      in this case, set the removeEvent event so we can finish
      unloading.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(devExt->pendingActionCount >= 0);
    InterlockedDecrement(&devExt->pendingActionCount);    

    if (devExt->pendingActionCount < 0){
        /*
         *  All pending actions have completed and we've gotten
         *  the REMOVE_DEVICE IRP.
         *  Set the removeEvent so we'll stop waiting on REMOVE_DEVICE.
         */
        ASSERT((devExt->state == STATE_REMOVING) || 
               (devExt->state == STATE_REMOVED));
        KeSetEvent(&devExt->removeEvent, 0, FALSE);
    }
}



VOID RegistryAccessSample(PDEVICE_OBJECT devObj)
/*++

Routine Description:

    SAMPLE showing how to access the device-specific registry key 

Arguments:

    devObj - device object pointer
             NOTE: This must not be the functional device object
                   created by this filter driver, because that
                   device object does not have a devnode area
                   in the registry; pass the device object of
                   the device object for which this driver is
                   a filter.  This is the device object passed
                   to VA_AddDevice.

Return Value:

    VOID

--*/
{
    NTSTATUS status;
    HANDLE hRegDevice;

    status = IoOpenDeviceRegistryKey(   devObj, 
                                        PLUGPLAY_REGKEY_DEVICE, 
                                        KEY_READ, 
                                        &hRegDevice);
    if (NT_SUCCESS(status)){
        UNICODE_STRING keyName;
        PKEY_VALUE_FULL_INFORMATION keyValueInfo;
        ULONG keyValueTotalSize, actualLength;

        RtlInitUnicodeString(&keyName, L"SampleFilterParam"); 
        keyValueTotalSize = sizeof(KEY_VALUE_FULL_INFORMATION) +
                            keyName.Length*sizeof(WCHAR) +
                            sizeof(ULONG);
        keyValueInfo = ExAllocatePoolWithTag(   PagedPool,
                                                keyValueTotalSize,
                                                FILTER_TAG);
        if (keyValueInfo){
            status = ZwQueryValueKey(   hRegDevice,
                                        &keyName,
                                        KeyValueFullInformation,
                                        keyValueInfo,
                                        keyValueTotalSize,
                                        &actualLength); 
            if (NT_SUCCESS(status)){
                ULONG value;

                ASSERT(keyValueInfo->Type == REG_DWORD);
                ASSERT(keyValueInfo->DataLength == sizeof(ULONG));
                                
                value = *((PULONG)(((PCHAR)keyValueInfo)+keyValueInfo->DataOffset));
                DBGOUT(("RegistryAccessSample: value is %xh.", value));
            }
            else {
                DBGOUT(("ZwQueryValueKey failed with %xh.", status));
            }
	    
	    ExFreePool(keyValueInfo);
        }
        else {
            ASSERT(keyValueInfo);
        }

        ZwClose(hRegDevice);
    }
    else {
        DBGOUT(("IoOpenDeviceRegistryKey failed with %xh.", status));
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\fchba\inc\hbaapi.h ===
//***************************************************************************
//
//  main.c
// 
//  Module: Windows HBA API implmentation
//
//  Purpose: Contains HBA api header
//
//  Copyright (c) 2001 Microsoft Corporation
//
//***************************************************************************

#ifdef _HBAAPIP_
#define HBA_API __cdecl
#else
#define HBA_API DECLSPEC_IMPORT __cdecl
#endif

#define HBA_VERSION 1

typedef ULONGLONG HBA_UINT64;
typedef LONGLONG HBA_INT64;
typedef ULONG HBA_UINT32;
typedef USHORT HBA_UINT16;
typedef UCHAR HBA_UINT8;

typedef HBA_UINT32 HBA_HANDLE;

typedef HBA_UINT32 HBA_STATUS;

#define HBA_STATUS_OK 0
#define HBA_STATUS_ERROR 1 /* Error */
#define HBA_STATUS_ERROR_NOT_SUPPORTED 2 /* Function not supported.*/
#define HBA_STATUS_ERROR_INVALID_HANDLE 3 /* invalid handle */
#define HBA_STATUS_ERROR_ARG 4 /* Bad argument */
#define HBA_STATUS_ERROR_ILLEGAL_WWN 5 /* WWN not recognized */
#define HBA_STATUS_ERROR_ILLEGAL_INDEX 6 /* Index not recognized */
#define HBA_STATUS_ERROR_MORE_DATA 7 /* Larger buffer required */
#define HBA_STATUS_ERROR_STALE_DATA 8 /* Data is stale, HBARefreshInformation is required */

typedef HBA_UINT32 HBA_PORTTYPE;

#define HBA_PORTTYPE_UNKNOWN 1 /* Unknown */
#define HBA_PORTTYPE_OTHER 2 /* Other */
#define HBA_PORTTYPE_NOTPRESENT 3 /* Not present */
#define HBA_PORTTYPE_NPORT 5 /* Fabric */
#define HBA_PORTTYPE_NLPORT 6 /* Public Loop */
#define HBA_PORTTYPE_FLPORT 7
#define HBA_PORTTYPE_FPORT 8 /* Fabric Port */
#define HBA_PORTTYPE_EPORT 9 /* Fabric expansion port */
#define HBA_PORTTYPE_GPORT 10 /* Generic Fabric Port */
#define HBA_PORTTYPE_LPORT 20 /* Private Loop */
#define HBA_PORTTYPE_PTP 21 /* Point to Point */

typedef HBA_UINT32 HBA_PORTSTATE;
#define HBA_PORTSTATE_UNKNOWN 1 /* Unknown */
#define HBA_PORTSTATE_ONLINE 2 /* Operational */
#define HBA_PORTSTATE_OFFLINE 3 /* User Offline */
#define HBA_PORTSTATE_BYPASSED 4 /* Bypassed */
#define HBA_PORTSTATE_DIAGNOSTICS 5 /* In diagnostics mode */
#define HBA_PORTSTATE_LINKDOWN 6 /* Link Down */
#define HBA_PORTSTATE_ERROR 7 /* Port Error */
#define HBA_PORTSTATE_LOOPBACK 8 /* Loopback */

typedef HBA_UINT32 HBA_PORTSPEED;
#define HBA_PORTSPEED_1GBIT 1 /* 1 GBit/sec */
#define HBA_PORTSPEED_2GBIT 2 /* 2 GBit/sec */
#define HBA_PORTSPEED_10GBIT 4 /* 10 GBit/sec */

typedef HBA_UINT32 HBA_COS;

typedef struct HBA_fc4types {
	HBA_UINT8 bits[32]; /* 32 bytes of FC-4 per GS-2 */
} HBA_FC4TYPES, *PHBA_FC4TYPES;

typedef struct HBA_wwn {
	HBA_UINT8 wwn[8];
} HBA_WWN, *PHBA_WWN;

typedef struct HBA_ipaddress {
	int ipversion; // see enumerations in RNID
	union
	{
		unsigned char ipv4address[4];
		unsigned char ipv6address[16];
	} ipaddress;
} HBA_IPADDRESS, *PHBA_IPADDRESS;

typedef struct HBA_AdapterAttributes {
	char Manufacturer[64]; /*Emulex */
	char SerialNumber[64]; /* A12345 */
	char Model[256]; /* QLA2200 */
	char ModelDescription[256]; /* Agilent TachLite */
	HBA_WWN NodeWWN;
	char NodeSymbolicName[256]; /* From GS-2 */
	char HardwareVersion[256]; /* Vendor use */
	char DriverVersion[256]; /* Vendor use */
	char OptionROMVersion[256]; /* Vendor use - i.e. hardware boot ROM*/
	char FirmwareVersion[256]; /* Vendor use */
	HBA_UINT32 VendorSpecificID; /* Vendor specific */
	HBA_UINT32 NumberOfPorts;
	char DriverName[256]; /* Binary path and/or name of driver file. */
} HBA_ADAPTERATTRIBUTES, *PHBA_ADAPTERATTRIBUTES;

typedef struct HBA_PortAttributes {
	HBA_WWN NodeWWN;
	HBA_WWN PortWWN;
	HBA_UINT32 PortFcId;
	HBA_PORTTYPE PortType; /*PTP, Fabric, etc. */
	HBA_PORTSTATE PortState;
	HBA_COS PortSupportedClassofService;
	HBA_FC4TYPES PortSupportedFc4Types;
	HBA_FC4TYPES PortActiveFc4Types;
	char PortSymbolicName[256];
	char OSDeviceName[256]; /* \device\ScsiPort3 */
	HBA_PORTSPEED PortSupportedSpeed;
	HBA_PORTSPEED PortSpeed;
	HBA_UINT32 PortMaxFrameSize;
	HBA_WWN FabricName;
	HBA_UINT32 NumberofDiscoveredPorts;
} HBA_PORTATTRIBUTES, *PHBA_PORTATTRIBUTES;

typedef struct HBA_PortStatistics {
	HBA_INT64 SecondsSinceLastReset;
	HBA_INT64 TxFrames;
	HBA_INT64 TxWords;
	HBA_INT64 RxFrames;
	HBA_INT64 RxWords;
	HBA_INT64 LIPCount;
	HBA_INT64 NOSCount;
	HBA_INT64 ErrorFrames;
	HBA_INT64 DumpedFrames;
	HBA_INT64 LinkFailureCount;
	HBA_INT64 LossOfSyncCount;
	HBA_INT64 LossOfSignalCount;
	HBA_INT64 PrimitiveSeqProtocolErrCount;
	HBA_INT64 InvalidTxWordCount;
	HBA_INT64 InvalidCRCCount;
} HBA_PORTSTATISTICS, *PHBA_PORTSTATISTICS;

typedef enum HBA_fcpbindingtype { TO_D_ID, TO_WWN } HBA_FCPBINDINGTYPE;

typedef struct HBA_ScsiId {
	char OSDeviceName[256]; /* \device\ScsiPort3 */
	HBA_UINT32 ScsiBusNumber; /* Bus on the HBA */
	HBA_UINT32 ScsiTargetNumber; /* SCSI Target ID to OS */
	HBA_UINT32 ScsiOSLun;
} HBA_SCSIID, *PHBA_SCSIID;

typedef struct HBA_FcpId {
	HBA_UINT32 FcId;
	HBA_WWN NodeWWN;
	HBA_WWN PortWWN;
	HBA_UINT64 FcpLun;
} HBA_FCPID, *PHBA_FCPID;

typedef struct HBA_FcpScsiEntry {
	HBA_SCSIID ScsiId;
	HBA_FCPID FcpId;
} HBA_FCPSCSIENTRY, *PHBA_FCPSCSIENTRY;

typedef struct HBA_FCPTargetMapping {
	HBA_UINT32 NumberOfEntries;
	HBA_FCPSCSIENTRY entry[1]; /* Variable length array containing mappings*/
} HBA_FCPTARGETMAPPING, *PHBA_FCPTARGETMAPPING;

typedef struct HBA_FCPBindingEntry {
	HBA_FCPBINDINGTYPE type;
	HBA_SCSIID ScsiId;
	HBA_FCPID FcpId;
} HBA_FCPBINDINGENTRY, *PHBA_FCPBINDINGENTRY;

typedef struct HBA_FCPBinding {
	HBA_UINT32 NumberOfEntries;
	HBA_FCPBINDINGENTRY entry[1]; /* Variable length array */
} HBA_FCPBINDING, *PHBA_FCPBINDING;

typedef enum HBA_wwntype { NODE_WWN, PORT_WWN } HBA_WWNTYPE;

typedef struct HBA_MgmtInfo {
	HBA_WWN wwn;
	HBA_UINT32 unittype;
	HBA_UINT32 PortId;
	HBA_UINT32 NumberOfAttachedNodes;
	HBA_UINT16 IPVersion;
	HBA_UINT16 UDPPort;
	HBA_UINT8 IPAddress[16];
	HBA_UINT16 reserved;
	HBA_UINT16 TopologyDiscoveryFlags;
} HBA_MGMTINFO, *PHBA_MGMTINFO;

#define HBA_EVENT_LIP_OCCURRED 1
#define HBA_EVENT_LINK_UP 2
#define HBA_EVENT_LINK_DOWN 3
#define HBA_EVENT_LIP_RESET_OCCURRED 4
#define HBA_EVENT_RSCN 5
#define HBA_EVENT_PROPRIETARY 0xFFFF

typedef struct HBA_Link_EventInfo {
	HBA_UINT32 PortFcId; /* Port which this event occurred */
	HBA_UINT32 Reserved[3];
} HBA_LINK_EVENTINFO, *PHBA_LINK_EVENTINFO;

typedef struct HBA_RSCN_EventInfo {
	HBA_UINT32 PortFcId; /* Port which this event occurred */
	HBA_UINT32 NPortPage; /* Reference FC-FS for RSCN ELS "Affected N-Port Pages"*/
	HBA_UINT32 Reserved[2];
} HBA_RSCN_EVENTINFO, *PHBA_RSCN_EVENTINFO;

typedef struct HBA_Pty_EventInfo {
	HBA_UINT32 PtyData[4]; /* Proprietary data */
} HBA_PTY_EVENTINFO, *PHBA_PTY_EVENTINFO;

typedef struct HBA_EventInfo {
	HBA_UINT32 EventCode;
	union {
		HBA_LINK_EVENTINFO Link_EventInfo;
		HBA_RSCN_EVENTINFO RSCN_EventInfo;
		HBA_PTY_EVENTINFO Pty_EventInfo;
	} Event;
} HBA_EVENTINFO, *PHBA_EVENTINFO;

typedef PVOID PHBA_ENTRYPOINTS;

HBA_STATUS HBA_API HBA_RegisterLibrary(PHBA_ENTRYPOINTS entrypoints);

HBA_UINT32 HBA_API HBA_GetVersion();
HBA_STATUS HBA_API  HBA_LoadLibrary();
HBA_STATUS HBA_API HBA_FreeLibrary();

HBA_UINT32 HBA_API HBA_GetNumberOfAdapters();

HBA_STATUS HBA_API HBA_GetAdapterName(HBA_UINT32 adapterindex, char *adaptername);


HBA_HANDLE HBA_API HBA_OpenAdapter(
    char* adaptername
);

void HBA_API HBA_CloseAdapter(
					  HBA_HANDLE handle
);

HBA_STATUS HBA_API HBA_GetAdapterAttributes(
	HBA_HANDLE handle,
	HBA_ADAPTERATTRIBUTES *hbaattributes
);

HBA_STATUS HBA_API HBA_GetAdapterPortAttributes(
	HBA_HANDLE handle,
	HBA_UINT32 portindex,
	HBA_PORTATTRIBUTES *portattributes
);

HBA_STATUS HBA_API HBA_GetPortStatistics(
	HBA_HANDLE handle,
	HBA_UINT32 portindex,
	HBA_PORTSTATISTICS *portstatistics
);


HBA_STATUS HBA_API HBA_GetDiscoveredPortAttributes(
	HBA_HANDLE handle,
	HBA_UINT32 portindex,
	HBA_UINT32 discoveredportindex,
	HBA_PORTATTRIBUTES *portattributes
);

HBA_STATUS HBA_API HBA_GetPortAttributesByWWN(
	HBA_HANDLE handle,
	HBA_WWN PortWWN,
	HBA_PORTATTRIBUTES *portattributes
);

HBA_STATUS HBA_API HBA_SendCTPassThru(
	HBA_HANDLE handle,
	void * pReqBuffer,
	HBA_UINT32 ReqBufferSize,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize
);

HBA_STATUS HBA_API HBA_GetEventBuffer(
	HBA_HANDLE handle,
	PHBA_EVENTINFO EventBuffer,
	HBA_UINT32 *EventCount);

HBA_STATUS HBA_API HBA_SetRNIDMgmtInfo(
	HBA_HANDLE handle,
	HBA_MGMTINFO *pInfo);

HBA_STATUS HBA_API HBA_GetRNIDMgmtInfo(
	HBA_HANDLE handle,
	HBA_MGMTINFO *pInfo);

HBA_STATUS HBA_API HBA_SendRNID(
	HBA_HANDLE handle,
	HBA_WWN wwn,
	HBA_WWNTYPE wnntype,
	void * pRspBuffer,
	HBA_UINT32 *RspBufferSize
);

HBA_STATUS HBA_API HBA_GetFcpTargetMapping (
    HBA_HANDLE handle,
    PHBA_FCPTARGETMAPPING mapping
);

HBA_STATUS HBA_API HBA_GetFcpPersistentBinding (
    HBA_HANDLE handle,
	PHBA_FCPBINDING binding
);

HBA_STATUS HBA_API HBA_SendScsiInquiry (
	HBA_HANDLE handle,
	HBA_WWN PortWWN,
	HBA_UINT64 fcLUN,
	HBA_UINT8 EVPD,
	HBA_UINT32 PageCode,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize);

HBA_STATUS HBA_API HBA_SendReportLUNs (
	HBA_HANDLE handle,
	HBA_WWN portWWN,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize
);

HBA_STATUS HBA_API HBA_SendReadCapacity (
	HBA_HANDLE handle,
	HBA_WWN portWWN,
	HBA_UINT64 fcLUN,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize
);

void HBA_API HBA_RefreshInformation(HBA_HANDLE handle);
void HBA_API HBA_ResetStatistics(HBA_HANDLE handle, HBA_UINT32 portindex);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\fchba\hbaapi\main.c ===
//***************************************************************************
//
//  main.c
// 
//  Module: Windows HBA API implmentation
//
//  Purpose: Contains DLL entry points and main HBA api functions
//
//  Copyright (c) 2001 Microsoft Corporation
//
//***************************************************************************


#include "hbaapip.h"

#include <stdio.h>

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************

HANDLE Module;

BOOL WINAPI LibMain32(
	HINSTANCE Instance,
    ULONG Reason,
    LPVOID pvReserved
    )
{
    if (DLL_PROCESS_ATTACH==Reason)
	{		
		Mutex = CreateMutex(NULL,
							FALSE,
							NULL);

		if (Mutex == NULL)
		{
			return(FALSE);
		}
		
        Module = Instance;
		DisableThreadLibraryCalls(Module);
	}
    return(TRUE);
}

//
// Main HBA Apis
//
HBA_STATUS HBA_API HBA_RegisterLibrary(
    PHBA_ENTRYPOINTS entrypoints
    )
{
	return(HBA_STATUS_ERROR_NOT_SUPPORTED);
}

HBA_UINT32 HBA_API HBA_GetVersion(
    void
    )
{
	return(HBA_VERSION);
}

HBA_STATUS HBA_API HBA_LoadLibrary(
    )
{
	return(HBA_STATUS_OK);
}

HBA_STATUS HBA_API HBA_FreeLibrary(
    void
    )
{
	return(HBA_STATUS_OK);
}


HBA_UINT32 HBA_API HBA_GetNumberOfAdapters(
    void								   
    )
{
	HANDLE Handle;
	PWNODE_ALL_DATA Buffer;
	ULONG Count = 0;
	ULONG Status;

	Status = WmiOpenBlock((LPGUID)&MSFC_FCAdapterHBAAttributes_GUID,
						  GENERIC_READ,
						  &Handle);

	if (Status == ERROR_SUCCESS)
	{
		Status = QueryAllData(Handle,
							  &Buffer);

		if (Status == ERROR_SUCCESS)
		{
			Status = ParseAllData(Buffer,
								  &Count,
								  NULL,
								  NULL,
								  NULL),
			FreeMemory(Buffer);
								  
		}
		WmiCloseBlock(Handle);
	}
	
	return( Count );
}

HBA_STATUS HBA_GetAdapterNameW(
	IN HBA_UINT32 AdapterIndex,
    OUT PWCHAR AdapterName
	)
{
	HANDLE Handle;
	PWNODE_ALL_DATA Buffer;
	HBA_STATUS HbaStatus = HBA_STATUS_ERROR;
	ULONG Count;
	ULONG Len;
	PWCHAR Name;
	ULONG Status;
	PUSHORT *InstanceNames;

	Status = WmiOpenBlock((LPGUID)&MSFC_FCAdapterHBAAttributes_GUID,
						  GENERIC_READ,
						  &Handle);

	if (Status == ERROR_SUCCESS)
	{
		Status = QueryAllData(Handle,
							  &Buffer);

		if (Status == ERROR_SUCCESS)
		{
			Status = ParseAllData(Buffer,
								  &Count,
								  &InstanceNames,
								  NULL,
								  NULL);
			if (Status == ERROR_SUCCESS)
			{
				if (AdapterIndex < Count)
				{
					Name = InstanceNames[AdapterIndex];
					Len = *Name++;
					wcsncpy(AdapterName, Name, Len/sizeof(WCHAR));
					AdapterName[Len] = 0;
					HbaStatus = HBA_STATUS_OK;
				}
				FreeMemory(InstanceNames);
			}
			
			FreeMemory(Buffer);
								  
		}
		WmiCloseBlock(Handle);
	}
	
	return(HbaStatus);
}

HBA_STATUS HBA_API HBA_GetAdapterName(
	IN HBA_UINT32 AdapterIndex,
    OUT PCHAR AdapterName
	)
{
	WCHAR AdapterNameW[256];
	HBA_STATUS HbaStatus;
	ULONG Status;

    HbaStatus = HBA_GetAdapterNameW(AdapterIndex,
									AdapterNameW);

	if (HbaStatus == HBA_STATUS_OK)
	{
		Status = UnicodeToAnsi(AdapterNameW,
							   AdapterName,
							  256);
		if (Status != ERROR_SUCCESS)
		{
			HbaStatus = HBA_STATUS_ERROR;
		}
	}
	return(HbaStatus);
}


HBA_HANDLE HBA_OpenAdapterW(
    PWCHAR AdapterName
)
{
	HBA_HANDLE HbaHandle = 0;
	HANDLE Handle;
	PADAPTER_HANDLE HandleData;
	ULONG Status;
	PWNODE_SINGLE_INSTANCE Buffer;
	
	Status = WmiOpenBlock((LPGUID)&MSFC_FCAdapterHBAAttributes_GUID,
						  GENERIC_READ,
						  &Handle);

    if (Status == ERROR_SUCCESS)
	{
		//
		// Validate adapter name by querying for that adapter name as a
		// WMI instance name
		//
		Status = QuerySingleInstance(Handle,
									 AdapterName,
									 &Buffer);

		if (Status == ERROR_SUCCESS)
		{
			//
			// If it exists then we allocate an adapter handle data
			// structure and insert it on the list of open adapter
			// handles
			//
			HandleData = AllocMemory(sizeof(ADAPTER_HANDLE));
			if (HandleData != NULL)
			{
				memset(HandleData, 0, sizeof(ADAPTER_HANDLE));
				HandleData->InstanceName = AllocMemory((wcslen(AdapterName) + 1) *
													    sizeof(WCHAR));
				if (HandleData->InstanceName != NULL)
				{
					wcscpy(HandleData->InstanceName, AdapterName);
					
					EnterCritSection();
					HandleData->HbaHandle = HbaHandleCounter++;
					InsertHeadList(&HbaHandleList, &HandleData->List);
					LeaveCritSection();
					HbaHandle = HandleData->HbaHandle;
				} else {
					FreeMemory(HandleData);
				}
			}
			FreeMemory(Buffer);
		}
		WmiCloseBlock(Handle);
	}
	return(HbaHandle);
}


HBA_HANDLE HBA_API HBA_OpenAdapter(
    PCHAR AdapterName
)
{
	PWCHAR AdapterNameW;
	ULONG Len, AllocLen;
	ULONG Status;
	HBA_HANDLE HbaHandle;

	Len = strlen(AdapterName) + 1;
	AllocLen = Len * sizeof(WCHAR);

	AdapterNameW = AllocMemory(AllocLen);
	if (AdapterNameW != NULL)
	{
		Status = AnsiToUnicode(AdapterName,
							   AdapterNameW,
							   Len);
							   
		HbaHandle = HBA_OpenAdapterW(AdapterNameW);
		
		FreeMemory(AdapterNameW);
	}
	
	return(HbaHandle);
}

void HBA_API HBA_CloseAdapter(
    HBA_HANDLE HbaHandle
)
{
	PADAPTER_HANDLE HandleData;
	
	HandleData = GetDataByHandle(HbaHandle);
	if (HandleData != NULL)
	{
		EnterCritSection();
		RemoveEntryList(&HandleData->List);
		LeaveCritSection();
		FreeMemory(HandleData->InstanceName);
		FreeMemory(HandleData);
	}
}

#if DBG
ULONG HbaapiDebugSpew = 1;

VOID
HbaapiDebugPrint(
    PCHAR DebugMessage,
    ...
    )
/*++

Routine Description:

    Debug print for properties pages - stolen from classpnp\class.c

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
	CHAR SpewBuffer[DEBUG_BUFFER_LENGTH];
    va_list ap;

    va_start(ap, DebugMessage);

	if (HbaapiDebugSpew)
	{
        _vsnprintf(SpewBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

        OutputDebugStringA(SpewBuffer);
    }

    va_end(ap);

} // end WmiDebugPrint()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\fchba\inc\hbadata.h ===
#ifndef _hbadata_h_
#define _hbadata_h_

// MSFC_FibrePortHBAStatistics - MSFC_FibrePortHBAStatistics
// This class exposes statistical information associated with a Fibre Channel port. There should be one instance of this class for each port.
#define MSFC_FibrePortHBAStatisticsGuid \
    { 0x27efaba4,0x362a,0x4f20, { 0x92,0x0b,0xed,0x66,0xe2,0x80,0xfc,0xf5 } }

DEFINE_GUID(MSFC_FibrePortHBAStatistics_GUID, \
            0x27efaba4,0x362a,0x4f20,0x92,0x0b,0xed,0x66,0xe2,0x80,0xfc,0xf5);


typedef struct _MSFC_FibrePortHBAStatistics
{
    // Unique identifier for the port. This idenitifer must be unique among all ports on all adapters. The same value for the identifier must be used for the same port in other classes that expose port information
    ULONGLONG UniquePortId;
    #define MSFC_FibrePortHBAStatistics_UniquePortId_SIZE sizeof(ULONGLONG)
    #define MSFC_FibrePortHBAStatistics_UniquePortId_ID 1

    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define MSFC_FibrePortHBAStatistics_HBAStatus_SIZE sizeof(ULONG)
    #define MSFC_FibrePortHBAStatistics_HBAStatus_ID 2

    // 
    LONGLONG SecondsSinceLastReset;
    #define MSFC_FibrePortHBAStatistics_SecondsSinceLastReset_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_SecondsSinceLastReset_ID 3

    // 
    LONGLONG TxFrames;
    #define MSFC_FibrePortHBAStatistics_TxFrames_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_TxFrames_ID 4

    // 
    LONGLONG TxWords;
    #define MSFC_FibrePortHBAStatistics_TxWords_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_TxWords_ID 5

    // 
    LONGLONG RxFrames;
    #define MSFC_FibrePortHBAStatistics_RxFrames_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_RxFrames_ID 6

    // 
    LONGLONG RxWords;
    #define MSFC_FibrePortHBAStatistics_RxWords_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_RxWords_ID 7

    // 
    LONGLONG LIPCount;
    #define MSFC_FibrePortHBAStatistics_LIPCount_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_LIPCount_ID 8

    // 
    LONGLONG NOSCount;
    #define MSFC_FibrePortHBAStatistics_NOSCount_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_NOSCount_ID 9

    // 
    LONGLONG ErrorFrames;
    #define MSFC_FibrePortHBAStatistics_ErrorFrames_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_ErrorFrames_ID 10

    // 
    LONGLONG DumpedFrames;
    #define MSFC_FibrePortHBAStatistics_DumpedFrames_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_DumpedFrames_ID 11

    // 
    LONGLONG LinkFailureCount;
    #define MSFC_FibrePortHBAStatistics_LinkFailureCount_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_LinkFailureCount_ID 12

    // 
    LONGLONG LossOfSyncCount;
    #define MSFC_FibrePortHBAStatistics_LossOfSyncCount_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_LossOfSyncCount_ID 13

    // 
    LONGLONG LossOfSignalCount;
    #define MSFC_FibrePortHBAStatistics_LossOfSignalCount_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_LossOfSignalCount_ID 14

    // 
    LONGLONG PrimitiveSeqProtocolErrCount;
    #define MSFC_FibrePortHBAStatistics_PrimitiveSeqProtocolErrCount_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_PrimitiveSeqProtocolErrCount_ID 15

    // 
    LONGLONG InvalidTxWordCount;
    #define MSFC_FibrePortHBAStatistics_InvalidTxWordCount_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_InvalidTxWordCount_ID 16

    // 
    LONGLONG InvalidCRCCount;
    #define MSFC_FibrePortHBAStatistics_InvalidCRCCount_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_InvalidCRCCount_ID 17

} MSFC_FibrePortHBAStatistics, *PMSFC_FibrePortHBAStatistics;

// MSFC_HBAPortAttributesResults - MSFC_HBAPortAttributesResults
#define MSFC_HBAPortAttributesResultsGuid \
    { 0xa76bd4e3,0x9961,0x4d9b, { 0xb6,0xbe,0x86,0xe6,0x98,0x26,0x0f,0x68 } }

DEFINE_GUID(MSFC_HBAPortAttributesResults_GUID, \
            0xa76bd4e3,0x9961,0x4d9b,0xb6,0xbe,0x86,0xe6,0x98,0x26,0x0f,0x68);


typedef struct _MSFC_HBAPortAttributesResults
{
    // 
    UCHAR NodeWWN[8];
    #define MSFC_HBAPortAttributesResults_NodeWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_HBAPortAttributesResults_NodeWWN_ID 1

    // 
    UCHAR PortWWN[8];
    #define MSFC_HBAPortAttributesResults_PortWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_HBAPortAttributesResults_PortWWN_ID 2

    // 
    ULONG PortFcId;
    #define MSFC_HBAPortAttributesResults_PortFcId_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortFcId_ID 3

    // 
    ULONG PortType;
    #define MSFC_HBAPortAttributesResults_PortType_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortType_ID 4

    // 
    ULONG PortState;
    #define MSFC_HBAPortAttributesResults_PortState_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortState_ID 5

    // 
    ULONG PortSupportedClassofService;
    #define MSFC_HBAPortAttributesResults_PortSupportedClassofService_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortSupportedClassofService_ID 6

    // 
    UCHAR PortSupportedFc4Types[32];
    #define MSFC_HBAPortAttributesResults_PortSupportedFc4Types_SIZE sizeof(UCHAR[32])
    #define MSFC_HBAPortAttributesResults_PortSupportedFc4Types_ID 7

    // 
    UCHAR PortActiveFc4Types[32];
    #define MSFC_HBAPortAttributesResults_PortActiveFc4Types_SIZE sizeof(UCHAR[32])
    #define MSFC_HBAPortAttributesResults_PortActiveFc4Types_ID 8

    // 
    ULONG PortSupportedSpeed;
    #define MSFC_HBAPortAttributesResults_PortSupportedSpeed_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortSupportedSpeed_ID 9

    // 
    ULONG PortSpeed;
    #define MSFC_HBAPortAttributesResults_PortSpeed_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortSpeed_ID 10

    // 
    ULONG PortMaxFrameSize;
    #define MSFC_HBAPortAttributesResults_PortMaxFrameSize_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortMaxFrameSize_ID 11

    // 
    UCHAR FabricName[8];
    #define MSFC_HBAPortAttributesResults_FabricName_SIZE sizeof(UCHAR[8])
    #define MSFC_HBAPortAttributesResults_FabricName_ID 12

    // 
    ULONG NumberofDiscoveredPorts;
    #define MSFC_HBAPortAttributesResults_NumberofDiscoveredPorts_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_NumberofDiscoveredPorts_ID 13

    // 
    WCHAR PortSymbolicName[256 + 1];
    #define MSFC_HBAPortAttributesResults_PortSymbolicName_ID 14

    // 
    WCHAR OSDeviceName[256 + 1];
    #define MSFC_HBAPortAttributesResults_OSDeviceName_ID 15

} MSFC_HBAPortAttributesResults, *PMSFC_HBAPortAttributesResults;

// MSFC_FibrePortHBAAttributes - MSFC_FibrePortHBAAttributes
// This class exposes attribute information associated with a Fibre Channel port. There should be one instance of this class for each port.
#define MSFC_FibrePortHBAAttributesGuid \
    { 0x61b397fd,0xf5ae,0x4950, { 0x97,0x58,0x0e,0xe5,0x98,0xe3,0xc6,0xe6 } }

DEFINE_GUID(MSFC_FibrePortHBAAttributes_GUID, \
            0x61b397fd,0xf5ae,0x4950,0x97,0x58,0x0e,0xe5,0x98,0xe3,0xc6,0xe6);


typedef struct _MSFC_FibrePortHBAAttributes
{
    // Unique identifier for the port. This idenitifer must be unique among all ports on all adapters. The same value for the identifier must be used for the same port in other classes that expose port information
    ULONGLONG UniquePortId;
    #define MSFC_FibrePortHBAAttributes_UniquePortId_SIZE sizeof(ULONGLONG)
    #define MSFC_FibrePortHBAAttributes_UniquePortId_ID 1

    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define MSFC_FibrePortHBAAttributes_HBAStatus_SIZE sizeof(ULONG)
    #define MSFC_FibrePortHBAAttributes_HBAStatus_ID 2

    // 
    MSFC_HBAPortAttributesResults Attributes;
    #define MSFC_FibrePortHBAAttributes_Attributes_SIZE sizeof(MSFC_HBAPortAttributesResults)
    #define MSFC_FibrePortHBAAttributes_Attributes_ID 3

} MSFC_FibrePortHBAAttributes, *PMSFC_FibrePortHBAAttributes;

// MSFC_FibrePortHBAMethods - MSFC_FibrePortHBAMethods
// This class exposes operations that can be performed on a Fibre Channel port. There should be one instance of this class for each port.
#define MSFC_FibrePortHBAMethodsGuid \
    { 0xe693553e,0xedf6,0x4d57, { 0xbf,0x08,0xef,0xca,0xae,0x1a,0x2e,0x1c } }

DEFINE_GUID(MSFC_FibrePortHBAMethods_GUID, \
            0xe693553e,0xedf6,0x4d57,0xbf,0x08,0xef,0xca,0xae,0x1a,0x2e,0x1c);

//
// Method id definitions for MSFC_FibrePortHBAMethods
#define ResetStatistics     1

// MSFC_FCAdapterHBAAttributes - MSFC_FCAdapterHBAAttributes
// This class exposes attribute information associated with a fibre channel adapter. There should be one instance of this class for each adapter
#define MSFC_FCAdapterHBAAttributesGuid \
    { 0xf8f3ea26,0xab2c,0x4593, { 0x8b,0x84,0xc5,0x64,0x28,0xe6,0xbe,0xdb } }

DEFINE_GUID(MSFC_FCAdapterHBAAttributes_GUID, \
            0xf8f3ea26,0xab2c,0x4593,0x8b,0x84,0xc5,0x64,0x28,0xe6,0xbe,0xdb);


typedef struct _MSFC_FCAdapterHBAAttributes
{
    // Unique identifier for the adapter. This idenitifer must be unique among all adapters. The same value for the identifier must be used for the same adapter in other classes that expose adapter information
    ULONGLONG UniqueAdapterId;
    #define MSFC_FCAdapterHBAAttributes_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MSFC_FCAdapterHBAAttributes_UniqueAdapterId_ID 1

    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define MSFC_FCAdapterHBAAttributes_HBAStatus_SIZE sizeof(ULONG)
    #define MSFC_FCAdapterHBAAttributes_HBAStatus_ID 2

    // 
    UCHAR NodeWWN[8];
    #define MSFC_FCAdapterHBAAttributes_NodeWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_FCAdapterHBAAttributes_NodeWWN_ID 3

    // 
    ULONG VendorSpecificID;
    #define MSFC_FCAdapterHBAAttributes_VendorSpecificID_SIZE sizeof(ULONG)
    #define MSFC_FCAdapterHBAAttributes_VendorSpecificID_ID 4

    // 
    ULONG NumberOfPorts;
    #define MSFC_FCAdapterHBAAttributes_NumberOfPorts_SIZE sizeof(ULONG)
    #define MSFC_FCAdapterHBAAttributes_NumberOfPorts_ID 5

    // 
    WCHAR Manufacturer[64 + 1];
    #define MSFC_FCAdapterHBAAttributes_Manufacturer_ID 6

    // 
    WCHAR SerialNumber[64 + 1];
    #define MSFC_FCAdapterHBAAttributes_SerialNumber_ID 7

    // 
    WCHAR Model[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_Model_ID 8

    // 
    WCHAR ModelDescription[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_ModelDescription_ID 9

    // 
    WCHAR NodeSymbolicName[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_NodeSymbolicName_ID 10

    // 
    WCHAR HardwareVersion[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_HardwareVersion_ID 11

    // 
    WCHAR DriverVersion[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_DriverVersion_ID 12

    // 
    WCHAR OptionROMVersion[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_OptionROMVersion_ID 13

    // 
    WCHAR FirmwareVersion[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_FirmwareVersion_ID 14

    // 
    WCHAR DriverName[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_DriverName_ID 15

} MSFC_FCAdapterHBAAttributes, *PMSFC_FCAdapterHBAAttributes;

// HBAFC3MgmtInfo - HBAFC3MgmtInfo
// This class exposes FC3 Management information associated with a fibre channel adapter. There should be one instance of this class for each adapter
#define HBAFC3MgmtInfoGuid \
    { 0x5966a24f,0x6aa5,0x418e, { 0xb7,0x5c,0x2f,0x21,0x4d,0xfb,0x4b,0x18 } }

DEFINE_GUID(HBAFC3MgmtInfo_GUID, \
            0x5966a24f,0x6aa5,0x418e,0xb7,0x5c,0x2f,0x21,0x4d,0xfb,0x4b,0x18);


typedef struct _HBAFC3MgmtInfo
{
    // Unique identifier for the adapter. This idenitifer must be unique among all adapters. The same value for the identifier must be used for the same adapter in other classes that expose adapter information
    ULONGLONG UniqueAdapterId;
    #define HBAFC3MgmtInfo_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define HBAFC3MgmtInfo_UniqueAdapterId_ID 1

    // 
    UCHAR wwn[8];
    #define HBAFC3MgmtInfo_wwn_SIZE sizeof(UCHAR[8])
    #define HBAFC3MgmtInfo_wwn_ID 2

    // 
    ULONG unittype;
    #define HBAFC3MgmtInfo_unittype_SIZE sizeof(ULONG)
    #define HBAFC3MgmtInfo_unittype_ID 3

    // 
    ULONG PortId;
    #define HBAFC3MgmtInfo_PortId_SIZE sizeof(ULONG)
    #define HBAFC3MgmtInfo_PortId_ID 4

    // 
    ULONG NumberOfAttachedNodes;
    #define HBAFC3MgmtInfo_NumberOfAttachedNodes_SIZE sizeof(ULONG)
    #define HBAFC3MgmtInfo_NumberOfAttachedNodes_ID 5

    // 
    USHORT IPVersion;
    #define HBAFC3MgmtInfo_IPVersion_SIZE sizeof(USHORT)
    #define HBAFC3MgmtInfo_IPVersion_ID 6

    // 
    USHORT UDPPort;
    #define HBAFC3MgmtInfo_UDPPort_SIZE sizeof(USHORT)
    #define HBAFC3MgmtInfo_UDPPort_ID 7

    // 
    UCHAR IPAddress[16];
    #define HBAFC3MgmtInfo_IPAddress_SIZE sizeof(UCHAR[16])
    #define HBAFC3MgmtInfo_IPAddress_ID 8

    // 
    USHORT reserved;
    #define HBAFC3MgmtInfo_reserved_SIZE sizeof(USHORT)
    #define HBAFC3MgmtInfo_reserved_ID 9

    // 
    USHORT TopologyDiscoveryFlags;
    #define HBAFC3MgmtInfo_TopologyDiscoveryFlags_SIZE sizeof(USHORT)
    #define HBAFC3MgmtInfo_TopologyDiscoveryFlags_ID 10

} HBAFC3MgmtInfo, *PHBAFC3MgmtInfo;

// MSFC_HBAPortMethods - MSFC_HBAPortMethods
// This class exposes port discovery operations that can be by a fibre channel adapter. There should be one instance of this class for each adapter
#define MSFC_HBAPortMethodsGuid \
    { 0xdf87d4ed,0x4612,0x4d12, { 0x85,0xfb,0x83,0x57,0x4e,0xc3,0x4b,0x7c } }

DEFINE_GUID(MSFC_HBAPortMethods_GUID, \
            0xdf87d4ed,0x4612,0x4d12,0x85,0xfb,0x83,0x57,0x4e,0xc3,0x4b,0x7c);

//
// Method id definitions for MSFC_HBAPortMethods
#define GetDiscoveredPortAttributes     1
typedef struct _GetDiscoveredPortAttributes_IN
{
    // 
    ULONG PortIndex;
    #define GetDiscoveredPortAttributes_IN_PortIndex_SIZE sizeof(ULONG)
    #define GetDiscoveredPortAttributes_IN_PortIndex_ID 1

    // 
    ULONG DiscoveredPortIndex;
    #define GetDiscoveredPortAttributes_IN_DiscoveredPortIndex_SIZE sizeof(ULONG)
    #define GetDiscoveredPortAttributes_IN_DiscoveredPortIndex_ID 2

} GetDiscoveredPortAttributes_IN, *PGetDiscoveredPortAttributes_IN;

typedef struct _GetDiscoveredPortAttributes_OUT
{
    // HBA Status result for the operation
    ULONG HBAStatus;
    #define GetDiscoveredPortAttributes_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetDiscoveredPortAttributes_OUT_HBAStatus_ID 3

    // 
    MSFC_HBAPortAttributesResults PortAttributes;
    #define GetDiscoveredPortAttributes_OUT_PortAttributes_SIZE sizeof(MSFC_HBAPortAttributesResults)
    #define GetDiscoveredPortAttributes_OUT_PortAttributes_ID 4

} GetDiscoveredPortAttributes_OUT, *PGetDiscoveredPortAttributes_OUT;

#define GetPortAttributesByWWN     2
typedef struct _GetPortAttributesByWWN_IN
{
    // 
    UCHAR wwn[8];
    #define GetPortAttributesByWWN_IN_wwn_SIZE sizeof(UCHAR[8])
    #define GetPortAttributesByWWN_IN_wwn_ID 1

} GetPortAttributesByWWN_IN, *PGetPortAttributesByWWN_IN;

typedef struct _GetPortAttributesByWWN_OUT
{
    // HBA Status result for the operation
    ULONG HBAStatus;
    #define GetPortAttributesByWWN_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetPortAttributesByWWN_OUT_HBAStatus_ID 2

    // 
    MSFC_HBAPortAttributesResults PortAttributes;
    #define GetPortAttributesByWWN_OUT_PortAttributes_SIZE sizeof(MSFC_HBAPortAttributesResults)
    #define GetPortAttributesByWWN_OUT_PortAttributes_ID 3

} GetPortAttributesByWWN_OUT, *PGetPortAttributesByWWN_OUT;

#define RefreshInformation     3

// MSFC_HBAFc3MgmtMethods - MSFC_HBAFc3MgmtMethods
// This class exposes FC3 management operations that can be done by a fibre channel adapter. There should be one instance of this class for each adapter
#define MSFC_HBAFc3MgmtMethodsGuid \
    { 0x5f339b02,0x881b,0x454c, { 0xb6,0xa0,0xd7,0x34,0x49,0xa6,0x6f,0x0c } }

DEFINE_GUID(MSFC_HBAFc3MgmtMethods_GUID, \
            0x5f339b02,0x881b,0x454c,0xb6,0xa0,0xd7,0x34,0x49,0xa6,0x6f,0x0c);

//
// Method id definitions for MSFC_HBAFc3MgmtMethods
#define SendCTPassThru     1
typedef struct _SendCTPassThru_IN
{
    // 
    ULONG RequestBufferCount;
    #define SendCTPassThru_IN_RequestBufferCount_SIZE sizeof(ULONG)
    #define SendCTPassThru_IN_RequestBufferCount_ID 1

    // 
    UCHAR RequestBuffer[1];
    #define SendCTPassThru_IN_RequestBuffer_ID 2

} SendCTPassThru_IN, *PSendCTPassThru_IN;

typedef struct _SendCTPassThru_OUT
{
    // HBA Status result for the operation
    ULONG HBAStatus;
    #define SendCTPassThru_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendCTPassThru_OUT_HBAStatus_ID 3

    // 
    ULONG ResponseBufferCount;
    #define SendCTPassThru_OUT_ResponseBufferCount_SIZE sizeof(ULONG)
    #define SendCTPassThru_OUT_ResponseBufferCount_ID 4

    // 
    UCHAR ResponseBuffer[1];
    #define SendCTPassThru_OUT_ResponseBuffer_ID 5

} SendCTPassThru_OUT, *PSendCTPassThru_OUT;

#define SendRNID     2
typedef struct _SendRNID_IN
{
    // 
    UCHAR wwn[8];
    #define SendRNID_IN_wwn_SIZE sizeof(UCHAR[8])
    #define SendRNID_IN_wwn_ID 1

    // 
    ULONG wwntype;
    #define SendRNID_IN_wwntype_SIZE sizeof(ULONG)
    #define SendRNID_IN_wwntype_ID 2

} SendRNID_IN, *PSendRNID_IN;

typedef struct _SendRNID_OUT
{
    // HBA Status result for the operation
    ULONG HBAStatus;
    #define SendRNID_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendRNID_OUT_HBAStatus_ID 3

    // 
    ULONG ResponseBufferCount;
    #define SendRNID_OUT_ResponseBufferCount_SIZE sizeof(ULONG)
    #define SendRNID_OUT_ResponseBufferCount_ID 4

    // 
    UCHAR ResponseBuffer[1];
    #define SendRNID_OUT_ResponseBuffer_ID 5

} SendRNID_OUT, *PSendRNID_OUT;

#define GetFC3MgmtInfo     3
typedef struct _GetFC3MgmtInfo_OUT
{
    // HBA Status result for the operation
    ULONG HBAStatus;
    #define GetFC3MgmtInfo_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetFC3MgmtInfo_OUT_HBAStatus_ID 1

    // 
    HBAFC3MgmtInfo MgmtInfo;
    #define GetFC3MgmtInfo_OUT_MgmtInfo_SIZE sizeof(HBAFC3MgmtInfo)
    #define GetFC3MgmtInfo_OUT_MgmtInfo_ID 2

} GetFC3MgmtInfo_OUT, *PGetFC3MgmtInfo_OUT;

#define SetFC3MgmtInfo     4
typedef struct _SetFC3MgmtInfo_IN
{
    // 
    HBAFC3MgmtInfo MgmtInfo;
    #define SetFC3MgmtInfo_IN_MgmtInfo_SIZE sizeof(HBAFC3MgmtInfo)
    #define SetFC3MgmtInfo_IN_MgmtInfo_ID 2

} SetFC3MgmtInfo_IN, *PSetFC3MgmtInfo_IN;

typedef struct _SetFC3MgmtInfo_OUT
{
    // HBA Status result for the operation
    ULONG HBAStatus;
    #define SetFC3MgmtInfo_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SetFC3MgmtInfo_OUT_HBAStatus_ID 1

} SetFC3MgmtInfo_OUT, *PSetFC3MgmtInfo_OUT;


// HBAScsiID - HBAScsiID
#define HBAScsiIDGuid \
    { 0xa76f5058,0xb1f0,0x4622, { 0x9e,0x88,0x5c,0xc4,0x1e,0x34,0x45,0x4a } }

DEFINE_GUID(HBAScsiID_GUID, \
            0xa76f5058,0xb1f0,0x4622,0x9e,0x88,0x5c,0xc4,0x1e,0x34,0x45,0x4a);


typedef struct _HBAScsiID
{
    // 
    WCHAR OSDeviceName[256 + 1];
    #define HBAScsiID_OSDeviceName_ID 1

    // 
    ULONG ScsiBusNumber;
    #define HBAScsiID_ScsiBusNumber_SIZE sizeof(ULONG)
    #define HBAScsiID_ScsiBusNumber_ID 2

    // 
    ULONG ScsiTargetNumber;
    #define HBAScsiID_ScsiTargetNumber_SIZE sizeof(ULONG)
    #define HBAScsiID_ScsiTargetNumber_ID 3

    // 
    ULONG ScsiOSLun;
    #define HBAScsiID_ScsiOSLun_SIZE sizeof(ULONG)
    #define HBAScsiID_ScsiOSLun_ID 4

} HBAScsiID, *PHBAScsiID;

// HBAFCPID - HBAFCPID
#define HBAFCPIDGuid \
    { 0xff02bc96,0x7fb0,0x4bac, { 0x8f,0x97,0xc7,0x1e,0x49,0x5f,0xa6,0x98 } }

DEFINE_GUID(HBAFCPID_GUID, \
            0xff02bc96,0x7fb0,0x4bac,0x8f,0x97,0xc7,0x1e,0x49,0x5f,0xa6,0x98);


typedef struct _HBAFCPID
{
    // 
    ULONG Fcid;
    #define HBAFCPID_Fcid_SIZE sizeof(ULONG)
    #define HBAFCPID_Fcid_ID 1

    // 
    UCHAR NodeWWN[8];
    #define HBAFCPID_NodeWWN_SIZE sizeof(UCHAR[8])
    #define HBAFCPID_NodeWWN_ID 2

    // 
    UCHAR PortWWN[8];
    #define HBAFCPID_PortWWN_SIZE sizeof(UCHAR[8])
    #define HBAFCPID_PortWWN_ID 3

    // 
    ULONGLONG FcpLun;
    #define HBAFCPID_FcpLun_SIZE sizeof(ULONGLONG)
    #define HBAFCPID_FcpLun_ID 4

} HBAFCPID, *PHBAFCPID;

// HBAFCPScsiEntry - HBAFCPScsiEntry
#define HBAFCPScsiEntryGuid \
    { 0x77ca1248,0x1505,0x4221, { 0x8e,0xb6,0xbb,0xb6,0xec,0x77,0x1a,0x87 } }

DEFINE_GUID(HBAFCPScsiEntry_GUID, \
            0x77ca1248,0x1505,0x4221,0x8e,0xb6,0xbb,0xb6,0xec,0x77,0x1a,0x87);


typedef struct _HBAFCPScsiEntry
{
    // 
    HBAScsiID ScsiId;
    #define HBAFCPScsiEntry_ScsiId_SIZE sizeof(HBAScsiID)
    #define HBAFCPScsiEntry_ScsiId_ID 1

    // 
    HBAFCPID FCPId;
    #define HBAFCPScsiEntry_FCPId_SIZE sizeof(HBAFCPID)
    #define HBAFCPScsiEntry_FCPId_ID 2

} HBAFCPScsiEntry, *PHBAFCPScsiEntry;

// HBAFCPBindingEntry - HBAFCPBindingEntry
#define HBAFCPBindingEntryGuid \
    { 0xfceff8b7,0x9d6b,0x4115, { 0x84,0x22,0x05,0x99,0x24,0x51,0xa6,0x29 } }

DEFINE_GUID(HBAFCPBindingEntry_GUID, \
            0xfceff8b7,0x9d6b,0x4115,0x84,0x22,0x05,0x99,0x24,0x51,0xa6,0x29);


typedef struct _HBAFCPBindingEntry
{
    // 
    ULONG Type;
    #define HBAFCPBindingEntry_Type_SIZE sizeof(ULONG)
    #define HBAFCPBindingEntry_Type_ID 1

    // 
    HBAScsiID ScsiId;
    #define HBAFCPBindingEntry_ScsiId_SIZE sizeof(HBAScsiID)
    #define HBAFCPBindingEntry_ScsiId_ID 2

    // 
    HBAFCPID FCPId;
    #define HBAFCPBindingEntry_FCPId_SIZE sizeof(HBAFCPID)
    #define HBAFCPBindingEntry_FCPId_ID 3

} HBAFCPBindingEntry, *PHBAFCPBindingEntry;

// MSFC_HBAFCPInfo - MSFC_HBAFCPInfo
// This class exposes operations associated with FCP on a Fibre Channel adapter. There should be one instance of this class for each adapter.
#define MSFC_HBAFCPInfoGuid \
    { 0x7a1fc391,0x5b23,0x4c19, { 0xb0,0xeb,0xb1,0xae,0xf5,0x90,0x50,0xc3 } }

DEFINE_GUID(MSFC_HBAFCPInfo_GUID, \
            0x7a1fc391,0x5b23,0x4c19,0xb0,0xeb,0xb1,0xae,0xf5,0x90,0x50,0xc3);

//
// Method id definitions for MSFC_HBAFCPInfo
#define GetFcpTargetMapping     1
typedef struct _GetFcpTargetMapping_OUT
{
    // HBA Status result for the operation
    ULONG HBAStatus;
    #define GetFcpTargetMapping_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetFcpTargetMapping_OUT_HBAStatus_ID 1

    // 
    ULONG EntryCount;
    #define GetFcpTargetMapping_OUT_EntryCount_SIZE sizeof(ULONG)
    #define GetFcpTargetMapping_OUT_EntryCount_ID 2

    // 
    HBAFCPScsiEntry Entry[1];
    #define GetFcpTargetMapping_OUT_Entry_ID 3

} GetFcpTargetMapping_OUT, *PGetFcpTargetMapping_OUT;

#define GetFcpPersistentBinding     2
typedef struct _GetFcpPersistentBinding_OUT
{
    // HBA Status result for the operation
    ULONG HBAStatus;
    #define GetFcpPersistentBinding_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetFcpPersistentBinding_OUT_HBAStatus_ID 1

    // 
    ULONG EntryCount;
    #define GetFcpPersistentBinding_OUT_EntryCount_SIZE sizeof(ULONG)
    #define GetFcpPersistentBinding_OUT_EntryCount_ID 2

    // 
    HBAFCPBindingEntry Entry[1];
    #define GetFcpPersistentBinding_OUT_Entry_ID 3

} GetFcpPersistentBinding_OUT, *PGetFcpPersistentBinding_OUT;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\inc\bmfmisc.h ===
//
// Header describing a compressed binary mof blob
//
typedef struct
{
    DWORD Signature;
    DWORD CompressionType;
    DWORD CompressedSize;
    DWORD UncompressedSize;
    BYTE Buffer[1];
} BMOFCOMPRESSEDHEADER, *PBMOFCOMPRESSEDHEADER;



typedef struct
{
	HANDLE MofHandle;
	HANDLE EnglishMofHandle;
	BOOLEAN WriteToEnglish;
	PUCHAR UncompressedBlob;
} MOFFILETARGET, *PMOFFILETARGET;


#define MofObjectTypeClass 0
#define MofObjectTypeInstance 1

#ifdef __cplusplus
extern "C" {
#endif
	
BOOLEAN __stdcall ConvertMofToBmf(
    TCHAR *MofFile,
    TCHAR *EnglishMofFile,
    TCHAR *BmfFile
    );

BOOLEAN __stdcall ConvertBmfToMof(
    PUCHAR BinaryMofData,
    TCHAR *MofFile,
    TCHAR *EnglishMofFile
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\inc\bmof.h ===
//***************************************************************************
//
//  (c) 1997 by Microsoft Corporation
//
//  bmof.h
//
//  a-davj  14-April-97   Created.
//
//  Describes the format of binary MOF files.  In addition, it defines some
//  structures which specify the details of the format and also defines some
//  addtional structures and helper functions for navigating a BMOF file.
//
//***************************************************************************

#ifndef __BMOF__
#define __BMOF__


#ifdef __cplusplus
extern "C" {
#endif

//  Binary mof files contain a large blob of data which consists of stuctures
//  which contain other structures, etc.  The layout of that blob is detailed in
//  the following comments.  However, the binary files are compressed and always
//  starts off with the following DWORDS
//  [Signature] [Compression Type, Always 1] [Compressed size] [Expanded size] The blob follows!
//  An example of decompressing the file is in test.c
//
//   The following is a BNF description of the structures that make up
//   a BMOF file and also serve to illustrate the basic layout of WBEM
//   objects.
//  
//  --A MOF is zero or more objects
//  
//  WBEM_Binary_MOF ::= WBEM_Object*; 
//  
//  --An object is a qualifier list (applying to the entire object) and
//  --a property list
//  
//  WBEM_Object ::= WBEM_QualifierList WBEM_PropertyList;
//  
//  --A property list is zero or more properties
//     
//  WBEM_PropertyList ::= WBEM_Property*;   / zero or more properties
//  
//  --A property is a set of qualifiers applying to the property, and
//  --a type, a name, and a value
//  
//  WBEM_Property ::= WBEM_QualifierList* <type> <name> <value>;
//  
//  --A qualifier list is zero or more qualifiers
//  
//  WBEM_QualifierList ::= WBEM_Qualifier*;   -- zero or more qualifiers
//  
//  --A qualifier is a type, a name, and a value. However, the supported types
//  --are not as extensive as for properties.
//  
//  WBEM_Qualifier ::= <type> <name> <value>;
//  
//  
//  Note that a qualifier set (a list of qualifiers) can be applied
//  to the entire object or to individual properties. However, qualifiers
//  cannot be applied to other qualifiers:
//  
//      object = quals + props
//      prop = quals + name + value
//      qual = name + value
//  
//  Information such as the name of a class, the super class, etc., are coded
//  as property values.  Finding the value of the property __CLASS, for example,
//  gives the name of the class.  All properties beginning with a double
//  underscore are well-known system properties common to all WBEM objects.
//  All other properties are user-defined.
//  
//  The list of predefined properties is found in WBEM documentation.
//  
//  Offsets are relative to their owning structure, not absolute to the
//  entire encoding image.  This allows moving the subcomponents around
//  without rencoding everything.
//  
//  Note that an offset of 0xFFFFFFFF indicates that the field is not used.
//  
//  Both properties and qualifiers have value fields which contain data based
//  on Ole Automation types.  Qualifiers are simple types (no arrays or 
//  embedded objects) while property values might contain arrays and/or 
//  embedded objects.  
//
//  One difference from Ole is that BSTRs are actually stored as WCHAR 
//  strings even if the data type is marked as BSTR.  
//
//  In addition, some qualifiers or properties are actually aliases which 
//  must be resolved later.  Aliases are stored as BSTR values and the type
//  field is set to VT_BSTR | VT_BYREF.  An array of alias strings is a bit
//  more complicated since not all the elements need be aliases.  In the array
//  case, each actual alias string is prepended with a L'$' while each 
//  "regular" string is prepended by a L' '.
//
//  Currently, only scalars and single dimensional arrays are supported.
//  However, the BMOF file layout is designed so as to accommodate multi-
//  dimensional array in the future.  For array data, the data is layout out
//
//  ArrayData ::= ArrayHeaderData + RowOfData*; 
//
//  The ArrayHeaderData has the form;
//  dwtotalsize, dwNumDimenstions, dwMostSigDimension... dwLeastSigDimension
// 
//  Currently only 1 dimensional arrays are supported, a 5 element
//  array would start with;
//  dwSize, 1, 5
//
//  After the header, one or more rows would follow.  A row represents the
//  "most rapidly changing" data.  Currently, there is only one row.
//
//  The row format is;
//
//  dwSizeOfRow, MostSigDimension ... dwLeastSignificentDimension+1,data
//  For a one dimensional array, it would just be
//  dwSizeOfRow, Data
//

//  The extension  for supporting qualifier flavors is to add the following data after the current blob.
//  
//  typedef struct 
//  {
//      WCHAR wcSignature;          // the string BMOFQUALFLAVOR11
//      DWORD dwNumPair;
//      // BYTE FlavorInfo[];             // Blob containing array of WBEM_Object structs
//  }WBEM_Binary_FLAVOR;
//  
//  The FlavorInfo blob will be a series of DWORD pairs of the form
//  
//  Typedef struct
//  {
//  	DWORD dwOffsetInOriginalBlob;
//  	DWORD dwFlavor;
//  }

// Each Binary MOF file starts off with these signature bytes.

#define BMOF_SIG 0x424d4f46

// The following structures exactly describe the contents of a BMOF file.
// These can be used to navigate the file using the various offsets and
// lots of casting.  

typedef struct 
{
    DWORD dwSignature;          // four characters, BMOF
    DWORD dwLength;
    DWORD dwVersion;            // 0x1
    DWORD dwEncoding;           // 0x1 = little endian, DWORD-aligned, no compression

    DWORD dwNumberOfObjects;    // Total classes and instances in MOF

    // BYTE Info[];             // Blob containing array of WBEM_Object structs
                                // First object is at offset 0.
}WBEM_Binary_MOF;

typedef struct                  // Describes a class or instance
{
    DWORD dwLength;
    DWORD dwOffsetQualifierList;
    DWORD dwOffsetPropertyList;
    DWORD dwOffsetMethodList;
    DWORD dwType;               // 0 = class, 1 = instance
    
    //  BYTE Info[];            // Blob of qualifier set and properties
}WBEM_Object;

typedef struct 
{
    DWORD dwLength;
    DWORD dwNumberOfProperties;
    
    //  BYTE Info[];                // Blob with all properties placed end-to-end    
}WBEM_PropertyList;
                                                                   
typedef struct 
{
    DWORD dwLength;             // Length of this struct
    DWORD dwType;               // A VT_ type from WTYPES.H (VT_I4, VT_UI8, etc)
    DWORD dwOffsetName;         // Offset in <Info> of the null-terminated name.
    DWORD dwOffsetValue;        // Offset in <Info> of the value.
    DWORD dwOffsetQualifierSet; // 
        
    
    //  BYTE  Info[];           // Contains qualifier set, name, and value
}WBEM_Property;

// Rough encoding example for a string:
//
// dwLength = 10;
// dwType   = VT_LPWSTR;    
// dwOffsetName  = 0;
// dwOffsetValue = 8;
// dwOffsetQualifierSet = 0xFFFFFFFF;   // Indicates not used
//
// Info[] = "CounterValue\0<default value>\0";


typedef struct       
{
    DWORD dwLength;
    DWORD dwNumQualifiers;
    //  BYTE Info[];                // Array of WBEM_Qualifiers placed end-to-end
}WBEM_QualifierList;


typedef struct 
{
    DWORD dwLength;         // Length of this struct
    DWORD dwType;           // A VT_ type from WTYPES.H (VT_I4, VT_UI8, etc)
    DWORD dwOffsetName;     // Offset in <Info> of the null-terminated name.
    DWORD dwOffsetValue;    // Offset in <Info> of the value.
    //  BYTE  Info[];   
}WBEM_Qualifier;


// These structures and the helper functions that go with them can be used
// to easily navigate a BMOF file.  These structures "wrap" the above 
// structures so as to provide features such as searching and enumeration.

typedef struct 
{
    WBEM_QualifierList * m_pql;
    WBEM_Qualifier * m_pInfo;
    DWORD m_CurrQual;
    WBEM_Qualifier * m_pCurr;

}CBMOFQualList;

typedef struct 
{
    WBEM_Object * m_pob;
    BYTE * m_pInfo;
    WBEM_PropertyList * m_ppl;
    DWORD m_CurrProp;
    WBEM_Property * m_pCurrProp;

    WBEM_PropertyList * m_pml;
    DWORD m_CurrMeth;
    WBEM_Property * m_pCurrMeth;

}CBMOFObj;

typedef struct 
{
    WBEM_Binary_MOF * m_pol;
    DWORD m_CurrObj;
    WBEM_Object * m_pInfo;
    WBEM_Object * m_pCurrObj;   
}CBMOFObjList;


typedef struct 
{
    BYTE * m_pData;
    DWORD  m_dwType;
}CBMOFDataItem;


//
// Qualifier flavor definitions
#define FlavorAmended           0x80
#define FlavorDisableOverride   0x10
#define FlavorToSubclass        0x02
#define FlavorToInstance        0x01



// Using any of the following help functions requires that these two 
// functions be provided in another module and allow independence from
// any particular allocation method.

//
// redefine the BMOF allocation routines to be the same as the WMI allocation
// routines.
#define BMOFFree(p) WmipFree(p)
#define BMOFAlloc(s) WmipAlloc(s)


// These functions wrap the object list and provider for enumeration of
// the objects.

CBMOFObjList * _stdcall CreateObjList(BYTE * pBuff);
void _stdcall ResetObjList(CBMOFObjList * pol);
CBMOFObj * _stdcall NextObj(CBMOFObjList *pol);
CBMOFObj * _stdcall FindObj(CBMOFObjList *pol, WCHAR * pName);

// These functions allow access to the parts of a class or instance object

void _stdcall ResetObj(CBMOFObj * pol);
CBMOFQualList * _stdcall GetQualList(CBMOFObj * pol);
CBMOFQualList * _stdcall GetPropQualList(CBMOFObj * pol, WCHAR * pName);
CBMOFQualList * _stdcall GetMethQualList(CBMOFObj * pol, WCHAR * pName);
BOOL _stdcall NextProp(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL _stdcall NextMeth(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL _stdcall FindProp(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem);
BOOL _stdcall FindMeth(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem);
BOOL _stdcall GetName(CBMOFObj * pob, WCHAR ** ppName);
DWORD _stdcall GetType(CBMOFObj * pob);
WBEM_Property * _stdcall FindPropPtr(CBMOFObj * pob, WCHAR * pName);
WBEM_Property * _stdcall FindMethPtr(CBMOFObj * pob, WCHAR * pName);

//  These functions provide easy access to a qualifier list.

void _stdcall ResetQualList(CBMOFQualList * pql);
BOOL _stdcall NextQual(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL _stdcall NextQualEx(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem, 
                                            DWORD * pdwFlavor, BYTE * pBuff);
BOOL _stdcall FindQual(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem);
BOOL _stdcall FindQualEx(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem, 
                                            DWORD * pdwFlavor, BYTE * pBuff);

// These functions provide easy access to a data item.  Note that data items
// might be stored in arrays.

int _stdcall GetNumDimensions(CBMOFDataItem *);
int _stdcall GetNumElements(CBMOFDataItem *, long lDim);
int _stdcall GetData(CBMOFDataItem *, BYTE * pRet, long * plDims);

// These functions are mainly useful to the above helper functions

int _stdcall iTypeSize(DWORD vtTest);
BOOL _stdcall SetValue(CBMOFDataItem * pItem, BYTE * pInfo, DWORD dwOffset, DWORD dwType);
BOOL _stdcall SetName(WCHAR ** ppName, BYTE * pInfo, DWORD dwOffset);
CBMOFQualList * _stdcall CreateQualList(WBEM_QualifierList *pql);
CBMOFObj * _stdcall CreateObj(WBEM_Object * pob);


#ifdef __cplusplus
}
#endif

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\inc\mrcicode.h ===
/*
 *  Microsoft Confidential
 *  Copyright (c) 1994 Microsoft Corporation
 *  All Rights Reserved.
 *
 *  MRCICODE.H
 *
 *  MRCI 1 & MRCI 2 maxcompress and decompress functions
 */

#ifdef BIT16
#define     FAR     _far
#else
#ifndef FAR
#define     FAR
#endif
#endif

#ifdef __cplusplus
extern "C"
{
#endif

extern unsigned _stdcall Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned _stdcall Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);

extern unsigned _stdcall Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned _stdcall Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\inc\dllcalls.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    DLLCALLS.H

Abstract:

	This file defines the entry points for calling this as a dll rather than a com object.

History:

	3/20/00     a-davj      Created

--*/

#ifndef __DLLCALLS__H_
#define __DLLCALLS__H_

HRESULT APIENTRY  CompileFileViaDLL( 
            /* [in] */ LPWSTR FileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LPWSTR User,
            /* [in] */ LPWSTR Authority,
            /* [in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);

HRESULT APIENTRY  CreateBMOFViaDLL( 
            /* [in] */ LPWSTR TextFileName,
            /* [in] */ LPWSTR BMOFFileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\inc\chunkimp.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    chunkimpl.h

Abstract:

    This routine will manage allocations of chunks of structures. It also
    contains a handy unicode to ansi conversion function

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#if DBG
BOOLEAN WmipLoggingEnabled = FALSE;
#endif

PENTRYHEADER WmipAllocEntry(
    PCHUNKINFO ChunkInfo
    )
/*++

Routine Description:

    This routine will allocate a single structure within a list of chunks
    of structures.

Arguments:

    ChunkInfo describes the chunks of structures

Return Value:

    Pointer to structure or NULL if one cannot be allocated. Entry returns
    with its refcount set to 1

--*/
{
    PLIST_ENTRY ChunkList, EntryList, FreeEntryHead;
    PCHUNKHEADER Chunk;
    PBYTE EntryPtr;
    ULONG EntryCount, ChunkSize;
    PENTRYHEADER Entry;
    ULONG i;

#ifdef HEAPVALIDATION
    WmipAssert(RtlValidateProcessHeaps());
#endif
    WmipEnterCriticalSection();
    ChunkList = ChunkInfo->ChunkHead.Flink;

    //
    // Loop over all chunks to see if any chunk has a free entry for us
    while(ChunkList != &ChunkInfo->ChunkHead)
    {
        Chunk = CONTAINING_RECORD(ChunkList, CHUNKHEADER, ChunkList);
        if (! IsListEmpty(&Chunk->FreeEntryHead))
        {
            EntryList = RemoveHeadList(&Chunk->FreeEntryHead);
            Chunk->EntriesInUse++;
            WmipLeaveCriticalSection();
            Entry = (CONTAINING_RECORD(EntryList,
                                       ENTRYHEADER,
                                       FreeEntryList));
            WmipAssert(Entry->Flags & FLAG_ENTRY_ON_FREE_LIST);
            memset(Entry, 0, ChunkInfo->EntrySize);
            Entry->Chunk = Chunk;
            Entry->RefCount = 1;
            Entry->Flags = ChunkInfo->InitialFlags;
            Entry->Signature = ChunkInfo->Signature;
#if DBG
            InterlockedIncrement(&ChunkInfo->AllocCount);
#endif
            return(Entry);
        }
        ChunkList = ChunkList->Flink;
    }
    WmipLeaveCriticalSection();

    //
    // There are no more free entries in any of the chunks. Allocate a new
    // chunk if we can
    ChunkSize = (ChunkInfo->EntrySize * ChunkInfo->EntriesPerChunk) +
                  sizeof(CHUNKHEADER);
    Chunk = (PCHUNKHEADER)WmipAlloc(ChunkSize);
    if (Chunk != NULL)
    {
        //
        // Initialize the chunk by building the free list of entries within
        // it while also initializing each entry.
        memset(Chunk, 0, ChunkSize);

        FreeEntryHead = &Chunk->FreeEntryHead;
        InitializeListHead(FreeEntryHead);

        EntryPtr = (PBYTE)Chunk + sizeof(CHUNKHEADER);
        EntryCount = ChunkInfo->EntriesPerChunk - 1;

        for (i = 0; i < EntryCount; i++)
        {
            Entry = (PENTRYHEADER)EntryPtr;
            Entry->Chunk = Chunk;
            Entry->Flags = FLAG_ENTRY_ON_FREE_LIST;
            InsertHeadList(FreeEntryHead,
                           &((PENTRYHEADER)EntryPtr)->FreeEntryList);
            EntryPtr = EntryPtr + ChunkInfo->EntrySize;
        }
        //
        // EntryPtr now points to the last entry in the chunk which has not
        // been placed on the free list. This will be the entry returned
        // to the caller.
        Entry = (PENTRYHEADER)EntryPtr;
        Entry->Chunk = Chunk;
        Entry->RefCount = 1;
        Entry->Flags = ChunkInfo->InitialFlags;
        Entry->Signature = ChunkInfo->Signature;

        Chunk->EntriesInUse = 1;

        //
        // Now place the newly allocated chunk onto the list of chunks
        WmipEnterCriticalSection();
        InsertHeadList(&ChunkInfo->ChunkHead, &Chunk->ChunkList);
        WmipLeaveCriticalSection();

    } else {
        WmipDebugPrint(("WMI: Could not allocate memory for new chunk %x\n",
                        ChunkInfo));
        Entry = NULL;
    }
    return(Entry);
}

void WmipFreeEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
/*++

Routine Description:

    This routine will free an entry within a chunk and if the chunk has no
    more allocated entries then the chunk will be returned to the pool.

Arguments:

    ChunkInfo describes the chunks of structures

    Entry is the chunk entry to free

Return Value:


--*/
{
    PCHUNKHEADER Chunk;

    WmipAssert(Entry != NULL);
    WmipAssert(! (Entry->Flags & FLAG_ENTRY_ON_FREE_LIST))
    WmipAssert((Entry->Flags & FLAG_ENTRY_INVALID))
    WmipAssert(Entry->RefCount == 0);
    WmipAssert(Entry->Signature == ChunkInfo->Signature);

    Chunk = Entry->Chunk;
    WmipAssert(Chunk->EntriesInUse > 0);

    WmipEnterCriticalSection();
    if ((--Chunk->EntriesInUse == 0) &&
        (ChunkInfo->ChunkHead.Blink != &Chunk->ChunkList))
    {
        //
        // We return the chunks memory back to the heap if there are no
        // more entries within the chunk in use and the chunk was not the
        // first chunk to be allocated.
        RemoveEntryList(&Chunk->ChunkList);
        WmipLeaveCriticalSection();
        WmipFree(Chunk);
    } else {
        //
        // Otherwise just mark the entry as free and put it back on the
        // chunks free list.
#if DBG
        memset(Entry, 0xCCCCCCCC, ChunkInfo->EntrySize);
#endif
        Entry->Flags = FLAG_ENTRY_ON_FREE_LIST;
        Entry->Signature = 0;
        InsertTailList(&Chunk->FreeEntryHead, &Entry->FreeEntryList);
        WmipLeaveCriticalSection();
    }
}


ULONG WmipUnreferenceEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
/*+++

Routine Description:

    This routine will remove a reference count from the entry and if the
    reference count reaches zero then the entry is removed from its active
    list and then cleaned up and finally freed.

Arguments:

    ChunkInfo points at structure that describes the entry

    Entry is the entry to unreference

Return Value:

    New refcount of the entry

---*/
{
    ULONG RefCount;

    WmipAssert(Entry != NULL);
    WmipAssert(Entry->RefCount > 0);
    WmipAssert(Entry->Signature == ChunkInfo->Signature);

    WmipEnterCriticalSection();
    InterlockedDecrement(&Entry->RefCount);
    RefCount = Entry->RefCount;

    if (RefCount == 0)
    {
        //
        // Entry has reached a ref count of 0 so mark it as invalid and remove
        // it from its active list.
        Entry->Flags |= FLAG_ENTRY_INVALID;

        if ((Entry->InUseEntryList.Flink != NULL) &&
            (Entry->Flags & FLAG_ENTRY_REMOVE_LIST))
        {
            RemoveEntryList(&Entry->InUseEntryList);
        }

        WmipLeaveCriticalSection();

        if (ChunkInfo->EntryCleanup != NULL)
        {
            //
            // Call cleanup routine to free anything contained by the entry
            (*ChunkInfo->EntryCleanup)(ChunkInfo, Entry);
        }

        //
        // Place the entry back on its free list
        WmipFreeEntry(ChunkInfo, Entry);
    } else {
        WmipLeaveCriticalSection();
    }
    return(RefCount);
}

ULONG AnsiSizeForUnicodeString(
    PWCHAR UnicodeString,
    ULONG *AnsiSizeInBytes
    )
/*++

Routine Description:

    This routine will return the length needed to represent the unicode
    string as ANSI

Arguments:

    UnicodeString is the unicode string whose ansi length is returned

Return Value:

    Number of bytes needed to represent unicode string as ANSI

--*/
{
    WmipAssert(UnicodeString != NULL);

    try
    {
        *AnsiSizeInBytes = WideCharToMultiByte(CP_ACP,
                                        0,
                        UnicodeString,
                        -1,
                        NULL,
                                            0, NULL, NULL) * sizeof(WCHAR);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        return(ERROR_NOACCESS);
    }
    return((*AnsiSizeInBytes == 0) ? GetLastError() : ERROR_SUCCESS);
}


ULONG UnicodeToAnsi(
    LPCWSTR pszW,
    LPSTR * ppszA,
    ULONG *AnsiSizeInBytes OPTIONAL
    )
/*++

Routine Description:

    Convert Unicode string into its ansi equivalent

Arguments:

    pszW is unicode string to convert

    *ppszA on entry has a pointer to a ansi string into which the answer
        is written. If NULL on entry then a buffer is allocated and  returned
    in it.

Return Value:

    Error code

--*/
{
    ULONG cbAnsi, cCharacters;
    ULONG Status;
    ULONG cbAnsiUsed;
    BOOLEAN CallerReturnBuffer = (*ppszA != NULL);

    //
    // If input is null then just return the same.
    if (pszW == NULL)
    {
        *ppszA = NULL;
        return(ERROR_SUCCESS);
    }

    try
    {
        cCharacters = wcslen(pszW)+1;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        WmipDebugPrint(("WMI: Bad pointer %x passed to UnicodeToAnsi\n", pszW));
        return(ERROR_NOACCESS);
    }

    // Determine number of bytes to be allocated for ANSI string. An
    // ANSI string can have at most 2 bytes per character (for Double
    // Byte Character Strings.)
    cbAnsi = cCharacters*2;

    // Use of the OLE allocator is not required because the resultant
    // ANSI  string will never be passed to another COM component. You
    // can use your own allocator.
    if (*ppszA == NULL)
    {
        *ppszA = (LPSTR) WmipAlloc(cbAnsi);
        if (NULL == *ppszA)
    {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    // Convert to ANSI.
    try
    {
        cbAnsiUsed = WideCharToMultiByte(CP_ACP, 0, pszW, cCharacters, *ppszA,
                      cbAnsi, NULL, NULL);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        if (! CallerReturnBuffer)
        {
            WmipFree(*ppszA);
            *ppszA = NULL;
        }
        return(ERROR_NOACCESS);
    }

    if (AnsiSizeInBytes != NULL)
    {
        *AnsiSizeInBytes = cbAnsiUsed;
    }
    if (0 == cbAnsiUsed)
    {
        Status = GetLastError();
        if (! CallerReturnBuffer)
        {
            WmipFree(*ppszA);
            *ppszA = NULL;
        }
        return(Status);
    }

    return(ERROR_SUCCESS);

}

ULONG AnsiToUnicode(
    LPCSTR pszA,
    LPWSTR * ppszW
    )
/*++

Routine Description:

    Convert Ansi string into its Unicode equivalent

Arguments:

    pszA is ansi string to convert

    *ppszW on entry has a pointer to a unicode string into which the answer
        is written. If NULL on entry then a buffer is allocated and  returned
    in it.

Return Value:

    Error code

--*/
{
    ULONG cCharacters;
    ULONG Status;
    ULONG cbUnicodeUsed;
    BOOLEAN CallerReturnBuffer = (*ppszW != NULL);

    //
    // If input is null then just return the same.
    if (pszA == NULL)
    {
        *ppszW = NULL;
        return(ERROR_SUCCESS);
    }

    //
    // Determine the count of characters needed for Unicode string
    try
    {
        cCharacters = MultiByteToWideChar(CP_ACP, 0, pszA, -1, NULL, 0);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        WmipDebugPrint(("WMI: Bad pointer %x passed to AnsiToUnicode\n", pszA));
        return(ERROR_NOACCESS);
    }

    if (cCharacters == 0)
    {
        *ppszW = NULL;
        return(GetLastError());
    }

    // Use of the OLE allocator is not required because the resultant
    // ANSI  string will never be passed to another COM component. You
    // can use your own allocator.

    if (*ppszW == NULL)
    {
        *ppszW = (LPWSTR) WmipAlloc(cCharacters * sizeof(WCHAR));
    }
    if (NULL == *ppszW)
        return(ERROR_NOT_ENOUGH_MEMORY);

    // Convert to Unicode
    try
    {
        cbUnicodeUsed = MultiByteToWideChar(CP_ACP, 0, pszA, -1, *ppszW, cCharacters);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        if (! CallerReturnBuffer)
        {
            WmipFree(*ppszW);
            *ppszW = NULL;
        }
        return(ERROR_NOACCESS);
    }
    if (0 == cbUnicodeUsed)
    {
        Status = GetLastError();
        if (! CallerReturnBuffer)
        {
            WmipFree(*ppszW);
            *ppszW = NULL;
        }
        return(Status);
    }

    return(ERROR_SUCCESS);

}

ULONG UnicodeSizeForAnsiString(
    LPCSTR pszA,
    ULONG *UnicodeSizeInBytes
    )
/*++

Routine Description:

    This routine will return the length needed to represent the ansi
    string as UNICODE

Arguments:

    pszA is ansi string to convert


Return Value:

    Error code

--*/
{

    WmipAssert(pszA != NULL);


    //
    // Determine the count of characters needed for Unicode string
    try
    {
        *UnicodeSizeInBytes = MultiByteToWideChar(CP_ACP, 0, pszA, -1, NULL, 0) * sizeof(WCHAR);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        return(ERROR_NOACCESS);
    }

    return((*UnicodeSizeInBytes == 0) ? GetLastError() : ERROR_SUCCESS);

}

#if 0     // TODO: Delete me
ULONG WmipStaticInstanceNameSize(
    PWMIINSTANCEINFO WmiInstanceInfo
    )
/*+++

Routine Description:

    This routine will calculate the size needed to place instance names in
    a WNODE_ALL_DATA

Arguments:

    WmiInstanceInfo describes to instance set whose instance name size
        is to be calculated

Return Value:

    Size needed to place instance names in a WNODE_ALL_DATA plus 3. The
    extra 3 bytes are added in case the OffsetInstanceNameOffsets need to be
    padded since they must be on a 4 byte boundry.
        
---*/
{
    ULONG NameSize;
    ULONG i;
    ULONG SuffixLen;

    //
    // If we already computed this then just return the results
    if (WmiInstanceInfo->InstanceNameSize != 0)
    {
        return(WmiInstanceInfo->InstanceNameSize);
    }

    //
    // Start with a name size of 3 in case the OffsetInstanceNameOffset will
    // need to be padded so that it starts on a 4 byte boundry.
    NameSize = 3;

    if (WmiInstanceInfo->Flags & IS_INSTANCE_BASENAME)
    {
        //
        // For static base names we assume that there will never be more than
        // 999999 instances of a guid.
        SuffixLen = MAXBASENAMESUFFIXSIZE * sizeof(WCHAR);
        WmipAssert((WmiInstanceInfo->BaseIndex + WmiInstanceInfo->InstanceCount) < 999999);
        NameSize += ((wcslen(WmiInstanceInfo->BaseName) * sizeof(WCHAR)) + 2 + SuffixLen + sizeof(ULONG)) * WmiInstanceInfo->InstanceCount;
    } else if (WmiInstanceInfo->Flags & IS_INSTANCE_STATICNAMES)
    {
        //
        // Count up each size of the static instance names in the list
        for (i = 0; i < WmiInstanceInfo->InstanceCount; i++)
        {
            NameSize += (wcslen(WmiInstanceInfo->StaticNamePtr[i]) + 2) * sizeof(WCHAR) + sizeof(ULONG);
        }
    }

    WmiInstanceInfo->InstanceNameSize = NameSize;

    return(NameSize);
}

void WmipInsertStaticNames(
    PWNODE_ALL_DATA Wnode,
    ULONG MaxWnodeSize,
    PWMIINSTANCEINFO WmiInstanceInfo
    )
/*+++

Routine Description:

    This routine will copy into the WNODE_ALL_DATA instance names for a
    static instance name set. If the Wnode_All_data is too small then it
    is converted to a WNODE_TOO_SMALL

Arguments:

    Wnode points at the WNODE_ALL_DATA
    MaxWnodeSize is the maximum size of the Wnode
    WmiInstanceInfo is the Instance Info

Return Value:

---*/
{
    PWCHAR NamePtr;
    PULONG NameOffsetPtr;
    ULONG InstanceCount;
    ULONG i;
    WCHAR Index[7];
    PWCHAR StaticName;
    ULONG SizeNeeded;
    ULONG NameLen;
    USHORT Len;
    ULONG PaddedBufferSize;

    if ((WmiInstanceInfo->Flags &
                (IS_INSTANCE_BASENAME | IS_INSTANCE_STATICNAMES)) == 0)
    {
        WmipDebugPrint(("WMI: Try to setup static names for dynamic guid\n"));
        return;
    }
    InstanceCount = WmiInstanceInfo->InstanceCount;

    //
    // Pad out the size of the buffer to a 4 byte boundry since the
    // OffsetInstanceNameOffsets must be on a 4 byte boundry
    PaddedBufferSize = (Wnode->WnodeHeader.BufferSize + 3) & ~3;
    
    //
    // Compute size needed to write instance names.
    SizeNeeded = (InstanceCount * sizeof(ULONG)) +
                 WmipStaticInstanceNameSize(WmiInstanceInfo) +
                 Wnode->WnodeHeader.BufferSize;

    if (SizeNeeded > MaxWnodeSize)
    {
        //
        // If not enough space left then change into a WNODE_TOO_SMALL
        Wnode->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
        Wnode->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
        ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded = SizeNeeded;
        return;
    }

    //
    // Build the array of offsets to instance names
    NameOffsetPtr = (PULONG)((PBYTE)Wnode + PaddedBufferSize);
    Wnode->OffsetInstanceNameOffsets = (ULONG)((PBYTE)NameOffsetPtr - (PBYTE)Wnode);
    NamePtr = (PWCHAR)(NameOffsetPtr + InstanceCount);


    if (WmiInstanceInfo->Flags & IS_INSTANCE_BASENAME)
    {
        if (WmiInstanceInfo->Flags & IS_PDO_INSTANCENAME)
        {
            Wnode->WnodeHeader.Flags |= WNODE_FLAG_PDO_INSTANCE_NAMES;
        }

        for (i = 0; i < InstanceCount; i++)
        {
            *NameOffsetPtr++ = (ULONG)((PBYTE)NamePtr - (PBYTE)Wnode);
            wcscpy(NamePtr+1,
                   WmiInstanceInfo->BaseName);
            swprintf(Index, L"%d", WmiInstanceInfo->BaseIndex+i);
            wcscat(NamePtr+1, Index);
            NameLen = wcslen(NamePtr+1) + 1;
            *NamePtr = (USHORT)NameLen * sizeof(WCHAR);
            NamePtr += NameLen + 1;
        }
    } else if (WmiInstanceInfo->Flags & IS_INSTANCE_STATICNAMES) {
        for (i = 0; i < InstanceCount; i++)
        {
            *NameOffsetPtr++ = (ULONG)((PBYTE)NamePtr - (PBYTE)Wnode);
            StaticName = WmiInstanceInfo->StaticNamePtr[i];
            Len = (wcslen(StaticName)+1) * sizeof(WCHAR);
            *NamePtr++ = Len;
            wcscpy(NamePtr, StaticName);
            NamePtr += Len / sizeof(WCHAR);
        }
    }
    Wnode->WnodeHeader.BufferSize = SizeNeeded;
}
#endif


#ifdef HEAPVALIDATION
PVOID WmipAlloc(
    ULONG Size
    )
{
    PVOID p;

    WmipAssert(RtlValidateProcessHeaps());
    p = RtlAllocateHeap(WmipProcessHeap, 0, Size);

    WmipDebugPrint(("WMI: WmipAlloc %x (%x)\n", p, Size));

    return(p);
}

void WmipFree(
    PVOID p
    )
{

    WmipDebugPrint(("WMI: WmipFree %x\n", p));
    WmipAssert(p != NULL);

    WmipAssert(RtlValidateProcessHeaps());
    RtlFreeHeap(WmipProcessHeap, 0, p);
}
#endif

#ifdef MEMPHIS
void __cdecl DebugOut(char *Format, ...)
{
    char Buffer[1024];
    va_list pArg;
    ULONG i;

    va_start(pArg, Format);
    i = _vsnprintf(Buffer, sizeof(Buffer), Format, pArg);
    OutputDebugString(Buffer);
}
#else
void __cdecl DebugOut(char *Format, ...)
{
    char Buffer[1024];
    va_list pArg;
    ULONG i;

    i = sprintf(Buffer, "[%d] - ", GetTickCount());
    va_start(pArg, Format);
    i = _vsnprintf(&Buffer[i], sizeof(Buffer), Format, pArg);
    DbgPrint(Buffer);
}
#endif

#ifndef MEMPHIS
ULONG WmipCheckGuidAccess(
    LPGUID Guid,
    ACCESS_MASK DesiredAccess
    )
{
    HANDLE Handle;
    ULONG Status;

    Status = WmipOpenKernelGuid(Guid,
                                DesiredAccess,
                                &Handle,
                                IOCTL_WMI_OPEN_GUID
                );

    if (Status == ERROR_SUCCESS)
    {
        CloseHandle(Handle);
    }

    return(Status);
}

ULONG WmipBuildGuidObjectAttributes(
    IN LPGUID Guid,
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PUNICODE_STRING GuidString,
    OUT PWCHAR GuidObjectName
    )
{
    WCHAR GuidChar[37];

	WmipAssert(Guid != NULL);
    
    //
    // Build up guid name into the ObjectAttributes
    //
    swprintf(GuidChar, L"%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
               Guid->Data1, Guid->Data2, 
               Guid->Data3,
               Guid->Data4[0], Guid->Data4[1],
               Guid->Data4[2], Guid->Data4[3],
               Guid->Data4[4], Guid->Data4[5],
               Guid->Data4[6], Guid->Data4[7]);

	WmipAssert(wcslen(GuidChar) == 36);
	
	wcscpy(GuidObjectName, WmiGuidObjectDirectory);
	wcscat(GuidObjectName, GuidChar);    
	RtlInitUnicodeString(GuidString, GuidObjectName);
    
	memset(ObjectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
	ObjectAttributes->Length = sizeof(OBJECT_ATTRIBUTES);
	ObjectAttributes->ObjectName = GuidString;
	
    return(ERROR_SUCCESS);    
}

ULONG WmipOpenKernelGuid(
    LPGUID Guid,
    ACCESS_MASK DesiredAccess,
    PHANDLE Handle,
    ULONG Ioctl
    )
{
    WMIOPENGUIDBLOCK WmiOpenGuidBlock;
    UNICODE_STRING GuidString;
    ULONG ReturnSize;
    ULONG Status;
    WCHAR GuidObjectName[WmiGuidObjectNameLength+1];
    OBJECT_ATTRIBUTES ObjectAttributes;

    Status = WmipBuildGuidObjectAttributes(Guid,
                                           &ObjectAttributes,
                                           &GuidString,
                                           GuidObjectName);
                                       
    if (Status == ERROR_SUCCESS)
    {
        WmiOpenGuidBlock.ObjectAttributes = &ObjectAttributes;
        WmiOpenGuidBlock.DesiredAccess = DesiredAccess;

        Status = WmipSendWmiKMRequest(NULL, 
                                      Ioctl,
                                      (PVOID)&WmiOpenGuidBlock,
                                      sizeof(WMIOPENGUIDBLOCK),
                                      (PVOID)&WmiOpenGuidBlock,
                                      sizeof(WMIOPENGUIDBLOCK),
                                      &ReturnSize,
                      NULL);

        if (Status == ERROR_SUCCESS)
        {
            *Handle = WmiOpenGuidBlock.Handle.Handle;
        } else {
            *Handle = NULL;
        }
    }
    return(Status);
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\fchba\testapp\hbatest.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#include "hbaapi.h"

#define MAX_ADAPTERS 64



void CallMiscFunctions()
{
	HBA_STATUS Status;
	HBA_UINT32 Version;
	
    Status = HBA_RegisterLibrary(NULL);
	if (Status != HBA_STATUS_ERROR_NOT_SUPPORTED)
	{
		printf("HBA_RegisterLibrary -> %d\n", Status);
	}
	
	Version = HBA_GetVersion();
	if (Version != HBA_VERSION)
	{
		printf("HBA_GetVersion -> %d\n", Version);
	}
	
	Status = HBA_LoadLibrary();
	if (Status != HBA_STATUS_OK)
	{
		printf("HBA_LoadLibrary -> %d\n", Status);
	}
	
	Status = HBA_FreeLibrary();
	if (Status != HBA_STATUS_OK)
	{
		printf("HBA_FreeLibrary -> %d\n", Status);
	}
	
// TODO: These functions
#if 0

HBA_API HBA_STATUS HBA_SendScsiInquiry (
	HBA_HANDLE handle,
	HBA_WWN PortWWN,
	HBA_UINT64 fcLUN,
	HBA_UINT8 EVPD,
	HBA_UINT32 PageCode,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize);

HBA_API HBA_STATUS HBA_SendReportLUNs (
	HBA_HANDLE handle,
	HBA_WWN portWWN,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize
);

HBA_API HBA_STATUS HBA_SendReadCapacity (
	HBA_HANDLE handle,
	HBA_WWN portWWN,
	HBA_UINT64 fcLUN,
	void * pRspBuffer,
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize
);
#endif

	
}

HBA_STATUS BuildAdapterList(
    PULONG AdapterCount,
    TCHAR **Adapters
)
{
	HBA_UINT32 Count, i;
	PTCHAR Name;
	HBA_STATUS Status;

	Count = HBA_GetNumberOfAdapters();
	if (Count > MAX_ADAPTERS)
	{
		printf("%d is above limit of %d adapters\n", Count, MAX_ADAPTERS);
		Count = MAX_ADAPTERS;
	}

	*AdapterCount = Count;
	Status = HBA_STATUS_OK;
	for (i = 0; i < Count; i++)
	{
		Name = malloc(256 * sizeof(TCHAR));
		Status = HBA_GetAdapterName(i, Name);
		if (Status == HBA_STATUS_OK)
		{
			Adapters[i] = Name;
		} else {
			printf("HBA_GetAdapterName(%d) -> %d\n", i, Status);
			break;
		}
	}
	
	return(Status);
}

void PrintHBA_WWN(
    PCHAR s,
	HBA_WWN wwn
    )
{
	printf(s);
	printf(" %02x %02x %02x %02x %02x %02x %02x %02x \n",
		   wwn.wwn[0], wwn.wwn[1], wwn.wwn[2], wwn.wwn[3],
		   wwn.wwn[4], wwn.wwn[5], wwn.wwn[6], wwn.wwn[7]);
		   
}

void PrintHBA_UINT32(
    PCHAR s,
    HBA_UINT32 u
    )
{
	printf(s);
	printf(": 0x%x\n", u);
}

#ifdef UNICODE
void Printchar(
    PCHAR s,
    PWCHAR w
    )
{
	printf(s);
	printf(": %ws\n", w);
}
#else
void Printchar(
    PCHAR s,
    PCHAR w
    )
{
	printf(s);
	printf(": %s\n", w);
}
#endif

HBA_STATUS GetAdapterAttributes(
    HBA_HANDLE Handle,
    HBA_UINT32 *PortCount
    )
{
	HBA_STATUS Status;
	HBA_ADAPTERATTRIBUTES Attributes;
	
	Status = HBA_GetAdapterAttributes(Handle,
									  &Attributes);

	if (Status == HBA_STATUS_OK)
	{
		printf("\nAdapter Attributes:\n");
		PrintHBA_WWN("NodeWWN", Attributes.NodeWWN);
		PrintHBA_UINT32("VendorSpecificID", Attributes.VendorSpecificID);
		PrintHBA_UINT32("NumberOfPorts", Attributes.NumberOfPorts);
		*PortCount = Attributes.NumberOfPorts;
	
		Printchar("Manufacturer", Attributes.Manufacturer);
		Printchar("SerialNumber", Attributes.SerialNumber);
		Printchar("Model", Attributes.Model);
		Printchar("ModelDescription", Attributes.ModelDescription);
		Printchar("NodeSymbolicName", Attributes.NodeSymbolicName);
		Printchar("HardwareVersion", Attributes.HardwareVersion);
		Printchar("DriverVersion", Attributes.DriverVersion);
		Printchar("OptionROMVersion", Attributes.OptionROMVersion);
		Printchar("FirmwareVersion", Attributes.FirmwareVersion);
		Printchar("DriverName", Attributes.DriverName);		
	} else {
		printf("HBA_GetAdapterAttributes -> %d\n", Status);
	}
	return(Status);
}

void PrintHBA_PORTTYPE(
    PCHAR s,
    HBA_PORTTYPE u
    )
{
	// TODO: symbolic constants
	printf(s);
	printf(": 0x%x\n", u);
}

void PrintHBA_PORTSPEED(
    PCHAR s,
    HBA_PORTSPEED u
    )
{
	// TODO: symbolic constants
	printf(s);
	printf(": 0x%x\n", u);
}

void PrintHBA_PORTSTATE(
    PCHAR s,
    HBA_PORTSTATE u
    )
{
	// TODO: symbolic constants
	printf(s);
	printf(": 0x%x\n", u);
}

void PrintHBA_COS(
    PCHAR s,
    HBA_COS u
    )
{
	// TODO: symbolic constants
	printf(s);
	printf(": 0x%x\n", u);
}

void PrintHBA_FC4TYPES(
    PCHAR s,
    HBA_FC4TYPES Fc4
    )
{
	ULONG i;
	
	// TODO: symbolic constants
	printf(s);
	printf(":");
	for (i = 0; i < 32; i++)
	{
		printf(" %02x", Fc4.bits[i]);
	}
	printf("\n");
}

void PrintHBA_UINT64(
    PCHAR s,
    HBA_UINT64 u
    )
{
	printf(s);
	printf(": 0x%x\n", u);
}

void PrintHBA_INT64(
    PCHAR s,
    HBA_INT64 u
    )
{
	printf(s);
	printf(": 0x%x\n", u);
}

void PrintHBA_UINT16(
    PCHAR s,
    HBA_UINT16 u
    )
{
	printf(s);
	printf(": 0x%x\n", u);
}

void PrintHBA_UINT8A(
    PCHAR s,
    HBA_UINT8 *u,
    ULONG Len
    )
{
	ULONG i;
	
	printf(s);
	printf(":");
	for (i = 0; i < Len; i++)
	{
		printf(" 0x%x\n", u[i]);
	}
	printf("\n");
}

void PrintHBA_PORTATTRIBUTES(
    PHBA_PORTATTRIBUTES Attributes
	)
{
	PrintHBA_WWN("NodeWWN", Attributes->NodeWWN);
	PrintHBA_WWN("PortWWN", Attributes->PortWWN);
	PrintHBA_UINT32("PortFcId", Attributes->PortFcId);
	PrintHBA_PORTTYPE("PortType", Attributes->PortType);
	PrintHBA_PORTSTATE("PortState", Attributes->PortState);
	PrintHBA_COS("PortSupportedClassofService", Attributes->PortSupportedClassofService);
	PrintHBA_FC4TYPES("PortSupportedFc4Types", Attributes->PortSupportedFc4Types);
	PrintHBA_FC4TYPES("PortActiveFc4Types", Attributes->PortActiveFc4Types);
	Printchar("PortSymbolicName", Attributes->PortSymbolicName);
	Printchar("OSDeviceName", Attributes->OSDeviceName);
	PrintHBA_PORTSPEED("PortSupportedSpeed", Attributes->PortSupportedSpeed);
	PrintHBA_PORTSPEED("PortSpeed", Attributes->PortSpeed);
	PrintHBA_UINT32("PortMaxFrameSize", Attributes->PortMaxFrameSize);
	PrintHBA_WWN("FabricName", Attributes->FabricName);
	PrintHBA_UINT32("NumberofDiscoveredPorts", Attributes->NumberofDiscoveredPorts);
}

HBA_STATUS GetPortInformation(
    HBA_HANDLE Handle,
    HBA_UINT32 PortIndex
    )
{
	HBA_STATUS Status;
	HBA_PORTATTRIBUTES Attributes;
	HBA_PORTSTATISTICS Statistics;
	UINT i;

    HBA_ResetStatistics(Handle, PortIndex);
	Status = HBA_GetAdapterPortAttributes(Handle,
								   PortIndex,
								   &Attributes);

	if (Status == HBA_STATUS_OK)
	{
		PrintHBA_PORTATTRIBUTES(&Attributes);
		Status = HBA_GetPortStatistics(Handle,
									   PortIndex,
									   &Statistics);
		if (Status == HBA_STATUS_OK)
		{
			PrintHBA_INT64("SecondsSinceLastReset", Statistics.SecondsSinceLastReset);
			PrintHBA_INT64("TxFrames", Statistics.TxFrames);
			PrintHBA_INT64("TxWords", Statistics.TxWords);
			PrintHBA_INT64("RxFrames", Statistics.RxFrames);
			PrintHBA_INT64("RxWords", Statistics.RxWords);
			PrintHBA_INT64("LIPCount", Statistics.LIPCount);
			PrintHBA_INT64("NOSCount", Statistics.NOSCount);
			PrintHBA_INT64("ErrorFrames", Statistics.ErrorFrames);
			PrintHBA_INT64("DumpedFrames", Statistics.DumpedFrames);
			PrintHBA_INT64("LinkFailureCount", Statistics.LinkFailureCount);
			PrintHBA_INT64("LossOfSyncCount", Statistics.LossOfSyncCount);
			PrintHBA_INT64("LossOfSignalCount", Statistics.LossOfSignalCount);
			PrintHBA_INT64("PrimitiveSeqProtocolErrCount", Statistics.PrimitiveSeqProtocolErrCount);
			PrintHBA_INT64("InvalidTxWordCount", Statistics.InvalidTxWordCount);
			PrintHBA_INT64("InvalidCRCCount", Statistics.InvalidCRCCount);

			for (i = 0; i < 4; i++)
			{
				printf("\nDiscovered port %d\n", i);
				Status = HBA_GetDiscoveredPortAttributes(Handle,
					                                     PortIndex,
                                                         i,
                                    					 &Attributes);
				if (Status == HBA_STATUS_OK)
				{
					HBA_WWN wwn = {0};    // TODO: make wwn meaningful
					
					PrintHBA_PORTATTRIBUTES(&Attributes);
					
					Status = HBA_GetPortAttributesByWWN(Handle,
						                                wwn,
						                                &Attributes);

					if (Status == HBA_STATUS_OK)
					{
						PrintHBA_PORTATTRIBUTES(&Attributes);
					} else {
						printf("HBA_GetPortAttributesByWWN -> %d\n", Status);
					}
				} else {
					printf("HBA_GetDiscoveredPortAttributes -> %d\n", Status);
				}
			}
		} else {
			printf("HBA_GetPortStatistics -> %d\n", Status);
		}
	} else {
		printf("HBA_GetPortAttributes -> %d\n", Status);
	}
	return(Status);
}

HBA_STATUS GetSetMgmtInfo(
    HBA_HANDLE Handle
    )
{
	HBA_MGMTINFO MgmtInfo;
	HBA_STATUS Status;

	Status = HBA_GetRNIDMgmtInfo(Handle,
								 &MgmtInfo);
	if (Status == HBA_STATUS_OK)
	{
		PrintHBA_WWN("wwn", MgmtInfo.wwn);
		PrintHBA_UINT32("unittype", MgmtInfo.unittype);
		PrintHBA_UINT32("PortId", MgmtInfo.PortId);
		PrintHBA_UINT32("NumberOfAttachedNodes", MgmtInfo.NumberOfAttachedNodes);
		PrintHBA_UINT16("IPVersion", MgmtInfo.IPVersion);
		PrintHBA_UINT16("UDPPort", MgmtInfo.UDPPort);
		PrintHBA_UINT8A("IPAddress", MgmtInfo.IPAddress, 16);
		PrintHBA_UINT16("reserved", MgmtInfo.reserved);
		PrintHBA_UINT16("TopologyDiscoveryFlags", MgmtInfo.TopologyDiscoveryFlags);

		Status = HBA_SetRNIDMgmtInfo(Handle,
									 &MgmtInfo);
		if (Status != HBA_STATUS_OK)
		{
			printf("HBA_SetRNIDMgmtInfo -> %d\n", Status);
		}
	} else {
		printf("HBA_GetRNIDMgmtInfo -> %d\n", Status);
	}
	
	return(Status);
}

UCHAR RspBuffer[0x1000];
UCHAR ReqBuffer[0x800];

HBA_STATUS SendPassThroughs(
    HBA_HANDLE Handle
    )
{
	HBA_STATUS Status;
	HBA_UINT32 RspBufferSize;
	HBA_WWN wwn = {0};
	HBA_WWNTYPE wwnType = 0;

	memset(ReqBuffer, 0x80, sizeof(ReqBuffer));
	Status = HBA_SendCTPassThru(Handle,
								ReqBuffer,
								sizeof(ReqBuffer),
								RspBuffer,
								sizeof(RspBuffer)/2);
	if (Status != HBA_STATUS_OK)
	{
		printf("HBA_SendCTPassThru too small -> %d\n", Status);
	}
								
	memset(ReqBuffer, 0x81, sizeof(ReqBuffer));
	Status = HBA_SendCTPassThru(Handle,
								ReqBuffer,
								sizeof(ReqBuffer),
								RspBuffer,
								sizeof(RspBuffer));
	if (Status != HBA_STATUS_OK)
	{
		printf("HBA_SendCTPassThru -> %d\n", Status);
	}

	//
	// Now do RNID
	//
	
	RspBufferSize = 0;
	memset(ReqBuffer, 0x80, sizeof(ReqBuffer));
	Status = HBA_SendRNID(Handle,
						  wwn,
						  wwnType,
						  RspBuffer,
						  &RspBufferSize);
	if (Status != HBA_STATUS_OK)
	{
		printf("HBA_SendRNID too small -> %d\n", Status);
	} else {
		printf("HBA_SENDRNID too small RspBufferSize = %d\n", RspBufferSize);
	}
								

	memset(ReqBuffer, 0x81, sizeof(ReqBuffer));
	RspBufferSize = 100;
	Status = HBA_SendRNID(Handle,
						  wwn,
						  wwnType,
						  RspBuffer,
						  &RspBufferSize);
	if (Status != HBA_STATUS_OK)
	{
		printf("HBA_SendRNID -> %d\n", Status);
	} else {
		printf("HBA_SENDRNID RspBufferSize = %d\n", RspBufferSize);
	}
	return(Status);
}

void PrintHBA_SCSIID(
    PHBA_SCSIID ScsiId
    )
{
	Printchar("OSDeviceName", ScsiId->OSDeviceName);
	PrintHBA_UINT32("ScsiBusNumber", ScsiId->ScsiBusNumber);
	PrintHBA_UINT32("ScsiTargetNumber", ScsiId->ScsiTargetNumber);
	PrintHBA_UINT32("ScsiOSLun", ScsiId->ScsiOSLun);	
}

void PrintHBA_FCPID(
    PHBA_FCPID FcpId
    )
{
	PrintHBA_UINT32("FcId", FcpId->FcId);
	PrintHBA_WWN("NodeWWN", FcpId->NodeWWN);
	PrintHBA_WWN("PortWWN", FcpId->PortWWN);
	PrintHBA_UINT64("FcpLun", FcpId->FcpLun);
}

void PrintHBA_FCPSCSIENTRY(
    PHBA_FCPSCSIENTRY entry
    )
{
	PrintHBA_SCSIID(&entry->ScsiId);
	PrintHBA_FCPID(&entry->FcpId);	
}

void PrintHBA_FCPBINDINGTYPE(
    PCHAR s,
    HBA_FCPBINDINGTYPE type
    )
{
	printf(s);
	if (type == TO_D_ID)
	{
		printf(": TO_D_ID\n");
	} else if (type == TO_WWN) {
		printf(": TO_WWN\n");
	} else {
		printf(": ?? UNKNOWN ??\n");
	}
}

void PrintHBA_FCPBINDINGENTRY(
    PHBA_FCPBINDINGENTRY entry
    )
{
	PrintHBA_FCPBINDINGTYPE("type", entry->type);
	PrintHBA_SCSIID(&entry->ScsiId);
	PrintHBA_FCPID(&entry->FcpId);	
}

HBA_STATUS GetMappings(
    HBA_HANDLE Handle
    )
{
	HBA_FCPTARGETMAPPING FcpMappingStatic;
	PHBA_FCPTARGETMAPPING FcpMapping;
	HBA_FCPBINDING FcpBindingStatic;
	PHBA_FCPBINDING FcpBinding;
	ULONG i, SizeNeeded;
	HBA_STATUS Status;

	printf("FcpTargetMapping\n");
	FcpMappingStatic.NumberOfEntries = 0;
	Status = HBA_GetFcpTargetMapping(Handle,
									 &FcpMappingStatic);
	if (Status == HBA_STATUS_ERROR_MORE_DATA)
	{
		SizeNeeded = (sizeof(HBA_FCPTARGETMAPPING) +
					  (FcpMappingStatic.NumberOfEntries * sizeof(HBA_FCPSCSIENTRY)));

		FcpMapping = (PHBA_FCPTARGETMAPPING)malloc(SizeNeeded);
		if (FcpMapping != NULL)
		{
			FcpMapping->NumberOfEntries = FcpMappingStatic.NumberOfEntries;
			Status = HBA_GetFcpTargetMapping(Handle,
											 FcpMapping);
			if (Status == HBA_STATUS_OK)
			{
				printf("Entries = %d\n", FcpMapping->NumberOfEntries);
				for (i = 0; i <  FcpMapping->NumberOfEntries; i++)
				{
					PrintHBA_FCPSCSIENTRY(&FcpMapping->entry[i]);
				}
			} else {
				printf("HBA_GetFcpTargetMapping full -> %d\n", Status);
			}
		} else {
			printf("Alloc for %d FCPMapping failed\n", SizeNeeded);
		}
	} else {
		printf("HBA_GetFcpTargetMapping -> %d\n", Status);
	}

	printf("FcpBinding\n");
	FcpBindingStatic.NumberOfEntries = 0;
	Status = HBA_GetFcpPersistentBinding(Handle,
									 &FcpBindingStatic);
	if (Status == HBA_STATUS_ERROR_MORE_DATA)
	{
		SizeNeeded = (sizeof(HBA_FCPBINDING) +
					  (FcpBindingStatic.NumberOfEntries * sizeof(HBA_FCPBINDINGENTRY)));

		FcpBinding = (PHBA_FCPBINDING)malloc(SizeNeeded);
		if (FcpBinding != NULL)
		{
			FcpBinding->NumberOfEntries = FcpBindingStatic.NumberOfEntries;
			Status = HBA_GetFcpPersistentBinding(Handle,
											 FcpBinding);
			if (Status == HBA_STATUS_OK)
			{
				printf("NumberOfEntries = %d\n", FcpBinding->NumberOfEntries);
				for (i = 0; i <  FcpBinding->NumberOfEntries; i++)
				{
					PrintHBA_FCPBINDINGENTRY(&FcpBinding->entry[i]);
				}
			} else {
				printf("HBA_GetPersistentBinding full -> %d\n", Status);
			}
		} else {
			printf("Alloc for %d FcpBinding failed\n", SizeNeeded);
		}
	} else {
		printf("HBA_GetFcpPersistenBinding -> %d\n", Status);
	}
	return(Status);
}

HBA_STATUS GetAdapterInformation(
    PTCHAR AdapterName
    )
{
	HBA_STATUS Status;
	HBA_HANDLE Handle;
	HBA_UINT32 i, PortCount;
	
	Handle = HBA_OpenAdapter(AdapterName);
	if (Handle != 0)
	{
		HBA_RefreshInformation(Handle);
		
		Status = GetAdapterAttributes(Handle, &PortCount);
		if (Status == HBA_STATUS_OK)
		{
			for (i = 0; i < PortCount; i++)
			{
				printf("Port %d\n", i);
				Status = GetPortInformation(Handle, i);
				if (Status != HBA_STATUS_OK)
				{
					printf("GetPortAttributes(%d) -> %d\n", i, Status);
				}
			}

			Status = GetSetMgmtInfo(Handle);
			if (Status != HBA_STATUS_OK)
			{
				printf("GetSetMgmtInfo -> %d\n", Status);
			}

			Status = SendPassThroughs(Handle);
			if (Status != HBA_STATUS_OK)
			{
				printf("DoPassthroughs -> %d\n", Status);
			}

			Status = GetMappings(Handle);
			if (Status != HBA_STATUS_OK)
			{
				printf("GetMappings -> %d\n", Status);
			}
		}
		
		HBA_CloseAdapter(Handle);
	} else {
#ifdef UNICODE		
		printf("HBA_OpenAdapter(%ws) Error\n", AdapterName);
#else
		printf("HBA_OpenAdapter(%s) Error\n", AdapterName);
#endif
	}
	return(Status);
}


int _cdecl main(int argc, char *argv[])
{
	TCHAR *Adapters[MAX_ADAPTERS];
	ULONG AdapterCount;
	HBA_STATUS Status;
	ULONG i;

	CallMiscFunctions();
	
	Status = BuildAdapterList(&AdapterCount, Adapters);
	if (Status == HBA_STATUS_OK)
	{
		printf("%d adapters discovered\n", AdapterCount);
		
		for (i = 0; i < AdapterCount; i++)
		{
#ifdef UNICODE
			printf("Adapter: %ws\n", Adapters[i]);
#else
			printf("Adapter: %s\n", Adapters[i]);
#endif
			Status = GetAdapterInformation(Adapters[i]);
			if (Status != HBA_STATUS_OK)
			{
#ifdef UNICODE				
				printf("GetAdapterInformation(%ws) -> %d\n",
					   Adapters[i], Status);
#else
				printf("GetAdapterInformation(%s) -> %d\n",
					   Adapters[i], Status);
#endif
			}
		}
	}
	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\inc\traceump.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    traceump.h

Abstract:

    Private headers for Event Tracing user mode

Author:

    19-Jul-2000   Melur Raghuraman

Revision History:

--*/ 

#ifndef MEMPHIS


#define MAXSTR                         1024
#define BUFFER_SIZE                    64*1024
#define MAX_BUFFER_SIZE                10*1024*1024
#define NOTIFY_RETRY_COUNT             10

#define TRACE_VERSION_MAJOR             1
#define TRACE_VERSION_MINOR             0

#define SYSTEM_TRACE_VERSION1           1

#ifdef _WIN64
#define SYSTEM_TRACE_MARKER1    TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                                    | (TRACE_HEADER_TYPE_SYSTEM64 << 16) | SYSTEM_TRACE_VERSION1
#else
#define SYSTEM_TRACE_MARKER1    TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                                            | (TRACE_HEADER_TYPE_SYSTEM32 << 16) | SYSTEM_TRACE_VERSION1
#endif

#define LOGFILE_FIELD_OFFSET(field) \
        sizeof(WMI_BUFFER_HEADER) + \
        sizeof(SYSTEM_TRACE_HEADER) +\
        FIELD_OFFSET(TRACE_LOGFILE_HEADER, field)

typedef struct _WMI_LOGGER_CONTEXT {
    LARGE_INTEGER               StartTime;
    HANDLE                      LogFileHandle;
    HANDLE                      NewFileHandle;
    ULONG                       LoggerId;
    ULONG                       LocalSequence;
    HANDLE                      Semaphore;
    HANDLE                      LoggerThreadId;
    HANDLE                      hThread;
    HANDLE                      LoggerEvent;
    NTSTATUS                    LoggerStatus;

    ULONG                       BuffersAvailable;
    ULONG                       NumberOfProcessors;
    ULONG                       BufferPageSize; // BufferSize rounded to page
    LIST_ENTRY                  FreeList;
    LIST_ENTRY                  FlushList;
    PLIST_ENTRY                 TransitionBuffer;
    PWMI_BUFFER_HEADER*         ProcessorBuffers;   // Per Processor Buffer
    UNICODE_STRING              LoggerName;
    UNICODE_STRING              LogFileName;

    ULONG                       CollectionOn;
    ULONG                       NewFileFlag;
    ULONG                       EnableFlags;
    ULONG                       MaximumFileSize;
    ULONG                       LogFileMode;
    ULONG                       LastFlushedBuffer;
    LARGE_INTEGER               FlushTimer;
    LARGE_INTEGER               FirstBufferOffset;
    LARGE_INTEGER               ByteOffset;
    LARGE_INTEGER               BufferAgeLimit;

    ULONG                       TimerResolution; // Used for backtracking in Rundown code
    ULONG                       UsePerfClock;    // Logger Specific PerfClock flags

// the following are attributes available for query
    ULONG                       BufferSize;
    ULONG                       NumberOfBuffers;
    ULONG                       MaximumBuffers;
    ULONG                       MinimumBuffers;
    ULONG                       EventsLost;
    ULONG                       BuffersWritten;
    ULONG                       LogBuffersLost;
    ULONG                       RealTimeBuffersLost;

    PULONG                      SequencePtr;
    GUID                        InstanceGuid;

// logger specific extension to context
    PVOID                       BufferSpace;    // Reserved Buffer Space
} WMI_LOGGER_CONTEXT, *PWMI_LOGGER_CONTEXT;


//
// logsup.c
//

PVOID
WmipGetTraceBuffer(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PSYSTEM_THREAD_INFORMATION pThread,
    IN ULONG GroupType,
    IN ULONG RequiredSize
    );

//
// tracehw.c
//

ULONG
WmipDumpHardwareConfig(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

ULONG
WmipDumpGuidMaps(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PLIST_ENTRY GuidMapListHeadPtr,
    IN ULONG StartFlag
    );

ULONG
WmipAddGuidHandleToGuidMapList(
    IN PLIST_ENTRY GuidMapListHeadPtr,
    IN ULONGLONG   GuidHandle,
    IN LPGUID      Guid
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\ntdll\handle.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    main.c

Abstract:
    
    Implements WMI GUID handle management code

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"
#include <rpc.h>

BOOLEAN WmipIsNumber(
    LPCWSTR String
    )
{
    while (*String != UNICODE_NULL)
    {
        if ((*String < L'0') || 
            (*String++ > L'9'))
        {
            return(FALSE);
        }
    }
    return(TRUE);
}


#define WmipWStringSizeInBytes(string) \
    ( ( (wcslen((string)) + 1) * sizeof(WCHAR) ) )


ULONG WmipBaseCookieIndex;
LIST_ENTRY WmipCookieHead = {&WmipCookieHead, &WmipCookieHead};


PNOTIFYCOOKIE WmipFindCookieByGuid(
    LPGUID Guid,
    PNOTIFYCOOKIECHUNK *Chunk
    )
/*+++

Routine Description:

    This routine assumes the PM critical section is held
        
Arguments:


Return Value:

---*/
{
    PLIST_ENTRY CookieList;
    PNOTIFYCOOKIECHUNK CookieChunk;
    PNOTIFYCOOKIE Cookie;
    ULONG i;
    
    CookieList = WmipCookieHead.Flink;
    while (CookieList != &WmipCookieHead)
    {
        CookieChunk = CONTAINING_RECORD(CookieList,
                                        NOTIFYCOOKIECHUNK,
                                        Next);

        for (i = 0; i < NOTIFYCOOKIESPERCHUNK; i++)
        {
            Cookie = &CookieChunk->Cookies[i];
            if ((Cookie->InUse) &&
                (IsEqualGUID(Guid, &Cookie->Guid)))
            {
                *Chunk = CookieChunk;
                return(Cookie);
            }
        }
        
        CookieList = CookieList->Flink;
    }
    return(NULL);
}

ULONG WmipAllocateCookie(
    PVOID DeliveryInfo,
    PVOID DeliveryContext,
    LPGUID Guid
    )
{
    PLIST_ENTRY CookieList;
    PNOTIFYCOOKIECHUNK CookieChunk;
    PNOTIFYCOOKIE Cookie;
    ULONG i;
    ULONG CheckSlot, FreeSlot;
    
    WmipEnterPMCritSection();

    while (1)
    {
        CookieList = WmipCookieHead.Flink;
        while (CookieList != &WmipCookieHead)
        {
            CookieChunk = CONTAINING_RECORD(CookieList,
                                            NOTIFYCOOKIECHUNK,
                                            Next);
            if (! CookieChunk->Full)
            {
                FreeSlot = CookieChunk->FreeSlot;
                for (i = 0; i < NOTIFYCOOKIESPERCHUNK; i++)
                {
                    CheckSlot = (FreeSlot + i) % NOTIFYCOOKIESPERCHUNK;
                    if (! CookieChunk->Cookies[CheckSlot].InUse)
                    {
                        //
                        // We found a free cookie slot
                        Cookie = &CookieChunk->Cookies[CheckSlot];
                        Cookie->InUse = TRUE;
                        CookieChunk->FreeSlot = (USHORT)((CheckSlot + 1) % NOTIFYCOOKIESPERCHUNK);
                        WmipLeavePMCritSection();
                        Cookie->DeliveryInfo = DeliveryInfo;
                        Cookie->DeliveryContext = DeliveryContext;
                        Cookie->Guid = *Guid;
                        return(CookieChunk->BaseSlot + CheckSlot + 1);
                    }
                }
            
                //
                // All slots were full so mark as such
                CookieChunk->Full = TRUE;
            }
            CookieList = CookieList->Flink;
        }
    
        //
        // No free cookie slots, allocate a new chunk
        CookieChunk = WmipAlloc(sizeof(NOTIFYCOOKIECHUNK));
        if (CookieChunk == NULL)
        {
            WmipLeavePMCritSection();
            return(0);
        }
        
        memset(CookieChunk, 0, sizeof(NOTIFYCOOKIECHUNK));
        CookieChunk->BaseSlot = WmipBaseCookieIndex;
        WmipBaseCookieIndex += NOTIFYCOOKIESPERCHUNK;
        InsertHeadList(&WmipCookieHead, &CookieChunk->Next);
    }
}

PNOTIFYCOOKIE WmipFindCookie(
    ULONG CookieSlot,
    LPGUID Guid,
    PNOTIFYCOOKIECHUNK *Chunk
    )
/*+++

Routine Description:

    This routine assumes the PM critical section is held
        
Arguments:


Return Value:

---*/
{
    PLIST_ENTRY CookieList;
    PNOTIFYCOOKIE Cookie;
    PNOTIFYCOOKIECHUNK CookieChunk;
    
    WmipAssert(CookieSlot != 0);
    
    CookieSlot--;
    
    CookieList = WmipCookieHead.Flink;
    while (CookieList != &WmipCookieHead)
    {
        CookieChunk = CONTAINING_RECORD(CookieList,
                                        NOTIFYCOOKIECHUNK,
                                        Next);
                                    
        if ((CookieSlot >= CookieChunk->BaseSlot) &&
            (CookieSlot < (CookieChunk->BaseSlot + NOTIFYCOOKIESPERCHUNK)))
        {
            Cookie = &CookieChunk->Cookies[CookieSlot - CookieChunk->BaseSlot];
            if (Guid != NULL)
            {
                if ((! Cookie->InUse) ||
                    (! IsEqualGUID(&Cookie->Guid, Guid)))
                {
                    Cookie = WmipFindCookieByGuid(Guid, &CookieChunk);
                }
            } else {
                if (! (Cookie->InUse) )
                    return NULL;
            }
            
            *Chunk = CookieChunk;
            return(Cookie);
        }
        
        CookieList = CookieList->Flink;
    }
    
    if (Guid != NULL)
    {
        Cookie = WmipFindCookieByGuid(Guid, &CookieChunk);
    } else {
        Cookie = NULL;
    }
    
    return(Cookie);
}

void WmipFreeCookie(
    ULONG CookieSlot
    )
{
    PNOTIFYCOOKIE Cookie;
    PNOTIFYCOOKIECHUNK CookieChunk;
    
    WmipEnterPMCritSection();
    Cookie = WmipFindCookie(CookieSlot, NULL, &CookieChunk);
    if (Cookie != NULL)
    {
        Cookie->InUse = FALSE;
        CookieChunk->Full = FALSE;
        CookieChunk->FreeSlot = (USHORT)(CookieSlot - CookieChunk->BaseSlot - 1);
    }
    WmipLeavePMCritSection();
}

void
WmipGetGuidInCookie(
    ULONG CookieSlot,
    LPGUID Guid
    )
{
    PNOTIFYCOOKIE Cookie;
    PNOTIFYCOOKIECHUNK CookieChunk;

    WmipEnterPMCritSection();
    Cookie = WmipFindCookie(CookieSlot, NULL, &CookieChunk);
    if (Cookie != NULL)
    {
        *Guid = Cookie->Guid;
    }
    WmipLeavePMCritSection();

    return;
}



BOOLEAN WmipLookupCookie(
    ULONG CookieSlot,
    LPGUID Guid,
    PVOID *DeliveryInfo,
    PVOID *DeliveryContext
    )
{
    PNOTIFYCOOKIE Cookie;
    PNOTIFYCOOKIECHUNK CookieChunk;    
    
    WmipEnterPMCritSection();
    Cookie = WmipFindCookie(CookieSlot, Guid, &CookieChunk);
    if (Cookie != NULL)
    {
        *DeliveryInfo = Cookie->DeliveryInfo;
        *DeliveryContext = Cookie->DeliveryContext;
    }
    WmipLeavePMCritSection();
    
    return(Cookie != NULL);
}


#if DBG
PCHAR GuidToStringA(
    PCHAR s,
    LPGUID piid
    )
{
    GUID XGuid = *piid;
    
    sprintf(s, "%x-%x-%x-%x%x%x%x%x%x%x%x",
               XGuid.Data1, XGuid.Data2, 
               XGuid.Data3,
               XGuid.Data4[0], XGuid.Data4[1],
               XGuid.Data4[2], XGuid.Data4[3],
               XGuid.Data4[4], XGuid.Data4[5],
               XGuid.Data4[6], XGuid.Data4[7]);

    return(s);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\inc\wmiump.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wmiump.h

Abstract:

    Private headers for WMI user mode

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#define _WMI_SOURCE_

//
// Define this to track reference counts
//#define TRACK_REFERNECES

//
// Define this to get extra checks on heap validation
//#define HEAPVALIDATION

//
// Define this to get a trace of critical section
//#define CRITSECTTRACE

//
// Define this to compile WMI to run as a service under NT
#define RUN_AS_SERVICE

//
// Define this to include WMI user mode functionality. Note that if you enable
// this then you also need to fix the files: wmi\dll\sources and wmi\makefil0.
//#define WMI_USER_MODE

//
// Define this to track memory leaks
//#define TRACK_MEMORY_LEAKS

#ifndef MEMPHIS
#define UNICODE
#define _UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <ole2.h>
#include <tchar.h>
#include <stdio.h>

#ifndef MEMPHIS
#include "svcs.h"
#endif

#include <netevent.h>

#ifdef MEMPHIS
//
// CONSIDER: Is there a better place to get this stuff on MEMPHIS
//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//


#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

typedef LONG NTSTATUS;
typedef NTSTATUS (*PUSER_THREAD_START_ROUTINE)(
    PVOID ThreadParameter
    );


#include <stdio.h>
#endif

#include "wmium.h"
#include "wmiumkm.h"
#include "ntwmi.h"
#include "wmiguid.h"

#if DBG
#define WmipAssert(x) if (! (x) ) { \
    BOOLEAN OldLoggingEnabled = WmipLoggingEnabled; \
    WmipLoggingEnabled = TRUE; \
    WmipDbgPrint(("WMI Assertion: "#x" at %s %d\n", __FILE__, __LINE__)); \
    WmipLoggingEnabled = OldLoggingEnabled; \
    DebugBreak(); }
#else
#define WmipAssert(x)
#endif

#if DBG
extern BOOLEAN WmipLoggingEnabled;
#ifdef MEMPHIS
void __cdecl DebugOut(char *Format, ...);
#define WmipDebugPrint(_x_) { if (WmipLoggingEnabled) DebugOut _x_; }
#define WmipDbgPrint(_x_) { if (WmipLoggingEnabled) DebugOut _x_; }
#else
#define WmipDebugPrint(_x_) { if (WmipLoggingEnabled) DbgPrint _x_; }
#define WmipDbgPrint(_x_) { if (WmipLoggingEnabled) DbgPrint _x_; }
#endif
#else
#define WmipDebugPrint(_x_)
#define WmipDbgPrint(_x_)
#endif

#define NULL_GUID  {0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

//
// Registry based config options. Only available on checked builds
//
#define WmiRegKeyText TEXT("SYSTEM\\CurrentControlSet\\Control\\WMI")
#define PumpTimeoutRegValueText TEXT("NotificationPumpTimeout")
#define LoggingEnableValueText TEXT("LoggingEnabled")





//
// WMI RPC related definitions
typedef struct
{
    WNODE_HEADER WnodeHeader;
    BYTE Data[1];
} WNODE_INTERNAL, *PWNODE_INTERNAL;

#define INTERNAL_PROVIDER_ID 1

//
// Size of initial buffer used to read notifications from kernel mode
#define STARTNOTIFICATIONBUFFERSIZE 4096

#ifdef MEMPHIS
#define WmiRpcProtocolSequence TEXT("ncalrpc")

#define WmiServiceRpcProtocolSequence TEXT("ncalrpc")
#define WmiServiceRpcEndpoint TEXT("WmiRpcEndpoint")
#else
//#define WmiRpcProtocolSequence TEXT("ncalrpc")
//#define WmiRpcEndpointPrefix TEXT("NT")

#define WmiRpcProtocolSequence TEXT("ncacn_np")
#define WmiRpcEndpointPrefix TEXT("\\pipe\\")

#define WmiServiceRpcProtocolSequence TEXT("ncacn_np")
#define WmiServiceRpcEndpoint SVCS_RPC_PIPE
#endif

#define MinRpcCalls 1
#define MaxRpcCalls RPC_C_PROTSEQ_MAX_REQS_DEFAULT

//
// Time to wait between retrying an RPC call that was too busy to complete
#define RPC_BUSY_WAIT_TIMER   500

//
// Number of times to retry an RPC call that was too busy to complete
#define RPC_BUSY_WAIT_RETRIES 5

//
// WMI RPC interface principle name
#define WMI_RPC_PRINC_NAME TEXT("WMI_RPC_PRINC_NAME")

//
// This macro will break CountedString into a pointer to the actual string
// and the actual length of the string excluding any trailing nul characters
#define WmipBreakCountedString(CountedString, CountedStringLen) { \
    CountedStringLen = *CountedString++; \
    if (CountedString[(CountedStringLen-sizeof(WCHAR))/sizeof(WCHAR)] == UNICODE_NULL) \
    { \
        CountedStringLen -= sizeof(WCHAR); \
    } \
}


typedef struct
{
    HANDLE GuidHandle;
    PVOID DeliveryInfo;
    ULONG_PTR DeliveryContext;
    ULONG Flags;
} NOTIFYEE, *PNOTIFYEE;

#define STATIC_NOTIFYEE_COUNT 2

typedef struct
{
    LIST_ENTRY GNList;
    GUID Guid;
    ULONG RefCount;	
    ULONG NotifyeeCount;
    PNOTIFYEE Notifyee;
    NOTIFYEE StaticNotifyee[STATIC_NOTIFYEE_COUNT];
} GUIDNOTIFICATION, *PGUIDNOTIFICATION;

#define WmipAllocGNEntry() (PGUIDNOTIFICATION)WmipAlloc(sizeof(GUIDNOTIFICATION))
#define WmipFreeGNEntry(GNEntry) WmipFree(GNEntry)
#define WmipReferenceGNEntry(GNEntry) InterlockedIncrement(&GNEntry->RefCount);


//
// Notification Cookie data structures
#if DBG
#define NOTIFYCOOKIESPERCHUNK 2
#else
#define NOTIFYCOOKIESPERCHUNK 128
#endif

typedef struct
{
    PVOID DeliveryContext;
    PVOID DeliveryInfo;
    GUID Guid;
    BOOLEAN InUse;
} NOTIFYCOOKIE, *PNOTIFYCOOKIE;

typedef struct
{
    LIST_ENTRY Next;                         // Next cookie chunk
    ULONG BaseSlot;                          // Index of first slot number
    USHORT FreeSlot;                         // Index to a free cookie
    BOOLEAN Full;                            // TRUE if this chunk is full
    NOTIFYCOOKIE Cookies[NOTIFYCOOKIESPERCHUNK];
} NOTIFYCOOKIECHUNK, *PNOTIFYCOOKIECHUNK;

//
// Useful macro to establish a WNODE_HEADER quickly
#ifdef _WIN64

#define WmipBuildWnodeHeader(Wnode, WnodeSize, FlagsUlong, Handle) { \
    (Wnode)->Flags = FlagsUlong;                           \
    (Wnode)->KernelHandle = Handle;                \
    (Wnode)->BufferSize = WnodeSize;                 \
    (Wnode)->Linkage = 0;                 \
}

#else

#define WmipBuildWnodeHeader(Wnode, WnodeSize, FlagsUlong, Handle) { \
    (Wnode)->Flags = FlagsUlong;                           \
    *((PULONG64)(&((Wnode)->TimeStamp))) = (ULONG64)(IntToPtr(PtrToInt(Handle))); \
    (Wnode)->BufferSize = WnodeSize;                 \
    (Wnode)->Linkage = 0;                 \
}

#endif

#ifdef MEMPHIS
extern HANDLE PMMutex;
#define WmipEnterPMCritSection() WaitForSingleObject(PMMutex, INFINITE)

#define WmipLeavePMCritSection() ReleaseMutex(PMMutex)

#else
extern RTL_CRITICAL_SECTION PMCritSect;
#if DBG
#define WmipEnterPMCritSection() \
                WmipAssert(NT_SUCCESS(RtlEnterCriticalSection(&PMCritSect)));
#define WmipLeavePMCritSection() { \
     WmipAssert(PMCritSect.LockCount >= 0); \
     WmipAssert(NT_SUCCESS(RtlLeaveCriticalSection(&PMCritSect))); }
#else
#define WmipEnterPMCritSection() RtlEnterCriticalSection(&PMCritSect)
#define WmipLeavePMCritSection() RtlLeaveCriticalSection(&PMCritSect)
#endif // DBG
#endif // MEMPHIS


typedef struct
{
    NOTIFICATIONCALLBACK Callback;
    ULONG_PTR Context;
    PWNODE_HEADER Wnode;
    BYTE WnodeBuffer[1];
} NOTIFDELIVERYCTX, *PNOTIFDELIVERYCTX;


// from handle.c

#define WmipVerifyToken() \
{ \
    ULONG VerifyStatus; \
    VerifyStatus = WmipCheckImpersonationTokenType(); \
    if (VerifyStatus != ERROR_SUCCESS) \
	{ \
		SetLastError(VerifyStatus); \
		return(VerifyStatus); \
	} \
}

ULONG WmipCheckImpersonationTokenType(
    void
    );

ULONG WmipCopyStringToCountedUnicode(
    LPCWSTR String,
    PWCHAR CountedString,
    ULONG *BytesUsed,
    BOOLEAN ConvertFromAnsi
    );

ULONG WmipCountedAnsiToCountedUnicode(
    PCHAR Ansi,
    PWCHAR Unicode
    );

ULONG WmipCountedUnicodeToCountedAnsi(
    PWCHAR Unicode,
    PCHAR Ansi
    );

#ifndef MEMPHIS
ULONG WmipCheckGuidAccess(
    LPGUID Guid,
    ACCESS_MASK DesiredAccess
    );

ULONG WmipOpenKernelGuid(
    LPGUID Guid,
    ACCESS_MASK DesiredAccess,
    PHANDLE Handle,
    ULONG Ioctl
    );
#endif

ULONG WmipAllocateCookie(
    PVOID DeliveryInfo,
    PVOID DeliveryContext,
    LPGUID Guid
    );

BOOLEAN WmipLookupCookie(
    ULONG CookieSlot,
    LPGUID Guid,
    PVOID *DeliveryInfo,
    PVOID *DeliveryContext
    );

void WmipGetGuidInCookie(
    ULONG CookieSlot,
    LPGUID Guid
    );

void WmipFreeCookie(
    ULONG CookieSlot
    );

PGUIDNOTIFICATION
WmipFindGuidNotification(
    LPGUID Guid
    );

ULONG
WmipAddToGNList(
    LPGUID Guid,
    PVOID DeliveryInfo,
    ULONG_PTR DeliveryContext,
    ULONG Flags,
    HANDLE GuidHandle
    );

ULONG
WmipRemoveFromGNList(
    LPGUID Guid,
    PVOID DeliveryInfo
    );

BOOLEAN
WmipDereferenceGNEntry(
    PGUIDNOTIFICATION GNEntry
    );

PTCHAR GuidToString(
    PTCHAR s,
    LPGUID piid
    );

PCHAR GuidToStringA(
    PCHAR s,
    LPGUID piid
    );


// from request.c
ULONG WmipSendWmiRequest(
    ULONG ActionCode,
    PWNODE_HEADER Wnode,
    ULONG WnodeSize,
    PVOID OutBuffer,
    ULONG MaxBufferSize,
    ULONG *RetSize
    );

ULONG WmipSendWmiKMRequest(
    HANDLE Handle,
    ULONG Ioctl,
    PVOID InBuffer,
    ULONG InBufferSize,
    PVOID OutBuffer,
    ULONG MaxBufferSize,
    ULONG *ReturnSize,
    LPOVERLAPPED Overlapped
    );

ULONG WmipConvertWADToAnsi(
    PWNODE_ALL_DATA Wnode
    );

ULONG WmipConvertWADToUnicode(
    PWNODE_ALL_DATA WnodeAllData,
    ULONG *BufferSize
    );

ULONG WmipRegisterGuids(
    IN LPGUID MasterGuid,
    IN ULONG RegistrationCookie,    
    IN PWMIREGINFOW RegInfo,
    IN ULONG GuidCount,
    OUT PTRACEGUIDMAP *GuidMapHandle,
    OUT ULONG64 *LoggerContext,
    OUT HANDLE *RegistrationHandle
    );

//
// from intrnldp.c
ULONG WmipInternalProvider(
    ULONG ActionCode,
    PWNODE_HEADER Wnode,
    ULONG MaxWnodeSize,
    PVOID OutBuffer,
    ULONG *RetSize
   );

ULONG
WmipEnumRegGuids(
    PWMIGUIDLISTINFO *pGuidInfo
    );

//
// from dcapi.c
ULONG
WmipNotificationRegistration(
    IN LPGUID InGuid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG64 LoggerContext,
    IN ULONG Flags,
    IN BOOLEAN IsAnsi
    );


//
// from mofapi.c
//
void WmipProcessLanguageAddRemoveEvent(
    IN PWNODE_SINGLE_INSTANCE WnodeSI,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    );

void WmipProcessMofAddRemoveEvent(
    IN PWNODE_SINGLE_INSTANCE WnodeSI,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    );


//
// from notify.c
extern ULONG WmipNotificationSinkIndex;
#ifndef MEMPHIS

ULONG WmipProcessUMRequest(
    PWMI_LOGGER_INFORMATION LoggerInfo,
    PVOID DeliveryContext,
    ULONG ReplyIndex
    );

#endif

ULONG WmipAddHandleToEventPump(
    LPGUID Guid,
    PVOID DeliveryInfo,
    ULONG_PTR DeliveryContext,
    ULONG NotificationFlags,
    HANDLE GuidHandle
    );

void WmipMakeEventCallbacks(
    IN PWNODE_HEADER Wnode,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    );


ULONG
WmipReceiveNotifications(
    IN ULONG HandleCount,
    IN HANDLE *HandleList,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi,
    IN ULONG Action,
    IN PUSER_THREAD_START_ROUTINE UserModeCallback,
    IN HANDLE ProcessHandle
    );

ULONG WmipEventPump(
    PVOID Param
    );

//
// from main.c
VOID
WmipCreateHeap(
    VOID
    );

#ifndef IsEqualGUID
#define IsEqualGUID(guid1, guid2) \
                (!memcmp((guid1), (guid2), sizeof(GUID)))
#endif


//
// These define the dll and mof resource name for all of the builtin mof
// resources
#define WMICOREDLLNAME L"wmicore.dll"
#define WMICOREMOFRESOURCENAME L"MofResource"


//
// This defines the registry key under which security descriptors associated
// with the guids are stored.
#ifndef MEMPHIS
#define WMISECURITYREGISTRYKEY TEXT("System\\CurrentControlSet\\Control\\Wmi\\Security")
#endif


//
// This defines the initial value of the buffer passed to each data provider
// to retrieve the registration information
#if DBG
#define INITIALREGINFOSIZE sizeof(WNODE_TOO_SMALL)
#else
#define INITIALREGINFOSIZE 8192
#endif


//
// Chunk Management definitions
// All structures that rely upon the chunk allocator must be defined so that
// their members match that of ENTRYHEADER. These include DATASOURCE,
// GUIDENTRY, INSTANCESET, DCENTRY, NOTIFICATIONENTRY, MOFCLASS, MOFRESOURCE
// Also ENTRYHEADER reserves 0x80000000 for its own flag.

struct _CHUNKINFO;
struct _ENTRYHEADER;

typedef void (*ENTRYCLEANUP)(
    struct _CHUNKINFO *,
    struct _ENTRYHEADER *
    );

typedef struct _CHUNKINFO
{
    LIST_ENTRY ChunkHead;        // Head of list of chunks
    ULONG EntrySize;            // Size of a single entry
    ULONG EntriesPerChunk;        // Number of entries per chunk allocation
    ENTRYCLEANUP EntryCleanup;   // Entry cleanup routine
    ULONG InitialFlags;         // Initial flags for all entries
    ULONG Signature;
#if DBG
    ULONG AllocCount;
    ULONG FreeCount;
#endif
} CHUNKINFO, *PCHUNKINFO;

typedef struct
{
    LIST_ENTRY ChunkList;        // Node in list of chunks
    LIST_ENTRY FreeEntryHead;    // Head of list of free entries in chunk
    ULONG EntriesInUse;            // Count of entries being used
} CHUNKHEADER, *PCHUNKHEADER;

typedef struct _ENTRYHEADER
{
    union
    {
        LIST_ENTRY FreeEntryList;    // Node in list of free entries
        LIST_ENTRY InUseEntryList;   // Node in list ofin use entries
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;                // Flags
    ULONG RefCount;                 // Reference Count
    ULONG Signature;
} ENTRYHEADER, *PENTRYHEADER;

                                // Set if the entry is free
#define FLAG_ENTRY_ON_FREE_LIST       0x80000000
#define FLAG_ENTRY_ON_INUSE_LIST      0x40000000
#define FLAG_ENTRY_INVALID            0x20000000
#define FLAG_ENTRY_REMOVE_LIST        0x10000000


#define WmipReferenceEntry(Entry) \
    InterlockedIncrement(&((PENTRYHEADER)(Entry))->RefCount)

// chunk.c
#ifndef MEMPHIS
ULONG WmipBuildGuidObjectAttributes(
    IN LPGUID Guid,
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PUNICODE_STRING GuidString,
    OUT PWCHAR GuidObjectName
    );
#endif

ULONG WmipUnreferenceEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry);

PENTRYHEADER WmipAllocEntry(
    PCHUNKINFO ChunkInfo
    );

void WmipFreeEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

//
// This is the guid that denotes non event notifications. WMICore
// automatically registers anyone opening a guid to
extern GUID RegChangeNotificationGuid;

extern CHUNKINFO DSChunkInfo;
extern CHUNKINFO GEChunkInfo;
extern CHUNKINFO ISChunkInfo;
extern CHUNKINFO DCChunkInfo;
extern CHUNKINFO NEChunkInfo;
extern CHUNKINFO MRChunkInfo;

struct tagGUIDENTRY;
typedef struct tagGUIDENTRY GUIDENTRY, *PGUIDENTRY, *PBGUIDENTRY;

struct tagDATASOURCE;


//
// An INSTANCESET contains the information a set of instances that is provided
// by a single data source. An instance set is part of two lists. One list is
// the set of instance sets for a particular guid. The other list is the list
// of instance sets supported by a data source.
//

//
// Instance names for an instance set registered with a base name and count
// are stored in a ISBASENAME structure. This structure is tracked by
// PDFISBASENAME in wmicore.idl.
typedef struct
{
    ULONG BaseIndex;            // First index to append to base name
    WCHAR BaseName[1];            // Actual base name
} ISBASENAME, *PISBASENAME, *PBISBASENAME;

//
// This defines the maximum number of characters that can be part of a suffix
// to a basename. The current value of 6 will allow up to 999999 instances
// of a guid with a static base name
#define MAXBASENAMESUFFIXSIZE    6

//
// Instance names for an instance set registerd with a set of static names
// are kept in a ISSTATICNAMES structure. This structure is tracked by
// PDFISSTATICNAMES defined in wmicore.idl
typedef struct
{
    PWCHAR StaticNamePtr[1];     // pointers to static names
//    WCHAR StaticNames[1];
} ISSTATICENAMES, *PISSTATICNAMES, *PBISSTATICNAMES;

typedef struct tagInstanceSet
{
    union
    {
        // Entry in list of instances within a guid
        LIST_ENTRY GuidISList;

        // Entry in main list of free instances
        LIST_ENTRY FreeISList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    // Reference count of number of guids using this instance set
    ULONG RefCount;

    // Signature to identify entry
    ULONG Signature;

    // Entry in list of instances within a data source
    LIST_ENTRY DSISList;

    // Back link to guid that this instance set is a member
    PBGUIDENTRY GuidEntry;

    // Back link to data source that this instance set is a member
    struct tagDATASOURCE *DataSource;

    // Count of instances in instance set
    ULONG Count;

    //
    // If IS_INSTANCE_BASENAME is set then IsBaseName pointe at instance base
    // name structure. Else if IS_INSTANCE_STATICNAME is set then
    // IsStaticNames points to static instance name list. If
    union
    {
        PBISBASENAME IsBaseName;
        PBISSTATICNAMES IsStaticNames;
    };

} INSTANCESET, *PINSTANCESET, *PBINSTANCESET;

#define IS_SIGNATURE 'nalA'

//
// Guid Map Entry List maintains the list of Guid and their maps.
// Only those Guids that are Unregistered while a logger session is in
// progress is kept in this list.
// It is also used as a placeholder for InstanceIds. Trace Guid Registration
// calls return a handle to a GUIDMAPENTRY which maintains the map and the
// Instance Ids.
//

typedef struct tagTRACE_REG_INFO
{
    ULONG       RegistrationCookie;
    HANDLE      InProgressEvent; // Registration is in Progress Event
    BOOLEAN     EnabledState;    // Indicates if this GUID is Enabled or not.
    PVOID       NotifyRoutine;
    PVOID       TraceCtxHandle;
} TRACE_REG_INFO, *PTRACE_REG_INFO;

typedef struct
{
    LIST_ENTRY      Entry;
    TRACEGUIDMAP    GuidMap;
    ULONG           InstanceId;
    ULONG64         LoggerContext;
    PTRACE_REG_INFO pControlGuidData;
} GUIDMAPENTRY, *PGUIDMAPENTRY;


#define IS_INSTANCE_BASENAME        0x00000001
#define IS_INSTANCE_STATICNAMES     0x00000002
#define IS_EXPENSIVE                0x00000004    // set if collection must be enabled
#define IS_COLLECTING               0x00000008    // set when collecting

#define IS_KM_PROVIDER              0x00000080    // KM data provider
#define IS_SM_PROVIDER              0x00000100    // Shared memory provider
#define IS_UM_PROVIDER              0x00000200    // User mode provider
#define IS_NEWLY_REGISTERED         0x00000800    // set if IS is registering

//
// Any traced guids are used for trace logging and not querying
#define IS_TRACED                   0x00001000

// Set when events are enabled for instance set
#define IS_ENABLE_EVENT             0x00002000

// Set when events are enabled for instance set
#define IS_ENABLE_COLLECTION        0x00004000

// Set if guid is used only for firing events and not querying
#define IS_EVENT_ONLY               0x00008000

// Set if data provider for instance set is expecting ansi instsance names
#define IS_ANSI_INSTANCENAMES       0x00010000

// Set if instance names are originated from a PDO
#define IS_PDO_INSTANCENAME         0x00020000

// If set the data provider for the InstanceSet is internal to wmi.dll
#define IS_INTERNAL_PROVIDER        0x00040000

// Set if a Traced Guid is also a Trace Control Guid
#define IS_CONTROL_GUID             0x00080000

#define IS_ON_FREE_LIST             0x80000000

typedef struct tagGUIDENTRY
{
    union
    {
        // Entry in list of all guids registered with WMI
        LIST_ENTRY MainGEList;

        // Entry in list of free guid entry blocks
        LIST_ENTRY FreeGEList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    // Count of number of data sources using this guid
    ULONG RefCount;

    // Signature to identify entry
    ULONG Signature;

    // Count of InstanceSets headed by this guid
    ULONG ISCount;

    // Head of list of all instances for guid
    LIST_ENTRY ISHead;

    // Guid that represents data block
    GUID Guid;

} GUIDENTRY, *PGUIDENTRY, *PBGUIDENTRY;

#define GE_SIGNATURE 'diuG'

#define GE_ON_FREE_LIST        0x80000000

//
// When set this guid is an internally defined guid that has no data source
// attached to it.
#define GE_FLAG_INTERNAL    0x00000001



typedef struct
{
    union
    {
        // Entry in list of all DS
        LIST_ENTRY MainMRList;

        // Entry in list of free DS
        LIST_ENTRY FreeMRList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    ULONG RefCount;

    // Signature to identify entry
    ULONG Signature;

    PWCHAR MofImagePath;           // Path to image file with resource
    PWCHAR MofResourceName;        // Name of resource containing mof data
#ifdef WMI_USER_MODE
    LIST_ENTRY MRMCHead;
#endif

} MOFRESOURCE, *PMOFRESOURCE;

#define MR_SIGNATURE 'yhsA'


#if DBG
#define AVGMOFRESOURCECOUNT 1
#else
#define AVGMOFRESOURCECOUNT 4
#endif

typedef struct tagDATASOURCE
{
    union
    {
        // Entry in list of all DS
        LIST_ENTRY MainDSList;

        // Entry in list of free DS
        LIST_ENTRY FreeDSList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    ULONG RefCount;

    ULONG Signature;

    // Head of list of instances for this DS
    LIST_ENTRY ISHead;

    // Binding string and callback address for DS rpc server
    PTCHAR BindingString;
    RPC_BINDING_HANDLE RpcBindingHandle;
    ULONG RequestAddress;
    ULONG RequestContext;

    // Provider id of kernel mode driver
    ULONG_PTR ProviderId;

    // Path to registry holding ACLs
    PTCHAR RegistryPath;

    // Head of list of MofResources attached to data source
    ULONG MofResourceCount;
    PMOFRESOURCE *MofResources;
    PMOFRESOURCE StaticMofResources[AVGMOFRESOURCECOUNT];
};

#define DS_SIGNATURE ' naD'

#define VERIFY_DPCTXHANDLE(DsCtxHandle) \
    ( ((DsCtxHandle) == NULL) || \
      (((PBDATASOURCE)(DsCtxHandle))->Signature == DS_SIGNATURE) )
	
typedef struct tagDATASOURCE DATASOURCE, *PDATASOURCE, *PBDATASOURCE;

#define DS_ALLOW_ALL_ACCESS    0x00000001
#define DS_KERNEL_MODE         0x00000002

//
// Set in the Internal WMI data source
#define DS_INTERNAL            0x00000004

#define DS_ON_FREE_LIST        0x80000000


//
// A list of enabled notifications is maintained by the wmi service to mange
// delivering events and to know when to send enable and disable event
// wmi requests to the data providers. Each NOTIFICATIONENTRY has an array of
// DCREF which is a reference to the data consumer who is interested in the
// event.

#define RPCOUTSTANDINGCALLLIMIT 128

typedef struct
{
    LIST_ENTRY MainDCList;        // Node on global data consumer list
    PCHUNKHEADER Chunk;           // Chunk in which entry is located
    ULONG Flags;
    ULONG RefCount;

    ULONG Signature;
                                  // Actual RPC binding handle
    RPC_BINDING_HANDLE RpcBindingHandle;

    PUCHAR EventData;             // Buffer to hold events to be sent
    ULONG LastEventOffset;        // Offset in EventData to previous event
    ULONG NextEventOffset;        // Offset in EventData to write next event
    ULONG EventDataSizeLeft;      // Number of bytes left to use in EventData

    ULONG RpcCallsOutstanding;    // Number of rpc calls outstanding
#if DBG
    PTCHAR BindingString;         // Binding string for consumer
#endif
} DCENTRY, *PDCENTRY;

#define DC_SIGNATURE 'cirE'

// If the data consumer has had its context rundown routine then this flag
// is set. This indicates that the data consumer has gone away and no more
// events should be sent to him.
#define DC_FLAG_RUNDOWN        0x00000001

#define VERIFY_DCCTXHANDLE(DcCtxHandle) \
    ( ((DcCtxHandle) == NULL) || \
      (((PDCENTRY)(DcCtxHandle))->Signature == DC_SIGNATURE) )


typedef struct
{
    PDCENTRY DcEntry;     // points at data consumer interested in notification
                          // Number of times collect has been enabled by
                          // this DC.
    ULONG CollectRefCount;

                          // Number of times collect has been enabled by
                          // this DC.
    ULONG EventRefCount;

    ULONG Flags;         // Flags
    ULONG LostEventCount;
} DCREF, *PDCREF;

//
// _ENABLED flag set if DP already called to enable notification or collection
#define DCREF_FLAG_NOTIFICATION_ENABLED    0x00000001
#define DCREF_FLAG_COLLECTION_ENABLED      0x00000002

// if DCREF_FLAG_NO_EXTRA_THREAD set then WMI will not create a special thread
// to do the direct notification callback.
#define DCREF_FLAG_NO_EXTRA_THREAD        0x00000008

// If this flag is set then the notification callback is expecting an ANSI
// instance names.
#define DCREF_FLAG_ANSI                   0x00000010

// NOTE: Other notification flags in wmium.h are:
// NOTIFICATION_TRACE_FLAG 0x00010000
//
// NOTIFICATION_FLAG_CALLBACK_DIRECT is set when NotifyAddress specifies
// a direct callback address for delivering the event.
//
// NOTIFICATION_FLAG_CALLBACK_DIRECT is set when NotifyAddress specifies
// a direct callback address for delivering the event.
//
#define NOTIFICATION_FLAG_CALLBACK_DIRECT    0x00020000
#define NOTIFICATION_FLAG_CALLBACK_QUEUED    0x00040000
#define NOTIFICATION_FLAG_WINDOW             0x00080000
#define NOTIFICATION_FLAG_BATCHED            0x00100000

//
// This flag is set for those guid handles that may be duplicated in
// the list. All Notifyee slots that have this flag are considered in a
// group and only one handle needs to be put on the list
//
#define NOTIFICATION_FLAG_GROUPED_EVENT      0x00200000

//
// This flag is set for those guid handles that are pending closure.
// Only the pump thread is allowed to close a handle; the main threads
// will set this flag to indicate that the handle should no longer be
// used. When the pump thread builds the list of handles and notices
// the flag it will close the handle.
//
#define NOTIFICATION_FLAG_PENDING_CLOSE      0x00400000

#define WmipIsNotifyeePendingClose(Notifyee) \
    (((Notifyee)->Flags & NOTIFICATION_FLAG_PENDING_CLOSE) == NOTIFICATION_FLAG_PENDING_CLOSE)


//
// These are the flags contained in DcRef->Flags that pertain to Notifications
#define NOTIFICATION_MASK_EVENT_FLAGS  \
                                    (NOTIFICATION_FLAG_CALLBACK_DIRECT | \
                                     NOTIFICATION_FLAG_CALLBACK_QUEUED | \
                                     NOTIFICATION_FLAG_WINDOW | \
                                     DCREF_FLAG_NO_EXTRA_THREAD | \
                                     DCREF_FLAG_ANSI)


//
// This defines the number of DC references a NOTIFICATIONENTRY can have
// in a single entry

// CONSIDER: Merging NOTIFICATIONENTRY with GUIDENTRY
#define DCREFPERNOTIFICATION    16

typedef struct _notificationentry
{
    LIST_ENTRY MainNotificationList;    // Node in main notifications list
    PCHUNKHEADER Chunk;                 // Chunk in which entry is located
    ULONG Flags;                        // flags
    ULONG RefCount;

    // Signature to identify entry
    ULONG Signature;

    GUID Guid;                          // guid representing notification
                                        // If > DCREFPERNOTIFICATION DC have
                                        // enabled this event then this points
                                        // to another NOTIFICATIONENTRY which
                                        // has another DCREF array
    struct _notificationentry *Continuation;
    ULONG EventRefCount;                // Global count of event enables
    ULONG CollectRefCount;              // Global count of collection enables
    ULONG64 LoggerContext;              // Logger context handle
	    
    HANDLE CollectInProgress;           // Event set when all collect complete

    DCREF DcRef[DCREFPERNOTIFICATION];    // DC that have enabled this event
} NOTIFICATIONENTRY, *PNOTIFICATIONENTRY;

#define NE_SIGNATURE 'eluJ'

// Set when a notification request is being processed by the data providers
#define NE_FLAG_NOTIFICATION_IN_PROGRESS 0x00000001

// Set when a collection request is being processed by the data providers
#define NE_FLAG_COLLECTION_IN_PROGRESS 0x00000002

// Set when a trace disable is being processed by a worker thread
#define NE_FLAG_TRACEDISABLE_IN_PROGRESS 0x00000004

#ifdef WMI_USER_MODE
//
// Valid MOF data types for qualifiers and properties (data items)
typedef enum
{
    MOFInt32 = 0,                // 32bit integer
    MOFUInt32 = 1,               // 32bit unsigned integer
    MOFInt64 = 2,                // 64bit integer
    MOFUInt64 = 3,               // 32bit unsigned integer
    MOFInt16 = 4,                // 16bit integer
    MOFUInt16 = 5,               // 16bit unsigned integer
    MOFChar = 6,                 // 8bit integer
    MOFByte = 7,                 // 8bit unsigned integer
    MOFWChar = 8,                // Wide (16bit) character
    MOFDate = 9,                 // Date field
    MOFBoolean = 10,             // 8bit Boolean value
    MOFEmbedded = 11,            // Embedded class
    MOFString = 12,              // Counted String type
    MOFZTString = 13,            // NULL terminated unicode string
    MOFAnsiString = 14,          // NULL terminated ansi string
    MOFUnknown = 0xffffffff      // Data type is not known
} MOFDATATYPE, *PMOFDATATYPE;

// Data items that are of type MOFString are stored in the data block as a
// counted unicode string. The text of the string is always preceeded by
// a USHORT which contains the count of bytes following that composes the
// string. The string may be NULL terminated and in that case the count must
// include the null termination bytes.


// Data items that are of type MOFDate are fixed length Unicode strings and
// not preceeded by a count value. It is in the following fixed format:
//
//      yyyymmddhhmmss.mmmmmmsutc
//
// Where  yyyy is a 4 digit year, mm is the month, dd is the day,  hh  is
// the  hour  (24-hour clock), mm is the minute, ss is  the  second,  the
// mmmmmm is the number of microseconds (typically all zeros) and s is  a
//  "+"  or  "-" indicating the sign of the UTC (correction field, and  utc
// is  the  offset from UTC in minutes (using the sign indicated  by  s).
// For  example,  Wednesday, May 25, 1994, at 1:30:15  PM  EDT  would  be
// represented as:
//
//      19940525133015.0000000-300
//
// Values  MUST  be zero-padded so that the entire string is  always  the
// same 25-character length.  Fields which are not significant  MUST  be
// replaced  with asterisk characters.  Similarly,  intervals   use  the
// same  format, except   that   the  interpretation of the fields is based
// on elapsed time. For  example,  an  elapsed time of 1 day, 13 hours,
// 23 minutes, and 12 seconds  would  be:
//
//      00000001132312.000000+000
//
// A UTC offset of zero is always used for interval properties.

struct _MOFCLASSINFOW;
struct _MOFCLASSINFOA;

//
// Each class has one or more data items that are described by a MOFDATAITEM
// structure.
typedef struct
{
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
           Name;                    // Text name of data item
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
           Description;             // Text description of data item
    MOFDATATYPE DataType;           // MOF data type
    ULONG Version;                  // Version that this MOF is part of
    ULONG SizeInBytes;              // Size of data item in Blob
    ULONG Flags;                    // Flags, See MOFDI_FLAG_*
    GUID EmbeddedClassGuid;         // Guid of data item's embedded class
    ULONG FixedArrayElements;       // Number of elements in fixed sized array
                                    // Used when MOF_FLAG_FIXED_ARRAY is set

    ULONG VariableArraySizeId;      // MOF_FLAG_VARIABLE_ARRAY, Data id of
                                    // variable containing number of elements
                                    // in array

    PVOID VarArrayTempPtr;
    PVOID EcTempPtr;
    ULONG_PTR PropertyQualifierHandle;
    ULONG MethodId;
    LPWSTR HeaderName;// Name of structure in generated header
    struct _MOFCLASSINFOW *MethodClassInfo;
	ULONG MaxLen;
} MOFDATAITEMW, *PMOFDATAITEMW;

typedef struct
{
    LPSTR
           Name;                    // Text name of data item
    LPSTR
           Description;             // Text description of data item
    MOFDATATYPE DataType;           // MOF data type
    ULONG Version;                  // Version that this MOF is part of
    ULONG SizeInBytes;              // Size of data item in Blob
    ULONG Flags;                    // Flags, See MOFDI_FLAG_*
    GUID EmbeddedClassGuid;         // Guid of data item's embedded class
    ULONG FixedArrayElements;       // Number of elements in fixed sized array
                                    // Used when MOF_FLAG_FIXED_ARRAY is set

    ULONG VariableArraySizeId;      // MOF_FLAG_VARIABLE_ARRAY, Data id of
                                    // variable containing number of elements
                                    // in array
    PVOID VarArrayTempPtr;
    PVOID EcTempPtr;
    ULONG_PTR PropertyQualifierHandle;
    ULONG MethodId;
    LPSTR HeaderName;               // Name of structure in generated header
    struct _MOFCLASSINFOA *MethodClassInfo;
	ULONG MaxLen;
} MOFDATAITEMA, *PMOFDATAITEMA;

#ifdef UNICODE
typedef MOFDATAITEMW MOFDATAITEM;
typedef PMOFDATAITEMW PMOFDATAITEM;
#else
typedef MOFDATAITEMA MOFDATAITEM;
typedef PMOFDATAITEMA PMOFDATAITEM;
#endif


// Data item is actually a fixed sized array
#define MOFDI_FLAG_FIXED_ARRAY        0x00000001

// Data item is actually a variable length array
#define MOFDI_FLAG_VARIABLE_ARRAY     0x00000002

// Data item is actually an embedded class
#define MOFDI_FLAG_EMBEDDED_CLASS     0x00000004

// Data item is readable
#define MOFDI_FLAG_READABLE           0x00000008

// Data item is writable
#define MOFDI_FLAG_WRITEABLE          0x00000010

// Data item is an event
#define MOFDI_FLAG_EVENT              0x00000020

// Embedded class Guid is not set
#define MOFDI_FLAG_EC_GUID_NOT_SET    0x00000040

// Data item is really a method
#define MOFDI_FLAG_METHOD             0x00000080

// Data item is an input method parameter
#define MOFDI_FLAG_INPUT_METHOD       0x00000100

// Data item is an output method parameter
#define MOFDI_FLAG_OUTPUT_METHOD      0x00000200

//
// The MOFCLASSINFO structure describes the format of a data block
typedef struct _MOFCLASSINFOW
{
    GUID Guid;                    // Guid that represents class

#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
                      Name;       // Text name of class
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
                      Description;// Text description of class
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
                      HeaderName;// Name of structure in generated header
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
                      GuidName1;// Name of Guid in generated header
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
                      GuidName2;// Name of Guid in generated header
    USHORT Language;                // Language of MOF
    USHORT Reserved;
    ULONG Flags;                  // Flags, see MOFGI_FLAG_*
    ULONG Version;                // Version of Guid
    ULONG DataItemCount;          // Number of wmi data items (properties)
    ULONG MethodCount;            // Number of wmi data items (properties)
                                  // Array of Property info
#ifdef MIDL_PASS
    [size_is(DataItemCount)]
#endif
      MOFDATAITEMW *DataItems;
#ifndef MIDL_PASS
    UCHAR Tail[1];
#endif
} MOFCLASSINFOW, *PMOFCLASSINFOW;

typedef struct _MOFCLASSINFOA
{
    GUID Guid;                    // Guid that represents class

    LPSTR
                      Name;       // Text name of class
    LPSTR
                      Description;// Text description of class
    LPSTR
                      HeaderName;// Name of structure in generated header
    LPSTR
                      GuidName1;// Name of Guid in generated header
    LPSTR
                      GuidName2;// Name of Guid in generated header
    USHORT Language;                // Language of MOF
    USHORT Reserved;
    ULONG Flags;                  // Flags, see MOFGI_FLAG_*
    ULONG Version;                // Version of Guid
    ULONG DataItemCount;          // Number of wmi data items (properties)
    ULONG MethodCount;            // Number of wmi data items (properties)
                                  // Array of Property info
    MOFDATAITEMA *DataItems;
    UCHAR Tail[1];
} MOFCLASSINFOA, *PMOFCLASSINFOA;

#ifdef UNICODE
typedef MOFCLASSINFOW MOFCLASSINFO;
typedef PMOFCLASSINFOW PMOFCLASSINFO;
#else
typedef MOFCLASSINFOA MOFCLASSINFO;
typedef PMOFCLASSINFOA PMOFCLASSINFO;
#endif

// 0x00000001 to 0x00000004 are not available
#define MOFCI_FLAG_EVENT          0x10000000
#define MOFCI_FLAG_EMBEDDED_CLASS 0x20000000
#define MOFCI_FLAG_READONLY       0x40000000
#define MOFCI_FLAG_METHOD_PARAMS  0x80000000

typedef struct
{
    union
    {
        // Entry in list of all DS
        LIST_ENTRY MainMCList;

        // Entry in list of free DS
        LIST_ENTRY FreeMCList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    ULONG RefCount;

    PMOFCLASSINFOW MofClassInfo;   // Actual class info data

    LIST_ENTRY MCMRList;          // Entry in list of MCs in a MR

    LIST_ENTRY MCVersionList;     // Head or entry in list of MCs with
                                  // same guid, but possibly different versions

    ULONG_PTR ClassObjectHandle;      // CBMOFObj, BMOF class object ptr
    PMOFRESOURCE MofResource;     // Resource holding class info

} MOFCLASS, *PMOFCLASS;

// If this is set then the MOF class can never be replaced with a later version
#define MC_FLAG_NEVER_REPLACE 0x00000001

#endif

//
// AVGGUIDSPERDS defines a guess as to the number of guids that get registered
// by any data provider. It is used to allocate the buffer used to deliver
// registration change notifications.
#if DBG
#define AVGGUIDSPERDS    2
#else
#define AVGGUIDSPERDS    256
#endif


#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)(Base) + (Offset)))



//
// Guid and InstanceSet cache
#if DBG
#define PTRCACHEGROWSIZE 2
#else
#define PTRCACHEGROWSIZE 64
#endif

typedef struct
{
    LPGUID Guid;
    PBINSTANCESET InstanceSet;
} PTRCACHE;


//
// Registration data structures
//

#ifdef MEMPHIS

extern HANDLE SMMutex;
#define WmipEnterSMCritSection() WaitForSingleObject(SMMutex, INFINITE)

#define WmipLeaveSMCritSection() ReleaseMutex(SMMutex)

#else
extern RTL_CRITICAL_SECTION SMCritSect;
#if DBG
#ifdef CRITSECTTRACE
#define WmipEnterSMCritSection() { \
    WmipDebugPrint(("WMI: %d Enter SM Crit %s %d\n", GetCurrentThreadId(), __FILE__, __LINE__)); \
    RtlEnterCriticalSection(&SMCritSect); }

#define WmipLeaveSMCritSection() { \
    WmipDebugPrint(("WMI: %d Leave SM Crit %s %d\n", GetCurrentThreadId(), __FILE__, __LINE__)); \
    RtlLeaveCriticalSection(&SMCritSect); }
#else
#define WmipEnterSMCritSection() \
                WmipAssert(NT_SUCCESS(RtlEnterCriticalSection(&SMCritSect)));
#define WmipLeaveSMCritSection() { \
     WmipAssert(SMCritSect.LockCount >= 0); \
     WmipAssert(NT_SUCCESS(RtlLeaveCriticalSection(&SMCritSect))); }
#endif // CRITSECTTRACE

#else
#define WmipEnterSMCritSection() RtlEnterCriticalSection(&SMCritSect)
#define WmipLeaveSMCritSection() RtlLeaveCriticalSection(&SMCritSect)
#endif // DBG
#endif // MEMPHIS

#ifndef IsEqualGUID
#define IsEqualGUID(guid1, guid2) \
                (!memcmp((guid1), (guid2), sizeof(GUID)))
#endif


//
// WMI MOF result codes. Since they are never given to the caller they are
// defined in here
#define ERROR_WMIMOF_INCORRECT_DATA_TYPE -1               /* 0xffffffff */
#define ERROR_WMIMOF_NO_DATA -2                           /* 0xfffffffe */
#define ERROR_WMIMOF_NOT_FOUND -3                         /* 0xfffffffd */
#define ERROR_WMIMOF_UNUSED -4                            /* 0xfffffffc */
// Property %ws in class %ws has no embedded class name
#define ERROR_WMIMOF_NO_EMBEDDED_CLASS_NAME -5            /* 0xfffffffb */
// Property %ws in class %ws has an unknown data type
#define ERROR_WMIMOF_UNKNOWN_DATA_TYPE -6                 /* 0xfffffffa */
// Property %ws in class %ws has no syntax qualifier
#define ERROR_WMIMOF_NO_SYNTAX_QUALIFIER -7               /* 0xfffffff9 */
#define ERROR_WMIMOF_NO_CLASS_NAME -8                     /* 0xfffffff8 */
#define ERROR_WMIMOF_BAD_DATA_FORMAT -9                   /* 0xfffffff7 */
// Property %ws in class %ws has the same WmiDataId %d as property %ws
#define ERROR_WMIMOF_DUPLICATE_ID -10                     /* 0xfffffff6 */
// Property %ws in class %ws has a WmiDataId of %d which is out of range
#define ERROR_WMIMOF_BAD_DATAITEM_ID -11                  /* 0xfffffff5 */
#define ERROR_WMIMOF_MISSING_DATAITEM -12                 /* 0xfffffff4 */
// Property for WmiDataId %d is not defined in class %ws
#define ERROR_WMIMOF_DATAITEM_NOT_FOUND -13               /* 0xfffffff3 */
// Embedded class %ws not defined for Property %ws in Class %ws
#define ERROR_WMIMOF_EMBEDDED_CLASS_NOT_FOUND -14         /* 0xfffffff2 */
// Property %ws in class %ws has an incorrect [WmiVersion] qualifier
#define ERROR_WMIMOF_INCONSISTENT_VERSIONING -15          /* 0xfffffff1 */
#define ERROR_WMIMOF_NO_PROPERTY_QUALIFERS -16            /* 0xfffffff0 */
// Class %ws has a badly formed or missing [guid] qualifier
#define ERROR_WMIMOF_BAD_OR_MISSING_GUID -17              /* 0xffffffef */
// Could not find property %ws which is the array size for property %ws in class %ws
#define ERROR_WMIMOF_VL_ARRAY_SIZE_NOT_FOUND -18          /* 0xffffffee */
// A class could not be parsed properly
#define ERROR_WMIMOF_CLASS_NOT_PARSED -19                 /* 0xffffffed */
// Wmi class %ws requires the qualifiers [Dynamic, Provider("WmiProv")]
#define ERROR_WMIMOF_MISSING_HMOM_QUALIFIERS -20          /* 0xffffffec */
// Error accessing binary mof file %s
#define ERROR_WMIMOF_CANT_ACCESS_FILE -21                 /* 0xffffffeb */
// Property InstanceName in class %ws must be type string and not %ws
#define ERROR_WMIMOF_INSTANCENAME_BAD_TYPE -22            /* 0xffffffea */
// Property Active in class %ws must be type bool and not %ws
#define ERROR_WMIMOF_ACTIVE_BAD_TYPE -23                  /* 0xffffffe9 */
// Property %ws in class %ws does not have [WmiDataId()] qualifier
#define ERROR_WMIMOF_NO_WMIDATAID -24                     /* 0xffffffe8 */
// Property InstanceName in class %ws must have [key] qualifier
#define ERROR_WMIMOF_INSTANCENAME_NOT_KEY -25             /* 0xffffffe7 */
// Class %ws does not have an InstanceName qualifier
#define ERROR_WMIMOF_NO_INSTANCENAME -26                  /* 0xffffffe6 */
// Class %ws does not have an Active qualifier
#define ERROR_WMIMOF_NO_ACTIVE -27                        /* 0xffffffe5 */
// Property %ws in class %ws is an array, but doesn't specify a dimension
#define ERROR_WMIMOF_MUST_DIM_ARRAY -28                   /* 0xffffffe4 */
// The element count property %ws for the variable length array %ws in class %ws is not an integral type
#define ERROR_WMIMOF_BAD_VL_ARRAY_SIZE_TYPE -29           /* 0xdddddde4 */
// Property %ws in class %ws is both a fixed and variable length array
#define ERROR_WMIMOF_BOTH_FIXED_AND_VARIABLE_ARRAY -30    /* 0xffffffe3 */
// Embedded class %ws should not have InstaneName or Active properties
#define ERROR_WMIMOF_EMBEDDED_CLASS -31                   /* 0xffffffe2 */
#define ERROR_WMIMOF_IMPLEMENTED_REQUIRED -32             /* 0xffffffe1 */
//    TEXT("WmiMethodId for method %ws in class %ws must be unique")
#define ERROR_WMIMOF_DUPLICATE_METHODID -33             /* 0xffffffe0 */
//    TEXT("WmiMethodId for method %ws in class %ws must be specified")
#define ERROR_WMIMOF_MISSING_METHODID -34             /* 0xffffffdf */
//    TEXT("WmiMethodId for method %ws in class %ws must not be 0")
#define ERROR_WMIMOF_METHODID_ZERO -35             /* 0xffffffde */
//    TEXT("Class %ws is derived from WmiEvent and may not be [abstract]")
#define ERROR_WMIMOF_WMIEVENT_ABSTRACT -36             /* 0xffffffdd */
//    TEXT("The element count property for the variable length array
//    %ws in class %ws is not a property of the class"),
#define ERROR_WMIMOF_VL_ARRAY_NOT_FOUND -37           /* 0xffffffdc */
//    TEXT("An error occured resolving the variable length array
//    property %ws in class %ws to element count property")
#define ERROR_WMIMOF_VL_ARRAY_NOT_RESOLVED -38       /* 0xffffffdb */
//    TEXT("Method %ws in class %ws must return void\n")
#define ERROR_WMIMOF_METHOD_RETURN_NOT_VOID -39     /* 0xffffffda */

#define ERROR_WMIMOF_COUNT 39

// This file is not a valid binary mof file
// ERROR_WMI_INVALID_MOF

// There was not enough memory to complete an operation
// ERROR_NOT_ENOUGH_MEMORY

//
// Function prototypes for private functions

//
// sharemem.c
ULONG WmipEstablishSharedMemory(
    PBDATASOURCE DataSource,
    LPCTSTR SectionName,
    ULONG SectionSize
    );

//
// validate.c
BOOLEAN WmipValidateCountedString(
    WCHAR *String
    );

BOOLEAN WmipValidateGuid(
    LPGUID Guid
    );

BOOLEAN WmipProbeForRead(
    PUCHAR Buffer,
    ULONG BufferSize
    );

//
// alloc.c

extern LIST_ENTRY GEHead;
extern PLIST_ENTRY GEHeadPtr;
extern CHUNKINFO GEChunkInfo;

extern LIST_ENTRY NEHead;
extern PLIST_ENTRY NEHeadPtr;
extern CHUNKINFO NEChunkInfo;

extern LIST_ENTRY DSHead;
extern PLIST_ENTRY DSHeadPtr;
extern CHUNKINFO DSChunkInfo;

extern LIST_ENTRY DCHead;
extern PLIST_ENTRY DCHeadPtr;
extern CHUNKINFO DCChunkInfo;

extern LIST_ENTRY MRHead;
extern PLIST_ENTRY MRHeadPtr;
extern CHUNKINFO MRChunkInfo;

extern CHUNKINFO ISChunkInfo;

extern LIST_ENTRY GMHead;
extern PLIST_ENTRY GMHeadPtr;

#ifdef WMI_USER_MODE
extern LIST_ENTRY MCHead;
extern PLIST_ENTRY MCHeadPtr;
extern CHUNKINFO MCChunkInfo;
#endif

#ifdef TRACK_REFERNECES
#define WmipUnreferenceDS(DataSource) \
{ \
    WmipDebugPrint(("WMI: Unref DS %x at %s %d\n", DataSource, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&DSChunkInfo, (PENTRYHEADER)DataSource); \
}

#define WmipReferenceDS(DataSource) \
{ \
    WmipDebugPrint(("WMI: Ref DS %x at %s %d\n", DataSource, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)DataSource); \
}

#define WmipUnreferenceGE(GuidEntry) \
{ \
    WmipDebugPrint(("WMI: Unref GE %x at %s %d\n", GuidEntry, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&GEChunkInfo, (PENTRYHEADER)GuidEntry); \
}

#define WmipReferenceGE(GuidEntry) \
{ \
    WmipDebugPrint(("WMI: Ref GE %x at %s %d\n", GuidEntry, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)GuidEntry); \
}

#define WmipUnreferenceIS(InstanceSet) \
{ \
    WmipDebugPrint(("WMI: Unref IS %x at %s %d\n", InstanceSet, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&ISChunkInfo, (PENTRYHEADER)InstanceSet); \
}

#define WmipReferenceIS(InstanceSet) \
{ \
    WmipDebugPrint(("WMI: Ref IS %x at %s %d\n", InstanceSet, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)InstanceSet); \
}

#define WmipUnreferenceDC(DataConsumer) \
{ \
    WmipDebugPrint(("WMI: Unref DC %x at %s %d\n", DataConsumer, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&DCChunkInfo, (PENTRYHEADER)DataConsumer); \
}

#define WmipReferenceDC(DataConsumer) \
{ \
    WmipDebugPrint(("WMI: Ref DC %x at %s %d\n", DataConsumer, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)DataConsumer); \
}

#define WmipUnreferenceNE(NotificationEntry) \
{ \
    WmipDebugPrint(("WMI: Unref NE %x at %s %d\n", NotificationEntry, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&NEChunkInfo, (PENTRYHEADER)NotificationEntry); \
}

#define WmipReferenceNE(NotificationEntry) \
{ \
    WmipDebugPrint(("WMI: Ref NE %x at %s %d\n", NotificationEntry, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)NotificationEntry); \
}

#define WmipUnreferenceMR(MofResource) \
{ \
    WmipDebugPrint(("WMI: Unref MR %x at %s %d\n", MofResource, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&MRChunkInfo, (PENTRYHEADER)MofResource); \
}

#define WmipReferenceMR(MofResource) \
{ \
    WmipDebugPrint(("WMI: Ref MR %x at %s %d\n", MofResource, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)MofResource); \
}

#ifdef WMI_USER_MODE
#define WmipUnreferenceMC(MofClass) \
{ \
    WmipDebugPrint(("WMI: Unref MC %x at %s %d\n", MofClass, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&MCChunkInfo, (PENTRYHEADER)MofClass); \
}

#define WmipReferenceMC(MofClass) \
{ \
    WmipDebugPrint(("WMI: Ref MC %x at %s %d\n", MofClass, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)MofClass); \
}
#endif
#else
#define WmipUnreferenceDS(DataSource) \
    WmipUnreferenceEntry(&DSChunkInfo, (PENTRYHEADER)DataSource)

#define WmipReferenceDS(DataSource) \
    WmipReferenceEntry((PENTRYHEADER)DataSource)

#define WmipUnreferenceGE(GuidEntry) \
    WmipUnreferenceEntry(&GEChunkInfo, (PENTRYHEADER)GuidEntry)

#define WmipReferenceGE(GuidEntry) \
    WmipReferenceEntry((PENTRYHEADER)GuidEntry)

#define WmipUnreferenceIS(InstanceSet) \
    WmipUnreferenceEntry(&ISChunkInfo, (PENTRYHEADER)InstanceSet)

#define WmipReferenceIS(InstanceSet) \
    WmipReferenceEntry((PENTRYHEADER)InstanceSet)

#define WmipUnreferenceDC(DataConsumer) \
    WmipUnreferenceEntry(&DCChunkInfo, (PENTRYHEADER)DataConsumer)

#define WmipReferenceDC(DataConsumer) \
    WmipReferenceEntry((PENTRYHEADER)DataConsumer)

#define WmipUnreferenceNE(NotificationEntry) \
    WmipUnreferenceEntry(&NEChunkInfo, (PENTRYHEADER)NotificationEntry)

#define WmipReferenceNE(NotificationEntry) \
    WmipReferenceEntry((PENTRYHEADER)NotificationEntry)

#define WmipUnreferenceMR(MofResource) \
    WmipUnreferenceEntry(&MRChunkInfo, (PENTRYHEADER)MofResource)

#define WmipReferenceMR(MofResource) \
    WmipReferenceEntry((PENTRYHEADER)MofResource)

#ifdef WMI_USER_MODE
#define WmipUnreferenceMC(MofClass) \
    WmipUnreferenceEntry(&MCChunkInfo, (PENTRYHEADER)MofClass)

#define WmipReferenceMC(MofClass) \
    WmipReferenceEntry((PENTRYHEADER)MofClass)
#endif
#endif

PBDATASOURCE WmipAllocDataSource(
    void
    );

PBGUIDENTRY WmipAllocGuidEntry(
    void
    );

#define WmipAllocInstanceSet() ((PBINSTANCESET)WmipAllocEntry(&ISChunkInfo))
#define WmipAllocDataConsumer() ((PDCENTRY)WmipAllocEntry(&DCChunkInfo))

#define WmipAllocNotificationEntry() ((PNOTIFICATIONENTRY)WmipAllocEntry(&NEChunkInfo))

#define WmipAllocMofResource() ((PMOFRESOURCE)WmipAllocEntry(&MRChunkInfo))

#ifdef WMI_USER_MODE
#define WmipAllocMofClass() ((PMOFCLASS)WmipAllocEntry(&MCChunkInfo))
#endif

#define WmipAllocString(Size) \
    WmipAlloc((Size)*sizeof(WCHAR))

#define WmipFreeString(Ptr) \
    WmipFree(Ptr)

#ifdef MEMPHIS
#define WmipAlloc(Size) \
    malloc(Size)

#define WmipFree(Ptr) \
    free(Ptr)
	
#define WmipInitProcessHeap()
#else

//
// Reserve 1MB for WMI.DLL, but only commit 16K initially
#define DLLRESERVEDHEAPSIZE 1024 * 1024
#define DLLCOMMITHEAPSIZE     0 * 1024

//
// Reserve 1MB for WMI service, but only commit 16K initially
#define CORERESERVEDHEAPSIZE 1024 * 1024
#define CORECOMMITHEAPSIZE     16 * 1024


extern PVOID WmipProcessHeap;

#define WmipInitProcessHeap() \
{ \
    if (WmipProcessHeap == NULL) \
    { \
        WmipCreateHeap(); \
    } \
}


#ifdef HEAPVALIDATION
PVOID WmipAlloc(
    ULONG Size
    );

void WmipFree(
    PVOID p
    );

#else
#if DBG
_inline PVOID WmipAlloc(ULONG Size)
{
    WmipAssert(WmipProcessHeap != NULL);
    return(RtlAllocateHeap(WmipProcessHeap, 0, Size));
}

_inline void WmipFree(PVOID Ptr)
{
    RtlFreeHeap(WmipProcessHeap, 0, Ptr);
}

#else
#define WmipAlloc(Size) \
    RtlAllocateHeap(WmipProcessHeap, 0, Size)

#define WmipFree(Ptr) \
    RtlFreeHeap(WmipProcessHeap, 0, Ptr)
#endif
#endif
#endif

BOOLEAN WmipRealloc(
    PVOID *Buffer,
    ULONG CurrentSize,
    ULONG NewSize,
    BOOLEAN FreeOriginalBuffer
    );


//
// datastr.c
extern GUID WmipBinaryMofGuid;

void WmipGenerateBinaryMofNotification(
    PBINSTANCESET BianryMofInstanceSet,
    LPCGUID Guid	
    );

BOOLEAN WmipEstablishInstanceSetRef(
    PBDATASOURCE DataSourceRef,
    LPGUID Guid,
    PBINSTANCESET InstanceSet
    );

ULONG WmipAddDataSource(
    PTCHAR QueryBinding,
    ULONG RequestAddress,
    ULONG RequestContext,
    LPCTSTR ImagePath,
    PWMIREGINFOW RegistrationInfo,
    ULONG RegistrationInfoSize,
    ULONG_PTR *ProviderId,
    BOOLEAN IsAnsi
    );

ULONG WmipUpdateAddGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PWMIREGINFO RegistrationInfo,
    PBINSTANCESET *AddModInstanceSet
    );

ULONG WmipUpdateModifyGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PWMIREGINFO RegistrationInfo,
    PBINSTANCESET *AddModInstanceSet
    );

BOOLEAN  WmipUpdateRemoveGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PBINSTANCESET *AddModInstanceSet
    );

void WmipUpdateDataSource(
    ULONG_PTR ProviderId,
    PWMIREGINFOW RegistrationInfo,
    ULONG RetSize
    );

void WmipRemoveDataSource(
    ULONG_PTR ProviderId
    );

void WmipRemoveDataSourceByDS(
    PBDATASOURCE DataSource
    );

ULONG WmipRegisterInternalDataSource(
    void
    );

PBGUIDENTRY WmipFindGEByGuid(
    LPGUID Guid,
    BOOLEAN MakeTopOfList
    );

PBINSTANCESET WmipFindISInDSByGuid(
    PBDATASOURCE DataSource,
    LPGUID Guid
    );

PNOTIFICATIONENTRY WmipFindNEByGuid(
    GUID UNALIGNED *Guid,
    BOOLEAN MakeTopOfList
    );

PDCREF WmipFindExistingAndFreeDCRefInNE(
    PNOTIFICATIONENTRY NotificationEntry,
    PDCENTRY DataConsumer,
    PDCREF *FreeDcRef
    );

PDCREF WmipFindDCRefInNE(
    PNOTIFICATIONENTRY NotificationEntry,
    PDCENTRY DataConsumer
    );

PBDATASOURCE WmipFindDSByProviderId(
    ULONG_PTR ProviderId
    );

PBINSTANCESET WmipFindISByGuid(
    PBDATASOURCE DataSource,
    GUID UNALIGNED *Guid
    );

PMOFRESOURCE WmipFindMRByNames(
    LPCWSTR ImagePath,
    LPCWSTR MofResourceName
    );

#ifdef WMI_USER_MODE
PMOFCLASS WmipFindMCByGuid(
    LPGUID Guid
    );

PMOFCLASS WmipFindMCByGuidAndBestLanguage(
    LPGUID Guid,
    WORD Language
    );

PMOFCLASS WmipFindMCByGuidAndLanguage(
    LPGUID Guid,
    WORD Language
    );
#endif

PBINSTANCESET WmipFindISinGEbyName(
    PBGUIDENTRY GuidEntry,
    PWCHAR InstanceName,
    PULONG InstanceIndex
    );

PWNODE_HEADER WmipGenerateRegistrationNotification(
    PBDATASOURCE DataSource,
    PWNODE_HEADER Wnode,
    ULONG GuidMax,
    ULONG NotificationCode
    );

BOOLEAN
WmipIsControlGuid(
    PBGUIDENTRY GuidEntry
    );

void WmipGenerateMofResourceNotification(
    LPWSTR ImagePath,
    LPWSTR ResourceName,
    LPCGUID Guid
    );

//
// wbem.c
ULONG WmipBuildMofClassInfo(
    PBDATASOURCE DataSource,
    LPWSTR ImagePath,
    LPWSTR MofResourceName,
    PBOOLEAN NewMofResource
    );

ULONG WmipReadBuiltinMof(
    void
    );


//
// from krnlmode.c
ULONG WmipInitializeKM(
    HANDLE *WmiKMHandle
    );

void WmipKMNonEventNotification(
    HANDLE WmiKMHandle,
    PWNODE_HEADER Wnode
    );

//
// main.c

extern HANDLE WmipRestrictedToken;

void WmipGetRegistryValue(
    TCHAR *ValueName,
    PULONG Value
    );

ULONG WmiRunService(
    ULONG Context
#ifdef MEMPHIS
    , HINSTANCE InstanceHandle
#endif
    );

ULONG WmipInitializeAccess(
    PTCHAR *RpcStringBinding
    );

void WmiTerminateService(
    void
    );

ULONG WmiInitializeService(
    void
);

void WmiDeinitializeService(
    void
);

void WmipEventNotification(
    PWNODE_HEADER Wnode,
    BOOLEAN SingleEvent,
    ULONG EventSizeGuess
    );

#define WmipBuildRegistrationNotification(Wnode, WnodeSize, NotificationCode, GuidCount) { \
    memset(Wnode, 0, sizeof(WNODE_HEADER)); \
    memcpy(&Wnode->Guid, &RegChangeNotificationGuid, sizeof(GUID)); \
    Wnode->BufferSize = WnodeSize; \
    Wnode->Linkage = NotificationCode; \
    Wnode->Version = GuidCount; \
    Wnode->Flags = WNODE_FLAG_INTERNAL; \
}

void WmipSendQueuedEvents(
    void
    );

ULONG WmipCleanupDataConsumer(
    PDCENTRY DataConsumer
#if DBG
    ,BOOLEAN *NotificationsEnabled,
    BOOLEAN *CollectionsEnabled
#endif
    );
//
// This defines the maximum number of replacement strings over all of the
// event messages.
#define MAX_MESSAGE_STRINGS 2
void __cdecl WmipReportEventLog(
    ULONG MessageCode,
    WORD MessageType,
    WORD MessageCategory,
    DWORD RawDataSize,
    PVOID RawData,
    WORD StringCount,
    ...
    );

#ifdef MEMPHIS
long WINAPI
DeviceNotificationWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam);

void WmipDestroyDeviceNotificationWindow(
    HINSTANCE InstanceHandle,
    HWND WindowHandle
    );

ULONG WmipCreateDeviceNotificationWindow(
    HINSTANCE InstanceHandle,
    HWND *DeviceNotificationWindow
    );

#endif


//
// server.c
void WmipRpcServerDeinitialize(
    void
    );

ULONG WmipRpcServerInitialize(
    void
    );

ULONG WmipDeliverWnodeToDS(
    ULONG ActionCode,
    PBDATASOURCE DataSource,
    PWNODE_HEADER Wnode
);

ULONG WmipDoDisableRequest(
    PNOTIFICATIONENTRY NotificationEntry,
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext,
    ULONG InProgressFlag
    );

ULONG CollectOrEventWorker(
    PDCENTRY DataConsumer,
    LPGUID Guid,
    BOOLEAN Enable,
    BOOLEAN IsEvent,
    ULONG *NotificationCookie,
    ULONG64 LoggerContext,
    ULONG NotificationFlags
    );

ULONG WmipCreateRestrictedToken(
    HANDLE *RestrictedToken
    );

void WmipShowPrivs(
    HANDLE TokenHandle
    );

#ifdef MEMPHIS
#define WmipRestrictToken(Token) (ERROR_SUCCESS)
#define WmipUnrestrictToken() (ERROR_SUCCESS)
#else
ULONG WmipRestrictToken(
    HANDLE RestrictedToken
    );

ULONG WmipUnrestrictToken(
    void
    );

ULONG WmipServiceDisableTraceProviders(
    PWNODE_HEADER Wnode
    );

#endif

void WmipReleaseCollectionEnabled(
    PNOTIFICATIONENTRY NotificationEntry
    );

//
// chunk.c
ULONG UnicodeToAnsi(
    LPCWSTR pszW,
    LPSTR * ppszA,
    ULONG *AnsiSizeInBytes OPTIONAL
    );

ULONG AnsiToUnicode(
    LPCSTR pszA,
    LPWSTR * ppszW
    );

ULONG AnsiSizeForUnicodeString(
    PWCHAR UnicodeString,
    ULONG *AnsiSizeInBytes
    );

ULONG UnicodeSizeForAnsiString(
    LPCSTR AnsiString,
    ULONG *UnicodeSizeInBytes
    );

//
// debug.c
#if DBG
void WmipDumpIS(
    PBINSTANCESET IS,
    BOOLEAN RecurseGE,
    BOOLEAN RecurseDS
    );

void WmipDumpGE(
    PBGUIDENTRY GE,
    BOOLEAN RecurseIS
    );

void WmipDumpDS(
    PBDATASOURCE DS,
    BOOLEAN RecurseIS
    );

void WmipDumpAllDS(
    void
    );

#endif

#ifndef MEMPHIS

typedef enum
{
    TRACELOG_START        = 0,
    TRACELOG_STOP         = 1,
    TRACELOG_QUERY        = 2,
    TRACELOG_QUERYALL     = 3,
    TRACELOG_QUERYENABLED = 4,
    TRACELOG_UPDATE       = 5,
    TRACELOG_FLUSH        = 6
} TRACEREQUESTCODE;

typedef struct _WMI_REF_CLOCK {
    LARGE_INTEGER   StartTime;
    LARGE_INTEGER   StartPerfClock;
} WMI_REF_CLOCK, *PWMI_REF_CLOCK;

//
// logsup.c

ULONG
WmiUnregisterGuids(
    IN WMIHANDLE WMIHandle,
    IN LPGUID    Guid,
    OUT ULONG64  *LoggerContext
);

void
WmipGenericTraceEnable(
    IN ULONG RequestCode,
    IN PVOID Buffer,
    IN OUT PVOID *RequestAddress
    );

ULONG
WmipAddLogHeaderToLogFile(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN PWMI_REF_CLOCK RefClock,
    IN ULONG Update
    );

ULONG
WmipStartLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
WmipStopLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
WmipQueryLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN ULONG Update
    );
ULONG
WmipFlushLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

VOID
WmipInitString(
    IN PVOID Destination,
    IN PVOID Buffer,
    IN ULONG Size
    );

ULONG
WmipGetTraceRegKeys(
    );

ULONG
WmipFinalizeLogFileHeader(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
WmipRelogHeaderToLogFile( 
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo ,
    IN PSYSTEM_TRACE_HEADER RelogProp
    );

//
// umlog.c
BOOLEAN
FASTCALL
WmipIsPrivateLoggerOn();

ULONG
WmipFlushUmLoggerBuffer();

ULONG
WmipSendUmLogRequest(
    IN WMITRACECODE RequestCode,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
FASTCALL
WmiTraceUmEvent(
    IN PWNODE_HEADER Wnode
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\ntdll\dpapi.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    dpapi.c

Abstract:
    
    WMI data provider api set

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include <nt.h>
#include "wmiump.h"
#include "trcapi.h"


ULONG WmipCountedAnsiToCountedUnicode(
    PCHAR Ansi, 
    PWCHAR Unicode
    )
/*++

Routine Description:

    Translate a counted ansi string into a counted unicode string.
    Conversion may be done inplace, that is Ansi == Unicode.

Arguments:

    Ansi is the counted ansi string to convert to UNICODE
        
    Unicode is the buffer to place the converted string into

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    PCHAR APtr;
    PWCHAR WPtr;
    ULONG AnsiSize, UnicodeSize;
    ULONG Status;
    
    AnsiSize = *((PUSHORT)Ansi);
    APtr = WmipAlloc(AnsiSize + 1);
    if (APtr != NULL)
    {
        memcpy(APtr, Ansi + sizeof(USHORT), AnsiSize);
        APtr[AnsiSize] = 0;
        
        WPtr = NULL;                
        Status = WmipAnsiToUnicode(APtr, &WPtr);
        if (Status == ERROR_SUCCESS)
        {
            UnicodeSize = (wcslen(WPtr)+1) * sizeof(WCHAR);
            *Unicode = (USHORT)UnicodeSize; 
            memcpy(Unicode+1, WPtr, UnicodeSize);
            Status = ERROR_SUCCESS;
            WmipFree(WPtr);
        } 
        WmipFree(APtr);        
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(Status);
}


ULONG WmipCountedUnicodeToCountedAnsi(
    PWCHAR Unicode,
    PCHAR Ansi
    )
/*++

Routine Description:

    Translate a counted ansi string into a counted unicode string.
    Conversion may be done inplace, that is Ansi == Unicode.

Arguments:

    Unicode is the counted unicode string to convert to ansi

    Ansi is the buffer to place the converted string into
        
Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    PCHAR APtr;
    PWCHAR WPtr;
    ULONG AnsiSize, UnicodeSize;
    ULONG Status;
    
    UnicodeSize = *Unicode;
    WPtr = WmipAlloc(UnicodeSize + sizeof(WCHAR));
    if (WPtr != NULL)
    {
        memcpy(WPtr, Unicode + 1, UnicodeSize);
        WPtr[UnicodeSize/sizeof(WCHAR)] = UNICODE_NULL;

        APtr = NULL;
        Status = WmipUnicodeToAnsi(WPtr, &APtr, &AnsiSize);
        if (Status == ERROR_SUCCESS)
        {
            *((PUSHORT)Ansi) = (USHORT)AnsiSize; 
            memcpy(Ansi+sizeof(USHORT), APtr, AnsiSize);
            Status = ERROR_SUCCESS;
            WmipFree(APtr);
        } 
        WmipFree(WPtr);        
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(Status);
}

ULONG WmipCopyStringToCountedUnicode(
    LPCWSTR String,
    PWCHAR CountedString,
    ULONG *BytesUsed,
    BOOLEAN ConvertFromAnsi        
    )
/*++

Routine Description:

    This routine will copy an ansi ro unicode C string to a counted unicode
    string.
        
Arguments:

    String is the ansi or unicode incoming string
        
    Counted string is a pointer to where to write counted unicode string
        
    *BytesUsed returns number of bytes used to build counted unicode string
        
    ConvertFromAnsi is TRUE if String is an ANSI string 

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    USHORT StringSize;
    PWCHAR StringPtr = CountedString+1;
    ULONG Status;
    
    if (ConvertFromAnsi)
    {
        StringSize = (strlen((PCHAR)String) +1) * sizeof(WCHAR);
        Status = WmipAnsiToUnicode((PCHAR)String,
                               &StringPtr);
    } else {
        StringSize = (wcslen(String) +1) * sizeof(WCHAR);
        wcscpy(StringPtr, String);
        Status = ERROR_SUCCESS;
    }
    
    *CountedString = StringSize;
     *BytesUsed = StringSize + sizeof(USHORT);                

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\ntdll\guidapi.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    wmiguidapi.c

Abstract:

   Data structures and functions that generate GUID. 


--*/



#include <ntos.h>

#define MAX_CACHED_UUID_TIME 10000  // 10 seconds
#define WMI_UUID_TIME_HIGH_MASK    0x0FFF
#define WMI_UUID_VERSION           0x1000
typedef long WMI_STATUS;
#define WMI_ENTRY __stdcall
#define WMI_S_OUT_OF_MEMORY               14
#define WMI_S_OK                          0
#define WMI_S_UUID_LOCAL_ONLY            1824L
//#define RPC_RAND_UUID_VERSION      0x4000
#define WMI_UUID_RESERVED          0x80
#define WMI_UUID_CLOCK_SEQ_HI_MASK 0x3F

extern WmipSleep(unsigned long dwMilliseconds);

typedef struct _WMI_UUID_GENERATE
{
    unsigned long  TimeLow;
    unsigned short TimeMid;
    unsigned short TimeHiAndVersion;
    unsigned char  ClockSeqHiAndReserved;
    unsigned char  ClockSeqLow;
    unsigned char  NodeId[6];
} WMI_UUID_GENERATE;

typedef struct _UUID_CACHED_VALUES_STRUCT
{

    ULARGE_INTEGER      Time;  // Time of last uuid allocation
    long                AllocatedCount; // Number of UUIDs allocated
    unsigned char       ClockSeqHiAndReserved;
    unsigned char       ClockSeqLow;

    unsigned char       NodeId[6];
} UUID_CACHED_VALUES_STRUCT;


UUID_CACHED_VALUES_STRUCT  UuidCachedValues;

WMI_STATUS 
WmipUuidGetValues(
    OUT UUID_CACHED_VALUES_STRUCT *Values
    )
/*++

Routine Description:

    This routine allocates a block of uuids for UuidCreate to handout.

Arguments:

    Values - Set to contain everything needed to allocate a block of uuids.
             The following fields will be updated here:

    NextTimeLow -   Together with LastTimeLow, this denotes the boundaries
                    of a block of Uuids. The values between NextTimeLow
                    and LastTimeLow are used in a sequence of Uuids returned
                    by UuidCreate().

    LastTimeLow -   See NextTimeLow.

    ClockSequence - Clock sequence field in the uuid.  This is changed
                    when the clock is set backward.

Return Value:

    WMI_S_OK - We successfully allocated a block of uuids.

    WMI_S_OUT_OF_MEMORY - As needed.
--*/
{
    NTSTATUS NtStatus;
    ULARGE_INTEGER Time;
    ULONG Range;
    ULONG Sequence;
    int Tries = 0;

    do {
        NtStatus = NtAllocateUuids(&Time, &Range, &Sequence, (char *) &Values->NodeId[0]);

        if (NtStatus == STATUS_RETRY)
            {
            WmipSleep(1);
            }

        Tries++;

        if (Tries == 20)
            {
#ifdef DEBUGRPC
            PrintToDebugger("Rpc: NtAllocateUuids retried 20 times!\n");
            ASSERT(Tries < 20);
#endif
            NtStatus = STATUS_UNSUCCESSFUL;
            }

        } while(NtStatus == STATUS_RETRY);

    if (!NT_SUCCESS(NtStatus))
        {
        return(WMI_S_OUT_OF_MEMORY);
        }

    // NtAllocateUuids keeps time in SYSTEM_TIME format which is 100ns ticks since
    // Jan 1, 1601.  UUIDs use time in 100ns ticks since Oct 15, 1582.

    // 17 Days in Oct + 30 (Nov) + 31 (Dec) + 18 years and 5 leap days.

    Time.QuadPart +=   (unsigned __int64) (1000*1000*10)       // seconds
                     * (unsigned __int64) (60 * 60 * 24)       // days
                     * (unsigned __int64) (17+30+31+365*18+5); // # of days

    ASSERT(Range);

    Values->ClockSeqHiAndReserved =
        WMI_UUID_RESERVED | (((unsigned char) (Sequence >> 8))
        & (unsigned char) WMI_UUID_CLOCK_SEQ_HI_MASK);

    Values->ClockSeqLow = (unsigned char) (Sequence & 0x00FF);

    // The order of these assignments is important

    Values->Time.QuadPart = Time.QuadPart + (Range - 1);
    Values->AllocatedCount = Range;

    /*if ((Values->NodeId[0] & 0x80) == 0)
        {*/
        return(WMI_S_OK);
        /*}
    
    return (WMI_S_UUID_LOCAL_ONLY);*/
}



WMI_STATUS WMI_ENTRY
WmipUuidCreateSequential (
    OUT UUID * Uuid
    )
/*++

Routine Description:

    This routine will create a new UUID (or GUID) which is unique in
    time and space.  We will try to guarantee that the UUID (or GUID)
    we generate is unique in time and space.  This means that this
    routine may fail if we can not generate one which we can guarantee
    is unique in time and space.

Arguments:

    Uuid - Returns the generated UUID (or GUID).

Return Value:

    WMI_S_OK - The operation completed successfully.

    RPC_S_UUID_NO_ADDRESS - We were unable to obtain the ethernet or
        token ring address for this machine.

    WMI_S_UUID_LOCAL_ONLY - On NT & Chicago if we can't get a
        network address.  This is a warning to the user, the
        UUID is still valid, it just may not be unique on other machines.

    WMI_S_OUT_OF_MEMORY - Returned as needed.
--*/
{
    WMI_UUID_GENERATE * WmiUuid = (WMI_UUID_GENERATE *) Uuid;
    WMI_STATUS Status = WMI_S_OK;
	ULARGE_INTEGER Time;
    long Delta;
    static unsigned long LastTickCount = 0;

    if (NtGetTickCount()-LastTickCount > MAX_CACHED_UUID_TIME)
        {
        UuidCachedValues.AllocatedCount = 0;
        LastTickCount = NtGetTickCount();
        }

    for(;;)
        {
        Time.QuadPart = UuidCachedValues.Time.QuadPart;

        // Copy the static info into the UUID.  We can't do this later
        // because the clock sequence could be updated by another thread.

        *(unsigned long *)&WmiUuid->ClockSeqHiAndReserved =
            *(unsigned long *)&UuidCachedValues.ClockSeqHiAndReserved;
        *(unsigned long *)&WmiUuid->NodeId[2] =
            *(unsigned long *)&UuidCachedValues.NodeId[2];

        Delta = InterlockedDecrement(&UuidCachedValues.AllocatedCount);

        if (Time.QuadPart != UuidCachedValues.Time.QuadPart)
            {
            // If our captured time doesn't match the cache then another
            // thread already took the lock and updated the cache. We'll
            // just loop and try again.
            continue;
            }

        if (Delta >= 0)
            {
            break;
            }

        //
        // Allocate block of Uuids.
        //

        Status = WmipUuidGetValues( &UuidCachedValues );
     /*   if (Status == WMI_S_OK)
            {
            UuidCacheValid = CACHE_VALID;
            }
        else
            {
            UuidCacheValid = CACHE_LOCAL_ONLY;
            }*/

        if (Status != WMI_S_OK)
            {
#ifdef DEBUGRPC
            if (Status != WMI_S_OUT_OF_MEMORY)
                PrintToDebugger("RPC: UuidGetValues returned or raised: %x\n", Status);
#endif
            ASSERT( (Status == WMI_S_OUT_OF_MEMORY) );


            return Status;
            }

        // Loop
        }


    Time.QuadPart -= Delta;

    WmiUuid->TimeLow = (unsigned long) Time.LowPart;
    WmiUuid->TimeMid = (unsigned short) (Time.HighPart & 0x0000FFFF);
    WmiUuid->TimeHiAndVersion = (unsigned short)
        (( (unsigned short)(Time.HighPart >> 16)
        & WMI_UUID_TIME_HIGH_MASK ) | WMI_UUID_VERSION);

   // ASSERT(   Status == WMI_S_OK
   //        || Status == WMI_S_UUID_LOCAL_ONLY);

 /*   if (UuidCacheValid == CACHE_LOCAL_ONLY)
        {
        return WMI_S_UUID_LOCAL_ONLY;
        }*/

    return(Status);
}


NTSTATUS
WmipUuidCreate(
    OUT UUID *Uuid
    )
{

	return (NTSTATUS)WmipUuidCreateSequential (Uuid );
	
}



ULONG WmipUnicodeToAnsi(
    LPCWSTR pszW,
    LPSTR * ppszA,
    ULONG *AnsiSizeInBytes OPTIONAL
    ){

	ANSI_STRING DestinationString;
	UNICODE_STRING SourceString;
	NTSTATUS Status;

	RtlInitAnsiString(&DestinationString,(PCHAR)ppszA);
	RtlInitUnicodeString(&SourceString,(PWSTR)pszW);
	
	Status = RtlUnicodeStringToAnsiString( &DestinationString, &SourceString, (ppszA == NULL) );

	if(ppszA != NULL ){

		memcpy(ppszA,DestinationString.Buffer,DestinationString.Length);
	}
	
	if (AnsiSizeInBytes != NULL){

        *AnsiSizeInBytes = DestinationString.Length;
    }

	return Status;
}

ULONG WmipAnsiToUnicode(
    LPCSTR pszA,
    LPWSTR * ppszW
    ){

	UNICODE_STRING DestinationString;
	ANSI_STRING SourceString;
	NTSTATUS Status;

	RtlInitUnicodeString(&DestinationString,(PWSTR)ppszW);
	RtlInitAnsiString(&SourceString,(PCHAR)pszA);
	
	Status = RtlAnsiStringToUnicodeString( &DestinationString, &SourceString, (ppszW == NULL) );

	if(ppszW != NULL ){

		memcpy(ppszW,DestinationString.Buffer,DestinationString.Length);
	}
    
	return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\mofread\test.c ===
//***************************************************************************
//
//  (c) 1997 by Microsoft Corporation
//
//  test.c
//
//  a-davj  14-April-97   Created.
//
//  Demonstration program for dumping out Binary Managed Object Format (BMOF) 
//  data.
//
//***************************************************************************

#include <windows.h>                                     
#include <ole2.h>
#include <oleauto.h>
#include <stdio.h>
#include <io.h> 
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <stdlib.h>

#include "bmof.h"
#include "mrcicode.h"

void DisplayObject(CBMOFObj * po);

//***************************************************************************
//
//  void * BMOFAlloc
//
//  DESCRIPTION:
//
//  Provides allocation service for BMOF.C.  This allows users to choose
//  the allocation method that is used.
//
//  PARAMETERS:
//
//  Size                Input.  Size of allocation in bytes.
//
//  RETURN VALUE:
//
//  pointer to new data.  NULL if allocation failed.
//
//***************************************************************************

void * BMOFAlloc(size_t Size)
{
    return malloc(Size);
}

//***************************************************************************
//
//  void BMOFFree
//
//  DESCRIPTION:
//
//  Provides allocation service for BMOF.C.  This frees what ever was
//  allocated via BMOFAlloc.
//
//  PARAMETERS:
//
//  pointer to memory to be freed.
//
//***************************************************************************

void BMOFFree(void * pFree)
{
   free(pFree);
}

//***************************************************************************
//
//  void DisplayVariant
//
//  DESCRIPTION:
//
//  Displays VARIANT data.  Note that this is only done in this sample for
//  convienence, and using OLE is NOT necessary.
//
//  PARAMETERS:
//
//  pvar                Input.  Pointer to VARIANT which is to be displayed.
//                      It is assumed that the variant type is simple, I.E.
//                      neither the VT_ARRAY or VT_BYREF bits are set.
//
//***************************************************************************

void DisplayVariant(VARIANT * pvar)
{
    SCODE sc;
    VARIANT vTemp;

    // Uninitialized data will have a VT_NULL type.

    if(pvar->vt == VT_NULL)
    {
        printf(" data is NULL");
        return;
    }

     // String types can just be dumped.

     if(pvar->vt == VT_BSTR)
     {
        printf("value is %S",pvar->bstrVal);
         return;
     }
	 else if(pvar->vt == VT_UNKNOWN)
	 {
		CBMOFObj * pObj;
		printf(" got an embedded object");
		pObj = (CBMOFObj *)pvar->bstrVal;
		DisplayObject(pObj);
		return;
	 }

    // For non string data, convert the infomation to a bstr and display it.

    VariantInit(&vTemp);
    sc = VariantChangeTypeEx(&vTemp, pvar,0,0, VT_BSTR);
    if(sc == S_OK)
    {
        printf("value is %S",vTemp.bstrVal);
    }
    else
        printf(" Couldnt convert type 0x%x, error code 0x%x", pvar->vt, sc);
    VariantClear(&vTemp);
}

//***************************************************************************
//
//  void DisplayData
//
//  DESCRIPTION:
//
//  Displays the data held in a data item.  Note that Ole is use just for 
//  ease of use and is optional.
//
//  PARAMETERS:
//
//  pItem               Input.  Item to be displayed.
//
//***************************************************************************

void DisplayData(CBMOFDataItem * pItem)
{
    DWORD dwType, dwSimpleType;
    long lNumDim, lCnt;
    long lFirstDim;
    VARIANT var;

   // Determine the data type and clear out the variant

	dwType = pItem->m_dwType;
	printf("\nData type is 0x%x ", dwType);
    dwSimpleType = dwType & ~VT_ARRAY & ~VT_BYREF;
    memset((void *)&var.lVal, 0, 8);

    lNumDim = GetNumDimensions(pItem);
  
    if(lNumDim == 0)    
    {
      // handle the simple scalar case.  Note that uninitialized properties
      // will not have data.

        if(GetData(pItem, (BYTE *)&(var.lVal), NULL))
        {
            var.vt = (VARTYPE)dwSimpleType;
            DisplayVariant(&var);

            // Note the GetData does not use OLE to allocate BSTRs
            // and so we need to use our own freeing routine here.

            if(var.vt == VT_BSTR)
               BMOFFree(var.bstrVal);
        }
        else
            printf(" NULL ");
    }
    else if(lNumDim == 1)
    {
        // For the array case, just loop getting each element.
        // Start by getting the number of elements

        lFirstDim = GetNumElements(pItem, 0);
        if(lFirstDim < 1)
        {
            printf("\n CANT DISPLAY, BOGUS DIMENSION");
            return;
        }
		printf("\n");
        for(lCnt = 0; lCnt < lFirstDim; lCnt++)
        {
            if(GetData(pItem, (BYTE *)&(var.lVal), &lCnt))
            {
                var.vt = (VARTYPE)dwSimpleType;
                DisplayVariant(&var);

               // Note the GetData does not use OLE to allocate BSTRs
               // and so we need to use our own freeing routine here.

               if(var.vt == VT_BSTR)
                  BMOFFree(var.bstrVal);
               printf("\n");
            }
            else
                printf(" NULL ");
        }
    }
	else if(lNumDim == -1)
    {
        printf("\n Undefined array");
        return;
	}
    else
    {
        // Currently multidimension arrays are not supported.

        printf("\n CANT DISPLAY, TOO MANY DIMEMSIONS");
        return;
    }


    return;
}

//***************************************************************************
//
//  void DisplayQualList
//
//  DESCRIPTION:
//
//  Helper routine for displaying a qualifier list.
//
//  PARAMETERS:
//
//  pql                 Input.  Pointer to structure which wraps the 
//                      qualifier list.
//
//***************************************************************************

void DisplayQualList(CBMOFQualList * pql)
{
    WCHAR * pName = NULL;
    CBMOFDataItem Item;
    ResetQualList(pql);
    printf("\nDisplaying qual list");
    

    while(NextQual(pql, &pName, &Item))
    {
        printf("\nQualifier name is -%S- ",pName);
        DisplayData(&Item);
        BMOFFree(pName);
    }
}


//***************************************************************************
//
//  void DisplayObject
//
//  DESCRIPTION:
//
//  Helper routine for displaying a class or instance.
//
//  PARAMETERS:
//
//  po                  Input.  Pointer to structure that wraps the object.
//
//***************************************************************************

void DisplayObject(CBMOFObj * po)
{
    CBMOFQualList * pql;
    CBMOFDataItem Item;
    WCHAR * pName = NULL;
    BOOL bfirstmethod = TRUE;

    // Display the objects name, its type (Is it a class or instance), and
    // display the qualifier set which is attached to the object.

    if(GetName(po, &pName))
    {
        printf("\n\nLooking at object %S",pName);
        BMOFFree(pName);
    }
    printf("\nThe objects type is 0x%x", GetType(po));
    pql = GetQualList(po);
    if(pql)
    {
        DisplayQualList(pql);
        BMOFFree(pql);
        pql = NULL;
    }
    
    // Display each property and it associated qualifier list

    ResetObj(po);
    printf("\nDisplaying prop list");
    
    while(NextProp(po, &pName, &Item))
    {
        printf("\n\nProperty name is -%S- type is 0x%x",pName, Item.m_dwType);
        DisplayData(&Item);
        pql = GetPropQualList(po, pName);
        if(pql)
        {
            DisplayQualList(pql);
            BMOFFree(pql);
            pql = NULL;
        }

        BMOFFree(pName);
    }

    while(NextMeth(po, &pName, &Item))
    {

        if(bfirstmethod)
            printf("\nDisplaying method list");
        bfirstmethod = FALSE;

        printf("\n\nMethod name is -%S- type is 0x%x",pName, Item.m_dwType);
        DisplayData(&Item);
        pql = GetMethQualList(po, pName);
        if(pql)
        {
            DisplayQualList(pql);
            BMOFFree(pql);
            pql = NULL;
        }

        BMOFFree(pName);
    }

}

//***************************************************************************
//
//  BYTE * ReadBMOFFile
//
//  DESCRIPTION:
//
//  Opens and decompresses the binary mof file
//
//  PARAMETERS:
//
//  pFileName           Input.  Pointer to structure that wraps the object.
//
//  RETURN VALUE:
//
//  pointer to the binary mof data.  This should be freed using "free".  Note that
//  NULL is returned for all errors.
//
//***************************************************************************

BYTE * ReadBMOFFile(char * pFileName)
{
    int fh1 = -1;
    int iRet;
    DWORD dwCompType, dwCompressedSize, dwExpandedSize, dwSig, dwResSize;
    BYTE * pCompressed = NULL;
    BYTE * pExpanded = NULL;

    fh1 = _open(pFileName, _O_BINARY | _O_RDONLY);
    if(fh1 == -1)
    {
        printf("\nCould not open the file %s", pFileName);
        return NULL;
    }

    // get the signature, compression type, and the sizes

    iRet = _read(fh1, &dwSig, sizeof(DWORD));
    if((DWORD)iRet != sizeof(DWORD))
    {
        printf("\nError reading file");
        _close(fh1);
        return NULL;
    }

    iRet = _read(fh1, &dwCompType, sizeof(DWORD));
    iRet = _read(fh1, &dwCompressedSize, sizeof(DWORD));
    iRet = _read(fh1, &dwExpandedSize, sizeof(DWORD));

    // make sure the signature is valid and that the compression type is one 
    // we understand!

    if(dwSig != BMOF_SIG ||dwCompType != 1)
    {
        _close(fh1);
        return NULL;
    }

    // Allocate storage for the compressed data and
    // expanded data

    pCompressed = malloc(dwCompressedSize);
    pExpanded = malloc(dwExpandedSize);
    if(pCompressed == NULL || pExpanded == NULL)
    {
        _close(fh1);
        return NULL;
    }

    // Read the compressed data.

    iRet = _read(fh1, pCompressed, dwCompressedSize);
    if((DWORD)iRet != dwCompressedSize)
    {
        printf("\nError reading data");
        free(pExpanded);
        free(pCompressed);
        return NULL;
    }

    _close(fh1);

    // Decompress the data

    dwResSize = Mrci1Decompress(pCompressed, dwCompressedSize, pExpanded, dwExpandedSize);
    free(pCompressed);

    if(dwResSize != dwExpandedSize)
    {
        printf("\nError expanding data!!!");
        free(pExpanded);
        return NULL;
    }
    return pExpanded;
}

//***************************************************************************
//
//  int main
//
//  DESCRIPTION:
//
//  Entry point.
//
//  COMMAND LINE ARGUMENT:
//
//  This program should be launced with a single argument which is the
//  name of the file which contains the BMOF.
//
//  RETURN VALUE:
//
//  0 if OK, 1 if error.
//
//***************************************************************************

int _cdecl main(int argc, char ** argv)
{
    BYTE * pTest;
    CBMOFObjList * pol;
    CBMOFObj * po;

    // check the command line

    if(argc < 2)
    {
        printf("\nusage: test BMOFFILE\nwhere BMOFFILE is the binary mof file to dump");
        return 1;
    }

    pTest = ReadBMOFFile(argv[1]);

    if(pTest == NULL)
    {
       printf("\nterminating abnormally, could not read binary mof");
       return 1;
    }

    // Now use the helper functions to dump out the file.  Create an object
    // list structure and use it to enumerate the objects.

    pol = CreateObjList(pTest);
    if(pol == NULL)
    {
       return 1;
    }
    printf("\nThe number of objects is %d",pol->m_pol->dwNumberOfObjects);

    ResetObjList (pol);
    while(po = NextObj(pol))
    {
        DisplayObject(po);
        BMOFFree(po);
    }

    BMOFFree(pol);

    free(pTest);
    printf("\nTerminating normally\n");
    return 0;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\mofcheck\mofcheck.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    mofcheck.c

Abstract:

    TODO: Enable localization

    Tool to validate that a binary MOF is valid for use with WMI

    Usage:

        wmimofck <binary mof file>


    Rules that are enforced by this program:

    * Any classes that do not have the WMI qualifier are ignored. Any class
      with the qualifier is a WMI class.
    * All WMI classes must have guids, including embedded classes.
    * All WMI classes that do not have special HMOM qualifiers [Dynamic,
      Provider("WMIProv")] are embedded only classes.
    * All non embedded WMI classes must have a property with the [key]
      qualifier named InstanceName, be of type string and NOT have a
      WmiDataId qualifier.
    * Embedded only classes should not have InstanceName or Active properties
    * All other properties in a WMI class must have a WmiDataId qualifier
      that specifies the position of the data item represented by the property
      within the data block represented by the class.
    * The property for the first data item in the data block must have
      WmiDataId(1). WmiDataId(0) is reserved.
    * WmiDataId qualifier values must be contiguous, ie, 1,2,3,4,5... There may
      not be any duplicate or missing WmiDataId values in a class.
    * The order of the properties as specified in the mof does not need to
      follow that of the WmiDataId
    * A property with a greater WmiDataId can not be marked with a WmiVersion
      qualifier whose value is lower than any properties with a lower WmiDataId
    * All embedded classes must be defined in the same mof
    * Only the following types are valid for properties:
        string, sint32, uint32, sint64, uint64, bool, sint16, uint16, char16
        sint8, uint8, datetime
    * Any variable length array must have a WmiSizeIs qualifier that specifies
      the property that holds the number of elements in the array. This
      property must be part of the same class as the variable length array,
      and this property must be an unsigned integer type (uint8, uint16,
      uint32, uint64)
    * Fixed length arrays must have the max qualifier.
    * An array may not be both fixed and variable length
    * Methods must have WmiMethodId qualifier with a unique value
    * Methods must have the Implemented qualifier
    * Methods must have a void return
    * Classes derrived from WmiEvent may not be abstract

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#define WMI_USER_MODE

#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <ctype.h>

#include "wmiump.h"
#include "bmof.h"
#include "mrcicode.h"

#ifdef WmipUnreferenceMC
#undef WmipUnreferenceMC
#endif
#define WmipUnreferenceMC(MofClass)

#ifdef WmipUnreferenceMR
#undef WmipUnreferenceMR
#endif
#define WmipUnreferenceMR(MofClass)

#ifdef WmipAllocMofResource
#undef WmipAllocMofResource
#endif
#define WmipAllocMofResource() WmipAlloc(sizeof(MOFRESOURCE))

#ifdef WmipAllocMofClass
#undef WmipAllocMofClass
#endif
#define WmipAllocMofClass() WmipAlloc(sizeof(MOFCLASS))


BOOL wGUIDFromString(LPCWSTR lpsz, LPGUID pguid);


#if DBG
BOOLEAN WmipLoggingEnabled = FALSE;
#endif

#ifdef MEMPHIS
#if DBG
void __cdecl DebugOut(char *Format, ...)
{
    char Buffer[1024];
    va_list pArg;
    ULONG i;

    va_start(pArg, Format);
    i = _vsnprintf(Buffer, sizeof(Buffer), Format, pArg);
    OutputDebugString(Buffer);
}
#endif
#endif

TCHAR *MessageText[ERROR_WMIMOF_COUNT + 5] =
{
    TEXT("This file is not a valid binary mof file"),
    TEXT("There was not enough memory to complete an operation"),
    TEXT("Binary Mof file %s could not be opened"),

    TEXT("Unknown error code %d\n"),

//
// ERROR_WMIMOF_ messages start here
    TEXT("ERROR_WMIMOF_INCORRECT_DATA_TYPE"),
    TEXT("ERROR_WMIMOF_NO_DATA"),
    TEXT("ERROR_WMIMOF_NOT_FOUND"),
    TEXT("ERROR_WMIMOF_UNUSED"),
    TEXT("Property %ws in class %ws has no embedded class name"),
    TEXT("Property %ws in class %ws has an unknown data type"),
    TEXT("Property %ws in class %ws has no syntax qualifier"),
    TEXT("ERROR_WMIMOF_NO_SYNTAX_QUALIFIER"),
    TEXT("ERROR_WMIMOF_NO_CLASS_NAME"),
    TEXT("ERROR_WMIMOF_BAD_DATA_FORMAT"),
    TEXT("Property %ws in class %ws has the same WmiDataId %d as property %ws"),
    TEXT("Property %ws in class %ws has a WmiDataId of %d which is out of range"),
    TEXT("ERROR_WMIMOF_MISSING_DATAITEM"),
    TEXT("Property for WmiDataId %d is not defined in class %ws"),
    TEXT("Embedded class %ws not defined for Property %ws in Class %ws"),
    TEXT("Property %ws in class %ws has an incorrect [WmiVersion] qualifier"),
    TEXT("ERROR_WMIMOF_NO_PROPERTY_QUALIFERS"),
    TEXT("Class %ws has a badly formed or missing [guid] qualifier"),
    TEXT("Could not find property %ws which is the array size for property %ws in class %ws"),
    TEXT("A class could not be parsed properly"),
    TEXT("Wmi class %ws requires the qualifiers [Dynamic, Provider(\"WmiProv\")]"),
    TEXT("Error accessing binary mof file %s, code %d"),
    TEXT("Property InstanceName in class %ws must be type string and not %ws"),
    TEXT("Property Active in class %ws must be type bool and not %ws"),
    TEXT("Property %ws in class %ws does not have [WmiDataId()] qualifier"),
    TEXT("Property InstanceName in class %ws must have [key] qualifier"),
    TEXT("Class %ws and all its base classes do not have an InstanceName property"),
    TEXT("Class %ws and all its base classes do not have an Active qualifier"),
    TEXT("Property %ws in class %ws is an array, but doesn't specify a dimension"),
    TEXT("The element count property %ws for the variable length array %ws in class %ws is not an integral type"),
    TEXT("Property %ws in class %ws is both a fixed and variable length array"),
    TEXT("Embedded class %ws should be abstract or not have InstaneName or Active properties"),
    TEXT("Implemented qualifier required on method %ws in class %ws"),

    TEXT("WmiMethodId for method %ws in class %ws must be unique"),
    TEXT("WmiMethodId for method %ws in class %ws must be specified"),
    TEXT("WmiMethodId for method %ws in class %ws must not be 0"),
    TEXT("Class %ws is derived from WmiEvent and may not be [abstract]"),
    TEXT("The element count property for the variable length array %ws in class %ws is not a property of the class"),
    TEXT("An error occured resolving the variable length array property %ws in class %ws to element count property"),
    TEXT("Method %ws in class %ws must have return type void\n")            
};


HANDLE FileHandle, MappingHandle;
TCHAR *BMofFileName;

BOOLEAN DoMethodHeaderGeneration;
BOOLEAN ForceHeaderGeneration;

//
// These global variables hold the compressed buffer and size
PVOID CompressedFileBuffer;
ULONG CompressedSize;

//
// These global variables hold the uncompressed buffer and size
PVOID FileBuffer;
ULONG UncompressedSize;

BOOLEAN SkipEmbedClassCheck;

void __cdecl ErrorMessage(
    BOOLEAN ExitProgram,
    ULONG ErrorCode,
    ...
    )
{
    va_list pArg;
    LONG Index;
    TCHAR *ErrorText;
    TCHAR Buffer[1024];

    UnmapViewOfFile(CompressedFileBuffer);
    CloseHandle(MappingHandle);
    CloseHandle(FileHandle);
    DeleteFile(BMofFileName);


    if (ErrorCode == ERROR_WMI_INVALID_MOF)
    {
        Index = 0;
    } else if (ErrorCode == ERROR_NOT_ENOUGH_MEMORY) {
        Index = 1;
    } else if (ErrorCode == ERROR_FILE_NOT_FOUND) {
        Index = 2;
    } else {
        Index = (-1 * ((LONG)ErrorCode)) + 4;
    }

    fprintf(stderr, "%s (0) : error RC2135 : ", BMofFileName);
    if ( (Index < 0) || (Index > (ERROR_WMIMOF_COUNT+4)))
    {
        ErrorText = MessageText[3];
        fprintf(stderr, ErrorText, ErrorCode);
    } else {
        ErrorText = MessageText[Index];
        va_start(pArg, ErrorCode);
        _vsnprintf(Buffer, sizeof(Buffer), ErrorText, pArg);
        fprintf(stderr, Buffer);
        fprintf(stderr, "\n");
    }

    if (ExitProgram)
    {
        ExitProcess(ErrorCode);
    }
}

typedef struct
{
    DWORD Signature;
    DWORD CompressionType;
    DWORD CompressedSize;
    DWORD UncompressedSize;
    BYTE Buffer[];
} COMPRESSEDHEADER, *PCOMPRESSEDHEADER;

ULONG WmipDecompressBuffer(
    IN PVOID CompressedBuffer,
    OUT PVOID *UncompressedBuffer,
    OUT ULONG *UncompressedSize
    )
/*++

Routine Description:

    This routine will decompress a compressed MOF blob into a buffer
    that can be used to interpert the blob.

Arguments:

    CompressedBuffer points at the compressed MOF blob

    *UncompressedBuffer returns with a pointer to the uncompressed
        MOF blob

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    PCOMPRESSEDHEADER CompressedHeader = (PCOMPRESSEDHEADER)CompressedBuffer;
    BYTE *Buffer;
    ULONG Status;

    if ((CompressedHeader->Signature != BMOF_SIG) ||
        (CompressedHeader->CompressionType != 1))
    {
        WmipDebugPrint(("WMI: Invalid compressed mof header\n"));
        Status = ERROR_WMI_INVALID_MOF;
    } else {
        Buffer = WmipAlloc(CompressedHeader->UncompressedSize);
        if (Buffer == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            *UncompressedSize = Mrci1Decompress(&CompressedHeader->Buffer[0],
                                               CompressedHeader->CompressedSize,
                                               Buffer,
                                               CompressedHeader->UncompressedSize);

            if (*UncompressedSize != CompressedHeader->UncompressedSize)
            {
                WmipDebugPrint(("WMI: Invalid compressed mof buffer\n"));
                WmipFree(Buffer);
                Status = ERROR_WMI_INVALID_MOF;
            } else {
                *UncompressedBuffer = Buffer;
                Status = ERROR_SUCCESS;
            }
        }
    }
    return(Status);
}

ULONG WmipGetDataItemIdInMofClass(
    PMOFCLASSINFOW MofClassInfo,
    PWCHAR PropertyName,
    ULONG *DataItemIndex
    )
{
    PMOFDATAITEMW MofDataItem;
    ULONG i;

    for (i = 0; i < MofClassInfo->DataItemCount; i++)
    {
        MofDataItem = &MofClassInfo->DataItems[i];
        WmipAssert(MofDataItem->Name != NULL);
        if (_wcsicmp(PropertyName, MofDataItem->Name) == 0)
        {
            //
            // data item ids are 0 or 1 based depending if they are parameters
            // for a method or part of a data class. They match the
            // value in the MOF file while data item indexes within
            // the MofClassInfo structure are 0 based.
            *DataItemIndex = i;
            return(ERROR_SUCCESS);
        }
    }
    return(ERROR_WMIMOF_DATAITEM_NOT_FOUND);
}

PMOFCLASS WmipFindClassInMofResourceByGuid(
    PMOFRESOURCE MofResource,
    LPGUID Guid
    )
{
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;

    MofClassList = MofResource->MRMCHead.Flink;
    while (MofClassList != &MofResource->MRMCHead)
    {
        MofClass = CONTAINING_RECORD(MofClassList,
                                     MOFCLASS,
                                     MCMRList);
        if (IsEqualGUID(&MofClass->MofClassInfo->Guid, Guid))
        {
            return(MofClass);
        }
        MofClassList = MofClassList->Flink;
    }
    return(NULL);
}


PMOFCLASS WmipFindClassInMofResourceByName(
    PMOFRESOURCE MofResource,
    PWCHAR ClassName
    )
{
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;

    MofClassList = MofResource->MRMCHead.Flink;
    while (MofClassList != &MofResource->MRMCHead)
    {
        MofClass = CONTAINING_RECORD(MofClassList,
                                     MOFCLASS,
                                     MCMRList);
        if (_wcsicmp(MofClass->MofClassInfo->Name, ClassName) == 0)
        {
            return(MofClass);
        }
        MofClassList = MofClassList->Flink;
    }
    return(NULL);
}

ULONG WmipFillEmbeddedClasses(
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW MofClassInfo,
    BOOLEAN CleanupOnly
    )
{
    PWCHAR ClassName;
    PMOFDATAITEMW MofDataItem;
    ULONG i;
    PMOFCLASS EmbeddedMofClass;
    ULONG Status = ERROR_SUCCESS;
    WCHAR *EmbeddedClassName;

    for (i = 0; i < MofClassInfo->DataItemCount; i++)
    {
        MofDataItem = &MofClassInfo->DataItems[i];
        if (MofDataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS)
        {
            ClassName = (PWCHAR)MofDataItem->EcTempPtr;
#if DBG
            printf("Look for embdedded class %ws (%x) for %ws in class %ws\n",
                   ClassName, (ULONG_PTR)ClassName, MofDataItem->Name, MofClassInfo->Name);
#endif
            if (! CleanupOnly)
            {
                EmbeddedClassName = ClassName+(sizeof(L"object") / sizeof(WCHAR));
                EmbeddedMofClass = WmipFindClassInMofResourceByName(
                           MofResource,
                           EmbeddedClassName);
                if (EmbeddedMofClass != NULL)
                {
                    memcpy(&MofDataItem->EmbeddedClassGuid,
                           &EmbeddedMofClass->MofClassInfo->Guid,
                           sizeof(GUID));
                } else if (SkipEmbedClassCheck) {
                    MofDataItem->Flags |= MOFDI_FLAG_EC_GUID_NOT_SET;
                } else {
                    Status = ERROR_WMIMOF_EMBEDDED_CLASS_NOT_FOUND;
                    ErrorMessage(TRUE,
                                 ERROR_WMIMOF_EMBEDDED_CLASS_NOT_FOUND,
                                 EmbeddedClassName,
                                 MofDataItem->Name,
                                 MofClassInfo->Name);
                }
            }

        // Don't free ClassName since we may use MofDataItem->EcTempPtr later

        }
    }

    //
    // Resolve guids for embedded classes in any method parameter classinfo
    //
    for (i = 0; i < MofClassInfo->MethodCount; i++)
    {
        MofDataItem = &MofClassInfo->DataItems[i+MofClassInfo->DataItemCount];
        WmipFillEmbeddedClasses(MofResource,
                                MofDataItem->MethodClassInfo,
                                CleanupOnly);
    }
    return(Status);
}


void WmipFreeMofClassInfo(
    PMOFCLASSINFOW MofClassInfo
    )
/*++

Routine Description:

    This routine frees any memory allocated for the MofClassInfo and then
    the MofClassInfo itself

Arguments:

    MofClassInfo is a pointer to a MofClassInfo structure

Return Value:


--*/
{
    ULONG i;
    PMOFDATAITEMW MofDataItem;

    WmipAssert(MofClassInfo != NULL);

    if (MofClassInfo != NULL)
    {
        if (MofClassInfo->Name != NULL)
        {
            WmipFree(MofClassInfo->Name);
        }

        if (MofClassInfo->Description != NULL)
        {
            WmipFree(MofClassInfo->Description);
        }

        for (i = 0; i < MofClassInfo->DataItemCount + MofClassInfo->MethodCount; i++)
        {
            MofDataItem = &MofClassInfo->DataItems[i];
            if (MofDataItem->Name != NULL)
            {
                WmipFree(MofDataItem->Name);
            }

            if (MofDataItem->Description != NULL)
            {
                WmipFree(MofDataItem->Description);
            }
        }
    }
}

ULONG WmipFindProperty(
    CBMOFObj * ClassObject,
    WCHAR * PropertyName,
    CBMOFDataItem *MofPropertyData,
    DWORD *ValueType,
    PVOID ValueBuffer
    )
/*++

Routine Description:

    This routine will find a named property within a class object

Arguments:

    ClassObject is the class object in which to search

    PropertyName is the name of the property to search for

    MofPropertyData returns with the property data

    *ValueType on entry has the property data type being searched for. On exit
        it has the actual qualifier type for the qualifier value. If on entry
        *ValueType is 0xffffffff then any data type is acceptable

    ValueBuffer points to a buffer that returns the value of the
        property. If the property is a simple type (int or int64) then
        the value is returned in the buffer. If qualifier value is a string
        then a pointer to the string is returned in the buffer

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    ULONG Status;

    if (FindProp(ClassObject, PropertyName, MofPropertyData))
    {
        if ((*ValueType != 0xffffffff) &&
            (MofPropertyData->m_dwType != *ValueType))
        {
            Status = ERROR_WMIMOF_INCORRECT_DATA_TYPE;
        }

        if (GetData(MofPropertyData, (BYTE *)ValueBuffer, 0) == 0)
        {
            Status = ERROR_WMIMOF_NO_DATA;
        } else {
            *ValueType = MofPropertyData->m_dwType;
            Status = ERROR_SUCCESS;
        }
    } else {
        Status = ERROR_WMIMOF_NOT_FOUND;
    }
    return(Status);
}

ULONG WmipFindMofQualifier(
    CBMOFQualList *QualifierList,
    LPCWSTR QualifierName,
    DWORD *QualifierType,
    DWORD *NumberElements,
    PVOID QualifierValueBuffer
    )
/*++

Routine Description:

    This routine will find a MOF qualifier within the qualifier list passed,
    ensure that its type matches the type requested and return the qualifier's
    value

Arguments:

    QualifierList is the MOF qualifier list

    QualifierName is the name of the qualifier to search for

    *QualifierType on entry has the qualifier type being searched for. On exit
        it has the actual qualifier type for the qualifier value. If on entry
        *QualifierType is 0xffffffff then any qualifier type is acceptable

    *NumberElements returns the number of elements in the array if the result
        of the qualifier is an array

    QualifierValueBuffer points to a buffer that returns the value of the
        qualifier. If the qualifier is a simple type (int or int64) then
        the value is returned in the buffer. If qualifier value is a string
        then a pointer to the string is returned in the buffer

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    CBMOFDataItem MofDataItem;
    ULONG Status;
    PUCHAR List, ListPtr;
    ULONG BaseTypeSize;
    ULONG ElementCount;
    ULONG i;

    if (FindQual(QualifierList, (PWCHAR)QualifierName, &MofDataItem))
    {
        if ((*QualifierType != 0xffffffff) &&
            (MofDataItem.m_dwType != *QualifierType))
        {
            Status = ERROR_WMIMOF_INCORRECT_DATA_TYPE;
        }

        if (MofDataItem.m_dwType & VT_ARRAY)
        {
            if (MofDataItem.m_dwType == (VT_BSTR | VT_ARRAY))
            {
                BaseTypeSize = sizeof(PWCHAR);
            } else {
                BaseTypeSize = iTypeSize(MofDataItem.m_dwType);
            }

            ElementCount = GetNumElements(&MofDataItem, 0);
            if (NumberElements != NULL)
            {
                *NumberElements = ElementCount;
            }

            if (ElementCount != -1)
            {
               List = WmipAlloc(ElementCount * BaseTypeSize);
               if (List != NULL)
               {
                   ListPtr = List;
                   for (i = 0; i < ElementCount; i++)
                   {
                       if ((GetData(&MofDataItem,
                                   (BYTE *)ListPtr,
                                   &i)) == 0)
                       {
                           WmipFree(List);
                           Status = ERROR_WMIMOF_NO_DATA;
                           return(Status);
                       }
                       ListPtr += BaseTypeSize;
                   }
                   Status = ERROR_SUCCESS;
                   *QualifierType = MofDataItem.m_dwType;
                   *((PVOID *)QualifierValueBuffer) = List;
               } else {
                   Status = ERROR_NOT_ENOUGH_MEMORY;
               }
            } else {
                Status = ERROR_WMIMOF_NOT_FOUND;
            }
        } else {
            if (GetData(&MofDataItem, (BYTE *)QualifierValueBuffer, 0) == 0)
            {
                Status = ERROR_WMIMOF_NO_DATA;
            } else {
                *QualifierType = MofDataItem.m_dwType;
                Status = ERROR_SUCCESS;
            }
        }
    } else {
        Status = ERROR_WMIMOF_NOT_FOUND;
    }
    return(Status);
}


MOFDATATYPE VTToMofDataTypeMap[] =
{
    MOFUnknown,                /* VT_EMPTY= 0, */
    MOFUnknown,                /* VT_NULL    = 1, */
    MOFInt16,                  /* VT_I2    = 2, */
    MOFInt32,                  /* VT_I4    = 3, */
    MOFUnknown,                /* VT_R4    = 4, */
    MOFUnknown,                /* VT_R8    = 5, */
    MOFUnknown,                /* VT_CY    = 6, */
    MOFUnknown,                /* VT_DATE    = 7, */
    MOFString,                 /* VT_BSTR    = 8, */
    MOFUnknown,                /* VT_DISPATCH    = 9, */
    MOFUnknown,                /* VT_ERROR    = 10, */
    MOFBoolean,                /* VT_BOOL    = 11, */
    MOFUnknown,                /* VT_VARIANT    = 12, */
    MOFUnknown,                /* VT_UNKNOWN    = 13, */
    MOFUnknown,                /* VT_DECIMAL    = 14, */
    MOFChar,                   /* VT_I1    = 16, */
    MOFByte,                   /* VT_UI1    = 17, */
    MOFUInt16,                 /* VT_UI2    = 18, */
    MOFUInt32,                 /* VT_UI4    = 19, */
    MOFInt64,                  /* VT_I8    = 20, */
    MOFUInt64,                 /* VT_UI8    = 21, */
};

MOFDATATYPE WmipVTToMofDataType(
    DWORD VariantType
    )
{
    MOFDATATYPE MofDataType;

    if (VariantType < (sizeof(VTToMofDataTypeMap) / sizeof(MOFDATATYPE)))
    {
        MofDataType = VTToMofDataTypeMap[VariantType];
    } else {
        MofDataType = MOFUnknown;
    }
    return(MofDataType);
}


ULONG WmipGetClassDataItemCount(
    CBMOFObj * ClassObject,
    PWCHAR QualifierToFind
    )
/*++

Routine Description:

    This routine will count the number of WMI data items in the class and
    the total number of properties in the class.

Arguments:

    ClassObject is class for which we count the number of data items

    *TotalCount returns the total number of properties

Return Value:

    Count of methods

--*/
{
    CBMOFQualList *PropQualifierList;
    CBMOFDataItem MofPropertyData;
    DWORD QualifierType;
    ULONG Counter = 0;
    WCHAR *PropertyName;
    ULONG Status;
    ULONG Index;

    ResetObj(ClassObject);
    while ((NextProp(ClassObject, &PropertyName, &MofPropertyData)) &&
           PropertyName != NULL)
    {
        PropQualifierList = GetPropQualList(ClassObject, PropertyName);
        if (PropQualifierList != NULL)
        {
            //
            // Get the id of the property so we know it order in class
            QualifierType = VT_I4;
            Status = WmipFindMofQualifier(PropQualifierList,
                                          QualifierToFind,
                                          &QualifierType,
                                          NULL,
                                          (PVOID)&Index);
            if (Status == ERROR_SUCCESS)
            {
                Counter++;
            }
            BMOFFree(PropQualifierList);
        }
        BMOFFree(PropertyName);
    }

    return(Counter);
}

ULONG WmipGetClassMethodCount(
    CBMOFObj * ClassObject
)
/*++

Routine Description:

    This routine will count the number of WMI data items in the class

Arguments:

    ClassObject is class for which we count the number of data items

Return Value:

    Count of methods

--*/
{
    ULONG MethodCount;
    WCHAR *MethodName;
    CBMOFDataItem MofMethodData;

    ResetObj(ClassObject);
    MethodCount = 0;
    while(NextMeth(ClassObject, &MethodName, &MofMethodData))
    {
        MethodCount++;
        if (MethodName != NULL)
        {
            BMOFFree(MethodName);
        }
    }
    return(MethodCount);
}


ULONG WmipParsePropertyObject(
    OUT PMOFDATAITEMW MofDataItem,
    IN CBMOFDataItem *MofPropertyData,
    IN CBMOFQualList *PropQualifierList
    )
/*++

Routine Description:

    This routine will parse a BMOF object that is known to be an object that
    contains a property and fill int the MofDataItem that holds its
    information. If the routine detects an error then parsing will stop as
    the whole class will need to be rejected.


    No error messages are generated from this routine. The return error
    code is checked and an appropriate message generated.

Arguments:

    MofDataItem is the mof data item information structure to fill in

    MofPropertyData has the property information for the data item

    PropQualifierList has the qualifier list for the property

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    short BooleanValue;
    DWORD QualifierType;
    ULONG Status;
    WCHAR *StringPtr;
    ULONG FixedArraySize;
    DWORD VTDataType;
    DWORD VersionValue;
    BOOLEAN FreeString = TRUE;
    PMOFCLASSINFOW MethodClassInfo;
    ULONG MaxLen;
    
    //
    // Keep track of property and property qualifier objects
    MofDataItem->PropertyQualifierHandle = (ULONG_PTR)PropQualifierList;

    //
    // Get the description string which is not required
    QualifierType = VT_BSTR;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"description",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&MofDataItem->Description);

    //
    // Get the version value which is not required
    QualifierType = VT_I4;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"WmiVersion",
                                  &QualifierType,
                                  NULL,
                                  (PVOID)&VersionValue);
    if (Status == ERROR_SUCCESS)
    {
        MofDataItem->Version = VersionValue;
    }

    //
    // Get read qualifier which is not required
    QualifierType = VT_BOOL;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"read",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&BooleanValue);

    if ((Status == ERROR_SUCCESS) && BooleanValue)
    {
        MofDataItem->Flags |= MOFDI_FLAG_READABLE;
    }

    //
    // Get write qualifier which is not required
    QualifierType = VT_BOOL;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"write",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&BooleanValue);

    if ((Status == ERROR_SUCCESS) && BooleanValue)
    {
        MofDataItem->Flags |= MOFDI_FLAG_WRITEABLE;
    }

    //
    // Get WmiEvent qualifier which is not required
    QualifierType = VT_BOOL;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"WmiEvent",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&BooleanValue);

    if ((Status == ERROR_SUCCESS) && BooleanValue)
    {
        MofDataItem->Flags |= MOFDI_FLAG_EVENT;
    }

    //
    // See if this is a fixed length array
    QualifierType = VT_I4;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"max",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&FixedArraySize);

    if (Status == ERROR_SUCCESS)
    {
        MofDataItem->Flags |= MOFDI_FLAG_FIXED_ARRAY;
        MofDataItem->FixedArrayElements = FixedArraySize;
#if DBG
        printf(" Fixed Array");
#endif
    }

    //
    // See if this is a fixed length array
    QualifierType = VT_I4;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"MaxLen",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&MaxLen);

    if (Status == ERROR_SUCCESS)
    {
        MofDataItem->MaxLen = MaxLen;
    }

    //
    // See if maxmium length 
    QualifierType = VT_BSTR;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"WmiSizeIs",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&StringPtr);

    if (Status == ERROR_SUCCESS)
    {
        if (MofDataItem->Flags & MOFDI_FLAG_FIXED_ARRAY)
        {
            BMOFFree(StringPtr);
            return(ERROR_WMIMOF_BOTH_FIXED_AND_VARIABLE_ARRAY);
        }
        MofDataItem->Flags |= MOFDI_FLAG_VARIABLE_ARRAY;

        //
        // When all properties are parsed we will come back and compute the
        // data item id for the data item that holds the number of elements
        // in the array. For now we'll hang onto the string pointer
        MofDataItem->VarArrayTempPtr = StringPtr;
#if DBG
        printf(" Variable Array of %ws", StringPtr);
#endif
    }

    if ((MofPropertyData->m_dwType & VT_ARRAY) &&
        ((MofDataItem->Flags & (MOFDI_FLAG_VARIABLE_ARRAY | MOFDI_FLAG_FIXED_ARRAY)) == 0))
    {
        return(ERROR_WMIMOF_MUST_DIM_ARRAY);
    }

    //
    // Now figure out the data type and size of the data item
    VTDataType = MofPropertyData->m_dwType & ~(VT_ARRAY | VT_BYREF);

    QualifierType = VT_BSTR;
    Status = WmipFindMofQualifier(PropQualifierList,
                                      L"CIMTYPE",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&StringPtr);

    if (VTDataType == VT_DISPATCH)
    {
        //
        // This is an embedded class
        MofDataItem->DataType = MOFEmbedded;

        if (Status == ERROR_SUCCESS)
        {
            //
            // We will resolve the class name to its guid later so we
            // just hang onto the embedded class name here.
            MofDataItem->EcTempPtr = StringPtr;
            MofDataItem->Flags |= MOFDI_FLAG_EMBEDDED_CLASS;
#if DBG
            printf(" Embedded Class of %ws (%x)", StringPtr, (ULONG_PTR)StringPtr);
#endif
        } else {
            return(ERROR_WMIMOF_NO_EMBEDDED_CLASS_NAME);
        }
    } else {
        if (Status == ERROR_SUCCESS)
        {
            if (_wcsnicmp(StringPtr, L"object:", 7) == 0) {
                MofDataItem->DataType = MOFEmbedded;
                MofDataItem->EcTempPtr = StringPtr;
                MofDataItem->Flags |= MOFDI_FLAG_EMBEDDED_CLASS;
                FreeString = FALSE;
#if DBG
                printf(" Embedded Class of %ws (%x)", StringPtr, (ULONG_PTR)StringPtr);
#endif
            } else if (_wcsicmp(StringPtr, L"string") == 0) {
                MofDataItem->DataType = MOFString;
            } else if (_wcsicmp(StringPtr, L"sint32") == 0) {
                MofDataItem->DataType = MOFInt32;
                MofDataItem->SizeInBytes = 4;
            } else if (_wcsicmp(StringPtr, L"uint32") == 0) {
                MofDataItem->DataType = MOFUInt32;
                MofDataItem->SizeInBytes = 4;
            } else if (_wcsicmp(StringPtr, L"boolean") == 0) {
                MofDataItem->DataType = MOFBoolean;
                MofDataItem->SizeInBytes = 1;
            } else if (_wcsicmp(StringPtr, L"sint64") == 0) {
                MofDataItem->DataType = MOFInt64;
                MofDataItem->SizeInBytes = 8;
            } else if (_wcsicmp(StringPtr, L"uint64") == 0) {
                MofDataItem->DataType = MOFUInt64;
                MofDataItem->SizeInBytes = 8;
            } else if ((_wcsicmp(StringPtr, L"sint16") == 0) ||
                       (_wcsicmp(StringPtr, L"char16") == 0)) {
                MofDataItem->DataType = MOFInt16;
                MofDataItem->SizeInBytes = 2;
            } else if (_wcsicmp(StringPtr, L"uint16") == 0) {
                MofDataItem->DataType = MOFUInt16;
                MofDataItem->SizeInBytes = 2;
            } else if (_wcsicmp(StringPtr, L"sint8") == 0) {
                MofDataItem->DataType = MOFChar;
                MofDataItem->SizeInBytes = 1;
            } else if (_wcsicmp(StringPtr, L"uint8") == 0) {
                MofDataItem->DataType = MOFByte;
                MofDataItem->SizeInBytes = 1;
            } else if (_wcsicmp(StringPtr, L"datetime") == 0) {
                MofDataItem->DataType = MOFDate;
                MofDataItem->SizeInBytes = 25;
            } else {
                WmipDebugPrint(("WMI: Unknown data item syntax %ws\n",
                                  StringPtr));
                BMOFFree(StringPtr);
                return(ERROR_WMIMOF_UNKNOWN_DATA_TYPE);
            }

            if (FreeString)
            {
                BMOFFree(StringPtr);
            }

            //
            // If fixed array then multiply number elements by element size
            if ((MofDataItem->SizeInBytes != 0) &&
                (MofDataItem->Flags & MOFDI_FLAG_FIXED_ARRAY))
            {
                MofDataItem->SizeInBytes *= MofDataItem->FixedArrayElements;
            }
        } else {
            WmipDebugPrint(("WMI: No Syntax qualifier for %ws\n",
            MofDataItem->Name));
            return(ERROR_WMIMOF_NO_SYNTAX_QUALIFIER);
        }
    }
    return(ERROR_SUCCESS);
}

ULONG WmipParseMethodObject(
    CBMOFDataItem *MofMethodData,
    CBMOFQualList *PropQualifierList,
    PULONG MethodId
    )
{
    ULONG UlongValue;
    ULONG Status;
    DWORD QualifierType;
    short BooleanValue;
    
    QualifierType = VT_BOOL;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"Implemented",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&BooleanValue);

    if ((Status != ERROR_SUCCESS) || (! BooleanValue))
    {
        return(ERROR_WMIMOF_IMPLEMENTED_REQUIRED);
    }

    QualifierType = VT_I4;
    Status = WmipFindMofQualifier(PropQualifierList,
                                  L"WmiMethodId",
                                  &QualifierType,
                                          NULL,
                                  (PVOID)&UlongValue);

    if (Status != ERROR_SUCCESS)
    {
        return(ERROR_WMIMOF_IMPLEMENTED_REQUIRED);
    }

    if (UlongValue == 0)
    {
        return(ERROR_WMIMOF_METHODID_ZERO);
    }

    *MethodId = UlongValue;


    return(ERROR_SUCCESS);
}

ULONG WmipResolveVLArray(
    IN PMOFCLASSINFOW MofClassInfo,
    IN OUT PMOFDATAITEMW MofDataItem,
    IN ULONG FinalStatus
)
/*++

Routine Description:

    This routine will resolve the array index for a variable length array

Arguments:

    MofCLassInfo is the class info for the class

    MofDataItem is the mof data item that is a variable length array and
        whole index needs to be resolved.

    FinalStatus is the status of the mof parsing previously done for the
        class

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    MOFDATATYPE ArraySizeDataType;
    PWCHAR PropertyName;
    ULONG Status;
    ULONG Index;

    PropertyName = (PWCHAR)MofDataItem->VarArrayTempPtr;
    if (FinalStatus == ERROR_SUCCESS)
    {
        //
        // Only resolve this in the case where the class parsing
        // has not failed. We kept the name of the property containing the
        // number of elements in the array handy, so we need to
        // resolve it to its data item id and free the name.
        //
        Status = WmipGetDataItemIdInMofClass(MofClassInfo,
                                       PropertyName,
                                       &Index);
            

            
            
        if (Status != ERROR_SUCCESS)
        {
            FinalStatus = Status;
        } else {
            if ((MofClassInfo->Flags & MOFCI_FLAG_METHOD_PARAMS) ==
                              MOFCI_FLAG_METHOD_PARAMS)
            {
                MofDataItem->VariableArraySizeId = Index;
            } else {
                MofDataItem->VariableArraySizeId = Index + 1;
        }
        
            ArraySizeDataType = MofClassInfo->DataItems[Index].DataType;
            if ((ArraySizeDataType != MOFInt32) &&
                (ArraySizeDataType != MOFUInt32) &&
                (ArraySizeDataType != MOFInt64) &&
                (ArraySizeDataType != MOFUInt64) &&
                (ArraySizeDataType != MOFInt16) &&
                (ArraySizeDataType != MOFUInt16))
            {
                FinalStatus = ERROR_WMIMOF_BAD_VL_ARRAY_SIZE_TYPE;
            }
        }
    }
    BMOFFree(PropertyName);
    PropertyName = NULL;

    return(FinalStatus);
}


ULONG WmipParseMethodInOutObject(
    CBMOFObj *ClassObject,
    PMOFCLASSINFOW ClassInfo,
    ULONG DataItemCount
)
/*++

Routine Description:

    This routine will parse a class object that is either the in or out
    parameters for a method.

Arguments:

    ClassObject is the in or out parameter class object to parse

    ClassInfo returns updated with information from ClassObject

    DataItemCount is the number of data items in the ClassInfo

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    ULONG Status;
    CBMOFDataItem MofPropertyData;
    PWCHAR PropertyName = NULL;
    ULONG Index;
    PMOFDATAITEMW MofDataItem;
    CBMOFQualList *PropQualifierList = NULL;
    DWORD QualifierType;
    short BooleanValue;

    ResetObj(ClassObject);
    while (NextProp(ClassObject, &PropertyName, &MofPropertyData))
    {
        PropQualifierList = GetPropQualList(ClassObject, PropertyName);
        if (PropQualifierList != NULL)
        {

            //
            // Get the id of the property so we know its order in class
            //
            QualifierType = VT_I4;
            Status = WmipFindMofQualifier(PropQualifierList,
                                              L"Id",
                                              &QualifierType,
                                              NULL,
                                              (PVOID)&Index);
            if (Status == ERROR_SUCCESS)
            {
                //
                // Method ids are 0 based
                //
                if (Index < DataItemCount)
                {
                    //
                    // Valid data item id, make sure it already isn't
                    // in use. Note that we could have the same property
                    // be in both the in and the out class objects
                    //
                    MofDataItem = &ClassInfo->DataItems[Index];


                    //
                    // See if this is an input, output or both
                     //
                    QualifierType = VT_BOOL;
                    Status = WmipFindMofQualifier(PropQualifierList,
                                              L"in",
                                              &QualifierType,
                                              NULL,
                                              (PVOID)&BooleanValue);
                    if ((Status == ERROR_SUCCESS) && BooleanValue)
                    {
                        MofDataItem->Flags |= MOFDI_FLAG_INPUT_METHOD;
                    }

                    QualifierType = VT_BOOL;
                    Status = WmipFindMofQualifier(PropQualifierList,
                                              L"out",
                                              &QualifierType,
                                              NULL,
                                              (PVOID)&BooleanValue);
                    if ((Status == ERROR_SUCCESS) && BooleanValue)
                    {
                        MofDataItem->Flags |= MOFDI_FLAG_OUTPUT_METHOD;
                    }


                    if ((MofDataItem->Name != NULL) &&
                        (wcscmp(MofDataItem->Name, PropertyName) != 0))
                    {
                        //
                        // id already in use
                        //
                        Status = ERROR_WMIMOF_DUPLICATE_ID;
                        goto done;
                    }

                    if (MofDataItem->Name == NULL)
                    {
                        MofDataItem->Name = PropertyName;
                    } else {
                        BMOFFree(PropertyName);
                    }
                    PropertyName = NULL;

                    Status = WmipParsePropertyObject(
                                              MofDataItem,
                                              &MofPropertyData,
                                              PropQualifierList);

                    if (Status != ERROR_SUCCESS)
                    {
                        goto done;
                    }
                } else {
                    //
                    // Method ID qualifier is out of range
                    //
                    Status = ERROR_WMIMOF_BAD_DATAITEM_ID;
                    goto done;
                }
            } else {
                //
                // property is supposed to have a method id !!
                //
                Status = ERROR_WMIMOF_METHOD_RETURN_NOT_VOID;
                goto done;
            }
        }
    }

done:
    if (PropertyName != NULL)
    {
        BMOFFree(PropertyName);
        PropertyName = NULL;
    }

    if (PropQualifierList != NULL)
    {
        BMOFFree(PropQualifierList);
    }

    return(Status);
}


ULONG WmipParseMethodParameterObjects(
    IN CBMOFObj *InObject,
    IN CBMOFObj *OutObject,
    OUT PMOFCLASSINFOW *ClassInfo
    )
/*++

Routine Description:

    This routine will parse the in and out method parameter obejcts to create
    a MOFCLASSINFO that describes the method call.

Arguments:

    InObject is the object with the input parameters

    OutObject is the object with the output parameters

    *ClassInfo returns with the class info for the method call

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    PMOFCLASSINFOW MofClassInfo;
    ULONG Status, FinalStatus;
    DWORD QualifierType;
    ULONG DataItemCount;
    ULONG MofClassInfoSize;
    WCHAR *StringPtr;
    ULONG i, Index;
    ULONG InItemCount, OutItemCount;
    ULONG Size;
    PMOFDATAITEMW MofDataItem;
    ULONG Count;

    FinalStatus = ERROR_SUCCESS;
    
    if (InObject != NULL)
    {
        ResetObj(InObject);
        InItemCount = WmipGetClassDataItemCount(InObject, L"Id");
    } else {
        InItemCount = 0;
    }

    if (OutObject != NULL)
    {
        ResetObj(OutObject);
        OutItemCount = WmipGetClassDataItemCount(OutObject, L"Id");
    } else {
        OutItemCount = 0;
    }

    DataItemCount = InItemCount + OutItemCount;

    Size = sizeof(MOFCLASSINFOW) + DataItemCount * sizeof(MOFDATAITEMW);
    MofClassInfo = WmipAlloc(Size);
    if (MofClassInfo == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Get the essential information to fill in the MOF class info
    memset(MofClassInfo, 0, Size);
    MofClassInfo->Flags |= MOFCI_FLAG_METHOD_PARAMS;

    MofClassInfo->DataItems = (PMOFDATAITEMW) ((PUCHAR)MofClassInfo +
                                                   sizeof(MOFCLASSINFOW));

    //
    // number of properties/data items in class
    MofClassInfo->DataItemCount = DataItemCount;
    MofClassInfo->MethodCount = 0;

    //
    // Parse the input parameter class object
    //
    if (InObject != NULL)
    {
        Status = WmipParseMethodInOutObject(InObject,
                                            MofClassInfo,
                                            DataItemCount);
        if (Status == ERROR_SUCCESS)
        {
            if (OutObject != NULL)
            {
                //
                // Parse the output parameter class object
                //
                Status = WmipParseMethodInOutObject(OutObject,
                                                    MofClassInfo,
                                                    DataItemCount);
            }

            //
            // Now do any post parsing validation and fixup any variable
            // length array properties
            //
            FinalStatus = Status;
            Count = MofClassInfo->DataItemCount;
            for (Index = 0; Index < Count; Index++)
            {
                MofDataItem = &MofClassInfo->DataItems[Index];

                if (MofDataItem->Name == NULL)
                {
                    MofClassInfo->DataItemCount--;
                }

                if (MofDataItem->Flags & MOFDI_FLAG_VARIABLE_ARRAY)
                {
                    FinalStatus = WmipResolveVLArray(MofClassInfo,
                                                     MofDataItem,
                                                     FinalStatus);
                }
            }
        }
    }

    *ClassInfo = MofClassInfo;

    return(FinalStatus);
}


ULONG WmipParseMethodParameters(
    CBMOFDataItem *MofMethodData,
    PMOFCLASSINFOW *MethodClassInfo
)
{
    ULONG Status = ERROR_SUCCESS;
    CBMOFObj *InObject;
    CBMOFObj *OutObject;
    ULONG i;
    ULONG NumberDimensions;
    ULONG NumberElements;
    VARIANT InVar, OutVar;
    DWORD SimpleType;

    SimpleType = MofMethodData->m_dwType & ~VT_ARRAY & ~VT_BYREF;

    NumberDimensions = GetNumDimensions(MofMethodData);
    if (NumberDimensions > 0)
    {
        NumberElements = GetNumElements(MofMethodData, 0);
        WmipAssert(NumberDimensions == 1);
        WmipAssert((NumberElements == 1) || (NumberElements == 2));

        i = 0;
        memset((void *)&InVar.lVal, 0, 8);

        if (GetData(MofMethodData, (BYTE *)&(InVar.lVal), &i))
        {
            InObject = (CBMOFObj *)InVar.bstrVal;
            InVar.vt = (VARTYPE)SimpleType;
            WmipAssert(InVar.vt ==  VT_UNKNOWN);

            if (NumberElements == 2)
            {
                i = 1;
                memset((void *)&OutVar.lVal, 0, 8);
                if (GetData(MofMethodData, (BYTE *)&(OutVar.lVal), &i))
                {
                    OutVar.vt = (VARTYPE)SimpleType;
                    WmipAssert(OutVar.vt ==  VT_UNKNOWN);
                    OutObject = (CBMOFObj *)OutVar.bstrVal;
                } else {
                    Status = ERROR_WMIMOF_NOT_FOUND;
                }
            } else {
                OutObject = NULL;
            }
        } else {
            Status = ERROR_WMIMOF_NOT_FOUND;
        }
    } else {
        InObject = NULL;
        OutObject = NULL;
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = WmipParseMethodParameterObjects(InObject,
                                                 OutObject,
                                                 MethodClassInfo);      
    }

    return(Status);
}

ULONG WmipParseClassObject(
    PMOFRESOURCE MofResource,
    CBMOFObj * ClassObject
    )
/*++

Routine Description:

    This routine will parse a BMOF object that is known to be an object that
    contains a class. If we run into a parsing error then we immediate
    quit parsing the class and return an error.

Arguments:

    MofResource is the Mof Resource structure

    ClassObject is BMOF object to parse

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    PMOFCLASSINFOW MofClassInfo;
    CBMOFQualList *ClassQualifierList = NULL;
    CBMOFQualList *PropQualifierList = NULL;
    CBMOFQualList *MethQualifierList = NULL;
    CBMOFDataItem MofPropertyData, MofMethodData;
    ULONG Status;
    DWORD QualifierType;
    ULONG DataItemCount;
    ULONG MofClassInfoSize;
    WCHAR *PropertyName = NULL;
    WCHAR *MethodName = NULL;
    ULONG Index;
    PMOFDATAITEMW MofDataItem;
    WCHAR *StringPtr;
    PMOFCLASS MofClass;
    ULONG FailedStatus;
    ULONG Version;
    short BooleanValue;
    WCHAR *ClassName;
    BOOLEAN DynamicQualifier, ProviderQualifier;
    PULONG MethodList = 0;
    ULONG MethodCount, MethodId;
    ULONG i, Size;
    BOOLEAN IsEvent;
    PMOFCLASSINFOW MethodClassInfo;
    BOOLEAN AbstractClass = FALSE;

    //
    // Get the class name which is required
    if (! GetName(ClassObject, &ClassName))
    {
        WmipDebugPrint(("WMI: MofClass does not have a name\n"));
        Status = ERROR_WMIMOF_NO_CLASS_NAME;
        ErrorMessage(TRUE, ERROR_WMI_INVALID_MOF);
        return(Status);
    }

#if DBG
    printf("Parsing class %ws\n", ClassName);
#endif

    ResetObj(ClassObject);
    ClassQualifierList = GetQualList(ClassObject);
    if (ClassQualifierList == NULL)
    {
        WmipDebugPrint(("WMI: MofClass %ws does not have a qualifier list\n",
                        ClassName));
        Status = ERROR_WMIMOF_NO_CLASS_NAME;
        ErrorMessage(TRUE, ERROR_WMI_INVALID_MOF);
        return(Status);
    }

    //
    // Classes derived from WmiEvent may not be [abstract]

    QualifierType = VT_BSTR;
    Status = WmipFindProperty(ClassObject,
                                  L"__SUPERCLASS",
                                  &MofPropertyData,
                                  &QualifierType,
                                  (PVOID)&StringPtr);
    if (Status == ERROR_SUCCESS)
    {
        IsEvent = (_wcsicmp(StringPtr, L"WmiEvent") == 0);
    } else {
        IsEvent = FALSE;
    }
    
    QualifierType = VT_BOOL;
    Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"Abstract",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&BooleanValue);

    if ((Status == ERROR_SUCCESS) && BooleanValue)
    {
        //
        // This is an abstract class - make sure it is not derived from
        // WmiEvent
        AbstractClass = TRUE;
        QualifierType = VT_BSTR;
        Status = WmipFindProperty(ClassObject,
                                  L"__SUPERCLASS",
                                  &MofPropertyData,
                                  &QualifierType,
                                  (PVOID)&StringPtr);
        if (Status == ERROR_SUCCESS)
        {
            if (_wcsicmp(StringPtr, L"WmiEvent") == 0)
            {
                ErrorMessage(TRUE,
                     ERROR_WMIMOF_WMIEVENT_ABSTRACT,
                     ClassName);
                 return(ERROR_WMIMOF_WMIEVENT_ABSTRACT);
            }
            BMOFFree(StringPtr);
        }
    }

    //
    // See if this is a WMI class. Wmi classes have the [WMI] qualifier
    QualifierType = VT_BOOL;
    Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"WMI",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&BooleanValue);

    if (! ((Status == ERROR_SUCCESS) && BooleanValue))
    {
        //
        // Skip this non-wmi class
        return(ERROR_SUCCESS);
    }

    //
    // Now check for WBEM required qualifiers
    QualifierType = VT_BOOL;
    Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"Dynamic",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&BooleanValue);

    DynamicQualifier = ((Status == ERROR_SUCCESS) && BooleanValue);


    QualifierType = VT_BSTR;
    Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"Provider",
                                      &QualifierType,
                                      NULL,
                                      (PVOID)&StringPtr);

    if (Status == ERROR_SUCCESS)
    {
        if (_wcsicmp(StringPtr, L"WmiProv") != 0)
        {
            Status = ERROR_WMIMOF_MISSING_HMOM_QUALIFIERS;
        }
        BMOFFree(StringPtr);
        ProviderQualifier = TRUE;
    } else {
        ProviderQualifier = FALSE;
    }


    if ((ProviderQualifier && ! DynamicQualifier) ||
        (! ProviderQualifier && DynamicQualifier))
    {
        //
        // Both or neither [Dynamic, Provider(WmiProv)] qualifiers are required
        ErrorMessage(TRUE,
                     ERROR_WMIMOF_MISSING_HMOM_QUALIFIERS,
                     ClassName);
        return(ERROR_WMIMOF_MISSING_HMOM_QUALIFIERS);
    }


    MofClass = WmipAllocMofClass();
    if (MofClass == NULL)
    {
        //
        // No memory for MofClass so give up
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Reference the MofResource so it stays around while the MofClass
    // stays around
    MofClass->MofResource = MofResource;
    WmipReferenceMR(MofResource);

    DataItemCount = WmipGetClassDataItemCount(ClassObject, L"WmiDataId");
    MethodCount = WmipGetClassMethodCount(ClassObject);
    ResetObj(ClassObject);

    Size = sizeof(MOFCLASSINFO);

    MofClassInfoSize = Size +
                        (DataItemCount+MethodCount) * sizeof(MOFDATAITEMW);
    MofClassInfo = WmipAlloc(MofClassInfoSize);
    if (MofClassInfo == NULL)
    {
        // WmipMCCleanup will unreference the MofResource
        WmipUnreferenceMC(MofClass);
        return(ERROR_NOT_ENOUGH_MEMORY);
    } else {
        MofClass->MofClassInfo = MofClassInfo;
        MofClass->ClassObjectHandle = (ULONG_PTR)ClassObject;

        //
        // Get the essential information to fill in the MOF class info
        memset(MofClassInfo, 0, MofClassInfoSize);

        MofClassInfo->Flags = MOFCI_FLAG_READONLY;
        MofClassInfo->Flags |= IsEvent ? MOFCI_FLAG_EVENT : 0;
        MofClassInfo->Flags |= ProviderQualifier ? MOFCI_RESERVED0 : 0;

        if (!ProviderQualifier && !DynamicQualifier)
        {
             //
            // If neither the provider qualifier and Dynamic qualifier are
            // specified then this is an embedded class
            //
            MofClassInfo->Flags |= MOFCI_FLAG_EMBEDDED_CLASS;
        }

        MofClassInfo->DataItems = (PMOFDATAITEMW) ((PUCHAR)MofClassInfo +
                                                   Size);

        //
        // number of properties/data items in class
        MofClassInfo->DataItemCount = DataItemCount;
        MofClassInfo->MethodCount = MethodCount;

        MofClassInfo->Name = ClassName;

        ClassQualifierList = GetQualList(ClassObject);
        if (ClassQualifierList == NULL)
        {
            WmipDebugPrint(("WMI: MofClass %ws does not have a qualifier list\n",
                            MofClassInfo->Name));
            Status = ERROR_WMIMOF_NO_CLASS_NAME;
            ErrorMessage(TRUE, ERROR_WMI_INVALID_MOF);
            goto done;
        }

        //
        // Get the class guid which is required. Then convert it into
        // binary form.
        QualifierType = VT_BSTR;
        Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"guid",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&StringPtr);
        if (Status == ERROR_SUCCESS)
        {
            Status = wGUIDFromString(StringPtr , &MofClassInfo->Guid) ?
                                        ERROR_SUCCESS :
                                        ERROR_WMIMOF_BAD_DATA_FORMAT;
            BMOFFree((PVOID)StringPtr);

        }
        if (Status != ERROR_SUCCESS)
        {
            WmipDebugPrint(("WMI: MofClass %ws guid not found or in incorrect format\n",
                           MofClassInfo->Name));
            ErrorMessage(TRUE,
                         ERROR_WMIMOF_BAD_OR_MISSING_GUID,
                         MofClassInfo->Name);
            goto done;
        }


        //
        // Get the description string which is not required
        QualifierType = VT_BSTR;
        Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"description",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&MofClassInfo->Description);


        //
        // Get the header name string which is not required
        QualifierType = VT_BSTR;
        Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"HeaderName",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&MofClassInfo->HeaderName);

        //
        // Get the header name string which is not required
        QualifierType = VT_BSTR;
        Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"GuidName1",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&MofClassInfo->GuidName1);


        //
        // Get the header name string which is not required
        QualifierType = VT_BSTR;
        Status = WmipFindMofQualifier(ClassQualifierList,
                                      L"GuidName2",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&MofClassInfo->GuidName2);

        //
        // Now gather all of the information about the data items/properties
        ResetObj(ClassObject);
        Status = ERROR_SUCCESS;
        while (NextProp(ClassObject, &PropertyName, &MofPropertyData))
        {
#if DBG
            printf("    %ws - ", PropertyName);
#endif
            PropQualifierList = GetPropQualList(ClassObject, PropertyName);
            if (PropQualifierList != NULL)
            {
                //
                // Get the id of the property so we know its order in class
                // If it doesn't have an id then we ignore it
                QualifierType = VT_I4;
                Status = WmipFindMofQualifier(PropQualifierList,
                                              L"WmiDataId",
                                              &QualifierType,
                                          NULL,
                                              (PVOID)&Index);
                if (Status == ERROR_SUCCESS)
                {
                    //
                    // Wmi Data Item ids are 1 based in the MOF
                    Index--;
                    if (Index < DataItemCount)
                    {
                        //
                        // Valid data item id, make sure it already isn't
                        // in use.
                        MofDataItem = &MofClassInfo->DataItems[Index];
                        if (MofDataItem->Name != NULL)
                        {
                            WmipDebugPrint(("WMI: Mof Class %ws has duplicate data item id %d for %ws and %ws\n",
                                 MofClassInfo->Name, Index,
                                 MofDataItem->Name, PropertyName));
                            Status = ERROR_WMIMOF_DUPLICATE_ID;
                            ErrorMessage(TRUE,
                                         ERROR_WMIMOF_DUPLICATE_ID,
                                         MofDataItem->Name,
                                          MofClassInfo->Name,
                                         Index+1,
                                         PropertyName);
                            goto done;
                        }
                        MofDataItem->Name = PropertyName;
                        PropertyName = NULL;
                        Status = WmipParsePropertyObject(
                                              MofDataItem,
                                              &MofPropertyData,
                                              PropQualifierList);
                        if (Status != ERROR_SUCCESS)
                        {
                            WmipDebugPrint(("WMI: MofClass %ws Property %ws not parsed properly %x\n",
                                        MofClassInfo->Name, MofDataItem->Name, Status));
                            ErrorMessage(TRUE,
                                         Status,
                                          MofDataItem->Name,
                                          MofClassInfo->Name);
                            goto done;
                        }

                        if (MofDataItem->Flags & MOFDI_FLAG_WRITEABLE)
                        {
                            MofClassInfo->Flags &= ~MOFCI_FLAG_READONLY;
                        }
                    } else {
                        WmipDebugPrint(("WMI: MofClass %ws has DataItem Id for %ws out of range %d\n",
                            MofClassInfo->Name, PropertyName, Index));
                        Status = ERROR_WMIMOF_BAD_DATAITEM_ID;
                        ErrorMessage(TRUE,
                                     ERROR_WMIMOF_BAD_DATAITEM_ID,
                                        PropertyName,
                                        MofClassInfo->Name,
                                     Index+1);
                        goto done;
                    }
                } else {
                    //
                    // This property does not have a WmiDataId qualifier
                    // so see if it is Active or InstanceName
                    QualifierType = VT_BSTR;
                    Status = WmipFindMofQualifier(PropQualifierList,
                                                  L"CIMTYPE",
                                                  &QualifierType,
                                          NULL,
                                                  (PVOID)&StringPtr);

                    if (_wcsicmp(PropertyName, L"InstanceName") == 0)
                    {
                        if ((Status != ERROR_SUCCESS) ||
                            (_wcsicmp(StringPtr, L"string") != 0))
                        {
                            Status = ERROR_WMIMOF_INSTANCENAME_BAD_TYPE;
                            ErrorMessage(TRUE,
                                         ERROR_WMIMOF_INSTANCENAME_BAD_TYPE,
                                         MofClassInfo->Name,
                                         StringPtr);
                            BMOFFree(StringPtr);
                            goto done;
                        } else {
                            BMOFFree(StringPtr);
                            if ((! ProviderQualifier) && (! AbstractClass))
                            {
                                //
                                // If InstanceName specified, but this is an
                                // embedded class then an error
                                Status = ERROR_WMIMOF_EMBEDDED_CLASS;
                                ErrorMessage(TRUE,
                                         ERROR_WMIMOF_EMBEDDED_CLASS,
                                         MofClassInfo->Name);
                                goto done;
                            }
                            QualifierType = VT_BOOL;
                            Status = WmipFindMofQualifier(PropQualifierList,
                                                  L"key",
                                                  &QualifierType,
                                          NULL,
                                                  (PVOID)&BooleanValue);
                            if ((Status == ERROR_SUCCESS) && BooleanValue)
                            {
                                MofClassInfo->Flags |= MOFCI_RESERVED1;
                            } else {
                                Status = ERROR_WMIMOF_INSTANCENAME_NOT_KEY;
                                ErrorMessage(TRUE,
                                         ERROR_WMIMOF_INSTANCENAME_NOT_KEY,
                                         MofClassInfo->Name);
                                goto done;
                            }
                        }
                    } else if (_wcsicmp(PropertyName, L"Active") == 0)
                    {
                        if ((Status != ERROR_SUCCESS) ||
                            (_wcsicmp(StringPtr, L"boolean") != 0))
                        {
                            Status = ERROR_WMIMOF_ACTIVE_BAD_TYPE;
                            ErrorMessage(TRUE,
                                         ERROR_WMIMOF_ACTIVE_BAD_TYPE,
                                         MofClassInfo->Name,
                                         StringPtr);
                            BMOFFree(StringPtr);
                            goto done;
                        } else {
                            BMOFFree(StringPtr);
                            if ((! ProviderQualifier) && (! AbstractClass))
                            {
                                //
                                // If Boolean specified, but this is an
                                // embedded class then an error
                                Status = ERROR_WMIMOF_EMBEDDED_CLASS;
                                ErrorMessage(TRUE,
                                         ERROR_WMIMOF_EMBEDDED_CLASS,
                                         MofClassInfo->Name);
                                goto done;
                            }
                            MofClassInfo->Flags |= MOFCI_RESERVED2;
                        }
                    } else {
                        Status = ERROR_WMIMOF_NO_WMIDATAID;
                        ErrorMessage(TRUE,
                                     ERROR_WMIMOF_NO_WMIDATAID,
                                        PropertyName,
                                        MofClassInfo->Name);
                        BMOFFree(StringPtr);
                        goto done;
                    }
                }

                // Do not free PropQualifierList since it is needed for
                // generating header files
                PropQualifierList= NULL;
            }

#if DBG
                printf("\n");
#endif
            if (PropertyName != NULL)
            {
                BMOFFree(PropertyName);
                PropertyName = NULL;
            }
        }
        //
        // Now parse the methods
#if DBG
        printf("Parsing methods\n");
#endif

        if (MethodCount > 0)
        {
            MethodList = (PULONG)BMOFAlloc(MethodCount * sizeof(ULONG));
            if (MethodList == NULL)
            {
                WmipDebugPrint(("WMI: Not enough memory for Method List\n"));
                return(ERROR_NOT_ENOUGH_MEMORY);

            }
        }

        MethodCount = 0;
        ResetObj(ClassObject);
        while(NextMeth(ClassObject, &MethodName, &MofMethodData))
        {
#if DBG
            printf("    %ws - ", MethodName);
#endif
            MethQualifierList = GetMethQualList(ClassObject, MethodName);
            if (MethQualifierList != NULL)
            {
                Status = WmipParseMethodObject(&MofMethodData,
                                               MethQualifierList,
                                               &MethodId);
                if (Status != ERROR_SUCCESS)
                {
                    WmipDebugPrint(("WMI: MofClass %ws Method %ws not parsed properly %x\n",
                                    MofClassInfo->Name, MethodName, Status));
                    ErrorMessage(TRUE,
                                         Status,
                                          MethodName,
                                     MofClassInfo->Name);
                    goto done;
                }

                for (i = 0; i < MethodCount; i++)
                {
                    if (MethodId == MethodList[i])
                    {
                        ErrorMessage(TRUE,
                                 ERROR_WMIMOF_DUPLICATE_METHODID,
                                 MethodName,
                                 MofClassInfo->Name);
                        goto done;
                    }
                }

                MofDataItem = &MofClassInfo->DataItems[DataItemCount+MethodCount];
                MethodList[MethodCount++] = MethodId;

                MofDataItem->Flags = MOFDI_FLAG_METHOD;
                MofDataItem->Name = MethodName;
                MofDataItem->MethodId = MethodId;


                //
                // Get the header name string which is not required
                QualifierType = VT_BSTR;
                Status = WmipFindMofQualifier(MethQualifierList,
                                      L"HeaderName",
                                      &QualifierType,
                                          NULL,
                                      (PVOID)&MofDataItem->HeaderName);

                BMOFFree(MethQualifierList);
                MethQualifierList = NULL;

                //
                // parse the parameters for the method call
                //
                Status = WmipParseMethodParameters(&MofMethodData,
                                                   &MethodClassInfo);

                if (Status == ERROR_SUCCESS)
                {
                    MofDataItem->MethodClassInfo = MethodClassInfo;
                } else if (Status == ERROR_WMIMOF_METHOD_RETURN_NOT_VOID) {
                    ErrorMessage(TRUE,
                                 ERROR_WMIMOF_METHOD_RETURN_NOT_VOID,
                                 MethodName,
                                 MofClassInfo->Name);                                
                }

            }
#if DBG
            printf("\n");
#endif
            // DOn't free method name, kept in MofDataItem
            MethodName = NULL;
        }
    }

done:
    //
    // Cleanup any loose pointers

    if (MethodList != NULL)
    {
        BMOFFree(MethodList);
        MethodList = NULL;
    }


    if (PropertyName != NULL)
    {
        BMOFFree(PropertyName);
        PropertyName = NULL;
    }

    if (MethodName != NULL)
    {
        BMOFFree(MethodName);
        MethodName = NULL;
    }

    if (PropQualifierList != NULL)
    {
        BMOFFree(PropQualifierList);
    }

    if (MethQualifierList != NULL)
    {
        BMOFFree(MethQualifierList);
    }

    if (ClassQualifierList != NULL)
    {
        BMOFFree(ClassQualifierList);
    }

    //
    // Validate that we have all data item ids filled in, fixup any
    // property references for variable length arrays and setup
    // the appropriate version number in the data items.
    FailedStatus = Status;
    Version = 1;
    for (Index = 0; Index < MofClassInfo->DataItemCount; Index++)
    {
        MofDataItem = &MofClassInfo->DataItems[Index];

        if (MofDataItem->Flags & MOFDI_FLAG_VARIABLE_ARRAY)
        {
            //
            // Resolve the variable length array
            //
            Status = WmipResolveVLArray(MofClassInfo,
                                        MofDataItem,
                                        FailedStatus);
            if (Status != ERROR_SUCCESS)
            {
                if (Status == ERROR_WMIMOF_VL_ARRAY_SIZE_NOT_FOUND)
                {
                    WmipDebugPrint(("WMI: Could not resolve vl array size property %ws in class %ws\n",
                            PropertyName, MofClassInfo->Name));
                    ErrorMessage(TRUE,
                                 ERROR_WMIMOF_VL_ARRAY_SIZE_NOT_FOUND,
                                 PropertyName,
                                    MofDataItem->Name,
                                    MofClassInfo->Name);
                } else if (Status == ERROR_WMIMOF_BAD_VL_ARRAY_SIZE_TYPE) {
                    ErrorMessage(TRUE,
                                 ERROR_WMIMOF_BAD_VL_ARRAY_SIZE_TYPE,
                                 MofClassInfo->DataItems[MofDataItem->VariableArraySizeId-1].Name,
                                 MofDataItem->Name,
                                 MofClassInfo->Name);

                } else if (Status == ERROR_WMIMOF_DATAITEM_NOT_FOUND) {
                    ErrorMessage(TRUE,
                                 ERROR_WMIMOF_VL_ARRAY_NOT_FOUND,
                                 MofDataItem->Name,
                                 MofClassInfo->Name);
                } else {
                    ErrorMessage(TRUE,
                                 ERROR_WMIMOF_VL_ARRAY_NOT_RESOLVED,
                                 MofDataItem->Name,
                                 MofClassInfo->Name);
                }
                FailedStatus = Status;
            }
        }

        //
        // Ensure that this data item has got a name, that is the mof
        // writer didn't skip a data item id
        if (MofDataItem->Name == NULL)
        {
            //
            // This data item was not filled in
            Status = ERROR_WMIMOF_MISSING_DATAITEM;
            WmipDebugPrint(("WMI: Missing data item %d in class %ws\n",
                         Index, MofClassInfo->Name));
            ErrorMessage(TRUE,
                         ERROR_WMIMOF_MISSING_DATAITEM,
                         Index+1,
                         MofClassInfo->Name);
            FailedStatus = Status;
        }

        if (FailedStatus != ERROR_SUCCESS)
        {
            continue;
        }

        //
        // Establish version for data item
        if (MofDataItem->Version == 0)
        {
            MofDataItem->Version = Version;
        } else if ((MofDataItem->Version == Version) ||
                   (MofDataItem->Version == Version+1)) {
            Version = MofDataItem->Version;
        } else {
            Status = ERROR_WMIMOF_INCONSISTENT_VERSIONING;
            WmipDebugPrint(("WMI: Inconsistent versioning in class %ws at data item id %d\n",
                          MofClassInfo->Name, Index));
            ErrorMessage(TRUE,
                         ERROR_WMIMOF_INCONSISTENT_VERSIONING,
                         MofDataItem->Name,
                         MofClassInfo->Name);
            FailedStatus = Status;
            // fall thru......
            // continue;
        }
    }


    if (FailedStatus == ERROR_SUCCESS)
    {
        //
        // Mof class parsed OK so we set its version number and link it
        // into the list of classes for the MOF resource
        MofClassInfo->Version = Version;

        //
        // Link this into the list of MofClasses for this mof resource
        InsertTailList(&MofResource->MRMCHead, &MofClass->MCMRList);

    } else {
        WmipUnreferenceMC(MofClass);
        Status = FailedStatus;
    }

    return(Status);
}


//
// The routines below were blantenly stolen without remorse from the ole
// sources in \nt\private\ole32\com\class\compapi.cxx. They are copied here
// so that WMI doesn't need to load in ole32 only to convert a guid string
// into its binary representation.
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------
BOOL HexStringToDword(LPCWSTR lpsz, DWORD * RetValue,
                             int cDigits, WCHAR chDelim)
{
    int Count;
    DWORD Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }

    *RetValue = Value;

    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wUUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
        DWORD dw;

        if (!HexStringToDword(lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(DWORD)*2 + 1;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data2 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data3 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[0] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, '-'))
                return FALSE;
        lpsz += sizeof(BYTE)*2+1;

        pguid->Data4[1] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[2] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[3] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[4] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[5] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[6] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[7] = (BYTE)dw;

        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wGUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (*lpsz == '{' )
        lpsz++;

    if(wUUIDFromString(lpsz, pguid) != TRUE)
        return FALSE;

    lpsz +=36;

    if (*lpsz == '}' )
        lpsz++;

    if (*lpsz != '\0')   // check for zero terminated string - test bug #18307
    {
       return FALSE;
    }

    return TRUE;
}

ULONG GetRootObjectList(
    char *BMofFile,
    CBMOFObjList **ObjectList
    )
{
    ULONG Status;
    ULONG CompressedSizeHigh;

    BMofFileName = BMofFile;
    FileHandle = CreateFile(BMofFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

    if (FileHandle == INVALID_HANDLE_VALUE)
    {
        Status = GetLastError();
        ErrorMessage(TRUE, ERROR_WMIMOF_CANT_ACCESS_FILE, BMofFile, Status);
        return(Status);
    }

    CompressedSize = GetFileSize(FileHandle, &CompressedSizeHigh);

    MappingHandle = CreateFileMapping(FileHandle,
                                      NULL,
                                      PAGE_READONLY,
                                      0, 0,
                                      NULL);
    if (MappingHandle == NULL)
    {
        CloseHandle(FileHandle);
        Status = GetLastError();
        ErrorMessage(TRUE, ERROR_WMIMOF_CANT_ACCESS_FILE, BMofFile, Status);
        return(Status);
    }

    CompressedFileBuffer = MapViewOfFile(MappingHandle,
                               FILE_MAP_READ,
                               0, 0,
                               0);

    if (CompressedFileBuffer == NULL)
    {
        CloseHandle(MappingHandle);
        CloseHandle(FileHandle);
        Status = GetLastError();
        ErrorMessage(TRUE, ERROR_WMIMOF_CANT_ACCESS_FILE, BMofFile, Status);
        return(Status);
    }

    Status = WmipDecompressBuffer(CompressedFileBuffer,
                                  &FileBuffer,
                                  &UncompressedSize);

    if (Status != ERROR_SUCCESS)
    {
        UnmapViewOfFile(CompressedFileBuffer);
        CloseHandle(MappingHandle);
        CloseHandle(FileHandle);
        Status = GetLastError();
        ErrorMessage(TRUE, ERROR_WMIMOF_CANT_ACCESS_FILE, BMofFile, Status);
        return(Status);
    }

    fprintf(stderr, "Binary mof file %s expanded to %d bytes\n", BMofFile,
                                                       UncompressedSize);

    //
    //  Create an object list structure of all the objects in the MOF
    *ObjectList = CreateObjList(FileBuffer);
    if(*ObjectList == NULL)
    {
        UnmapViewOfFile(CompressedFileBuffer);
        CloseHandle(MappingHandle);
        CloseHandle(FileHandle);
        ErrorMessage(TRUE, ERROR_WMI_INVALID_MOF);
        return(ERROR_WMI_INVALID_MOF);
    }
    return(ERROR_SUCCESS);
}

ULONG VerifyClassProperties(
    PMOFRESOURCE MofResource,
    PWCHAR ClassName,
    PWCHAR BaseClassName,
    PMOFCLASS MofClass

)
{
    CBMOFObj *ClassObject;
    PMOFCLASSINFOW MofClassInfo;
    CBMOFDataItem MofPropertyData;
    DWORD QualifierType;
    WCHAR *StringPtr;
    ULONG Status = ERROR_SUCCESS;
    PMOFCLASS MofSuperClass;
    
    ClassObject = (CBMOFObj *)MofClass->ClassObjectHandle;
    MofClassInfo = MofClass->MofClassInfo;
        
    if ( ((MofClassInfo->Flags & MOFCI_RESERVED1) == 0) &&
         ((MofClassInfo->Flags & MOFCI_RESERVED2) == 0) )       
    {
        //
        // This class does not have the instanceName and Active properties
        // so we expect that a superclass should. Look for the superclass
        // and check that
        //
        QualifierType = VT_BSTR;
        Status = WmipFindProperty(ClassObject,
                                      L"__SUPERCLASS",
                                      &MofPropertyData,
                                      &QualifierType,
                                      (PVOID)&StringPtr);
        if (Status == ERROR_SUCCESS)
        {
            //
            // Find the MofClass for the superclass and see if it has
            // the required properties
            //
            MofSuperClass = WmipFindClassInMofResourceByName(MofResource,
                                                StringPtr);
                                            
            if (MofSuperClass != NULL)
            {
                Status = VerifyClassProperties(MofResource,
                                               MofSuperClass->MofClassInfo->Name,
                                               BaseClassName,
                                               MofSuperClass);
            } else {
                //
                // We could not find the superclass, but we will assume
                // that this is ok
                //
                fprintf(stderr, "%s (0): warning RC2135 : Class %ws and all of its base classes do not have InstanceName and Active properties\n",
                    BMofFileName, BaseClassName);
                Status = ERROR_SUCCESS;
            }
            BMOFFree(StringPtr);
            
        } else {
            Status = ERROR_WMIMOF_NO_INSTANCENAME;
            ErrorMessage(TRUE,
                         ERROR_WMIMOF_NO_INSTANCENAME,
                         BaseClassName);
        }
    } else {
        //
        // If its got one of the properties make sure that it has
        // both of them.
    
        if ((MofClassInfo->Flags & MOFCI_RESERVED1) == 0)
        {
            Status = ERROR_WMIMOF_NO_INSTANCENAME;
            ErrorMessage(TRUE,
                         ERROR_WMIMOF_NO_INSTANCENAME,
                         BaseClassName);
        }

        if ((MofClassInfo->Flags & MOFCI_RESERVED2) == 0)
        {
            Status = ERROR_WMIMOF_NO_ACTIVE;
            ErrorMessage(TRUE,
                         ERROR_WMIMOF_NO_ACTIVE,
                         BaseClassName);
        }
    }
    return(Status);
}

ULONG ParseBinaryMofFile(
    char *BMofFile,
    PMOFRESOURCE *ReturnMofResource
    )
{
    ULONG Status;
    CBMOFObjList *MofObjList;
    CBMOFObj *ClassObject;
    PMOFRESOURCE MofResource;
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;
    BOOLEAN CleanupOnly;
    PMOFCLASSINFOW MofClassInfo;

    MofResource = WmipAllocMofResource();
    if (MofResource == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    *ReturnMofResource = MofResource;
    InitializeListHead(&MofResource->MRMCHead);
    Status = GetRootObjectList(BMofFile, &MofObjList);
    if (Status == ERROR_SUCCESS)
    {
        ResetObjList (MofObjList);

        while((Status == ERROR_SUCCESS) &&
              (ClassObject = NextObj(MofObjList)) )
        {
            Status = WmipParseClassObject(MofResource, ClassObject);
            if (Status != ERROR_SUCCESS)
            {
                ErrorMessage(TRUE, ERROR_WMIMOF_CLASS_NOT_PARSED);
            }
        }

        //
        // Now that all classes are parsed we need to go back and find
        // the guids for any embedded classes, or if a class failed
        // to parse then we need to free any embedded class names
        CleanupOnly = (Status != ERROR_SUCCESS);
        MofClassList = MofResource->MRMCHead.Flink;
        while (MofClassList != &MofResource->MRMCHead)
        {
            MofClass = CONTAINING_RECORD(MofClassList,
                                         MOFCLASS,
                                         MCMRList);
            MofClassInfo = MofClass->MofClassInfo;
                                    
            if ((! CleanupOnly) &&
                (MofClassInfo->Flags & MOFCI_RESERVED0))
            {
                //
                // if the class has Provider qualifier, it better have
                // an instancename and Active properties in itself or in a
                // superclass
                //
                Status = VerifyClassProperties(MofResource,
                                               MofClassInfo->Name,
                                               MofClassInfo->Name,
                                               MofClass);
                                        
                CleanupOnly = (Status != ERROR_SUCCESS);
            }
                                    
            Status = WmipFillEmbeddedClasses(MofResource,
                                             MofClassInfo,
                                             CleanupOnly);
            if (Status != ERROR_SUCCESS)
            {
                CleanupOnly = TRUE;
            }
            MofClassList = MofClassList->Flink;
        }

        if (CleanupOnly)
        {
            Status = ERROR_WMI_INVALID_MOF;
        }

        BMOFFree(MofObjList);

        if (Status != ERROR_SUCCESS)
        {
            //
            // Make sure we have a useful Win32 error code and not
            // an internal WMIMOF error code
            Status = ERROR_WMI_INVALID_MOF;
        }
    }
    return(Status);
}

ULONG FilePrintVaList(
    HANDLE FileHandle,
    CHAR *Format,
    va_list pArg
    )
{
    CHAR Buffer[8192];
    ULONG Size, Written;
    ULONG Status;

    Size = _vsnprintf(Buffer, sizeof(Buffer), Format, pArg);
    if (WriteFile(FileHandle,
                       Buffer,
                       Size,
                       &Written,
                       NULL))
    {
        Status = ERROR_SUCCESS;
    } else {
        Status = GetLastError();
    }

    return(Status);
}

ULONG FilePrint(
    HANDLE FileHandle,
    char *Format,
    ...
    )
{
    ULONG Status;
    va_list pArg;

    va_start(pArg, Format);
    Status = FilePrintVaList(FileHandle, Format, pArg);
    return(Status);
}

ULONG GenerateASLTemplate(
    PCHAR TemplateFile
    )
{
    return(ERROR_SUCCESS);
}

ULONG GenerateBinaryMofData(
    HANDLE FileHandle
    )
{
    ULONG Lines;
    ULONG LastLine;
    ULONG i;
    ULONG Index;
    PUCHAR BMofBuffer = (PUCHAR)CompressedFileBuffer;
    PCHAR IndentString = "    ";
    ULONG Status;

    Lines = CompressedSize / 16;
    LastLine = CompressedSize % 16;
    if (LastLine == 0)
    {
        LastLine = 16;
        Lines--;
    }

    for (i = 0; i < Lines; i++)
    {
        Index = i * 16;
        Status = FilePrint(FileHandle, "%s0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x,\r\n",
              IndentString,
              BMofBuffer[Index],
              BMofBuffer[Index+1],
              BMofBuffer[Index+2],
              BMofBuffer[Index+3],
              BMofBuffer[Index+4],
              BMofBuffer[Index+5],
              BMofBuffer[Index+6],
              BMofBuffer[Index+7],
              BMofBuffer[Index+8],
              BMofBuffer[Index+9],
              BMofBuffer[Index+10],
              BMofBuffer[Index+11],
              BMofBuffer[Index+12],
              BMofBuffer[Index+13],
              BMofBuffer[Index+14],
              BMofBuffer[Index+15]);

        if (Status != ERROR_SUCCESS)
        {
            return(Status);
        }
    }

    LastLine--;
    FilePrint(FileHandle, "%s",               IndentString);
    Index = Lines * 16;
    for (i = 0; i < LastLine; i++)
    {
        FilePrint(FileHandle, "0x%02x, ",
                  BMofBuffer[Index+i]);
        if (Status != ERROR_SUCCESS)
        {
            return(Status);
        }
    }

    FilePrint(FileHandle, "0x%02x\r\n",
                  BMofBuffer[Index+i]);

    return(Status);
}

//
// This will loop over the mof class list and print out once for each class
// in the list.
//
// Handle is the file handle to which to write
// MR is the MofResource whose classes are being enumerated
// NamePtr is the variable to place the name of the class
// Counter is the variable to use as a counter
// Format is the format template to use to write out
//

HANDLE GlobalFilePrintHandle;
ULONG FilePrintGlobal(CHAR *Format, ...)
{
    ULONG Status;
    va_list pArg;

    va_start(pArg, Format);
    Status = FilePrintVaList(GlobalFilePrintHandle, Format, pArg);
    return(Status);
}

#define FilePrintMofClassLoop( \
    Handle, \
    MR, \
    NamePtr, \
    Counter, \
    DiscardEmbedded, \
    Format   \
    ) \
{    \
    PLIST_ENTRY MofClassList; \
    PMOFCLASSINFOW ClassInfo; \
    PMOFCLASS MofClass; \
    GlobalFilePrintHandle = TemplateHandle; \
    (Counter) = 0; \
    MofClassList = (MR)->MRMCHead.Flink; \
    while (MofClassList != &(MR)->MRMCHead) \
    { \
        MofClass = CONTAINING_RECORD(MofClassList, MOFCLASS, MCMRList); \
        ClassInfo = MofClass->MofClassInfo; \
        if (! ((DiscardEmbedded) && \
               (ClassInfo->Flags & MOFCI_FLAG_EMBEDDED_CLASS)) ) \
        { \
            (NamePtr) = ClassInfo->Name; \
            FilePrintGlobal Format; \
            (Counter)++; \
        } \
        MofClassList = MofClassList->Flink; \
    } \
}

typedef void (*ENUMMOFCLASSCALLBACK)(
    HANDLE TemplateHandle,
    PMOFCLASS MofClass,
    ULONG Counter,
    PVOID Context
    );

void EnumerateMofClasses(
    HANDLE TemplateHandle,
    PMOFRESOURCE MR,
    ENUMMOFCLASSCALLBACK Callback,
    PVOID Context
    )
{
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;
    ULONG Counter;

    Counter = 0;
    MofClassList = MR->MRMCHead.Flink;
    while (MofClassList != &MR->MRMCHead)
    {
        MofClass = CONTAINING_RECORD(MofClassList, MOFCLASS, MCMRList);
        (*Callback)(TemplateHandle,
                    MofClass,
                    Counter,
                    Context);

        MofClassList = MofClassList->Flink;
        Counter++;
    }
}

void GenerateGuidListTemplate(
    HANDLE TemplateHandle,
    PMOFCLASS MofClass,
    ULONG Counter,
    PVOID Context
    )
{
    PMOFCLASSINFOW ClassInfo;
    PWCHAR GuidName1, GuidSuffix1;

    ClassInfo = MofClass->MofClassInfo;

    if ( ! (ClassInfo->Flags & MOFCI_FLAG_EMBEDDED_CLASS))
    {
        //
        // Only generate code for non embedded classes
        //
        if (ClassInfo->GuidName1 != NULL)
        {
            GuidName1 = ClassInfo->GuidName1;
            GuidSuffix1 = L"";
        } else {
            GuidName1 = ClassInfo->Name;
            GuidSuffix1 = L"Guid";
        }

        FilePrint(TemplateHandle,
              "GUID %wsGUID = %ws%ws;\r\n",
              ClassInfo->Name,
              GuidName1, GuidSuffix1);
      }
}


void GenerateFunctionControlListTemplate(
    HANDLE TemplateHandle,
    PMOFCLASS MofClass,
    ULONG Counter,
    PVOID Context
    )
{
    PMOFCLASSINFOW ClassInfo;

    ClassInfo = MofClass->MofClassInfo;

    if (! (ClassInfo->Flags & MOFCI_FLAG_EMBEDDED_CLASS) )
    {
        FilePrint(TemplateHandle,
"        case %wsGuidIndex:\r\n"
"        {\r\n",
        ClassInfo->Name);

        if (ClassInfo->Flags & MOFCI_FLAG_EVENT)
        {
            FilePrint(TemplateHandle,
"            if (Enable)\r\n"
"            {\r\n"
"                //\r\n"
"                // TODO: Event is being enabled, do anything required to\r\n"
"                //       allow the event to be fired\r\n"
"                //\r\n"
"            } else {\r\n"
"                //\r\n"
"                // TODO: Event is being disabled, do anything required to\r\n"
"                //       keep the event from being fired\r\n"
"                //\r\n"
"            }\r\n");

        } else {
            FilePrint(TemplateHandle,
"            //\r\n"
"            // TODO: Delete this entire case if data block does not have the\r\n"
"            //       WMIREG_FLAG_EXPENSIVE flag set\r\n"
"            //\r\n"
"            if (Enable)\r\n"
"            {\r\n"
"                //\r\n"
"                // TODO: Datablock collection is being enabled. If this\r\n"
"                //       data block has been marked as expensive in the\r\n"
"                //       guid list then this code will be called when the\r\n"
"                //       first data consumer opens this data block. If\r\n"
"                //       anything needs to be done to allow data to be \r\n"
"                //       collected for this data block then it should be\r\n"
"                //       done here\r\n"
"                //\r\n"
"            } else {\r\n"
"                //\r\n"
"                // TODO: Datablock collection is being disabled. If this\r\n"
"                //       data block has been marked as expensive in the\r\n"
"                //       guid list then this code will be called when the\r\n"
"                //       last data consumer closes this data block. If\r\n"
"                //       anything needs to be done to cleanup after data has \r\n"
"                //       been collected for this data block then it should be\r\n"
"                //       done here\r\n"
"                //\r\n"
"            }\r\n");
        }

        FilePrint(TemplateHandle,
"            break;\r\n"
"        }\r\n\r\n");
    }
}

void GenerateSetList(
    HANDLE TemplateHandle,
    PMOFCLASS MofClass,
    ULONG Counter,
    PVOID Context
    )
{
    PCHAR Format = (PCHAR)Context;

    PMOFCLASSINFOW ClassInfo;

    ClassInfo = MofClass->MofClassInfo;
    if (! (ClassInfo->Flags & MOFCI_FLAG_EMBEDDED_CLASS) )
    {
        if (! (ClassInfo->Flags & MOFCI_FLAG_READONLY))
        {
            FilePrint(TemplateHandle, Format, ClassInfo->Name);
        } else {
            FilePrint(TemplateHandle,
"        case %wsGuidIndex:\r\n"
"        {            \r\n"
"            status = STATUS_WMI_READ_ONLY;\r\n"
"            break;\r\n"
"        }\r\n\r\n",
             ClassInfo->Name);
        }
    }
}

void GenerateMethodCTemplate(
    HANDLE TemplateHandle,
    PMOFCLASS MofClass,
    ULONG Counter,
    PVOID Context
    )
{
    PMOFCLASSINFOW ClassInfo;
    ULONG i;
    PMOFDATAITEMW DataItem;

    ClassInfo = MofClass->MofClassInfo;

    if (ClassInfo->MethodCount > 0)
    {

        FilePrint(TemplateHandle,
"        case %wsGuidIndex:\r\n"
"        {\r\n"
"            switch(MethodId)\r\n"
"            {\r\n",
          ClassInfo->Name);

        for (i = 0; i < ClassInfo->MethodCount; i++)
        {
            DataItem = &ClassInfo->DataItems[i+ClassInfo->DataItemCount];
            FilePrint(TemplateHandle,
"                case %ws:\r\n"
"                {            \r\n"
"                    //\r\n"
"                    // TODO: Validate InstanceIndex, InBufferSize \r\n"
"                    //       and Buffer contents to ensure that the \r\n"
"                    //       input buffer is valid and OutBufferSize is\r\n"
"                    //       large enough to return the output data.\r\n"
"                    //\r\n"
"                    break;\r\n"
"                }\r\n\r\n",
                               DataItem->Name);
        }

        FilePrint(TemplateHandle,
"                default:\r\n"
"                {\r\n"
"                    status = STATUS_WMI_ITEMID_NOT_FOUND;\r\n"
"                    break;\r\n"
"                }\r\n"
"            }\r\n"
"            break;\r\n"
"        }\r\n"
"\r\n"
                );
    }
}

BOOLEAN DoesSupportMethods(
    PMOFRESOURCE MR
    )
{
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;

    MofClassList = MR->MRMCHead.Flink;
    while (MofClassList != &MR->MRMCHead)
    {
        MofClass = CONTAINING_RECORD(MofClassList, MOFCLASS, MCMRList);
        if (MofClass->MofClassInfo->MethodCount > 0)
        {
            return(TRUE);
        }
        MofClassList = MofClassList->Flink;
    }
    return(FALSE);
}

BOOLEAN DoesReadOnly(
    PMOFRESOURCE MR
    )
{
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;
    PMOFCLASSINFOW ClassInfo;
    ULONG i;

    MofClassList = MR->MRMCHead.Flink;
    while (MofClassList != &MR->MRMCHead)
    {
        MofClass = CONTAINING_RECORD(MofClassList, MOFCLASS, MCMRList);
        ClassInfo = MofClass->MofClassInfo;

        for (i = 0; i < ClassInfo->DataItemCount; i++)
        {
            if (ClassInfo->DataItems[i].Flags & MOFDI_FLAG_WRITEABLE)
            {
                return(FALSE);
            }
        }

        MofClassList = MofClassList->Flink;
    }
    return(TRUE);
}

PCHAR GetBaseNameFromFileName(
    PCHAR FileName,
    PCHAR BaseName
    )
{
    PCHAR p, p1;
    ULONG Len;

    p = FileName;
    p1 = FileName;
    while ((*p != '.') && (*p != 0))
    {
        if (*p == '\\')
        {
            p1 = p+1;
        }
        p++;
    }

    Len = (ULONG)(p - p1);
    memcpy(BaseName, p1, Len);
    BaseName[Len] = 0;
    return(BaseName);
}


ULONG GenerateCTemplate(
    PCHAR TemplateFile,
    PCHAR HFileName,
    PCHAR XFileName,
    PMOFRESOURCE MofResource
    )
{
    BOOLEAN SupportsMethods, SupportsFunctionControl, IsReadOnly;
    HANDLE TemplateHandle;
    CHAR BaseName[MAX_PATH], BaseXFileName[MAX_PATH], BaseHFileName[MAX_PATH];
    ULONG i;
    PWCHAR ClassName;

    GetBaseNameFromFileName(TemplateFile, BaseName);
    GetBaseNameFromFileName(XFileName, BaseXFileName);
    GetBaseNameFromFileName(XFileName, BaseHFileName);
    BaseName[0] = (CHAR)toupper(BaseName[0]);

    SupportsMethods = DoesSupportMethods(MofResource);
    SupportsFunctionControl = TRUE;
    IsReadOnly = DoesReadOnly(MofResource);

    TemplateHandle = CreateFile(TemplateFile,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

    if ((TemplateHandle == NULL) || (TemplateHandle == INVALID_HANDLE_VALUE))
    {
        return(GetLastError());
    }

    FilePrint(TemplateHandle,
"//\r\n"
"// %s.c - Code generated by wmimofck tool\r\n"
"//\r\n"
"// Finish code by doing all TODO: sections\r\n"
"//\r\n"
"\r\n"
"#include <wdm.h>\r\n"
"#include <wmistr.h>\r\n"
"#include <wmiguid.h>\r\n"
"#include <wmilib.h>\r\n"
"\r\n"
"//\r\n"
"// Include data header for classes\r\n"
"#include \"%s.h\"\r\n"
"\r\n"
"\r\n",
        BaseName,
        BaseHFileName
    );

    FilePrint(TemplateHandle,
"//\r\n"
"// TODO: Place the contents in this device extension into the driver's\r\n"
"//       actual device extension. It is only defined here to supply\r\n"
"//       a device extension so that this file can be compiled on its own\r\n"
"//\r\n"
"#ifdef MAKE_THIS_COMPILE\r\n"
"typedef struct DEVICE_EXTENSION\r\n"
"{\r\n"
"    WMILIB_CONTEXT WmiLib;\r\n"
"    PDEVICE_OBJECT physicalDevObj;\r\n"
"} DEVICE_EXTENSION, *PDEVICE_EXTENSION;\r\n"
"#endif\r\n\r\n"
         );

    FilePrint(TemplateHandle,
"NTSTATUS\r\n"
"%sInitializeWmilibContext(\r\n"
"    IN PWMILIB_CONTEXT WmilibContext\r\n"
"    );\r\n"
"\r\n"
"NTSTATUS\r\n"
"%sFunctionControl(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN WMIENABLEDISABLECONTROL Function,\r\n"
"    IN BOOLEAN Enable\r\n"
"    );\r\n"
"\r\n"
"NTSTATUS\r\n"
"%sExecuteWmiMethod(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN ULONG InstanceIndex,\r\n"
"    IN ULONG MethodId,\r\n"
"    IN ULONG InBufferSize,\r\n"
"    IN ULONG OutBufferSize,\r\n"
"    IN PUCHAR Buffer\r\n"
"    );\r\n"
"\r\n"
"NTSTATUS\r\n"
"%sSetWmiDataItem(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG InstanceIndex,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN ULONG DataItemId,\r\n"
"    IN ULONG BufferSize,\r\n"
"    IN PUCHAR Buffer\r\n"
"    );\r\n"
"\r\n"
"NTSTATUS\r\n"
"%sSetWmiDataBlock(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN ULONG InstanceIndex,\r\n"
"    IN ULONG BufferSize,\r\n"
"    IN PUCHAR Buffer\r\n"
"    );\r\n"
"\r\n"
"NTSTATUS\r\n"
"%sQueryWmiDataBlock(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN ULONG InstanceIndex,\r\n"
"    IN ULONG InstanceCount,\r\n"
"    IN OUT PULONG InstanceLengthArray,\r\n"
"    IN ULONG BufferAvail,\r\n"
"    OUT PUCHAR Buffer\r\n"
"    );\r\n"
"\r\n"
"NTSTATUS\r\n"
"%sQueryWmiRegInfo(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    OUT ULONG *RegFlags,\r\n"
"    OUT PUNICODE_STRING InstanceName,\r\n"
"    OUT PUNICODE_STRING *RegistryPath,\r\n"
"    OUT PUNICODE_STRING MofResourceName,\r\n"
"    OUT PDEVICE_OBJECT *Pdo\r\n"
"    );\r\n"
"\r\n"
"#ifdef ALLOC_PRAGMA\r\n"
"#pragma alloc_text(PAGE,%sQueryWmiRegInfo)\r\n"
"#pragma alloc_text(PAGE,%sQueryWmiDataBlock)\r\n"
"#pragma alloc_text(PAGE,%sSetWmiDataBlock)\r\n"
"#pragma alloc_text(PAGE,%sSetWmiDataItem)\r\n"
"#pragma alloc_text(PAGE,%sExecuteWmiMethod)\r\n"
"#pragma alloc_text(PAGE,%sFunctionControl)\r\n"
"#pragma alloc_text(PAGE,%sInitializeWmilibContext)\r\n"
"#endif\r\n"
"\r\n",
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName,
      BaseName
    );

    FilePrint(TemplateHandle,
"//\r\n"
"// TODO: Decide if your MOF is going to be part of your driver as a resource\r\n"
"//       attached to it. If this is done then all MOF in the resource will be\r\n"
"//       added to the schema. If this is the case be sure that \r\n"
"//       USE_BINARY_MOF_RESOURCE is defined. MOF can also be reported at \r\n"
"//       runtime via a query to the driver. This can be useful if you want\r\n"
"//       the MOF reported to the schema to be dynamic. If MOF is reported via\r\n"
"//       a query then USE_BINARY_MOF_QUERY should be defined.\r\n"
"\r\n"
"#define USE_BINARY_MOF_QUERY\r\n"
"#define USE_BINARY_MOF_RESOURCE\r\n"
"\r\n"
"#ifdef USE_BINARY_MOF_QUERY\r\n"
"//\r\n"
"// MOF data can be reported by a device driver via a resource attached to\r\n"
"// the device drivers image file or in response to a query on the binary\r\n"
"// mof data guid. Here we define global variables containing the binary mof\r\n"
"// data to return in response to a binary mof guid query. Note that this\r\n"
"// data is defined to be in a PAGED data segment since it does not need to\r\n"
"// be in nonpaged memory. Note that instead of a single large mof file\r\n"
"// we could have broken it into multiple individual files. Each file would\r\n"
"// have its own binary mof data buffer and get reported via a different\r\n"
"// instance of the binary mof guid. By mixing and matching the different\r\n"
"// sets of binary mof data buffers a \"dynamic\" composite mof would be created.\r\n"
"\r\n"
"#ifdef ALLOC_DATA_PRAGMA\r\n"
"   #pragma data_seg(\"PAGED\")\r\n"
"#endif\r\n"
"\r\n"
"UCHAR %sBinaryMofData[] =\r\n"
"{\r\n"
"    #include \"%s.x\"\r\n"
"};\r\n"
"#ifdef ALLOC_DATA_PRAGMA\r\n"
"   #pragma data_seg()\r\n"
"#endif\r\n"
"#endif\r\n"
"\r\n",
    BaseName,
    BaseXFileName
    );

    FilePrint(TemplateHandle,
"//\r\n"
"// Define symbolic names for the guid indexes\r\n"
    );

    FilePrintMofClassLoop(TemplateHandle, MofResource, ClassName, i, TRUE,
                          ("#define %wsGuidIndex    %d\r\n",
               ClassName, i));

    FilePrint(TemplateHandle,
"#ifdef USE_BINARY_MOF_QUERY\r\n"
"#define BinaryMofGuidIndex   %d\r\n"
"#endif\r\n",
    i
    );

    FilePrint(TemplateHandle,
"//\r\n"
"// List of guids supported\r\n\r\n"
    );

    EnumerateMofClasses(TemplateHandle,
                        MofResource,
                        GenerateGuidListTemplate,
                        NULL);

    FilePrint(TemplateHandle,
"#ifdef USE_BINARY_MOF_QUERY\r\n"
"GUID %sBinaryMofGUID =         BINARY_MOF_GUID;\r\n"
"#endif\r\n"
"\r\n"
"//\r\n"
"// TODO: Make sure the instance count and flags are set properly for each\r\n"
"//       guid\r\n"
"WMIGUIDREGINFO %sGuidList[] =\r\n"
"{\r\n",
               BaseName, BaseName);

    FilePrintMofClassLoop(TemplateHandle, MofResource, ClassName, i, TRUE,
("    {\r\n"
"        &%wsGUID,                        // Guid\r\n"
"        1,                               // # of instances in each device\r\n"
"        0                                // Flags\r\n"
"    },\r\n",
         ClassName));

    FilePrint(TemplateHandle,
"#ifdef USE_BINARY_MOF_QUERY\r\n"
"    {\r\n"
"        &%sBinaryMofGUID,\r\n"
"        1,\r\n"
"        0\r\n"
"    }\r\n"
"#endif\r\n"
"};\r\n\r\n"
"#define %sGuidCount (sizeof(%sGuidList) / sizeof(WMIGUIDREGINFO))\r\n"
"\r\n",
       BaseName, BaseName, BaseName);

    FilePrint(TemplateHandle,
"//\r\n"
"// We need to hang onto the registry path passed to our driver entry so that\r\n"
"// we can return it in the QueryWmiRegInfo callback. Be sure to store a copy\r\n"
"// of it into %sRegistryPath in the DriverEntry routine\r\n"
"//\r\n"
"extern UNICODE_STRING %sRegistryPath;\r\n\r\n",
              BaseName, BaseName);

    FilePrint(TemplateHandle,
"NTSTATUS %sSystemControl(\r\n"
"    PDEVICE_OBJECT DeviceObject,\r\n"
"    PIRP Irp\r\n"
"    )\r\n"
"/*++\r\n"
"\r\n"
"Routine Description:\r\n"
"\r\n"
"    Dispatch routine for System Control IRPs (MajorFunction == IRP_MJ_SYSTEM_CONTROL)\r\n"
"\r\n"
"Arguments:\r\n"
"\r\n"
"    DeviceObject \r\n"
"    Irp\r\n"
"\r\n"
"Return Value:\r\n"
"\r\n"
"    NT status code\r\n"
"\r\n"
"--*/\r\n"
"{\r\n"
"    PWMILIB_CONTEXT wmilibContext;\r\n"
"    NTSTATUS status;\r\n"
"    SYSCTL_IRP_DISPOSITION disposition;\r\n"
"    PDEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;\r\n"
"\r\n"
"    //\r\n"
"    // TODO: Point at the WMILIB context within the device extension\r\n"
"    wmilibContext = &devExt->WmiLib;\r\n"
"\r\n"
"    //\r\n"
"    // Call Wmilib helper function to crack the irp. If this is a wmi irp\r\n"
"    // that is targetted for this device then WmiSystemControl will callback\r\n"
"    // at the appropriate callback routine.\r\n"
"    //\r\n"
"    status = WmiSystemControl(wmilibContext,\r\n"
"                              DeviceObject,\r\n"
"                              Irp,\r\n"
"                              &disposition);\r\n"
"\r\n"
"    switch(disposition)\r\n"
"    {\r\n"
"        case IrpProcessed:\r\n"
"        {\r\n"
"            //\r\n"
"            // This irp has been processed and may be completed or pending.\r\n"
"            break;\r\n"
"        }\r\n"
"\r\n"
"        case IrpNotCompleted:\r\n"
"        {\r\n"
"            //\r\n"
"            // This irp has not been completed, but has been fully processed.\r\n"
"            // we will complete it now.\r\n"
"            IoCompleteRequest(Irp, IO_NO_INCREMENT);\r\n"
"            break;\r\n"
"        }\r\n"
"\r\n"
"        case IrpForward:\r\n"
"        case IrpNotWmi:\r\n"
"        default:\r\n"
"        {\r\n"
"            //\r\n"
"            // This irp is either not a WMI irp or is a WMI irp targetted\r\n"
"            // at a device lower in the stack.\r\n"
"\r\n"
"            // TODO: Forward IRP down the device stack to the next device\r\n"
"            //       Or if this is a PDO then just complete the irp without\r\n"
"            //       touching it.\r\n"
"            break;\r\n"
"        }\r\n"
"\r\n"
"    }\r\n"
"\r\n"
"    return(status);\r\n"
"}\r\n",
         BaseName);

    FilePrint(TemplateHandle,
"NTSTATUS\r\n"
"%sQueryWmiRegInfo(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    OUT ULONG *RegFlags,\r\n"
"    OUT PUNICODE_STRING InstanceName,\r\n"
"    OUT PUNICODE_STRING *RegistryPath,\r\n"
"    OUT PUNICODE_STRING MofResourceName,\r\n"
"    OUT PDEVICE_OBJECT *Pdo\r\n"
"    )\r\n"
"/*++\r\n"
"\r\n"
"Routine Description:\r\n"
"\r\n"
"    This routine is a callback into the driver to retrieve the list of\r\n"
"    guids or data blocks that the driver wants to register with WMI. This\r\n"
"    routine may not pend or block. Driver should NOT call\r\n"
"    WmiCompleteRequest.\r\n"
"\r\n"
"Arguments:\r\n"
"\r\n"
"    DeviceObject is the device whose registration info is being queried\r\n"
"\r\n"
"    *RegFlags returns with a set of flags that describe the guids being\r\n"
"        registered for this device. If the device wants enable and disable\r\n"
"        collection callbacks before receiving queries for the registered\r\n"
"        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the\r\n"
"        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case\r\n"
"        the instance name is determined from the PDO associated with the\r\n"
"        device object. Note that the PDO must have an associated devnode. If\r\n"
"        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique\r\n"
"        name for the device.\r\n"
"\r\n"
"    InstanceName returns with the instance name for the guids if\r\n"
"        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The\r\n"
"        caller will call ExFreePool with the buffer returned.\r\n"
"\r\n"
"    *RegistryPath returns with the registry path of the driver. The caller\r\n"
"         does NOT free this buffer.\r\n"
"\r\n"
"    *MofResourceName returns with the name of the MOF resource attached to\r\n"
"        the binary file. If the driver does not have a mof resource attached\r\n"
"        then this can be returned as NULL. The caller does NOT free this\r\n"
"        buffer.\r\n"
"\r\n"
"    *Pdo returns with the device object for the PDO associated with this\r\n"
"        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in\r\n"
"        *RegFlags.\r\n"
"\r\n"
"Return Value:\r\n"
"\r\n"
"    status\r\n"
"\r\n"
"--*/\r\n"
"{\r\n"
"    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;\r\n"
"\r\n"
"    //\r\n"
"    // Return the registry path for this driver. This is required so WMI\r\n"
"    // can find your driver image and can attribute any eventlog messages to\r\n"
"    // your driver.\r\n"
"    *RegistryPath = &%sRegistryPath;\r\n"
"        \r\n"
"#ifndef USE_BINARY_MOF_RESOURCE\r\n"
"    //\r\n"
"    // Return the name specified in the .rc file of the resource which\r\n"
"    // contains the bianry mof data. By default WMI will look for this\r\n"
"    // resource in the driver image (.sys) file, however if the value\r\n"
"    // MofImagePath is specified in the driver's registry key\r\n"
"    // then WMI will look for the resource in the file specified there.\r\n"
"    RtlInitUnicodeString(MofResourceName, L\"MofResourceName\");\r\n"
"#endif\r\n"
"\r\n"
"    //\r\n"
"    // Specify that the driver wants WMI to automatically generate instance\r\n"
"    // names for all of the data blocks based upon the device stack's\r\n"
"    // device instance id. Doing this is STRONGLY recommended since additional\r\n"
"    // information about the device would then be available to callers.\r\n"
"    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;\r\n"
"\r\n"
"    //\r\n"
"    // TODO: Assign the physical device object for the device stack to *Pdo\r\n"
"    *Pdo = devExt->physicalDevObj;\r\n"
"\r\n"
"    return(STATUS_SUCCESS);\r\n"
"}\r\n"
"\r\n",
      BaseName, BaseName);

    FilePrint(TemplateHandle,
"NTSTATUS\r\n"
"%sQueryWmiDataBlock(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN ULONG InstanceIndex,\r\n"
"    IN ULONG InstanceCount,\r\n"
"    IN OUT PULONG InstanceLengthArray,\r\n"
"    IN ULONG BufferAvail,\r\n"
"    OUT PUCHAR Buffer\r\n"
"    )\r\n"
"/*++\r\n"
"\r\n"
"Routine Description:\r\n"
"\r\n"
"    This routine is a callback into the driver to query for the contents of\r\n"
"    all instances of a data block. If the driver can satisfy the query within\r\n"
"    the callback it should call WmiCompleteRequest to complete the irp before\r\n"
"    returning to the caller. Or the driver can return STATUS_PENDING if the\r\n"
"    irp cannot be completed immediately and must then call WmiCompleteRequest\r\n"
"    once the query is satisfied.\r\n"
"\r\n"
"Arguments:\r\n"
"\r\n"
"    DeviceObject is the device whose data block is being queried\r\n"
"\r\n"
"    Irp is the Irp that makes this request\r\n"
"\r\n"
"    GuidIndex is the index into the list of guids provided when the\r\n"
"        device registered\r\n"
"\r\n"
"    InstanceCount is the number of instnaces expected to be returned for\r\n"
"        the data block.\r\n"
"\r\n"
"    InstanceLengthArray is a pointer to an array of ULONG that returns the\r\n"
"        lengths of each instance of the data block. If this is NULL then\r\n"
"        there was not enough space in the output buffer to fufill the request\r\n"
"        so the irp should be completed with the buffer needed.\r\n"
"\r\n"
"    BufferAvail on entry has the maximum size available to write the data\r\n"
"        blocks.\r\n"
"\r\n"
"    Buffer on return is filled with the returned data blocks. Note that each\r\n"
"        instance of the data block must be aligned on a 8 byte boundry.\r\n"
"\r\n"
"\r\n"
"Return Value:\r\n"
"\r\n"
"    status\r\n"
"\r\n"
"--*/\r\n"
"{\r\n"
"    NTSTATUS status = STATUS_UNSUCCESSFUL;\r\n"
"    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;\r\n"
"    ULONG sizeNeeded;\r\n"
"\r\n"
"    switch(GuidIndex)\r\n"
"    {\r\n"
       ,BaseName        );

    FilePrintMofClassLoop(TemplateHandle, MofResource, ClassName, i, TRUE, (
"        case %wsGuidIndex:\r\n"
"        {\r\n"
"            //\r\n"
"            // TODO: Check that the size of the buffer passed is large enough\r\n"
"            //       for all of the instances requested and if so fill Buffer\r\n"
"            //       with the data. Make sure that each instance begins on an\r\n"
"            //       8 byte boundry.\r\n"
"            //\r\n"
"            break;\r\n"
"        }\r\n\r\n",
                          ClassName));

    FilePrint(TemplateHandle,
"#ifdef USE_BINARY_MOF_QUERY\r\n"
"        case BinaryMofGuidIndex:\r\n"
"        {\r\n"
"            //\r\n"
"            // TODO: If the driver supports reporting MOF dynamically, \r\n"
"            //       change this code to handle multiple instances of the\r\n"
"            //       binary mof guid and return only those instances that\r\n"
"            //       should be reported to the schema\r\n"
"            //\r\n"
"            sizeNeeded = sizeof(%sBinaryMofData);\r\n"
"\r\n"
"            if (BufferAvail < sizeNeeded)\r\n"
"            {\r\n"
"                status = STATUS_BUFFER_TOO_SMALL;\r\n"
"            } else {\r\n"
"                RtlCopyMemory(Buffer, %sBinaryMofData, sizeNeeded);\r\n"
"                *InstanceLengthArray = sizeNeeded;\r\n"
"                status = STATUS_SUCCESS;\r\n"
"            }\r\n"
"            break;\r\n"
"        }\r\n"
"#endif\r\n"
"\r\n"
"        default:\r\n"
"        {\r\n"
"            status = STATUS_WMI_GUID_NOT_FOUND;\r\n"
"            break;\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    //\r\n"
"    // Complete the irp. If there was not enough room in the output buffer\r\n"
"    // then status is STATUS_BUFFER_TOO_SMALL and sizeNeeded has the size\r\n"
"    // needed to return all of the data. If there was enough room then\r\n"
"    // status is STATUS_SUCCESS and sizeNeeded is the actual number of bytes\r\n"
"    // being returned.\r\n"
"    status = WmiCompleteRequest(\r\n"
"                                     DeviceObject,\r\n"
"                                     Irp,\r\n"
"                                     status,\r\n"
"                                     sizeNeeded,\r\n"
"                                     IO_NO_INCREMENT);\r\n"
"\r\n"
"    return(status);\r\n"
"}\r\n"
           , BaseName, BaseName);

    if (! IsReadOnly)
    {
        FilePrint(TemplateHandle,
"\r\n"
"NTSTATUS\r\n"
"%sSetWmiDataBlock(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN ULONG InstanceIndex,\r\n"
"    IN ULONG BufferSize,\r\n"
"    IN PUCHAR Buffer\r\n"
"    )\r\n"
"/*++\r\n"
"\r\n"
"Routine Description:\r\n"
"\r\n"
"    This routine is a callback into the driver to change the contents of\r\n"
"    a data block. If the driver can change the data block within\r\n"
"    the callback it should call WmiCompleteRequest to complete the irp before\r\n"
"    returning to the caller. Or the driver can return STATUS_PENDING if the\r\n"
"    irp cannot be completed immediately and must then call WmiCompleteRequest\r\n"
"    once the data is changed.\r\n"
"\r\n"
"Arguments:\r\n"
"\r\n"
"    DeviceObject is the device whose data block is being queried\r\n"
"\r\n"
"    Irp is the Irp that makes this request\r\n"
"\r\n"
"    GuidIndex is the index into the list of guids provided when the\r\n"
"        device registered\r\n"
"\r\n"
"    BufferSize has the size of the data block passed\r\n"
"\r\n"
"    Buffer has the new values for the data block\r\n"
"\r\n"
"\r\n"
"Return Value:\r\n"
"\r\n"
"    status\r\n"
"\r\n"
"--*/\r\n"
"{\r\n"
"    NTSTATUS status;\r\n"
"    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;\r\n"
"\r\n"
"\r\n"
"    switch(GuidIndex)\r\n"
"    {\r\n"
    , BaseName);

        EnumerateMofClasses(TemplateHandle,
                            MofResource,
                            GenerateSetList,
"\r\n"
"        case %wsGuidIndex:\r\n"
"        {            \r\n"
"            //\r\n"
"            // TODO: Validate InstanceIndex, BufferSize and Buffer contents\r\n"
"            //       and if valid then set the underlying data block, write\r\n"
"            //       to the hardware, etc.\r\n"
"            break;\r\n"
"        }\r\n"
"\r\n"
           );

        FilePrint(TemplateHandle,
"        default:\r\n"
"        {\r\n"
"            status = STATUS_WMI_GUID_NOT_FOUND;\r\n"
"            break;\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    status = WmiCompleteRequest(\r\n"
"                                     DeviceObject,\r\n"
"                                     Irp,\r\n"
"                                     status,\r\n"
"                                     0,\r\n"
"                                     IO_NO_INCREMENT);\r\n"
"\r\n"
"    return(status);\r\n"
"\r\n"
"\r\n"
"}\r\n"
           );
        FilePrint(TemplateHandle,
"       \r\n"
"NTSTATUS\r\n"
"%sSetWmiDataItem(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN ULONG InstanceIndex,\r\n"
"    IN ULONG DataItemId,\r\n"
"    IN ULONG BufferSize,\r\n"
"    IN PUCHAR Buffer\r\n"
"    )\r\n"
"/*++\r\n"
"\r\n"
"Routine Description:\r\n"
"\r\n"
"    This routine is a callback into the driver to change the contents of\r\n"
"    a data block. If the driver can change the data block within\r\n"
"    the callback it should call WmiCompleteRequest to complete the irp before\r\n"
"    returning to the caller. Or the driver can return STATUS_PENDING if the\r\n"
"    irp cannot be completed immediately and must then call WmiCompleteRequest\r\n"
"    once the data is changed.\r\n"
"\r\n"
"Arguments:\r\n"
"\r\n"
"    DeviceObject is the device whose data block is being changed\r\n"
"\r\n"
"    Irp is the Irp that makes this request\r\n"
"\r\n"
"    GuidIndex is the index into the list of guids provided when the\r\n"
"        device registered\r\n"
"\r\n"
"    DataItemId has the id of the data item being set\r\n"
"\r\n"
"    BufferSize has the size of the data item passed\r\n"
"\r\n"
"    Buffer has the new values for the data item\r\n"
"\r\n"
"\r\n"
"Return Value:\r\n"
"\r\n"
"    status\r\n"
"\r\n"
"--*/\r\n"
"{\r\n"
"    NTSTATUS status;\r\n"
"\r\n"
"    switch(GuidIndex)\r\n"
"    {\r\n"
        , BaseName);

        EnumerateMofClasses(TemplateHandle,
                            MofResource,
                            GenerateSetList,
"        case %wsGuidIndex:\r\n"
"        {            \r\n"
"            //\r\n"
"            // TODO: Validate InstanceIndex, DataItemId, BufferSize \r\n"
"            //       and Buffer contents\r\n"
"            //       and if valid then set the underlying data item, write\r\n"
"            //       to the hardware, etc.\r\n"
"            break;\r\n"
"        }\r\n");


        FilePrint(TemplateHandle,
"        default:\r\n"
"        {\r\n"
"            status = STATUS_WMI_GUID_NOT_FOUND;\r\n"
"            break;\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    status = WmiCompleteRequest(\r\n"
"                                     DeviceObject,\r\n"
"                                     Irp,\r\n"
"                                     status,\r\n"
"                                     0,\r\n"
"                                     IO_NO_INCREMENT);\r\n"
"\r\n"
"    return(status);\r\n"
"}\r\n"
        );

    }

    if (SupportsMethods)
    {

        FilePrint(TemplateHandle,
"NTSTATUS\r\n"
"%sExecuteWmiMethod(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN ULONG InstanceIndex,\r\n"
"    IN ULONG MethodId,\r\n"
"    IN ULONG InBufferSize,\r\n"
"    IN ULONG OutBufferSize,\r\n"
"    IN PUCHAR Buffer\r\n"
"    )\r\n"
"/*++\r\n"
"\r\n"
"Routine Description:\r\n"
"\r\n"
"    This routine is a callback into the driver to execute a method. If\r\n"
"    the driver can complete the method within the callback it should\r\n"
"    call WmiCompleteRequest to complete the irp before returning to the\r\n"
"    caller. Or the driver can return STATUS_PENDING if the irp cannot be\r\n"
"    completed immediately and must then call WmiCompleteRequest once the\r\n"
"    data is changed.\r\n"
"\r\n"
"Arguments:\r\n"
"\r\n"
"    DeviceObject is the device whose method is being executed\r\n"
"\r\n"
"    Irp is the Irp that makes this request\r\n"
"\r\n"
"    GuidIndex is the index into the list of guids provided when the\r\n"
"        device registered\r\n"
"\r\n"
"    MethodId has the id of the method being called\r\n"
"\r\n"
"    InBufferSize has the size of the data block passed in as the input to\r\n"
"        the method.\r\n"
"\r\n"
"    OutBufferSize on entry has the maximum size available to write the\r\n"
"        returned data block.\r\n"
"\r\n"
"    Buffer is filled with the input buffer on entry and returns with\r\n"
"         the output data block\r\n"
"\r\n"
"Return Value:\r\n"
"\r\n"
"    status\r\n"
"\r\n"
"--*/\r\n"
"{\r\n"
"    ULONG sizeNeeded = 0;\r\n"
"    NTSTATUS status;\r\n"
"\r\n"
"    switch(GuidIndex)\r\n"
"    {\r\n"
"            \r\n"
        , BaseName);

        EnumerateMofClasses(TemplateHandle,
                            MofResource,
                            GenerateMethodCTemplate,
                            NULL);


        FilePrint(TemplateHandle,
"        default:\r\n"
"        {\r\n"
"            status = STATUS_WMI_GUID_NOT_FOUND;\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    status = WmiCompleteRequest(\r\n"
"                                     DeviceObject,\r\n"
"                                     Irp,\r\n"
"                                     status,\r\n"
"                                     sizeNeeded,\r\n"
"                                     IO_NO_INCREMENT);\r\n"
"\r\n"
"    return(status);\r\n"
"}\r\n"
            );
    }

    if (SupportsFunctionControl)
    {
        FilePrint(TemplateHandle,
"NTSTATUS\r\n"
"%sFunctionControl(\r\n"
"    IN PDEVICE_OBJECT DeviceObject,\r\n"
"    IN PIRP Irp,\r\n"
"    IN ULONG GuidIndex,\r\n"
"    IN WMIENABLEDISABLECONTROL Function,\r\n"
"    IN BOOLEAN Enable\r\n"
"    )\r\n"
"/*++\r\n"
"\r\n"
"Routine Description:\r\n"
"\r\n"
"    This routine is a callback into the driver to enabled or disable event\r\n"
"    generation or data block collection. A device should only expect a\r\n"
"    single enable when the first event or data consumer enables events or\r\n"
"    data collection and a single disable when the last event or data\r\n"
"    consumer disables events or data collection. Data blocks will only\r\n"
"    receive collection enable/disable if they were registered as requiring\r\n"
"    it. If the driver can complete enabling/disabling within the callback it\r\n"
"    should call WmiCompleteRequest to complete the irp before returning to\r\n"
"    the caller. Or the driver can return STATUS_PENDING if the irp cannot be\r\n"
"    completed immediately and must then call WmiCompleteRequest once the\r\n"
"    data is changed.\r\n"
"\r\n"
"Arguments:\r\n"
"\r\n"
"    DeviceObject is the device object\r\n"
"\r\n"
"    GuidIndex is the index into the list of guids provided when the\r\n"
"        device registered\r\n"
"\r\n"
"    Function specifies which functionality is being enabled or disabled\r\n"
"\r\n"
"    Enable is TRUE then the function is being enabled else disabled\r\n"
"\r\n"
"Return Value:\r\n"
"\r\n"
"    status\r\n"
"\r\n"
"--*/\r\n"
"{\r\n"
"    NTSTATUS status;\r\n"
"\r\n"
"    switch(GuidIndex)\r\n"
"    {\r\n",
        BaseName);

        EnumerateMofClasses(TemplateHandle,
                            MofResource,
                            GenerateFunctionControlListTemplate,
                            NULL);

        FilePrint(TemplateHandle,
"        \r\n"
"        default:\r\n"
"        {\r\n"
"            status = STATUS_WMI_GUID_NOT_FOUND;\r\n"
"            break;\r\n"
"        }\r\n"
"    }\r\n"
"    \r\n"
"    status = WmiCompleteRequest(\r\n"
"                                     DeviceObject,\r\n"
"                                     Irp,\r\n"
"                                     STATUS_SUCCESS,\r\n"
"                                     0,\r\n"
"                                     IO_NO_INCREMENT);\r\n"
"    return(status);\r\n"
"}\r\n"
             );

    }


    FilePrint(TemplateHandle,
"NTSTATUS\r\n"
"%sInitializeWmilibContext(\r\n"
"    IN PWMILIB_CONTEXT WmilibContext\r\n"
"    )\r\n"
"/*++\r\n"
"\r\n"
"Routine Description:\r\n"
"\r\n"
"    This routine will initialize the wmilib context structure with the\r\n"
"    guid list and the pointers to the wmilib callback functions. This routine\r\n"
"    should be called before calling IoWmiRegistrationControl to register\r\n"
"    your device object.\r\n"
"\r\n"
"Arguments:\r\n"
"\r\n"
"    WmilibContext is pointer to the wmilib context.\r\n"
"\r\n"
"Return Value:\r\n"
"\r\n"
"    status\r\n"
"\r\n"
"--*/\r\n"
"{\r\n"
"    RtlZeroMemory(WmilibContext, sizeof(WMILIB_CONTEXT));\r\n"
"    \r\n"
"    WmilibContext->GuidCount = %sGuidCount;\r\n"
"    WmilibContext->GuidList = %sGuidList;    \r\n"
"    \r\n"
"    WmilibContext->QueryWmiRegInfo = %sQueryWmiRegInfo;\r\n"
"    WmilibContext->QueryWmiDataBlock = %sQueryWmiDataBlock;\r\n",
        BaseName,
        BaseName,
        BaseName,
        BaseName,
        BaseName);

    if (! IsReadOnly)
    {
        FilePrint(TemplateHandle,
"    WmilibContext->SetWmiDataBlock = %sSetWmiDataBlock;\r\n"
"    WmilibContext->SetWmiDataItem = %sSetWmiDataItem;\r\n",
                   BaseName, BaseName);
    }

    if (SupportsMethods)
    {
        FilePrint(TemplateHandle,
"    WmilibContext->ExecuteWmiMethod = %sExecuteWmiMethod;\r\n",
                   BaseName);
    }

    if (SupportsFunctionControl)
    {
        FilePrint(TemplateHandle,
"    WmilibContext->WmiFunctionControl = %sFunctionControl;\r\n",
                   BaseName);
    }

    FilePrint(TemplateHandle,
"\r\n"
"    return(STATUS_SUCCESS);\r\n"
"}"
                  );

    CloseHandle(TemplateHandle);
    return(ERROR_SUCCESS);
}

//
// A data item is variable length if it is a variable length array or a
// string that does not have a maxiumum length specified
//
#define WmipIsDataitemVariableLen(DataItem) \
     ( (DataItem->Flags & MOFDI_FLAG_VARIABLE_ARRAY) || \
       ((DataItem->DataType == MOFString) && \
        (DataItem->MaxLen == 0)) ||  \
       (DataItem->DataType == MOFZTString) || \
       (DataItem->DataType == MOFAnsiString) )
                                            

BOOLEAN ClassCanCreateHeader(
    PMOFCLASSINFOW ClassInfo,
    ULONG RequiredFlags,
    PULONG ItemCount
    )
{
    ULONG i;
    BOOLEAN HasVariableLength = FALSE;
    PMOFDATAITEMW DataItem;
    ULONG Count;

    Count = 0;
    for (i = 0; i < ClassInfo->DataItemCount; i++)
    {
        DataItem = &ClassInfo->DataItems[i];
            
        if ((RequiredFlags == 0xffffffff) ||
            (DataItem->Flags & RequiredFlags))
            
        {
            if (HasVariableLength)
            {
                *ItemCount = Count;
                return(FALSE);
            }

            Count++;

            HasVariableLength = (! ForceHeaderGeneration) &&
                                WmipIsDataitemVariableLen(DataItem);
        }
    }

    *ItemCount = Count;
    return(TRUE);
}

PWCHAR MofDataTypeText[15] =
{
    L"LONG",           // 32bit integer
    L"ULONG",          // 32bit unsigned integer
    L"LONGLONG",         // 64bit integer
    L"ULONGLONG",         // 32bit unsigned integer
    L"SHORT",         // 16bit integer
    L"USHORT",         // 16bit unsigned integer
    L"CHAR",         // 8bit integer
    L"UCHAR",         // 8bit unsigned integer
    L"WCHAR",         // Wide (16bit) character
    L"DATETIME",      // Date field
    L"BOOLEAN",         // 8bit Boolean value
    L"MOFEmbedded",         // Embedded class
    L"MOFString",         // Counted String type
    L"MOFZTString",         // NULL terminated unicode string
    L"MOFAnsiString"         // NULL terminated ansi string
};


ULONG GenerateClassHeader(
    HANDLE TemplateHandle,
    PMOFRESOURCE MofResource,
    PWCHAR ClassName,
    PMOFCLASSINFOW ClassInfo,
    ULONG RequiredFlags
    )
{
    ULONG Status;
    CBMOFDataItem *PropertyObject;
    CBMOFQualList *PropertyQualifier;
    ULONG Status2, QualifierType;
    PVOID ptr;
    ULONG ValueMapCount, DefineValuesCount, ValuesCount;
    PWCHAR *ValueMapPtr, *DefineValuesPtr, *ValuesPtr;
    ULONG BitMapCount, DefineBitMapCount, BitValuesCount, BitMapValue;
    PWCHAR *BitMapPtr, *DefineBitMapPtr, *BitValuesPtr;
    PWCHAR DefineDataId;
    WCHAR DefineDataIdText[MAX_PATH];
    PMOFDATAITEMW DataItem;
    PWCHAR Description;
    PMOFCLASS EmbeddedClass;
    ULONG i, j;
    PWCHAR DataTypeText;
    ULONG ItemCount;
    PWCHAR VLCommentText = L"  ";

    WmipDebugPrint(("Generate class header for %ws\n", ClassName));
    if ((ClassCanCreateHeader(ClassInfo, RequiredFlags, &ItemCount)) &&
        (ItemCount != 0))
    {
        Status = FilePrint(TemplateHandle,
                           "typedef struct _%ws\r\n{\r\n",
                           ClassName);
        for (i = 0; i < ClassInfo->DataItemCount; i++)
        {
            DataItem = &ClassInfo->DataItems[i];
            if ((RequiredFlags == 0xffffffff) ||
                (DataItem->Flags & RequiredFlags))
            {
                PropertyQualifier = (CBMOFQualList *)DataItem->PropertyQualifierHandle;                             
                //
                // Handle any bit maps via the DefineBitMap qualifier
                //
                QualifierType = VT_ARRAY | VT_BSTR;
                if (WmipFindMofQualifier(PropertyQualifier,
                                         L"DefineBitMap",
                                         &QualifierType,
                                         &DefineBitMapCount,
                                         &DefineBitMapPtr) == ERROR_SUCCESS)
                {
                    QualifierType = VT_ARRAY | VT_BSTR;
                    if (WmipFindMofQualifier(PropertyQualifier,
                                             L"BitValues",
                                             &QualifierType,
                                             &BitValuesCount,
                                             &BitValuesPtr) == ERROR_SUCCESS)
                    {
                        if (DefineBitMapCount == BitValuesCount)
                        {
                            QualifierType = VT_ARRAY | VT_BSTR;
                            if (WmipFindMofQualifier(PropertyQualifier,
                                L"BitMap",
                                &QualifierType,
                                &BitMapCount,
                                &BitMapPtr) != ERROR_SUCCESS)
                            {
                                BitMapPtr = NULL;
                            }
                            
                            FilePrint(TemplateHandle,
                                      "\r\n");
                            for (j = 0; j < DefineBitMapCount; j++)
                            {
                                if ((BitMapPtr != NULL) &&
                                      (j < BitMapCount) &&
                                      (BitMapPtr[j] != NULL))
                                {
                                    FilePrint(TemplateHandle,
                                              "// %ws\r\n",
                                              BitMapPtr[j]);
                                }
                                BitMapValue = 1 << _wtoi(BitValuesPtr[j]);
                                FilePrint(TemplateHandle,
                                          "#define %ws 0x%x\r\n",
                                          DefineBitMapPtr[j],
                                          BitMapValue);
                            }
                            FilePrint(TemplateHandle,
                                      "\r\n");
                        } else {
                            FilePrint(TemplateHandle, "// Warning: Cannot create Bitmap definitions\r\n//          Requires DefineBitMap and BitValues qualifier with same number of elements\r\n\r\n");
                        }
                        
                        for (j = 0; j < BitValuesCount; j++)
                        {
                            BMOFFree(BitValuesPtr[j]);
                        }
                        BMOFFree(BitValuesPtr);
                        
                        if (BitMapPtr != NULL)
                        {
                            for (j = 0; j < BitMapCount; j++)
                            {
                                BMOFFree(BitMapPtr[j]);
                            }
                            BMOFFree(BitMapPtr);
                        }
                    } else {
                        FilePrint(TemplateHandle, "// Warning: Cannot create Bitmap definitions\r\n//          Requires DefineBitMap and BitValues qualifier with same number of elements\r\n\r\n");
                    }
                    
                    for (j = 0; j < DefineBitMapCount; j++)
                    {
                        BMOFFree(DefineBitMapPtr[j]);
                    }
                    BMOFFree(DefineBitMapPtr);
                }
                
                //
                // Handle any enumerations via the DefineValueMap qualifier
                //
                QualifierType = VT_ARRAY | VT_BSTR;
                if (WmipFindMofQualifier(PropertyQualifier,
                                         L"DefineValues",
                                         &QualifierType,
                                         &DefineValuesCount,
                                         &DefineValuesPtr) == ERROR_SUCCESS)
                {
                    QualifierType = VT_ARRAY | VT_BSTR;
                    if (WmipFindMofQualifier(PropertyQualifier,
                                             L"ValueMap",
                                             &QualifierType,
                                             &ValueMapCount,
                                             &ValueMapPtr) == ERROR_SUCCESS)
                    {
                        if (DefineValuesCount == ValueMapCount)
                        {
                            QualifierType = VT_ARRAY | VT_BSTR;
                            if (WmipFindMofQualifier(PropertyQualifier,
                                L"Values",
                                &QualifierType,
                                &ValuesCount,
                                &ValuesPtr) != ERROR_SUCCESS)
                            {
                                ValuesPtr = NULL;
                            }
                            
                            FilePrint(TemplateHandle,
                                      "\r\n");
                            for (j = 0; j < DefineValuesCount; j++)
                            {
                                if ((ValuesPtr != NULL) &&
                                      (j < ValuesCount) &&
                                      (ValuesPtr[j] != NULL))
                                {
                                    FilePrint(TemplateHandle,
                                              "// %ws\r\n",
                                              ValuesPtr[j]);
                                }
                                FilePrint(TemplateHandle,
                                          "#define %ws %ws\r\n",
                                          DefineValuesPtr[j],
                                          ValueMapPtr[j]);
                            }
                            FilePrint(TemplateHandle,
                                      "\r\n");
                        } else {
                            FilePrint(TemplateHandle, "// Warning: Cannot create ValueMap enumeration definitions\r\n//          Requires DefineValues and ValueMap qualifier with same number of elements\r\n\r\n");
                        }
                        
                        for (j = 0; j < ValueMapCount; j++)
                        {
                            BMOFFree(ValueMapPtr[j]);
                        }
                        BMOFFree(ValueMapPtr);
                        
                        if (ValuesPtr != NULL)
                        {
                            for (j = 0; j < ValuesCount; j++)
                            {
                                BMOFFree(ValuesPtr[j]);
                            }
                            BMOFFree(ValuesPtr);
                        }
                    } else {
                        FilePrint(TemplateHandle, "// Warning: Cannot create ValueMap enumeration definitions\r\n//          Requires DefineValues and ValueMap qualifier with same number of elements\r\n\r\n");
                    }
                    
                    for (j = 0; j < DefineValuesCount; j++)
                    {
                        BMOFFree(DefineValuesPtr[j]);
                    }
                    BMOFFree(DefineValuesPtr);
                }
                
                //
                // Generate structure element from property information
                //
                if (DataItem->Description != NULL)
                {
                    Description = DataItem->Description;
                } else {
                    Description = L"";
                }
                
                //
                // Produce a #define for the data id of the property
                //
                QualifierType = VT_BSTR;
                if (WmipFindMofQualifier(PropertyQualifier,
                                         L"DefineDataId",
                                         &QualifierType,
                                         NULL,
                                         &DefineDataId) != ERROR_SUCCESS)
                {
                    swprintf(DefineDataIdText,
                             L"%ws_%ws",
                             ClassName,
                             DataItem->Name);
                    DefineDataId = DefineDataIdText;
                }
                
                if (DataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS)
                {
                    // Get Embedded Class name
                    EmbeddedClass = WmipFindClassInMofResourceByGuid(
                        MofResource,
                        &DataItem->EmbeddedClassGuid);
                    
                    if (EmbeddedClass != NULL)
                    {
                        if (EmbeddedClass->MofClassInfo->HeaderName != NULL)
                        {
                            DataTypeText = EmbeddedClass->MofClassInfo->HeaderName;
                        } else {
                            DataTypeText = EmbeddedClass->MofClassInfo->Name;
                        }
                    } else {
                        DataTypeText = L"UNKNOWN";
                    }
                    
                } else {
                    // Standard data type
                    if ((DataItem->DataType == MOFString) ||
                          (DataItem->DataType == MOFZTString) ||
                          (DataItem->DataType == MOFAnsiString) ||
                          (DataItem->DataType == MOFDate))
                    {
                        DataTypeText = L"WCHAR";
                    } else {                        
                        DataTypeText = MofDataTypeText[DataItem->DataType];
                    }
                }
                
                if (DataItem->Flags & MOFDI_FLAG_FIXED_ARRAY)
                {
                    Status = FilePrint(TemplateHandle,
                                       "    // %ws\r\n%ws  %ws %ws[%d];\r\n"
                                       "    #define %ws_SIZE sizeof(%ws[%d])\r\n",
                                       Description,
                                       VLCommentText,
                                       DataTypeText,
                                       DataItem->Name,
                                       DataItem->FixedArrayElements,
                                       DefineDataId,
                                       DataTypeText,
                                       DataItem->FixedArrayElements);
                } else if (DataItem->Flags & MOFDI_FLAG_VARIABLE_ARRAY) {
                    Status = FilePrint(TemplateHandle,
                                       "    // %ws\r\n%ws  %ws %ws[1];\r\n",
                                       Description,
                                       VLCommentText,
                                       DataTypeText,
                                       DataItem->Name);
                } else if (DataItem->DataType == MOFDate) {
                    Status = FilePrint(TemplateHandle,
                                       "    // %ws\r\n%ws  WCHAR %ws[25];\r\n"
                                       "    #define %ws_SIZE sizeof(WCHAR[25])\r\n",
                                       Description,
                                       VLCommentText,
                                       DataItem->Name,
                                       DefineDataId);
                } else if ((DataItem->DataType == MOFString) ||
                           (DataItem->DataType == MOFZTString) ||
                           (DataItem->DataType == MOFAnsiString)) {
                    if (DataItem->MaxLen == 0)
                    {
                        Status = FilePrint(TemplateHandle,
                                           "    // %ws\r\n%ws  CHAR VariableData[1];\r\n",
                                           Description,
										   VLCommentText);
                    } else {
                        Status = FilePrint(TemplateHandle,
                                           "    // %ws\r\n%ws  WCHAR %ws[%d + 1];\r\n",
                                           Description,
                                           VLCommentText,
                                           DataItem->Name,
                                           DataItem->MaxLen
                                          );
                    }
                } else {
                    Status = FilePrint(TemplateHandle,
                                       "    // %ws\r\n%ws  %ws %ws;\r\n"
                                       "    #define %ws_SIZE sizeof(%ws)\r\n",
                                       Description,
                                       VLCommentText,
                                       DataTypeText,
                                       DataItem->Name,
                                       DefineDataId,
                                       DataTypeText);
                }
                
                if (WmipIsDataitemVariableLen(DataItem))
                {
                    VLCommentText = L"//";
                }
                
                Status = FilePrint(TemplateHandle,
                                   "    #define %ws_ID %d\r\n\r\n",
                                   DefineDataId,
                                   i+1
                                  );
                
                if (DefineDataId != DefineDataIdText)
                {
                    BMOFFree(DefineDataId);
                }
            }
        }
        
        Status = FilePrint(TemplateHandle,
                       "} %ws, *P%ws;\r\n\r\n",
                       ClassName,
                       ClassName);

    } else {
        
#if DBG
        printf("Warning: Header for class %ws cannot be created\n",
               ClassName);
#endif

        if (ItemCount != 0)
        {
            Status = FilePrint(TemplateHandle,
                           "// Warning: Header for class %ws cannot be created\r\n"
                           "typedef struct _%ws\r\n{\r\n    char VariableData[1];\r\n\r\n",
                           ClassName,
                           ClassName);
            
            Status = FilePrint(TemplateHandle,
                       "} %ws, *P%ws;\r\n\r\n",
                       ClassName,
                       ClassName);

        } else {
            Status = ERROR_SUCCESS;
        }
    }
    return(Status);
}


ULONG GenerateHTemplate(
    PCHAR TemplateFile,
    PMOFRESOURCE MofResource
    )
{
    HANDLE TemplateHandle;
    ULONG Status;
    ULONG i,j;
    PWCHAR DataTypeText, ClassName;
    WCHAR MethodClassName[MAX_PATH];
    PWCHAR GuidName1, GuidName2;
    PWCHAR GuidSuffix1, GuidSuffix2;
    PMOFDATAITEMW DataItem;
    PMOFCLASSINFOW ClassInfo, MethodClassInfo;
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;
    PCHAR p;
    ULONG Len;
    CBMOFObj *ClassObject;
    PWCHAR MethodBaseClassName;

    TemplateHandle = CreateFile(TemplateFile,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

    if ((TemplateHandle == NULL) || (TemplateHandle == INVALID_HANDLE_VALUE))
    {
        return(GetLastError());
    }

    //
    // move back to only get the last part of the path and convert any
    // . into _
    //
    Len = strlen(TemplateFile);
    p = TemplateFile + Len;
    while ((p >= TemplateFile) && (*p != '\\'))
    {
        if (*p == '.')
        {
            *p = '_';
        }
        p--;
    }
    
    p++;

    Status = FilePrint(TemplateHandle,
                       "#ifndef _%s_\r\n#define _%s_\r\n\r\n",
                        p, p);


    //
    // Loop over all mof classes
    MofClassList = MofResource->MRMCHead.Flink;
    while (MofClassList != &MofResource->MRMCHead)
    {
        MofClass = CONTAINING_RECORD(MofClassList,
                                         MOFCLASS,
                                         MCMRList);

        ClassInfo = MofClass->MofClassInfo;
        ClassObject = (CBMOFObj *)MofClass->ClassObjectHandle;

        if (ClassInfo->HeaderName != NULL)
        {
              ClassName = ClassInfo->HeaderName;
        } else {
               ClassName = ClassInfo->Name;
        }

        if (ClassInfo->GuidName1 != NULL)
        {
              GuidName1 = ClassInfo->GuidName1;
            GuidSuffix1 = L"";
        } else {
               GuidName1 = ClassInfo->Name;
            GuidSuffix1 = L"Guid";
        }

        if (ClassInfo->GuidName2 != NULL)
        {
            GuidName2 = ClassInfo->GuidName2;
            GuidSuffix2 = L"";
        } else {
            GuidName2 = ClassInfo->Name;
            GuidSuffix2 = L"_GUID";
        }

        Status = FilePrint(TemplateHandle,
                            "// %ws - %ws\r\n",
                            ClassInfo->Name,
                            ClassName);
        if (ClassInfo->Description != NULL)
        {
            Status = FilePrint(TemplateHandle,
                           "// %ws\r\n",
                           ClassInfo->Description);
        }

        Status = FilePrint(TemplateHandle,
                           "#define %ws%ws \\\r\n"
                           "    { 0x%08x,0x%04x,0x%04x, { 0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x } }\r\n\r\n",
                           GuidName1, GuidSuffix1,
                           ClassInfo->Guid.Data1, ClassInfo->Guid.Data2,
                           ClassInfo->Guid.Data3,
                           ClassInfo->Guid.Data4[0], ClassInfo->Guid.Data4[1],
                           ClassInfo->Guid.Data4[2], ClassInfo->Guid.Data4[3],
                           ClassInfo->Guid.Data4[4], ClassInfo->Guid.Data4[5],
                           ClassInfo->Guid.Data4[6], ClassInfo->Guid.Data4[7]);

        Status = FilePrint(TemplateHandle,
                           "DEFINE_GUID(%ws%ws, \\\r\n"
                           "            0x%08x,0x%04x,0x%04x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x);\r\n\r\n",
                           GuidName2, GuidSuffix2,
                           ClassInfo->Guid.Data1, ClassInfo->Guid.Data2,
                           ClassInfo->Guid.Data3,
                           ClassInfo->Guid.Data4[0], ClassInfo->Guid.Data4[1],
                           ClassInfo->Guid.Data4[2], ClassInfo->Guid.Data4[3],
                           ClassInfo->Guid.Data4[4], ClassInfo->Guid.Data4[5],
                           ClassInfo->Guid.Data4[6], ClassInfo->Guid.Data4[7]);
        if (ClassInfo->MethodCount > 0)
        {
            Status = FilePrint(TemplateHandle,
                               "//\r\n// Method id definitions for %ws\r\n",
                               ClassInfo->Name);
        }

        for (i = 0; i < ClassInfo->MethodCount; i++)
        {
            DataItem = &ClassInfo->DataItems[i+ClassInfo->DataItemCount];
            Status = FilePrint(TemplateHandle,
                               "#define %ws     %d\r\n",
                               DataItem->Name,
                               DataItem->MethodId);


            MethodClassInfo = DataItem->MethodClassInfo;

            if (DataItem->HeaderName != NULL)
            {
                MethodBaseClassName = DataItem->HeaderName;
            } else {
                MethodBaseClassName = DataItem->Name;               
            }

            if (DoMethodHeaderGeneration)
            {
                swprintf(MethodClassName, L"%ws_IN", MethodBaseClassName);
                Status = GenerateClassHeader(TemplateHandle,
                                             MofResource,
                                             MethodClassName,
                                             MethodClassInfo,
                                             MOFDI_FLAG_INPUT_METHOD);

                swprintf(MethodClassName, L"%ws_OUT", MethodBaseClassName);
                Status = GenerateClassHeader(TemplateHandle,
                                             MofResource,
                                             MethodClassName,
                                             MethodClassInfo,
                                             MOFDI_FLAG_OUTPUT_METHOD);
            }
            
        }

        Status = FilePrint(TemplateHandle,
                           "\r\n");
        
        Status = GenerateClassHeader(TemplateHandle,
                                     MofResource,
                                     ClassName,
                                     ClassInfo,
                                     0xffffffff);

        MofClassList = MofClassList->Flink;
    }

    Status = FilePrint(TemplateHandle,
                       "#endif\r\n");

    CloseHandle(TemplateHandle);
    if (Status != ERROR_SUCCESS)
    {
        DeleteFile(TemplateFile);
    }

    return(Status);
}

ULONG FilePrintDataItem(
    HANDLE TemplateHandle,
    PMOFRESOURCE MofResource,
    ULONG Level,
    PCHAR Prefix,
    PCHAR DisplayPrefix,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW DataItem
)
{
    ULONG Status = ERROR_SUCCESS;
    CHAR NewPrefix[MAX_PATH];
    CHAR NewDisplayPrefix[MAX_PATH];
    CHAR ArrayLenBuffer[MAX_PATH];
    PCHAR ArrayLen;
    PMOFCLASSINFOW EmbeddedClassInfo;
    PMOFCLASS EmbeddedClass;
    PMOFDATAITEMW NewDataItem;
    ULONG j;

    if (DataItem->Flags & MOFDI_FLAG_FIXED_ARRAY)
    {
        sprintf(ArrayLenBuffer, "%d",
                                DataItem->FixedArrayElements);
        ArrayLen = ArrayLenBuffer;
    } else if (DataItem->Flags & MOFDI_FLAG_VARIABLE_ARRAY) {
        sprintf(ArrayLenBuffer, "%s%ws",
                    Prefix,
                      ClassInfo->DataItems[DataItem->VariableArraySizeId-1].Name);
        ArrayLen = ArrayLenBuffer;
    } else {
        ArrayLen = NULL;
    }

    if (ArrayLen != NULL)
    {
        Status = FilePrint(TemplateHandle,
                                       "    for i%d = 0 to (%s-1)\r\n",
                                       Level,
                                       ArrayLen);
        sprintf(NewPrefix, "%s%ws(i%d)",
                  Prefix,
                  DataItem->Name,
                  Level);
        sprintf(NewDisplayPrefix, "%s%ws(\"&i%d&\")",
                  DisplayPrefix,
                  DataItem->Name,
                  Level);
    } else {
        sprintf(NewPrefix, "%s%ws",
                  Prefix,
                  DataItem->Name);

        sprintf(NewDisplayPrefix, "%s%ws",
                  DisplayPrefix,
                  DataItem->Name);

    }

    if (DataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS)
    {
        EmbeddedClass = WmipFindClassInMofResourceByGuid(
                                             MofResource,
                                             &DataItem->EmbeddedClassGuid);

        if (EmbeddedClass != NULL)
          {
            strcat(NewPrefix, ".");
            strcat(NewDisplayPrefix, ".");

            EmbeddedClassInfo = EmbeddedClass->MofClassInfo;
            for (j = 0; j < EmbeddedClassInfo->DataItemCount; j++)
            {
                NewDataItem = &EmbeddedClassInfo->DataItems[j];
                   Status = FilePrintDataItem(TemplateHandle,
                                           MofResource,
                                           Level+1,
                                           NewPrefix,
                                           NewDisplayPrefix,
                                           EmbeddedClassInfo,
                                           NewDataItem);
            }
        } else {
#if DBG
            printf("WARNING - Cannot create test for %s, cannot find embedded class\n",
                         NewPrefix);
#endif
                FilePrint(TemplateHandle, "REM WARNING - Cannot create test for %s, cannot find embedded class\r\n",
                         NewPrefix);
        }
    } else {
        Status = FilePrint(TemplateHandle,
                  "    a.WriteLine(\"        %s=\" & %s)\r\n",
                  NewDisplayPrefix,
                  NewPrefix);
    }

    if (ArrayLen != NULL)
    {
        Status = FilePrint(TemplateHandle,
                           "    next 'i%d\r\n",
                           Level);
    }

    return(Status);
}

BOOLEAN CanCreateTest(
    PMOFCLASSINFOW ClassInfo
            )
{
    //
    // Cannot create tests for embedded classes or events
    if (((ClassInfo->Flags & MOFCI_RESERVED1) == 0) ||
        (ClassInfo->Flags & MOFCI_FLAG_EVENT))

    {
        return(FALSE);
    }

    return(TRUE);
}

ULONG GenerateTTemplate(
    PCHAR TemplateFile,
    PMOFRESOURCE MofResource
    )
{
    HANDLE TemplateHandle;
    ULONG Status;
    ULONG i;
    PMOFDATAITEMW DataItem;
    PMOFCLASSINFOW ClassInfo;
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;
    PCHAR p, p1;

    TemplateHandle = CreateFile(TemplateFile,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

    if ((TemplateHandle != NULL) && (TemplateHandle != INVALID_HANDLE_VALUE))
    {
        p = TemplateFile;
        p1 = TemplateFile;
        while ((*p != '.') && (*p != 0))
        {
            if (*p == '\\')
            {
                p1 = p+1;
            }
            p++;
        }

        if (*p == '.')
        {
            *p = 0;
        }

        Status = FilePrint(TemplateHandle,
                           "REM Note that missing classes in log file mean tthe hat WMI cannot access them.\r\n"
                           "REM Most likely this indicates a problem with the driver.\r\n"
                           "REM See %%windir%%\\system32\\wbem\\wmiprov.log and nt eventlog for more details.\r\n"
                           "REM You could also delete the line On Error Resume Next and examine the\r\n"
                           "REM specific VBScript error\r\n\r\n\r\n");
        Status = FilePrint(TemplateHandle,
                     "On Error Resume Next\r\n\r\n");

        Status = FilePrint(TemplateHandle,
                     "Set fso = CreateObject(\"Scripting.FileSystemObject\")\r\n");
        Status = FilePrint(TemplateHandle,
                     "Set a = fso.CreateTextFile(\"%s.log\", True)\r\n",
                     p1);

        Status = FilePrint(TemplateHandle,
                        "Set Service = GetObject(\"winmgmts:{impersonationLevel=impersonate}!root/wmi\")\r\n");

        //
        // Loop over all mof classes
        MofClassList = MofResource->MRMCHead.Flink;
        while (MofClassList != &MofResource->MRMCHead)
        {
            MofClass = CONTAINING_RECORD(MofClassList,
                                             MOFCLASS,
                                             MCMRList);

            ClassInfo = MofClass->MofClassInfo;

            if (CanCreateTest(ClassInfo))
            {
                Status = FilePrint(TemplateHandle,
                                "Rem %ws - %ws\r\n",
                                ClassInfo->Name,
                          ClassInfo->Description ? ClassInfo->Description : L"");

                Status = FilePrint(TemplateHandle,
                          "Set enumSet = Service.InstancesOf (\"%ws\")\r\n"
                          "a.WriteLine(\"%ws\")\r\n",
                          ClassInfo->Name,
                          ClassInfo->Name);

                Status = FilePrint(TemplateHandle,
                        "for each instance in enumSet\r\n");

                Status = FilePrint(TemplateHandle,
                  "    a.WriteLine(\"    InstanceName=\" & instance.InstanceName)\r\n");

                for (i = 0; i < ClassInfo->DataItemCount; i++)
                {
                    DataItem = &ClassInfo->DataItems[i];
                    FilePrintDataItem(TemplateHandle,
                                      MofResource,
                                      1,
                                      "instance.",
                                      "instance.",
                                      ClassInfo,
                                      DataItem);

                }
            Status = FilePrint(TemplateHandle,
                                   "next 'instance\r\n\r\n");

            }

            MofClassList = MofClassList->Flink;
        }

        Status = FilePrint(TemplateHandle,
                           "a.Close\r\n"
                           "Wscript.Echo \"%s Test Completed, see %s.log for details\"\r\n",
                           p1, p1);

        CloseHandle(TemplateHandle);
        if (Status != ERROR_SUCCESS)
        {
            DeleteFile(TemplateFile);
        }
    } else {
        Status = GetLastError();
    }
    return(Status);
}

ULONG GenerateXTemplate(
    PCHAR TemplateFile
    )
{
    HANDLE TemplateHandle;
    ULONG Status;

    TemplateHandle = CreateFile(TemplateFile,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

    if ((TemplateHandle == NULL) || (TemplateHandle == INVALID_HANDLE_VALUE))
    {
        return(GetLastError());
    }

    Status = GenerateBinaryMofData(TemplateHandle);

    CloseHandle(TemplateHandle);
    if (Status != ERROR_SUCCESS)
    {
        DeleteFile(TemplateFile);
    }

    return(Status);

}
typedef void (*PROPERTYCALLBACK)(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW DataItem,
    ULONG Counter,
    PVOID Context
    );


void EnumerateClassProperties(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PROPERTYCALLBACK Callback,
    BOOLEAN Recurse,
    PVOID Context
    )
{
    ULONG i;
    WCHAR I[1];
    WCHAR F[1];

    if (InstanceName == NULL)
    {
        I[0] = UNICODE_NULL;
        InstanceName = I;
    }

    if (FormName == NULL)
    {
        F[0] = UNICODE_NULL;
        FormName = F;
    }

    for (i = 0; i < ClassInfo->DataItemCount; i++)
    {
        WCHAR FName[MAX_PATH];
        WCHAR IName[MAX_PATH];
        PMOFCLASS EmbeddedClass;
        PMOFDATAITEMW DataItem;

        DataItem = &ClassInfo->DataItems[i];
          wcscpy(IName, InstanceName);
           wcscat(IName, L".");
           wcscat(IName, DataItem->Name);

        wcscpy(FName, FormName);
        wcscat(FName, DataItem->Name);

        if (DataItem->Flags & (MOFDI_FLAG_FIXED_ARRAY |
                               MOFDI_FLAG_VARIABLE_ARRAY))
        {
            wcscat(IName, L"(");
            wcscat(IName, FName);
            wcscat(IName, L"Index)");
        }

        (*Callback)(TemplateHandle,
                    FName,
                    IName,
                    InstanceName,
                    MofResource,
                    ClassInfo,
                    DataItem,
                    i,
                    Context);


        if (Recurse && (DataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS))
        {
            EmbeddedClass = WmipFindClassInMofResourceByGuid(
                                             MofResource,
                                             &DataItem->EmbeddedClassGuid);

            if (EmbeddedClass != NULL)
            {
                EnumerateClassProperties(TemplateHandle,
                                     FName,
                                     IName,
                                     MofResource,
                                     EmbeddedClass->MofClassInfo,
                                     Callback,
                                     Recurse,
                                     Context);
            }
        }
    }
}


void GenerateChangeText(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW DataItem,
    ULONG Counter,
    PVOID Context
)
{
    //
    // Generate code to change the contents of a property
    //
    if (! (DataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS))
    {
        FilePrint(TemplateHandle,
"      Instance%ws = TheForm.%wsText.Value\r\n",
             InstanceName,
             FormName);
    }
}

void GenerateReloadText(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW DataItem,
    ULONG Counter,
    PVOID Context
)
{
    //
    // Generate code to redisplay the contents of the property
    //
    if (! (DataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS))
    {
        FilePrint(TemplateHandle,
"        TheForm.%wsText.Value = Instance%ws\r\n",
             FormName,
             InstanceName);
    }

    if (DataItem->Flags & (MOFDI_FLAG_FIXED_ARRAY | MOFDI_FLAG_VARIABLE_ARRAY))
    {
        FilePrint(TemplateHandle,
"        TheForm.%wsIndexText.Value = %wsIndex\r\n",
           FormName, FormName);

        if (DataItem->Flags & MOFDI_FLAG_FIXED_ARRAY)
        {
            FilePrint(TemplateHandle,
"        %wsMaxIndex = %d\r\n",
                      FormName, DataItem->FixedArrayElements);
        } else {
            FilePrint(TemplateHandle,
"        %wsMaxIndex = Instance%ws.%ws\r\n",
                  FormName, InstancePrefix,
                  ClassInfo->DataItems[DataItem->VariableArraySizeId-1].Name);
        }
    }

}

void GenerateTextFormText(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW DataItem,
    ULONG Counter,
    PVOID Context
)
{
    if (! (DataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS)) {
        FilePrint(TemplateHandle,
"<p class=MsoNormal>%ws: <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><INPUT TYPE=\"TEXT\" SIZE=\"96\" NAME=\"%wsText\"></p>\r\n"
"\r\n",
             FormName, FormName);
     }

    if (DataItem->Flags &
        (MOFDI_FLAG_FIXED_ARRAY | MOFDI_FLAG_VARIABLE_ARRAY))
    {
        FilePrint(TemplateHandle,
"\r\n"
"<input name=Next%wsButton type=BUTTON value=Next OnClick=\"NextIndexButton_OnClick %wsIndex, %wsMaxIndex\">\r\n"
"\r\n"
"<input name=Prev%wsButton type=BUTTON value=Previous OnClick=\"PrevIndexButton_OnClick %wsIndex, %wsMaxIndex\">\r\n"
"\r\n"
"%wsArrayIndex: <INPUT TYPE=\"TEXT\" SIZE=\"5\" NAME=\"%wsIndexText\">\r\n"
"\r\n"
"<input name=GoTo%wsButton type=BUTTON value=GoTo OnClick=\"GoToIndexButton_OnClick %wsIndex, %wsMaxIndex, Document.ClassForm.%wsIndexText.Value\">\r\n"
"\r\n",
                  FormName,
                  FormName,
                  FormName,
                  FormName,
                  FormName,
                  FormName,
                  FormName,
                  FormName,
                  FormName,
                  FormName,
                  FormName,
                  FormName);
    }

}

void GenerateArrayDimsText(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MofDataItem,
    ULONG Counter,
    PVOID Context
)
{
    //
    // Declare an index variable that tracks the current index of an array
    //
    if (MofDataItem->Flags &
            (MOFDI_FLAG_FIXED_ARRAY | MOFDI_FLAG_VARIABLE_ARRAY))
    {
        FilePrint(TemplateHandle,
"Dim %wsIndex\r\n"
"%wsIndex = 0\r\n"
"Dim %wsMaxIndex\r\n"
"%wsMaxIndex = 1\r\n",
                  FormName,
                  FormName,
                  FormName,
                  FormName);
    }
}

void GenerateMethodInL2Text(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MofDataItem,
    ULONG Counter,
    PVOID Context
)
{
    if (! (MofDataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS))
    {
            FilePrint(TemplateHandle,
"      %ws = TheForm.%ws%wsText.Value\r\n",
                  InstanceName,
                  Context,
                  FormName);        
    }
}

void GenerateMethodInText(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MofDataItem,
    ULONG Counter,
    PVOID Context
)
{
    //
    // Declare classes for all IN and OUT embedded classes
    //
    if (MofDataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS)
    {
        PWCHAR EmbeddedClassName = (PWCHAR)MofDataItem->EcTempPtr +
                                         (sizeof(L"object") / sizeof(WCHAR));

        if (MofDataItem->Flags & (MOFDI_FLAG_INPUT_METHOD))
        {                                   
            FilePrint(TemplateHandle,
"      Set %ws = Service.Get(\"%ws\").SpawnInstance_\r\n",
                      FormName,
                      EmbeddedClassName);
        } else {
            FilePrint(TemplateHandle,
"      Dim %ws\r\n",
                      FormName);
        }
    }

    if (MofDataItem->Flags & (MOFDI_FLAG_INPUT_METHOD))
    {

        if (MofDataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS)
        {
            PMOFCLASS EmbeddedClass;
            EmbeddedClass = WmipFindClassInMofResourceByGuid(
                                             MofResource,
                                             &MofDataItem->EmbeddedClassGuid);

            if (EmbeddedClass != NULL)
            {
                EnumerateClassProperties(TemplateHandle,
                                     FormName,
                                     FormName,
                                     MofResource,
                                     EmbeddedClass->MofClassInfo,
                                     GenerateMethodInL2Text,
                                     TRUE,
                                     Context);
            }



        } else {
            FilePrint(TemplateHandle,
"      %ws = TheForm.%ws%wsText.Value\r\n",
                  FormName,
                  Context,
                  FormName);
        }
    }
}


void GenerateMethodOutL2Text(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MofDataItem,
    ULONG Counter,
    PVOID Context
)
{
    if (! (MofDataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS))
    {
            FilePrint(TemplateHandle,
"        TheForm.%ws%wsText.Value = %ws\r\n",

                  Context,
                  FormName,
                  InstanceName);
    }
}

void GenerateMethodOutText(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MofDataItem,
    ULONG Counter,
    PVOID Context
)
{
    if (MofDataItem->Flags & (MOFDI_FLAG_OUTPUT_METHOD))
    {
        if (MofDataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS)
        {
            PMOFCLASS EmbeddedClass;
            PWCHAR EmbeddedClassName = (PWCHAR)MofDataItem->EcTempPtr +
                                         (sizeof(L"object") / sizeof(WCHAR));
            EmbeddedClass = WmipFindClassInMofResourceByGuid(
                                             MofResource,
                                             &MofDataItem->EmbeddedClassGuid);

            if (EmbeddedClass != NULL)
            {
                EnumerateClassProperties(TemplateHandle,
                                     FormName,
                                     FormName,
                                     MofResource,
                                     EmbeddedClass->MofClassInfo,
                                     GenerateMethodOutL2Text,
                                     TRUE,
                                     Context);
            }



        } else {
            FilePrint(TemplateHandle,
"        TheForm.%ws%wsText.Value = %ws\r\n",

                  Context,
                  FormName,
                  FormName);
        }
    }
}

void GenerateMethodCallText(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MofDataItem,
    ULONG Counter,
    PVOID Context
)
{
    //
    // Declare an index variable that tracks the current index of an array
    //
    FilePrint(TemplateHandle,
" %ws",
                  FormName);

    if (Counter != PtrToUlong(Context))
    {
        FilePrint(TemplateHandle, ", ");
    }
}

void GenerateMethodControlText(
    HANDLE TemplateHandle,
    PWCHAR FormName,
    PWCHAR InstanceName,
    PWCHAR InstancePrefix,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MofDataItem,
    ULONG Counter,
    PVOID Context
)
{
    PWCHAR MethodName = (PWCHAR)Context;

    FilePrint(TemplateHandle,
"<p>  "
             );

    if (MofDataItem->Flags & (MOFDI_FLAG_INPUT_METHOD))
    {
        FilePrint(TemplateHandle,
                   " [in] ");
    }

    if (MofDataItem->Flags & (MOFDI_FLAG_OUTPUT_METHOD))
    {
        FilePrint(TemplateHandle,
                   " [out] ");
    }


    if (MofDataItem->Flags & MOFDI_FLAG_EMBEDDED_CLASS)
    {
        FilePrint(TemplateHandle, "%ws </p>\r\n", FormName);
    } else {
        FilePrint(TemplateHandle,
" %ws <INPUT TYPE=\"TEXT\" SIZE=\"70\" NAME=\"%ws%wsText\"></p>\r\n",
                  FormName,
                  MethodName,
                  FormName);
    }

    if (MofDataItem->Flags &
        (MOFDI_FLAG_FIXED_ARRAY | MOFDI_FLAG_VARIABLE_ARRAY))
    {
        FilePrint(TemplateHandle,
"\r\n"
"<input name=Next%wsButton type=BUTTON value=Next OnClick=\"NextIndexButton_OnClick %ws%wsIndex, %ws%wsMaxIndex\">\r\n"
"\r\n"
"<input name=Prev%wsButton type=BUTTON value=Previous OnClick=\"PrevIndexButton_OnClick %ws%wsIndex, %ws%wsMaxIndex\">\r\n"
"\r\n"
"%ws%wsArrayIndex: <INPUT TYPE=\"TEXT\" SIZE=\"5\" NAME=\"%ws%wsIndexText\">\r\n"
"\r\n"
"<input name=GoTo%ws%wsButton type=BUTTON value=GoTo OnClick=\"GoToIndexButton_OnClick %ws%wsIndex, %ws%wsMaxIndex, Document.ClassForm.%ws%wsIndexText.Value\">\r\n"
"\r\n",
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName,
                  FormName,
                  MethodName);
    }

}


typedef void (*METHODCALLBACK)(
    HANDLE TemplateHandle,
    PWCHAR MethodName,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MethodDataItem,
    ULONG Counter,
    PVOID Context
    );


void EnumerateClassMethods(
    HANDLE TemplateHandle,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    METHODCALLBACK Callback,
    PVOID Context
    )
{
    PMOFDATAITEMW DataItem;
    ULONG i;

    for (i = 0; i < ClassInfo->MethodCount; i++)
    {
        DataItem = &ClassInfo->DataItems[i+ClassInfo->DataItemCount];

        WmipAssert(DataItem->Flags & MOFDI_FLAG_METHOD);

        (*Callback)(TemplateHandle,
                    DataItem->Name,
                    MofResource,
                    ClassInfo,
                    DataItem,
                    i,
                    Context);
    }
}

void GenerateMethodButtonsText(
    HANDLE TemplateHandle,
    PWCHAR MethodName,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MethodDataItem,
    ULONG Counter,
    PVOID Context
)
{
    PMOFCLASSINFOW MethodClassInfo;

    FilePrint(TemplateHandle,
"<p class=MsoNormal>Method %ws: <input name=%wsButton type=BUTTON value=Execute> </p>\r\n",
        MethodName, MethodName);

    MethodClassInfo = MethodDataItem->MethodClassInfo;
    EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             MethodClassInfo,
                             GenerateMethodControlText,
                             TRUE,
                             MethodName);


}

void GenerateMethodSubsText(
    HANDLE TemplateHandle,
    PWCHAR MethodName,
    PMOFRESOURCE MofResource,
    PMOFCLASSINFOW ClassInfo,
    PMOFDATAITEMW MethodDataItem,
    ULONG Counter,
    PVOID Context
)
{
    PMOFCLASSINFOW MethodClassInfo;

    FilePrint(TemplateHandle,
"Sub %wsButton_OnClick\r\n"
"  if InstanceCount <> 0 Then\r\n"
"    On Error Resume Next\r\n"
"    Err.Clear\r\n"
"    Set Instance = Service.Get(InstancePaths(CurrentInstanceIndex))\r\n"
"    if Err.Number = 0 Then\r\n"
"      Set TheForm = Document.ClassForm\r\n"
"      Err.Clear\r\n",
               MethodName);

    MethodClassInfo = MethodDataItem->MethodClassInfo;
    EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             MethodClassInfo,
                             GenerateMethodInText,
                             FALSE,
                             MethodName);

    FilePrint(TemplateHandle,
"      Instance.%ws ",
            MethodName);

    EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             MethodClassInfo,
                             GenerateMethodCallText,
                             FALSE,
                             UlongToPtr(MethodClassInfo->DataItemCount-1));

    FilePrint(TemplateHandle,
"\r\n      if Err.Number = 0 Then\r\n"
             );

    EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             MethodClassInfo,
                             GenerateMethodOutText,
                             FALSE,
                             MethodName);


    FilePrint(TemplateHandle,
"        MsgBox \"Method Execution Succeeded\"\r\n"
"      Else\r\n"
"        MsgBox Err.Description,, \"Method Execution Failed\"\r\n"
"      End if\r\n"
"    End if\r\n"
"  End if\r\n"
"End Sub\r\n\r\n"
        );

}



ULONG GenerateClassWebPage(
    HANDLE TemplateHandle,
    PMOFCLASS MofClass,
    PMOFRESOURCE MofResource
    )
{
    PMOFCLASSINFOW ClassInfo = MofClass->MofClassInfo;
    BOOLEAN IsEvent=(ClassInfo->Flags & MOFCI_FLAG_EVENT) == MOFCI_FLAG_EVENT;


    FilePrint(TemplateHandle,
"<html xmlns:v=\"urn:schemas-microsoft-com:vml\"\r\n"
"xmlns:o=\"urn:schemas-microsoft-com:office:office\"\r\n"
"xmlns:w=\"urn:schemas-microsoft-com:office:word\"\r\n"
"xmlns=\"http://www.w3.org/TR/REC-html40\">\r\n"
"\r\n"
"<head>\r\n"
"<meta http-equiv=Content-Type content=\"text/html; charset=us-ascii\">\r\n"
"<meta name=ProgId content=Word.Document>\r\n"
"<meta name=Generator content=\"Microsoft Word 9\">\r\n"
"<meta name=Originator content=\"Microsoft Word 9\">\r\n"
"<link rel=File-List href=\"./valid_files/filelist.xml\">\r\n"
"<link rel=Edit-Time-Data href=\"./valid_files/editdata.mso\">\r\n"
"<!--[if !mso]>\r\n"
"<style>\r\n"
"v\\:* {behavior:url(#default#VML);}\r\n"
"o\\:* {behavior:url(#default#VML);}\r\n"
"w\\:* {behavior:url(#default#VML);}\r\n"
".shape {behavior:url(#default#VML);}\r\n"
"</style>\r\n"
"<![endif]-->\r\n"
"<title>Class %ws</title>\r\n"
"<!--[if gte mso 9]><xml>\r\n"
" <o:DocumentProperties>\r\n"
"  <o:Author>Wmi Mof Checking Tool</o:Author>\r\n"
"  <o:Template>Normal</o:Template>\r\n"
"  <o:LastAuthor>Wmi Mof Checking Tool</o:LastAuthor>\r\n"
"  <o:Revision>2</o:Revision>\r\n"
"  <o:TotalTime>3</o:TotalTime>\r\n"
"  <o:Created>1999-09-10T01:09:00Z</o:Created>\r\n"
"  <o:LastSaved>1999-09-10T01:12:00Z</o:LastSaved>\r\n"
"  <o:Pages>1</o:Pages>\r\n"
"  <o:Words>51</o:Words>\r\n"
"  <o:Characters>292</o:Characters>\r\n"
"  <o:Company>Microsoft</o:Company>\r\n"
"  <o:Lines>2</o:Lines>\r\n"
"  <o:Paragraphs>1</o:Paragraphs>\r\n"
"  <o:CharactersWithSpaces>358</o:CharactersWithSpaces>\r\n"
"  <o:Version>9.2720</o:Version>\r\n"
" </o:DocumentProperties>\r\n"
"</xml><![endif]--><!--[if gte mso 9]><xml>\r\n"
" <w:WordDocument>\r\n"
"  <w:Compatibility>\r\n"
"   <w:UseFELayout/>\r\n"
"  </w:Compatibility>\r\n"
" </w:WordDocument>\r\n"
"</xml><![endif]-->\r\n"
"<style>\r\n"
"<!--\r\n"
" /* Font Definitions */\r\n"
"@font-face\r\n"
"    {font-family:\"MS Mincho\";\r\n"
"    panose-1:2 2 6 9 4 2 5 8 3 4;\r\n"
"    mso-font-alt:\"\\FF2D\\FF33 \\660E\\671D\";\r\n"
"    mso-font-charset:128;\r\n"
"    mso-generic-font-family:roman;\r\n"
"    mso-font-format:other;\r\n"
"    mso-font-pitch:fixed;\r\n"
"    mso-font-signature:1 134676480 16 0 131072 0;}\r\n"
"@font-face\r\n"
"    {font-family:\"\\@MS Mincho\";\r\n"
"    panose-1:2 2 6 9 4 2 5 8 3 4;\r\n"
"    mso-font-charset:128;\r\n"
"    mso-generic-font-family:modern;\r\n"
"    mso-font-pitch:fixed;\r\n"
"    mso-font-signature:-1610612033 1757936891 16 0 131231 0;}\r\n"
" /* Style Definitions */\r\n"
"p.MsoNormal, li.MsoNormal, div.MsoNormal\r\n"
"    {mso-style-parent:\"\";\r\n"
"    margin:0in;\r\n"
"    margin-bottom:.0001pt;\r\n"
"    mso-pagination:widow-orphan;\r\n"
"    font-size:12.0pt;\r\n"
"    font-family:\"Times New Roman\";\r\n"
"    mso-fareast-font-family:\"MS Mincho\";}\r\n"
"@page Section1\r\n"
"    {size:8.5in 11.0in;\r\n"
"    margin:1.0in 1.25in 1.0in 1.25in;\r\n"
"    mso-header-margin:.5in;\r\n"
"    mso-footer-margin:.5in;\r\n"
"    mso-paper-source:0;}\r\n"
"div.Section1\r\n"
"    {page:Section1;}\r\n"
"-->\r\n"
"</style>\r\n"
"<!--[if gte mso 9]><xml>\r\n"
" <o:shapedefaults v:ext=\"edit\" spidmax=\"1026\"/>\r\n"
"</xml><![endif]--><!--[if gte mso 9]><xml>\r\n"
" <o:shapelayout v:ext=\"edit\">\r\n"
"  <o:idmap v:ext=\"edit\" data=\"1\"/>\r\n"
" </o:shapelayout></xml><![endif]-->\r\n"
"</head>\r\n"
"\r\n"
"<body lang=EN-US style='tab-interval:.5in'>\r\n"
"\r\n"
"<div class=Section1>\r\n"
"\r\n"
"<h3>Class %ws</h3>\r\n"
"\r\n"
"\r\n"
"<div class=MsoNormal align=center style='text-align:center'>\r\n"
"\r\n"
"<hr size=2 width=\"100%\" align=center>\r\n"
"\r\n"
"</div>\r\n"
"\r\n"
"\r\n"
"<form NAME=ClassForm>\r\n"
"\r\n"
"<p class=MsoNormal><span style='display:none;mso-hide:all'><script language=\"VBScript\">\r\n"
"<!--\r\n"
"On Error Resume Next\r\n"
"Dim Locator\r\n"
"Dim Service\r\n"
"Dim Collection\r\n"
"Dim InstancePaths()\r\n"
"Dim InstanceCount\r\n"
"Dim CurrentInstanceIndex\r\n"
"\r\n",
        ClassInfo->Name, ClassInfo->Name, ClassInfo->Name);


    EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             ClassInfo,
                             GenerateArrayDimsText,
                             TRUE,
                             NULL);

    FilePrint(TemplateHandle, "\r\n");

    if (IsEvent)
    {
        FilePrint(TemplateHandle,
"Dim LastEventObject\r\n"
"Dim ReceivedEvent\r\n"
"ReceivedEvent = FALSE\r\n"
"InstanceCount = 1\r\n"
"\r\n"
"Sub window_onLoad \r\n"
"  Set Locator = CreateObject(\"WbemScripting.SWbemLocator\")\r\n"
"  Locator.Security_.Privileges.AddAsString \"SeSecurityPrivilege\"\r\n"
"  Set Service = Locator.ConnectServer(, \"root\\wmi\")\r\n"
"  Service.Security_.ImpersonationLevel=3\r\n"
"  On Error Resume Next\r\n"
"  Err.Clear\r\n"
"  Service.ExecNotificationQueryAsync mysink, _\r\n"
"           \"select * from %ws\"\r\n"
"\r\n"
"  if Err.Number <> 0 Then\r\n"
"    MsgBox Err.Description,, \"Error Registering for event\"\r\n"
"  End If\r\n"
"End Sub\r\n"
"\r\n",
                 ClassInfo->Name);

    FilePrint(TemplateHandle,
"Sub ReloadInstance\r\n"
"  Set TheForm = Document.ClassForm\r\n"
"  if ReceivedEvent Then\r\n"
"      Set Instance = LastEventObject\r\n"
"      TheForm.InstanceNameText.Value = Instance.InstanceName\r\n"
             );

        EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             ClassInfo,
                             GenerateReloadText,
                             TRUE,
                             NULL);

        FilePrint(TemplateHandle,
"  End If\r\n"
"\r\n"
"End Sub\r\n"
"\r\n"
                    );
    } else {
        FilePrint(TemplateHandle,
"Set Locator = CreateObject(\"WbemScripting.SWbemLocator\")\r\n"
"' Note that Locator.ConnectServer can be used to connect to remote computers\r\n"
"Set Service = Locator.ConnectServer(, \"root\\wmi\")\r\n"
"Service.Security_.ImpersonationLevel=3\r\n"
             );
        
        FilePrint(TemplateHandle,
"Set Collection = Service.InstancesOf (\"%ws\")\r\n"
"\r\n"
"InstanceCount = 0\r\n"
"Err.Clear\r\n"
"for each Instance in Collection\r\n"
"    if Err.Number = 0 Then\r\n"
"      InstanceCount = InstanceCount + 1\r\n"
"\r\n"
"      ReDim Preserve InstancePaths(InstanceCount)\r\n"
"\r\n"
"      Set ObjectPath = Instance.Path_\r\n"
"      InstancePaths(InstanceCount) = ObjectPath.Path\r\n"
"    End If\r\n"
"next 'Instance\r\n"
"\r\n"
"if InstanceCount = 0 Then\r\n"
"  MsgBox \"No instances available for this class\"\r\n"
"Else\r\n"
"  CurrentInstanceIndex = 1\r\n"
"End if\r\n"
"\r\n",
    ClassInfo->Name
    );

        FilePrint(TemplateHandle,
"Sub ChangeButton_OnClick\r\n"
"  Set TheForm = Document.ClassForm\r\n"
"  if InstanceCount = 0 Then\r\n"
"    MsgBox \"No instances available for this class\"\r\n"
"  Else\r\n"
"    On Error Resume Next\r\n"
"    Err.Clear\r\n"
"    Set Instance = Service.Get(InstancePaths(CurrentInstanceIndex))\r\n"
"    if Err.Number = 0 Then\r\n"
    );

        EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             ClassInfo,
                             GenerateChangeText,
                             TRUE,
                             NULL);

        FilePrint(TemplateHandle,
"\r\n"
"      Err.Clear\r\n"
"      Instance.Put_()\r\n"
"      if Err.Number <> 0 Then\r\n"
"        MsgBox Err.Description, ,CurrentObjectPath\r\n"
"      End If\r\n"
"    Else\r\n"
"        MsgBox Err.Description, ,CurrentObjectPath\r\n"
"    End If\r\n"
"  End If\r\n"
"End Sub\r\n"
"\r\n"
"Sub ReloadInstance\r\n"
"  Set TheForm = Document.ClassForm\r\n"
"  if InstanceCount = 0 Then\r\n"
"    TheForm.InstanceNameText.Value = \"No Instances Available\"\r\n"
"  Else\r\n"
"    On Error Resume Next\r\n"
"    Err.Clear\r\n"
"    Set Instance = Service.Get(InstancePaths(CurrentInstanceIndex))\r\n"
"    if Err.Number = 0 Then\r\n"
"\r\n"
"      TheForm.InstanceNameText.Value = InstancePaths(CurrentInstanceIndex)\r\n"
             );

        EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             ClassInfo,
                             GenerateReloadText,
                             TRUE,
                             NULL);

        FilePrint(TemplateHandle,
"    Else\r\n"
"      MsgBox Err.Description, ,CurrentObjectPath\r\n"
"    End If\r\n"
"  End If\r\n"
"\r\n"
"End Sub\r\n"
"\r\n"
"Sub RefreshButton_OnClick\r\n"
"  if InstanceCount = 0 Then\r\n"
"    MsgBox \"No instances available for this class\"\r\n"
"  Else\r\n"
"    call ReloadInstance\r\n"
"  End If\r\n"
"End Sub\r\n"
"\r\n"
"Sub NextButton_OnClick\r\n"
"\r\n"
"  if InstanceCount = 0 Then\r\n"
"    MsgBox \"No instances available for this class\"\r\n"
"  Else\r\n"
"    if CurrentInstanceIndex = InstanceCount Then\r\n"
"      CurrentInstanceIndex = 1\r\n"
"    Else \r\n"
"      CurrentInstanceIndex = CurrentInstanceIndex + 1\r\n"
"    End If\r\n"
"    call ReloadInstance\r\n"
"  End if\r\n"
"\r\n"
"\r\n"
"End Sub\r\n"
"\r\n"
"Sub PrevButton_OnClick\r\n"
"\r\n"
"  if InstanceCount = 0 Then\r\n"
"    MsgBox \"No instances available for this class\"\r\n"
"  Else\r\n"
"    if CurrentInstanceIndex = 1 Then\r\n"
"      CurrentInstanceIndex = InstanceCount\r\n"
"    Else\r\n"
"      CurrentInstanceIndex = CurrentInstanceIndex - 1\r\n"
"    End if\r\n"
"    call ReloadInstance\r\n"
"  End if\r\n"
"\r\n"
"\r\n"
"End Sub\r\n"
"\r\n");
    }
    
    FilePrint(TemplateHandle,
"Sub NextIndexButton_OnClick(ByRef Index, MaxIndex)\r\n"
"  if InstanceCount <> 0 Then\r\n"
"    Index = Index + 1\r\n"
"    if Index = MaxIndex Then\r\n"
"      Index = 0\r\n"
"    End If\r\n"
"      Call ReloadInstance\r\n"
"  End If\r\n"
"End Sub\r\n"
"\r\n"
"Sub PrevIndexButton_OnClick(ByRef Index, MaxIndex)\r\n"
"  if InstanceCount <> 0 Then\r\n"
"    if Index = 0 Then\r\n"
"      Index = MaxIndex - 1\r\n"
"    Else\r\n"
"      Index = Index - 1\r\n"
"    End If\r\n"
"      Call ReloadInstance\r\n"
"  End If\r\n"
"End Sub\r\n"
"\r\n"
"Sub GotoIndexButton_OnClick(ByRef Index, MaxIndex, NewIndex)\r\n"
"  if InstanceCount <> 0 Then\r\n"
"    DestIndex = NewIndex + 0\r\n"
"    if DestIndex >= 0 And DestIndex < MaxIndex Then\r\n"
"      Index = DestIndex\r\n"
"      Call ReloadInstance\r\n"
"    Else\r\n"
"      MsgBox \"Enter an index between 0 and \" & MaxIndex-1, ,\"Index out of range\"\r\n"
"    End If\r\n"
"  End If\r\n"
"End Sub\r\n"
"\r\n");

    EnumerateClassMethods(TemplateHandle,
                             MofResource,
                             ClassInfo,
                             GenerateMethodSubsText,
                             NULL);

    FilePrint(TemplateHandle,
"-->\r\n"
"</script></span>"
"<INPUT TYPE=\"TEXT\" SIZE=\"128\" NAME=\"InstanceNameText\" VALUE=\"\"></p>\r\n"
        );

    if (IsEvent)
    {
        FilePrint(TemplateHandle,
"<SCRIPT FOR=\"mysink\" EVENT=\"OnObjectReady(Instance, objAsyncContext)\" LANGUAGE=\"VBScript\">\r\n"
                 );         
            
        FilePrint(TemplateHandle,
"        Set LastEventObject = Instance\r\n"
"        ReceivedEvent = TRUE\r\n"
"        Call ReloadInstance\r\n"
                 );
            
        FilePrint(TemplateHandle,
"</SCRIPT>\r\n"
            );
    } else {
        FilePrint(TemplateHandle,
"\r\n"
"<input name=NextButton type=BUTTON value=Next>\r\n"
"\r\n"
"<input name=PrevButton type=BUTTON value=Previous>\r\n"
"\r\n"
"<input name=ChangeButton type=BUTTON value=Change>\r\n"
"\r\n"
"<input name=RefreshButton type=BUTTON value=Refresh>\r\n"
"\r\n"
"<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>\r\n"
"\r\n"
                  );
    }

    EnumerateClassProperties(TemplateHandle,
                             NULL,
                             NULL,
                             MofResource,
                             ClassInfo,
                             GenerateTextFormText,
                             TRUE,
                             NULL);


    EnumerateClassMethods(TemplateHandle,
                          MofResource,
                          ClassInfo,
                          GenerateMethodButtonsText,
                          NULL);

    FilePrint(TemplateHandle,
"<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>\r\n"
"\r\n"
"<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>\r\n"
"\r\n"
"<p class=MsoNormal><a href=\"index.htm\"\r\n"
"title=\"Goes back to list of classes in this MOF\">Back to List</a></p>\r\n"
"\r\n"
"</form>\r\n"
"\r\n"
          );
    if (! IsEvent)
    {
        FilePrint(TemplateHandle,
"<p class=MsoNormal><span style='display:none;mso-hide:all'><script language=\"VBScript\">\r\n"
"<!--\r\n"
"  call ReloadInstance\r\n"
"-->\r\n"
"</script></span></p>\r\n"
"\r\n"
           );
   }

   FilePrint(TemplateHandle,
"</div>\r\n"
"\r\n"
            );
        
    if (IsEvent)
    {
        FilePrint(TemplateHandle,
"<OBJECT ID=\"mysink\" CLASSID=\"CLSID:75718C9A-F029-11d1-A1AC-00C04FB6C223\"></OBJECT>\r\n"
                );
    }

    FilePrint(TemplateHandle,
"</body>\r\n"
"\r\n"
"</html>\r\n"
              );

    return(ERROR_SUCCESS);
}

ULONG GenerateWebFiles(
    PCHAR WebDir,
    PMOFRESOURCE MofResource
    )
{
    ULONG Status;
    HANDLE IndexHandle, TemplateHandle;
    CHAR PathName[MAX_PATH];
    PCHAR FileName;
    ULONG Len, Index;
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;
    PMOFCLASSINFOW ClassInfo;
    CBMOFObj *ClassObject;

    if (! CreateDirectory(WebDir, NULL))
    {
        Status = GetLastError();
        if (Status != ERROR_ALREADY_EXISTS)
        {
            return(Status);
        }
    }

    strcpy(PathName, WebDir);
    Len = strlen(PathName)-1;
    if (PathName[Len] != '\\')
    {
        PathName[++Len] = '\\';
        PathName[++Len] = 0;
    } else {
        Len++;
    }
    FileName = &PathName[Len];

    strcpy(FileName, "index.htm");
    IndexHandle = CreateFile(PathName,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
    if ((IndexHandle == NULL) || (IndexHandle == INVALID_HANDLE_VALUE))
    {
        return(GetLastError());
    }

    FilePrint(IndexHandle,
              "<HTML>\r\n<HEAD><TITLE>Class List</TITLE></HEAD><BODY>\r\n");


    //
    // Loop over all mof classes
    Index = 0;
    MofClassList = MofResource->MRMCHead.Flink;
    while (MofClassList != &MofResource->MRMCHead)
    {
        MofClass = CONTAINING_RECORD(MofClassList,
                                         MOFCLASS,
                                         MCMRList);

        ClassInfo = MofClass->MofClassInfo;
        ClassObject = (CBMOFObj *)MofClass->ClassObjectHandle;

        if (! (ClassInfo->Flags & MOFCI_FLAG_EMBEDDED_CLASS))
        {
            //
            // don't create pages for embedded classes or events
            sprintf(FileName, "%ws.htm", ClassInfo->Name);
            TemplateHandle = CreateFile(PathName,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

            if ((TemplateHandle == NULL) || (TemplateHandle == INVALID_HANDLE_VALUE))
            {
                CloseHandle(IndexHandle);
                return(GetLastError());
            }

            FilePrint(IndexHandle,
                      "<H3><A href=\"%ws.htm\">%ws</A></H3><HR>",
                      ClassInfo->Name,
                      ClassInfo->Name);

            Status = GenerateClassWebPage(TemplateHandle,
                                          MofClass,
                                          MofResource);

            CloseHandle(TemplateHandle);
        }
        MofClassList = MofClassList->Flink;
    }

    FilePrint(IndexHandle, "</BODY>\r\n</HTML>\r\n");
    CloseHandle(IndexHandle);
    return(ERROR_SUCCESS);
}

ULONG AppendUnicodeTextFiles(
    char *DestFile,
    char *SrcFile1,
    char *SrcFile2                           
    )
{
    #define READ_BLOCK_SIZE 0x8000
    
    HANDLE DestHandle, SrcHandle;
    ULONG BytesRead, BytesWritten;
    PUCHAR Buffer, p;
    BOOL b;
    ULONG Status = ERROR_SUCCESS;
    BOOLEAN FirstTime;
    ULONG TotalBytesRead = 0;
    ULONG TotalBytesWritten = 0;
    ULONG ReadSize;
    CHAR c;

    //
    // This is a very simple procedure. We append the second file onto
    // the end of the first file, however we always skip the first 2
    // bytes of the second file if they are a 0xFFFE. This signature
    // denotes that the file is a unicode text file, but if it gets
    // appended in the middle of the file then mofcomp will get really
    // pissed off and barf.
    //
    Buffer = (PUCHAR)WmipAlloc(READ_BLOCK_SIZE);
    if (Buffer != NULL)
    {
        DestHandle = CreateFile(DestFile,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
        if (DestHandle != INVALID_HANDLE_VALUE)
        {
            SrcHandle = CreateFile(SrcFile1,
                                   GENERIC_READ,
                                   0,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);
            if (SrcHandle != INVALID_HANDLE_VALUE)
            {
                //
                // Just copy over all data from first file into
                // destination
                //
                do
                {
                    b = ReadFile(SrcHandle,
                                 Buffer,
                                 READ_BLOCK_SIZE,
                                 &BytesRead,
                                 NULL);
                    if (b)
                    {
                        TotalBytesRead += BytesRead;
                        WmipDebugPrint(("Read 0x%x/0x%x from Source 1\n",
                                        BytesRead, TotalBytesRead));
                        b = WriteFile(DestHandle,
                                      Buffer,
                                      BytesRead,
                                      &BytesWritten,
                                      NULL);
                        if (!b)
                        {                           
                            Status = GetLastError();
                            break;
                        } else if (BytesWritten != BytesRead) {
                            Status = ERROR_BAD_LENGTH;
                            break;
                        }
                        TotalBytesWritten += BytesWritten;
                        WmipDebugPrint(("Wrote 0x%x/0x%x to Dest\n",
                                        BytesWritten, TotalBytesWritten));
                    } else { 
                        Status = GetLastError();
                        break;
                    }
                } while (BytesRead == READ_BLOCK_SIZE);
                
                CloseHandle(SrcHandle);

                //
                // Now copy the data from the second file, but make
                // sure we skip any 0xFFFE at the beginning of the
                // second file
                //
                TotalBytesRead = 0;
                SrcHandle = CreateFile(SrcFile2,
                                       GENERIC_READ,
                                       0,
                                       NULL,
                                       OPEN_EXISTING,
                                       FILE_ATTRIBUTE_NORMAL,
                                       NULL);
                if (SrcHandle != INVALID_HANDLE_VALUE)
                {
                    FirstTime = TRUE;
                    do
                    {
                        b = ReadFile(SrcHandle,
                                 Buffer,
                                 READ_BLOCK_SIZE,
                                 &BytesRead,
                                 NULL);
                        
                        if (b)
                        {
                            ReadSize = READ_BLOCK_SIZE;
                            
                            TotalBytesRead += BytesRead;
                            WmipDebugPrint(("Read 0x%x/0x%x from Source 2\n",
                                        BytesRead, TotalBytesRead));
                            if (FirstTime)
                            {
                                FirstTime = FALSE;
                                if ( *((PWCHAR)Buffer) = 0xFFFE )
                                {
                                    WmipDebugPrint(("First Time and need to skip 2 bytes\n"));
                                    p = Buffer + 2;
                                    BytesRead -= 2;
                                    ReadSize -= 2;
                                }
                            } else {
                                p = Buffer;
                            }
                                
                            b = WriteFile(DestHandle,
                                      p,
                                      BytesRead,
                                      &BytesWritten,
                                      NULL);
                            if (!b)
                            {                           
                                Status = GetLastError();
                                break;
                            } else if (BytesWritten != BytesRead) {
                                Status = ERROR_BAD_LENGTH;
                                break;
                            }
                            TotalBytesWritten += BytesWritten;
                            WmipDebugPrint(("Wrote 0x%x/0x%x to Dest\n",
                                        BytesWritten, TotalBytesWritten));
                        } else { 
                            Status = GetLastError();
                            break;
                        }
                    } while (BytesRead == ReadSize);

                    if (Status == ERROR_SUCCESS)
                    {
                        //
                        // Copy put a ^Z at the end so well do that too
                        //
                        c = 0x1a;
                        b = WriteFile(DestHandle,
                                      &c,
                                      1,
                                      &BytesWritten,
                                      NULL);

                        if (!b)
                        {                           
                            Status = GetLastError();
                        } else if (BytesWritten != 1) {
                            Status = ERROR_BAD_LENGTH;
                        }
                        TotalBytesWritten += BytesWritten;
                        WmipDebugPrint(("Wrote 0x%x/0x%x to Dest\n",
                                        BytesWritten, TotalBytesWritten));
                    }
                    
                    CloseHandle(SrcHandle);
                }
                
            } else {
                Status = GetLastError();
            }
            CloseHandle(DestHandle);
        } else {
            Status = GetLastError();
        }
        WmipFree(Buffer);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(Status); 
}


void Usage(
    void
    )
{
    printf("WMI Mof Check Tool - Revision 19\n");
    printf("\n");
    printf("WmiMofCk validates that the classes, properties, methods and events specified \n");
    printf("in a binary mof file (.bmf) are valid for use with WMI. It also generates \n");
    printf("useful output files needed to build and test the WMI data provider.\n");
    printf("\n");
    printf("If the -h parameter is specified then a C language header file is created\n");
    printf("that defines the guids, data structures and method indicies specified in the\n");
    printf("MOF file.\n");
    printf("\n");
    printf("If the -t parameter is specified then a VBScript applet is created that will\n");
    printf("query all data blocks and properties specified in the MOF file. This can be\n");
    printf("useful for testing WMI data providers.\n");
    printf("\n");
    printf("If the -x parameter is specified then a text file is created that contains\n");
    printf("the text representation of the binary mof data. This can be included in \n");
    printf("the source of the driver if the driver supports reporting the binary mof \n");
    printf("via a WMI query rather than a resource on the driver image file.\n\n");
    printf("If the -c parameter is specified then a C language source file is\n");
    printf("generated that contains a template for implementing WMI code in\n");
    printf("a device driver\n\n");
    printf("if the -w parameter is specified then a set of HTML files are\n");
    printf("generated that create a rudimentary UI that can be used to access\n");
    printf("the wmi data blocks\n\n");
    printf("if the -m parameter is specified then structure definitions for\n");
    printf("method parameter lists are generated in the generated header file.\n\n");
    printf("if the -u parameter is specified then structure definitions for all\n");
    printf("data blocks are generated unconditionally\n\n");
    printf("\n");
    printf("Usage:\n");
    printf("    wmimofck -h<C Source Language Header output file>\n");
    printf("             -c<C Source Language Code output file>\n");
    printf("             -x<Hexdump output file>\n");
    printf("             -t<Command line VBScript test output file>\n");
    printf("             -w<HTML UI output file directory>\n");
    printf("             -y<MofFile> -z<MflFile>\n");
    printf("             -m\n");
    printf("             -u\n");
    printf("             <binary mof input file>\n\n");
}

#define IsWhiteSpace(c) ( (c == ' ') || (c == '\t') )
ULONG GetParameter(
    char *Parameter,
    ULONG ParameterSize,
    char *CommandLine
    )
{
    ULONG i;

    i = 0;
    ParameterSize--;

    while ( (! IsWhiteSpace(*CommandLine)) &&
            ( *CommandLine != 0) &&
            (i < ParameterSize) )
    {
        *Parameter++ = *CommandLine++;
        i++;
    }
    *Parameter = 0;
    return(i);
}

int _cdecl main(int argc, char *argv[])
{
    char BMofFile[MAX_PATH];
    char *Parameter;
    int i;
    ULONG Status;
    char ASLFile[MAX_PATH];
    char CFile[MAX_PATH];
    char HFile[MAX_PATH];
    char XFile[MAX_PATH];
    char TFile[MAX_PATH];
    char WebDir[MAX_PATH];
    char MofFile[MAX_PATH];
    char MflFile[MAX_PATH];
    char c;
    PMOFRESOURCE MofResource;

    *ASLFile = 0;
    *CFile = 0;
    *HFile = 0;
    *XFile = 0;
    *TFile = 0;
    *WebDir = 0;
    *MofFile = 0;
    *MflFile = 0;
    *BMofFile = 0;

    printf("Microsoft (R) WDM Extensions To WMI MOF Checking Utility  Version 1.50.0000\n");
    printf("Copyright (c) Microsoft Corp. 1997-2000. All rights reserved.\n\n");

    SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT);   // BUGBUG: Remove when MOF format maintains alignment correctly

    if (argc == 1)
    {
        Usage();
        return(1);
    }

    i = 1;
    while (i < argc)
    {
        Parameter = argv[i++];
        if (IsWhiteSpace(*Parameter))
        {
            Parameter++;
            continue;
        }

        if (*Parameter != '-')
        {
            //
            // Parameter does not start with -, must be bmof filename
            if (*BMofFile != 0)
            {
                //
                // Only one filename allowed
                Usage();
            }
            GetParameter(BMofFile, sizeof(BMofFile), Parameter);
        } else {
            Parameter++;
            // Check for - parameters here
            c = (CHAR)toupper(*Parameter);
            Parameter++;
            switch (c)
            {
                case 'A' :
                {
                    GetParameter(ASLFile, sizeof(ASLFile), Parameter);
                    break;
                }

                case 'C':
                {
                    GetParameter(CFile, sizeof(CFile), Parameter);
                    break;
                }

                case 'H':
                {
                    GetParameter(HFile, sizeof(HFile), Parameter);
                    break;
                }

                case 'U':
                {
                    ForceHeaderGeneration = TRUE;
                }

                case 'M':
                {
                    DoMethodHeaderGeneration = TRUE;
                    break;
                }

                case 'X':
                {
                    GetParameter(XFile, sizeof(XFile), Parameter);
                    break;
                }

                case 'T':
                {
                    GetParameter(TFile, sizeof(TFile), Parameter);
                    break;
                }

                case 'W':
                {
                    GetParameter(WebDir, sizeof(WebDir), Parameter);
                    break;
                }

                case 'Y':
                {
                    GetParameter(MofFile, sizeof(MofFile), Parameter);
                    break;
                }

                case 'Z':
                {
                    GetParameter(MflFile, sizeof(MflFile), Parameter);
                    break;
                }

                default: {
                    Usage();
                    return(1);
                }
            }

        }
    }

    if (*BMofFile == 0)
    {
        //
        // We must have a filename
        Usage();
        return(1);
    }

    if (*MofFile != 0)
    {
        if (*MflFile != 0)
        {
            Status = AppendUnicodeTextFiles(BMofFile, MofFile, MflFile);
        } else {
            Usage();
            return(1);
        }
        return(Status);
    }

    
    Status = ParseBinaryMofFile(BMofFile, &MofResource);

    if (Status == ERROR_SUCCESS)
    {
        if (*HFile != 0)
        {
            //
            // Generate C Header file
            Status = GenerateHTemplate(HFile, MofResource);
            if (Status != ERROR_SUCCESS)
            {
                //
                // TODO: Better message
                printf("Error %d creating C Header Template file \n", Status);
            }
        }

        if (*XFile != 0)
        {
            //
            // Generate X Header file
            Status = GenerateXTemplate(XFile);
            if (Status != ERROR_SUCCESS)
            {
                //
                // TODO: Better message
                printf("Error %d creating X Header Template file \n", Status);
            }
        }

        if (*TFile != 0)
        {
            //
            // Generate C output template
            Status = GenerateTTemplate(TFile, MofResource);
            if (Status != ERROR_SUCCESS)
            {
                //
                // TODO: Better message
                printf("Error %d creating C Template file \n", Status);
            }
        }

        if (*CFile != 0)
        {
            //
            // Generate C output template
            Status = GenerateCTemplate(CFile,
                                       HFile,
                                       *XFile == 0 ? CFile : XFile,
                                       MofResource);
            if (Status != ERROR_SUCCESS)
            {
                //
                // TODO: Better message
                printf("Error %d creating C Template file \n", Status);
            }
        }

        if (*WebDir != 0)
        {
            //
            // Generate HTML UI for classes
            //
            Status = GenerateWebFiles(WebDir,
                                      MofResource);
        }

        if (*ASLFile != 0)
        {
            //
            // Generate ASL output template
            Status = GenerateASLTemplate(ASLFile);
        }
    }
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\ntdll\logapi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    logapi.c

Abstract:

    WMI logger api set. The routines here will need to appear like they
    are system calls. They are necessary to do the necessary error checking
    and do most of the legwork that can be done outside the kernel. The
    kernel portion will subsequently only deal with the actual logging
    and tracing.

Author:

    28-May-1997 JeePang

Revision History:

--*/

#ifndef MEMPHIS
#ifdef DBG
#include <stdio.h> // only for fprintf
#endif
#include <nt.h>
#include <ntrtl.h>          // for ntutrl.h
#include <nturtl.h>         // for RTL_CRITICAL_SECTION in winbase.h/wtypes.h
#include <wtypes.h>         // for LPGUID in wmium.h
#include <ntverp.h>
#include "wmiump.h"
#include "evntrace.h"
#include "tracelib.h"
#include "trcapi.h"

#define MAXSTR                          1024
#define MAXGUIDCOUNT                    65536

#define MAXINST                         0XFFFFFFFF
#define TRACE_RETRY_COUNT               5

#define TRACE_HEADER_FULL   (TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                            | (TRACE_HEADER_TYPE_FULL_HEADER << 16))

#define TRACE_HEADER_INSTANCE (TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                            | (TRACE_HEADER_TYPE_INSTANCE << 16))

ULONG   WmipIsBBTOn = 0;


//
// This guid is used by RegisterTraceGuids when register a tracelog
// provider. Any ACLs for controlling registration should be placed on
// this guid. Note that since the kernel will created unnamed guid
// objects, multiple tracelog providers can register without issue.
//
// {DF8480A1-7492-4f45-AB78-1084642581FB}
GUID RegisterReservedGuid = { 0xdf8480a1, 0x7492, 0x4f45, 0xab, 0x78, 0x10, 0x84, 0x64, 0x25, 0x81, 0xfb };
						   
//
// Local Data Structures Used
//
typedef struct _TRACE_REG_PACKET {
    ULONG RegistrationCookie;
    ULONG Reserved;
} TRACE_REG_PACKET, *PTRACE_REG_PACKET;

HANDLE WmipDeviceHandle = NULL;

VOID
WmipCopyInfoToProperties(
    IN PWMI_LOGGER_INFORMATION Info,
    IN PEVENT_TRACE_PROPERTIES Properties
    );

VOID
WmipCopyPropertiesToInfo(
    IN PEVENT_TRACE_PROPERTIES Properties,
    IN PWMI_LOGGER_INFORMATION Info
    );


NTSTATUS
WmipTraceUmMessage(
    IN ULONG    Size,
    IN ULONG64  LoggerHandle,
    IN ULONG    MessageFlags,
    IN LPGUID   MessageGuid,
    IN USHORT   MessageNumber,
    va_list     MessageArgList
);

VOID
WmipFixupLoggerStrings(
    PWMI_LOGGER_INFORMATION LoggerInfo
    );


VOID
WmipFixupLoggerStrings(
    PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    ULONG Offset = sizeof(WMI_LOGGER_INFORMATION);
    ULONG LoggerInfoSize;

    if (LoggerInfo == NULL)
        return;

    LoggerInfoSize = LoggerInfo->Wnode.BufferSize;

    if (LoggerInfoSize <= Offset)

        return;

    //
    // Fixup LoggerName first
    //

    if (LoggerInfo->LoggerName.Length > 0) {
        LoggerInfo->LoggerName.Buffer = (PWCHAR) ((PUCHAR)LoggerInfo + Offset);
        Offset += LoggerInfo->LoggerName.MaximumLength;
    }

    if (LoggerInfoSize <= Offset) 
        return;

    if (LoggerInfo->LogFileName.Length > 0) {
        LoggerInfo->LogFileName.Buffer = (PWCHAR)((PUCHAR)LoggerInfo + Offset);
        Offset += LoggerInfo->LogFileName.MaximumLength;
    }

#ifdef DBG
    WmipAssert(LoggerInfoSize >= Offset);
#endif
}

/*
ULONG
WMIAPI
StartTraceA(
    OUT PTRACEHANDLE LoggerHandle,
    IN LPCSTR LoggerName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
/*++

Routine Description:

    This is the ANSI version routine to start a logger.
    The caller must pass in a pointer to accept the returned logger handle,
    and must provide a valid logger name.

Arguments:

    LoggerHandle    The handle to the logger to be returned.

    LoggerName      A unique name for the logger

    Properties      Logger properties. If the caller wishes to use WMI's
                    defaults, all the numeric values must be set to 0.
                    Furthermore, the LoggerName and LogFileName fields
                    within must point to sufficient storage for the names
                    to be returned.

Return Value:

    The status of performing the action requested.

--*//*
{
    NTSTATUS Status;
    ULONG ErrorCode;
    PWMI_LOGGER_INFORMATION LoggerInfo = NULL;
    ANSI_STRING AnsiString;
    ULONG IsLogFile;
    LPSTR CapturedName;
    ULONG SizeNeeded;
    ULONG LogFileNameLen, LoggerNameLen;
    PCHAR LogFileName;
    PTRACE_ENABLE_FLAG_EXTENSION FlagExt = NULL;
    PCHAR Buffer=NULL;
    PCHAR FullPathName=NULL;
    ULONG FullPathNameSize = MAXSTR;


    WmipInitProcessHeap();
    
    // first check to make sure that arguments passed are alright
    //

    if (Properties == NULL || LoggerHandle == NULL) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }
    if (LoggerName == NULL) {
        return WmipSetDosError(ERROR_INVALID_NAME);
    }

    IsLogFile = TRUE;
    LogFileNameLen = 0;
    LoggerNameLen = 0;
    LogFileName = NULL;

    try {
        // LoggerName is a Mandatory Parameter. Must provide space for it. 
        //
        LoggerNameLen = strlen(LoggerName);
        SizeNeeded = sizeof (EVENT_TRACE_PROPERTIES) + LoggerNameLen + 1;

        // If the caller supplied loggername and LogFileName offsets
        // make sure they are in range. 
        //
        if (Properties->LoggerNameOffset > 0) 
            if ((Properties->LoggerNameOffset < sizeof (EVENT_TRACE_PROPERTIES))
            || (Properties->LoggerNameOffset > Properties->Wnode.BufferSize))
                return WmipSetDosError(ERROR_INVALID_PARAMETER);

        if (Properties->LogFileNameOffset > 0) {
            ULONG RetValue;

            if ((Properties->LogFileNameOffset < sizeof(EVENT_TRACE_PROPERTIES))
            || (Properties->LogFileNameOffset > Properties->Wnode.BufferSize))
                return WmipSetDosError(ERROR_INVALID_PARAMETER);

            LogFileName = ((PCHAR)Properties + Properties->LogFileNameOffset );
            SizeNeeded += sizeof (LogFileName);

Retry:
            FullPathName = WmipAlloc(FullPathNameSize);
            if (FullPathName == NULL) {
                return WmipSetDosError(ERROR_OUTOFMEMORY);
            }
            RetValue = GetFullPathName(LogFileName, FullPathNameSize, FullPathName, NULL);

            if (RetValue != 0) {
                if (RetValue > FullPathNameSize) {
                    WmipFree(FullPathName);
                    FullPathNameSize = RetValue;
                    goto Retry;
                }
                else {
                    LogFileName = FullPathName;
                }
            }
            LogFileNameLen = strlen(LogFileName);
            if (LogFileNameLen == 0) 
                IsLogFile = FALSE;

        }
        else 
            IsLogFile = FALSE;

        //
        //  Check to see if there is room in the Properties structure
        //  to return both the InstanceName (LoggerName) and the LogFileName
        //
            

        if (Properties->Wnode.BufferSize < SizeNeeded) {
            ErrorCode = ERROR_BAD_LENGTH;
            goto Cleanup;
        }

        CapturedName = (LPSTR) LoggerName;
        LoggerNameLen = strlen(CapturedName);

        if (LoggerNameLen <= 0) {
            ErrorCode = ERROR_INVALID_NAME;
            goto Cleanup;
        }

        if (!(Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
            if (!IsLogFile) {
                ErrorCode = ERROR_BAD_PATHNAME;
                goto Cleanup;
            }
        }

        if ((Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) &&
            (Properties->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) ) {
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        if (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) {
            if (   (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
                || (Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        //
        // Relogger is supported only with Private Logger
        //
        if (Properties->LogFileMode & EVENT_TRACE_RELOG_MODE) {
            if (!(Properties->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) 
                || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
                || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE)
                || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) ) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        if (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE) {
            if ((Properties->MaximumFileSize == 0) ||
                (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) ||
                (IsLogFile != TRUE)
               ){
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            //
            // Check to see if there a %d Pattern in the LogFileName
            //
            Buffer = WmipAlloc((LogFileNameLen+64) * sizeof(CHAR) );
            if (Buffer == NULL) {
                ErrorCode = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }

            sprintf(Buffer, LogFileName, 1);
            if (RtlEqualMemory(LogFileName, Buffer, LogFileNameLen) ) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

    // For UserMode logger the LoggerName and LogFileName must be
    // passed in as offsets. 
    //
        SizeNeeded = sizeof(WMI_LOGGER_INFORMATION) +
                     (LoggerNameLen  + 1) * sizeof(WCHAR) +
                     (LogFileNameLen + 1) * sizeof(WCHAR);

        if (Properties->EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &Properties->EnableFlags;
            if ((FlagExt->Length == 0) || (FlagExt->Offset == 0))
                return WmipSetDosError(ERROR_INVALID_PARAMETER);
            SizeNeeded += FlagExt->Length * sizeof(ULONG);
        }

        SizeNeeded = (SizeNeeded +7) & ~7;

        LoggerInfo = WmipAlloc(SizeNeeded);
        if (LoggerInfo == NULL) {
            ErrorCode = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        RtlZeroMemory(LoggerInfo, SizeNeeded);

    // at this point, we need to prepare WMI_LOGGER_INFORMATION
    // which requires Ansi strings to be converted to UNICODE_STRING
    //
        *LoggerHandle = 0;

        WmipCopyPropertiesToInfo(
            (PEVENT_TRACE_PROPERTIES) Properties,
            LoggerInfo);

        //
        // If we are relogging, the caller passes in the number of processors
        // for the Private logger to use via the ProviderId field in Wnode
        //

        LoggerInfo->NumberOfProcessors = Properties->Wnode.ProviderId;
        LoggerInfo->Wnode.ProviderId = 0;


        RtlInitAnsiString(&AnsiString, CapturedName);

        LoggerInfo->LoggerName.MaximumLength =
                                (USHORT) (sizeof(WCHAR) * (LoggerNameLen + 1));
        LoggerInfo->LoggerName.Buffer =
                (LPWSTR) (  ((PUCHAR) LoggerInfo)
                          + sizeof(WMI_LOGGER_INFORMATION));
        Status = RtlAnsiStringToUnicodeString(
                    &LoggerInfo->LoggerName,
                    &AnsiString, FALSE);
        if (!NT_SUCCESS(Status)) {
            ErrorCode = WmipSetNtStatus(Status);
            goto Cleanup;
        }

        if (IsLogFile) {
            LoggerInfo->LogFileName.MaximumLength =
                                (USHORT) (sizeof(WCHAR) * (LogFileNameLen + 1));
            LoggerInfo->LogFileName.Buffer =
                    (LPWSTR) (  ((PUCHAR) LoggerInfo)
                              + sizeof(WMI_LOGGER_INFORMATION)
                              + LoggerInfo->LoggerName.MaximumLength);

            RtlInitAnsiString(&AnsiString, LogFileName);
            Status = RtlAnsiStringToUnicodeString(
                        &LoggerInfo->LogFileName,
                        &AnsiString, FALSE);

            if (!NT_SUCCESS(Status)) {
                ErrorCode = WmipSetNtStatus(Status);
                goto Cleanup;
            }
        }

        LoggerInfo->Wnode.BufferSize = SizeNeeded;
        LoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;

        if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            PTRACE_ENABLE_FLAG_EXTENSION tFlagExt;
            ULONG Offset;
            tFlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &LoggerInfo->EnableFlags;
            Offset = SizeNeeded - (FlagExt->Length * sizeof(ULONG));
            tFlagExt->Offset = (USHORT) Offset;
            RtlCopyMemory(
                (PCHAR) LoggerInfo + Offset,
                (PCHAR) Properties + FlagExt->Offset,
                FlagExt->Length * sizeof(ULONG) );
        }


        ErrorCode = WmipStartLogger(LoggerInfo);

        if (ErrorCode == ERROR_SUCCESS) {
            ULONG AvailableLength, RequiredLength;
            PCHAR pLoggerName, pLogFileName;

            WmipCopyInfoToProperties(
                LoggerInfo, 
                (PEVENT_TRACE_PROPERTIES)Properties);

            if (Properties->LoggerNameOffset == 0) {
                Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
            }
            
            pLoggerName = (PCHAR)((PCHAR)Properties + 
                                  Properties->LoggerNameOffset );

            if (Properties->LoggerNameOffset >  Properties->LogFileNameOffset )
                AvailableLength = Properties->Wnode.BufferSize -
                                 Properties->LoggerNameOffset;
            else
                AvailableLength =  Properties->LogFileNameOffset -
                                  Properties->LoggerNameOffset;

            RequiredLength = strlen(CapturedName) + 1;
            if (RequiredLength <= AvailableLength) {
               strcpy(pLoggerName, CapturedName); 
            }
            *LoggerHandle = LoggerInfo->Wnode.HistoricalContext;

            // 
            // If there is room copy fullpath name
            //
            if (Properties->LogFileNameOffset > Properties->LoggerNameOffset )
                AvailableLength = Properties->Wnode.BufferSize -
                                 Properties->LogFileNameOffset;
            else
                AvailableLength =  Properties->LoggerNameOffset -
                                  Properties->LogFileNameOffset;



            if ( (LogFileNameLen > 0) && (AvailableLength >= LogFileNameLen) ) {

                pLogFileName = (PCHAR)((PCHAR)Properties +
                                           Properties->LogFileNameOffset );

                strcpy(pLogFileName, LogFileName);

            }
        }
    }


    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = WmipSetNtStatus( GetExceptionCode() );
    }

Cleanup:
    if (LoggerInfo != NULL)     
        WmipFree(LoggerInfo);
    if (FullPathName != NULL)   
        WmipFree(FullPathName);
    if (Buffer != NULL)         
        WmipFree(Buffer); 

    return WmipSetDosError(ErrorCode);
}

ULONG
WMIAPI
StartTraceW(
    OUT    PTRACEHANDLE            LoggerHandle,
    IN     LPCWSTR                 LoggerName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
/*++

Routine Description:

    This is the Unicode version routine to start a logger.
    The caller must pass in a pointer to accept the returned logger handle,
    and must provide a valid logger name.

Arguments:

    LoggerHandle    The handle to the logger to be returned.

    LoggerName      A unique name for the logger

    Properties      Logger properties. If the caller wishes to use WMI's
                    defaults, all the numeric values must be set to 0.
                    Furthermore, the LoggerName and LogFileName fields
                    within must point to sufficient storage for the names
                    to be returned.

Return Value:

    The status of performing the action requested.

--*//*
{
    ULONG ErrorCode;
    PWMI_LOGGER_INFORMATION LoggerInfo = NULL;
    ULONG  IsLogFile;
    LPWSTR CapturedName;
    ULONG  SizeNeeded;
    USHORT LogFileNameLen, LoggerNameLen;
    PWCHAR LogFileName;
    PTRACE_ENABLE_FLAG_EXTENSION FlagExt = NULL;
    PWCHAR Buffer = NULL;
    PWCHAR FullPathName = NULL;
    ULONG FullPathNameSize = MAXSTR;
    ULONG RetValue;


    WmipInitProcessHeap();
    
    // first check to make sure that arguments passed are alright
    //

    if (Properties == NULL || LoggerHandle == NULL) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }
    if (LoggerName == NULL) {
        return WmipSetDosError(ERROR_INVALID_NAME);
    }

    IsLogFile = TRUE;
    LogFileNameLen = 0;
    LoggerNameLen = 0;
    LogFileName = NULL;

    try {
        // LoggerName is a Mandatory Parameter. Must provide space for it.
        //
        CapturedName = (LPWSTR) LoggerName;
        LoggerNameLen =  (USHORT) wcslen(CapturedName);

        SizeNeeded = sizeof (EVENT_TRACE_PROPERTIES) + (LoggerNameLen + 1) * sizeof(WCHAR);


        // If the caller supplied loggername and LogFileName offsets
        // make sure they are in range.
        //

        if (Properties->LoggerNameOffset > 0)
            if ((Properties->LoggerNameOffset < sizeof(EVENT_TRACE_PROPERTIES))
            || (Properties->LoggerNameOffset > Properties->Wnode.BufferSize))
                return WmipSetDosError(ERROR_INVALID_PARAMETER);

        if (Properties->LogFileNameOffset > 0) {
            if ((Properties->LogFileNameOffset < sizeof(EVENT_TRACE_PROPERTIES)) 
            || (Properties->LogFileNameOffset > Properties->Wnode.BufferSize))
                return WmipSetDosError(ERROR_INVALID_PARAMETER);

            LogFileName = (PWCHAR)((char*)Properties + 
                              Properties->LogFileNameOffset);
            SizeNeeded += (wcslen(LogFileName) +1) * sizeof(WCHAR);

Retry:
            FullPathName = WmipAlloc(FullPathNameSize * sizeof(WCHAR));
            if (FullPathName == NULL) {
                return WmipSetDosError(ERROR_OUTOFMEMORY);
            }

            RetValue = GetFullPathNameW(LogFileName, FullPathNameSize, FullPathName,NULL);
            if (RetValue != 0) {
                if (RetValue > FullPathNameSize) {
                    WmipFree(FullPathName);
                    FullPathNameSize =  RetValue;
                    goto Retry;
                }
                else {
                    LogFileName = FullPathName;
                }
            }
            LogFileNameLen = (USHORT) wcslen(LogFileName);
            if (LogFileNameLen <= 0)
                IsLogFile = FALSE;
        }
        else 
            IsLogFile = FALSE;

        //
        // Check to see if there is room for both LogFileName and
        // LoggerName (InstanceName) to be returned
        //

        if (Properties->Wnode.BufferSize < SizeNeeded) {
            ErrorCode = ERROR_BAD_LENGTH;
            goto Cleanup;
        }

        LoggerNameLen = (USHORT) wcslen(CapturedName);
        if (LoggerNameLen <= 0) {
            ErrorCode = ERROR_INVALID_NAME;
            goto Cleanup;
        }

        if (!(Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
            if (!IsLogFile) {
                ErrorCode = ERROR_BAD_PATHNAME;
                goto Cleanup;
            }
        }
        if ((Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) &&
            (Properties->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) ) {
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        if (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) {
            if (   (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
                || (Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
                ErrorCode = ERROR_INVALID_PARAMETER; 
                goto Cleanup;
            }
        }
        //
        // Relogger is supported only with Private Logger
        //
        if (Properties->LogFileMode & EVENT_TRACE_RELOG_MODE) {
            if (!(Properties->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
                || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
                || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE)
                || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) ) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        if (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE) {
            if ((Properties->MaximumFileSize == 0) ||
                (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) ||
                (IsLogFile != TRUE) 
               ){
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            //
            // Check to see if there a %d Pattern in the LogFileName
            //
            Buffer = WmipAlloc((LogFileNameLen+64) * sizeof(WCHAR) );
            if (Buffer == NULL) {
                ErrorCode = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }
            
            swprintf(Buffer, LogFileName, 1);
            if (RtlEqualMemory(LogFileName, Buffer, LogFileNameLen * sizeof(WCHAR))) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        SizeNeeded = sizeof(WMI_LOGGER_INFORMATION) + 
                     (LoggerNameLen +1) * sizeof(WCHAR) +
                     (LogFileNameLen + 1) * sizeof(WCHAR);

        if (Properties->EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &Properties->EnableFlags;
            if ((FlagExt->Length == 0) || (FlagExt->Offset == 0)) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            SizeNeeded += FlagExt->Length * sizeof(ULONG);            
        }

        SizeNeeded = (SizeNeeded +7) & ~7;
        LoggerInfo = WmipAlloc(SizeNeeded);
        if (LoggerInfo == NULL) {
            ErrorCode = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        RtlZeroMemory(LoggerInfo, SizeNeeded);

    // at this point, we need to prepare WMI_LOGGER_INFORMATION
    // which requires wide char strings to be converted to UNICODE_STRING
    //
        *LoggerHandle = 0;

        WmipCopyPropertiesToInfo(Properties, LoggerInfo);
        //
        // If we are relogging, the caller passes in the number of processors
        // for the Private logger to use via the ProviderId field in Wnode
        //

        LoggerInfo->NumberOfProcessors = Properties->Wnode.ProviderId;
        LoggerInfo->Wnode.ProviderId = 0;

        LoggerInfo->LoggerName.MaximumLength =
                sizeof(WCHAR) * (LoggerNameLen + 1);
        LoggerInfo->LoggerName.Length =
                sizeof(WCHAR) * LoggerNameLen;
        LoggerInfo->LoggerName.Buffer = (PWCHAR)
                (((PUCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION));
        wcsncpy(LoggerInfo->LoggerName.Buffer, LoggerName, LoggerNameLen);

        if (IsLogFile) {
            LoggerInfo->LogFileName.MaximumLength =
                    sizeof(WCHAR) * (LogFileNameLen + 1);
            LoggerInfo->LogFileName.Length =
                    sizeof(WCHAR) * LogFileNameLen;
            LoggerInfo->LogFileName.Buffer = (PWCHAR)
                    (((PUCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION)
                                   + LoggerInfo->LoggerName.MaximumLength);
            wcsncpy(LoggerInfo->LogFileName.Buffer,
                    LogFileName,
                    LogFileNameLen);

        }

        LoggerInfo->Wnode.BufferSize = SizeNeeded;
        LoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;

        if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            PTRACE_ENABLE_FLAG_EXTENSION tFlagExt;
            ULONG Offset;
            tFlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &LoggerInfo->EnableFlags;
            Offset = SizeNeeded - (FlagExt->Length * sizeof(ULONG));
            tFlagExt->Offset = (USHORT) Offset;
            RtlCopyMemory(
                (PCHAR) LoggerInfo + Offset,
                (PCHAR) Properties + FlagExt->Offset,
                FlagExt->Length * sizeof(ULONG) );
        }


        ErrorCode = WmipStartLogger(LoggerInfo);

        if (ErrorCode == ERROR_SUCCESS) {
            ULONG AvailableLength, RequiredLength;
            PWCHAR pLoggerName;
            PWCHAR pLogFileName;

            WmipCopyInfoToProperties(LoggerInfo, Properties);
            if (Properties->LoggerNameOffset > 0) {
                Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
            }
            pLoggerName = (PWCHAR)((PCHAR)Properties +
                                  Properties->LoggerNameOffset );

            if (Properties->LoggerNameOffset >  Properties->LogFileNameOffset )
                AvailableLength = Properties->Wnode.BufferSize -
                                 Properties->LoggerNameOffset;
            else
                AvailableLength =  Properties->LogFileNameOffset -
                                  Properties->LoggerNameOffset;


            RequiredLength = (wcslen(CapturedName) + 1) * sizeof(WCHAR);
            if (RequiredLength <= AvailableLength) {
               wcscpy(pLoggerName, CapturedName);
            }

            *LoggerHandle = LoggerInfo->Wnode.HistoricalContext;

            //
            // If there is room for FullPath name, return it
            // TODO: Do the same for ANSI code...
            // 

            if (Properties->LogFileNameOffset > Properties->LoggerNameOffset )
                AvailableLength = Properties->Wnode.BufferSize -
                                 Properties->LogFileNameOffset;
            else
                AvailableLength =  Properties->LoggerNameOffset -
                                  Properties->LogFileNameOffset;


            RequiredLength = LoggerInfo->LogFileName.Length;

            pLogFileName = (PWCHAR)((PCHAR)Properties +
                                           Properties->LogFileNameOffset );

            if ( (RequiredLength > 0) &&  (RequiredLength <= AvailableLength) ) {
                wcsncpy(pLogFileName, LoggerInfo->LogFileName.Buffer, LoggerInfo->LogFileName.Length);
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = WmipSetNtStatus( GetExceptionCode() );
    }

Cleanup:
    if (LoggerInfo != NULL)
        WmipFree(LoggerInfo);
    if (FullPathName != NULL)
        WmipFree(FullPathName);
    if (Buffer != NULL) 
        WmipFree(Buffer);
    return WmipSetDosError(ErrorCode);
}
*/
ULONG
WMIAPI
ControlTraceA(
    IN TRACEHANDLE LoggerHandle,
    IN LPCSTR LoggerName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG Control
    )
/*++

Routine Description:

    This is the ANSI version routine to control and query an existing logger.
    The caller must pass in either a valid handle, or a logger name to
    reference the logger instance. If both are given, the logger name will
    be used.

Arguments:

    LoggerHandle    The handle to the logger instance.

    LoggerName      A instance name for the logger

    Properties      Logger properties to be returned to the caller.

    Control         This can be one of the following:
                    EVENT_TRACE_CONTROL_QUERY     - to query the logger
                    EVENT_TRACE_CONTROL_STOP      - to stop the logger
                    EVENT_TRACE_CONTROL_UPDATE    - to update the logger
                    EVENT_TRACE_CONTROL_FLUSH   - to flush the logger

Return Value:

    The status of performing the action requested.

--*/
{
    NTSTATUS Status;
    ULONG ErrorCode;

    BOOLEAN IsKernelTrace = FALSE;
    PWMI_LOGGER_INFORMATION LoggerInfo     = NULL;
    PWCHAR                  strLoggerName  = NULL;
    PWCHAR                  strLogFileName = NULL;
    ULONG                   sizeNeeded     = 0;
    PCHAR                   FullPathName = NULL;
    ULONG                   LoggerNameLen = MAXSTR;
    ULONG                   LogFileNameLen = MAXSTR;
    ULONG                   FullPathNameSize = MAXSTR;
    ULONG                   RetValue;

    WmipInitProcessHeap();

    if (Properties == NULL) {
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    try {
        if (LoggerName != NULL) {
            LoggerNameLen = strlen(LoggerName) + 1;
            sizeNeeded = LoggerNameLen * sizeof(CHAR);
        }


        if (Properties->Wnode.BufferSize < sizeof(EVENT_TRACE_PROPERTIES) ) {
            ErrorCode = ERROR_BAD_LENGTH;
            goto Cleanup;
        }
        //
        // If the caller supplied loggername and LogFileName offsets
        // make sure they are in range.
        //
        if (Properties->LoggerNameOffset > 0) {
            if ((Properties->LoggerNameOffset < sizeof(EVENT_TRACE_PROPERTIES))
            || (Properties->LoggerNameOffset > Properties->Wnode.BufferSize))
            {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        if (Properties->LogFileNameOffset > 0) {
            if ((Properties->LogFileNameOffset < sizeof(EVENT_TRACE_PROPERTIES))
            || (Properties->LogFileNameOffset > Properties->Wnode.BufferSize))
            {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = ERROR_NOACCESS;
        goto Cleanup;
    }

RetryFull:

    sizeNeeded = sizeof(WMI_LOGGER_INFORMATION) + (LoggerNameLen + LogFileNameLen) * sizeof(WCHAR);
    sizeNeeded = (sizeNeeded +7) & ~7;
    LoggerInfo = (PWMI_LOGGER_INFORMATION) WmipAlloc(sizeNeeded);
    if (LoggerInfo == NULL) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(LoggerInfo, sizeNeeded);

    strLoggerName  = (PWCHAR) (  ((PUCHAR) LoggerInfo)
                            + sizeof(WMI_LOGGER_INFORMATION));
    WmipInitString(&LoggerInfo->LoggerName,
                   strLoggerName,
                   LoggerNameLen * sizeof(WCHAR));
    strLogFileName = (PWCHAR) (  ((PUCHAR) LoggerInfo)
                            + sizeof(WMI_LOGGER_INFORMATION)
                            + LoggerNameLen * sizeof(WCHAR));
    WmipInitString(&LoggerInfo->LogFileName,
                   strLogFileName,
                   LogFileNameLen * sizeof(WCHAR));

    // Look for logger name first
    //
    try {
        if (IsEqualGUID(&Properties->Wnode.Guid, &SystemTraceControlGuid)) {
            LoggerInfo->Wnode.Guid = Properties->Wnode.Guid;
            IsKernelTrace = TRUE;
        }
        if (LoggerName != NULL) {
            if (strlen(LoggerName) > 0) {
                ANSI_STRING AnsiString;

                RtlInitAnsiString(&AnsiString, LoggerName);
                Status = RtlAnsiStringToUnicodeString(
                    &LoggerInfo->LoggerName, &AnsiString, FALSE);
                if (!NT_SUCCESS(Status)) {
                    ErrorCode = WmipSetNtStatus(Status);
                    goto Cleanup;
                }
            }
            else if ((LoggerHandle == 0) && (!IsKernelTrace)) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        else if ((LoggerHandle == 0) && (!IsKernelTrace)) {
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        LoggerInfo->LogFileName.Buffer = (PWCHAR)
                (((PCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION)
                        + LoggerInfo->LoggerName.MaximumLength);

        if (Properties->LogFileNameOffset >= sizeof(EVENT_TRACE_PROPERTIES)) {
            ULONG  lenLogFileName;
            PCHAR  strLogFileName;

            strLogFileName = (PCHAR) (  ((PCHAR) Properties)
                                      + Properties->LogFileNameOffset);
Retry:
            FullPathName = WmipAlloc(FullPathNameSize);
            if (FullPathName == NULL) {
                ErrorCode = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }
            RetValue = WmipGetFullPathNameA(strLogFileName, FullPathNameSize, FullPathName, NULL); 
            if (RetValue != 0) {
                if (RetValue > FullPathNameSize) {
                    WmipFree(FullPathName);
                    FullPathNameSize = RetValue;
                    goto Retry;
                }
                else {
                    strLogFileName = FullPathName;
                }
            }

            lenLogFileName = strlen(strLogFileName);
            if (lenLogFileName > 0) {
                ANSI_STRING ansiLogFileName;

                RtlInitAnsiString(& ansiLogFileName, strLogFileName);
                LoggerInfo->LogFileName.MaximumLength =
                        sizeof(WCHAR) * ((USHORT) (lenLogFileName + 1));

                Status = RtlAnsiStringToUnicodeString(
                        & LoggerInfo->LogFileName, & ansiLogFileName, FALSE);
                if (!NT_SUCCESS(Status)) {
                    ErrorCode = WmipSetNtStatus(Status);
                    goto Cleanup;
                }
            }
        }
        // stuff the loggerhandle in Wnode
        LoggerInfo->Wnode.HistoricalContext = LoggerHandle;
        LoggerInfo->LogFileMode = Properties->LogFileMode;
        LoggerInfo->Wnode.BufferSize = sizeNeeded;
        LoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;

        //
        // For Private Loggers the Guid is required to  determine the provider
        //

        LoggerInfo->Wnode.Guid = Properties->Wnode.Guid;
        switch (Control) {
        case EVENT_TRACE_CONTROL_QUERY  :
            ErrorCode = WmipQueryLogger(LoggerInfo, FALSE);
            break;
        case EVENT_TRACE_CONTROL_STOP   :
            ErrorCode = WmipStopLogger(LoggerInfo);
            break;
        case EVENT_TRACE_CONTROL_UPDATE :
            WmipCopyPropertiesToInfo((PEVENT_TRACE_PROPERTIES) Properties,
                                     LoggerInfo);
            LoggerInfo->Wnode.HistoricalContext = LoggerHandle;
            ErrorCode = WmipQueryLogger(LoggerInfo, TRUE);
            break;
        case EVENT_TRACE_CONTROL_FLUSH :
            ErrorCode = WmipFlushLogger(LoggerInfo); 
            break;

        default :
            ErrorCode = ERROR_INVALID_PARAMETER;
        }

    //
    // The Kernel call could fail with ERROR_MORE_DATA and we need to retry 
    // with sufficient buffer space for the two strings. The size required 
    // is returned in the MaximuumLength field. 
    //

        if (ErrorCode == ERROR_MORE_DATA) {
            LogFileNameLen = LoggerInfo->LogFileName.MaximumLength / sizeof(WCHAR);
            LoggerNameLen = LoggerInfo->LoggerName.MaximumLength / sizeof(WCHAR);
            if (LoggerInfo != NULL) {
                WmipFree(LoggerInfo);
                LoggerInfo = NULL;
            }
            if (FullPathName != NULL) {
                WmipFree(FullPathName);
                FullPathName = NULL;
            }
            goto RetryFull;
        }


        if (ErrorCode == ERROR_SUCCESS) {
            ANSI_STRING String;
            PCHAR pLoggerName, pLogFileName;
            ULONG BytesAvailable;
            ULONG Length = 0;
//
// need to convert the strings back
//
            WmipCopyInfoToProperties(
                LoggerInfo, 
                (PEVENT_TRACE_PROPERTIES)Properties);

            WmipFixupLoggerStrings(LoggerInfo);

            if (Properties->LoggerNameOffset == 0) 
                Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);

            if (Properties->LoggerNameOffset > Properties->LogFileNameOffset)
                BytesAvailable = Properties->Wnode.BufferSize -
                                 Properties->LoggerNameOffset;
            else
                BytesAvailable =  Properties->LogFileNameOffset -
                                  Properties->LoggerNameOffset;

            Status = RtlUnicodeStringToAnsiString(
                                &String, &LoggerInfo->LoggerName, TRUE);
            if (NT_SUCCESS(Status)) {
                Length = String.Length;
                if (BytesAvailable < (Length + sizeof(CHAR)) ) {
                    PWNODE_TOO_SMALL WnodeSmall = (PWNODE_TOO_SMALL) Properties;
                    WnodeSmall->SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + Length 
                                            + LoggerInfo->LogFileName.Length + 2 * sizeof(CHAR);
                    WnodeSmall->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;
                    ErrorCode = ERROR_MORE_DATA;
                    goto Cleanup;
                }
                else {
                    pLoggerName = (PCHAR) ((PCHAR)Properties +
                                Properties->LoggerNameOffset);
                    RtlZeroMemory(pLoggerName, BytesAvailable);
                    if (Length > 0) {
                        strncpy(pLoggerName, String.Buffer, Length);
                    }
                }
                RtlFreeAnsiString(&String);
                ErrorCode = RtlNtStatusToDosError(Status);
            }

            if (Properties->LogFileNameOffset == 0) {
                Properties->LogFileNameOffset = Properties->LoggerNameOffset + 
                                                Length;
            }

            if (Properties->LogFileNameOffset > Properties->LoggerNameOffset)
                BytesAvailable = Properties->Wnode.BufferSize -
                                 Properties->LogFileNameOffset;
            else
                BytesAvailable =  Properties->LoggerNameOffset -
                                  Properties->LogFileNameOffset;

            Status = RtlUnicodeStringToAnsiString(
                                    &String, &LoggerInfo->LogFileName, TRUE);

            if (NT_SUCCESS(Status)) {
                Length = String.Length;
                if (BytesAvailable < (Length + sizeof(CHAR)) ) {
                    PWNODE_TOO_SMALL WnodeSmall = (PWNODE_TOO_SMALL) Properties;
                    WnodeSmall->SizeNeeded = (Properties->Wnode.BufferSize - BytesAvailable) + Length + sizeof(CHAR);
                    WnodeSmall->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;
                    ErrorCode = ERROR_MORE_DATA;
                }
                else {
                    pLogFileName = (PCHAR) ((PCHAR)Properties +
                                                    Properties->LogFileNameOffset);
                    RtlZeroMemory(pLogFileName, BytesAvailable);

                    strncpy(pLogFileName, String.Buffer, Length );
                }
                RtlFreeAnsiString(&String);
                ErrorCode = RtlNtStatusToDosError(Status);
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = WmipSetNtStatus(GetExceptionCode());
    }

Cleanup:
    if (LoggerInfo != NULL)
        WmipFree(LoggerInfo);
    if (FullPathName != NULL) 
        WmipFree(FullPathName);
    return WmipSetDosError(ErrorCode);
}
/*
ULONG
WMIAPI
ControlTraceW(
    IN TRACEHANDLE LoggerHandle,
    IN LPCWSTR LoggerName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG Control
    )
/*++

Routine Description:

    This is the ANSI version routine to control and query an existing logger.
    The caller must pass in either a valid handle, or a logger name to
    reference the logger instance. If both are given, the logger name will
    be used.

Arguments:

    LoggerHandle    The handle to the logger instance.

    LoggerName      A instance name for the logger

    Properties      Logger properties to be returned to the caller.

    Control         This can be one of the following:
                    EVENT_TRACE_CONTROL_QUERY     - to query the logger
                    EVENT_TRACE_CONTROL_STOP      - to stop the logger
                    EVENT_TRACE_CONTROL_UPDATE    - to update the logger
                    EVENT_TRACE_CONTROL_FLUSH     - to flush the logger

Return Value:

    The status of performing the action requested.

--*//*
{
    ULONG ErrorCode;
    BOOLEAN IsKernelTrace = FALSE;

    PWMI_LOGGER_INFORMATION LoggerInfo     = NULL;
    PWCHAR                  strLoggerName  = NULL;
    PWCHAR                  strLogFileName = NULL;
    ULONG                   sizeNeeded     = 0;
    PWCHAR                  FullPathName = NULL;
    ULONG                   LoggerNameLen = MAXSTR;
    ULONG                   LogFileNameLen = MAXSTR;
    ULONG                   RetValue;

    WmipInitProcessHeap();
    
    if (Properties == NULL) {
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    try {
        //
        //
        //
        if (LoggerName != NULL) {
            LoggerNameLen = wcslen(LoggerName) + 1;
            sizeNeeded = LoggerNameLen * sizeof(WCHAR);
        }
        //
        // LoggerName is a Mandatory Parameter. Must provide space for it.
        //
        if (Properties->Wnode.BufferSize < sizeof(EVENT_TRACE_PROPERTIES) ) {
            ErrorCode = ERROR_BAD_LENGTH;
            goto Cleanup;
        }
        //
        // If the caller supplied loggername and LogFileName offsets
        // make sure they are in range.
        //

        if (Properties->LoggerNameOffset > 0) {
            if ((Properties->LoggerNameOffset < sizeof (EVENT_TRACE_PROPERTIES))
            || (Properties->LoggerNameOffset > Properties->Wnode.BufferSize)) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        if (Properties->LogFileNameOffset > 0) {
            if ((Properties->LogFileNameOffset < sizeof(EVENT_TRACE_PROPERTIES))
            || (Properties->LogFileNameOffset > Properties->Wnode.BufferSize))
            {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = ERROR_NOACCESS;
        goto Cleanup;
    }

RetryFull:
    sizeNeeded = sizeof(WMI_LOGGER_INFORMATION) + (LoggerNameLen + LogFileNameLen) * sizeof(WCHAR);

    sizeNeeded = (sizeNeeded +7) & ~7;
    LoggerInfo = (PWMI_LOGGER_INFORMATION) WmipAlloc(sizeNeeded);
    if (LoggerInfo == NULL) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(LoggerInfo, sizeNeeded);

    strLoggerName  = (PWCHAR) (  ((PUCHAR) LoggerInfo)
                            + sizeof(WMI_LOGGER_INFORMATION));
    WmipInitString(&LoggerInfo->LoggerName,
                   strLoggerName,
                   LoggerNameLen * sizeof(WCHAR));
    strLogFileName = (PWCHAR) (  ((PUCHAR) LoggerInfo)
                            + sizeof(WMI_LOGGER_INFORMATION)
                            + LoggerNameLen * sizeof(WCHAR));
    WmipInitString(&LoggerInfo->LogFileName,
                   strLogFileName,
                   LogFileNameLen * sizeof(WCHAR));
    try {

        if (IsEqualGUID(&Properties->Wnode.Guid, &SystemTraceControlGuid)) {
            LoggerInfo->Wnode.Guid = Properties->Wnode.Guid;
            IsKernelTrace = TRUE;
        }
        if (LoggerName != NULL) {
            if (wcslen(LoggerName) > 0) {
                wcscpy(strLoggerName, (PWCHAR) LoggerName);
                RtlInitUnicodeString(&LoggerInfo->LoggerName, strLoggerName);
            }
            else if ((LoggerHandle == 0)  && (!IsKernelTrace)) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        else if ((LoggerHandle == 0) && (!IsKernelTrace)) {
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        
        if (Properties->LogFileNameOffset >= sizeof(EVENT_TRACE_PROPERTIES)) {
            ULONG  lenLogFileName;
            PWCHAR strLogFileName;
            ULONG FullPathNameSize = MAXSTR;

            strLogFileName = (PWCHAR) (  ((PCHAR) Properties)
                                       + Properties->LogFileNameOffset);

Retry:
            FullPathName = WmipAlloc(FullPathNameSize * sizeof(WCHAR));
            if (FullPathName == NULL) {
                ErrorCode = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }
            RetValue = GetFullPathNameW(strLogFileName, FullPathNameSize, FullPathName, NULL);
            if (RetValue != 0) {
                if (RetValue > FullPathNameSize) {
                    WmipFree(FullPathName);
                    FullPathNameSize = RetValue;
                    goto Retry;
                }
                else {
                    strLogFileName = FullPathName;
                }
            }

            lenLogFileName = wcslen(strLogFileName);
            LoggerInfo->LogFileName.Buffer = (PWCHAR)
                        (((PCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION)
                                + LoggerInfo->LoggerName.MaximumLength);
            if (lenLogFileName > 0) {
                LoggerInfo->LogFileName.MaximumLength =
                        sizeof(WCHAR) * ((USHORT) (lenLogFileName + 1));
                LoggerInfo->LogFileName.Length =
                        sizeof(WCHAR) * ((USHORT) (lenLogFileName));
                wcsncpy(LoggerInfo->LogFileName.Buffer,
                        strLogFileName,
                        lenLogFileName);
            }
            else {
                LoggerInfo->LogFileName.Length = 0;
                LoggerInfo->LogFileName.MaximumLength = MAXSTR * sizeof(WCHAR);
            }
        }

        LoggerInfo->LogFileMode = Properties->LogFileMode;
        LoggerInfo->Wnode.HistoricalContext = LoggerHandle;
        LoggerInfo->Wnode.BufferSize = sizeNeeded;
        LoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;

        //
        // For Private Loggers, the Guid must be supplied
        //

        LoggerInfo->Wnode.Guid = Properties->Wnode.Guid;

        switch (Control) {
        case EVENT_TRACE_CONTROL_QUERY  :
            ErrorCode = WmipQueryLogger(LoggerInfo, FALSE);
            break;
        case EVENT_TRACE_CONTROL_STOP   :
            ErrorCode = WmipStopLogger(LoggerInfo);
            break;
        case EVENT_TRACE_CONTROL_UPDATE :
            WmipCopyPropertiesToInfo(Properties, LoggerInfo);
            LoggerInfo->Wnode.HistoricalContext = LoggerHandle;
            ErrorCode = WmipQueryLogger(LoggerInfo, TRUE);
            break;
        case EVENT_TRACE_CONTROL_FLUSH :
            ErrorCode = WmipFlushLogger(LoggerInfo); 
            break;

        default :
            ErrorCode = ERROR_INVALID_PARAMETER;
        }

    //
    // The Kernel call could fail with ERROR_MORE_DATA and we need to retry
    // with sufficient buffer space for the two strings. The size required
    // is returned in the MaximuumLength field.
    //

        if (ErrorCode == ERROR_MORE_DATA) {
            LogFileNameLen = LoggerInfo->LogFileName.MaximumLength / sizeof(WCHAR);
            LoggerNameLen = LoggerInfo->LoggerName.MaximumLength / sizeof(WCHAR);
            if (LoggerInfo != NULL) {
                WmipFree(LoggerInfo);
                LoggerInfo = NULL;
            }
            if (FullPathName != NULL) {
                WmipFree(FullPathName);
                FullPathName = NULL;
            }
            goto RetryFull;
        }
    
        if (ErrorCode == ERROR_SUCCESS) {
            ULONG Length = 0;
            ULONG BytesAvailable = 0;
            PWCHAR pLoggerName, pLogFileName;
            WmipCopyInfoToProperties(LoggerInfo, Properties);

            WmipFixupLoggerStrings(LoggerInfo);

            if (Properties->LoggerNameOffset == 0)
                Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);

            if (Properties->LoggerNameOffset >  Properties->LogFileNameOffset ) 
                BytesAvailable = Properties->Wnode.BufferSize -
                                 Properties->LoggerNameOffset;
            else 
                BytesAvailable =  Properties->LogFileNameOffset - 
                                  Properties->LoggerNameOffset;
            Length = LoggerInfo->LoggerName.Length;
            if (Length > 0) {
                if (BytesAvailable < (Length + sizeof(WCHAR) )) {
                    PWNODE_TOO_SMALL WnodeSmall = (PWNODE_TOO_SMALL) Properties;
                    WnodeSmall->SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + 
                                                   Length + LoggerInfo->LogFileName.Length + 2 * sizeof(WCHAR);
                    WnodeSmall->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;

                    Length = BytesAvailable - sizeof(WCHAR);
                    ErrorCode = ERROR_MORE_DATA;
                    goto Cleanup;
                }
                else {
                    pLoggerName = (PWCHAR) ((PCHAR)Properties + 
                                                Properties->LoggerNameOffset);
                    wcsncpy(pLoggerName, LoggerInfo->LoggerName.Buffer, Length/2 );
                }
            }
/*            if (BytesAvailable > sizeof(WCHAR)) {

                pLoggerName = (PWCHAR) ((PCHAR)Properties + 
                                                Properties->LoggerNameOffset);
                RtlZeroMemory(pLoggerName, BytesAvailable);

                Length = LoggerInfo->LoggerName.Length;

                if (BytesAvailable <= Length)
                    Length = BytesAvailable - sizeof(WCHAR);
                if (Length > 0)  {
                    wcsncpy(pLoggerName, 
                            LoggerInfo->LoggerName.Buffer, Length/2 );
                }
            }*//*

            if (Properties->LogFileNameOffset == 0) {
                Properties->LogFileNameOffset = Properties->LoggerNameOffset +
                                                Length;
            }

            if (Properties->LogFileNameOffset > Properties->LoggerNameOffset )
                BytesAvailable = Properties->Wnode.BufferSize -
                                 Properties->LogFileNameOffset;
            else
                BytesAvailable =  Properties->LoggerNameOffset -
                                  Properties->LogFileNameOffset;

            //
            // Check for space to return LogFileName. 
            //
            Length = LoggerInfo->LogFileName.Length;
            if (Length > 0) {
                if (BytesAvailable < (Length + sizeof(WCHAR)) ) {
                    PWNODE_TOO_SMALL WnodeSmall = (PWNODE_TOO_SMALL) Properties;
                    WnodeSmall->SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) +
                                                   Length + LoggerInfo->LogFileName.Length + 2 * sizeof(WCHAR);
                    WnodeSmall->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;

                    Length = BytesAvailable - sizeof(WCHAR);
                    ErrorCode = ERROR_MORE_DATA;
                }
                else {

                    pLogFileName = (PWCHAR) ((PCHAR)Properties +
                                                    Properties->LogFileNameOffset);
                    RtlZeroMemory(pLogFileName, BytesAvailable);

                    wcsncpy(pLogFileName, 
                            LoggerInfo->LogFileName.Buffer, Length/2 );
               }
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = WmipSetNtStatus(GetExceptionCode());
    }

Cleanup:
    if (LoggerInfo != NULL)
        WmipFree(LoggerInfo);
    if (FullPathName != NULL)
        WmipFree(FullPathName);

    return WmipSetDosError(ErrorCode);
}

ULONG
WMIAPI
EnableTrace(
    IN ULONG Enable,
    IN ULONG EnableFlag,
    IN ULONG EnableLevel,
    IN LPCGUID ControlGuid,
    IN TRACEHANDLE TraceHandle
    )
{
    ULONG status;
    PTRACE_ENABLE_CONTEXT pTraceHandle = (PTRACE_ENABLE_CONTEXT)&TraceHandle;
    PWMI_LOGGER_INFORMATION pLoggerInfo;
    ULONG Flags;
    GUID Guid;
    BOOLEAN IsKernelTrace = FALSE;
    ULONG SizeNeeded = 0;
    ULONG RetryCount = 1;

    WmipInitProcessHeap();

    // We only accept T/F for Enable code. In future, we really should take
    // enumerated request codes. Declaring the Enable as ULONG instead
    // of BOOLEAN should give us room for expansion.

    if ( (ControlGuid == NULL) 
         || (EnableLevel > 255) 
         || ((Enable != TRUE) && (Enable != FALSE)) ) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }
    try {
        Guid = *ControlGuid;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipSetDosError(ERROR_NOACCESS);
    }

    //
    // Check to see if this is a valid TraceHandle or not by query
    //
    SizeNeeded = sizeof(WMI_LOGGER_INFORMATION) + 2 * MAXSTR;

Retry:

    SizeNeeded = (SizeNeeded +7) & ~7;

    pLoggerInfo = WmipAlloc(SizeNeeded);
    if (pLoggerInfo == NULL) {
        return WmipSetDosError(ERROR_OUTOFMEMORY);
    }

    RtlZeroMemory(pLoggerInfo, SizeNeeded);
    pLoggerInfo->Wnode.HistoricalContext = TraceHandle;
    if (IsEqualGUID(&Guid, &SystemTraceControlGuid)) {
        WmiSetLoggerId(KERNEL_LOGGER_ID, &pLoggerInfo->Wnode.HistoricalContext);
        IsKernelTrace = TRUE;
    }
    else {
        // Validate TraceHandle is in range
       pLoggerInfo->Wnode.HistoricalContext = TraceHandle;
    }
    pLoggerInfo->Wnode.BufferSize = SizeNeeded;
    pLoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;

    //
    // For PRIVATE logger, We need the Guid to determine the Provider
    //
    pLoggerInfo->Wnode.Guid   = Guid;

    status = WmipQueryLogger(pLoggerInfo, FALSE);
    if (status != ERROR_SUCCESS) {
        WmipFree(pLoggerInfo);

        if ((status == ERROR_MORE_DATA) && 
            (pTraceHandle->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE)) {
            SizeNeeded = RetryCount * (sizeof(WMI_LOGGER_INFORMATION) 
                                       + 2 * MAXSTR);
            if (RetryCount++ > TRACE_RETRY_COUNT) 
                return WmipSetDosError(status);
            goto Retry;
        }
        return WmipSetDosError(status);
    }

    if (IsKernelTrace) {
        Flags = pLoggerInfo->EnableFlags; 
        //
        // If Enabling, we need to pass down the final state of the flags
        // ie., the old flags plus the new flags. 
        // If disabling, we need to pass down the only the flags that 
        // are already turned on and being turned off now. 
        //
        if (Enable) {
            Flags |= EnableFlag;
        }
        else {
            Flags &= EnableFlag;
        } 

        // 
        // At this point if the Flags are 0, then no change is being 
        // requested. 
        //
        
        if (Flags) {
            pLoggerInfo->EnableFlags = Flags;
            status = WmipQueryLogger(pLoggerInfo, TRUE);
        }
        WmipFree(pLoggerInfo);
        return WmipSetDosError(status); 
    }
    else {
        WmipFree(pLoggerInfo);
        pTraceHandle->Level = (UCHAR)EnableLevel;
    }

    pTraceHandle->EnableFlags = EnableFlag;
    
    //
    // This is done from the Control Process which can call this API for 
    // any known Guid. The service must maintain the information about 
    // whether the Guid is a valid Trace Guid or not. 
    //
    if (TraceHandle == (TRACEHANDLE)0) {
       return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }
    
    try {
            status = WmipNotificationRegistration(
                        &Guid,
                        (UCHAR)Enable,
                        (NOTIFICATIONCALLBACK) 0x0,
                        0, 
                        TraceHandle,
                        NOTIFICATION_TRACE_FLAG, FALSE);
            if (status != ERROR_SUCCESS)
                return WmipSetDosError(status);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipSetDosError(ERROR_NOACCESS);
    }
    return WmipSetDosError(status);
}
*/


ULONG
WmipTraceEvent(
    IN TRACEHANDLE LoggerHandle,
    IN PWNODE_HEADER Wnode
    )
{
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatus;
    PULONG TraceMarker;
    ULONG Size;
    PEVENT_TRACE_HEADER EventTrace = (PEVENT_TRACE_HEADER)Wnode;
    USHORT    LoggerId;
    PTRACE_ENABLE_CONTEXT pContext = (PTRACE_ENABLE_CONTEXT)&LoggerHandle;


    Wnode->HistoricalContext = LoggerHandle;
    if ( (pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE) && (WmipIsBBTOn == 0) ) {
            goto UmOnly;
    }

    Size = EventTrace->Size;
    //
    // Now the LoggerHandle is expected to be filled in by the caller.
    //  But check to see if it has a valid value.
    //

    LoggerId = WmiGetLoggerId(LoggerHandle);
    if ((LoggerId == 0) || (LoggerId == KERNEL_LOGGER_ID)) {
         return ERROR_INVALID_HANDLE;
    }

    if (WmipDeviceHandle == NULL) { // should initialize this during enable??
        //
        // If device is not open then open it now. The
        // handle is closed in the process detach dll callout (DllMain)

        WmipEnterPMCritSection();
        if (WmipDeviceHandle != NULL) { // got set just after test, so return
            WmipLeavePMCritSection();
        }
        else {
            WmipDeviceHandle
                = WmipCreateFileA (WMIDataDeviceName,
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);
            WmipLeavePMCritSection();
            if (WmipDeviceHandle == (HANDLE)-1) {
                WmipDeviceHandle = NULL;
                return(WmipGetLastError());
            }
        }
    }
    //
    // 
    if (WmipIsBBTOn) {
        WmiSetLoggerId(WMI_GLOBAL_LOGGER_ID, &Wnode->HistoricalContext);
    }

    NtStatus = NtDeviceIoControlFile(
                   WmipDeviceHandle,
                   NULL,
                   NULL,
                   NULL,
                   &IoStatus,
                   IOCTL_WMI_TRACE_EVENT,
                   Wnode,
                   Size,
                   Wnode,
                   Size
                   );

    return WmipSetNtStatus( NtStatus );

UmOnly:

    return WmiTraceUmEvent(Wnode);

}


ULONG 
WMIAPI
TraceEvent(
    IN TRACEHANDLE LoggerHandle,
    IN PEVENT_TRACE_HEADER EventTrace
    )
{
    ULONG Status, SavedMarker;
    PULONG TraceMarker;
    ULONG Size;
    ULONGLONG SavedGuidPtr;
    BOOLEAN RestoreSavedGuidPtr = FALSE;
    PWNODE_HEADER Wnode = (PWNODE_HEADER) EventTrace;
    ULONG Flags;

    WmipInitProcessHeap();
    
    if (Wnode == NULL ) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }

    try {
        TraceMarker = (PULONG) Wnode;
        SavedMarker = *TraceMarker;

        Flags = Wnode->Flags;

        Wnode->Flags |= WNODE_FLAG_TRACED_GUID; 
        
        Size = EventTrace->Size;
        if (Size < sizeof(EVENT_TRACE_HEADER)) {
            return WmipSetDosError(ERROR_INVALID_PARAMETER);
        }
        *TraceMarker = 0;
        EventTrace->Size = (USHORT)Size;
        *TraceMarker |= TRACE_HEADER_FULL;
        if (Wnode->Flags & WNODE_FLAG_USE_GUID_PTR) {
            RestoreSavedGuidPtr = TRUE;
            SavedGuidPtr = EventTrace->GuidPtr;
        }
        Status = WmipTraceEvent(LoggerHandle, Wnode);
        *TraceMarker = SavedMarker;
        Wnode->Flags = Flags;
        if (RestoreSavedGuidPtr) {
            EventTrace->GuidPtr = SavedGuidPtr;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipSetNtStatus( GetExceptionCode() );
    }
    return WmipSetDosError(Status);
}




ULONG
WMIAPI
TraceEventInstance(
    IN TRACEHANDLE  LoggerHandle,
    IN PEVENT_INSTANCE_HEADER EventTrace,
    IN PEVENT_INSTANCE_INFO pInstInfo,
    IN PEVENT_INSTANCE_INFO pParentInstInfo
    )
{
    PULONG TraceMarker;
    PGUIDMAPENTRY GuidMapEntry;
    ULONG Size, SavedMarker;
    ULONG Flags;
    PWNODE_HEADER Wnode = (PWNODE_HEADER) EventTrace;
    PEVENT_INSTANCE_HEADER InstanceHeader= (PEVENT_INSTANCE_HEADER) Wnode;
    ULONG Status;

    WmipInitProcessHeap();
    
    if ((Wnode == NULL ) || (pInstInfo == NULL)) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }

    try {
        Flags = Wnode->Flags;
        TraceMarker = (PULONG) Wnode;
        SavedMarker = *TraceMarker;
        Flags |= WNODE_FLAG_TRACED_GUID; 
        Size = EventTrace->Size;
        if (Size < sizeof(EVENT_INSTANCE_HEADER)) {
            return WmipSetDosError(ERROR_INVALID_PARAMETER);
        }
        GuidMapEntry =  (PGUIDMAPENTRY) pInstInfo->RegHandle;
        if (GuidMapEntry == NULL) {
            return WmipSetDosError(ERROR_INVALID_PARAMETER);
        }
        *TraceMarker = 0;
        EventTrace->Size = (USHORT)Size;
        *TraceMarker |= TRACE_HEADER_INSTANCE;

        //
        // With EVENT_INSTANCE_HEADER we don't want the logger
        // to try to dereference the GuidPtr since it is
        // just a hash value for the Guid and not really a LPGUID.
        //

        if (Wnode->Flags & WNODE_FLAG_USE_GUID_PTR) {
            Wnode->Flags  &= ~WNODE_FLAG_USE_GUID_PTR;
        }

        InstanceHeader->InstanceId = pInstInfo->InstanceId;
        InstanceHeader->RegHandle= GuidMapEntry->GuidMap.GuidMapHandle;
        if (pParentInstInfo != NULL) {
            GuidMapEntry =  (PGUIDMAPENTRY) pParentInstInfo->RegHandle;
            if (GuidMapEntry == NULL) {
                *TraceMarker = SavedMarker;
                return WmipSetDosError(ERROR_INVALID_PARAMETER);
            }
            InstanceHeader->ParentInstanceId =
                                   pParentInstInfo->InstanceId;
            InstanceHeader->ParentRegHandle =
                                   GuidMapEntry->GuidMap.GuidMapHandle;
        }

        Status = WmipTraceEvent(LoggerHandle, Wnode);

        Wnode->Flags = Flags;
        *TraceMarker = SavedMarker;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipSetNtStatus( GetExceptionCode() );
    }
    return WmipSetDosError(Status);
}

ULONG 
WMIAPI
RegisterTraceGuidsW(
    IN WMIDPREQUEST RequestAddress,
    IN PVOID        RequestContext,
    IN LPCGUID       ControlGuid,
    IN ULONG        GuidCount,
    IN PTRACE_GUID_REGISTRATION GuidReg,
    IN LPCWSTR       MofImagePath,
    IN LPCWSTR       MofResourceName,
    IN PTRACEHANDLE  RegistrationHandle
    )
{
    ULONG SizeNeeded;
    PWMIREGINFOW WmiRegInfo;
    PTRACE_GUID_REGISTRATION GuidRegPtr;
    PWMIREGGUIDW WmiRegGuidPtr;
    ULONG Status;
    ULONG i;
    PTRACEGUIDMAP GuidMapHandle = NULL;
    PTRACEGUIDMAP TraceGuidMap = NULL;
    ULONG RegistrationCookie;
    PGUIDMAPENTRY pGuidMapEntry, pControlGMEntry;
    PTRACE_REG_INFO pTraceRegInfo = NULL;
    PTRACE_REG_PACKET RegPacket;
    PWCHAR StringPtr;
    ULONG StringPos, StringSize, GuidMapSize;
    ULONG BusyRetries;
    TRACEHANDLE LoggerContext = 0;
    HANDLE InProgressEvent = NULL;
	GUID Guid;
	HANDLE TraceCtxHandle;

    WmipInitProcessHeap();
    
    if ((RequestAddress == NULL) ||
        (RegistrationHandle == NULL) ||
        (GuidCount <= 0) ||
        (GuidReg == NULL)  ||
        (ControlGuid == NULL) ||
        (GuidCount > MAXGUIDCOUNT) )
    {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }

    try {
        Guid = *ControlGuid;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipSetNtStatus( GetExceptionCode() );
    }

    //
    // Check to see if BBT buffers are active and set a flag for 
    // redirecting TraceEvent calls
    //

    if ((ULONG_PTR)(NtCurrentTeb()->ReservedForPerf) >> 8) {
        WmipIsBBTOn = TRUE;
    }

    // 
    // Allocate WMIREGINFO for controlGuid + GuidCount. 
    // 
    GuidCount++;

    StringPos = sizeof(WMIREGINFOW) + GuidCount * sizeof(WMIREGGUIDW);
    SizeNeeded = StringPos;

    if (MofImagePath == NULL) {
        MofImagePath = L"";
    }
    if (MofResourceName != NULL) {
        SizeNeeded += (wcslen(MofResourceName)+2) * sizeof(WCHAR);
    }

    if (MofImagePath != NULL) {
        SizeNeeded += (wcslen(MofImagePath)+2) * sizeof(WCHAR);
    }

    SizeNeeded = (SizeNeeded +7) & ~7;
    WmiRegInfo = WmipAlloc(SizeNeeded);
    if (WmiRegInfo == NULL) 
    {
        return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
    }

    RtlZeroMemory(WmiRegInfo, SizeNeeded);
    WmiRegInfo->BufferSize = SizeNeeded;
    WmiRegInfo->GuidCount = GuidCount;

    WmiRegGuidPtr = &WmiRegInfo->WmiRegGuid[0];
    WmiRegGuidPtr->Flags |= WMIREG_FLAG_TRACED_GUID;
    WmiRegGuidPtr->Flags |= WMIREG_FLAG_TRACE_CONTROL_GUID;

    try {
        *RegistrationHandle = (TRACEHANDLE) 0;    
        WmiRegGuidPtr->Guid = Guid;
        for (i = 1; i < GuidCount; i++) {
            WmiRegGuidPtr = &WmiRegInfo->WmiRegGuid[i];
            WmiRegGuidPtr->Flags |= WMIREG_FLAG_TRACED_GUID;
            GuidRegPtr = &GuidReg[i-1];
            WmiRegGuidPtr->Guid = *GuidRegPtr->Guid;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        WmipFree(WmiRegInfo);
        return WmipSetNtStatus( GetExceptionCode() );
    }
    //
    // Allocate storage for the return GUIDMAPHANDLE structure
    //

    GuidMapSize = sizeof(TRACEGUIDMAP) * GuidCount; 
    GuidMapHandle = WmipAlloc(GuidMapSize);
    if (GuidMapHandle == NULL) {
        WmipFree(WmiRegInfo);
        return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
    }
    
    //
    // Allocate the GuidMapEntries to save the  GuidMaps before making the
    // Registration call. 
    //
    pControlGMEntry = WmipAlloc(sizeof( GUIDMAPENTRY) );
    if (pControlGMEntry == NULL) 
    {
        WmipFree(WmiRegInfo);
        WmipFree(GuidMapHandle);
        return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
    }
    RtlZeroMemory(pControlGMEntry, sizeof( GUIDMAPENTRY ));
    InitializeListHead(&pControlGMEntry->Entry);

    pTraceRegInfo = WmipAlloc(sizeof(TRACE_REG_INFO));
    if (pTraceRegInfo == NULL) {
        WmipFree(WmiRegInfo);
        WmipFree(GuidMapHandle);
        WmipFree(pControlGMEntry);
        return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
    }
    RtlZeroMemory(pTraceRegInfo, sizeof( TRACE_REG_INFO) );
    pControlGMEntry->pControlGuidData = pTraceRegInfo;
    pTraceRegInfo->NotifyRoutine = RequestAddress;

    // Manual reset, Initially not signalled
    
    InProgressEvent = WmipCreateEventA(NULL, TRUE, FALSE, NULL);
    if (InProgressEvent == NULL) {
        WmipFree(WmiRegInfo);
        WmipFree(GuidMapHandle);
        WmipFree(pControlGMEntry);
        WmipFree(pTraceRegInfo);
        return WmipSetDosError(ERROR_OBJECT_NOT_FOUND);
    }
    pTraceRegInfo->InProgressEvent = InProgressEvent;
    //
    // Allocate Registration Cookie 
    // 
    RegistrationCookie = WmipAllocateCookie(pControlGMEntry, 
                                            RequestContext,
                                            (LPGUID)&Guid);
    if (RegistrationCookie == 0) {
        pTraceRegInfo->InProgressEvent = NULL;
        NtClose(InProgressEvent);
        WmipFree(WmiRegInfo);
        WmipFree(GuidMapHandle);
        WmipFree(pControlGMEntry);
        WmipFree(pTraceRegInfo);
        return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
    }
    pTraceRegInfo->RegistrationCookie = RegistrationCookie;

#ifdef DBG
    WmipDebugPrint(("WMI TRACE REG: AllocateCookie %d Callback %X\n", 
                RegistrationCookie, RequestAddress));
#endif
    //
    // Allocate the Guid Map Entries
    //

    for (i=1; i < GuidCount; i++) {
        pGuidMapEntry = WmipAlloc(sizeof( GUIDMAPENTRY) );
        if (pGuidMapEntry == NULL)
        {
            PLIST_ENTRY Head, Next;
            pTraceRegInfo->InProgressEvent = NULL;
            NtClose(InProgressEvent);
            WmipFree(WmiRegInfo);
            WmipFree(GuidMapHandle);
            WmipFreeCookie(RegistrationCookie);
            Head = &pControlGMEntry->Entry;
            Next = Head->Flink;
            while (Next != Head) {
                PGUIDMAPENTRY GuidMap;
                GuidMap = CONTAINING_RECORD( Next, GUIDMAPENTRY, Entry);
                Next = Next->Flink;
                RemoveEntryList(&GuidMap->Entry);
                WmipFree(GuidMap);
            }
            WmipFree(pControlGMEntry);
            return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
        }
        RtlZeroMemory(pGuidMapEntry, sizeof(GUIDMAPENTRY));
        InsertTailList( &pControlGMEntry->Entry, &pGuidMapEntry->Entry);
    }

    if (MofResourceName != NULL) {
        WmiRegInfo->MofResourceName = StringPos;
        StringPtr = (PWCHAR)OffsetToPtr(WmiRegInfo, StringPos);
        Status = WmipCopyStringToCountedUnicode(MofResourceName,
                                                StringPtr,
                                                &StringSize,
                                                FALSE);
        StringPos += StringSize;
        WmipAssert(StringPos <= SizeNeeded);
    }

    if (MofImagePath != NULL) {
        WmiRegInfo->RegistryPath = StringPos;
        StringPtr = (PWCHAR)OffsetToPtr(WmiRegInfo, StringPos);
        Status = WmipCopyStringToCountedUnicode(MofImagePath,
                                                StringPtr,
                                                &StringSize,
                                                FALSE);
        StringPos += StringSize;
        WmipAssert(StringPos <= SizeNeeded);
    }

    RtlZeroMemory(GuidMapHandle, GuidMapSize);

    Status = WmipRegisterGuids(&RegisterReservedGuid,
                               RegistrationCookie,
                               WmiRegInfo,
                               GuidCount,
                               &GuidMapHandle,
                               &LoggerContext,
                               &TraceCtxHandle);

    if (Status == ERROR_SUCCESS)
	{
        //
        // Place the registration handle on the list of handles to
		// wait for notifications from
		//

		Status = WmipAddHandleToEventPump(&Guid,
                                         (PVOID)TraceCtxHandle, // Needed for UM Logger to Reply 
                                         0,
                                         0,
                                         TraceCtxHandle);
									 
        if (Status != ERROR_SUCCESS)
		{
			//
			// If we cannot add the handle to the event pump we might as
			// well give up.
			//
			NtClose(TraceCtxHandle);
		}
	}
						   
    if (Status == ERROR_SUCCESS) {
        TraceGuidMap = &GuidMapHandle[0];
        pControlGMEntry->GuidMap = *TraceGuidMap; 
        pTraceRegInfo->TraceCtxHandle = TraceCtxHandle;

         try 
        {
            PLIST_ENTRY Head, Next;
            RegPacket = (PTRACE_REG_PACKET)RegistrationHandle;
            RegPacket->RegistrationCookie = RegistrationCookie; 
            Head = &pControlGMEntry->Entry;
            Next = Head->Flink;
             for (i=1; ((i < GuidCount) && (Head != Next)); i++) {
                pGuidMapEntry = CONTAINING_RECORD(Next, GUIDMAPENTRY,Entry);
                Next = Next->Flink;
                pGuidMapEntry->InstanceId = 0;
                TraceGuidMap = &GuidMapHandle[i];
                pGuidMapEntry->GuidMap = *TraceGuidMap;
                GuidRegPtr = &GuidReg[i-1];
                GuidRegPtr->RegHandle = pGuidMapEntry;
             }
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }
        
        //
        // We will make the Enable/Disable notification here.
        //

         if ( Status == ERROR_SUCCESS ) {

            WNODE_HEADER Wnode;
            PTRACE_ENABLE_CONTEXT pContext = (PTRACE_ENABLE_CONTEXT)&LoggerContext;
            ULONG InOutSize;
            BOOLEAN DeliverNotification = TRUE;
            RtlZeroMemory(&Wnode, sizeof(Wnode));
            Wnode.BufferSize = sizeof(Wnode);
            Wnode.HistoricalContext = LoggerContext;
            Wnode.Guid = Guid; 
            if (pContext && pContext->InternalFlag & 
                EVENT_TRACE_INTERNAL_FLAG_PRIVATE) {
                // Before Delivering this Notification
                // make sure that the Process Private logger
                // is running. 
                pTraceRegInfo->EnabledState = TRUE;
                if (!WmipIsPrivateLoggerOn()) {
                    DeliverNotification = FALSE;
                }     
            } 
            
            if(IsEqualGUID(&NtdllTraceGuid, &Guid)) {    //Check for Ntdll Trace Guid.

                DeliverNotification = TRUE;
            }

            if (DeliverNotification) {
                try {
                    InOutSize = Wnode.BufferSize;
                    Status = (RequestAddress)(WMI_ENABLE_EVENTS,
                                 RequestContext,
                                 &InOutSize,
                                 &Wnode);
                } except (EXCEPTION_EXECUTE_HANDLER) {
#if DBG
                    Status = GetExceptionCode();
                    WmipDebugPrint(("WMI: Enable Call caused exception%d\n",
                        Status));
#endif
                    Status = ERROR_WMI_DP_FAILED;
                }
            }
        }
	
        if (Status != ERROR_SUCCESS) { // post processing failed. 
            NtSetEvent(InProgressEvent, NULL);
            pTraceRegInfo->InProgressEvent = NULL;
            NtClose(InProgressEvent);
            UnregisterTraceGuids(*RegistrationHandle);
            WmipFree(GuidMapHandle);
            WmipFree(WmiRegInfo);
            *RegistrationHandle = 0;
            return Status;
	    }
    }

    if (Status != ERROR_SUCCESS) {
        PLIST_ENTRY Head, Next;

        Head = &pControlGMEntry->Entry;
        Next = Head->Flink;
        while (Next != Head) {
            PGUIDMAPENTRY GuidMap;
            GuidMap = CONTAINING_RECORD( Next, GUIDMAPENTRY, Entry);
            Next = Next->Flink;
            RemoveEntryList(&GuidMap->Entry);
            WmipFree(GuidMap);
        }
        WmipFree(pControlGMEntry);
        WmipFreeCookie(RegistrationCookie);
    }

    WmipSetLastError(Status);

    WmipFree(GuidMapHandle);
    WmipFree(WmiRegInfo);

    NtSetEvent(InProgressEvent, NULL);
    pTraceRegInfo->InProgressEvent = NULL;
    NtClose(InProgressEvent);
    return(Status);
}

ULONG
WMIAPI
RegisterTraceGuidsA(
    IN WMIDPREQUEST RequestAddress,
    IN PVOID        RequestContext,
    IN LPCGUID       ControlGuid,
    IN ULONG        GuidCount,
    IN PTRACE_GUID_REGISTRATION GuidReg,
    IN LPCSTR       MofImagePath,
    IN LPCSTR       MofResourceName,
    IN PTRACEHANDLE  RegistrationHandle
    )
/*++

Routine Description:

    ANSI thunk to RegisterTraceGuidsW

--*/
{
    LPWSTR MofImagePathUnicode = NULL;
    LPWSTR MofResourceNameUnicode = NULL;
    ULONG Status;

    WmipInitProcessHeap();
    
    if ((RequestAddress == NULL) ||
        (RegistrationHandle == NULL) ||
        (GuidCount <= 0) ||
        (GuidReg == NULL)  ||
        (ControlGuid == NULL) || 
        (GuidCount > MAXGUIDCOUNT) )
    {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }

    Status = WmipAnsiToUnicode(MofImagePath, &MofImagePathUnicode);
    if (Status == ERROR_SUCCESS) {
        if (MofResourceName) {
            Status = WmipAnsiToUnicode(MofResourceName, &MofResourceNameUnicode);
        }
        if (Status == ERROR_SUCCESS) {

            Status = RegisterTraceGuidsW(RequestAddress,
                                        RequestContext,
                                        ControlGuid,
                                        GuidCount,
                                        GuidReg,
                                        MofImagePathUnicode,
                                        MofResourceNameUnicode,
                                        RegistrationHandle
                                        );
            if (MofResourceNameUnicode) {
                WmipFree(MofResourceNameUnicode);
            }
        }
        if (MofImagePathUnicode) {
            WmipFree(MofImagePathUnicode);
        }
    }
    return(Status);
}

ULONG
WMIAPI
UnregisterTraceGuids(
    IN TRACEHANDLE RegistrationHandle
    )
{
    // First check if the handle belongs to a Trace Control Guid. 
    // Then UnRegister all the regular trace guids controlled by 
    // this control guid and free up the storage allocated to maintain 
    // the TRACEGUIDMAPENTRY structures.

    // Get to the real Registration Handle, stashed away in 
    // in the internal structures and pass it onto the call.  

    PGUIDMAPENTRY pControlGMEntry;
    WMIHANDLE WmiRegistrationHandle;
    PLIST_ENTRY Next, Head;
    ULONG Status;
    PVOID RequestContext;
    PTRACE_REG_INFO pTraceRegInfo = NULL;
    PTRACE_REG_PACKET RegPacket; 
    GUID ControlGuid;
    ULONG64 LoggerContext = 0;
    WMIDPREQUEST RequestAddress;

    WmipInitProcessHeap();
    
    if (RegistrationHandle == 0) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }

    RegPacket = (PTRACE_REG_PACKET)&RegistrationHandle;

    if (!WmipLookupCookie(RegPacket->RegistrationCookie, 
                          NULL,
                          &pControlGMEntry,
                          &RequestContext) ){
        WmipDebugPrint(("WMI: LOOKUP COOKIE FAILED\n"));
        return(ERROR_INVALID_PARAMETER);
    }
        
    try {

        if (pControlGMEntry->pControlGuidData == NULL) {
            return WmipSetDosError(ERROR_INVALID_PARAMETER);
        }

    //
    // Free the Registration Cookie 
    //

        pTraceRegInfo = pControlGMEntry->pControlGuidData;
        RequestAddress = pTraceRegInfo->NotifyRoutine;

        WmipGetGuidInCookie(pTraceRegInfo->RegistrationCookie, &ControlGuid);

        WmipFreeCookie(pTraceRegInfo->RegistrationCookie);
        WmiRegistrationHandle = (WMIHANDLE)pTraceRegInfo->TraceCtxHandle;
        if (WmiRegistrationHandle == NULL) {
            return WmipSetDosError(ERROR_INVALID_PARAMETER);
        }

        Status =  WmiUnregisterGuids(WmiRegistrationHandle, 
                                     &ControlGuid, 
                                     &LoggerContext);

    //
    // Cleanup all the TraceGuidMapEntry structures for this control Guid 
    // whether WmiUnregisterGuids is successful or not. 
    //

        Head = &pControlGMEntry->Entry;
        Next = Head->Flink;

        while (Next != Head) {
            PGUIDMAPENTRY GuidMap;
            GuidMap = CONTAINING_RECORD( Next, GUIDMAPENTRY, Entry );
            Next = Next->Flink;
            RemoveEntryList(&GuidMap->Entry);
            WmipFree(GuidMap);
        }

    //
    // Check to see if we need to fire the Disable callback
    // before freeing the TraceRegInfo
    //

        if ((Status == ERROR_SUCCESS) && LoggerContext) {
            WNODE_HEADER Wnode;
            ULONG InOutSize = sizeof(Wnode);

            RtlZeroMemory(&Wnode, sizeof(Wnode));
            Wnode.BufferSize = sizeof(Wnode);
            Wnode.HistoricalContext = LoggerContext;
            Wnode.Guid = ControlGuid;
            Status = (RequestAddress)(WMI_DISABLE_EVENTS,
                            RequestContext,
                            &InOutSize,
                            &Wnode);
        }

        WmipFree(pControlGMEntry);
        WmipFree(pTraceRegInfo);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
#ifdef DBG
        WmipDebugPrint(("WMI: Exception in UnRegisterTraceGuids Bad handle\n"));
#endif 
    }

    RegistrationHandle = 0;

    return WmipSetDosError(Status);
}

ULONG
WmipQueryAllUmTraceW(
    OUT PEVENT_TRACE_PROPERTIES * PropertyArray,
    IN  BOOLEAN                   fEnabledOnly,
    IN  ULONG                     PropertyArrayCount,
    OUT PULONG                    LoggerCount)
{
    PWMI_LOGGER_INFORMATION    pLoggerInfo;
    PWMI_LOGGER_INFORMATION    pLoggerInfoCurrent;
    ULONG                      LoggerInfoSize;
    ULONG                      SizeUsed;
    ULONG                      SizeNeeded = 0;
    ULONG                      Length;
    ULONG                      lenLoggerName;
    ULONG                      lenLogFileName;
    ULONG                      Offset     = 0;
    ULONG                      i          = * LoggerCount;
    ULONG                      status;
    PWCHAR                     strSrcW;
    PWCHAR                     strDestW;

    LoggerInfoSize = (PropertyArrayCount - i)
                   * (  sizeof(WMI_LOGGER_INFORMATION)
                      + 2 * MAXSTR * sizeof(WCHAR));
    LoggerInfoSize = (LoggerInfoSize +7) & ~7;
    pLoggerInfo    = (PWMI_LOGGER_INFORMATION) WmipAlloc(LoggerInfoSize);
    if (pLoggerInfo == NULL) {
        status = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(pLoggerInfo, LoggerInfoSize);
    Length = sizeof(WMI_LOGGER_INFORMATION);
    WmipInitString(& pLoggerInfo->LoggerName,
                   (PWCHAR) ((PUCHAR) pLoggerInfo + Length),
                   MAXSTR * sizeof(WCHAR));
    Length += MAXSTR * sizeof(WCHAR);
    WmipInitString(& pLoggerInfo->LogFileName,
                   (PWCHAR) ((PUCHAR) pLoggerInfo + Length),
                   MAXSTR * sizeof(WCHAR));
    SizeUsed = pLoggerInfo->Wnode.BufferSize = LoggerInfoSize;


    status = WmipSendUmLogRequest(
                    (fEnabledOnly) ? (TRACELOG_QUERYENABLED) : (TRACELOG_QUERYALL),
                    pLoggerInfo
                    );

    if (status != ERROR_SUCCESS)
        goto Cleanup;

    while (i < PropertyArrayCount && Offset < SizeUsed) {

        PTRACE_ENABLE_CONTEXT pContext;

        pLoggerInfoCurrent = (PWMI_LOGGER_INFORMATION)
                             (((PUCHAR) pLoggerInfo) + Offset);

        pContext = (PTRACE_ENABLE_CONTEXT)
                        & pLoggerInfoCurrent->Wnode.HistoricalContext;
        pContext->InternalFlag |= EVENT_TRACE_INTERNAL_FLAG_PRIVATE;

        lenLoggerName = pLoggerInfoCurrent->LoggerName.Length / sizeof(WCHAR);
        if (lenLoggerName >= MAXSTR)
            lenLoggerName = MAXSTR - 1;

        lenLogFileName = pLoggerInfoCurrent->LogFileName.Length / sizeof(WCHAR);
        if (lenLogFileName >= MAXSTR)
            lenLogFileName = MAXSTR - 1;

        Length = sizeof(EVENT_TRACE_PROPERTIES)
               + sizeof(WCHAR) * (lenLoggerName + 1)
               + sizeof(WCHAR) * (lenLogFileName + 1);
        if (PropertyArray[i]->Wnode.BufferSize >= Length) {

            WmipCopyInfoToProperties(pLoggerInfoCurrent, PropertyArray[i]);

            strSrcW = (PWCHAR) (  ((PUCHAR) pLoggerInfoCurrent)
                                  + sizeof(WMI_LOGGER_INFORMATION));
            if (lenLoggerName > 0) {
                if (PropertyArray[i]->LoggerNameOffset == 0) {
                    PropertyArray[i]->LoggerNameOffset =
                                    sizeof(EVENT_TRACE_PROPERTIES);
                }
                strDestW = (PWCHAR) (  ((PUCHAR) PropertyArray[i])
                                     + PropertyArray[i]->LoggerNameOffset);
                wcsncpy(strDestW, strSrcW, lenLoggerName);
                strDestW[lenLoggerName] = 0;
            }

            strSrcW = (PWCHAR) (((PUCHAR) pLoggerInfoCurrent)
                              + sizeof(WMI_LOGGER_INFORMATION)
                              + pLoggerInfoCurrent->LoggerName.MaximumLength);
            if (lenLogFileName > 0) {
                if (PropertyArray[i]->LogFileNameOffset == 0) {
                    PropertyArray[i]->LogFileNameOffset =
                            PropertyArray[i]->LoggerNameOffset
                            + sizeof(WCHAR) * (lenLoggerName + 1);
                }
                strDestW = (PWCHAR) (  ((PUCHAR) PropertyArray[i])
                                     + PropertyArray[i]->LogFileNameOffset);
                wcsncpy(strDestW, strSrcW, lenLogFileName);
                strDestW[lenLogFileName] = 0;
            }
        }

        Offset = Offset
               + sizeof(WMI_LOGGER_INFORMATION)
               + pLoggerInfoCurrent->LogFileName.MaximumLength
               + pLoggerInfoCurrent->LoggerName.MaximumLength;
        i ++;
    }

    * LoggerCount = i;
    status = (* LoggerCount > PropertyArrayCount)
           ? ERROR_MORE_DATA : ERROR_SUCCESS;
Cleanup:
    if (pLoggerInfo)
        WmipFree(pLoggerInfo);

    return WmipSetDosError(status);
}
/*
ULONG
WMIAPI
QueryAllTracesW(
    OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
    IN  ULONG  PropertyArrayCount,
    OUT PULONG LoggerCount
    )
{
    ULONG i, status;
    ULONG returnCount = 0;
    EVENT_TRACE_PROPERTIES LoggerInfo;
    PEVENT_TRACE_PROPERTIES pLoggerInfo;

    WmipInitProcessHeap();

    if ((LoggerCount == NULL)  
        || (PropertyArrayCount > MAXLOGGERS)
        || (PropertyArray == NULL)
        || (PropertyArrayCount == 0))
        return ERROR_INVALID_PARAMETER;
    if (*PropertyArray == NULL) 
        return ERROR_INVALID_PARAMETER;
    
    try {
        *LoggerCount = 0;
        for (i=0; i<MAXLOGGERS; i++) {
            if (returnCount < PropertyArrayCount) {
                pLoggerInfo = PropertyArray[returnCount];
            }
            else {
                pLoggerInfo = &LoggerInfo; 
                RtlZeroMemory(pLoggerInfo, sizeof(EVENT_TRACE_PROPERTIES));
                pLoggerInfo->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES);
            }
            WmiSetLoggerId(i, &pLoggerInfo->Wnode.HistoricalContext);
            status = ControlTraceW(
                            (TRACEHANDLE)pLoggerInfo->Wnode.HistoricalContext,
                            NULL,
                            pLoggerInfo,
                            EVENT_TRACE_CONTROL_QUERY);
            if (status == ERROR_SUCCESS)
                returnCount++;
        }
        *LoggerCount = returnCount;
        status = WmipQueryAllUmTraceW(PropertyArray,
                                      FALSE,
                                      PropertyArrayCount,
                                      LoggerCount);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipSetDosError(ERROR_NOACCESS);
    }
    

    if (returnCount > PropertyArrayCount)
        return ERROR_MORE_DATA;
    else 
        return ERROR_SUCCESS;
}*/

ULONG
WmipQueryAllUmTraceA(
    OUT PEVENT_TRACE_PROPERTIES * PropertyArray,
    IN  BOOLEAN                   fEnabledOnly,
    IN  ULONG                     PropertyArrayCount,
    OUT PULONG                    LoggerCount)
{
    PWMI_LOGGER_INFORMATION    pLoggerInfo;
    PWMI_LOGGER_INFORMATION    pLoggerInfoCurrent;
    ULONG                      LoggerInfoSize;
    ULONG                      SizeUsed;
    ULONG                      SizeNeeded = 0;
    ULONG                      Length;
    ULONG                      lenLoggerName;
    ULONG                      lenLogFileName;
    ULONG                      Offset     = 0;
    ULONG                      i          = * LoggerCount;
    ULONG                      status;
    ANSI_STRING                strBufferA;
    PUCHAR                     strDestA;

    LoggerInfoSize = (PropertyArrayCount - i)
                   * (  sizeof(WMI_LOGGER_INFORMATION)
                      + 2 * MAXSTR * sizeof(WCHAR));
    LoggerInfoSize = (LoggerInfoSize +7) & ~7;
    pLoggerInfo    = (PWMI_LOGGER_INFORMATION) WmipAlloc(LoggerInfoSize);
    if (pLoggerInfo == NULL) {
        status = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(pLoggerInfo, LoggerInfoSize);
    Length = sizeof(WMI_LOGGER_INFORMATION);
    WmipInitString(& pLoggerInfo->LoggerName,
                   (PWCHAR) ((PUCHAR) pLoggerInfo + Length),
                   MAXSTR * sizeof(WCHAR));
    Length += MAXSTR * sizeof(WCHAR);
    WmipInitString(& pLoggerInfo->LogFileName,
                   (PWCHAR) ((PUCHAR) pLoggerInfo + Length),
                   MAXSTR * sizeof(WCHAR));
    SizeUsed = pLoggerInfo->Wnode.BufferSize = LoggerInfoSize;


    // 
    // TODO: Provide SizeNeeded case
    //

    status = WmipSendUmLogRequest(
                        (fEnabledOnly) ? (TRACELOG_QUERYENABLED)
                                       : (TRACELOG_QUERYALL),
                        pLoggerInfo
                    );

    if (status != ERROR_SUCCESS)
        goto Cleanup;


    while (i < PropertyArrayCount && Offset < SizeUsed) {
        PTRACE_ENABLE_CONTEXT pContext;

        pLoggerInfoCurrent = (PWMI_LOGGER_INFORMATION)
                             (((PUCHAR) pLoggerInfo) + Offset);
        pContext = (PTRACE_ENABLE_CONTEXT)
                        & pLoggerInfoCurrent->Wnode.HistoricalContext;
        pContext->InternalFlag |= EVENT_TRACE_INTERNAL_FLAG_PRIVATE;

        lenLoggerName = pLoggerInfoCurrent->LoggerName.Length / sizeof(WCHAR);
        if (lenLoggerName >= MAXSTR)
            lenLoggerName = MAXSTR - 1;

        lenLogFileName = pLoggerInfoCurrent->LogFileName.Length / sizeof(WCHAR);
        if (lenLogFileName >= MAXSTR)
            lenLogFileName = MAXSTR - 1;

        Length = sizeof(EVENT_TRACE_PROPERTIES)
               + sizeof(CHAR) * (lenLoggerName + 1)
               + sizeof(CHAR) * (lenLogFileName + 1);
        if (PropertyArray[i]->Wnode.BufferSize >= Length) {
            WmipCopyInfoToProperties(pLoggerInfoCurrent, PropertyArray[i]);

            if (lenLoggerName > 0) {
                pLoggerInfoCurrent->LoggerName.Buffer = (PWCHAR)
                                        (  ((PUCHAR) pLoggerInfoCurrent)
                                         + sizeof(WMI_LOGGER_INFORMATION));
                status = RtlUnicodeStringToAnsiString(& strBufferA,
                                & pLoggerInfoCurrent->LoggerName, TRUE);
                if (NT_SUCCESS(status)) {
                    if (PropertyArray[i]->LoggerNameOffset == 0) {
                        PropertyArray[i]->LoggerNameOffset =
                                        sizeof(EVENT_TRACE_PROPERTIES);
                    }
                    strDestA = (PCHAR) (  ((PUCHAR) PropertyArray[i])
                                         + PropertyArray[i]->LoggerNameOffset);
                    strcpy(strDestA, strBufferA.Buffer);
                    RtlFreeAnsiString(& strBufferA);
                }
                strDestA[lenLoggerName] = 0;
            }

            if (lenLogFileName > 0) {
                pLoggerInfoCurrent->LogFileName.Buffer = (PWCHAR)
                              (  ((PUCHAR) pLoggerInfoCurrent)
                               + sizeof(WMI_LOGGER_INFORMATION)
                               + pLoggerInfoCurrent->LoggerName.MaximumLength);
                status = RtlUnicodeStringToAnsiString(& strBufferA,
                                & pLoggerInfoCurrent->LogFileName, TRUE);
                if (NT_SUCCESS(status)) {
                    if (PropertyArray[i]->LogFileNameOffset == 0) {
                        PropertyArray[i]->LogFileNameOffset =
                                         sizeof(EVENT_TRACE_PROPERTIES)
                                       + sizeof(CHAR) * (lenLoggerName + 1);
                    }
                    strDestA = (PCHAR) (  ((PUCHAR) PropertyArray[i])
                                         + PropertyArray[i]->LogFileNameOffset);
                    strcpy(strDestA, strBufferA.Buffer);
                    RtlFreeAnsiString(& strBufferA);
                }
                strDestA[lenLogFileName] = 0;
            }
        }

        Offset = Offset
               + sizeof(WMI_LOGGER_INFORMATION)
               + pLoggerInfoCurrent->LogFileName.MaximumLength
               + pLoggerInfoCurrent->LoggerName.MaximumLength;
        i ++;
    }

    * LoggerCount = i;
    status = (* LoggerCount > PropertyArrayCount)
           ? ERROR_MORE_DATA : ERROR_SUCCESS;
Cleanup:
    if (pLoggerInfo)
        WmipFree(pLoggerInfo);

    return WmipSetDosError(status);
}
/*
ULONG
WMIAPI
QueryAllTracesA(
    OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
    IN  ULONG  PropertyArrayCount,
    OUT PULONG LoggerCount
    )
{
    ULONG i, status;
    ULONG returnCount = 0;
    EVENT_TRACE_PROPERTIES  LoggerInfo;
    PEVENT_TRACE_PROPERTIES pLoggerInfo;

    WmipInitProcessHeap();

    if ((LoggerCount == NULL)
        || (PropertyArrayCount > MAXLOGGERS)
        || (PropertyArray == NULL)
        || (PropertyArrayCount == 0))
        return ERROR_INVALID_PARAMETER;
    if (*PropertyArray == NULL)
        return ERROR_INVALID_PARAMETER;

    try {
        *LoggerCount = 0;
        for (i=0; i<MAXLOGGERS; i++) {
            if (returnCount < PropertyArrayCount) 
                pLoggerInfo = PropertyArray[returnCount];
            else {
                pLoggerInfo = &LoggerInfo;
                RtlZeroMemory(pLoggerInfo, sizeof(EVENT_TRACE_PROPERTIES));
                pLoggerInfo->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES);
            }

            WmiSetLoggerId(i, &pLoggerInfo->Wnode.HistoricalContext);

            status = ControlTraceA(
                        (TRACEHANDLE)pLoggerInfo->Wnode.HistoricalContext,
                        NULL,
                        pLoggerInfo,
                        EVENT_TRACE_CONTROL_QUERY);
            if (status == ERROR_SUCCESS)
                returnCount++;
        }
        *LoggerCount = returnCount;
        status = WmipQueryAllUmTraceA(PropertyArray,
                                      FALSE,
                                      PropertyArrayCount,
                                      LoggerCount);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
       return WmipSetDosError(ERROR_NOACCESS);
    }
    if (returnCount > PropertyArrayCount)
        return ERROR_MORE_DATA;
    else 
        return ERROR_SUCCESS;
}*/

TRACEHANDLE
WMIAPI
GetTraceLoggerHandle(
    IN PVOID Buffer
    )
{
    TRACEHANDLE LoggerHandle = (TRACEHANDLE) INVALID_HANDLE_VALUE;
    USHORT LoggerId;

    WmipInitProcessHeap();
    
    if (Buffer == NULL) {
        WmipSetDosError(ERROR_INVALID_PARAMETER);
        return LoggerHandle;
    }

    try {
        if (((PWNODE_HEADER)Buffer)->BufferSize < sizeof(WNODE_HEADER)) {
            WmipSetDosError(ERROR_BAD_LENGTH);
            return LoggerHandle;
        }
        LoggerHandle = (TRACEHANDLE)((PWNODE_HEADER)Buffer)->HistoricalContext;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        WmipSetDosError(ERROR_NOACCESS);
        return (TRACEHANDLE) INVALID_HANDLE_VALUE;
    }
    LoggerId = WmiGetLoggerId(LoggerHandle);
    if ((LoggerId >= MAXLOGGERS) && (LoggerId != KERNEL_LOGGER_ID)) 
    {
        WmipSetDosError(ERROR_INVALID_HANDLE);
        LoggerHandle = (TRACEHANDLE) INVALID_HANDLE_VALUE;
    }
    return LoggerHandle;
}

UCHAR
WMIAPI
GetTraceEnableLevel(
    IN TRACEHANDLE LoggerHandle
    )
{
    UCHAR Level;
    USHORT LoggerId;

    WmipInitProcessHeap();

    LoggerId = WmiGetLoggerId(LoggerHandle);

    if (((LoggerId >= MAXLOGGERS) && (LoggerId != KERNEL_LOGGER_ID))
            || (LoggerHandle == (TRACEHANDLE) NULL))
    {
        WmipSetDosError(ERROR_INVALID_HANDLE);
        return 0;
    }
    Level = WmiGetLoggerEnableLevel(LoggerHandle);
    return Level;
}

ULONG
WMIAPI
GetTraceEnableFlags(
    IN TRACEHANDLE LoggerHandle
    )
{
    ULONG Flags;
    USHORT LoggerId;

    WmipInitProcessHeap();

    LoggerId = WmiGetLoggerId(LoggerHandle);
    if (((LoggerId >= MAXLOGGERS) && (LoggerId != KERNEL_LOGGER_ID))
            || (LoggerHandle == (TRACEHANDLE) NULL))
    {
        WmipSetDosError(ERROR_INVALID_HANDLE);
        return 0;
    }
    Flags = WmiGetLoggerEnableFlags(LoggerHandle);
    return Flags;
}

ULONG
WMIAPI
CreateTraceInstanceId(
    IN PVOID RegHandle,
    IN OUT PEVENT_INSTANCE_INFO pInst
    )
/*++

Routine Description:

    This call takes the Registration Handle for a traced GUID and fills in the 
    instanceId in the EVENT_INSTANCE_INFO structure provided by the caller. 

Arguments:

    RegHandle       Registration Handle for the Guid. 

    pInst           Pointer to the Instance information

Return Value:

    The status of performing the action requested.

--*/
{
    PGUIDMAPENTRY GuidMapEntry;

    WmipInitProcessHeap();
    
    if ((RegHandle == NULL) || (pInst == NULL)) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    } 
    try {
        pInst->RegHandle = RegHandle;
        GuidMapEntry =  (PGUIDMAPENTRY) RegHandle;
        if (GuidMapEntry->InstanceId >= MAXINST) {
            InterlockedCompareExchange(&GuidMapEntry->InstanceId, MAXINST, 0);
        }
        pInst->InstanceId = InterlockedIncrement(&GuidMapEntry->InstanceId);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipSetNtStatus( GetExceptionCode() );
    }

    return ERROR_SUCCESS;
}
/*

ULONG
WMIAPI
EnumerateTraceGuids(
    IN OUT PTRACE_GUID_PROPERTIES *GuidPropertiesArray,
    IN ULONG PropertyArrayCount,
    OUT PULONG GuidCount
    )
/*++

Routine Description:

    This call returns all the registered trace control guids
    with their current status.

Arguments:

    GuidPropertiesArray Points to buffers to write trace control guid properties

    PropertyArrayCount  Size of the array provided

    GuidCount           Number of GUIDs written in the Array. If the
                        Array was smaller than the required size, GuidCount
                        returns the size needed.

Return Value:

    The status of performing the action requested.

--*//*
{
    ULONG Status;
    PWMIGUIDLISTINFO pGuidListInfo;

    WmipInitProcessHeap();

    Status = WmipEnumRegGuids(&pGuidListInfo);

    if (Status == ERROR_SUCCESS) {
        try {

            PWMIGUIDPROPERTIES pGuidProperties = pGuidListInfo->GuidList;
            ULONG i, j = 0;

            for (i=0; i < pGuidListInfo->ReturnedGuidCount; i++) {

                if (pGuidProperties->GuidType == 0) { // Trace Control Guid

                    if (j >=  PropertyArrayCount) {
                        Status = ERROR_MORE_DATA;
                    }
                    else {
                        RtlCopyMemory(&GuidPropertiesArray[j],
                                      &pGuidProperties,
                                      sizeof(WMIGUIDPROPERTIES)
                                     );
                    }
                    j++;
                }
                pGuidProperties++;
            }
            *GuidCount = j;
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Status = WmipSetNtStatus( GetExceptionCode() );
        }

        WmipFree(pGuidListInfo);
    }

    return Status;

}*/


// Stub APIs
ULONG
WMIAPI
QueryTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return ControlTraceA(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_QUERY);
}
/*
ULONG
WMIAPI
QueryTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return ControlTraceW(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_QUERY);
}*/
/*
ULONG
WMIAPI
StopTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return ControlTraceA(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_STOP);
}*/
/*
ULONG
WMIAPI
StopTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return ControlTraceW(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_STOP);
}*/

/*
ULONG
WMIAPI
UpdateTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return
        ControlTraceA(
            TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_UPDATE);
}*/
/*
ULONG
WMIAPI
UpdateTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return
        ControlTraceW(
            TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_UPDATE);
}*/
/*
ULONG
WMIAPI
FlushTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return ControlTraceA(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_FLUSH);
}*/
/*
ULONG
WMIAPI
FlushTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return ControlTraceW(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_FLUSH);
}*/


ULONG 
WmipTraceMessage(
    IN TRACEHANDLE LoggerHandle,
    IN ULONG       MessageFlags,
    IN LPGUID      MessageGuid,
    IN USHORT      MessageNumber,
    IN va_list     ArgList
)
{
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatus;
    PULONG TraceMarker;
    ULONG Size;
    ULONG Flags;
    ULONG dataBytes, argCount ;
    BOOLEAN UserModeOnly = FALSE;
    USHORT    LoggerId;
    PTRACE_ENABLE_CONTEXT pContext = (PTRACE_ENABLE_CONTEXT)&LoggerHandle;
    va_list ap ;
    PMESSAGE_TRACE_USER pMessage = NULL ;
    try {
        //
        // Determine the number bytes to follow header
        //
        dataBytes = 0 ;             // For Count of Bytes
        argCount = 0 ;              // For Count of Arguments
        { // Allocation Block
            
            PCHAR source;
            ap = ArgList ;
            while ((source = va_arg (ap, PVOID)) != NULL) {
                    size_t elemBytes;
                    elemBytes = va_arg (ap, size_t);
                    dataBytes += elemBytes;
                    argCount++ ;
            }
         } // end of allocation block


        if (pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE){
            UserModeOnly = TRUE;
            goto UmOnly;
        }
        //
        // Now the LoggerHandle is expected to be filled in by the caller.
        //  But check to see if it has a valid value.
        //

        LoggerId = WmiGetLoggerId(LoggerHandle);
        if ((LoggerId == 0) || (LoggerId == KERNEL_LOGGER_ID)) {
             return ERROR_INVALID_HANDLE;
        }

        Size = dataBytes + sizeof(MESSAGE_TRACE_USER) ;

        if (Size > TRACE_MESSAGE_MAXIMUM_SIZE) {
            WmipSetLastError(ERROR_BUFFER_OVERFLOW);
            return(ERROR_BUFFER_OVERFLOW);
        }
        
        pMessage = (PMESSAGE_TRACE_USER)WmipAlloc(Size);
        if (pMessage == NULL)
        {
             WmipSetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        pMessage->MessageHeader.Marker = TRACE_MESSAGE | TRACE_HEADER_FLAG ;
        //
        // Fill in Header.
        //
        pMessage->MessageFlags = MessageFlags ;
        pMessage->MessageHeader.Packet.MessageNumber = MessageNumber ;
        pMessage->LoggerHandle = (ULONG64)LoggerHandle ;
        // GUID ? or CompnentID ?
        if (MessageFlags&TRACE_MESSAGE_COMPONENTID) {
            RtlCopyMemory(&pMessage->MessageGuid,MessageGuid,sizeof(ULONG)) ;
        } else if (MessageFlags&TRACE_MESSAGE_GUID) { // Can't have both
        	RtlCopyMemory(&pMessage->MessageGuid,MessageGuid,sizeof(GUID));
        }
        pMessage->DataSize = dataBytes ;
        //
        // Now Copy in the Data.
        //
        { // Allocation Block
            va_list ap;
            PCHAR dest = (PCHAR)&pMessage->Data ;
            PCHAR source;
            ap = ArgList ;
            while ((source = va_arg (ap, PVOID)) != NULL) {
                size_t elemBytes;
                elemBytes = va_arg (ap, size_t);
                RtlCopyMemory (dest, source, elemBytes);
                dest += elemBytes;
            }
        } // Allocation Block
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        if (pMessage != NULL) {
            WmipFree(pMessage);
        }
        return WmipSetNtStatus( GetExceptionCode() );
    }

    if (WmipDeviceHandle == NULL) { // should initialize this during enable??
        //
        // If device is not open then open it now. The
        // handle is closed in the process detach dll callout (DllMain)

        WmipEnterPMCritSection();
        if (WmipDeviceHandle != NULL) { // got set just after test, so return
            WmipLeavePMCritSection();
        }
        else {
            WmipDeviceHandle
                = WmipCreateFileA (WMIDataDeviceName,
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);
            WmipLeavePMCritSection();
            if (WmipDeviceHandle == (HANDLE)-1) {
                WmipDeviceHandle = NULL;
                if (pMessage != NULL) {
                    WmipFree(pMessage);
                }   
                return(WmipGetLastError());
            }
        }
    }
    NtStatus = NtDeviceIoControlFile(
                   WmipDeviceHandle,
                   NULL,
                   NULL,
                   NULL,
                   &IoStatus,
                   IOCTL_WMI_TRACE_MESSAGE,
                   pMessage,
                   Size,
                   pMessage,
                   Size
                   );

UmOnly:

    try {
        if (UserModeOnly) {
            NtStatus = WmipTraceUmMessage(dataBytes,
                                         (ULONG64)LoggerHandle,
                                         MessageFlags,
                                         MessageGuid,
                                         MessageNumber,
                                         ArgList);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return ( GetExceptionCode() );
    }

    if (pMessage != NULL) {
            WmipFree(pMessage);
    }
    return WmipSetNtStatus( NtStatus );

}

ULONG
WMIAPI
TraceMessage(
    IN TRACEHANDLE LoggerHandle,
    IN ULONG       MessageFlags,
    IN LPGUID      MessageGuid,
    IN USHORT      MessageNumber,
    ...
)
/*++
Routine Description:
This routine is used by WMI data providers to trace events.
It expects the user to pass in the handle to the logger.
Also, the user cannot ask to log something that is larger than
the buffer size (minus buffer header).

Arguments:
//    IN TRACEHANDLE LoggerHandle   - LoggerHandle obtained earlier
//    IN USHORT MessageFlags,         - Flags which both control what standard values are logged and
//                                    also included in the message header to control decoding
//    IN PGUID MessageGuid,         - Pointer to the message GUID of this set of messages or if
//                                    TRACE_COMPONENTID is set the actual compnent ID
//    IN USHORT MessageNumber,      - The type of message being logged, associates it with the 
//                                    appropriate format string  
//    ...                           - List of arguments to be processed with the format string
//                                    these are stored as pairs of
//                                      PVOID - ptr to argument
//                                      ULONG - size of argument
//                                    and terminated by a pointer to NULL, length of zero pair.


Return Value:
    Status
--*/
{
    ULONG Status ;
    va_list ArgList ;

    WmipInitProcessHeap();
    
    try {
         va_start(ArgList,MessageNumber);
         Status = WmipTraceMessage(LoggerHandle, MessageFlags, MessageGuid, MessageNumber, ArgList);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipSetNtStatus( GetExceptionCode() );
    }
    return WmipSetDosError(Status);
}


ULONG
WMIAPI
TraceMessageVa(
    IN TRACEHANDLE LoggerHandle,
    IN ULONG       MessageFlags,
    IN LPGUID      MessageGuid,
    IN USHORT      MessageNumber,
    IN va_list     MessageArgList
)
// The Va version of TraceMessage
{
    ULONG Status ;

    WmipInitProcessHeap();
    
    try {
        Status = WmipTraceMessage(LoggerHandle, MessageFlags, MessageGuid, MessageNumber, MessageArgList);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipSetNtStatus( GetExceptionCode() );
    }
    return WmipSetDosError(Status);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\ntdll\logsup.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    logsup.c

Abstract:

    WMI logger api set. The routines here will need to appear like they
    are system calls. They are necessary to do the necessary error checking
    and do most of the legwork that can be done outside the kernel. The
    kernel portion will subsequently only deal with the actual logging
    and tracing.

Author:

    28-May-1997 JeePang

Revision History:

--*/

#ifndef MEMPHIS
#include <nt.h>
#include <ntrtl.h>          // for ntutrl.h
#include <nturtl.h>         // for RTL_CRITICAL_SECTION in winbase.h/wtypes.h
#include <wtypes.h>         // for LPGUID in wmium.h
#include "wmiump.h"
#include "evntrace.h"
#include "traceump.h"
#include "tracelib.h"
#include <math.h>
#include "trcapi.h"

NTSTATUS
WmipProcessRunDown(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN ULONG StartFlag,
    IN ULONG fEnableFlags
    );

NTSTATUS
WmipThreadRunDown(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN ULONG StartFlag,
    IN BOOLEAN bExtended
    );

ULONG WmiTraceAlignment = DEFAULT_TRACE_ALIGNMENT;
/*
ULONG
WmipStartLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This is the actual routine to communicate with the kernel to start
    the logger. All the required parameters must be in LoggerInfo.

Arguments:

    LoggerInfo      The actual parameters to be passed to and return from
                    kernel.

Return Value:

    The status of performing the action requested.

--*//*
{
    ULONG Status;
    ULONG BufferSize;
    ACCESS_MASK DesiredAccess = 0;
    LPGUID Guid;
    PVOID SavedChecksum;
    ULONG SavedLogFileMode;
    BOOLEAN IsKernelTrace = FALSE;
    BOOLEAN bLogFile = FALSE;
    BOOLEAN bRealTime = FALSE;


    Guid = &LoggerInfo->Wnode.Guid;
    if (IsEqualGUID(Guid, &SystemTraceControlGuid) ||
        IsEqualGUID(Guid, &WmiEventLoggerGuid)) {
        IsKernelTrace = TRUE;
        DesiredAccess |= TRACELOG_ACCESS_KERNEL_LOGGER;
    }
    if ((LoggerInfo->LogFileName.Length > 0) &&
        (LoggerInfo->LogFileName.Buffer != NULL)) {
        DesiredAccess |= TRACELOG_CREATE_ONDISK;
        bLogFile = TRUE;
    }
    SavedLogFileMode = LoggerInfo->LogFileMode;
    if (SavedLogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
        DesiredAccess |= TRACELOG_CREATE_REALTIME;
        bRealTime = TRUE;
    }
    Status = WmipCheckGuidAccess( Guid, DesiredAccess );

    if (Status != ERROR_SUCCESS) {
        return Status;
    }
    //
    // Set the Default Clock Type
    //

    if (LoggerInfo->Wnode.ClientContext != EVENT_TRACE_CLOCK_SYSTEMTIME) {
        LoggerInfo->Wnode.ClientContext = EVENT_TRACE_CLOCK_PERFCOUNTER;
    }

    if (SavedLogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
        Status = WmipSendUmLogRequest(
                    WmiStartLoggerCode,
                    LoggerInfo
                    );
    }
    else if (IsKernelTrace) {
        //
        // In order to capture the process/thread rundown accurately, we need to
        // start kernel logger in two steps. Start logger with delay write,
        // do rundown from user mode and then updatelogger with filename.
        //
        WMI_LOGGER_INFORMATION DelayLoggerInfo;
        ULONG EnableFlags = LoggerInfo->EnableFlags;
        LARGE_INTEGER Frequency;
        WMI_REF_CLOCK RefClock;
        //
        // If it's only realtime start logger in one step
        //

        if (bRealTime && !bLogFile) {

            BufferSize = LoggerInfo->BufferSize * 1024;
            Status =  WmipSendWmiKMRequest(
                        NULL,
                        IOCTL_WMI_START_LOGGER,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        &BufferSize,
                        NULL
                        );
            return WmipSetDosError(Status);
        }

        if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            PTRACE_ENABLE_FLAG_EXTENSION tFlagExt;

            tFlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                       &LoggerInfo->EnableFlags;
            EnableFlags = *(PULONG)((PCHAR)LoggerInfo + tFlagExt->Offset);
        }

        //
        // Take a reference timestamp before actually starting the logger
        //
        RefClock.StartTime.QuadPart = WmipGetSystemTime();
        if (LoggerInfo->Wnode.ClientContext == EVENT_TRACE_CLOCK_PERFCOUNTER) {
            Status = NtQueryPerformanceCounter(&RefClock.StartPerfClock, &Frequency);
        }
        else {
            RefClock.StartPerfClock = RefClock.StartTime;
        }


        RtlCopyMemory(&DelayLoggerInfo, LoggerInfo, sizeof(WMI_LOGGER_INFORMATION));
        RtlZeroMemory(&DelayLoggerInfo.LogFileName, sizeof(UNICODE_STRING) );

        DelayLoggerInfo.Wnode.BufferSize = sizeof(WMI_LOGGER_INFORMATION);

        DelayLoggerInfo.LogFileMode |= EVENT_TRACE_DELAY_OPEN_FILE_MODE;

        //
        // Since there's no filename in step 1 of StartLogger we need to mask
        // the NEWFILE mode to prevent kernel trying to generate a file
        //
        DelayLoggerInfo.LogFileMode &= ~EVENT_TRACE_FILE_MODE_NEWFILE;

        DelayLoggerInfo.EnableFlags = (EVENT_TRACE_FLAG_PROCESS & EnableFlags);
        DelayLoggerInfo.EnableFlags |= (EVENT_TRACE_FLAG_THREAD & EnableFlags);
        DelayLoggerInfo.EnableFlags |= (EVENT_TRACE_FLAG_IMAGE_LOAD & EnableFlags);

        BufferSize = DelayLoggerInfo.BufferSize * 1024;
        Status = WmipSendWmiKMRequest(
                    NULL,
                    IOCTL_WMI_START_LOGGER,
                    &DelayLoggerInfo,
                    DelayLoggerInfo.Wnode.BufferSize,
                    &DelayLoggerInfo,
                    DelayLoggerInfo.Wnode.BufferSize,
                    &BufferSize,
                    NULL
                    );
        if (Status != ERROR_SUCCESS) {
            return Status;
        }
        //
        // We need to pick up any parameter adjustment done by the kernel
        // here so UpdateTrace does not fail.
        //
        LoggerInfo->Wnode.HistoricalContext = DelayLoggerInfo.Wnode.HistoricalContext;
        LoggerInfo->MinimumBuffers          = DelayLoggerInfo.MinimumBuffers;
        LoggerInfo->MaximumBuffers          = DelayLoggerInfo.MaximumBuffers;
        LoggerInfo->NumberOfBuffers         = DelayLoggerInfo.NumberOfBuffers;
        LoggerInfo->BufferSize              = DelayLoggerInfo.BufferSize;
        LoggerInfo->AgeLimit                = DelayLoggerInfo.AgeLimit;

        BufferSize = LoggerInfo->BufferSize * 1024;

        //
        //  Add the LogHeader
        //
        LoggerInfo->Checksum = NULL;
        Status = WmipAddLogHeaderToLogFile(LoggerInfo, &RefClock, FALSE);

        if (Status == ERROR_SUCCESS) {
            SavedChecksum = LoggerInfo->Checksum;
            //
            // Update the logger with the filename
            //
            Status = WmipSendWmiKMRequest(
                        NULL,
                        IOCTL_WMI_UPDATE_LOGGER,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        &BufferSize,
                        NULL
                        );


            if (LoggerInfo->Checksum != NULL) {
                WmipFree(LoggerInfo->Checksum);
            }
        }

        if (Status != ERROR_SUCCESS) {
            ULONG lStatus;

            //
            // Logger must be stopped now
            //
            lStatus = WmipSendWmiKMRequest(
                    NULL,
                    IOCTL_WMI_STOP_LOGGER,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    &BufferSize,
                    NULL
                    );

            LoggerInfo->LogFileMode = SavedLogFileMode;
            return WmipSetDosError(Status);
        }
        else {
            if (LoggerInfo->LogFileHandle != NULL) {
                NtClose(LoggerInfo->LogFileHandle);
                LoggerInfo->LogFileHandle = NULL;
            }
        }
    }
    else {
        LoggerInfo->Checksum = NULL;
        Status = WmipAddLogHeaderToLogFile(LoggerInfo, NULL, FALSE);
        if (Status != ERROR_SUCCESS) {
            return WmipSetDosError(Status);
        }

        BufferSize = LoggerInfo->BufferSize * 1024;
        SavedChecksum = LoggerInfo->Checksum;

        Status = WmipSendWmiKMRequest(       // actually start the logger here
        		    NULL,
                    IOCTL_WMI_START_LOGGER,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    &BufferSize,
		            NULL
                    );
        if (Status == ERROR_SUCCESS) {
            if (LoggerInfo->LogFileHandle != NULL) {
                NtClose(LoggerInfo->LogFileHandle);
                LoggerInfo->LogFileHandle = NULL;
            }
        }

        if (SavedChecksum != NULL) {
            WmipFree(SavedChecksum);
        }
    }
    //
    // Restore the LogFileMode
    //
    LoggerInfo->LogFileMode = SavedLogFileMode;

    return WmipSetDosError(Status);
}*/


ULONG
WmipFinalizeLogFileHeader(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    ULONG                     Status    = ERROR_SUCCESS;
    ULONG                     ErrorCode = ERROR_SUCCESS;
    HANDLE                    LogFile   = INVALID_HANDLE_VALUE;
    LARGE_INTEGER             CurrentTime;
    ULONG                     BuffersWritten;
    WMI_LOGGER_CONTEXT        Logger;
    IO_STATUS_BLOCK           IoStatus;
    FILE_POSITION_INFORMATION FileInfo;
    FILE_STANDARD_INFORMATION FileSize;
    PWMI_BUFFER_HEADER        Buffer;  // need to initialize buffer first
    SYSTEM_BASIC_INFORMATION  SystemInfo;
    ULONG                     EnableFlags;

    RtlZeroMemory(&Logger, sizeof(WMI_LOGGER_CONTEXT));

    Logger.BufferSpace = NULL;
    if (LoggerInfo->LogFileName.Length > 0 ) {
        // open the file for writing synchronously for the logger
        //    others may want to read it as well.
        //
        LogFile = WmipCreateFileW(
                   (LPWSTR)LoggerInfo->LogFileName.Buffer,
                   GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ,
                   NULL,
                   OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL
                   );
        if (LogFile == INVALID_HANDLE_VALUE) {
            ErrorCode = WmipSetDosError(WmipGetLastError());
            goto cleanup;
        }

        Logger.BuffersWritten = LoggerInfo->BuffersWritten;

        Logger.BufferSpace = WmipAlloc(LoggerInfo->BufferSize * 1024);
        if (Logger.BufferSpace == NULL) {
            ErrorCode = WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
            goto cleanup;
        }
        Buffer = (PWMI_BUFFER_HEADER) Logger.BufferSpace;
        RtlZeroMemory(Buffer, LoggerInfo->BufferSize * 1024);
        Buffer->Wnode.BufferSize = LoggerInfo->BufferSize * 1024;
        Buffer->ClientContext.Alignment = (UCHAR)WmiTraceAlignment;
        Buffer->EventsLost = 0;
        Buffer->Offset = sizeof(WMI_BUFFER_HEADER);
        Buffer->Wnode.Guid = LoggerInfo->Wnode.Guid;
        Status = NtQuerySystemInformation(
                    SystemBasicInformation,
                    &SystemInfo, sizeof (SystemInfo), NULL);

        if (!NT_SUCCESS(Status)) {
            ErrorCode = WmipSetNtStatus(Status);
            goto cleanup;
        }
        Logger.TimerResolution = SystemInfo.TimerResolution;
        Logger.LogFileHandle = LogFile;
        Logger.BufferSize = LoggerInfo->BufferSize * 1024;

        // For Circular LogFile the process rundown data is appended at the
        // last buffer written and not to the end of file.
        //
        Status = NtQueryInformationFile(
                    LogFile,
                    &IoStatus,
                    &FileSize,
                    sizeof(FILE_STANDARD_INFORMATION),
                    FileStandardInformation
                        );
        if (!NT_SUCCESS(Status)) {
            ErrorCode = WmipSetNtStatus(Status);
            goto cleanup;
        }

        if (IsEqualGUID(&LoggerInfo->Wnode.Guid, &SystemTraceControlGuid)) {

            if (LoggerInfo->LogFileMode != EVENT_TRACE_FILE_MODE_CIRCULAR) {
                FileInfo.CurrentByteOffset = FileSize.EndOfFile;
            }
            else {
                ULONG BufferSize = LoggerInfo->BufferSize;  // in KB
                ULONG BuffersWritten = LoggerInfo->BuffersWritten;
                ULONG maxBuffers = (LoggerInfo->MaximumFileSize * 1024) / BufferSize;
                ULONG LastBuffer;
                ULONG StartBuffers;

                FileInfo.CurrentByteOffset.QuadPart =
                                         LOGFILE_FIELD_OFFSET(StartBuffers);
                Status = NtSetInformationFile(
                                     LogFile,
                                     &IoStatus,
                                     &FileInfo,
                                     sizeof(FILE_POSITION_INFORMATION),
                                     FilePositionInformation
                                     );
                if (!NT_SUCCESS(Status)) {
                    ErrorCode = WmipSetNtStatus(Status);
                    goto cleanup;
                }

                Status = NtReadFile(
                            LogFile,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatus,
                            &StartBuffers,
                            sizeof(ULONG),
                            NULL,
                            NULL
                            );
                if (!NT_SUCCESS(Status)) {
                    ErrorCode = WmipSetNtStatus(Status);
                    goto cleanup;
                }

                LastBuffer = (maxBuffers > StartBuffers) ?
                             (StartBuffers + (BuffersWritten - StartBuffers)
                             % (maxBuffers - StartBuffers))
                             : 0;
                FileInfo.CurrentByteOffset.QuadPart =  LastBuffer *
                                                       BufferSize * 1024;
            }

            Status = NtSetInformationFile(
                         LogFile,
                         &IoStatus,
                         &FileInfo,
                         sizeof(FILE_POSITION_INFORMATION),
                         FilePositionInformation
                         );
            if (!NT_SUCCESS(Status)) {
                ErrorCode = WmipSetNtStatus(Status);
                goto cleanup;
            }

            EnableFlags = LoggerInfo->EnableFlags;

            if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
                PTRACE_ENABLE_FLAG_EXTENSION tFlagExt;

                tFlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                           &LoggerInfo->EnableFlags;

                if (LoggerInfo->Wnode.BufferSize >= (tFlagExt->Offset + sizeof(ULONG)) )  {
                    EnableFlags = *(PULONG)((PCHAR)LoggerInfo + tFlagExt->Offset);
                }
                else {
                    EnableFlags = 0;    // Should not happen.
                }
            }

            if (LoggerInfo->Wnode.ClientContext != EVENT_TRACE_CLOCK_SYSTEMTIME) {
                LoggerInfo->Wnode.ClientContext = EVENT_TRACE_CLOCK_PERFCOUNTER;
            }
            Logger.UsePerfClock = LoggerInfo->Wnode.ClientContext;

            WmipProcessRunDown(&Logger, FALSE, EnableFlags);
            {
                PWMI_BUFFER_HEADER Buffer1 =
                                (PWMI_BUFFER_HEADER) Logger.BufferSpace;
                    if (Buffer1->Offset < Logger.BufferSize) {
                        RtlFillMemory(
                                (char *) Logger.BufferSpace + Buffer1->Offset,
                                Logger.BufferSize - Buffer1->Offset,
                                0xFF);
                    }
            }
            Status = NtWriteFile(
                        LogFile,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        Logger.BufferSpace,
                        Logger.BufferSize,
                        NULL,
                        NULL);
            if (NT_SUCCESS(Status)) {
                NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
                Logger.BuffersWritten++;
            }
        }
        else { // For Application Traces, need to dump the guidmaps again.

    // Set the FilePointer to end of file so that Rundown data may be appended.
    //
            FileInfo.CurrentByteOffset = FileSize.EndOfFile;
            Status = NtSetInformationFile(
                     LogFile,
                     &IoStatus,
                     &FileInfo,
                     sizeof(FILE_POSITION_INFORMATION),
                     FilePositionInformation
                     );
            if (!NT_SUCCESS(Status)) {
                ErrorCode = WmipSetNtStatus(Status);
                goto cleanup;
            }

            // Dump the Guid Maps once more at the End.
            //
            Buffer->EventsLost = 0;
            Buffer->Offset = sizeof(WMI_BUFFER_HEADER);
            BuffersWritten = Logger.BuffersWritten;

            if (WmipDumpGuidMaps(&Logger, NULL, FALSE) > 0) {
                if (Buffer->Offset < Logger.BufferSize) {
                    RtlFillMemory(
                            (char *) Logger.BufferSpace + Buffer->Offset,
                            Logger.BufferSize - Buffer->Offset,
                            0xFF);
                }
                Status = NtWriteFile(
                            LogFile,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatus,
                            Logger.BufferSpace,
                            Logger.BufferSize,
                            NULL,
                            NULL);
                if (NT_SUCCESS(Status)) {
                    NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
                    Logger.BuffersWritten = BuffersWritten;
                }
            }
        }

        // TODO: should use memory-mapped file

        // Update the EndTime stamp field in LogFile.
        //
        FileInfo.CurrentByteOffset.QuadPart =
                                LOGFILE_FIELD_OFFSET(EndTime);
        Status = NtSetInformationFile(
                     LogFile,
                     &IoStatus,
                     &FileInfo,
                     sizeof(FILE_POSITION_INFORMATION),
                     FilePositionInformation
                     );
        if (!NT_SUCCESS(Status)) {
            ErrorCode = WmipSetNtStatus(Status);
            goto cleanup;
        }

        // End Time is always wallclock time.
        //
        CurrentTime.QuadPart = WmipGetSystemTime();
        Status = NtWriteFile(
                    LogFile,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    &CurrentTime,
                    sizeof(ULONGLONG),
                    NULL,
                    NULL
                    );
        if (NT_SUCCESS(Status)) {
            NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
        }

       // Update the Number of Buffers Written field in the header
       //
        FileInfo.CurrentByteOffset.QuadPart =
                            LOGFILE_FIELD_OFFSET(BuffersWritten);
        Status = NtSetInformationFile(
                     LogFile,
                     &IoStatus,
                     &FileInfo,
                     sizeof(FILE_POSITION_INFORMATION),
                     FilePositionInformation
                     );
        if (!NT_SUCCESS(Status)) {
            ErrorCode = WmipSetNtStatus(Status);
            goto cleanup;
        }

        Status = NtWriteFile(
                    LogFile,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    &Logger.BuffersWritten,
                    sizeof(ULONG),
                    NULL,
                    NULL
                    );
        if (NT_SUCCESS(Status)) {
            NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
        }

        ErrorCode = RtlNtStatusToDosError(Status);
        LoggerInfo->BuffersWritten = Logger.BuffersWritten;

        //
        // Write the BuffersLost information into the logfile
        //


        FileInfo.CurrentByteOffset.QuadPart =
                            LOGFILE_FIELD_OFFSET(BuffersLost);
        Status = NtSetInformationFile(
                     LogFile,
                     &IoStatus,
                     &FileInfo,
                     sizeof(FILE_POSITION_INFORMATION),
                     FilePositionInformation
                     );
        if (!NT_SUCCESS(Status)) {
            ErrorCode = WmipSetNtStatus(Status);
            goto cleanup;
        }

        Status = NtWriteFile(
                    LogFile,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    &LoggerInfo->LogBuffersLost,
                    sizeof(ULONG),
                    NULL,
                    NULL
                    );
        if (NT_SUCCESS(Status)) {
            NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
        }

        //
        // Write the EventsLost information into the logfile
        //


        FileInfo.CurrentByteOffset.QuadPart =
                            LOGFILE_FIELD_OFFSET(EventsLost);
        Status = NtSetInformationFile(
                     LogFile,
                     &IoStatus,
                     &FileInfo,
                     sizeof(FILE_POSITION_INFORMATION),
                     FilePositionInformation
                     );
        if (!NT_SUCCESS(Status)) {
            ErrorCode = WmipSetNtStatus(Status);
            goto cleanup;
        }

        Status = NtWriteFile(
                    LogFile,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    &LoggerInfo->EventsLost,
                    sizeof(ULONG),
                    NULL,
                    NULL
                    );
        if (NT_SUCCESS(Status)) {
            NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
        }

    }

cleanup:
    if (LogFile != INVALID_HANDLE_VALUE) {
        NtClose(LogFile);
    }
    if (Logger.BufferSpace != NULL) {
        WmipFree(Logger.BufferSpace);
    }
    return WmipSetDosError(ErrorCode);
}

ULONG
WmipStopLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This is the actual routine to communicate with the kernel to stop
    the logger. All the properties of the logger will be returned in LoggerInfo.

Arguments:

    LoggerInfo      The actual parameters to be passed to and return from
                    kernel.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG ErrorCode, ReturnSize;
    PTRACE_ENABLE_CONTEXT pContext;

    if (LoggerInfo == NULL)
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    if (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    if ( !(LoggerInfo->Wnode.Flags & WNODE_FLAG_TRACED_GUID) )
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    pContext = (PTRACE_ENABLE_CONTEXT) & LoggerInfo->Wnode.HistoricalContext;
    if (   (pContext->InternalFlag != 0)
        && (pContext->InternalFlag != EVENT_TRACE_INTERNAL_FLAG_PRIVATE)) {
        // Currently only one possible InternalFlag value. This will filter
        // out some bogus LoggerHandle
        //
        return WmipSetDosError(ERROR_INVALID_HANDLE);
    }

    if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
        ErrorCode = WmipSendUmLogRequest(WmiStopLoggerCode, LoggerInfo);
        pContext->InternalFlag |= EVENT_TRACE_INTERNAL_FLAG_PRIVATE;
        pContext->LoggerId     = 1;
    }
    else {


        ErrorCode = WmipSendWmiKMRequest(
                        NULL,
                        IOCTL_WMI_STOP_LOGGER,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        &ReturnSize,
                        NULL
                        );

//
// if logging to a file, then update the EndTime, BuffersWritten and do
// process rundown for kernel trace.
//
        if (ErrorCode == ERROR_SUCCESS) {
            ErrorCode = WmipFinalizeLogFileHeader(LoggerInfo);
        }
    }

    return WmipSetDosError(ErrorCode);
}


ULONG
WmipQueryLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN ULONG Update
    )
/*++

Routine Description:

    This is the actual routine to communicate with the kernel to query
    the logger. All the properties of the logger will be returned in LoggerInfo.

Arguments:

    LoggerInfo      The actual parameters to be passed to and return from
                    kernel.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG Status, ReturnSize;
    HANDLE LogFileHandle = NULL;
    PTRACE_ENABLE_CONTEXT pContext;
    BOOLEAN bAddAppendFlag = FALSE;
    ULONG SavedLogFileMode;

    if (LoggerInfo == NULL)
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    if (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    if ( !(LoggerInfo->Wnode.Flags & WNODE_FLAG_TRACED_GUID) )
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    LoggerInfo->Checksum      = NULL;
    LoggerInfo->LogFileHandle = NULL;
    pContext = (PTRACE_ENABLE_CONTEXT) &LoggerInfo->Wnode.HistoricalContext;

    if (   (pContext->InternalFlag != 0)
        && (pContext->InternalFlag != EVENT_TRACE_INTERNAL_FLAG_PRIVATE)) {
        // Currently only one possible InternalFlag value. This will filter
        // out some bogus LoggerHandle
        //
        return WmipSetDosError(ERROR_INVALID_HANDLE);
    }

    //
    // If UPDATE and a new logfile is given throw in the LogFileHeader
    //
    if (   Update
        && LoggerInfo->LogFileName.Length > 0
        && !(   (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
             || (pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE))) {
        Status = WmipAddLogHeaderToLogFile(LoggerInfo, NULL, Update);
        if (Status  != ERROR_SUCCESS) {
            return WmipSetDosError(Status);
        }

        LogFileHandle = LoggerInfo->LogFileHandle;
        bAddAppendFlag = TRUE;
        //
        // If we are switching to a new file, make sure it is append mode
        //
        SavedLogFileMode = LoggerInfo->LogFileMode;
    }


    if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE ||
        pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE) {

        pContext->InternalFlag |= EVENT_TRACE_INTERNAL_FLAG_PRIVATE;
        pContext->LoggerId     = 1;

        Status = WmipSendUmLogRequest(
                    (Update) ? (WmiUpdateLoggerCode) : (WmiQueryLoggerCode),
                    LoggerInfo
                    );
    }
    else {
        Status = WmipSendWmiKMRequest(
                    NULL,
                    (Update ? IOCTL_WMI_UPDATE_LOGGER : IOCTL_WMI_QUERY_LOGGER),
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    &ReturnSize,
                    NULL
                    );

        if (LoggerInfo->Checksum != NULL) {
            WmipFree(LoggerInfo->Checksum);
        }
    }
    if (bAddAppendFlag) {
        LoggerInfo->LogFileMode = SavedLogFileMode;
    }
    return WmipSetDosError(Status);
}

PVOID
WmipGetTraceBuffer(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PSYSTEM_THREAD_INFORMATION pThread,
    IN ULONG GroupType,
    IN ULONG RequiredSize
    )
{
    PSYSTEM_TRACE_HEADER Header;
    PWMI_BUFFER_HEADER Buffer;
    THREAD_BASIC_INFORMATION ThreadInfo;
    KERNEL_USER_TIMES ThreadCpu;
    NTSTATUS Status;
    ULONG BytesUsed;
    PCLIENT_ID Cid;

    RequiredSize += sizeof (SYSTEM_TRACE_HEADER);   // add in header

    RequiredSize = (ULONG) ALIGN_TO_POWER2(RequiredSize, WmiTraceAlignment);

    Buffer = (PWMI_BUFFER_HEADER) Logger->BufferSpace;

    if (RequiredSize > Logger->BufferSize - sizeof(WMI_BUFFER_HEADER)) {
        WmipSetDosError(ERROR_BUFFER_OVERFLOW);
        return NULL;
    }

    if (RequiredSize > (Logger->BufferSize - Buffer->Offset)) {
        ULONG Status;
        IO_STATUS_BLOCK IoStatus;

        if (Buffer->Offset < Logger->BufferSize) {
            RtlFillMemory(
                    (char *) Buffer + Buffer->Offset,
                    Logger->BufferSize - Buffer->Offset,
                    0xFF);
        }
        Status = NtWriteFile(
                    Logger->LogFileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    Buffer,
                    Logger->BufferSize,
                    NULL,
                    NULL);
        Buffer->EventsLost = 0;
        Buffer->Offset = sizeof(WMI_BUFFER_HEADER);
        if (!NT_SUCCESS(Status)) {
            return NULL;
        }
        Logger->BuffersWritten++;
    }
    Header = (PSYSTEM_TRACE_HEADER) ((char*)Buffer + Buffer->Offset);

    if (Logger->UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
        LARGE_INTEGER Frequency;
        ULONGLONG Counter = 0;
        Status = NtQueryPerformanceCounter((PLARGE_INTEGER)&Counter,
                                            &Frequency);
        Header->SystemTime.QuadPart = Counter;
    }
    else {
        Header->SystemTime.QuadPart = WmipGetSystemTime();
    }

    Header->Header = (GroupType << 16) + RequiredSize;
    Header->Marker = SYSTEM_TRACE_MARKER;

    if (pThread == NULL) {
        Status = NtQueryInformationThread(
                    NtCurrentThread(),
                    ThreadBasicInformation,
                    &ThreadInfo,
                    sizeof ThreadInfo, NULL);
        if (NT_SUCCESS(Status)) {
            Cid = &ThreadInfo.ClientId;
            Header->ThreadId = HandleToUlong(Cid->UniqueThread);
            Header->ProcessId = HandleToUlong(Cid->UniqueProcess);
        }

        Status = NtQueryInformationThread(
                    NtCurrentThread(),
                    ThreadTimes,
                    &ThreadCpu, sizeof ThreadCpu, NULL);
        if (NT_SUCCESS(Status)) {
            Header->KernelTime = (ULONG) (ThreadCpu.KernelTime.QuadPart
                                      / Logger->TimerResolution);
            Header->UserTime   = (ULONG) (ThreadCpu.UserTime.QuadPart
                                      / Logger->TimerResolution);
        }
    }
    else {
        Cid = &pThread->ClientId;
        Header->ThreadId = HandleToUlong(Cid->UniqueThread);
        Header->ProcessId = HandleToUlong(Cid->UniqueProcess);
        Header->KernelTime = (ULONG) (pThread->KernelTime.QuadPart
                                / Logger->TimerResolution);
        Header->UserTime = (ULONG) (pThread->UserTime.QuadPart
                                / Logger->TimerResolution);
    }

    Buffer->Offset += RequiredSize;
    // If there is room, throw in a end of buffer marker.

    BytesUsed = Buffer->Offset;
    if ( BytesUsed <= (Logger->BufferSize-sizeof(ULONG)) ) {
        *((long*)((char*)Buffer+Buffer->Offset)) = -1;
    }
    return (PVOID) ( (char*) Header + sizeof(SYSTEM_TRACE_HEADER) );
}


VOID
WmipCopyPropertiesToInfo(
    IN PEVENT_TRACE_PROPERTIES Properties,
    IN PWMI_LOGGER_INFORMATION Info
    )
{
    ULONG SavedBufferSize = Info->Wnode.BufferSize;

    RtlCopyMemory(&Info->Wnode, &Properties->Wnode, sizeof(WNODE_HEADER));

    Info->Wnode.BufferSize = SavedBufferSize;

    Info->BufferSize            = Properties->BufferSize;
    Info->MinimumBuffers        = Properties->MinimumBuffers;
    Info->MaximumBuffers        = Properties->MaximumBuffers;
    Info->NumberOfBuffers       = Properties->NumberOfBuffers;
    Info->FreeBuffers           = Properties->FreeBuffers;
    Info->EventsLost            = Properties->EventsLost;
    Info->BuffersWritten        = Properties->BuffersWritten;
    Info->LoggerThreadId        = Properties->LoggerThreadId;
    Info->MaximumFileSize       = Properties->MaximumFileSize;
    Info->EnableFlags           = Properties->EnableFlags;
    Info->LogFileMode           = Properties->LogFileMode;
    Info->FlushTimer            = Properties->FlushTimer;
    Info->LogBuffersLost        = Properties->LogBuffersLost;
    Info->AgeLimit              = Properties->AgeLimit;
    Info->RealTimeBuffersLost   = Properties->RealTimeBuffersLost;
}

VOID
WmipCopyInfoToProperties(
    IN PWMI_LOGGER_INFORMATION Info,
    IN PEVENT_TRACE_PROPERTIES Properties
    )
{
    ULONG SavedSize = Properties->Wnode.BufferSize;
    RtlCopyMemory(&Properties->Wnode, &Info->Wnode, sizeof(WNODE_HEADER));
    Properties->Wnode.BufferSize = SavedSize;

    Properties->BufferSize            = Info->BufferSize;
    Properties->MinimumBuffers        = Info->MinimumBuffers;
    Properties->MaximumBuffers        = Info->MaximumBuffers;
    Properties->NumberOfBuffers       = Info->NumberOfBuffers;
    Properties->FreeBuffers           = Info->FreeBuffers;
    Properties->EventsLost            = Info->EventsLost;
    Properties->BuffersWritten        = Info->BuffersWritten;
    Properties->LoggerThreadId        = Info->LoggerThreadId;
    Properties->MaximumFileSize       = Info->MaximumFileSize;
    Properties->EnableFlags           = Info->EnableFlags;
    Properties->LogFileMode           = Info->LogFileMode;
    Properties->FlushTimer            = Info->FlushTimer;
    Properties->LogBuffersLost        = Info->LogBuffersLost;
    Properties->AgeLimit              = Info->AgeLimit;
    Properties->RealTimeBuffersLost   = Info->RealTimeBuffersLost;
}

NTSTATUS
WmipThreadRunDown(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN ULONG StartFlag,
    IN BOOLEAN bExtended
    )
{
    PSYSTEM_THREAD_INFORMATION pThreadInfo;
    ULONG GroupType;
    ULONG i;
    ULONG Size;
    ULONG SystemThreadInfoSize;
    PWMI_EXTENDED_THREAD_INFORMATION ThreadInfo;

    pThreadInfo = (PSYSTEM_THREAD_INFORMATION) (pProcessInfo+1);

    GroupType = EVENT_TRACE_GROUP_THREAD +
                ((StartFlag) ? EVENT_TRACE_TYPE_DC_START
                             : EVENT_TRACE_TYPE_DC_END);

    Size = sizeof(WMI_EXTENDED_THREAD_INFORMATION);


    SystemThreadInfoSize = (bExtended)  ? sizeof(SYSTEM_EXTENDED_THREAD_INFORMATION)
                                        : sizeof(SYSTEM_THREAD_INFORMATION);
    for (i=0; i < pProcessInfo->NumberOfThreads; i++) {
        if (pThreadInfo == NULL)
            break;
        ThreadInfo = (PWMI_EXTENDED_THREAD_INFORMATION)
                      WmipGetTraceBuffer( Logger,
                                          pThreadInfo,
                                          GroupType,
                                          Size );

        if (ThreadInfo) {
            ThreadInfo->ProcessId =
                HandleToUlong(pThreadInfo->ClientId.UniqueProcess);
            ThreadInfo->ThreadId =
                HandleToUlong(pThreadInfo->ClientId.UniqueThread);

            if (bExtended) {
                PSYSTEM_EXTENDED_THREAD_INFORMATION pExtThreadInfo;
                pExtThreadInfo = (PSYSTEM_EXTENDED_THREAD_INFORMATION) pThreadInfo;
                ThreadInfo->StackBase = pExtThreadInfo->StackBase;
                ThreadInfo->StackLimit = pExtThreadInfo->StackLimit;

                ThreadInfo->StartAddr = pExtThreadInfo->ThreadInfo.StartAddress;
                ThreadInfo->Win32StartAddr = pExtThreadInfo->Win32StartAddress;
                ThreadInfo->UserStackBase = NULL;
                ThreadInfo->UserStackLimit = NULL;
                ThreadInfo->WaitMode = -1;
            }
            else {
                ThreadInfo->StackBase = NULL;
                ThreadInfo->StackLimit = NULL;
                ThreadInfo->StartAddr = NULL;
                ThreadInfo->Win32StartAddr = NULL;
                ThreadInfo->UserStackBase = NULL;
                ThreadInfo->UserStackLimit = NULL;
                ThreadInfo->WaitMode = -1;
            }
        }
        pThreadInfo  = (PSYSTEM_THREAD_INFORMATION)( (char*)pThreadInfo + SystemThreadInfoSize );
    }
    return STATUS_SUCCESS;
}

void
WmipLogImageLoadEvent(
    IN HANDLE ProcessID,
    IN PWMI_LOGGER_CONTEXT pLogger,
    IN PRTL_PROCESS_MODULE_INFORMATION pModuleInfo,
    IN PSYSTEM_THREAD_INFORMATION pThreadInfo
)
{
    UNICODE_STRING wstrModuleName;
    ANSI_STRING    astrModuleName;
    ULONG          sizeModuleName;
    ULONG          sizeBuffer;
    PCHAR          pAuxInfo;
    PWMI_IMAGELOAD_INFORMATION ImageLoadInfo;

    if ((pLogger == NULL) || (pModuleInfo == NULL) || (pThreadInfo == NULL))
        return;

    RtlInitAnsiString( & astrModuleName, pModuleInfo->FullPathName);

    sizeModuleName = sizeof(WCHAR) * (astrModuleName.Length);
    sizeBuffer     = sizeModuleName + sizeof(WCHAR)
                   + FIELD_OFFSET (WMI_IMAGELOAD_INFORMATION, FileName);

    ImageLoadInfo = (PWMI_IMAGELOAD_INFORMATION)
                     WmipGetTraceBuffer(
                        pLogger,
                        pThreadInfo,
                        EVENT_TRACE_GROUP_PROCESS + EVENT_TRACE_TYPE_LOAD,
                        sizeBuffer);

    if (ImageLoadInfo == NULL) {
        return;
    }

    ImageLoadInfo->ImageBase = pModuleInfo->ImageBase;
    ImageLoadInfo->ImageSize = pModuleInfo->ImageSize;
    ImageLoadInfo->ProcessId = HandleToUlong(ProcessID);

    wstrModuleName.Buffer    = (LPWSTR) &ImageLoadInfo->FileName[0];

    wstrModuleName.MaximumLength = (USHORT) sizeModuleName + sizeof(WCHAR);
    RtlAnsiStringToUnicodeString(& wstrModuleName, & astrModuleName, FALSE);
}

ULONG
WmipSysModuleRunDown(
    IN PWMI_LOGGER_CONTEXT        pLogger,
    IN PSYSTEM_THREAD_INFORMATION pThreadInfo
    )
{
    NTSTATUS   status = STATUS_SUCCESS;
    char     * pLargeBuffer1;
    ULONG      ReturnLength;
    ULONG      CurrentBufferSize;

    ULONG                           i;
    PRTL_PROCESS_MODULES            pModules;
    PRTL_PROCESS_MODULE_INFORMATION pModuleInfo;

    pLargeBuffer1 = WmipMemReserve(MAX_BUFFER_SIZE);

    if (pLargeBuffer1 == NULL)
    {
        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    if (WmipMemCommit(pLargeBuffer1, BUFFER_SIZE) == NULL)
    {
        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    CurrentBufferSize = BUFFER_SIZE;

retry:
    status = NtQuerySystemInformation(
                    SystemModuleInformation,
                    pLargeBuffer1,
                    CurrentBufferSize,
                    &ReturnLength);

    if (status == STATUS_INFO_LENGTH_MISMATCH)
    {
        // Increase buffer size.
        //
        CurrentBufferSize += 8192;

        if (WmipMemCommit(pLargeBuffer1, CurrentBufferSize) == NULL)
        {
            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        goto retry;
    }

    if (!NT_SUCCESS(status))
    {
        goto Cleanup;
    }

    pModules = (PRTL_PROCESS_MODULES) pLargeBuffer1;

    for (i = 0, pModuleInfo = & (pModules->Modules[0]);
         i < pModules->NumberOfModules;
         i ++, pModuleInfo ++)
    {
        WmipLogImageLoadEvent(NULL, pLogger, pModuleInfo, pThreadInfo);
    }

Cleanup:
    if (pLargeBuffer1)
    {
        WmipMemFree(pLargeBuffer1);
    }
    return WmipSetNtStatus(status);
}

ULONG
WmipProcessModuleRunDown(
    IN PWMI_LOGGER_CONTEXT        pLogger,
    IN HANDLE                     ProcessID,
    IN PSYSTEM_THREAD_INFORMATION pThreadInfo)
{
    NTSTATUS               status = STATUS_SUCCESS;
    ULONG                  i;
    PRTL_DEBUG_INFORMATION pLargeBuffer1 = NULL;

    pLargeBuffer1 = RtlCreateQueryDebugBuffer(0, FALSE);
    if (pLargeBuffer1 == NULL)
    {
        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    status = RtlQueryProcessDebugInformation(
                    ProcessID,
                    RTL_QUERY_PROCESS_MODULES,
                    pLargeBuffer1);

    if ( !NT_SUCCESS(status) || (pLargeBuffer1->Modules == NULL) )
    {
        goto Cleanup;
    }

    for (i = 0; i < pLargeBuffer1->Modules->NumberOfModules; i ++)
    {
        WmipLogImageLoadEvent(
                ProcessID,
                pLogger,
                & (pLargeBuffer1->Modules->Modules[i]),
                pThreadInfo);
    }

Cleanup:
    if (pLargeBuffer1)
    {
        RtlDestroyQueryDebugBuffer(pLargeBuffer1);
    }
    return WmipSetNtStatus(status);
}

NTSTATUS
WmipProcessRunDown(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN ULONG StartFlag,
    IN ULONG fEnableFlags
    )
{
    PSYSTEM_PROCESS_INFORMATION  pProcessInfo;
    PSYSTEM_THREAD_INFORMATION   pThreadInfo;
    char* LargeBuffer1;
    NTSTATUS status;
    ULONG ReturnLength;
    ULONG CurrentBufferSize;
    ULONG GroupType;
    ULONG TotalOffset = 0;
    OBJECT_ATTRIBUTES objectAttributes;
    BOOLEAN WasEnabled = TRUE;
    BOOLEAN bExtended = TRUE;

    LargeBuffer1 = WmipMemReserve ( MAX_BUFFER_SIZE );
    if (LargeBuffer1 == NULL) {
        return STATUS_NO_MEMORY;
    }

    if (WmipMemCommit (LargeBuffer1, BUFFER_SIZE) == NULL) {
        return STATUS_NO_MEMORY;
    }

    CurrentBufferSize = BUFFER_SIZE;
    retry:
    if (bExtended) {
        status = NtQuerySystemInformation(
                    SystemExtendedProcessInformation,
                    LargeBuffer1,
                    CurrentBufferSize,
                    &ReturnLength
                    );
    }
    else {
        status = NtQuerySystemInformation(
                    SystemProcessInformation,
                    LargeBuffer1,
                    CurrentBufferSize,
                    &ReturnLength
                    );
    }

    if (status == STATUS_INFO_LENGTH_MISMATCH) {

        //
        // Increase buffer size.
        //

        CurrentBufferSize += 8192;

        if (WmipMemCommit (LargeBuffer1, CurrentBufferSize) == NULL) {
            return STATUS_NO_MEMORY;
        }
        goto retry;
    }

    if (!NT_SUCCESS(status)) {

        if (bExtended) {
            bExtended = FALSE;
            goto retry;
        }

        WmipMemFree(LargeBuffer1);
        return(status);
    }


    //
    // Adjust Privileges to obtain the module information
    //

    if (fEnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD) {
        status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                                    TRUE, FALSE, &WasEnabled);
        if (!NT_SUCCESS(status)) {
            WmipMemFree(LargeBuffer1);
            return  (status);
        }
    }


    TotalOffset = 0;
    pProcessInfo = (SYSTEM_PROCESS_INFORMATION *) LargeBuffer1;
    while (TRUE) {
        ULONG Size;
        ULONG Length = 0;
        ULONG SidLength = 0;
        PUCHAR AuxPtr;
        PULONG_PTR AuxInfo;
        ANSI_STRING s;
        HANDLE Token;
        HANDLE pProcess;
        PCLIENT_ID Cid;
        ULONG TempInfo[128];
        PWMI_PROCESS_INFORMATION WmiProcessInfo;

        Size = FIELD_OFFSET(WMI_PROCESS_INFORMATION, Sid);

        GroupType = EVENT_TRACE_GROUP_PROCESS +
                    ((StartFlag) ? EVENT_TRACE_TYPE_DC_START
                                 : EVENT_TRACE_TYPE_DC_END);

        pThreadInfo = (PSYSTEM_THREAD_INFORMATION) (pProcessInfo+1);
        if (pProcessInfo->NumberOfThreads > 0) {
            Cid = (PCLIENT_ID) &pThreadInfo->ClientId;
        }
        else {
            Cid = NULL;
        }

        // if at termination, rundown thread first before process
        if ( (!StartFlag) &&
             (fEnableFlags & EVENT_TRACE_FLAG_THREAD) ){
            status = WmipThreadRunDown(Logger,
                                       pProcessInfo,
                                       StartFlag,
                                       bExtended);
            if (!NT_SUCCESS(status)) {
                break;
            }

        }

        if (fEnableFlags & EVENT_TRACE_FLAG_PROCESS) {

            if ( pProcessInfo->ImageName.Buffer  &&
                     pProcessInfo->ImageName.Length > 0 ) {
                RtlUnicodeStringToAnsiString(
                                     &s,
                                     (PUNICODE_STRING)&pProcessInfo->ImageName,
                                     TRUE);
                Length = s.Length + 1;
            }
            else {
                Length = 1;
            }

            InitializeObjectAttributes(
                    &objectAttributes, 0, 0, NULL, NULL);
            status = NtOpenProcess(
                                  &pProcess,
                                  PROCESS_QUERY_INFORMATION,
                                  &objectAttributes,
                                  Cid);
            if (NT_SUCCESS(status)) {
                status = NtOpenProcessToken(
                                      pProcess,
                                      TOKEN_READ,
                                      &Token);
                if (NT_SUCCESS(status)) {

                    status = NtQueryInformationToken(
                                             Token,
                                             TokenUser,
                                             TempInfo,
                                             256,
                                             &SidLength);
                    NtClose(Token);
                }
                NtClose(pProcess);
            }
            if ( (!NT_SUCCESS(status)) || SidLength <= 0) {
                TempInfo[0] = 0;
                SidLength = sizeof(ULONG);
            }

            Size += Length + SidLength;
            WmiProcessInfo = (PWMI_PROCESS_INFORMATION)
                              WmipGetTraceBuffer( Logger,
                                                  pThreadInfo,
                                                  GroupType,
                                                  Size);
            if (WmiProcessInfo == NULL) {
                status = STATUS_NO_MEMORY;
                break;
            }
            WmiProcessInfo->ProcessId = HandleToUlong(pProcessInfo->UniqueProcessId);
            WmiProcessInfo->ParentId = HandleToUlong(pProcessInfo->InheritedFromUniqueProcessId);
            WmiProcessInfo->SessionId = pProcessInfo->SessionId;
            WmiProcessInfo->PageDirectoryBase = pProcessInfo->PageDirectoryBase;
            WmiProcessInfo->ExitStatus = 0;

            AuxPtr = (PUCHAR) (&WmiProcessInfo->Sid);

            RtlCopyMemory(AuxPtr, &TempInfo, SidLength);
            AuxPtr += SidLength;

            if ( Length > 1) {
                RtlCopyMemory(AuxPtr, s.Buffer, Length);
                AuxPtr += Length;
                RtlFreeAnsiString(&s);
            }
            *AuxPtr = '\0';
            AuxPtr++;
        }

        // if at beginning, trace threads after process
        if (StartFlag) {

            if (fEnableFlags & EVENT_TRACE_FLAG_THREAD) {
                WmipThreadRunDown(Logger, pProcessInfo, StartFlag, bExtended);
            }

            if (fEnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD) {
                if (pProcessInfo->UniqueProcessId == 0) {
                    WmipSysModuleRunDown(Logger, pThreadInfo);
                }
                else
                    WmipProcessModuleRunDown(
                            Logger,
                            (HANDLE) pProcessInfo->UniqueProcessId,
                            pThreadInfo);
            }
        }
        if (pProcessInfo->NextEntryOffset == 0) {
            break;
        }
        TotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
    }

    //
    // Restore privileges back to what it was before
    //

    if (fEnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD) {
        status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                                    WasEnabled,
                                    FALSE,
                                    &WasEnabled);
    }


    WmipMemFree(LargeBuffer1);

    return status;
}

VOID
WmipInitString(
    IN PVOID Destination,
    IN PVOID Buffer,
    IN ULONG Size
    )
{
    PSTRING s = (PSTRING) Destination;

    s->Buffer = Buffer;
    s->Length = 0;
    if (Buffer != NULL)
        s->MaximumLength = (USHORT) Size;
    else
        s->MaximumLength = 0;
}

VOID
WmipGenericTraceEnable(
    IN ULONG RequestCode,
    IN PVOID Buffer,
    IN OUT PVOID *RequestAddress
    )
{
    PGUIDMAPENTRY pControlGMEntry = *RequestAddress;
    PWNODE_HEADER Wnode = (PWNODE_HEADER) Buffer;
    PTRACE_REG_INFO pTraceRegInfo;
    PTRACE_ENABLE_CONTEXT pContext = (PTRACE_ENABLE_CONTEXT)&Wnode->HistoricalContext;

    *RequestAddress = NULL;

    if (Wnode == NULL || pControlGMEntry == NULL)
        return;

    if (!Wnode->Flags & WNODE_FLAG_TRACED_GUID)
        return;

    pTraceRegInfo  = pControlGMEntry->pControlGuidData;

    WmipAssert(pTraceRegInfo != NULL);


    if (pTraceRegInfo->InProgressEvent != NULL) {
        LARGE_INTEGER Timeout = {(ULONG)(-NOTIFY_RETRY_COUNT * 1000 * 10), -1};
// TODO: Raghu - what if it times out??
        NtWaitForSingleObject(pTraceRegInfo->InProgressEvent, 0, &Timeout);
    }

    *RequestAddress = pTraceRegInfo->NotifyRoutine;

    if (RequestCode == WMI_ENABLE_EVENTS) {
        pControlGMEntry->LoggerContext = Wnode->HistoricalContext;
        if (pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE) {
            pTraceRegInfo->EnabledState = TRUE;
            if (!WmipIsPrivateLoggerOn())
               *RequestAddress = NULL; // Do not notify if the logger is not up.
        }
    }
    else if (RequestCode == WMI_DISABLE_EVENTS) {
        if (pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE) {
            pTraceRegInfo->EnabledState = FALSE;
        }
        pControlGMEntry->LoggerContext = 0;
    }
}

ULONG
WmipAddLogHeaderToLogFile(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN PWMI_REF_CLOCK              RefClock,
    IN     ULONG                   Update
    )
{
    NTSTATUS Status;
    HANDLE LogFile = INVALID_HANDLE_VALUE;
    ULONG BufferSize;
    ULONG MemorySize;
    ULONG TraceKernel;
    SYSTEM_BASIC_INFORMATION SystemInfo;
    WMI_LOGGER_CONTEXT Logger;
    IO_STATUS_BLOCK IoStatus;
    PWMI_BUFFER_HEADER Buffer;
    FILE_POSITION_INFORMATION FileInfo;
    LPWSTR FileName = NULL;
    LPWSTR FileNameBuffer = NULL;
    ULONG HeaderSize;

    struct WMI_LOGFILE_HEADER {
           WMI_BUFFER_HEADER    BufferHeader;
           SYSTEM_TRACE_HEADER  SystemHeader;
           TRACE_LOGFILE_HEADER LogFileHeader;
    };
    struct WMI_LOGFILE_HEADER LoggerBuffer;
    BOOLEAN bLogFileAppend =
                    (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND)
                  ? (TRUE) : (FALSE);

    if (LoggerInfo == NULL)
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    if (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    if ( !(LoggerInfo->Wnode.Flags & WNODE_FLAG_TRACED_GUID) )
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    if ((LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE)  &&
        (LoggerInfo->LogFileName.Length > 0)) {
        FileName = (LPWSTR) WmipAlloc(LoggerInfo->LogFileName.Length + 64);
        if (FileName == NULL) {
            return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
        }
        swprintf(FileName, LoggerInfo->LogFileName.Buffer, 1);
        FileNameBuffer = FileName;
    }
    if (FileName == NULL)
        FileName = (LPWSTR) LoggerInfo->LogFileName.Buffer;

    //
    // If it is Append Mode, we need to open the file and make sure the
    // pick up the BufferSize
    //

    if ( bLogFileAppend ) {

        ULONG ReadSize   = sizeof(WMI_BUFFER_HEADER)
                         + sizeof(SYSTEM_TRACE_HEADER)
                         + sizeof(TRACE_LOGFILE_HEADER);
        ULONG nBytesRead = 0;

        //
        //  Update and Append do not mix. To Append LoggerInfo
        //  must have LogFileName
        //

        if ( (Update) || (LoggerInfo->LogFileName.Length <= 0) ) {
            if (FileNameBuffer != NULL) {
                WmipFree(FileNameBuffer);
            }
            return WmipSetDosError(ERROR_INVALID_PARAMETER);
        }

        LogFile = WmipCreateFileW(FileName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
        if (LogFile == INVALID_HANDLE_VALUE) {
            // cannot OPEN_EXISTING, assume that logfile is not there and
            // create a new one.
            //
            bLogFileAppend = FALSE;
            LoggerInfo->LogFileMode = LoggerInfo->LogFileMode
                                    & (~ (EVENT_TRACE_FILE_MODE_APPEND));
        }

        else {
            // read TRACE_LOGFILE_HEADER structure and update LoggerInfo
            // members.
            //
            Status = WmipReadFile(LogFile,
                              (LPVOID) & LoggerBuffer,
                              ReadSize,
                              & nBytesRead,
                              NULL);
            if (nBytesRead < ReadSize) {
                NtClose(LogFile);
                if (FileNameBuffer != NULL) {
                    WmipFree(FileNameBuffer);
                }
                return WmipSetDosError(ERROR_BAD_PATHNAME);
            }
            if (  LoggerBuffer.LogFileHeader.LogFileMode
                & EVENT_TRACE_FILE_MODE_CIRCULAR) {
                NtClose(LogFile);
                if (FileNameBuffer != NULL) {
                    WmipFree(FileNameBuffer);
                }
                return WmipSetDosError(ERROR_BAD_PATHNAME);
            }
            LoggerInfo->BufferSize      =
                            LoggerBuffer.LogFileHeader.BufferSize / 1024;
            LoggerInfo->BuffersWritten  =
                            LoggerBuffer.LogFileHeader.BuffersWritten;
            LoggerInfo->MaximumFileSize =
                            LoggerBuffer.LogFileHeader.MaximumFileSize;

            // Write back logfile append mode so WmipFinalizeLogFile() correctly
            // update BuffersWritten field
            //
            FileInfo.CurrentByteOffset.QuadPart =
                            LOGFILE_FIELD_OFFSET(EndTime);
            Status = NtSetInformationFile(LogFile,
                                          & IoStatus,
                                          & FileInfo,
                                          sizeof(FILE_POSITION_INFORMATION),
                                          FilePositionInformation);
            if (!NT_SUCCESS(Status)) {
                NtClose(LogFile);
                if (FileNameBuffer != NULL) {
                    WmipFree(FileNameBuffer);
                }
                return WmipSetNtStatus(Status);
            }
            LoggerBuffer.LogFileHeader.EndTime.QuadPart = 0;
            Status = NtWriteFile(LogFile,
                                 NULL,
                                 NULL,
                                 NULL,
                                 & IoStatus,
                                 & LoggerBuffer.LogFileHeader.EndTime,
                                 sizeof(LARGE_INTEGER),
                                 NULL,
                                 NULL);
            if (! NT_SUCCESS(Status)) {
                NtClose(LogFile);
                if (FileNameBuffer != NULL) {
                    WmipFree(FileNameBuffer);
                }
                return WmipSetNtStatus(Status);
            }

            // build checksum structure
            //
            if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
                LoggerInfo->Checksum = NULL;
            }
            else {
                LoggerInfo->Checksum = WmipAlloc(
                        sizeof(WNODE_HEADER) + sizeof(TRACE_LOGFILE_HEADER));
                if (LoggerInfo->Checksum != NULL) {
                    PBYTE ptrChecksum = LoggerInfo->Checksum;
                    RtlCopyMemory(ptrChecksum,
                                  & LoggerBuffer.BufferHeader,
                                  sizeof(WNODE_HEADER));
                    ptrChecksum += sizeof(WNODE_HEADER);
                    RtlCopyMemory(ptrChecksum,
                                  & LoggerBuffer.LogFileHeader,
                                  sizeof(TRACE_LOGFILE_HEADER));
                }
                else {
                    if (FileNameBuffer != NULL) {
                        WmipFree(FileNameBuffer);
                    }
                    return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
        }
    }

    // get the system parameters first

    LoggerInfo->LogFileHandle = NULL;

    Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &SystemInfo, sizeof (SystemInfo), NULL);

    if (!NT_SUCCESS(Status)) {
        if (FileNameBuffer != NULL) {
            WmipFree(FileNameBuffer);
        }
        return WmipSetNtStatus(Status);
    }

    // choose some logical default value for buffer size if user
    // has not provided one

    MemorySize = SystemInfo.NumberOfPhysicalPages * SystemInfo.PageSize
                    / 1024 / 1024;
    if (MemorySize <= 32)
        BufferSize      = SystemInfo.PageSize;
    else if (MemorySize <= 64)
        BufferSize      = SystemInfo.PageSize;
    else if (MemorySize <= 128)
        BufferSize      = SystemInfo.PageSize * 2;
    else if (MemorySize <= 256)
        BufferSize      = SystemInfo.PageSize * 2;
    else if (MemorySize > 512)
        BufferSize      = SystemInfo.PageSize * 2;
    else if (MemorySize <= 256)
        BufferSize      = SystemInfo.PageSize * 2;
    else if (MemorySize > 512)
        BufferSize      = 64 * 1024;        // allocation size
    else       // > 256 && < 512
        BufferSize      = SystemInfo.PageSize * 2;

    if (LoggerInfo->BufferSize > 1024)      // limit to 1Mb
        BufferSize = 1024 * 1024;
    else if (LoggerInfo->BufferSize > 0)
        BufferSize = LoggerInfo->BufferSize * 1024;

    TraceKernel = IsEqualGUID(&LoggerInfo->Wnode.Guid, &SystemTraceControlGuid);
    if (!TraceKernel) {
        GUID guid;
        RtlZeroMemory(&guid, sizeof(GUID));
        if (IsEqualGUID(&LoggerInfo->Wnode.Guid, &guid)) {
            // Generate a Guid for this logger stream
            // This will ensure  buffer filtering at the WMI service
            // based on this GUID.
            UUID uid;
            WmipUuidCreate(&uid);
            LoggerInfo->Wnode.Guid = uid;
        }
    }

    if (!Update) {
        // don't want to update BufferSize information if the request is
        // to update logger session
        //
        LoggerInfo->BufferSize = BufferSize / 1024;
    }

    if (LoggerInfo->LogFileName.Length <= 0)
        return  ERROR_SUCCESS; //goto SendToKm;
    //
    // We assumed the exposed API has checked for either RealTime or FileName
    // is provided

    //
    // open the file for writing synchronously for the logger
    // others may want to read it as well.
    // For logfile append mode, logfile has been opened previously
    //
    if (! bLogFileAppend) {
/*        LogFile = WmipCreateFileW(
                       (PWCHAR) LoggerInfo->LogFileName.Buffer,
                       GENERIC_WRITE,
                       FILE_SHARE_READ,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                       );  */
        LogFile = WmipCreateFile(
                    FileName,
                    FILE_GENERIC_WRITE,
                    FILE_SHARE_READ,
                    FILE_OVERWRITE_IF,
                    0);

        if (LogFile == INVALID_HANDLE_VALUE) {
            if (FileNameBuffer != NULL) {
                WmipFree(FileNameBuffer);
            }
            return WmipSetDosError(ERROR_BAD_PATHNAME);
        }
    }

    LoggerInfo->LogFileHandle = LogFile;


    //
    // If this is an Update call, then we need to pick up the original
    // buffer size for the LogFileHeader.
    //

    if (Update) {
        PWMI_LOGGER_INFORMATION pTempLoggerInfo;
        PWCHAR strLoggerName = NULL;
        PWCHAR strLogFileName = NULL;
        ULONG ErrCode;
        ULONG SizeNeeded = sizeof(WMI_LOGGER_INFORMATION) + MAXSTR * sizeof(WCHAR) * 2;
        SizeNeeded = (SizeNeeded +7) & ~7;
        pTempLoggerInfo = WmipAlloc(SizeNeeded);
        if (pTempLoggerInfo == NULL) {
            return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
        }
        RtlZeroMemory(pTempLoggerInfo, SizeNeeded);
        pTempLoggerInfo->Wnode.BufferSize = SizeNeeded;
        pTempLoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;
        pTempLoggerInfo->Wnode.HistoricalContext = LoggerInfo->Wnode.HistoricalContext;
        pTempLoggerInfo->Wnode.Guid = LoggerInfo->Wnode.Guid;

        if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
            pTempLoggerInfo->LogFileMode |= EVENT_TRACE_PRIVATE_LOGGER_MODE;
        }

        strLoggerName = (PWCHAR) ( ((PUCHAR) pTempLoggerInfo)
                                    + sizeof(WMI_LOGGER_INFORMATION));
        WmipInitString(&pTempLoggerInfo->LoggerName,
                       strLoggerName,
                       MAXSTR * sizeof(WCHAR));
        if (LoggerInfo->LoggerName.Length > 0) {
            RtlCopyUnicodeString( &pTempLoggerInfo->LoggerName,
                                  &LoggerInfo->LoggerName);
        }


        strLogFileName = (PWCHAR) ( ((PUCHAR) pTempLoggerInfo)
                                    + sizeof(WMI_LOGGER_INFORMATION)
                                    + MAXSTR * sizeof(WCHAR) );
        WmipInitString(&pTempLoggerInfo->LogFileName,
                       strLogFileName,
                       MAXSTR * sizeof(WCHAR) );

        //
        // Call QueryLogger
        //
        ErrCode = WmipQueryLogger(pTempLoggerInfo, FALSE);

        BufferSize = pTempLoggerInfo->BufferSize * 1024;
        WmipFree(pTempLoggerInfo);

        if (ErrCode != ERROR_SUCCESS) {
            return ErrCode;
        }
    }
    //
    // Before Allocating the Buffer for Logfile Header make
    // sure the buffer size is atleast as large as the LogFileHeader
    //

    HeaderSize =  sizeof(LoggerBuffer)
                        + LoggerInfo->LoggerName.Length + sizeof(WCHAR)
                        + LoggerInfo->LogFileName.Length + sizeof(WCHAR);

    if (HeaderSize > BufferSize) {
        //
        //  Round it to the nearest power of 2 and check for max size 1 MB
        //
        double dTemp = log (HeaderSize / 1024.0) / log (2.0);
        ULONG lTemp = (ULONG) (dTemp + 0.99);
        HeaderSize = (1 << lTemp);
        if (HeaderSize > 1024) {
            NtClose(LogFile);
            if (FileNameBuffer != NULL) {
                WmipFree(FileNameBuffer);
            }
            return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
        }
        LoggerInfo->BufferSize = HeaderSize;
        BufferSize = HeaderSize * 1024;
    }



    // allocate a buffer to write logger header and process/thread
    // rundown information
    //
    Logger.LogFileHandle   = LogFile;
    Logger.BufferSize      = BufferSize;
    Logger.TimerResolution = SystemInfo.TimerResolution;
    Logger.BufferSpace          = WmipAlloc(BufferSize);
    if (Logger.BufferSpace == NULL) {
        NtClose(LogFile);
        if (FileNameBuffer != NULL) {
            WmipFree(FileNameBuffer);
        }
        return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
    }
    if (LoggerInfo->Wnode.ClientContext != EVENT_TRACE_CLOCK_SYSTEMTIME) {
        LoggerInfo->Wnode.ClientContext = EVENT_TRACE_CLOCK_PERFCOUNTER;
    }
    Logger.UsePerfClock = LoggerInfo->Wnode.ClientContext;

    // initialize buffer first
    RtlZeroMemory(Logger.BufferSpace, BufferSize);
    Buffer         = (PWMI_BUFFER_HEADER) Logger.BufferSpace;
    Buffer->Offset = sizeof(WMI_BUFFER_HEADER);
    if (TraceKernel) {
        Buffer->Wnode.Guid   = SystemTraceControlGuid;
    }
    else {
        Buffer->Wnode.Guid   = LoggerInfo->Wnode.Guid;
    }
    Buffer->Wnode.BufferSize = BufferSize;
    Buffer->ClientContext.Alignment = (UCHAR)WmiTraceAlignment;
    Buffer->Wnode.Flags      = WNODE_FLAG_TRACED_GUID;

    if (bLogFileAppend) {
        Logger.BuffersWritten  = LoggerBuffer.LogFileHeader.BuffersWritten;
        WmipSetFilePointer(LogFile, 0, NULL, FILE_END);
    }
    else {
        PTRACE_LOGFILE_HEADER LogfileHeader;
        OSVERSIONINFO sVersionInfo;

        Logger.BuffersWritten  = 0;
        HeaderSize =  sizeof(TRACE_LOGFILE_HEADER)
                        + LoggerInfo->LoggerName.Length + sizeof(WCHAR)
                        + LoggerInfo->LogFileName.Length + sizeof(WCHAR);



        LogfileHeader = (PTRACE_LOGFILE_HEADER)
                        WmipGetTraceBuffer(
                            &Logger,
                            NULL,
                            EVENT_TRACE_GROUP_HEADER + EVENT_TRACE_TYPE_INFO,
                            HeaderSize
                            );
        if (LogfileHeader == NULL) {
            NtClose(LogFile);
            WmipFree(Logger.BufferSpace);
            if (FileNameBuffer != NULL) {
                WmipFree(FileNameBuffer);
            }
            return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
        }

        if (Logger.UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
            LARGE_INTEGER CurrentTime;
            LARGE_INTEGER Frequency;
            Status = NtQueryPerformanceCounter(&CurrentTime, &Frequency);
            LogfileHeader->PerfFreq = Frequency;

            LogfileHeader->ReservedFlags = EVENT_TRACE_CLOCK_PERFCOUNTER;
        }

        //
        // Start and End Times are wall clock time
        //
        if (RefClock != NULL) {
            PSYSTEM_TRACE_HEADER Header;
            LogfileHeader->StartTime = RefClock->StartTime;
            Header = (PSYSTEM_TRACE_HEADER) ( (char *) LogfileHeader - sizeof(SYSTEM_TRACE_HEADER) );
            Header->SystemTime = RefClock->StartPerfClock;
        }
        else {
            LogfileHeader->StartTime.QuadPart = WmipGetSystemTime();
        }

        RtlZeroMemory(&sVersionInfo, sizeof(OSVERSIONINFO));
        sVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        WmipGetVersionExA(&sVersionInfo);

        LogfileHeader->BufferSize = BufferSize;
        LogfileHeader->VersionDetail.MajorVersion =
                                         (UCHAR)sVersionInfo.dwMajorVersion;
        LogfileHeader->VersionDetail.MinorVersion =
                                         (UCHAR)sVersionInfo.dwMinorVersion;
        LogfileHeader->VersionDetail.SubVersion = TRACE_VERSION_MAJOR;
        LogfileHeader->VersionDetail.SubMinorVersion = TRACE_VERSION_MINOR;
        LogfileHeader->ProviderVersion = sVersionInfo.dwBuildNumber;
        LogfileHeader->StartBuffers = 1;
        LogfileHeader->LogFileMode
                = LoggerInfo->LogFileMode & (~(EVENT_TRACE_REAL_TIME_MODE));
        LogfileHeader->NumberOfProcessors = SystemInfo.NumberOfProcessors;
        if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
        {
            if ( (LoggerInfo->NumberOfProcessors > 0) &&
                 (LoggerInfo->LogFileMode & EVENT_TRACE_RELOG_MODE) ) {
                LogfileHeader->NumberOfProcessors = LoggerInfo->NumberOfProcessors;
            }
            else {
                LoggerInfo->NumberOfProcessors = SystemInfo.NumberOfProcessors;
            }
        }

        LogfileHeader->MaximumFileSize = LoggerInfo->MaximumFileSize;

        LogfileHeader->TimerResolution = SystemInfo.TimerResolution;
        LogfileHeader->LoggerName = (PWCHAR) ( (PUCHAR) LogfileHeader
                                    + sizeof(TRACE_LOGFILE_HEADER) );
        LogfileHeader->LogFileName = (PWCHAR) ((PUCHAR)LogfileHeader->LoggerName
                                    + LoggerInfo->LoggerName.Length
                                    + sizeof (WCHAR));
        RtlCopyMemory(LogfileHeader->LoggerName,
                    LoggerInfo->LoggerName.Buffer,
                    LoggerInfo->LoggerName.Length + sizeof(WCHAR));
        RtlCopyMemory(LogfileHeader->LogFileName,
                    LoggerInfo->LogFileName.Buffer,
                    LoggerInfo->LogFileName.Length + sizeof(WCHAR));
        WmipGetTimeZoneInformation(&LogfileHeader->TimeZone);
        LogfileHeader->PointerSize = sizeof(PVOID);

        if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
            LoggerInfo->Checksum = NULL;
        }
        else {
            LoggerInfo->Checksum = WmipAlloc(
                            sizeof(WNODE_HEADER)
                          + sizeof(TRACE_LOGFILE_HEADER));
            if (LoggerInfo->Checksum != NULL) {
                PBYTE ptrChecksum = LoggerInfo->Checksum;
                RtlCopyMemory(ptrChecksum, Buffer, sizeof(WNODE_HEADER));
                ptrChecksum += sizeof(WNODE_HEADER);
                RtlCopyMemory(
                    ptrChecksum, LogfileHeader, sizeof(TRACE_LOGFILE_HEADER));
            }
            else {
                NtClose(LogFile);
                WmipFree(Logger.BufferSpace);
                if (FileNameBuffer != NULL) {
                    WmipFree(FileNameBuffer);
                }
                return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
    }

    // Dump the GuidMaps to File at the Start
    //
    if (!Update) {
        if (TraceKernel) {
            ULONG EnableFlags = LoggerInfo->EnableFlags;

            if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
                PTRACE_ENABLE_FLAG_EXTENSION tFlagExt;

                tFlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                           &LoggerInfo->EnableFlags;
                EnableFlags = *(PULONG)((PCHAR)LoggerInfo + tFlagExt->Offset);
            }

            WmipDumpHardwareConfig(&Logger);


            WmipProcessRunDown( &Logger, TRUE, EnableFlags );
        }
        else {
            WmipDumpGuidMaps(&Logger, NULL, FALSE);
        }
    }

    Buffer = (PWMI_BUFFER_HEADER) Logger.BufferSpace;
    // flush the last buffer
    if (Buffer->Offset < Logger.BufferSize) {
        RtlFillMemory(
                (char *) Buffer + Buffer->Offset,
                Logger.BufferSize - Buffer->Offset,
                0xFF);
    }
    Status = NtWriteFile(
            LogFile,
            NULL,
            NULL,
            NULL,
            &IoStatus,
            Logger.BufferSpace,
            BufferSize,
            NULL,
            NULL);

    Logger.BuffersWritten++;

    if ((LoggerInfo->LogFileMode == EVENT_TRACE_FILE_MODE_CIRCULAR) ) {
        //
        // We need to write the number of StartBuffers in the
        // Circular Logfile header to process it properly.

        FileInfo.CurrentByteOffset.QuadPart =
                            LOGFILE_FIELD_OFFSET(StartBuffers);

        Status = NtSetInformationFile(
                             LogFile,
                             &IoStatus,
                             &FileInfo,
                             sizeof(FILE_POSITION_INFORMATION),
                             FilePositionInformation
                             );
        if (!NT_SUCCESS(Status)) {
            NtClose(LogFile);
            if (FileNameBuffer != NULL) {
                WmipFree(FileNameBuffer);
            }
            return WmipSetNtStatus(Status);
        }

        Status = NtWriteFile(
                            LogFile,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatus,
                            &Logger.BuffersWritten,
                            sizeof(ULONG),
                            NULL,
                            NULL
                            );
        if (NT_SUCCESS(Status)) {
            PTRACE_LOGFILE_HEADER pLogFileHeader;

            NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);

            // update StartBuffers in Checksum
            //
            pLogFileHeader = (PTRACE_LOGFILE_HEADER)
                     (((PUCHAR) LoggerInfo->Checksum) + sizeof(WNODE_HEADER));
            pLogFileHeader->StartBuffers = Logger.BuffersWritten;
        }
    }

    //
    // As a last thing update the Number of BuffersWritten so far
    // in the header and also update the checksum. This is to prevent
    // Logger failing Update calls under high load.
    //

    FileInfo.CurrentByteOffset.QuadPart =
                    LOGFILE_FIELD_OFFSET(BuffersWritten);

    Status = NtSetInformationFile(
                             LogFile,
                             &IoStatus,
                             &FileInfo,
                             sizeof(FILE_POSITION_INFORMATION),
                             FilePositionInformation
                             );
    if (!NT_SUCCESS(Status)) {
        NtClose(LogFile);
        return WmipSetNtStatus(Status);
    }

    Status = NtWriteFile(
                        LogFile,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        &Logger.BuffersWritten,
                        sizeof(ULONG),
                        NULL,
                        NULL
                        );
    if (NT_SUCCESS(Status)) {
        PTRACE_LOGFILE_HEADER pLogFileHeader;

        NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);

        // update StartBuffers in Checksum
        //
        if ( !(LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) ) {
            pLogFileHeader = (PTRACE_LOGFILE_HEADER)
                     (((PUCHAR) LoggerInfo->Checksum) + sizeof(WNODE_HEADER));
            pLogFileHeader->BuffersWritten = Logger.BuffersWritten;
        }
    }

    NtClose(LogFile);

    LogFile = WmipCreateFileW(
                 FileName,
                 GENERIC_WRITE,
                 FILE_SHARE_READ,
                 NULL,
                 OPEN_EXISTING,
                 FILE_FLAG_NO_BUFFERING,
                 NULL
                 );
/*    LogFile = WmipCreateFile(
                FileName,
                FILE_GENERIC_WRITE,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_NO_INTERMEDIATE_BUFFERING);
*/
    if (FileNameBuffer != NULL) {
        WmipFree(FileNameBuffer);
    }

    if (LogFile == INVALID_HANDLE_VALUE) {
        return WmipGetLastError();
    }
    LoggerInfo->LogFileHandle = LogFile;
    LoggerInfo->BuffersWritten = Logger.BuffersWritten;
    WmipFree(Logger.BufferSpace);
    return ERROR_SUCCESS;
}

ULONG
WmipDumpGuidMaps(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PLIST_ENTRY GuidMapListHeadPtr,
    IN ULONG RealTimeFlag
    )
/*++

Routine Description:

    This routine communicates with the WMI Service and obtains all the
    Trace Guids that are currently registered and those guids that unregistered
    in the middle of a Logging session.
    The GuidMaps are dumped to the logfile or added to the current GuidMapList
    for real time processing.

Arguments:

    Logger          Logger Context.
    RealTimeFlag    Flag to denote real time processing.

Return Value:

    Returns the number of Trace GUIDS obtained from the WMI service.

--*/
{
#if 0	
    ULONG Status;
    PTRACEGUIDMAP GuidMapList = NULL;
    ULONG MaxGuidCount;
    ULONG TotalGuidCount;
    ULONG ReturnGuidCount;
    ULONG BusyRetries;

    // Ensure that wmi service is around and willing to send us notifications
    Status = WmipEnableNotifications();
    if (Status != ERROR_SUCCESS)
    {
        WmipSetLastError(Status);
        return(0);
    }
    MaxGuidCount = 10;
retry:
    TotalGuidCount = 0;
    ReturnGuidCount = 0;
    GuidMapList = WmipAlloc(MaxGuidCount * sizeof(TRACEGUIDMAP));
    if (GuidMapList == NULL)
    {
        WmipSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return (0);
    }
    RtlZeroMemory(GuidMapList, MaxGuidCount * sizeof(TRACEGUIDMAP));

    BusyRetries = 0;
    do
    {
       try
       {
#if 0	
           Status = EnumerateTraceGuidMap(WmipDcCtxHandle,
                                      MaxGuidCount,
                                      &TotalGuidCount,
                                      &ReturnGuidCount,
                                      GuidMapList);
#endif			
       } except(EXCEPTION_EXECUTE_HANDLER) {
           Status = GetExceptionCode();
           if (Status == STATUS_ACCESS_VIOLATION)
           {
                Status = ERROR_NOACCESS;
                WmipFree(GuidMapList);
                WmipSetLastError(Status);
                return (0);
           }
       }
        if (Status == RPC_S_SERVER_TOO_BUSY)
        {
            WmipDebugPrint(("WMI: EnumerateTraceGuidMap too busy for the %d time\n",
                                      BusyRetries));
            WmipSleep(RPC_BUSY_WAIT_TIMER);
            BusyRetries++;
        }
    } while ((Status == RPC_S_SERVER_TOO_BUSY) &&
             (BusyRetries < RPC_BUSY_WAIT_RETRIES));

    //
    // If RPC was successful, then write out these events to logfile.
    //

    if (Status == ERROR_MORE_DATA) {
        MaxGuidCount = TotalGuidCount;
        WmipFree(GuidMapList);
        goto retry;
    }
    else if (Status == ERROR_SUCCESS) {
       ULONG GroupType;
       ULONG i;
       ULONG Size;
       PULONG AuxInfo;
       PTRACEGUIDMAP pTraceGuidMap = GuidMapList;


       GroupType = EVENT_TRACE_GROUP_HEADER + EVENT_TRACE_TYPE_GUIDMAP;
       Size = sizeof(TRACEGUIDMAP);

       for (i=0; i < ReturnGuidCount; i++) {
            if (RealTimeFlag) {
                WmipAddGuidHandleToGuidMapList(GuidMapListHeadPtr, pTraceGuidMap->GuidMapHandle,
                                               &pTraceGuidMap->Guid);
            }
            else {
                AuxInfo = (PULONG) WmipGetTraceBuffer(
                               Logger,
                               NULL,
                               GroupType,
                               Size);
               if (AuxInfo == NULL) {
                    WmipFree(GuidMapList);
                    WmipSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                   return(0);
               }
               RtlCopyMemory(AuxInfo, pTraceGuidMap, sizeof(TRACEGUIDMAP));
            }
           pTraceGuidMap++;
       }
    }
    WmipFree(GuidMapList);
    WmipSetLastError(Status);
    return(ReturnGuidCount);
#else
    WmipSetLastError(ERROR_INVALID_PARAMETER);
    return(0);
#endif
}

ULONG
WmiUnregisterGuids(
    IN WMIHANDLE WMIHandle,
    IN LPGUID    Guid,
    OUT ULONG64  *LoggerContext
)
/*++

Routine Description:

    This routine informs WMI that a data provider is no longer available
    to receive requests for the guids previously registered. WMI will
    unregister any guids registered with this handle.

Arguments:

    WMIHandle - Handle returned from WMIRegisterGuids that represents
                the guids whose data is not longer available.
    Guid -      Pointer to the control Guid which is unregistering

    LoggerContext - Returned value of the LoggerContext

Return Value:

    Returns status code

--*/
{
    ULONG Status;
    ULONG ReturnSize;
    WMIUNREGGUIDS UnregGuids;

    UnregGuids.RequestHandle.Handle = WMIHandle;
    UnregGuids.Guid = *Guid;

    Status = WmipSendWmiKMRequest(NULL,
                                         IOCTL_WMI_UNREGISTER_GUIDS,
                                         &UnregGuids,
                                         sizeof(WMIUNREGGUIDS),
                                         &UnregGuids,
                                         sizeof(WMIUNREGGUIDS),
                                         &ReturnSize,
                                         NULL);
    								


    WmipSetLastError(Status);
    return(Status);
}

ULONG
WmipFlushLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This is the actual routine to communicate with the kernel to start
    the logger. All the required parameters must be in LoggerInfo.

Arguments:

    LoggerInfo      The actual parameters to be passed to and return from
                    kernel.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG Status;
    ULONG BufferSize;
    PTRACE_ENABLE_CONTEXT pContext;

    if (   (LoggerInfo == NULL)
        || (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        || (! (LoggerInfo->Wnode.Flags & WNODE_FLAG_TRACED_GUID))) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }

    pContext = (PTRACE_ENABLE_CONTEXT) & LoggerInfo->Wnode.HistoricalContext;
    if (   (pContext->InternalFlag != 0)
        && (pContext->InternalFlag != EVENT_TRACE_INTERNAL_FLAG_PRIVATE)) {
        // Currently only one possible InternalFlag value. This will filter
        // out some bogus LoggerHandle
        //
        return WmipSetDosError(ERROR_INVALID_HANDLE);
    }

    if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
        Status = WmipSendUmLogRequest(
                    WmiFlushLoggerCode,
                    LoggerInfo
                    );
    }
    else {

        Status = WmipSendWmiKMRequest(       // actually start the logger here
                    NULL,
                    IOCTL_WMI_FLUSH_LOGGER,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    &BufferSize,
                    NULL
                    );
    }

    return WmipSetDosError(Status);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\ntdll\main.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    main.c

Abstract:
    
    WMI  dll main file

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#define INITGUID
#include "wmiump.h"
#include "evntrace.h"
#include <rpc.h>
#include "trcapi.h"

/*
Added by Digvijay
start
*/

#if DBG
BOOLEAN WmipLoggingEnabled = TRUE;
#endif

extern
RTL_CRITICAL_SECTION UMLogCritSect;

BOOLEAN EtwLocksInitialized = FALSE;

/*
Added by Digvijay
end
*/

#ifndef MEMPHIS
RTL_CRITICAL_SECTION PMCritSect;
PVOID WmipProcessHeap = NULL;
HANDLE WmipDeviceHandle;
#else
HANDLE PMMutex;
#endif

extern HANDLE WmipWin32Event;

HMODULE WmipDllHandle;

void WmipDeinitializeDll(
    void
    );

void WmipDeinitializeAccess(
    PTCHAR *RpcStringBinding
    );

ULONG WmipInitializeDll(
    void
    );

HINSTANCE DllInstanceHandle;

extern HANDLE WmipKMHandle;
/*
BOOLEAN
WmiDllInitialize(
    IN PVOID DllBase,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This function implements Win32 base dll initialization.

Arguments:

    DllHandle - 

    Reason  - attach\detach

    Context - Not Used

Return Value:

    STATUS_SUCCESS

--*//*
{
    ULONG Status = ERROR_SUCCESS;
    ULONG Foo;

    DllInstanceHandle = (HINSTANCE)DllBase;
    
    if (Reason == DLL_PROCESS_ATTACH)       
    {
#if DBG
        Foo = WmipLoggingEnabled ? 1 : 0;
        WmipGetRegistryValue(LoggingEnableValueText,
                             &Foo);
        WmipLoggingEnabled = (Foo == 0) ? FALSE : TRUE;
#endif
        Status = WmipInitializeDll();
    
    } else if (Reason == DLL_PROCESS_DETACH) {

#ifndef MEMPHIS
        // Flush out UM buffers to logfile
        //
#if 0       
        WmipFlushUmLoggerBuffer();
#endif
#endif
        //
        // DOn't need to clean up if process is exiting
        if (Context == NULL)
        {            
            WmipDeinitializeDll();
        }

        if (WmipKMHandle != (HANDLE)NULL)
        {
            WmipCloseHandle(WmipKMHandle);
        }
    }
    
    return(Status == ERROR_SUCCESS);
}*/


ULONG WmipInitializeDll(
    void
    )
/*+++

Routine Description:

Arguments:

Return Value:

---*/
{

#ifdef MEMPHIS        
    PMMutex = CreateMutex(NULL, FALSE, NULL);
    if (PMMutex == NULL)
    {
        return(WmipGetLastError());
    }
#else
    ULONG Status;

    Status = RtlInitializeCriticalSection(&PMCritSect);
    
    if (! NT_SUCCESS(Status))
    {
        return(RtlNtStatusToDosError(Status));
    }

    Status = RtlInitializeCriticalSection(&UMLogCritSect);

    if (! NT_SUCCESS(Status))
    {
        RtlDeleteCriticalSection(&PMCritSect); // Delete PMCritSec.
        return(RtlNtStatusToDosError(Status));
    }

    EtwLocksInitialized = TRUE;
    
#endif

    return(ERROR_SUCCESS);
}

#ifndef MEMPHIS
VOID
WmipCreateHeap(
    void
    )
{
    WmipEnterPMCritSection();
    
    if (WmipProcessHeap == NULL)
    {
        WmipProcessHeap = RtlCreateHeap(HEAP_GROWABLE,
                                        NULL,
                                        DLLRESERVEDHEAPSIZE,
                                        DLLCOMMITHEAPSIZE,
                                        NULL,
                                        NULL);
                
        if (WmipProcessHeap == NULL)
        {
            WmipDebugPrint(("WMI: Cannot create WmipProcessHeap, using process default\n"));
            WmipProcessHeap = RtlProcessHeap();
        }
    }
    
    WmipLeavePMCritSection();    
}
#endif

void WmipDeinitializeDll(
    void
    )
/*+++

Routine Description:

Arguments:

Return Value:

---*/
{
#ifdef MEMPHIS
    WmipCloseHandle(PMMutex);
#else
    if(EtwLocksInitialized){
        RtlDeleteCriticalSection(&PMCritSect);   
        RtlDeleteCriticalSection(&UMLogCritSect);
    }

    if ((WmipProcessHeap != NULL) &&
        (WmipProcessHeap != RtlProcessHeap()))

    {
        RtlDestroyHeap(WmipProcessHeap);
    }
    if (WmipDeviceHandle != NULL) 
    {
        WmipCloseHandle(WmipDeviceHandle);
    }
#endif
    if (WmipWin32Event != NULL)
    {
        WmipCloseHandle(WmipWin32Event);
    }   
}

/*
#if DBG

void WmipGetRegistryValue(
    TCHAR *ValueName,
    PULONG Value
    )
{
    HKEY Key;
    DWORD Type;
    DWORD ValueSize;
    ULONG Status;

    Status = RegOpenKey(HKEY_LOCAL_MACHINE,
                        WmiRegKeyText,
                        &Key);

    if (Status == ERROR_SUCCESS)
    {
        ValueSize = sizeof(ULONG);
        Status = RegQueryValueEx(Key,
                                 ValueName,
                                 NULL,
                                 &Type,
                                 (LPBYTE)Value,
                                 &ValueSize);

        if ((Status == ERROR_SUCCESS) &&
            (Type == REG_DWORD))
        {
            WmipDebugPrint(("WMI: %ws from registry is %d\n",
                            ValueName,
                            *Value));
        }
        RegCloseKey(Key);
    }   
}

#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\ntdll\ntdlltrc.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    HeapEventTracer.c

Abstract:

    This file implements Event Tracing for Heap functions .

--*/

#include <nt.h>
#include <ntrtl.h>          // for ntutrl.h
#include <nturtl.h>         // for RTL_CRITICAL_SECTION in winbase.h/wtypes.h
#include "wmiump.h"
#include "evntrace.h"
#include "ntdlltrc.h"
#include "trcapi.h"
#include "traceump.h"
#include "tracelib.h"


LONG NtdllTraceInitializeLock = 0;
LONG NtdllLoggerLock = 0;
PNTDLL_EVENT_HANDLES NtdllTraceHandles = NULL;
BOOL bNtdllTrace = FALSE;           // Flag determines that Tracing is enabled or disabled for this process.
ULONG GlobalCounter = 0;            // Used to determine that we have stale information about logger
PWMI_LOGGER_INFORMATION gLoggerInfo = NULL;
LONG TraceLevel = 0;

extern LONG WmipLoggerCount;
extern ULONG WmiTraceAlignment;
extern BOOLEAN LdrpInLdrInit;
extern PWMI_LOGGER_CONTEXT WmipLoggerContext;
extern BOOLEAN EtwLocksInitialized;

#define MAXSTR                  1024
#define BUFFER_STATE_FULL       2 
#define WmipIsLoggerOn() \
        (WmipLoggerContext != NULL) && \
        (WmipLoggerContext != (PWMI_LOGGER_CONTEXT) &WmipLoggerContext)

#define WmipLockLogger() InterlockedIncrement(&WmipLoggerCount)
#define WmipUnlockLogger() InterlockedDecrement(&WmipLoggerCount)

NTSTATUS
InitializeWmiHandles(PPNTDLL_EVENT_HANDLES ppWmiHandle)
/*++

Routine Description:

    This function does groundwork to start Tracing for Heap and Critcal Section.
	With the help of global lock NtdllTraceInitializeLock the function
	allocates memory for NtdllTraceHandles and initializes the various variables needed
	for heap and critical tracing.

Arguments

  ppWmiHandle : OUT Pointer is set to value of NtdllTraceHandles


Return Value:

     STATUS_SUCCESS
     STATUS_UNSUCCESSFUL

--*/
{

    NTSTATUS st = STATUS_UNSUCCESSFUL;
    PNTDLL_EVENT_HANDLES pWmiHandle = NULL;

    __try  {

        WmipInitProcessHeap();

        pWmiHandle = (PNTDLL_EVENT_HANDLES)WmipAlloc(sizeof(NTDLL_EVENT_HANDLES));

        if(pWmiHandle){

            pWmiHandle->hRegistrationHandle		= (TRACEHANDLE)INVALID_HANDLE_VALUE;
            pWmiHandle->pThreadListHead			= NULL;

            // 
            // Allocate TLS
            //

            pWmiHandle->dwTlsIndex = WmipTlsAlloc();

            if(pWmiHandle->dwTlsIndex == FAILED_TLSINDEX){

                WmipFree(pWmiHandle);

            }  else {

                RtlInitializeCriticalSection(&pWmiHandle->CriticalSection);
                *ppWmiHandle = pWmiHandle;
                st =  STATUS_SUCCESS;

            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        if(pWmiHandle !=NULL ) {
            WmipFree(pWmiHandle);
            pWmiHandle = NULL;
        }
    }

    return st;
}

void
CleanOnThreadExit()
/*++

Routine Description:

    This function cleans up the Thread buffer and takes its node out of the Link list 
	which contains information of all threads involved in tracing.

--*/
{

    PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
    PWMI_BUFFER_HEADER pWmiBuffer;

    if(NtdllTraceHandles != NULL ){

        pThreadLocalData = (PTHREAD_LOCAL_DATA)WmipTlsGetValue(NtdllTraceHandles->dwTlsIndex);

        //
        // Remove the node from the Link List
        //

        if(pThreadLocalData !=  NULL ){

            RtlEnterCriticalSection(&NtdllTraceHandles->CriticalSection);

            __try {

                if(pThreadLocalData->BLink == NULL ){

                    NtdllTraceHandles->pThreadListHead = pThreadLocalData->FLink;

                    if(NtdllTraceHandles->pThreadListHead){

                        NtdllTraceHandles->pThreadListHead->BLink = NULL;

                    }

                } else {

                    pThreadLocalData->BLink->FLink = pThreadLocalData->FLink;

                    if(pThreadLocalData->FLink != NULL ){

                        pThreadLocalData->FLink->BLink = pThreadLocalData->BLink;

                    }
                }

                pWmiBuffer = pThreadLocalData->pBuffer;

                if(pWmiBuffer){

                    WmipReleaseFullBuffer(pWmiBuffer);

                }

                pThreadLocalData->pBuffer = NULL;
                pThreadLocalData->ReferenceCount = 0;

                WmipFree(pThreadLocalData);
                WmipTlsSetValue(NtdllTraceHandles->dwTlsIndex, NULL);

            } __finally {

                RtlLeaveCriticalSection(&NtdllTraceHandles->CriticalSection);

            }
        }
    }
}

void
CleanUpAllThreadBuffers(BOOLEAN Release)
/*++

Routine Description:

    This function cleans up the All Thread buffers and sets them to NULL. This
	function is called when the tracing is disabled for the process.

--*/
{

    PTHREAD_LOCAL_DATA	pListHead;
    BOOL bAllClear = FALSE;
    PWMI_BUFFER_HEADER pWmiBuffer;
    int retry = 0;

    RtlEnterCriticalSection(&NtdllTraceHandles->CriticalSection);

    __try {

        while(bAllClear != TRUE && retry <= 10){

            bAllClear = TRUE;
            pListHead = NtdllTraceHandles->pThreadListHead;

            while(pListHead != NULL ){

                if(Release){

                    pWmiBuffer = pListHead->pBuffer;

                    if(pWmiBuffer){

                        if(InterlockedIncrement(&(pListHead->ReferenceCount)) == 1){

                            WmipReleaseFullBuffer(pWmiBuffer);
                            pListHead->pBuffer = NULL;
                            InterlockedDecrement(&(pListHead->ReferenceCount));

                        } else {

                            InterlockedDecrement(&(pListHead->ReferenceCount));
                            bAllClear = FALSE;
                        }
                    }
                } else {
                    pListHead->pBuffer = NULL;
                    pListHead->ReferenceCount = 0;
                }

                pListHead = pListHead->FLink;
            }

            retry++;

            if(!bAllClear){

                WmipSleep(250);
            }
        }

    } __finally {

        RtlLeaveCriticalSection(&NtdllTraceHandles->CriticalSection);

    }
}

void 
ShutDownWmiHandles()
/*++

Routine Description:

    This function is called when the process is exiting. This cleans all the thread 
	buffers and releases the memory allocated for NtdllTraceHandless.

--*/

{

    if(NtdllTraceHandles == NULL) return;

    bNtdllTrace  = FALSE;

    RtlEnterCriticalSection(&NtdllTraceHandles->CriticalSection);

    __try {

        if(NtdllTraceHandles->hRegistrationHandle != (TRACEHANDLE)INVALID_HANDLE_VALUE){

            UnregisterTraceGuids(NtdllTraceHandles->hRegistrationHandle);

        }

        if(NtdllTraceHandles->pThreadListHead != NULL){

            PTHREAD_LOCAL_DATA	pListHead, pNextListHead;

            pListHead = NtdllTraceHandles->pThreadListHead;

            while(pListHead != NULL ){

                if(pListHead->pBuffer != NULL){

                    WmipReleaseFullBuffer(pListHead->pBuffer);
                    pListHead->pBuffer = NULL;
                    InterlockedDecrement(&(pListHead->ReferenceCount));

                }

                pNextListHead = pListHead->FLink;
                WmipFree(pListHead);
                pListHead = pNextListHead;
            }
        }

        WmipTlsFree(NtdllTraceHandles->dwTlsIndex);

    } __finally {

        RtlLeaveCriticalSection(&NtdllTraceHandles->CriticalSection);

    }

    RtlDeleteCriticalSection(&NtdllTraceHandles->CriticalSection);

    WmipFree(NtdllTraceHandles);
    NtdllTraceHandles = NULL;
}

NTSTATUS
GetLoggerInfo(PWMI_LOGGER_INFORMATION LoggerInfo)
{

    ULONG st = STATUS_UNSUCCESSFUL;
    WMINTDLLLOGGERINFO NtdllLoggerInfo;
    ULONG BufferSize;

    if(LoggerInfo == NULL) return st;

    NtdllLoggerInfo.LoggerInfo = LoggerInfo;
    NtdllLoggerInfo.LoggerInfo->Wnode.Guid = NtdllTraceGuid;
    NtdllLoggerInfo.IsGet = TRUE;

    st =  WmipSendWmiKMRequest(
                                NULL,
                                IOCTL_WMI_NTDLL_LOGGERINFO,
                                &NtdllLoggerInfo,
                                sizeof(WMINTDLLLOGGERINFO),
                                &NtdllLoggerInfo,
                                sizeof(WMINTDLLLOGGERINFO),
                                &BufferSize,
                                NULL
                                );

    return st;

}

BOOLEAN
GetPidInfo(ULONG CheckPid, PWMI_LOGGER_INFORMATION LoggerInfo)
{

    NTSTATUS st;
    BOOLEAN Found = FALSE;
    PTRACE_ENABLE_FLAG_EXTENSION FlagExt = NULL;

    st = GetLoggerInfo(LoggerInfo);

    if(NT_SUCCESS(st)){

        PULONG PidArray = NULL;
        ULONG count;

        FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &LoggerInfo->EnableFlags;
        PidArray = (PULONG)(FlagExt->Offset + (PCHAR)LoggerInfo);

        for(count = 0; count <  FlagExt->Length; count++){

            if(CheckPid == PidArray[count]){
                Found = TRUE;
                break;
            }
        }
    }

    return Found;
}

ULONG 
WINAPI 
NtdllCtrlCallback(
    WMIDPREQUESTCODE RequestCode,
    PVOID Context,
    ULONG *InOutBufferSize, 
    PVOID Buffer
    )
/*++

Routine Description:

	This is WMI control callback function used at the time of registration.

--*/
{
    ULONG ret;

    ret = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:  //Enable Provider.
        {
            if(bNtdllTrace == TRUE) break;

            if(WmipIsLoggerOn()){

                bNtdllTrace = TRUE;
                break;

            }

            if(InterlockedIncrement(&NtdllLoggerLock) == 1){

                if( bNtdllTrace == FALSE ){

                    BOOLEAN PidEntry = FALSE;
                    PWMI_LOGGER_INFORMATION LoggerInfo = NULL;

                    ULONG sizeNeeded = sizeof(WMI_LOGGER_INFORMATION)  
                    + (4 * MAXSTR * sizeof(WCHAR)) 
                    + (MAX_PID + 1) * sizeof(ULONG);


                    //
                    // Check to see that this process is allowed to log events or not.
                    //


                    LoggerInfo = WmipAlloc(sizeNeeded);

                    if(LoggerInfo){

                        //
                        // Check to see that this process is allowed to register or not.
                        //


                        RtlZeroMemory(LoggerInfo, sizeNeeded);

                        if(GetPidInfo(WmipGetCurrentProcessId(), LoggerInfo)){

                            LoggerInfo->LoggerName.Buffer = (PWCHAR)(((PUCHAR) LoggerInfo) 
                                                            + sizeof(WMI_LOGGER_INFORMATION));

                            LoggerInfo->LogFileName.Buffer = (PWCHAR)(((PUCHAR) LoggerInfo) 
                                                             + sizeof(WMI_LOGGER_INFORMATION)
                                                             + LoggerInfo->LoggerName.MaximumLength);

                            LoggerInfo->InstanceCount   = 0;
                            LoggerInfo->InstanceId      = WmipGetCurrentProcessId();

                            TraceLevel = (LONG)LoggerInfo->Wnode.HistoricalContext;
                            LoggerInfo->Wnode.HistoricalContext = 0;

                            //Start Logger Here

                            ret = WmipStartUmLogger(sizeNeeded,&sizeNeeded, &sizeNeeded,LoggerInfo);

                            if(ret == ERROR_SUCCESS ){

                                CleanUpAllThreadBuffers(FALSE);
                                bNtdllTrace = TRUE;
                                gLoggerInfo = LoggerInfo;
                                InterlockedIncrement(&NtdllLoggerLock);

                            } else {

                                WmipFree(LoggerInfo);

                            }

                        }
                    }
                }
            }

            InterlockedDecrement(&NtdllLoggerLock);
            break;
        }
        case WMI_DISABLE_EVENTS:  //Disable Provider.
        {

            if( bNtdllTrace == TRUE ){

                ULONG WnodeSize,SizeUsed,SizeNeeded;

                bNtdllTrace = FALSE;

                while(  InterlockedIncrement(&NtdllLoggerLock) != 1 ){

                    WmipSleep(250);
                    InterlockedDecrement(&NtdllLoggerLock);

                }

                if(!WmipIsLoggerOn()){

                    InterlockedDecrement(&NtdllLoggerLock);
                    break;

                }

                //
                // Now release thread buffer memory here.
                //

                CleanUpAllThreadBuffers(TRUE);

                WnodeSize = gLoggerInfo->Wnode.BufferSize;
                SizeUsed = 0;
                SizeNeeded = 0;

                WmipStopUmLogger(WnodeSize,
                                &SizeUsed,
                                &SizeNeeded,
                                gLoggerInfo);

                if(gLoggerInfo){

                    WmipFree(gLoggerInfo);
                    gLoggerInfo = NULL;

                }

                InterlockedDecrement(&NtdllLoggerLock);
            }

            break;
        }

        default:
        {

            ret = ERROR_INVALID_PARAMETER;
            break;

        }
    }
    return ret;
}


ULONG 
RegisterNtdllTraceEvents() 
/*++

Routine Description:

    This function registers the guids with WMI for tracing.

Return Value:

	The return value of RegisterTraceGuidsA function.

--*/
{
        
    //Create the guid registration array
    NTSTATUS status;

    TRACE_GUID_REGISTRATION TraceGuidReg[] =
    {
        { 
        (LPGUID) &HeapGuid, 
        NULL 
        },
        { 
        (LPGUID) &CritSecGuid, 
        NULL 
        }

    };

    //Now register this process as a WMI trace provider.
    status = RegisterTraceGuidsA(
                                (WMIDPREQUEST)NtdllCtrlCallback,		// Enable/disable function.
                                NULL,									// RequestContext parameter
                                (LPGUID)&NtdllTraceGuid,			    // Provider GUID
                                2,										// TraceGuidReg array size
                                TraceGuidReg,							// Array of TraceGuidReg structures
                                NULL,									// Optional WMI - MOFImagePath
                                NULL,									// Optional WMI - MOFResourceName
                                &(NtdllTraceHandles->hRegistrationHandle)	// Handle required to unregister.
                                );

    return status;
}


NTSTATUS 
InitializeAndRegisterNtdllTraceEvents()
/*++

Routine Description:

	This functions checks for global variable NtdllTraceHandles and if not set then calls
	fucntion InitializeWmiHandles to initialize it. NtdllTraceHandles contains handles used
	for Heap tracing. If NtdllTraceHandles is already initialized then  a call is  made  to 
	register the guids.

Return Value:

     STATUS_SUCCESS
     STATUS_UNSUCCESSFUL

--*/

{
    NTSTATUS  st = STATUS_UNSUCCESSFUL;

    if(NtdllTraceHandles == NULL){

        if(InterlockedIncrement(&NtdllTraceInitializeLock) == 1){

            st = InitializeWmiHandles(&NtdllTraceHandles);

            if(NT_SUCCESS(st)){

	            st = RegisterNtdllTraceEvents();

            } 
        }
    }

    return st;
}


NTSTATUS
AllocateMemoryForThreadLocalData(PPTHREAD_LOCAL_DATA ppThreadLocalData)
/*++

Routine Description:

	This functions allcates memory for tls and adds it to Link list which
	contains informations of all threads involved in tracing.

Arguments

  ppThreadLocalData : The OUT pointer to the tls.

Return Value:

     STATUS_SUCCESS
     STATUS_UNSUCCESSFUL

--*/
{
    NTSTATUS st = STATUS_UNSUCCESSFUL;
    PTHREAD_LOCAL_DATA		pThreadLocalData = NULL;

    pThreadLocalData = (PTHREAD_LOCAL_DATA)WmipAlloc(sizeof(THREAD_LOCAL_DATA));

    if(pThreadLocalData != NULL){

        if(WmipTlsSetValue(NtdllTraceHandles->dwTlsIndex, (LPVOID)pThreadLocalData) == TRUE){

            pThreadLocalData->pBuffer   = NULL;
            pThreadLocalData->ReferenceCount = 0;

            RtlEnterCriticalSection(&NtdllTraceHandles->CriticalSection);

            if(NtdllTraceHandles->pThreadListHead == NULL ){

                pThreadLocalData->BLink = NULL;
                pThreadLocalData->FLink = NULL;

            } else {

                pThreadLocalData->FLink = NtdllTraceHandles->pThreadListHead;
                pThreadLocalData->BLink = NULL;
                NtdllTraceHandles->pThreadListHead->BLink = pThreadLocalData;

            }

            NtdllTraceHandles->pThreadListHead = pThreadLocalData;

            RtlLeaveCriticalSection(&NtdllTraceHandles->CriticalSection);

            st = STATUS_SUCCESS;
        } 
    }

    if(!NT_SUCCESS(st) && pThreadLocalData != NULL){

        WmipFree(pThreadLocalData);
        pThreadLocalData = NULL;

    }

    *ppThreadLocalData = pThreadLocalData;

    return st;
}


void
ReleaseBufferLocation(PTHREAD_LOCAL_DATA pThreadLocalData)
{

    PWMI_BUFFER_HEADER pWmiBuffer;

    pWmiBuffer = pThreadLocalData->pBuffer;

    if(pWmiBuffer){

        PPERFINFO_TRACE_HEADER EventHeader =  (PPERFINFO_TRACE_HEADER) (pWmiBuffer->SavedOffset
                                            + (PCHAR)(pWmiBuffer));

        EventHeader->Marker = PERFINFO_TRACE_MARKER;
        EventHeader->TS = WmipGetCycleCount();
        
    }

    InterlockedDecrement(&(pThreadLocalData->ReferenceCount));

    WmipUnlockLogger();
}


PCHAR
ReserveBufferSpace(PTHREAD_LOCAL_DATA pThreadLocalData, PUSHORT ReqSize)
{


    PWMI_BUFFER_HEADER TraceBuffer = pThreadLocalData->pBuffer;

    *ReqSize = (USHORT) ALIGN_TO_POWER2(*ReqSize, WmiTraceAlignment);

    if(TraceBuffer == NULL) return NULL;

    if(WmipLoggerContext->BufferSize - TraceBuffer->CurrentOffset < *ReqSize) {

        PWMI_BUFFER_HEADER NewTraceBuffer = NULL;

        NewTraceBuffer = WmipSwitchFullBuffer(TraceBuffer);

        if( NewTraceBuffer == NULL ){
             pThreadLocalData->pBuffer = NULL;
             return NULL;

        } else {

            pThreadLocalData->pBuffer = NewTraceBuffer;
            TraceBuffer = NewTraceBuffer;
        }
    }

    TraceBuffer->SavedOffset = TraceBuffer->CurrentOffset;
    TraceBuffer->CurrentOffset += *ReqSize;

    return  (PCHAR)( TraceBuffer->SavedOffset + (PCHAR) TraceBuffer );
}

NTSTATUS 
AcquireBufferLocation(PVOID *ppEvent, PPTHREAD_LOCAL_DATA ppThreadLocalData, PUSHORT ReqSize)
/*++

Routine Description:

    This  function is  called from heap.c and heapdll.c  whenever  there is some
	Heap activity. It looks up the buffer location where the even can be written 
    and gives back the pointer.

Arguments:

    ppEvent             - The pointer to pointer of buffer location
    ppThreadLocalData   - The pointer to pointer of thread event storing struct.

Return Value:

     STATUS_UNSUCCESSFUL if failed otherwise  STATUS_SUCCESS

--*/
{
	
    NTSTATUS  st = STATUS_SUCCESS;
    PWMI_BUFFER_HEADER pWmiBuffer;

    if( bNtdllTrace ){

         WmipLockLogger();

        if(WmipIsLoggerOn()){

            *ppThreadLocalData = (PTHREAD_LOCAL_DATA)WmipTlsGetValue(NtdllTraceHandles->dwTlsIndex);

            //
            //If there is no tls then create one here
            //

            if(*ppThreadLocalData ==  NULL ) {

                st = AllocateMemoryForThreadLocalData(ppThreadLocalData);

            } 

            //
            //If the thread buffer is NULL then get it from logger.
            //

            if( NT_SUCCESS(st) && (*ppThreadLocalData)->pBuffer == NULL ){

                (*ppThreadLocalData)->pBuffer  = WmipGetFullFreeBuffer();

                if((*ppThreadLocalData)->pBuffer == NULL){

                    st = STATUS_UNSUCCESSFUL;

                }
            }

            if(NT_SUCCESS(st)){

                //
                //Check ReferenceCount. If is 1 then the cleaning process might be in progress.
                //

                pWmiBuffer = (*ppThreadLocalData)->pBuffer;

                if(pWmiBuffer){

                    if(InterlockedIncrement(&((*ppThreadLocalData)->ReferenceCount)) == 1 ){

                        *ppEvent = ReserveBufferSpace(*ppThreadLocalData, ReqSize );

                        if(*ppEvent == NULL) {

                            InterlockedDecrement(&((*ppThreadLocalData)->ReferenceCount));
                            WmipUnlockLogger();

                        } 

                    } else { 

                        InterlockedDecrement(&((*ppThreadLocalData)->ReferenceCount));

                    }

                }

           }
        } else {

            WmipUnlockLogger();

        }
    } else if ( LdrpInLdrInit == FALSE && EtwLocksInitialized  && NtdllTraceInitializeLock == 0 ){ 

        //
        // Make sure that process is not in initialization phase
        // Also we test for NtdllTraceInitializeLock. If is 
        // greater than 0 then it was registered earlier so no 
        // need to fire IOCTLS  everytime
        //

        if((UserSharedData->TraceLogging >> 16) != GlobalCounter){

            PWMI_LOGGER_INFORMATION LoggerInfo = NULL;

            ULONG sizeNeeded = sizeof(WMI_LOGGER_INFORMATION)  
                                + (2 * MAXSTR * sizeof(TCHAR)) 
                                + (MAX_PID + 1) * sizeof(ULONG);

            GlobalCounter = UserSharedData->TraceLogging >> 16;

            WmipInitProcessHeap();

            LoggerInfo = WmipAlloc(sizeNeeded);

            if(LoggerInfo != NULL){

                //
                // Check to see that this process is allowed to register or not.
                //

                if(GetPidInfo(WmipGetCurrentProcessId(), LoggerInfo)){

                    st = InitializeAndRegisterNtdllTraceEvents();

                }

                WmipFree(LoggerInfo);
            }
        }
    }
    return st;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\ntdll\notify.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    notify.c

Abstract:

    Handles incoming notifications and requests for consumers and providers

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include <nt.h>
#include "wmiump.h"
#include "evntrace.h"
#include "trcapi.h"

ULONG WmipEventPumpFromKernel(
    PVOID Param
    );

void WmipExternalNotification(
    NOTIFICATIONCALLBACK Callback,
    ULONG_PTR Context,
    PWNODE_HEADER Wnode
    )
/*++

Routine Description:

    This routine dispatches an event to the appropriate callback
    routine. This process only receives events from the WMI service that
    need to be dispatched within this process. The callback address for the
    specific event is passed by the wmi service in Wnode->Linkage.

Arguments:

    Callback is address to callback

    Context is the context to callback with

    Wnode has event to deliver

Return Value:

--*/
{
    try
    {
        (*Callback)(Wnode, Context);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        WmipDebugPrint(("NotificationCallbackRoutine threw exception %d\n",
            GetExceptionCode()));
    }
}


#ifdef MEMPHIS
ULONG WmipExternalNotificationThread(
    PNOTIFDELIVERYCTX NDContext
    )
/*++

Routine Description:

    This routine is the thread function used to deliver events to event
    consumers on memphis.

Arguments:

    NDContext specifies the information about how to callback the application
    with the event.

Return Value:

--*/
{
    WmipExternalNotification(NDContext->Callback,
                             NDContext->Context,
                             NDContext->Wnode);
    WmipFree(NDContext);
    return(0);
}
#endif

void
WmipProcessExternalEvent(
    PWNODE_HEADER Wnode,
    ULONG WnodeSize,
    PVOID DeliveryInfo,
    ULONG_PTR DeliveryContext,
    ULONG NotificationFlags
)
{
    HANDLE ThreadHandle;
    PNOTIFDELIVERYCTX NDContext;
    PWNODE_HEADER *WnodePtr;
    BOOLEAN WnodePtrOk;
    PWNODE_HEADER WnodeCopy;
    BOOLEAN PostOk;
    ULONG Status;
    PVOID NotificationAddress;
    PVOID NotificationContext;

    NotificationAddress = DeliveryInfo;
    NotificationContext = (PVOID)DeliveryContext;

    if (NotificationFlags &
                         NOTIFICATION_FLAG_CALLBACK_DIRECT)
    {
        //
        // Callback notifications can happen in this thread or a new
        // thread. It is up to the server to decide.
#ifdef MEMPHIS
        if (NotificationFlags & DCREF_FLAG_NO_EXTRA_THREAD)
        {
            WmipExternalNotification(
                                    (NOTIFICATIONCALLBACK)NotificationAddress,
                                    (ULONG_PTR)NotificationContext,
                                    Wnode);
        } else {
            NDContext = WmipAlloc(FIELD_OFFSET(NOTIFDELIVERYCTX,
                                                    WnodeBuffer) + WnodeSize);
            if (NDContext != NULL)
            {
                NDContext->Callback = (NOTIFICATIONCALLBACK)NotificationAddress;
                NDContext->Context = (ULONG_PTR)NotificationContext;
                WnodeCopy = (PWNODE_HEADER)NDContext->WnodeBuffer;
                memcpy(WnodeCopy, Wnode, WnodeSize);
                NDContext->Wnode = WnodeCopy;
                ThreadHandle = WmipCreateThread(NULL,
                                              0,
                                              WmipExternalNotificationThread,
                                              NDContext,
                                              0,
                                              NULL);
                if (ThreadHandle != NULL)
                {
                    WmipCloseHandle(ThreadHandle);
                } else {
                     WmipDebugPrint(("WMI: Event dropped due to thread creation failure\n"));
                }
            } else {
                WmipDebugPrint(("WMI: Event dropped due to lack of memory\n"));
            }
        }
#else
        //
        // On NT we deliver events in this thread since
        // the service is using async rpc.
        WmipExternalNotification(
                            (NOTIFICATIONCALLBACK)NotificationAddress,
                            (ULONG_PTR)NotificationContext,
                            Wnode);
#endif
    }
}


void WmipInternalNotification(
    IN PWNODE_HEADER Wnode,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    )
{
    ULONG ActionCode, Cookie;
    PUCHAR Buffer = (PUCHAR)Wnode;

    //
    // This is an internal event, which is really a callback
    // from kernel mode
    //
    ActionCode = Wnode->ProviderId;
    Cookie = Wnode->CountLost;
#if DBG
    WmipDebugPrint(("WMI: Got internal event Action %d, Cookie %x\n",
                             ActionCode, Cookie));
#endif


    // if this is a trace guid enable/disable call use the cookie
    // to get the address


    if ( (Wnode->Flags & WNODE_FLAG_TRACED_GUID) || (ActionCode == WmiMBRequest) )
    {
        switch (ActionCode) {
            case WmiEnableEvents:
            case WmiDisableEvents:
            {
                WMIDPREQUEST WmiDPRequest;
                PVOID RequestAddress;
                PVOID RequestContext;
                ULONG Status;
                ULONG BufferSize = Wnode->BufferSize;

                if (Wnode->BufferSize >= (sizeof(WNODE_HEADER) + sizeof(ULONG64)) ) {
                    PULONG64 pLoggerContext = (PULONG64)(Buffer + sizeof(WNODE_HEADER));
                    Wnode->HistoricalContext = *pLoggerContext;
                }
                else {
#if DBG
                    WmipDebugPrint(("WMI: Wnode size %d is small for Trace notifications\n", Wnode->BufferSize));
#endif
                }

                if (WmipLookupCookie(Cookie,
                                     &Wnode->Guid,
                                     &RequestAddress,
                                     &RequestContext)) {
                    WmiDPRequest = (WMIDPREQUEST)RequestAddress;

                    try
                    {
#ifndef MEMPHIS


                        WmipGenericTraceEnable(Wnode->ProviderId, Buffer, (PVOID*)&WmiDPRequest);

#endif
                        if (*WmiDPRequest != NULL) {
                            Status = (*WmiDPRequest)(Wnode->ProviderId,
                                                 RequestContext,
                                                 &BufferSize,
                                                 Buffer);
                        }
                        else
                            Status = ERROR_WMI_DP_NOT_FOUND;
                    } except (EXCEPTION_EXECUTE_HANDLER) {
#if DBG
                        Status = GetExceptionCode();
                        WmipDebugPrint(("WMI: Service request call caused an exception %d\n",
                                        Status));
#endif
                        Status = ERROR_WMI_DP_FAILED;
                    }

                }
                break;
            }
            case WmiMBRequest:
            {
                PGUIDNOTIFICATION GNEntry;
                PVOID DeliveryInfo = NULL;
                ULONG_PTR DeliveryContext1;
                ULONG i;
                PWMI_LOGGER_INFORMATION LoggerInfo;

                if (Wnode->BufferSize < (sizeof(WNODE_HEADER) + sizeof(WMI_LOGGER_INFORMATION)) )
                {
#if DBG
                    WmipSetLastError(ERROR_WMI_DP_FAILED);
                    WmipDebugPrint(("WMI: WmiMBRequest with invalid buffer size %d\n",
                                        Wnode->BufferSize));
#endif
                    return;
                }

                LoggerInfo = (PWMI_LOGGER_INFORMATION) ((PUCHAR)Wnode + sizeof(WNODE_HEADER));


                GNEntry = WmipFindGuidNotification(&LoggerInfo->Wnode.Guid);

                if (GNEntry != NULL)
                {
                    WmipEnterPMCritSection();
                    for (i = 0; i < GNEntry->NotifyeeCount; i++)
                    {
                        if (GNEntry->Notifyee[i].DeliveryInfo != NULL)
                        {
                        //
                        // TODO: We expect only one entry here. Restrict at registration.
                        //
                            DeliveryInfo = GNEntry->Notifyee[i].DeliveryInfo;
                            DeliveryContext1 = GNEntry->Notifyee[i].DeliveryContext;
                            break;
                        }
                    }
                    WmipLeavePMCritSection();
                    WmipDereferenceGNEntry(GNEntry);
                }
                if (DeliveryInfo != NULL)
                {
                    LoggerInfo->Wnode.CountLost = Wnode->CountLost;
                    WmipProcessUMRequest(LoggerInfo, DeliveryInfo, Wnode->Version);
                }
                break;
            }
            default:
            {
#if DBG
                WmipSetLastError(ERROR_WMI_DP_FAILED);
                WmipDebugPrint(("WMI: WmiMBRequest failed. Delivery Info not found\n" ));
#endif
            }
        }
    } else if (IsEqualGUID(&Wnode->Guid, &GUID_MOF_RESOURCE_ADDED_NOTIFICATION) ||
               IsEqualGUID(&Wnode->Guid, &GUID_MOF_RESOURCE_REMOVED_NOTIFICATION) )
    {
        switch (ActionCode)
        {
            case MOFEVENT_ACTION_IMAGE_PATH:
            case MOFEVENT_ACTION_REGISTRY_PATH:
            {
                //
                // We got a MOF resource added or removed notification. We have
                // to convert from regpath to imagepath and then get the list
                // of MUI image paths
                //
             /*   WmipProcessMofAddRemoveEvent((PWNODE_SINGLE_INSTANCE)Wnode,
                                         Callback,
                                         DeliveryContext,
                                         IsAnsi);*/
                break;
            }

            case MOFEVENT_ACTION_LANGUAGE_CHANGE:
            {
                //
                // This is a notification for adding or removing a language
                // from the system. We need to figure out which language is
                // coming or going and then build a list of the affected mof
                // resources and send mof added or removed notifications for
                // all mof resources
                //
           /*     WmipProcessLanguageAddRemoveEvent((PWNODE_SINGLE_INSTANCE)Wnode,
                                          Callback,
                                          DeliveryContext,
                                          IsAnsi);*/
                break;
            }


            default:
            {
                WmipAssert(FALSE);
            }
        }
    }
}

void WmipConvertEventToAnsi(
    PWNODE_HEADER Wnode
    )
{
    PWCHAR WPtr;

    if (Wnode->Flags & WNODE_FLAG_ALL_DATA)
    {
        WmipConvertWADToAnsi((PWNODE_ALL_DATA)Wnode);
    } else if ((Wnode->Flags & WNODE_FLAG_SINGLE_INSTANCE) ||
               (Wnode->Flags & WNODE_FLAG_SINGLE_ITEM)) {

        WPtr = (PWCHAR)OffsetToPtr(Wnode,
                           ((PWNODE_SINGLE_INSTANCE)Wnode)->OffsetInstanceName);
        WmipCountedUnicodeToCountedAnsi(WPtr, (PCHAR)WPtr);
    }

    Wnode->Flags |= WNODE_FLAG_ANSI_INSTANCENAMES;

}

void WmipDeliverAllEvents(
    PUCHAR Buffer,
    ULONG BufferSize
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PWNODE_HEADER Wnode = (PWNODE_HEADER)Buffer;
    ULONG Linkage = 1;
    ULONG CompositeFlags;
    ULONG i;
    PGUIDNOTIFICATION GNEntry;
    ULONG Flags;
    PVOID DeliveryInfo;
    ULONG_PTR DeliveryContext;
    ULONG WnodeSize;
    ULONG CurrentOffset;
#if DBG
    PWNODE_HEADER LastWnode;
#endif          
    
    CurrentOffset = 0;
    while (Linkage != 0)
    {
        //
        // External notifications are handled here

        Linkage = Wnode->Linkage;
        Wnode->Linkage = 0;

        if (Wnode->Flags & WNODE_FLAG_INTERNAL)
        {
            //
            // This is an internal event, which is really a callback
            // from kernel mode
            //
            WmipInternalNotification(Wnode,
                                    NULL,
                                    0,
                                    FALSE);
        } else {        
            //
            // This is a plain old event, figure out who owns it and'
            // go deliver it
            //
            GNEntry = WmipFindGuidNotification(&Wnode->Guid);
            if (GNEntry != NULL)
            {
                CompositeFlags = 0;

                WnodeSize = Wnode->BufferSize;

                for (i = 0; i < GNEntry->NotifyeeCount; i++)
                {
                    WmipEnterPMCritSection();
                    Flags = GNEntry->Notifyee[i].Flags;
                    DeliveryInfo = GNEntry->Notifyee[i].DeliveryInfo;
                    DeliveryContext = GNEntry->Notifyee[i].DeliveryContext;
                    WmipLeavePMCritSection();
                    if ((DeliveryInfo != NULL) &&
                          ((Flags & DCREF_FLAG_ANSI) == 0))
                    {
                        WmipProcessExternalEvent(Wnode,
                                                WnodeSize,
                                                     DeliveryInfo,
                                                     DeliveryContext,
                                                     Flags);
                    }
                    CompositeFlags |= Flags;
                }

                //
                // If there is any demand for ANSI events then convert
                // event to ansi and send it off
                if (CompositeFlags & DCREF_FLAG_ANSI)
                {
                    //
                    // Caller wants ansi notification - convert
                    // instance names
                    //
                    WmipConvertEventToAnsi(Wnode);

                    for (i = 0; i < GNEntry->NotifyeeCount; i++)
                    {
                        WmipEnterPMCritSection();
                        Flags = GNEntry->Notifyee[i].Flags;
                        DeliveryInfo = GNEntry->Notifyee[i].DeliveryInfo;
                        DeliveryContext = GNEntry->Notifyee[i].DeliveryContext;
                        WmipLeavePMCritSection();
                        if ((DeliveryInfo != NULL) &&
                            (Flags & DCREF_FLAG_ANSI))
                        {
                            WmipProcessExternalEvent(Wnode,
                                                     WnodeSize,
                                                     DeliveryInfo,
                                                     DeliveryContext,
                                                     Flags);
                        }
                    }
                }
                WmipDereferenceGNEntry(GNEntry);
            }
        }

#if DBG
        LastWnode = Wnode;
#endif
        Wnode = (PWNODE_HEADER)OffsetToPtr(Wnode, Linkage);
        CurrentOffset += Linkage;
        
        if (CurrentOffset >= BufferSize)
        {
            WmipDebugPrint(("WMI: Invalid linkage field 0x%x in WNODE %p. Buffer %p, Length 0x%x\n",
                            Linkage, LastWnode, Buffer, BufferSize));
            Linkage = 0;
        }
    }
}

LIST_ENTRY WmipGNHead = {&WmipGNHead, &WmipGNHead};
PLIST_ENTRY WmipGNHeadPtr = &WmipGNHead;

void
WmipDereferenceGNEntry(
    PGUIDNOTIFICATION GNEntry
    )
{
    ULONG RefCount;
#if DBG
    ULONG i;
#endif

    WmipEnterPMCritSection();
    RefCount = InterlockedDecrement(&GNEntry->RefCount);
    if (RefCount == 0)
    {
        RemoveEntryList(&GNEntry->GNList);
        WmipLeavePMCritSection();
#if DBG
        for (i = 0; i < GNEntry->NotifyeeCount; i++)
        {
            WmipAssert(GNEntry->Notifyee[i].DeliveryInfo == NULL);
        }
#endif
        if (GNEntry->NotifyeeCount != STATIC_NOTIFYEE_COUNT)
        {
            WmipFree(GNEntry->Notifyee);
        }

        WmipFreeGNEntry(GNEntry);
    } else {
        WmipLeavePMCritSection();
    }
}

PGUIDNOTIFICATION
WmipFindGuidNotification(
    LPGUID Guid
    )
{
    PLIST_ENTRY GNList;
    PGUIDNOTIFICATION GNEntry;

    WmipEnterPMCritSection();
    GNList = WmipGNHead.Flink;
    while (GNList != &WmipGNHead)
    {
        GNEntry = (PGUIDNOTIFICATION)CONTAINING_RECORD(GNList,
                                    GUIDNOTIFICATION,
                                    GNList);

        if (IsEqualGUID(Guid, &GNEntry->Guid))
        {
            WmipAssert(GNEntry->RefCount > 0);
            WmipReferenceGNEntry(GNEntry);
            WmipLeavePMCritSection();
            return(GNEntry);
        }
    GNList = GNList->Flink;
    }
    WmipLeavePMCritSection();
    return(NULL);
}

ULONG
WmipAddToGNList(
    LPGUID Guid,
    PVOID DeliveryInfo,
    ULONG_PTR DeliveryContext,
    ULONG Flags,
    HANDLE GuidHandle
    )
{
    PGUIDNOTIFICATION GNEntry;
    ULONG NewCount;
    PNOTIFYEE NewNotifyee;
    BOOLEAN AllFull;
    ULONG EmptySlot;
    ULONG i;
#if DBG
    CHAR s[MAX_PATH];
#endif

    WmipEnterPMCritSection();
    GNEntry = WmipFindGuidNotification(Guid);

    if (GNEntry == NULL)
    {
        GNEntry = WmipAllocGNEntry();
        if (GNEntry == NULL)
        {
            WmipLeavePMCritSection();
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        memset(GNEntry, 0, sizeof(GUIDNOTIFICATION));

        GNEntry->Guid = *Guid;
        GNEntry->RefCount = 1;
        GNEntry->NotifyeeCount = STATIC_NOTIFYEE_COUNT;
        GNEntry->Notifyee = GNEntry->StaticNotifyee;
        InsertHeadList(&WmipGNHead, &GNEntry->GNList);
    }

    //
    // We have got a GUIDNOTIFICATION by newly allocating one or by finding
    // an existing one.
    AllFull = TRUE;
    for (i = 0; i < GNEntry->NotifyeeCount; i++)
    {
        if (GNEntry->Notifyee[i].DeliveryInfo == DeliveryInfo)
        {
            WmipDebugPrint(("WMI: Duplicate Notification Enable for guid %s, 0x%x\n",
                             GuidToStringA(s, Guid), DeliveryInfo));
            WmipLeavePMCritSection();
            WmipDereferenceGNEntry(GNEntry);
            return(ERROR_WMI_ALREADY_ENABLED);
        } else if (AllFull && (GNEntry->Notifyee[i].DeliveryInfo == NULL)) {
            EmptySlot = i;
            AllFull = FALSE;
        }
    }

    if (! AllFull)
    {
        GNEntry->Notifyee[EmptySlot].DeliveryInfo = DeliveryInfo;
        GNEntry->Notifyee[EmptySlot].DeliveryContext = DeliveryContext;
        GNEntry->Notifyee[EmptySlot].Flags = Flags;
        GNEntry->Notifyee[EmptySlot].GuidHandle = GuidHandle;
        WmipLeavePMCritSection();
        return(ERROR_SUCCESS);
    }

    //
    // All Notifyee structs are full so allocate a new chunk
    NewCount = GNEntry->NotifyeeCount * 2;
    NewNotifyee = WmipAlloc(NewCount * sizeof(NOTIFYEE));
    if (NewNotifyee == NULL)
    {
        WmipLeavePMCritSection();
        WmipDereferenceGNEntry(GNEntry);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    memset(NewNotifyee, 0, NewCount * sizeof(NOTIFYEE));
    memcpy(NewNotifyee, GNEntry->Notifyee,
                              GNEntry->NotifyeeCount * sizeof(NOTIFYEE));

    if (GNEntry->NotifyeeCount != STATIC_NOTIFYEE_COUNT)
    {
        WmipFree(GNEntry->Notifyee);
    }

    GNEntry->Notifyee = NewNotifyee;
    GNEntry->NotifyeeCount = NewCount;

    GNEntry->Notifyee[i].DeliveryInfo = DeliveryInfo;
    GNEntry->Notifyee[i].DeliveryContext = DeliveryContext;
    GNEntry->Notifyee[i].Flags = Flags;
    GNEntry->Notifyee[i].GuidHandle = GuidHandle;
    WmipLeavePMCritSection();
    return(ERROR_SUCCESS);

}

ULONG
WmipRemoveFromGNList(
    LPGUID Guid,
    PVOID DeliveryInfo,
    BOOLEAN ActuallyRemove
    )
{
    PGUIDNOTIFICATION GNEntry;
    ULONG i;
    ULONG Count;
    ULONG Status;

    GNEntry = WmipFindGuidNotification(Guid);

    if (GNEntry != NULL)
    {
        Status = ERROR_INVALID_PARAMETER;
        Count = 0;

        WmipEnterPMCritSection();
        for (i = 0; i < GNEntry->NotifyeeCount; i++)
        {
            if ((DeliveryInfo != NULL) &&
                (GNEntry->Notifyee[i].DeliveryInfo == DeliveryInfo) &&
                (Status != ERROR_SUCCESS))
            {
                if (ActuallyRemove)
                {
                    GNEntry->Notifyee[i].DeliveryInfo = NULL;
                    WmipCloseHandle(GNEntry->Notifyee[i].GuidHandle);
                    WmipDereferenceGNEntry(GNEntry);
                }
                Status = ERROR_SUCCESS;
                break;
            } else if (GNEntry->Notifyee[i].DeliveryInfo != NULL) {
                Count++;
            }
        }

        //
        // This hack will allow removal from the GNLIST in the case that the
        // passed DeliveryInfo does not match the DeliveryInfo in the GNEntry.
        // This is allowed only when there is only one NOTIFYEE in the GNENTRY
        // In the past we only supported one notifyee per guid in a process
        // and so we allowed the caller not to pass a valid DeliveryInfo when
        // unrefistering.

        if ((Status != ERROR_SUCCESS) &&
            (GNEntry->NotifyeeCount == STATIC_NOTIFYEE_COUNT) &&
            (GNEntry->Notifyee[0].DeliveryInfo != NULL) &&
            Count == 1)
        {
            if (ActuallyRemove)
            {
                GNEntry->Notifyee[0].DeliveryInfo = NULL;
                WmipCloseHandle(GNEntry->Notifyee[0].GuidHandle);
                WmipDereferenceGNEntry(GNEntry);
            }

            Status = ERROR_SUCCESS;
        }

        WmipLeavePMCritSection();
        WmipDereferenceGNEntry(GNEntry);
    } else {
        Status = ERROR_WMI_ALREADY_DISABLED;
    }

    return(Status);
}

PVOID WmipAllocDontFail(
    ULONG SizeNeeded,
    BOOLEAN *HoldCritSect
    )
{
    PVOID Buffer;

    do
    {
        Buffer = WmipAlloc(SizeNeeded);
        if (Buffer != NULL)
        {
            return(Buffer);
        }

        //
        // Out of memory so we'll sleep and hope that things will get
        // better later
        //
        if (*HoldCritSect)
        {
            //
            // If we are holding the PM critical section then we need
            // to release it. The caller is going to need to check if
            // the critical section was released and if so then deal
            // with it
            //
            *HoldCritSect = FALSE;
            WmipLeavePMCritSection();
        }
        WmipSleep(250);
    } while (1);
}

void WmipProcessEventBuffer(
    PUCHAR Buffer,
    ULONG ReturnSize,
    PUCHAR *PrimaryBuffer,
    ULONG *PrimaryBufferSize,
    PUCHAR *BackupBuffer,
    ULONG *BackupBufferSize,
    BOOLEAN ReallocateBuffers
    )
{
    PWNODE_TOO_SMALL WnodeTooSmall;
    ULONG SizeNeeded;
    BOOLEAN HoldCritSection;

    WnodeTooSmall = (PWNODE_TOO_SMALL)Buffer;
    if ((ReturnSize == sizeof(WNODE_TOO_SMALL)) &&
        (WnodeTooSmall->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL))
    {
        //
        // The buffer passed to kernel mode was too small
        // so we need to make it larger and then try the
        // request again.
        //
        if (ReallocateBuffers)
        {
            //
            // Only do this if the caller is prepared for us to
            // allocate a new set of buffers
            //
            SizeNeeded = WnodeTooSmall->SizeNeeded;

            WmipAssert(*PrimaryBuffer != NULL);
            WmipFree(*PrimaryBuffer);
            WmipDebugPrint(("WMI: [%x - %x] Free primary %x\n",
                            WmipGetCurrentProcessId(), WmipGetCurrentThreadId(),
                            *PrimaryBuffer));
            
            HoldCritSection = FALSE;
            *PrimaryBuffer = WmipAllocDontFail(SizeNeeded, &HoldCritSection);
            WmipDebugPrint(("WMI: [%x - %x] Realloc primary %x\n",
                            WmipGetCurrentProcessId(), WmipGetCurrentThreadId(),
                            *PrimaryBuffer));
            *PrimaryBufferSize = SizeNeeded;

            WmipAssert(*BackupBuffer != NULL);
            WmipFree(*BackupBuffer);
            WmipDebugPrint(("WMI: [%x - %x] Free backup %x\n",
                            WmipGetCurrentProcessId(), WmipGetCurrentThreadId(),
                            *BackupBuffer));
            
            HoldCritSection = FALSE;
            *BackupBuffer = WmipAllocDontFail(SizeNeeded, &HoldCritSection);
            WmipDebugPrint(("WMI: [%x - %x] Realloc backup %x\n",
                            WmipGetCurrentProcessId(), WmipGetCurrentThreadId(),
                            *BackupBuffer));
            *BackupBufferSize = SizeNeeded;
        }
    } else if (ReturnSize >= sizeof(WNODE_HEADER)) {
        //
        // The buffer return from kernel looks good so go and
        // deliver the events returned
        //
        WmipDeliverAllEvents(Buffer, ReturnSize);
    } else {
        //
        // If this completes successfully then we expect a decent size, but
        // we didn't get one
        //
        WmipDebugPrint(("WMI: Bad size 0x%x returned for notification query %p\n",
                                  ReturnSize, Buffer));

        WmipAssert(FALSE);
    }
}


ULONG
WmipReceiveNotifications(
    IN ULONG HandleCount,
    IN HANDLE *HandleList,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi,
    IN ULONG Action,
    IN PUSER_THREAD_START_ROUTINE UserModeCallback,
    IN HANDLE ProcessHandle
    )
{
    ULONG Status;
    ULONG ReturnSize;
    PWMIRECEIVENOTIFICATION RcvNotification;
    ULONG RcvNotificationSize;
    PUCHAR Buffer;
    ULONG BufferSize;
    PWNODE_TOO_SMALL WnodeTooSmall;
    PWNODE_HEADER Wnode;
    ULONG i;
    ULONG Linkage;

    if (HandleCount == 0)
    {
        WmipSetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    RcvNotificationSize = sizeof(WMIRECEIVENOTIFICATION) +
                          ((HandleCount-1) * sizeof(HANDLE3264));

    RcvNotification = WmipAlloc(RcvNotificationSize);

    if (RcvNotification != NULL)
    {

        Status = ERROR_SUCCESS;
        RcvNotification->Action = Action;
        WmipSetPVoid3264(RcvNotification->UserModeCallback, UserModeCallback);
        WmipSetHandle3264(RcvNotification->UserModeProcess, ProcessHandle);
        RcvNotification->HandleCount = HandleCount;
        for (i = 0; i < HandleCount; i++)
        {
            try
            {
                RcvNotification->Handles[i].Handle = HandleList[i];
            } except(EXCEPTION_EXECUTE_HANDLER) {
                Status = ERROR_INVALID_PARAMETER;
                break;
            }
        }

        BufferSize = 0x1000;
        Status = ERROR_INSUFFICIENT_BUFFER;
        while (Status == ERROR_INSUFFICIENT_BUFFER)
        {
            Buffer = WmipAlloc(BufferSize);
            if (Buffer != NULL)
            {
                Status = WmipSendWmiKMRequest(NULL,
                                          IOCTL_WMI_RECEIVE_NOTIFICATIONS,
                                          RcvNotification,
                                          RcvNotificationSize,
                                          Buffer,
                                          BufferSize,
                                          &ReturnSize,
                                           NULL);

                if (Status == ERROR_SUCCESS)
                {
                    WnodeTooSmall = (PWNODE_TOO_SMALL)Buffer;
                    if ((ReturnSize == sizeof(WNODE_TOO_SMALL)) &&
                        (WnodeTooSmall->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL))
                    {
                        //
                        // The buffer passed to kernel mode was too small
                        // so we need to make it larger and then try the
                        // request again
                        //
                        BufferSize = WnodeTooSmall->SizeNeeded;
                        Status = ERROR_INSUFFICIENT_BUFFER;
                    } else {
                        //
                        // We got a buffer of notifications so lets go
                        // process them and callback the caller
                        //
                        Wnode = (PWNODE_HEADER)Buffer;
                        do
                        {
                            Linkage = Wnode->Linkage;
                            Wnode->Linkage = 0;

                            if (Wnode->Flags & WNODE_FLAG_INTERNAL)
                            {
                                //
                                // Go and process the internal
                                // notification
                                //
                                WmipInternalNotification(Wnode,
                                                         Callback,
                                                         DeliveryContext,
                                                         IsAnsi);
                            } else {
                                if (IsAnsi)
                                {
                                    //
                                    // Caller wants ansi notification - convert
                                    // instance names
                                      //
                                    WmipConvertEventToAnsi(Wnode);
                                }

                                //
                                // Now go and deliver this event
                                //
                                WmipExternalNotification(Callback,
                                                         DeliveryContext,
                                                         Wnode);
                            }
                            Wnode = (PWNODE_HEADER)OffsetToPtr(Wnode, Linkage);
                        } while (Linkage != 0);
                    }
                }
                WmipFree(Buffer);
            } else {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        WmipFree(RcvNotification);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    WmipSetLastError(Status);
    return(Status);
}


void WmipMakeEventCallbacks(
    IN PWNODE_HEADER Wnode,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    )
{
    WmipAssert((Wnode->Flags & WNODE_FLAG_INTERNAL) == 0);
    
    if (Callback == NULL)
    {
        //
        // This event needs to be sent to all consumers
        //
        WmipDeliverAllEvents((PUCHAR)Wnode,
                             Wnode->BufferSize);
    } else {
        //
        // This event is targetted at a specific consumer
        //
        if (IsAnsi)
        {
            //
            // Caller wants ansi notification - convert
            // instance names
            //
            WmipConvertEventToAnsi(Wnode);        
        }
        
        //
        // Now go and deliver this event
        //
        WmipExternalNotification(Callback,
                                 DeliveryContext,
                                 Wnode);        
    }
}


//
// These globals are essentially parameters passed from the thread crating
// the event pump. The creating thread will alloc all of these resources
// so that it can know whether the pump thread will be successful or not.
// If we ever wanted to be able to have multiple pump threads then we'd
// need to move the globals into a structure and pass the struructure to the
// pump thread.
//
HANDLE WmipEventDeviceHandle;
HANDLE WmipPumpCommandEvent;
HANDLE WmipMyProcessHandle;
OVERLAPPED WmipOverlapped1, WmipOverlapped2;
PUCHAR WmipEventBuffer1, WmipEventBuffer2;
ULONG WmipEventBufferSize1, WmipEventBufferSize2;

//
// How long to wait before the event pump thread times out
//
#if DBG
#define EVENT_NOTIFICATION_WAIT (5 * 1000)
#else
#define EVENT_NOTIFICATION_WAIT (5 * 60 * 1000)
#endif
ULONG WmipEventNotificationWait = EVENT_NOTIFICATION_WAIT;

typedef enum
{
    EVENT_PUMP_ZERO,         // Pump thread has not been started yet
    EVENT_PUMP_IDLE,         // Pump thread was started, but then exited
    EVENT_PUMP_RUNNING,      // Pump thread is running
    EVENT_PUMP_STOPPING      // Pump thread is in process of stopping
} EVENTPUMPSTATE, *PEVENTPUMPSTATE;

EVENTPUMPSTATE WmipPumpState = EVENT_PUMP_ZERO;
BOOLEAN WmipNewPumpThreadPending;

#define WmipSendPumpCommand() WmipSetEvent(WmipPumpCommandEvent);

#define WmipIsPumpStopping() \
    ((WmipPumpState == EVENT_PUMP_STOPPING) ? TRUE : FALSE)


void WmipBuildReceiveNotification(
    PUCHAR *BufferPtr,
    ULONG *BufferSizePtr,
    ULONG *RequestSize,
    ULONG Action,
    HANDLE ProcessHandle
    )
{
    ULONG GuidCount;
    PUCHAR Buffer;
    ULONG BufferSize;
    PLIST_ENTRY GuidNotificationList;
    PGUIDNOTIFICATION GuidNotification;
    PWMIRECEIVENOTIFICATION ReceiveNotification;
    ULONG SizeNeeded;
    ULONG i;
    PNOTIFYEE Notifyee;
    ULONG ReturnSize;
    ULONG Status;
    BOOLEAN HoldCritSection;
    BOOLEAN HaveGroupHandle;

    Buffer = *BufferPtr;
    BufferSize = *BufferSizePtr;
    ReceiveNotification = (PWMIRECEIVENOTIFICATION)Buffer;

TryAgain:   
    GuidCount = 0;
    SizeNeeded = FIELD_OFFSET(WMIRECEIVENOTIFICATION, Handles);

    //
    // Loop over all guid notifications and build an ioctl request for
    // all of them
    //
    WmipEnterPMCritSection();

    GuidNotificationList = WmipGNHead.Flink;
    while (GuidNotificationList != &WmipGNHead)
    {
        GuidNotification = CONTAINING_RECORD(GuidNotificationList,
                                             GUIDNOTIFICATION,
                                             GNList);

        HaveGroupHandle = FALSE;
        for (i = 0; i < GuidNotification->NotifyeeCount; i++)
        {
            Notifyee = &GuidNotification->Notifyee[i];
            
            if ((Notifyee->DeliveryInfo != NULL) &&
                ((! HaveGroupHandle) ||
                 ((Notifyee->Flags & NOTIFICATION_FLAG_GROUPED_EVENT) == 0)))
            {
                //
                // If there is an active handle in the notifyee slot
                // and we either have not already inserted the group
                // handle for this guid or the slot is not part of the
                // guid group, then we insert the handle into the list
                //
                SizeNeeded += sizeof(HANDLE3264);
                if (SizeNeeded > BufferSize)
                {
                    //
                    // We need to grow the size of the buffer. Alloc a
                    // bigger buffer, copy over
                    //
                    BufferSize *= 2;
                    HoldCritSection = TRUE;
                    Buffer = WmipAllocDontFail(BufferSize, &HoldCritSection);

                    memcpy(Buffer, ReceiveNotification, *BufferSizePtr);

                    WmipFree(*BufferPtr);

                    *BufferPtr = Buffer;
                    *BufferSizePtr = BufferSize;
                    ReceiveNotification = (PWMIRECEIVENOTIFICATION)Buffer;

                    if (! HoldCritSection)
                    {
                        //
                        // Critical section was released within
                        // WmipAllocDontFail since we had to block. So
                        // everything could have changed. We need to go
                        // back and start over again
                        //
                        goto TryAgain;
                    }                   
                }

                WmipSetHandle3264(ReceiveNotification->Handles[GuidCount],
                                  Notifyee->GuidHandle);
                GuidCount++;
                
                if (Notifyee->Flags & NOTIFICATION_FLAG_GROUPED_EVENT)
                {
                    //
                    // This was a guid group handle and we did insert
                    // it into the list so we don't want to insert it
                    // again
                    //
                    HaveGroupHandle = TRUE;
                }
            }
        }
        GuidNotificationList = GuidNotificationList->Flink;
    }

    WmipLeavePMCritSection();
    ReceiveNotification->HandleCount = GuidCount;
    ReceiveNotification->Action = Action;
    WmipSetPVoid3264(ReceiveNotification->UserModeCallback, WmipEventPumpFromKernel);
    WmipSetHandle3264(ReceiveNotification->UserModeProcess, ProcessHandle);
    *RequestSize = SizeNeeded;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)           // Not all control paths return (due to infinite loop)
#endif
ULONG WmipEventPump(
    PVOID Param
    )
{
    LPOVERLAPPED ActiveOverlapped, DeadOverlapped;
    LPOVERLAPPED PrimaryOverlapped;
    LPOVERLAPPED BackupOverlapped;
    PUCHAR ActiveBuffer, DeadBuffer;
    ULONG ActiveBufferSize, DeadBufferSize;
    PUCHAR PrimaryBuffer, BackupBuffer;
    ULONG PrimaryBufferSize, BackupBufferSize;
    ULONG ReturnSize, DeadReturnSize;
    ULONG Status, WaitStatus;
    HANDLE HandleArray[2];
    ULONG RequestSize;

    WmipDebugPrint(("WMI: [%x - %x] New pump thread is started\n",
                    WmipGetCurrentProcessId(), WmipGetCurrentThreadId()));
    
    //
    // We need to hold off on letting the thread into the routine until
    // the previous pump thread has had a chance to finish. This could
    // occur if a GN is added/removed while the previous thread is
    // finishing up or if an event is received as the previous thread
    // is finishing up.
    //
    while (WmipIsPumpStopping())
    {
        //
        // wait 50ms for the previous thread to finish up
        //
        WmipDebugPrint(("WMI: [%x - %x] waiting for pump to be stopped\n",
                        WmipGetCurrentProcessId(), WmipGetCurrentThreadId()));
        WmipSleep(50);
    }
    
    //
    // Next thing to do is to make sure that another pump thread isn't
    // already running. This can happen in the case that both a GN is
    // added or removed and an event reaches kernel and the kernel
    // creates a new thread too. Right here we only let one of them
    // win.
    //
    WmipEnterPMCritSection();
    if ((WmipPumpState != EVENT_PUMP_IDLE) &&
        (WmipPumpState != EVENT_PUMP_ZERO))
    {
        WmipDebugPrint(("WMI: [%x - %x] Exit pump since state is %d\n",
                        WmipGetCurrentProcessId(), WmipGetCurrentThreadId(),
                        WmipPumpState));
        
        WmipLeavePMCritSection();

         WmipExitThread(0);
    } else {
        WmipDebugPrint(("WMI: [%x - %x] pump thread now running\n",
                        WmipGetCurrentProcessId(), WmipGetCurrentThreadId()));                      
        WmipPumpState = EVENT_PUMP_RUNNING;
        WmipNewPumpThreadPending = FALSE;
        WmipLeavePMCritSection();
    }

    //
    // Make sure we have all resources we'll need to pump out events
    // since there is no way that we can return an error to the original
    // caller since we are on a new thread
    //
    WmipAssert(WmipEventDeviceHandle != NULL);
    WmipAssert(WmipPumpCommandEvent != NULL);
    WmipAssert(WmipMyProcessHandle != NULL);
    WmipAssert(WmipEventBuffer1 != NULL);
    WmipAssert(WmipEventBuffer2 != NULL);
    WmipAssert(WmipOverlapped1.hEvent != NULL);
    WmipAssert(WmipOverlapped2.hEvent != NULL);

    ActiveOverlapped = NULL;

    PrimaryOverlapped = &WmipOverlapped1;
    PrimaryBuffer = WmipEventBuffer1;
    PrimaryBufferSize = WmipEventBufferSize1;

    BackupOverlapped = &WmipOverlapped2;
    BackupBuffer = WmipEventBuffer2;
    BackupBufferSize = WmipEventBufferSize2;

    WmipDebugPrint(("WMI: [%x - %x] 1 buffer is %x, 2 buffer id %x\n",
                    WmipGetCurrentProcessId(), WmipGetCurrentThreadId(),
                    WmipEventBuffer1, WmipEventBuffer2));
    HandleArray[0] = WmipPumpCommandEvent;

    while(TRUE)
    {
        //
        // Build request to receive events for all guids that are
        // registered
        //
        WmipEnterPMCritSection();
        if (IsListEmpty(&WmipGNHead))
        {
            //
            // There are no events to be received so we cancel any
            // outstanding requests and quietly exit this thread. Note
            // that once we leave the critsec there could be another
            // pump thread running so all we can do after that is exit.
            //

            WmipCancelIo(WmipEventDeviceHandle);

            
            //
            // Enter the idle state which implies that all of the
            // pump resources stay allocated when the thread is not
            // running
            //
            WmipEventBuffer1 = PrimaryBuffer;
            WmipEventBufferSize1 = PrimaryBufferSize;
            WmipEventBuffer2 = BackupBuffer;
            WmipEventBufferSize2 = BackupBufferSize;
                        
            WmipPumpState = EVENT_PUMP_IDLE;
            WmipDebugPrint(("WMI: [%x - %x] No more GN, pump exiting, pump state EVENT_PUMP_IDLE\n",
                           WmipGetCurrentProcessId(), WmipGetCurrentThreadId()));
            
            WmipLeavePMCritSection();
            
            WmipExitThread(0);
        }
        WmipLeavePMCritSection();

        if (ActiveOverlapped != NULL)
        {
            //
            // If there was a previously outstanding request then
            // we remember it and switch to the backup overlapped and
            // and data buffer
            //
            DeadOverlapped = ActiveOverlapped;
            DeadBuffer = ActiveBuffer;
            DeadBufferSize = ActiveBufferSize;

            //
            // The request being mooted should be the current primary
            //
            WmipAssert(DeadOverlapped == PrimaryOverlapped);
            WmipAssert(DeadBuffer == PrimaryBuffer);

            //
            // Use the backup request as the new primary
            //
            WmipAssert(BackupOverlapped != NULL);
            WmipAssert(BackupBuffer != NULL);

            PrimaryOverlapped = BackupOverlapped;
            PrimaryBuffer = BackupBuffer;
            PrimaryBufferSize = BackupBufferSize;

            BackupOverlapped = NULL;
            BackupBuffer = NULL;
        } else {
            //
            // If there is no outstanding request then we don't worry about
            // it
            //
            DeadOverlapped = NULL;
        }

        //
        // Build and send the request down to kernel to receive events
        //

RebuildRequest:     
        WmipBuildReceiveNotification(&PrimaryBuffer,
                                     &PrimaryBufferSize,
                                     &RequestSize,
                                     WmipIsPumpStopping() ? RECEIVE_ACTION_CREATE_THREAD :
                                                            RECEIVE_ACTION_NONE,
                                     WmipMyProcessHandle);

        ActiveOverlapped = PrimaryOverlapped;
        ActiveBuffer = PrimaryBuffer;
        ActiveBufferSize = PrimaryBufferSize;

        Status = WmipSendWmiKMRequest(WmipEventDeviceHandle,
                                      IOCTL_WMI_RECEIVE_NOTIFICATIONS,
                                      ActiveBuffer,
                                      RequestSize,
                                      ActiveBuffer,
                                      ActiveBufferSize,
                                      &ReturnSize,
                                      ActiveOverlapped);

        if (DeadOverlapped != NULL)
        {
            if ((Status != ERROR_SUCCESS) &&
                (Status != ERROR_IO_PENDING) &&
                (Status != ERROR_OPERATION_ABORTED))
            {
                //
                // There was a previous request which won't be cleared
                // unless the new request returns pending, cancelled
                // or success. So if the new request returns something
                // else then we need to retry the request
                //
                WmipDebugPrint(("WMI: Event Poll error %d\n", Status));
                WmipSleep(100);
                goto RebuildRequest;
            }

            //
            // The new request should have caused the old one to
            // be completed
            //
            if (WmipGetOverlappedResult(WmipEventDeviceHandle,
                                    DeadOverlapped,
                                    &DeadReturnSize,
                                    TRUE))
            {
                //
                // The dead request did succeed and was not failed by
                // the receipt of the new request. This is a unlikely
                // race condition where the requests crossed paths. So we
                // need to process the events returned in the dead request.
                // Now if the buffer returned was a WNODE_TOO_SMALL we want
                // to ignore it at this point since we are not at a
                // good position to reallocate the buffers - the
                // primary buffer is already attached to the new
                // request. That request is also going to return a
                // WNODE_TOO_SMALL and in the processing of that one we will
                // grow the buffers. So it is safe to ignore here.
                // However we will still need to dispatch any real
                // events received as they have been purged from KM.
                //
                if (DeadReturnSize != 0)
                {
                    WmipProcessEventBuffer(DeadBuffer,
                                           DeadReturnSize,
                                           &PrimaryBuffer,
                                           &PrimaryBufferSize,
                                           &BackupBuffer,
                                           &BackupBufferSize,
                                           FALSE);
                } else {
                    WmipAssert(WmipIsPumpStopping());
                }
            }

            //
            // Now make the completed request the backup request
            //
            WmipAssert(BackupOverlapped == NULL);
            WmipAssert(BackupBuffer == NULL);

            BackupOverlapped = DeadOverlapped;
            BackupBuffer = DeadBuffer;
            BackupBufferSize = DeadBufferSize;
        }

        if (Status == ERROR_IO_PENDING)
        {
            //
            // if the ioctl pended then we wait until either an event
            // is returned or a command needs processed
            //
            HandleArray[1] = ActiveOverlapped->hEvent;
            WaitStatus = WmipWaitForMultipleObjectsEx(2,
                                              HandleArray,
                                              FALSE,
                                              WmipEventNotificationWait,
                                              TRUE);
            WmipDebugPrint(("WMI: [%x - %x] Done Waiting for RCV or command -> %d\n",
                            WmipGetCurrentProcessId(), WmipGetCurrentThreadId(),
                            WaitStatus));
        } else {
            //
            // the ioctl completed immediately so we fake out the wait
            //
            WaitStatus = WAIT_OBJECT_0 + 1;
        }

        if (WaitStatus == WAIT_OBJECT_0 + 1)
        {
            if (Status == ERROR_IO_PENDING)
            {
                if (WmipGetOverlappedResult(WmipEventDeviceHandle,
                                        ActiveOverlapped,
                                        &ReturnSize,
                                        TRUE))
                {
                    Status = ERROR_SUCCESS;
                } else {
                    Status = WmipGetLastError();
                }
            }

            if (Status == ERROR_SUCCESS)
            {
                //
                // We received some events from KM so we want to go and
                // process them. If we got a WNODE_TOO_SMALL then the
                // primary and backup buffers will get reallocated with
                // the new size that is needed.
                //
                WmipDebugPrint(("WMI: [%x - %x] Process Active overlapped %p events %p (0x%x)\n",
                                WmipGetCurrentProcessId(), WmipGetCurrentThreadId(),
                                ActiveOverlapped, ActiveBuffer, ReturnSize));

                if (ReturnSize != 0)
                {
                    WmipProcessEventBuffer(ActiveBuffer,
                                           ReturnSize,
                                           &PrimaryBuffer,
                                           &PrimaryBufferSize,
                                           &BackupBuffer,
                                           &BackupBufferSize,
                                           TRUE);
                    //
                    // In the case that we are shutting down the event
                    // pump and the buffer passed to clear out all of
                    // the events was too small we need to call back
                    // down to the kernel to get the rest of the events
                    // since we cannot exit the thread with events that
                    // are not delivered. The kernel will not set the
                    // flag that a new thread is needed unless the irp
                    // clears all outstanding events
                    //
                } else {
                    WmipAssert(WmipIsPumpStopping());
                    if (WmipIsPumpStopping())
                    {
                        //
                        // The irp just completed should have not only
                        // just cleared all events out of kernel mode
                        // but also setup flags that new events should
                        // cause a new pump thread to be created. So
                        // there may be a new pump thread already created
                        // Also note there could be yet
                        // another event pump thread that was created
                        // if a GN was added or removed. Once we set
                        // the pump state to IDLE we are off to the
                        // races (See code at top of function)
                        //
                        WmipEnterPMCritSection();
                        
                        WmipPumpState = EVENT_PUMP_IDLE;
                        WmipDebugPrint(("WMI: [%x - %x] Pump entered IDLE\n",
                                        WmipGetCurrentProcessId(), WmipGetCurrentThreadId()));

                        WmipEventBuffer1 = PrimaryBuffer;
                        WmipEventBufferSize1 = PrimaryBufferSize;
                        WmipEventBuffer2 = BackupBuffer;
                        WmipEventBufferSize2 = BackupBufferSize;
                        
                        WmipLeavePMCritSection();
                        
                        WmipExitThread(0);
                    }

                }
                
            } else {
                //
                // For some reason the request failed. All we can do is
                // wait a bit and hope that the problem will clear up.
                // If we are stopping the thread we still need to wait
                // and try again as all events may not have been
                // cleared from the kernel. We really don't know if the
                // irp even made it to the kernel.
                //
                WmipDebugPrint(("WMI: [%x - %x] Error %d from Ioctl\n",
                                WmipGetCurrentProcessId(), WmipGetCurrentThreadId(),
                                Status));
                WmipSleep(250);
            }

            //
            // Flag that there is no longer a request outstanding
            //
            ActiveOverlapped = NULL;
        } else if (WaitStatus == STATUS_TIMEOUT) {
            //
            // The wait for events timed out so we go into the thread
            // stopping state to indicate that we are going to terminate 
            // the thread once all events are cleared out of kernel. At
            // this point we are commited to stopping the thread. If any 
            // GN are added/removed after going into the stopping state, 
            // a new (and suspended) thread will be created. Right
            // before exiting we check if that thread is pending and if
            // so resume it.
            //
            WmipEnterPMCritSection();
            WmipDebugPrint(("WMI: [%x - %x] Pump thread entering EVENT_PUMP_STOPPING\n",
                           WmipGetCurrentProcessId(), WmipGetCurrentThreadId()));
            WmipPumpState = EVENT_PUMP_STOPPING;
            WmipLeavePMCritSection();
        }
    }

    //
    // Should never break out of infinite loop
    //
    WmipAssert(FALSE);
        
    WmipExitThread(0);
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


ULONG WmipEventPumpFromKernel(
    PVOID Param
    )
{
    //
    // Note that we MUST call WmipExitThread when we want to shutdown the
    // thread and not return() since the thread has been created by
    // kernel mode and there is nothing on the stack to return to, so
    // we'd just AV
    //
    
    WmipEnterPMCritSection();
    if ((WmipNewPumpThreadPending == FALSE) &&
        (WmipPumpState == EVENT_PUMP_IDLE) ||
        (WmipPumpState == EVENT_PUMP_STOPPING))
    {
        //
        // If the pump is currently idle or stopping and there is not
        // another pump thread that is pending we want our thread
        // to be the one that gets the pump going again. We mark the
        // that there is a pump thread pending which means that no more 
        // pump threads will be created when adding/removing GN 
        // and any pump threads created by kernel will just exit quickly
        //
        WmipNewPumpThreadPending = TRUE;
        WmipDebugPrint(("WMI: [%x - %x] KM pump thread created and pump state now START PENDING\n",
                        WmipGetCurrentProcessId(), WmipGetCurrentThreadId()));
        WmipLeavePMCritSection();

        //
        // ISSUE: We cannot call WmipEventPump with Param (ie, the
        // parameter that is passed to this function) because when the
        // thread is created by a Win64 kernel on a x86 app running
        // under win64, Param is not actually passed on the stack since
        // the code that creates the context forgets to do so
        //
        WmipExitThread(WmipEventPump(0));
    }
    
    WmipDebugPrint(("WMI: [%x - %x] KM pump thread exiting since pump state %d, %s\n",
                        WmipGetCurrentProcessId(), WmipGetCurrentThreadId(),
                        WmipPumpState,
                        (WmipNewPumpThreadPending == TRUE) ?
                            "Pump Thread Pending" : "No Pump Thread Pending"));
                    
    WmipLeavePMCritSection();
    
    WmipExitThread(0);
    return 0;
}

ULONG WmipEstablishEventPump(
    )
{
#if DBG
    #define INITIALEVENTBUFFERSIZE 0x38
#else
    #define INITIALEVENTBUFFERSIZE 0x1000
#endif
    HANDLE ThreadHandle;
    CLIENT_ID ClientId;
    ULONG Status;
    BOOL b;


#if DBG
    //
    // On checked builds update the length of time to wait before a
    // pump thread times out
    //
   /* WmipGetRegistryValue(PumpTimeoutRegValueText,
                         &WmipEventNotificationWait);*/
#endif
    
    //
    // Make sure the event pump thread is running. We check both the
    // pump state and that the device handle is not created since there
    // is a window after the handle is created and the thread starts
    // running and changes the pump state
    //
    WmipEnterPMCritSection();

    if ((WmipPumpState == EVENT_PUMP_ZERO) &&
        (WmipEventDeviceHandle == NULL))
    {
        //
        // Not only is pump not running, but the resources for it
        // haven't been allocated
        //
        WmipAssert(WmipPumpCommandEvent == NULL);
        WmipAssert(WmipMyProcessHandle == NULL);
        WmipAssert(WmipOverlapped1.hEvent == NULL);
        WmipAssert(WmipOverlapped2.hEvent == NULL);
        WmipAssert(WmipEventBuffer1 == NULL);
        WmipAssert(WmipEventBuffer2 == NULL);

        //
        // Preallocate all of the resources that the event pump will need
        // so that it has no excuse to fail
        //

        WmipEventDeviceHandle = WmipCreateFileA(WMIDataDeviceName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL |
                                      FILE_FLAG_OVERLAPPED,
                              NULL);

        if (WmipEventDeviceHandle == INVALID_HANDLE_VALUE)
        {
            Status = WmipGetLastError();
            goto Cleanup;
        }

        WmipPumpCommandEvent = WmipCreateEventA(NULL, FALSE, FALSE, NULL);
        if (WmipPumpCommandEvent == NULL)
        {
            Status = WmipGetLastError();
            goto Cleanup;
        }

        b = WmipDuplicateHandle(WmipGetCurrentProcess(),
                            WmipGetCurrentProcess(),
                            WmipGetCurrentProcess(),
                            &WmipMyProcessHandle,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS);
        if (! b)
        {
            Status = WmipGetLastError();
            goto Cleanup;
        }

        WmipOverlapped1.hEvent = WmipCreateEventA(NULL, FALSE, FALSE, NULL);
        if (WmipOverlapped1.hEvent == NULL)
        {
            Status = WmipGetLastError();
            goto Cleanup;
        }

        WmipOverlapped2.hEvent = WmipCreateEventA(NULL, FALSE, FALSE, NULL);
        if (WmipOverlapped2.hEvent == NULL)
        {
            Status = WmipGetLastError();
            goto Cleanup;
        }

        WmipEventBuffer1 = WmipAlloc(INITIALEVENTBUFFERSIZE);
        if (WmipEventBuffer1 == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        WmipEventBufferSize1 = INITIALEVENTBUFFERSIZE;

        WmipEventBuffer2 = WmipAlloc(INITIALEVENTBUFFERSIZE);
        if (WmipEventBuffer2 == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        WmipEventBufferSize2 = INITIALEVENTBUFFERSIZE;

        ThreadHandle = WmipCreateThread(NULL,
                                    0,
                                    WmipEventPump,
                                    NULL,
                                    0,
                                    (LPDWORD)&ClientId);

        if (ThreadHandle != NULL)
        {
            WmipNewPumpThreadPending = TRUE;
            WmipDebugPrint(("WMI: [%x] Created initiail pump thread %x\n",
                            WmipGetCurrentProcessId(), ClientId.UniqueThread
                           ));
            WmipCloseHandle(ThreadHandle);
        } else {
            //
            // Since we were able to allocate all of our pump
            // resources, but didn't get the pump thread started,
            // we will hang onto our resources and move the pump
            // state to idle. In this way when the pump is started
            // again we do not have to reallocate our resources
            //
            WmipPumpState = EVENT_PUMP_IDLE;
            Status = WmipGetLastError();
            goto Done;
        }

        WmipLeavePMCritSection();
        return(ERROR_SUCCESS);
    } else {
        //
        // Pump resources should already be allocated
        //
        WmipAssert(WmipPumpCommandEvent != NULL);
        WmipAssert(WmipMyProcessHandle != NULL);
        WmipAssert(WmipOverlapped1.hEvent != NULL);
        WmipAssert(WmipOverlapped2.hEvent != NULL);
        WmipAssert(WmipEventBuffer1 != NULL);
        WmipAssert(WmipEventBuffer2 != NULL);
        if ((WmipNewPumpThreadPending == FALSE) &&
            (WmipPumpState == EVENT_PUMP_STOPPING) ||
            (WmipPumpState == EVENT_PUMP_IDLE))
        {
            //
            // If pump is stopping or is idle then we need to fire up a
            // new thread
            //
            ThreadHandle = WmipCreateThread(NULL,
                                        0,
                                        WmipEventPump,
                                        NULL,
                                        0,
                                        (LPDWORD)&ClientId);

            if (ThreadHandle != NULL)
            {
                WmipDebugPrint(("WMI: [%x] Created new pump thread %x (%d %d)\n",
                                WmipGetCurrentProcessId(), ClientId.UniqueThread,
                                WmipPumpState, WmipNewPumpThreadPending
                               ));
                WmipNewPumpThreadPending = TRUE;
                WmipCloseHandle(ThreadHandle);
            } else {
                Status = WmipGetLastError();
                goto Done;
            }
        } else {
            WmipAssert((WmipPumpState == EVENT_PUMP_RUNNING) ||
                       (WmipNewPumpThreadPending == TRUE));
        }
        WmipLeavePMCritSection();
        return(ERROR_SUCCESS);
    }
Cleanup:
    if (WmipEventDeviceHandle != NULL)
    {
        WmipCloseHandle(WmipEventDeviceHandle);
        WmipEventDeviceHandle = NULL;
    }

    if (WmipPumpCommandEvent != NULL)
    {
        WmipCloseHandle(WmipPumpCommandEvent);
        WmipPumpCommandEvent = NULL;
    }
    
    if (WmipMyProcessHandle != NULL)
    {
        WmipCloseHandle(WmipMyProcessHandle);
        WmipMyProcessHandle = NULL;
    }

    if (WmipOverlapped1.hEvent != NULL)
    {
        WmipCloseHandle(WmipOverlapped1.hEvent);
        WmipOverlapped1.hEvent = NULL;
    }

    if (WmipOverlapped2.hEvent != NULL)
    {
        WmipCloseHandle(WmipOverlapped2.hEvent);
        WmipOverlapped2.hEvent = NULL;
    }

    if (WmipEventBuffer1 != NULL)
    {
        WmipFree(WmipEventBuffer1);
        WmipEventBuffer1 = NULL;
    }

    if (WmipEventBuffer2 != NULL)
    {
        WmipFree(WmipEventBuffer2);
        WmipEventBuffer2 = NULL;
    }

Done:   
    WmipLeavePMCritSection();
    return(Status);
}

ULONG WmipAddHandleToEventPump(
    LPGUID Guid,
    PVOID DeliveryInfo,
    ULONG_PTR DeliveryContext,
    ULONG NotificationFlags,
    HANDLE GuidHandle
    )
{
    ULONG Status;

    Status = WmipAddToGNList(Guid,
                             DeliveryInfo,
                             DeliveryContext,
                             NotificationFlags,
                             GuidHandle);

    if (Status == ERROR_SUCCESS)
    {
        Status = WmipEstablishEventPump();
        
        if (Status == ERROR_SUCCESS)
        {
            WmipSendPumpCommand();
        }
    }
    return(Status);
}
/*
ULONG
WmipNotificationRegistration(
    IN LPGUID InGuid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG64 LoggerContext,
    IN ULONG Flags,
    IN BOOLEAN IsAnsi
    )
{
    HANDLE GuidHandle;
    GUID Guid;
    PVOID NotificationDeliveryContext;
    PVOID NotificationDeliveryInfo;
    ULONG NotificationFlags;
    ULONG Status;
    HANDLE ThreadHandle;
    DWORD ThreadId;
    ULONG ReturnSize;

    WmipInitProcessHeap();

    //
    // Validate input parameters and flags
    //
    if (InGuid == NULL)
    {
        WmipSetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    try
    {
        Guid = *InGuid;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        WmipSetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    if (Flags == NOTIFICATION_CHECK_ACCESS)
    {
        //
        // Caller just wants to check that he has does have permission
        // to enable the notification
        //
#ifdef MEMPHIS
        return(ERROR_SUCCESS);
#else
       Status =   WmipCheckGuidAccess(&Guid, WMIGUID_NOTIFICATION);
        WmipSetLastError(Status);
        return(Status);
#endif
    }

    //
    // Validate that flags are correct
    //
    if (Enable)
    {
        if ((Flags != NOTIFICATION_TRACE_FLAG) &&
            (Flags != NOTIFICATION_CALLBACK_DIRECT))
        {
            //
            // Invalid Flags were passed
            Status = ERROR_INVALID_PARAMETER;
        } else if (Flags == NOTIFICATION_TRACE_FLAG) {
            Status = ERROR_SUCCESS;
        } else if ((Flags == NOTIFICATION_CALLBACK_DIRECT) &&
                   (DeliveryInfo == NULL)) {
            //
            // Not a valid callback function
            Status = ERROR_INVALID_PARAMETER;
        } else {
            Status = ERROR_SUCCESS;
        }

        if (Status != ERROR_SUCCESS)
        {
            WmipSetLastError(Status);
            return(Status);
        }
    }


    NotificationDeliveryInfo = (PVOID)DeliveryInfo;
    NotificationDeliveryContext = (PVOID)DeliveryContext;

    NotificationFlags = IsAnsi ? DCREF_FLAG_ANSI : 0;


    if (Flags & NOTIFICATION_TRACE_FLAG)
    {
        //
        // This is a tracelog enable/disable request so send it down the
        // fast lane to KM so it can be processed.
        //
        WMITRACEENABLEDISABLEINFO TraceEnableInfo;

        TraceEnableInfo.Guid = Guid;
        TraceEnableInfo.LoggerContext = LoggerContext;
        TraceEnableInfo.Enable = Enable;

        Status = WmipSendWmiKMRequest(NULL,
                                      IOCTL_WMI_ENABLE_DISABLE_TRACELOG,
                                       &TraceEnableInfo,
                                      sizeof(WMITRACEENABLEDISABLEINFO),
                                      NULL,
                                      0,
                                      &ReturnSize,
                                      NULL);

    } else {
        //
        // This is a WMI event enable/disable event request so fixup the
        // flags and send a request off to the event pump thread.
        //
        if (Flags & NOTIFICATION_CALLBACK_DIRECT) {
            NotificationFlags |= NOTIFICATION_FLAG_CALLBACK_DIRECT;
        } else {
            NotificationFlags |= Flags;
        }

        if (Enable)
        {
            //
            // Since we are enabling, make sure we have access to the
            // guid and then make sure we can get the notification pump
            // thread running.
            //
            Status = WmipOpenKernelGuid(&Guid,
                                         WMIGUID_NOTIFICATION,
                                         &GuidHandle,
                                         IOCTL_WMI_OPEN_GUID_FOR_EVENTS);


            if (Status == ERROR_SUCCESS)
            {

                Status = WmipAddHandleToEventPump(&Guid,
                                                    DeliveryInfo,
                                                  DeliveryContext,
                                                  NotificationFlags |
                                                  NOTIFICATION_FLAG_GROUPED_EVENT,
                                                  GuidHandle);

                if (Status != ERROR_SUCCESS)
                {
                    //
                    // if we had opened the guid handle, but enabling
                    // failed for some other reason, we need to make sure
                    // we do not leave any opened guid handles
                    //
                    WmipCloseHandle(GuidHandle);
                }
            }
        } else {
            Status = WmipRemoveFromGNList(&Guid,
                                              DeliveryInfo,
                                              TRUE);
            if (Status == ERROR_SUCCESS)
            {
                WmipSendPumpCommand();
            }

            if (Status == ERROR_INVALID_PARAMETER)
            {
                CHAR s[MAX_PATH];
                WmipDebugPrint(("WMI: Invalid DeliveryInfo %x passed to unregister for notification %s\n",
                              DeliveryInfo,
                              GuidToStringA(s, &Guid)));
                Status = ERROR_WMI_ALREADY_DISABLED;
            }
        }
    }

    WmipSetLastError(Status);
    return(Status);
}*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\ntdll\tracehw.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tracehw.c

Abstract:

    This routine dumps the hardware configuration of the machine to the
    logfile.

Author:

    04-Jul-2000 Melur Raghuraman

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>          // for ntutrl.h
#include <nturtl.h>         // for RTL_CRITICAL_SECTION in winbase.h/wtypes.h
#include <wtypes.h>         // for LPGUID in wmium.h
#include <mountmgr.h>
#include <winioctl.h>
#include <ntddvol.h>
#include <ntddscsi.h>

#include "wmiump.h"
#include "evntrace.h"
#include "traceump.h"
#include "tracelib.h"
#include "trcapi.h"

#define DEFAULT_ALLOC_SIZE     4096

#define COMPUTERNAME_ROOT \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"

#define CPU_ROOT \
    L"\\Registry\\Machine\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor"

#define COMPUTERNAME_VALUE_NAME \
    L"ComputerName"

#define NETWORKCARDS_ROOT \
    L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards"

#define MHZ_VALUE_NAME \
    L"~MHz"

#define NIC_VALUE_NAME \
    L"Description"


NTSTATUS 
WmipRegOpenKey(
    IN LPWSTR lpKeyName,
    OUT PHANDLE KeyHandle
    )
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      KeyName;
    RtlInitUnicodeString( &KeyName, lpKeyName );
    RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));

    InitializeObjectAttributes(
                &ObjectAttributes,
                &KeyName,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL
                );

    return NtOpenKey( KeyHandle, KEY_READ, &ObjectAttributes );
}


NTSTATUS
WmipRegQueryValueKey(
    IN HANDLE KeyHandle,
    IN LPWSTR lpValueName,
    IN ULONG  Length,
    OUT PVOID KeyValue,
    OUT PULONG ResultLength
    )
{
    UNICODE_STRING ValueName;
    ULONG BufferLength;
    NTSTATUS Status;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    RtlInitUnicodeString( &ValueName, lpValueName );

    BufferLength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + Length;
    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) WmipAlloc(BufferLength);
    if (KeyValueInformation == NULL) {
        return STATUS_NO_MEMORY;
    }

    Status = NtQueryValueKey(
                KeyHandle,
                &ValueName,
                KeyValuePartialInformation,
                KeyValueInformation,
                BufferLength,
                ResultLength
                );
    if (NT_SUCCESS(Status)) {

        RtlCopyMemory(KeyValue, 
                      KeyValueInformation->Data, 
                      KeyValueInformation->DataLength
                     );

        *ResultLength = KeyValueInformation->DataLength;
        if (KeyValueInformation->Type == REG_SZ) {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > Length) {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            ((PUCHAR)KeyValue)[KeyValueInformation->DataLength++] = 0;
            ((PUCHAR)KeyValue)[KeyValueInformation->DataLength] = 0;
            *ResultLength = KeyValueInformation->DataLength + sizeof(WCHAR);
        }
    }
    WmipFree(KeyValueInformation);
    return Status;
}


NTSTATUS
WmipGetNetworkAdapters(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    PWCHAR Buffer = NULL;
    HANDLE Handle;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SubKeyIndex;
    ULONG DataLength;
    LPWSTR NicName;

    //
    // Open NetworkCards registry key to obtain the cards
    //

    Buffer = WmipAlloc(DEFAULT_ALLOC_SIZE);
    if (Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    swprintf(Buffer, NETWORKCARDS_ROOT);

    Status = WmipRegOpenKey((LPWSTR)Buffer, &Handle);

    if (!NT_SUCCESS(Status)) {
        goto NicCleanup;
    }

    for (SubKeyIndex=0; TRUE; SubKeyIndex++) {
        PKEY_BASIC_INFORMATION KeyInformation;
        ULONG RequiredLength;
        WCHAR Name[MAXSTR];
        HANDLE SubKeyHandle;

        KeyInformation = (PKEY_BASIC_INFORMATION)Buffer;

        Status = NtEnumerateKey(Handle,
                            SubKeyIndex,
                            KeyBasicInformation,
                            (PVOID) KeyInformation,
                            4096,
                            &RequiredLength
                           );

        if (Status == STATUS_NO_MORE_ENTRIES) {
            Status = STATUS_SUCCESS;
            break;
        }

        if (!NT_SUCCESS(Status)) {
            break;
        }

        if (KeyInformation->NameLength > MAXSTR) {
#ifdef DBG 
            WmipDebugPrint(("WMI: Ignoring NIC with largename %d\n", KeyInformation->NameLength));
            WmipAssert(KeyInformation->NameLength <= MAXSTR);
#endif 
            continue;
        }

        RtlCopyMemory(Name, (PWSTR)&(KeyInformation->Name[0]), KeyInformation->NameLength);
        Name[KeyInformation->NameLength/sizeof(WCHAR)] = 0;

        //
        // Now Query To get the Description field
        //
        swprintf(Buffer, L"%ws\\%ws", NETWORKCARDS_ROOT, Name);

        Status = WmipRegOpenKey((LPWSTR)Buffer, &SubKeyHandle);
        if (!NT_SUCCESS(Status)) {
            break;
        }

        swprintf(Name, NIC_VALUE_NAME);

NicQuery:
        Status = WmipRegQueryValueKey(SubKeyHandle, Name, 4096, (PVOID)Buffer, &DataLength);

        if (Status == STATUS_BUFFER_OVERFLOW) {
            WmipFree(Buffer);
            Buffer = WmipAlloc(DataLength);
            if (Buffer == NULL) {
                Status = STATUS_NO_MEMORY;
                NtClose(SubKeyHandle);
                break;
            }
            goto NicQuery;
        }
        if (!NT_SUCCESS(Status) ) {
            NtClose(SubKeyHandle);
            break;
        }

        NicName = (LPWSTR) WmipGetTraceBuffer( LoggerContext,
                                               NULL,
                                               EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_NIC,
                                               DataLength);

        if (NicName != NULL) {
            RtlCopyMemory(NicName, Buffer, DataLength);
        }
        NtClose(SubKeyHandle);
    }
    NtClose(Handle);
    
NicCleanup:
    if (Buffer != NULL) {
        WmipFree(Buffer);
    }
    return Status;
}


BOOL
WmipIsVolumeName(
    LPWSTR Name
    )
{
    if (Name[0] == '\\' &&
        (Name[1] == '?' || Name[1] == '\\') &&
        Name[2] == '?' &&
        Name[3] == '\\' &&
        Name[4] == 'V' &&
        Name[5] == 'o' &&
        Name[6] == 'l' &&
        Name[7] == 'u' &&
        Name[8] == 'm' &&
        Name[9] == 'e' &&
        Name[10] == '{' &&
        Name[19] == '-' &&
        Name[24] == '-' &&
        Name[29] == '-' &&
        Name[34] == '-' &&
        Name[47] == '}' ) {

        return TRUE;
        }
    return FALSE;
}



ULONG
WmipGetCpuConfig(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    PWCHAR Buffer = NULL;
    WCHAR ComputerName[MAXSTR];
    ULONG CpuNum;
    ULONG CpuSpeed;
    DWORD Size = MAXSTR;
    SYSTEM_INFO SysInfo;
    MEMORYSTATUS MemStatus;
    NTSTATUS Status;
    HANDLE Handle;
    ULONG DataLength;
    ULONG StringSize;
    ULONG SizeNeeded;
    PCPU_CONFIG_RECORD CpuConfig;


    Buffer = WmipAlloc(DEFAULT_ALLOC_SIZE);
    if (Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    WmipGlobalMemoryStatus(&MemStatus);


    swprintf(Buffer, COMPUTERNAME_ROOT);

    Status = WmipRegOpenKey((LPWSTR)Buffer, &Handle);

    if (!NT_SUCCESS(Status)) {
        goto CpuCleanup;
    }

    swprintf(Buffer, COMPUTERNAME_VALUE_NAME);
    Size = MAXSTR;

CpuQuery:
    Status = WmipRegQueryValueKey(Handle,
                               (LPWSTR) Buffer,
                               Size,
                               &ComputerName,
                               &StringSize
                               );

    if (Status == STATUS_BUFFER_OVERFLOW) {
        WmipFree(Buffer);
        Buffer = WmipAlloc(StringSize);
        if (Buffer == NULL) {
            NtClose(Handle);
            return STATUS_NO_MEMORY;
        }
        goto CpuQuery;
    }

    NtClose(Handle);
    if (!NT_SUCCESS(Status) ) {
        goto CpuCleanup;
    }

    //
    // Get Architecture Type, Processor Type and Level Stepping...
    //

    CpuNum = 0;
    CpuSpeed = 0;
    swprintf(Buffer, L"%ws\\%u", CPU_ROOT, CpuNum);
    Status = WmipRegOpenKey((LPWSTR)Buffer, &Handle);

    if (NT_SUCCESS(Status)) {
        swprintf(Buffer, MHZ_VALUE_NAME);
        Size = sizeof(DWORD);
        Status = WmipRegQueryValueKey(Handle,
                                   (LPWSTR) Buffer,
                                   Size,
                                   &CpuSpeed,
                                   &DataLength
                                   );
        NtClose(Handle);
        if (!NT_SUCCESS(Status)) {
            goto CpuCleanup;
        }
    }

    WmipGetSystemInfo(&SysInfo);

    //
    // Create EventTrace record for CPU configuration and write it
    //
    
    SizeNeeded = sizeof(CPU_CONFIG_RECORD) + StringSize;


    CpuConfig = (PCPU_CONFIG_RECORD) WmipGetTraceBuffer(LoggerContext,
                                                NULL,
                                                EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_CPU,
                                                SizeNeeded);

    if (CpuConfig == NULL) {
        Status = STATUS_NO_MEMORY;
        goto CpuCleanup;
    }
    
    CpuConfig->NumberOfProcessors = SysInfo.dwNumberOfProcessors;
    CpuConfig->ProcessorSpeed = CpuSpeed;
    CpuConfig->MemorySize = (ULONG)(((MemStatus.dwTotalPhys + 512) / 1024) + 512) / 1024;
    CpuConfig->PageSize = SysInfo.dwPageSize;
    CpuConfig->AllocationGranularity = SysInfo.dwAllocationGranularity;

    RtlCopyMemory(&CpuConfig->ComputerName, ComputerName, StringSize);

    CpuConfig->ComputerName[StringSize/2] = 0;
    
CpuCleanup:
    if (Buffer != NULL) {
        WmipFree(Buffer);
    }

    return Status;
}


NTSTATUS
WmipGetDiskInfo(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    PUCHAR Buffer = NULL;
    STORAGE_DEVICE_NUMBER Number;
    PMOUNTMGR_MOUNT_POINTS mountPoints;
    MOUNTMGR_MOUNT_POINT mountPoint;
    ULONG returnSize, success;
    SYSTEM_DEVICE_INFORMATION DevInfo;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG NumberOfDisks;
    PWCHAR deviceNameBuffer;
    ULONG i;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatus;

    DISK_GEOMETRY disk_geometry;
    PDISK_CACHE_INFORMATION disk_cache;
    PSCSI_ADDRESS scsi_address;
    PWCHAR KeyName;
    HANDLE              hDisk = INVALID_HANDLE_VALUE;
    UNICODE_STRING      UnicodeName;

    PPHYSICAL_DISK_RECORD Disk;
    PLOGICAL_DISK_EXTENTS LogicalDisk;
    ULONG SizeNeeded;

    Buffer = WmipAlloc(DEFAULT_ALLOC_SIZE);
    if (Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    //  Get the Number of Physical Disks
    //

    RtlZeroMemory(&DevInfo, sizeof(DevInfo));

    Status =   NtQuerySystemInformation(
                    SystemDeviceInformation,
                    &DevInfo, sizeof (DevInfo), NULL);

    if (!NT_SUCCESS(Status)) {
        goto DiskCleanup;
    }

    NumberOfDisks = DevInfo.NumberOfDisks;

    //
    // Open Each Physical Disk and get Disk Layout information
    //


    for (i=0; i < NumberOfDisks; i++) {

        DISK_CACHE_INFORMATION cacheInfo;
        WCHAR               driveBuffer[20];

        HANDLE              PartitionHandle;
        HANDLE KeyHandle;
        ULONG DataLength;

        //
        // Get Partition0 handle to get the Disk layout 
        //

        deviceNameBuffer = (PWCHAR) Buffer;
        swprintf(deviceNameBuffer, L"\\Device\\Harddisk%d\\Partition0", i);

        RtlInitUnicodeString(&UnicodeName, deviceNameBuffer);

        InitializeObjectAttributes(
                   &ObjectAttributes,
                   &UnicodeName,
                   OBJ_CASE_INSENSITIVE,
                   NULL,
                   NULL
                   );
        Status = NtOpenFile(
                &PartitionHandle,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatus,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                );


        if (!NT_SUCCESS(Status)) {
            goto DiskCleanup;
        }

        RtlZeroMemory(&disk_geometry, sizeof(DISK_GEOMETRY));
        // get geomerty information, the caller wants this
        Status = NtDeviceIoControlFile(PartitionHandle,
                       0,
                       NULL,
                       NULL,
                       &IoStatus,
                       IOCTL_DISK_GET_DRIVE_GEOMETRY,
                       NULL,
                       0,
                       &disk_geometry,
                       sizeof (DISK_GEOMETRY)
                       );
        if (!NT_SUCCESS(Status)) {
            NtClose(PartitionHandle);
            goto DiskCleanup;
        }
        scsi_address = (PSCSI_ADDRESS) Buffer;
        Status = NtDeviceIoControlFile(PartitionHandle,
                        0,
                        NULL,
                        NULL,
                        &IoStatus,
                        IOCTL_SCSI_GET_ADDRESS,
                        NULL,
                        0,
                        scsi_address,
                        sizeof (SCSI_ADDRESS)
                        );

        NtClose(PartitionHandle);

        if (!NT_SUCCESS(Status)) {
            goto DiskCleanup;
        }

        //
        // Get Manufacturer's name from Registry
        // We need to get the SCSI Address and then query the Registry with it.
        //

        KeyName = (PWCHAR) Buffer;
        swprintf(KeyName, 
                 L"\\Registry\\Machine\\Hardware\\DeviceMap\\Scsi\\Scsi Port %d\\Scsi Bus %d\\Target ID %d\\Logical Unit Id %d",
                 scsi_address->PortNumber, scsi_address->PathId, scsi_address->TargetId, scsi_address->Lun
                );
        Status = WmipRegOpenKey(KeyName, &KeyHandle);
        if (!NT_SUCCESS(Status)) {
            goto DiskCleanup;
        }
        else {
            ULONG Size = MAXSTR;
            RtlZeroMemory(Buffer, Size);
DiskQuery:
            Status = WmipRegQueryValueKey(KeyHandle,
                                          L"Identifier",
                                          Size,
                                          Buffer, &DataLength);
            if (Status == STATUS_BUFFER_OVERFLOW) {
                WmipFree(Buffer);
                Buffer = WmipAlloc(DataLength);
                if (Buffer == NULL) {
                    return STATUS_NO_MEMORY;
                }
                goto DiskQuery;
            }

            NtClose(KeyHandle);
            if (!NT_SUCCESS(Status) ) {
                goto DiskCleanup;
            }
        }

        //
        // Package all information about this disk and write an event record
        //

        SizeNeeded = sizeof(PHYSICAL_DISK_RECORD) + DataLength;

        Disk = (PPHYSICAL_DISK_RECORD) WmipGetTraceBuffer( LoggerContext, 
                                                           NULL,
                                                           EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_PHYSICALDISK,
                                                           SizeNeeded);

        if (Disk == NULL) {
            Status = STATUS_NO_MEMORY;
            goto DiskCleanup;
        }

        Disk->DiskNumber =  i;
        Disk->BytesPerSector = disk_geometry.BytesPerSector;
        Disk->SectorsPerTrack = disk_geometry.SectorsPerTrack;
        Disk->TracksPerCylinder = disk_geometry.TracksPerCylinder;
        Disk->Cylinders = disk_geometry.Cylinders.QuadPart;
        Disk->SCSIPortNumber = scsi_address->PortNumber;
        Disk->SCSIPathId = scsi_address->PathId;
        Disk->SCSITargetId = scsi_address->TargetId;
        Disk->SCSILun = scsi_address->Lun;

        RtlCopyMemory(Disk->Manufacturer, Buffer, DataLength);
        Disk->Manufacturer[DataLength/2] = 0;

    }

    //
    // Get Logical Disk Information
    //
    wcscpy((LPWSTR)Buffer, MOUNTMGR_DEVICE_NAME);
    RtlInitUnicodeString(&UnicodeName, (LPWSTR)Buffer);
    UnicodeName.MaximumLength = MAXSTR;

    InitializeObjectAttributes(
                    &ObjectAttributes,
                    &UnicodeName,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL );
    Status = NtCreateFile(
                    &hDisk,
                    GENERIC_READ | SYNCHRONIZE,
                    &ObjectAttributes,
                    &IoStatus,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    FILE_SYNCHRONOUS_IO_NONALERT|FILE_NON_DIRECTORY_FILE,
                    NULL, 0);

    if (!NT_SUCCESS(Status) ) {
        goto DiskCleanup;
    }
    RtlZeroMemory(Buffer, 4096);
    RtlZeroMemory(&mountPoint, sizeof(MOUNTMGR_MOUNT_POINT));
    returnSize = 0;
    mountPoints = (PMOUNTMGR_MOUNT_POINTS) &Buffer[0];

    Status = NtDeviceIoControlFile(hDisk,
                    0,
                    NULL,
                    NULL,
                    &IoStatus,
                    IOCTL_MOUNTMGR_QUERY_POINTS,
                    mountPoints,
                    sizeof(MOUNTMGR_MOUNT_POINT),
                    mountPoints,
                    4096
                    );

    if (NT_SUCCESS(Status)) {
        WCHAR name[MAXSTR];
        CHAR OutBuffer[4096];
        PMOUNTMGR_MOUNT_POINT point;
	    UNICODE_STRING VolumePoint;
        PVOLUME_DISK_EXTENTS VolExt;
        PDISK_EXTENT DiskExt;
        ULONG i;
        
        for (i=0; i<mountPoints->NumberOfMountPoints; i++) {
            point = &mountPoints->MountPoints[i];


            if (point->SymbolicLinkNameLength) {
                RtlCopyMemory(name,
                    (PCHAR) mountPoints + point->SymbolicLinkNameOffset,
                    point->SymbolicLinkNameLength);
                name[point->SymbolicLinkNameLength/sizeof(WCHAR)] = 0;
                if (WmipIsVolumeName(name)) {
                    continue;
                }
            }
            if (point->DeviceNameLength) {
                HANDLE hVolume;
                ULONG dwBytesReturned;
                PSTORAGE_DEVICE_NUMBER Number;
                DWORD IErrorMode;

                RtlCopyMemory(name,
                              (PCHAR) mountPoints + point->DeviceNameOffset,
                              point->DeviceNameLength);
                name[point->DeviceNameLength/sizeof(WCHAR)] = 0;

                RtlInitUnicodeString(&UnicodeName, name);
                UnicodeName.MaximumLength = MAXSTR;

            //
            // If the device name does not have the harddisk prefix
            // then it may be a floppy or cdrom and we want avoid 
            // calling NtCreateFile on them.
            //
                if(_wcsnicmp(name,L"\\device\\harddisk",16)) {
                    continue;
                }

                InitializeObjectAttributes(
                        &ObjectAttributes,
                        &UnicodeName,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL );
            //
            // We do not want any pop up dialog here in case we are unable to 
            // access the volume. 
            //
                IErrorMode = WmipSetErrorMode(SEM_FAILCRITICALERRORS|SEM_NOOPENFILEERRORBOX);
                Status = NtCreateFile(
                        &hVolume,
                        GENERIC_READ | SYNCHRONIZE,
                        &ObjectAttributes,
                        &IoStatus,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_OPEN_IF,
                        FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL, 0);
                WmipSetErrorMode(IErrorMode);
                if (!NT_SUCCESS(Status)) {
                    continue;
                }


                RtlZeroMemory(OutBuffer, 4096);
                dwBytesReturned = 0;
                VolExt = (PVOLUME_DISK_EXTENTS) &OutBuffer;

                Status = NtDeviceIoControlFile(hVolume,
                                0,
                                NULL,
                                NULL,
                                &IoStatus,
                                IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                                NULL,
                                0,
                                &OutBuffer, 
                                4096
                                );
               if (NT_SUCCESS(Status) ) {
                    ULONG j;
                    PLOGICAL_DISK_EXTENTS LogicalDisk;
                    ULONG NumberOfExtents = VolExt->NumberOfDiskExtents;
                    SizeNeeded = NumberOfExtents * sizeof(LOGICAL_DISK_EXTENTS);

                    LogicalDisk = (PLOGICAL_DISK_EXTENTS) WmipGetTraceBuffer( LoggerContext, 
                                                           NULL,
                                                           EVENT_TRACE_GROUP_CONFIG + EVENT_TRACE_TYPE_CONFIG_LOGICALDISK,
                                                           SizeNeeded);

                    if (LogicalDisk == NULL) {
                        Status = STATUS_NO_MEMORY;
                    }
                    else {


                        for (j=0; j < NumberOfExtents; j++) {


                            DiskExt = &VolExt->Extents[j];

                            LogicalDisk->DiskNumber = DiskExt->DiskNumber;
                            LogicalDisk->StartingOffset = DiskExt->StartingOffset.QuadPart;
                            LogicalDisk->PartitionSize = DiskExt->ExtentLength.QuadPart;
                            LogicalDisk++;
                        }
                    }
                }
                NtClose(hVolume);
            }
        }
    }
    NtClose(hDisk);

DiskCleanup:
    if (Buffer != NULL) {
        WmipFree(Buffer);
    }
    return Status;
}


//
// This routine records the hardware configuration in the
// logfile during RunDown
//


ULONG
WmipDumpHardwareConfig(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    NTSTATUS Status;

    Status = WmipGetCpuConfig(LoggerContext);

    if (!NT_SUCCESS(Status) )
        return WmipSetNtStatus(Status);

    Status = WmipGetDiskInfo(LoggerContext);

    if (!NT_SUCCESS(Status) )
        return WmipSetNtStatus(Status);

    Status = WmipGetNetworkAdapters(LoggerContext);

    if (!NT_SUCCESS(Status) )
        return WmipSetNtStatus(Status);

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\ntdll\request.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    request.c

Abstract:

    Implements WMI requests to different data providers

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>          // for ntutrl.h
#include <nturtl.h>         // for RTL_CRITICAL_SECTION in winbase.h/wtypes.h
#include "wmiump.h"
#include "evntrace.h"
#include "trcapi.h"
//
// This is the handle to the WMI kernel mode device
HANDLE WmipKMHandle;

//
// This is the one-deep Win32 event queue used to supply events for
// overlapped I/O to the WMI device.
HANDLE WmipWin32Event;


__inline HANDLE WmipAllocEvent(
    void
    )
{
    HANDLE EventHandle;

    EventHandle = (HANDLE)InterlockedExchangePointer((PVOID *)(&WmipWin32Event),
                                                     NULL);
    if (EventHandle == NULL)
    {
        //
        // If event in queue is in use then create a new one
        EventHandle = WmipCreateEventA(NULL, FALSE, FALSE, NULL);
    }
    return(EventHandle);
}

__inline void WmipFreeEvent(
    HANDLE EventHandle
    )
{
    if (InterlockedCompareExchangePointer(&WmipWin32Event,
                                          EventHandle,
                                          NULL) != NULL)
    {
        //
        // If there is already a handle in the event queue then free this
        // handle
        WmipCloseHandle(EventHandle);
    }
}

ULONG WmipSendWmiKMRequest(
    HANDLE DeviceHandle,
    ULONG Ioctl,
    PVOID InBuffer,
    ULONG InBufferSize,
    PVOID OutBuffer,
    ULONG MaxBufferSize,
    ULONG *ReturnSize,
    LPOVERLAPPED Overlapped
    )
/*+++

Routine Description:

    This routine does the work of sending WMI requests to the WMI kernel
    mode device.  Any retry errors returned by the WMI device are handled
    in this routine.

Arguments:

    Ioctl is the IOCTL code to send to the WMI device
    Buffer is the input buffer for the call to the WMI device
    InBufferSize is the size of the buffer passed to the device
    OutBuffer is the output buffer for the call to the WMI device
    MaxBufferSize is the maximum number of bytes that can be written
        into the buffer
    *ReturnSize on return has the actual number of bytes written in buffer
    Overlapped is an option OVERLAPPED struct that is used to make the 
        call async

Return Value:

    ERROR_SUCCESS or an error code
---*/
{
    OVERLAPPED StaticOverlapped;
    ULONG Status;
    BOOL IoctlSuccess;

    WmipEnterPMCritSection();
    if (WmipKMHandle == NULL)
    {
        //
        // If device is not open for then open it now. The
        // handle is closed in the process detach dll callout (DlllMain)
        WmipKMHandle = WmipCreateFileA(WMIDataDeviceName,
                                      GENERIC_READ | GENERIC_WRITE,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL |
                                      FILE_FLAG_OVERLAPPED,
                                      NULL);
        if (WmipKMHandle == (HANDLE)-1)
        {
            WmipKMHandle = NULL;
            WmipLeavePMCritSection();
            return(WmipGetLastError());
        }
    }
    WmipLeavePMCritSection();

    if (Overlapped == NULL)
    {
        //
        // if caller didn't pass an overlapped structure then supply
        // our own and make the call synchronous
        //
        Overlapped = &StaticOverlapped;
    
        Overlapped->hEvent = WmipAllocEvent();
        if (Overlapped->hEvent == NULL)
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    
    if (DeviceHandle == NULL)
    {
        DeviceHandle = WmipKMHandle;
    }

    do
    {
        IoctlSuccess = WmipDeviceIoControl(DeviceHandle,
                              Ioctl,
                              InBuffer,
                              InBufferSize,
                              OutBuffer,
                              MaxBufferSize,
                              ReturnSize,
                              Overlapped);

        if (!IoctlSuccess)
        {
            if (Overlapped == &StaticOverlapped)
            {
                //
                // if the call was successful and we are synchronous then
                // block until the call completes
                //
                if (WmipGetLastError() == ERROR_IO_PENDING)
                {
                    IoctlSuccess = WmipGetOverlappedResult(DeviceHandle,
                                               Overlapped,
                                               ReturnSize,
                                               TRUE);
                }
    
                if (! IoctlSuccess)
                {
                    Status = WmipGetLastError();
                } else {
                    Status = ERROR_SUCCESS;
                }
            } else {
                Status = WmipGetLastError();
            }
        } else {
            Status = ERROR_SUCCESS;
        }
    } while (Status == ERROR_WMI_TRY_AGAIN);

    if (Overlapped == &StaticOverlapped)
    {
        WmipFreeEvent(Overlapped->hEvent);
    }
    
    return(Status);
}

ULONG IoctlActionCode[WmiExecuteMethodCall+1] =
{
    IOCTL_WMI_QUERY_ALL_DATA,
    IOCTL_WMI_QUERY_SINGLE_INSTANCE,
    IOCTL_WMI_SET_SINGLE_INSTANCE,
    IOCTL_WMI_SET_SINGLE_ITEM,
    IOCTL_WMI_ENABLE_EVENT,
    IOCTL_WMI_DISABLE_EVENT,
    IOCTL_WMI_ENABLE_COLLECTION,
    IOCTL_WMI_DISABLE_COLLECTION,
    IOCTL_WMI_GET_REGINFO,
    IOCTL_WMI_EXECUTE_METHOD
};

ULONG WmipSendWmiRequest(
    ULONG ActionCode,
    PWNODE_HEADER Wnode,
    ULONG WnodeSize,
    PVOID OutBuffer,
    ULONG MaxWnodeSize,
    ULONG *RetSize
    )
/*+++

Routine Description:

    This routine does the work of sending WMI requests to the appropriate
    data provider. Note that this routine is called while the GuidHandle's
    critical section is held.

Arguments:


Return Value:

---*/
{
    ULONG Status = ERROR_SUCCESS;
    ULONG Ioctl;
    ULONG BusyRetries;

    //
    // Send the query down to kernel mode for execution
    //
    WmipAssert(ActionCode <= WmiExecuteMethodCall);
    Ioctl = IoctlActionCode[ActionCode];
    Status = WmipSendWmiKMRequest(NULL,
                                      Ioctl,
                                      Wnode,
                                      WnodeSize,
                                      OutBuffer,
                                      MaxWnodeSize,
                                      RetSize,
                                      NULL);
    return(Status);
}

ULONG WmipConvertWADToAnsi(
    PWNODE_ALL_DATA Wnode
    )
/*+++

Routine Description:

    This routine will convert the instance names in a WNODE_ALL_DATA to
    ansi. The conversion is done in place since we can assume that ansi
    strings are no longer than unicode strings.

Arguments:

    Wnode is the WNODE_ALL_DATA whose instance names are to be converted to
        ANSI

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    ULONG i;
    ULONG Linkage;
    ULONG InstanceCount;
    PULONG InstanceNameOffsets;
    PWCHAR Ptr;
    ULONG Status = ERROR_SUCCESS;

    WmipAssert(!(Wnode->WnodeHeader.Flags & WNODE_FLAG_ANSI_INSTANCENAMES));

    do
    {
        Wnode->WnodeHeader.Flags |= WNODE_FLAG_ANSI_INSTANCENAMES;

        InstanceCount = Wnode->InstanceCount;
        InstanceNameOffsets = (PULONG)(((PUCHAR)Wnode) +
                                            Wnode->OffsetInstanceNameOffsets);
        for (i = 0; i < InstanceCount; i++)
        {
            Ptr = (PWCHAR)(((PUCHAR)Wnode) + InstanceNameOffsets[i]);
            try
            {
                Status = WmipCountedUnicodeToCountedAnsi(Ptr, (PCHAR)Ptr);
            } except(EXCEPTION_EXECUTE_HANDLER) {
//                Wnode->WnodeHeader.Flags |= WNODE_FLAG_INVALID;
                return(ERROR_SUCCESS);
            }
            if (Status != ERROR_SUCCESS)
            {
                WmipSetLastError(Status);
                goto Done;
            }
        }

        Linkage = Wnode->WnodeHeader.Linkage;
        Wnode = (PWNODE_ALL_DATA)(((PUCHAR)Wnode) + Linkage);
    } while (Linkage != 0);


Done:
    return(Status);
}

/*ULONG WmipQueryPidEntry(
    IN  GUID Guid,
    IN  ULONG Pid,
    OUT BOOLEAN *PidEntry
   )
{
    ULONG Status;
    ULONG ReturnSize;
    ULONG Size = sizeof(QUERYPIDENTRY);
    PQUERYPIDENTRY QueryPidEntry = NULL;


    WmipInitProcessHeap();

    QueryPidEntry = WmipAlloc(Size);

    if(!QueryPidEntry)
        return STATUS_NO_MEMORY;

    QueryPidEntry->Guid      = Guid;
    QueryPidEntry->Pid       = Pid;
    QueryPidEntry->PidEntry  = FALSE;

 	Status = WmipSendWmiKMRequest(NULL,
                                 IOCTL_WMI_QUERY_PIDENTRY,
                                 QueryPidEntry,
                                 Size,
                                 QueryPidEntry,
                                 Size,
                                 &ReturnSize,
                                 NULL);
    							 
    if (Status == ERROR_SUCCESS){
        *PidEntry = QueryPidEntry->PidEntry;
    }

    WmipFree(QueryPidEntry);
    
    return Status;
}*/

ULONG WmipRegisterGuids(
    IN LPGUID MasterGuid,
    IN ULONG RegistrationCookie,    
    IN PWMIREGINFOW RegInfo,
    IN ULONG GuidCount,
    OUT PTRACEGUIDMAP *GuidMapHandle,
    OUT ULONG64 *LoggerContext,
    OUT HANDLE *RegistrationHandle
	)
{
	ULONG Status;
	ULONG SizeNeeded, InSizeNeeded, OutSizeNeeded;
    WCHAR GuidObjectName[WmiGuidObjectNameLength+1];
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING GuidString;
	PWMIREGREQUEST WmiRegRequest;
	PTRACEGUIDMAP TraceGuidMap;
	PUCHAR Buffer;
	PUCHAR RegInfoBuffer;
	PWMIREGRESULTS WmiRegResults;
	ULONG ReturnSize;
	ULONG TraceGuidMapSize;
	
	//
	// Allocate a buffer large enough for all in and out parameters
	//
	TraceGuidMapSize = GuidCount * sizeof(TRACEGUIDMAP);
	InSizeNeeded = sizeof(WMIREGREQUEST) + RegInfo->BufferSize;
    OutSizeNeeded = TraceGuidMapSize + sizeof(WMIREGRESULTS);
	if (InSizeNeeded > OutSizeNeeded)
	{
		SizeNeeded = InSizeNeeded;
	} else {
		SizeNeeded = OutSizeNeeded;
	}
	
	Buffer = WmipAlloc(SizeNeeded);
	
	if (Buffer != NULL)
	{
		//
		// Build the object attributes
		//
        WmiRegRequest = (PWMIREGREQUEST)Buffer;
    	WmiRegRequest->ObjectAttributes = &ObjectAttributes;
		WmiRegRequest->GuidCount = GuidCount;
    	RegInfoBuffer = Buffer + sizeof(WMIREGREQUEST);
    	
    	Status = WmipBuildGuidObjectAttributes(MasterGuid,
                                               &ObjectAttributes,
                                               &GuidString,
                                               GuidObjectName);
    									   
        if (Status == ERROR_SUCCESS)
        {
			WmiRegRequest->Cookie = RegistrationCookie;
    	    memcpy(RegInfoBuffer, RegInfo, RegInfo->BufferSize);
     	    Status = WmipSendWmiKMRequest(NULL,
                                         IOCTL_WMI_REGISTER_GUIDS,
                                         Buffer,
                                         InSizeNeeded,
                                         Buffer,
                                         OutSizeNeeded,
                                         &ReturnSize,
                                         NULL);
    								 
            if (Status == ERROR_SUCCESS)
    		{
				//
				// Successful call, return the out parameters
				//
				WmiRegResults = (PWMIREGRESULTS)((PUCHAR)Buffer + TraceGuidMapSize);
    			*RegistrationHandle = WmiRegResults->RequestHandle.Handle;
				*LoggerContext = WmiRegResults->LoggerContext;
				*GuidMapHandle = (PTRACEGUIDMAP)Buffer;
    		}
			
            //
			// Note that we do not free Buffer in this call. This will be
			// freed by the caller since it is returned in *GuidMapHandle
			//

        }
	} else {
		Status = ERROR_NOT_ENOUGH_MEMORY;
	}
	
	return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\ntdll\tracelib.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tracelib.c

Abstract:

    Private trace libraries and stubs that allows user-mode to reside in NTDLL.

Author:

    15-Aug-2000 JeePang

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "trcapi.h"
#include "tracelib.h"

/*ONG
WmipSetDosError(
    IN ULONG DosError
    )
{
    WmipSetLastError(DosError);
    return DosError;
}*/

ULONG
WmipSetNtStatus(
    IN NTSTATUS Status
    )
{
    ULONG ErrorCode = RtlNtStatusToDosError(Status);
    WmipSetLastError(ErrorCode);
    return ErrorCode;
}

PVOID
WmipMemReserve(
    IN SIZE_T   Size
    )
{
    NTSTATUS Status;
    PVOID    lpAddress = NULL;

    try {
        Status = NtAllocateVirtualMemory(
                    NtCurrentProcess(),
                    &lpAddress,
                    0,
                    &Size,
                    MEM_RESERVE,
                    PAGE_READWRITE);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
    if (NT_SUCCESS(Status)) {
        return lpAddress;
    }
    else {
        WmipSetNtStatus(Status);
        return NULL;
    }
}

PVOID
WmipMemCommit(
    IN PVOID Buffer,
    IN SIZE_T Size
    )
{
    NTSTATUS Status;

    try {
        Status = NtAllocateVirtualMemory(
                    NtCurrentProcess(),
                    &Buffer,
                    0,
                    &Size,
                    MEM_COMMIT,
                    PAGE_READWRITE);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
    if (NT_SUCCESS(Status)) {
        return Buffer;
    }
    else {
        WmipSetNtStatus(Status);
        return NULL;
    }
}

ULONG
WmipMemFree(
    IN PVOID Buffer
    )
{
    NTSTATUS Status;
    SIZE_T Size = 0;
    HANDLE hProcess = NtCurrentProcess();

    if (Buffer == NULL) {
        WmipSetDosError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    try {
        Status = NtFreeVirtualMemory( hProcess, &Buffer, &Size, MEM_RELEASE);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
    if (NT_SUCCESS(Status)) {
        return TRUE;
    }
    else {
        if (Status == STATUS_INVALID_PAGE_PROTECTION) {
            if (RtlFlushSecureMemoryCache(Buffer, Size)) {
                Status = NtFreeVirtualMemory(
                            hProcess, Buffer, &Size, MEM_RELEASE);
                if (NT_SUCCESS(Status)) {
                    return TRUE;
                }
            }
        }
        WmipSetNtStatus(Status);
        return FALSE;
    }
}

HANDLE
WmipCreateFile(
    LPCWSTR     lpFileName,
    DWORD       dwDesiredAccess,
    DWORD       dwShareMode,
    DWORD       dwCreationDisposition,
    DWORD       dwCreateFlags
    )
{
    UNICODE_STRING FileName;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    SECURITY_QUALITY_OF_SERVICE SQos;

    RtlInitUnicodeString(&FileName, lpFileName);
    if (!RtlDosPathNameToNtPathName_U(
                lpFileName,
                &FileName,
                NULL,
                &RelativeName)) {
        WmipSetDosError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
    }
    FreeBuffer = FileName.Buffer;
    if (RelativeName.RelativeName.Length) {
        FileName = *(PUNICODE_STRING) &RelativeName.RelativeName;
    }
    else {
        RelativeName.ContainingDirectory = NULL;
    }
    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL,
        );
    SQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SQos.ImpersonationLevel = SecurityImpersonation;
    SQos.EffectiveOnly = TRUE;
    SQos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    ObjectAttributes.SecurityQualityOfService = &SQos;

    Status = NtCreateFile(
                &FileHandle,
                (ACCESS_MASK) dwDesiredAccess
                    | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &ObjectAttributes,
                &Iosb,
                NULL,
                FILE_ATTRIBUTE_NORMAL
                    & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                dwCreationDisposition,
                dwCreateFlags | FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0);
    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_OBJECT_NAME_COLLISION) {
            WmipSetDosError(ERROR_FILE_EXISTS);
        }
        else {
            WmipSetNtStatus(Status);
        }
        return INVALID_HANDLE_VALUE;
    }
    if (lpFileName != FreeBuffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    }
    return FileHandle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\ntdll\trcapi.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:



Abstract:



Author:



Revision History:

--*/


#include "basedll.h"
#include "mountmgr.h"
#include "aclapi.h"
#include "winefs.h"


#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement 
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedCompareExchange _InterlockedCompareExchange


NTSTATUS
WmipUuidCreate(
    OUT UUID *Uuid
    );

NTSTATUS 
WmipRegOpenKey(
    IN LPWSTR lpKeyName,
    OUT PHANDLE KeyHandle
    );

DWORD 
WmipGetLastError(
	VOID
	);

VOID 
WmipSetLastError(
	DWORD 
	dwErrCode
	);


DWORD
WINAPI
WmipGetTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    );

BOOL
WINAPI
WmipGetVersionExW(
    LPOSVERSIONINFOW lpVersionInformation
    );

BOOL
WINAPI
WmipGetVersionExA(
    LPOSVERSIONINFOA lpVersionInformation
    );

PUNICODE_STRING
WmipBaseIsThisAConsoleName(
    PCUNICODE_STRING FileNameString,
    DWORD dwDesiredAccess
    );

ULONG
WmipBaseSetLastNTError(
    IN NTSTATUS Status
    );


PUNICODE_STRING
WmipBasep8BitStringToStaticUnicodeString(
    IN LPCSTR lpSourceString
    );


HANDLE
WINAPI
WmipCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

HANDLE
WmipBaseGetNamedObjectDirectory(
    VOID
    );



POBJECT_ATTRIBUTES
WmipBaseFormatObjectAttributes(
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    IN PSECURITY_ATTRIBUTES SecurityAttributes,
    IN PUNICODE_STRING ObjectName
    );



HANDLE
WINAPI
WmipCreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );


HANDLE
APIENTRY
WmipCreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );


HANDLE
APIENTRY
WmipCreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    );

DWORD
WINAPI
WmipSetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    PLONG lpDistanceToMoveHigh,
    DWORD dwMoveMethod
    );


BOOL
WINAPI
WmipReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    );



BOOL
WmipCloseHandle(
    HANDLE hObject
    );

DWORD
APIENTRY
WmipWaitForSingleObjectEx(
    HANDLE hHandle,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );

BOOL
WINAPI
WmipGetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    );

PLARGE_INTEGER
WmipBaseFormatTimeOut(
    OUT PLARGE_INTEGER TimeOut,
    IN DWORD Milliseconds
    );

DWORD
WmipWaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
    );

BOOL
WINAPI
WmipDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    );



BOOL
WINAPI
WmipCancelIo(
    HANDLE hFile
    );

VOID
APIENTRY
WmipExitThread(
    DWORD dwExitCode
    );



DWORD
WINAPI
WmipGetCurrentProcessId(
    VOID
    );

DWORD
APIENTRY
WmipGetCurrentThreadId(
    VOID
    );

HANDLE
WINAPI
WmipGetCurrentProcess(
    VOID
    );

BOOL
WmipSetEvent(
    HANDLE hEvent
    );

VOID
WINAPI
WmipGetSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
    );

VOID
WINAPI
WmipGlobalMemoryStatus(
    LPMEMORYSTATUS lpBuffer
    );

DWORD
APIENTRY
WmipWaitForMultipleObjectsEx(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );

VOID
BaseProcessStart(
    PPROCESS_START_ROUTINE lpStartAddress
    );

VOID
BaseThreadStart(
    IN LPTHREAD_START_ROUTINE lpStartAddress,
    IN LPVOID lpParameter
    );

HANDLE
APIENTRY
WmipCreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    );

DWORD
APIENTRY
WmipSleepEx(
    DWORD dwMilliseconds,
    BOOL bAlertable
    );

VOID
WmipSleep(
    DWORD dwMilliseconds
    );

BOOL
APIENTRY
WmipSetThreadPriority(
    HANDLE hThread,
    int nPriority
    );

BOOL
WmipDuplicateHandle(
    HANDLE hSourceProcessHandle,
    HANDLE hSourceHandle,
    HANDLE hTargetProcessHandle,
    LPHANDLE lpTargetHandle,
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwOptions
    );


UINT
WmipSetErrorMode(
    UINT uMode
    );

UINT
WmipGetErrorMode();


ULONG WmipUnicodeToAnsi(
    LPCWSTR pszW,
    LPSTR * ppszA,
    ULONG *AnsiSizeInBytes OPTIONAL
    );

ULONG WmipAnsiToUnicode(
    LPCSTR pszA,
    LPWSTR * ppszW
    );

HANDLE
APIENTRY
WmipDuplicateConsoleHandle(
    IN HANDLE hSourceHandle,
    IN DWORD dwDesiredAccess,
    IN BOOL bInheritHandle,
    IN DWORD dwOptions
    );

USHORT
WmipGetCurrentExeName( 
	OUT LPWSTR Buffer,
    IN ULONG BufferLength
	);

DWORD
WmipTlsAlloc(VOID);

LPVOID
WmipTlsGetValue(DWORD dwTlsIndex);

BOOL
WmipTlsSetValue(DWORD dwTlsIndex,LPVOID lpTlsValue);

BOOL
WmipTlsFree(DWORD dwTlsIndex);

/*
__int64
WmipGetCycleCount();*/

DWORD
APIENTRY
WmipGetFullPathNameA(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );

ULONG
WmipSetNtStatus(
    IN NTSTATUS Status
    );

__inline 
ULONG
WmipSetDosError(
    IN ULONG DosError
    )
{
    WmipSetLastError(DosError);
    return DosError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\ntdll\tracelib.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tracelib.h

Abstract:

    Private headers for user-mode trace library

Author:

    15-Aug-2000 JeePang

Revision History:

--*/

#ifndef _TRACELIB_H_
#define _TRACELIB_H_

#define WmipNtStatusToDosError(Status) ((ULONG)((Status == STATUS_SUCCESS)?ERROR_SUCCESS:RtlNtStatusToDosError(Status)))

#if defined(_IA64_)
#include <ia64reg.h>
#endif

//
// NTDLL cannot call GetSystemTimeAsFileTime
//
__inline __int64 WmipGetSystemTime()
{
    LARGE_INTEGER SystemTime;

    //
    // Read system time from shared region.
    //

    do {
        SystemTime.HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        SystemTime.LowPart = USER_SHARED_DATA->SystemTime.LowPart;
    } while (SystemTime.HighPart != USER_SHARED_DATA->SystemTime.High2Time);

    return SystemTime.QuadPart;
}

//
// GetCycleCounts
//
// Since we do not want to make a kernel mode  transition to get the
// thread CPU Times, we settle for just getting the CPU Cycle counts.
// We use the following macros from BradW to get the CPU cycle count.
// This method may be inaccurate if the clocks are not synchronized
// between processors.
//

#if defined(_X86_)
__inline
LONGLONG
WmipGetCycleCount(
    )
{
    __asm{
        RDTSC
    }
}
#elif defined(_AMD64_)
#define WmipGetCycleCount() ReadTimeStampCounter()
#elif defined(_IA64_)
#define WmipGetCycleCount() __getReg(CV_IA64_ApITC)
#else
#error "perf: a target architecture must be defined."
#endif


PVOID
WmipMemReserve(
    IN SIZE_T Size
    );

PVOID
WmipMemCommit(
    IN PVOID Buffer,
    IN SIZE_T Size
    );

ULONG
WmipMemFree(
    IN PVOID Buffer
    );

HANDLE
WmipCreateFile(
    LPCWSTR     lpFileName,
    DWORD       dwDesiredAccess,
    DWORD       dwShareMode,
    DWORD       dwCreationDisposition,
    DWORD       dwCreateFlags
    );

NTSTATUS
WmipGetCpuSpeed(
    OUT DWORD* CpuNum,
    OUT DWORD* CpuSpeed
    );

#endif // _TRACELIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\proppage\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wmiprop.rc
//
#define IDC_PROPERTY_LISTBOX            1001
#define IDC_DATA_SPIN                   1002
#define IDC_DATA_EDIT                   1003
#define IDC_DATA_COMBO                  1004
#define IDC_DATA_BUTTON                 1005
#define IDC_ARRAY_EDIT                  1006
#define IDC_ARRAY_SPIN                  1007
#define IDC_DATA_CHECK                  1008
#define IDC_DESCRIPTION_TEXT            1009
#define IDC_ARRAY_TEXT                  1010
#define IDC_ARRAY_STATIC                1011
#define ID_WMI_PROPPAGE                 3400
#define IDC_WMI_CONNECT_ERR             3401
#define IDC_WMI_EMBEDDED_OK             3402
#define IDC_WMI_EMBEDDED_CANCEL         3403
#define IDS_WMI_VALIDATION_ERROR        3500


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\ntdll\trcapi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    trcapi.c

Abstract:

    This module contains implementations of win32 api's used in wmi files.

Author:


Revision History:

--*/

#include <nt.h>
#include "wmiump.h"
#include "trcapi.h"

DWORD g_dwLastErrorToBreakOn = ERROR_SUCCESS;
UNICODE_STRING BasePathVariableName = RTL_CONSTANT_STRING(L"PATH");

#define TLS_MASK 0x80000000
#define TMP_TAG 0
#define IsActiveConsoleSession() (USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId)

#if defined(_WIN64) || defined(BUILD_WOW6432)
SYSTEM_BASIC_INFORMATION SysInfo;
#endif


extern BOOLEAN CsrServerProcess;

DWORD
WmipGetLastError(
    VOID
    )

/*++

Routine Description:

    This function returns the most recent error code set by a Win32 API
    call.  Applications should call this function immediately after a
    Win32 API call returns a failure indications (e.g.  FALSE, NULL or
    -1) to determine the cause of the failure.

    The last error code value is a per thread field, so that multiple
    threads do not overwrite each other's last error code value.

Arguments:

    None.

Return Value:

    The return value is the most recent error code as set by a Win32 API
    call.

--*/

{
    return (DWORD)NtCurrentTeb()->LastErrorValue;
}

VOID
WmipSetLastError(
    DWORD dwErrCode
    )

/*++

Routine Description:

    This function set the most recent error code and error string in per
    thread storage.  Win32 API functions call this function whenever
    they return a failure indication (e.g.  FALSE, NULL or -1).
    This function
    is not called by Win32 API function calls that are successful, so
    that if three Win32 API function calls are made, and the first one
    fails and the second two succeed, the error code and string stored
    by the first one are still available after the second two succeed.

    Applications can retrieve the values saved by this function using
    WmipGetLastError.  The use of this function is optional, as an
    application need only call if it is interested in knowing the
    specific reason for an API function failure.

    The last error code value is kept in thread local storage so that
    multiple threads do not overwrite each other's values.

Arguments:

    dwErrCode - Specifies the error code to store in per thread storage
        for the current thread.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    PTEB Teb = NtCurrentTeb();

    if ((g_dwLastErrorToBreakOn != ERROR_SUCCESS) &&
        (dwErrCode == g_dwLastErrorToBreakOn)) {
        DbgBreakPoint();
    }

    // make write breakpoints to this field more meaningful by only writing to it when
    // the value changes.
    if (Teb->LastErrorValue != dwErrCode) {
        Teb->LastErrorValue = dwErrCode;
    }
}

DWORD
WINAPI
WmipGetTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    )

/*++

Routine Description:

    This function allows an application to get the current timezone
    parameters These parameters control the Universal time to Local time
    translations.

    All UTC time to Local time translations are based on the following
    formula:

        UTC = LocalTime + Bias

    The return value of this function is the systems best guess of
    the current time zone parameters. This is one of:

        - Unknown

        - Standard Time

        - Daylight Savings Time

    If SetTimeZoneInformation was called without the transition date
    information, Unknown is returned, but the currect bias is used for
    local time translation.  Otherwise, the system will correctly pick
    either daylight savings time or standard time.

    The information returned by this API is identical to the information
    stored in the last successful call to SetTimeZoneInformation.  The
    exception is the Bias field returns the current Bias value in

Arguments:

    lpTimeZoneInformation - Supplies the address of the time zone
        information structure.

Return Value:

    TIME_ZONE_ID_UNKNOWN - The system can not determine the current
        timezone.  This is usually due to a previous call to
        SetTimeZoneInformation where only the Bias was supplied and no
        transition dates were supplied.

    TIME_ZONE_ID_STANDARD - The system is operating in the range covered
        by StandardDate.

    TIME_ZONE_ID_DAYLIGHT - The system is operating in the range covered
        by DaylightDate.

    0xffffffff - The operation failed.  Extended error status is
        available using WmipGetLastError.

--*/
{
    RTL_TIME_ZONE_INFORMATION tzi;
    NTSTATUS Status;

    //
    // get the timezone data from the system
    // If it's terminal server session use client time zone

        Status = NtQuerySystemInformation(
                    SystemCurrentTimeZoneInformation,
                    &tzi,
                    sizeof(tzi),
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            WmipBaseSetLastNTError(Status);
            return 0xffffffff;
            }


        lpTimeZoneInformation->Bias         = tzi.Bias;
        lpTimeZoneInformation->StandardBias = tzi.StandardBias;
        lpTimeZoneInformation->DaylightBias = tzi.DaylightBias;

        RtlMoveMemory(&lpTimeZoneInformation->StandardName,&tzi.StandardName,sizeof(tzi.StandardName));
        RtlMoveMemory(&lpTimeZoneInformation->DaylightName,&tzi.DaylightName,sizeof(tzi.DaylightName));

        lpTimeZoneInformation->StandardDate.wYear         = tzi.StandardStart.Year        ;
        lpTimeZoneInformation->StandardDate.wMonth        = tzi.StandardStart.Month       ;
        lpTimeZoneInformation->StandardDate.wDayOfWeek    = tzi.StandardStart.Weekday     ;
        lpTimeZoneInformation->StandardDate.wDay          = tzi.StandardStart.Day         ;
        lpTimeZoneInformation->StandardDate.wHour         = tzi.StandardStart.Hour        ;
        lpTimeZoneInformation->StandardDate.wMinute       = tzi.StandardStart.Minute      ;
        lpTimeZoneInformation->StandardDate.wSecond       = tzi.StandardStart.Second      ;
        lpTimeZoneInformation->StandardDate.wMilliseconds = tzi.StandardStart.Milliseconds;

        lpTimeZoneInformation->DaylightDate.wYear         = tzi.DaylightStart.Year        ;
        lpTimeZoneInformation->DaylightDate.wMonth        = tzi.DaylightStart.Month       ;
        lpTimeZoneInformation->DaylightDate.wDayOfWeek    = tzi.DaylightStart.Weekday     ;
        lpTimeZoneInformation->DaylightDate.wDay          = tzi.DaylightStart.Day         ;
        lpTimeZoneInformation->DaylightDate.wHour         = tzi.DaylightStart.Hour        ;
        lpTimeZoneInformation->DaylightDate.wMinute       = tzi.DaylightStart.Minute      ;
        lpTimeZoneInformation->DaylightDate.wSecond       = tzi.DaylightStart.Second      ;
        lpTimeZoneInformation->DaylightDate.wMilliseconds = tzi.DaylightStart.Milliseconds;

        return USER_SHARED_DATA->TimeZoneId;
}

BOOL
WINAPI
WmipGetVersionExW(
    LPOSVERSIONINFOW lpVersionInformation
    )
{
    PPEB Peb;
    NTSTATUS Status;

    if (lpVersionInformation->dwOSVersionInfoSize != sizeof( OSVERSIONINFOEXW ) &&
        lpVersionInformation->dwOSVersionInfoSize != sizeof( *lpVersionInformation )
       ) {
        WmipSetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
        }
    Status = RtlGetVersion(lpVersionInformation);
    if (Status == STATUS_SUCCESS) {
        Peb = NtCurrentPeb();
        if (Peb->CSDVersion.Buffer)
            wcscpy( lpVersionInformation->szCSDVersion, Peb->CSDVersion.Buffer );
        if (lpVersionInformation->dwOSVersionInfoSize ==
                                            sizeof( OSVERSIONINFOEXW))
            ((POSVERSIONINFOEXW)lpVersionInformation)->wReserved =
                                        (UCHAR)BaseRCNumber;
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL
WINAPI
WmipGetVersionExA(
    LPOSVERSIONINFOA lpVersionInformation
    )
{
    OSVERSIONINFOEXW VersionInformationU;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;

    if (lpVersionInformation->dwOSVersionInfoSize != sizeof( OSVERSIONINFOEXA ) &&
        lpVersionInformation->dwOSVersionInfoSize != sizeof( *lpVersionInformation )
       ) {
        WmipSetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
        }

    VersionInformationU.dwOSVersionInfoSize = sizeof( VersionInformationU );
    if (WmipGetVersionExW( (LPOSVERSIONINFOW)&VersionInformationU )) {
        lpVersionInformation->dwMajorVersion = VersionInformationU.dwMajorVersion;
        lpVersionInformation->dwMinorVersion = VersionInformationU.dwMinorVersion;
        lpVersionInformation->dwBuildNumber  = VersionInformationU.dwBuildNumber;
        lpVersionInformation->dwPlatformId   = VersionInformationU.dwPlatformId;
        if (lpVersionInformation->dwOSVersionInfoSize == sizeof( OSVERSIONINFOEXA )) {
            ((POSVERSIONINFOEXA)lpVersionInformation)->wServicePackMajor = VersionInformationU.wServicePackMajor;
            ((POSVERSIONINFOEXA)lpVersionInformation)->wServicePackMinor = VersionInformationU.wServicePackMinor;
            ((POSVERSIONINFOEXA)lpVersionInformation)->wSuiteMask = VersionInformationU.wSuiteMask;
            ((POSVERSIONINFOEXA)lpVersionInformation)->wProductType = VersionInformationU.wProductType;
            ((POSVERSIONINFOEXA)lpVersionInformation)->wReserved = VersionInformationU.wReserved;
            }

        AnsiString.Buffer = lpVersionInformation->szCSDVersion;
        AnsiString.Length = 0;
        AnsiString.MaximumLength = sizeof( lpVersionInformation->szCSDVersion );

        RtlInitUnicodeString( &UnicodeString, VersionInformationU.szCSDVersion );
        Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                               &UnicodeString,
                                               FALSE
                                             );
        if (NT_SUCCESS( Status )) {
            return TRUE;
            }
        else {
            return FALSE;
            }
        }
    else {
        return FALSE;
        }
}



ULONG
WmipBaseSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    WmipSetLastError( dwErrorCode );
    return( dwErrorCode );
}



PUNICODE_STRING
WmipBasep8BitStringToStaticUnicodeString(
    IN LPCSTR lpSourceString
    )

/*++

Routine Description:

    Captures and converts a 8-bit (OEM or ANSI) string into the Teb Static
    Unicode String

Arguments:

    lpSourceString - string in OEM or ANSI

Return Value:

    Pointer to the Teb static string if conversion was successful, NULL
    otherwise.  If a failure occurred, the last error is set.

--*/

{
    PUNICODE_STRING StaticUnicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    //
    //  Get pointer to static per-thread string
    //

    StaticUnicode = &NtCurrentTeb()->StaticUnicodeString;

    //
    //  Convert input string into unicode string
    //

    RtlInitAnsiString( &AnsiString, lpSourceString );
    //Status = Basep8BitStringToUnicodeString( StaticUnicode, &AnsiString, FALSE );
	Status = RtlAnsiStringToUnicodeString( StaticUnicode, &AnsiString, FALSE );

    //
    //  If we couldn't convert the string
    //

    if ( !NT_SUCCESS( Status ) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            WmipSetLastError( ERROR_FILENAME_EXCED_RANGE );
        } else {
            WmipBaseSetLastNTError( Status );
        }
        return NULL;
    } else {
        return StaticUnicode;
    }
}

HANDLE
WINAPI
WmipCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )

/*++

Routine Description:

    A file can be created, opened, or truncated, and a handle opened to
    access the new file using CreateFile.

    This API is used to create or open a file and obtain a handle to it
    that allows reading data, writing data, and moving the file pointer.

    This API allows the caller to specify the following creation
    dispositions:

      - Create a new file and fail if the file exists ( CREATE_NEW )

      - Create a new file and succeed if it exists ( CREATE_ALWAYS )

      - Open an existing file ( OPEN_EXISTING )

      - Open and existing file or create it if it does not exist (
        OPEN_ALWAYS )

      - Truncate and existing file ( TRUNCATE_EXISTING )

    If this call is successful, a handle is returned that has
    appropriate access to the specified file.

    If as a result of this call, a file is created,

      - The attributes of the file are determined by the value of the
        FileAttributes parameter or'd with the FILE_ATTRIBUTE_ARCHIVE bit.

      - The length of the file will be set to zero.

      - If the hTemplateFile parameter is specified, any extended
        attributes associated with the file are assigned to the new file.

    If a new file is not created, then the hTemplateFile is ignored as
    are any extended attributes.

    For DOS based systems running share.exe the file sharing semantics
    work as described above.  Without share.exe no share level
    protection exists.

    This call is logically equivalent to DOS (int 21h, function 5Bh), or
    DOS (int 21h, function 3Ch) depending on the value of the
    FailIfExists parameter.

Arguments:

    lpFileName - Supplies the file name of the file to open.  Depending on
        the value of the FailIfExists parameter, this name may or may
        not already exist.

    dwDesiredAccess - Supplies the caller's desired access to the file.

        DesiredAccess Flags:

        GENERIC_READ - Read access to the file is requested.  This
            allows data to be read from the file and the file pointer to
            be modified.

        GENERIC_WRITE - Write access to the file is requested.  This
            allows data to be written to the file and the file pointer to
            be modified.

    dwShareMode - Supplies a set of flags that indicates how this file is
        to be shared with other openers of the file.  A value of zero
        for this parameter indicates no sharing of the file, or
        exclusive access to the file is to occur.

        ShareMode Flags:

        FILE_SHARE_READ - Other open operations may be performed on the
            file for read access.

        FILE_SHARE_WRITE - Other open operations may be performed on the
            file for write access.

    lpSecurityAttributes - An optional parameter that, if present, and
        supported on the target file system supplies a security
        descriptor for the new file.

    dwCreationDisposition - Supplies a creation disposition that
        specifies how this call is to operate.  This parameter must be
        one of the following values.

        dwCreationDisposition Value:

        CREATE_NEW - Create a new file.  If the specified file already
            exists, then fail.  The attributes for the new file are what
            is specified in the dwFlagsAndAttributes parameter or'd with
            FILE_ATTRIBUTE_ARCHIVE.  If the hTemplateFile is specified,
            then any extended attributes associated with that file are
            propogated to the new file.

        CREATE_ALWAYS - Always create the file.  If the file already
            exists, then it is overwritten.  The attributes for the new
            file are what is specified in the dwFlagsAndAttributes
            parameter or'd with FILE_ATTRIBUTE_ARCHIVE.  If the
            hTemplateFile is specified, then any extended attributes
            associated with that file are propogated to the new file.

        OPEN_EXISTING - Open the file, but if it does not exist, then
            fail the call.

        OPEN_ALWAYS - Open the file if it exists.  If it does not exist,
            then create the file using the same rules as if the
            disposition were CREATE_NEW.

        TRUNCATE_EXISTING - Open the file, but if it does not exist,
            then fail the call.  Once opened, the file is truncated such
            that its size is zero bytes.  This disposition requires that
            the caller open the file with at least GENERIC_WRITE access.

    dwFlagsAndAttributes - Specifies flags and attributes for the file.
        The attributes are only used when the file is created (as
        opposed to opened or truncated).  Any combination of attribute
        flags is acceptable except that all other attribute flags
        override the normal file attribute, FILE_ATTRIBUTE_NORMAL.  The
        FILE_ATTRIBUTE_ARCHIVE flag is always implied.

        dwFlagsAndAttributes Flags:

        FILE_ATTRIBUTE_NORMAL - A normal file should be created.

        FILE_ATTRIBUTE_READONLY - A read-only file should be created.

        FILE_ATTRIBUTE_HIDDEN - A hidden file should be created.

        FILE_ATTRIBUTE_SYSTEM - A system file should be created.

        FILE_FLAG_WRITE_THROUGH - Indicates that the system should
            always write through any intermediate cache and go directly
            to the file.  The system may still cache writes, but may not
            lazily flush the writes.

        FILE_FLAG_OVERLAPPED - Indicates that the system should initialize
            the file so that ReadFile and WriteFile operations that may
            take a significant time to complete will return ERROR_IO_PENDING.
            An event will be set to the signalled state when the operation
            completes. When FILE_FLAG_OVERLAPPED is specified the system will
            not maintain the file pointer. The position to read/write from
            is passed to the system as part of the OVERLAPPED structure
            which is an optional parameter to ReadFile and WriteFile.

        FILE_FLAG_NO_BUFFERING - Indicates that the file is to be opened
            with no intermediate buffering or caching done by the
            system.  Reads and writes to the file must be done on sector
            boundries.  Buffer addresses for reads and writes must be
            aligned on at least disk sector boundries in memory.

        FILE_FLAG_RANDOM_ACCESS - Indicates that access to the file may
            be random. The system cache manager may use this to influence
            its caching strategy for this file.

        FILE_FLAG_SEQUENTIAL_SCAN - Indicates that access to the file
            may be sequential.  The system cache manager may use this to
            influence its caching strategy for this file.  The file may
            in fact be accessed randomly, but the cache manager may
            optimize its cacheing policy for sequential access.

        FILE_FLAG_DELETE_ON_CLOSE - Indicates that the file is to be
            automatically deleted when the last handle to it is closed.

        FILE_FLAG_BACKUP_SEMANTICS - Indicates that the file is being opened
            or created for the purposes of either a backup or a restore
            operation.  Thus, the system should make whatever checks are
            appropriate to ensure that the caller is able to override
            whatever security checks have been placed on the file to allow
            this to happen.

        FILE_FLAG_POSIX_SEMANTICS - Indicates that the file being opened
            should be accessed in a manner compatible with the rules used
            by POSIX.  This includes allowing multiple files with the same
            name, differing only in case.  WARNING:  Use of this flag may
            render it impossible for a DOS, WIN-16, or WIN-32 application
            to access the file.

        FILE_FLAG_OPEN_REPARSE_POINT - Indicates that the file being opened
            should be accessed as if it were a reparse point.  WARNING:  Use
            of this flag may inhibit the operation of file system filter drivers
            present in the I/O subsystem.

        FILE_FLAG_OPEN_NO_RECALL - Indicates that all the state of the file
            should be acessed without changing its storage location.  Thus,
            in the case of files that have parts of its state stored at a
            remote servicer, no permanent recall of data is to happen.

    Security Quality of Service information may also be specified in
        the dwFlagsAndAttributes parameter.  These bits are meaningful
        only if the file being opened is the client side of a Named
        Pipe.  Otherwise they are ignored.

        SECURITY_SQOS_PRESENT - Indicates that the Security Quality of
            Service bits contain valid values.

    Impersonation Levels:

        SECURITY_ANONYMOUS - Specifies that the client should be impersonated
            at Anonymous impersonation level.

        SECURITY_IDENTIFICAION - Specifies that the client should be impersonated
            at Identification impersonation level.

        SECURITY_IMPERSONATION - Specifies that the client should be impersonated
            at Impersonation impersonation level.

        SECURITY_DELEGATION - Specifies that the client should be impersonated
            at Delegation impersonation level.

    Context Tracking:

        SECURITY_CONTEXT_TRACKING - A boolean flag that when set,
            specifies that the Security Tracking Mode should be
            Dynamic, otherwise Static.

        SECURITY_EFFECTIVE_ONLY - A boolean flag indicating whether
            the entire security context of the client is to be made
            available to the server or only the effective aspects of
            the context.

    hTemplateFile - An optional parameter, then if specified, supplies a
        handle with GENERIC_READ access to a template file.  The
        template file is used to supply extended attributes for the file
        being created.  When the new file is created, the relevant attributes
        from the template file are used in creating the new file.

Return Value:

    Not -1 - Returns an open handle to the specified file.  Subsequent
        access to the file is controlled by the DesiredAccess parameter.

    0xffffffff - The operation failed. Extended error status is available
        using WmipGetLastError.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    ULONG CreateDisposition;
    ULONG CreateFlags;
    FILE_ALLOCATION_INFORMATION AllocationInfo;
    FILE_EA_INFORMATION EaInfo;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    ULONG EaSize;
    PUNICODE_STRING lpConsoleName;
    BOOL bInheritHandle;
    BOOL EndsInSlash;
    DWORD SQOSFlags;
    BOOLEAN ContextTrackingMode = FALSE;
    BOOLEAN EffectiveOnly = FALSE;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel = 0;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    switch ( dwCreationDisposition ) {
        case CREATE_NEW        :
            CreateDisposition = FILE_CREATE;
            break;
        case CREATE_ALWAYS     :
            CreateDisposition = FILE_OVERWRITE_IF;
            break;
        case OPEN_EXISTING     :
            CreateDisposition = FILE_OPEN;
            break;
        case OPEN_ALWAYS       :
            CreateDisposition = FILE_OPEN_IF;
            break;
        case TRUNCATE_EXISTING :
            CreateDisposition = FILE_OPEN;
            if ( !(dwDesiredAccess & GENERIC_WRITE) ) {
                WmipBaseSetLastNTError(STATUS_INVALID_PARAMETER);
                return INVALID_HANDLE_VALUE;
                }
            break;
        default :
            WmipBaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }

    // temporary routing code

    RtlInitUnicodeString(&FileName,lpFileName);

    if ( FileName.Length > 1 && lpFileName[(FileName.Length >> 1)-1] == (WCHAR)'\\' ) {
        EndsInSlash = TRUE;
        }
    else {
        EndsInSlash = FALSE;
        }
/*
    if ((lpConsoleName = WmipBaseIsThisAConsoleName(&FileName,dwDesiredAccess)) ) {

        Handle = INVALID_HANDLE_VALUE;

        bInheritHandle = FALSE;
        if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
                bInheritHandle = lpSecurityAttributes->bInheritHandle;
            }

        Handle = WmipOpenConsoleW(lpConsoleName,
                           dwDesiredAccess,
                           bInheritHandle,
                           FILE_SHARE_READ | FILE_SHARE_WRITE //dwShareMode
                          );

        if ( Handle == INVALID_HANDLE_VALUE ) {
            WmipBaseSetLastNTError(STATUS_ACCESS_DENIED);
            return INVALID_HANDLE_VALUE;
            }
        else {
            WmipSetLastError(0);
             return Handle;
            }
        }*/
    // end temporary code

    CreateFlags = 0;


    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        WmipSetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ? 0 : OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    SQOSFlags = dwFlagsAndAttributes & SECURITY_VALID_SQOS_FLAGS;

    if ( SQOSFlags & SECURITY_SQOS_PRESENT ) {

        SQOSFlags &= ~SECURITY_SQOS_PRESENT;

        if (SQOSFlags & SECURITY_CONTEXT_TRACKING) {

            SecurityQualityOfService.ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE) TRUE;
            SQOSFlags &= ~SECURITY_CONTEXT_TRACKING;

        } else {

            SecurityQualityOfService.ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE) FALSE;
        }

        if (SQOSFlags & SECURITY_EFFECTIVE_ONLY) {

            SecurityQualityOfService.EffectiveOnly = TRUE;
            SQOSFlags &= ~SECURITY_EFFECTIVE_ONLY;

        } else {

            SecurityQualityOfService.EffectiveOnly = FALSE;
        }

        SecurityQualityOfService.ImpersonationLevel = SQOSFlags >> 16;


    } else {

        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.EffectiveOnly = TRUE;
    }

    SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );
    Obja.SecurityQualityOfService = &SecurityQualityOfService;

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
            }
        }

    EaBuffer = NULL;
    EaSize = 0;

    if ( ARGUMENT_PRESENT(hTemplateFile) ) {
        Status = NtQueryInformationFile(
                    hTemplateFile,
                    &IoStatusBlock,
                    &EaInfo,
                    sizeof(EaInfo),
                    FileEaInformation
                    );
        if ( NT_SUCCESS(Status) && EaInfo.EaSize ) {
            EaSize = EaInfo.EaSize;
            do {
                EaSize *= 2;
                EaBuffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), EaSize);
                if ( !EaBuffer ) {
                    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                    WmipBaseSetLastNTError(STATUS_NO_MEMORY);
                    return INVALID_HANDLE_VALUE;
                    }
                Status = NtQueryEaFile(
                            hTemplateFile,
                            &IoStatusBlock,
                            EaBuffer,
                            EaSize,
                            FALSE,
                            (PVOID)NULL,
                            0,
                            (PULONG)NULL,
                            TRUE
                            );
                if ( !NT_SUCCESS(Status) ) {
                    RtlFreeHeap(RtlProcessHeap(), 0,EaBuffer);
                    EaBuffer = NULL;
                    IoStatusBlock.Information = 0;
                    }
                } while ( Status == STATUS_BUFFER_OVERFLOW ||
                          Status == STATUS_BUFFER_TOO_SMALL );
            EaSize = (ULONG)IoStatusBlock.Information;
            }
        }

    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );

    if ( dwFlagsAndAttributes & FILE_FLAG_DELETE_ON_CLOSE ) {
        CreateFlags |= FILE_DELETE_ON_CLOSE;
        dwDesiredAccess |= DELETE;
        }

    if ( dwFlagsAndAttributes & FILE_FLAG_OPEN_REPARSE_POINT ) {
        CreateFlags |= FILE_OPEN_REPARSE_POINT;
        }

    if ( dwFlagsAndAttributes & FILE_FLAG_OPEN_NO_RECALL ) {
        CreateFlags |= FILE_OPEN_NO_RECALL;
        }

    //
    // Backup semantics allow directories to be opened
    //

    if ( !(dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS) ) {
        CreateFlags |= FILE_NON_DIRECTORY_FILE;
        }
    else {

        //
        // Backup intent was specified... Now look to see if we are to allow
        // directory creation
        //

        if ( (dwFlagsAndAttributes & FILE_ATTRIBUTE_DIRECTORY  ) &&
             (dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ) &&
             (CreateDisposition == FILE_CREATE) ) {
             CreateFlags |= FILE_DIRECTORY_FILE;
             }
        }

    Status = NtCreateFile(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                NULL,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                CreateDisposition,
                CreateFlags,
                EaBuffer,
                EaSize
                );

    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    RtlFreeHeap(RtlProcessHeap(), 0, EaBuffer);

    if ( !NT_SUCCESS(Status) ) {
        WmipBaseSetLastNTError(Status);
        if ( Status == STATUS_OBJECT_NAME_COLLISION ) {
            WmipSetLastError(ERROR_FILE_EXISTS);
            }
        else if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            if ( EndsInSlash ) {
                WmipSetLastError(ERROR_PATH_NOT_FOUND);
                }
            else {
                WmipSetLastError(ERROR_ACCESS_DENIED);
                }
            }
        return INVALID_HANDLE_VALUE;
        }

    //
    // if NT returns supersede/overwritten, it means that a create_always, openalways
    // found an existing copy of the file. In this case ERROR_ALREADY_EXISTS is returned
    //

    if ( (dwCreationDisposition == CREATE_ALWAYS && IoStatusBlock.Information == FILE_OVERWRITTEN) ||
         (dwCreationDisposition == OPEN_ALWAYS && IoStatusBlock.Information == FILE_OPENED) ){
        WmipSetLastError(ERROR_ALREADY_EXISTS);
        }
    else {
        WmipSetLastError(0);
        }

    //
    // Truncate the file if required
    //

    if ( dwCreationDisposition == TRUNCATE_EXISTING) {

        AllocationInfo.AllocationSize.QuadPart = 0;
        Status = NtSetInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &AllocationInfo,
                    sizeof(AllocationInfo),
                    FileAllocationInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            WmipBaseSetLastNTError(Status);
            NtClose(Handle);
            Handle = INVALID_HANDLE_VALUE;
            }
        }

    //
    // Deal with hTemplateFile
    //

    return Handle;
}

HANDLE
WmipBaseGetNamedObjectDirectory(
    VOID
    )
{
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    UNICODE_STRING RestrictedObjectDirectory;
    ACCESS_MASK DirAccess = DIRECTORY_ALL_ACCESS &
                            ~(DELETE | WRITE_DAC | WRITE_OWNER);
    HANDLE hRootNamedObject;
    HANDLE BaseHandle;


    if ( BaseNamedObjectDirectory != NULL) {
        return BaseNamedObjectDirectory;
    }

    RtlAcquirePebLock();

    if ( !BaseNamedObjectDirectory ) {

        BASE_READ_REMOTE_STR_TEMP(TempStr);
        InitializeObjectAttributes( &Obja,
                                    BASE_READ_REMOTE_STR(BaseStaticServerData->NamedObjectDirectory, TempStr),
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                    );

        Status = NtOpenDirectoryObject( &BaseHandle,
                                        DirAccess,
                                        &Obja
                                      );

        // if the intial open failed, try again with just traverse, and
        // open the restricted subdirectory

        if ( !NT_SUCCESS(Status) ) {
            Status = NtOpenDirectoryObject( &hRootNamedObject,
                                            DIRECTORY_TRAVERSE,
                                            &Obja
                                          );
            if ( NT_SUCCESS(Status) ) {
                RtlInitUnicodeString( &RestrictedObjectDirectory, L"Restricted");

                InitializeObjectAttributes( &Obja,
                                            &RestrictedObjectDirectory,
                                            OBJ_CASE_INSENSITIVE,
                                            hRootNamedObject,
                                            NULL
                                            );
                Status = NtOpenDirectoryObject( &BaseHandle,
                                                DirAccess,
                                                &Obja
                                              );
                NtClose( hRootNamedObject );
            }

        }
        if ( NT_SUCCESS(Status) ) {
            BaseNamedObjectDirectory = BaseHandle;
        }
    }
    RtlReleasePebLock();
    return BaseNamedObjectDirectory;
}


POBJECT_ATTRIBUTES
WmipBaseFormatObjectAttributes(
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    IN PSECURITY_ATTRIBUTES SecurityAttributes,
    IN PUNICODE_STRING ObjectName
    )

/*++

Routine Description:

    This function transforms a Win32 security attributes structure into
    an NT object attributes structure.  It returns the address of the
    resulting structure (or NULL if SecurityAttributes was not
    specified).

Arguments:

    ObjectAttributes - Returns an initialized NT object attributes
        structure that contains a superset of the information provided
        by the security attributes structure.

    SecurityAttributes - Supplies the address of a security attributes
        structure that needs to be transformed into an NT object
        attributes structure.

    ObjectName - Supplies a name for the object relative to the
        BaseNamedObjectDirectory object directory.

Return Value:

    NULL - A value of null should be used to mimic the behavior of the
        specified SecurityAttributes structure.

    NON-NULL - Returns the ObjectAttributes value.  The structure is
        properly initialized by this function.

--*/

{
    HANDLE RootDirectory;
    ULONG Attributes;
    PVOID SecurityDescriptor;


    if ( ARGUMENT_PRESENT(SecurityAttributes) ||
         ARGUMENT_PRESENT(ObjectName) ) {

        if ( ARGUMENT_PRESENT(ObjectName) ) {
            RootDirectory = WmipBaseGetNamedObjectDirectory();
            }
        else {
            RootDirectory = NULL;
            }

        if ( SecurityAttributes ) {
            Attributes = (SecurityAttributes->bInheritHandle ? OBJ_INHERIT : 0);
            SecurityDescriptor = SecurityAttributes->lpSecurityDescriptor;
            }
        else {
            Attributes = 0;
            SecurityDescriptor = NULL;
            }

        if ( ARGUMENT_PRESENT(ObjectName) ) {
            Attributes |= OBJ_OPENIF;
            }

        InitializeObjectAttributes(
            ObjectAttributes,
            ObjectName,
            Attributes,
            RootDirectory,
            SecurityDescriptor
            );
        return ObjectAttributes;
        }
    else {
        return NULL;
        }
}



HANDLE
WINAPI
WmipCreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )

/*++

Routine Description:

    ANSI thunk to CreateFileW

--*/

{

    PUNICODE_STRING Unicode;

    Unicode = WmipBasep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return INVALID_HANDLE_VALUE;
    }

    return  WmipCreateFileW( Unicode->Buffer,
                          dwDesiredAccess,
                          dwShareMode,
                          lpSecurityAttributes,
                          dwCreationDisposition,
                          dwFlagsAndAttributes,
                          hTemplateFile
                        );
}


HANDLE
APIENTRY
WmipCreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )

/*++

Routine Description:

    An event object is created and a handle opened for access to the
    object with the CreateEvent function.

    The CreateEvent function creates an event object with the specified
    initial state.  If an event is in the Signaled state (TRUE), a wait
    operation on the event does not block.  If the event is in the Not-
    Signaled state (FALSE), a wait operation on the event blocks until
    the specified event attains a state of Signaled, or the timeout
    value is exceeded.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the following
    object type specific access flags are valid for event objects:

        - EVENT_MODIFY_STATE - Modify state access (set and reset) to
          the event is desired.

        - SYNCHRONIZE - Synchronization access (wait) to the event is
          desired.

        - EVENT_ALL_ACCESS - This set of access flags specifies all of
          the possible access flags for an event object.


Arguments:

    lpEventAttributes - An optional parameter that may be used to
        specify the attributes of the new event.  If the parameter is
        not specified, then the event is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    bManualReset - Supplies a flag which if TRUE specifies that the
        event must be manually reset.  If the value is FALSE, then after
        releasing a single waiter, the system automaticaly resets the
        event.

    bInitialState - The initial state of the event object, one of TRUE
        or FALSE.  If the InitialState is specified as TRUE, the event's
        current state value is set to one, otherwise it is set to zero.

    lpName - Optional unicode name of event

Return Value:

    NON-NULL - Returns a handle to the new event.  The handle has full
        access to the new event and may be used in any API that requires
        a handle to an event object.

    FALSE/NULL - The operation failed. Extended error status is available
        using WmipGetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    UNICODE_STRING ObjectName;
    PWCHAR pstrNewObjName = NULL;

    if ( ARGUMENT_PRESENT(lpName) ) {

        if (gpTermsrvFormatObjectName && 
            (pstrNewObjName = gpTermsrvFormatObjectName(lpName))) {

            RtlInitUnicodeString(&ObjectName,pstrNewObjName);

        } else {

            RtlInitUnicodeString(&ObjectName,lpName);
        }

        pObja = WmipBaseFormatObjectAttributes(&Obja,lpEventAttributes,&ObjectName);
        }
    else {
        pObja = WmipBaseFormatObjectAttributes(&Obja,lpEventAttributes,NULL);
        }

    Status = NtCreateEvent(
                &Handle,
                EVENT_ALL_ACCESS,
                pObja,
                bManualReset ? NotificationEvent : SynchronizationEvent,
                (BOOLEAN)bInitialState
                );

    if (pstrNewObjName) {
        RtlFreeHeap(RtlProcessHeap(), 0, pstrNewObjName);
    }

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            WmipSetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            WmipSetLastError(0);
            }
        return Handle;
        }
    else {
        WmipBaseSetLastNTError(Status);
        return NULL;
        }
}


//
// Event Services
//
HANDLE
APIENTRY
WmipCreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateEventW


--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR NameBuffer;

    NameBuffer = NULL;
    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                WmipSetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                WmipBaseSetLastNTError(Status);
                }
            return NULL;
            }
        NameBuffer = (LPCWSTR)Unicode->Buffer;
        }

    return WmipCreateEventW(
                lpEventAttributes,
                bManualReset,
                bInitialState,
                NameBuffer
                );
}


DWORD
WINAPI
WmipSetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    PLONG lpDistanceToMoveHigh,
    DWORD dwMoveMethod
    )

/*++

Routine Description:

    An open file's file pointer can be set using SetFilePointer.

    The purpose of this function is to update the current value of a
    file's file pointer.  Care should be taken in multi-threaded
    applications that have multiple threads sharing a file handle with
    each thread updating the file pointer and then doing a read.  This
    sequence should be treated as a critical section of code and should
    be protected using either a critical section object or a mutex
    object.

    This API provides the same functionality as DOS (int 21h, function
    42h) and OS/2's DosSetFilePtr.

Arguments:

    hFile - Supplies an open handle to a file whose file pointer is to be
        moved.  The file handle must have been created with
        GENERIC_READ or GENERIC_WRITE access to the file.

    lDistanceToMove - Supplies the number of bytes to move the file
        pointer.  A positive value moves the pointer forward in the file
        and a negative value moves backwards in the file.

    lpDistanceToMoveHigh - An optional parameter that if specified
        supplies the high order 32-bits of the 64-bit distance to move.
        If the value of this parameter is NULL, this API can only
        operate on files whose maximum size is (2**32)-2.  If this
        parameter is specified, than the maximum file size is (2**64)-2.
        This value also returns the high order 32-bits of the new value
        of the file pointer.  If this value, and the return value
        are 0xffffffff, then an error is indicated.

    dwMoveMethod - Supplies a value that specifies the starting point
        for the file pointer move.

        FILE_BEGIN - The starting point is zero or the beginning of the
            file.  If FILE_BEGIN is specified, then DistanceToMove is
            interpreted as an unsigned location for the new
            file pointer.

        FILE_CURRENT - The current value of the file pointer is used as
            the starting point.

        FILE_END - The current end of file position is used as the
            starting point.


Return Value:

    Not -1 - Returns the low order 32-bits of the new value of the file
        pointer.

    0xffffffff - If the value of lpDistanceToMoveHigh was NULL, then The
        operation failed.  Extended error status is available using
        WmipGetLastError.  Otherwise, this is the low order 32-bits of the
        new value of the file pointer.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    FILE_STANDARD_INFORMATION StandardInfo;
    LARGE_INTEGER Large;

    if (CONSOLE_HANDLE(hFile)) {
        WmipBaseSetLastNTError(STATUS_INVALID_HANDLE);
        return (DWORD)-1;
        }

    if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)) {
        Large.HighPart = *lpDistanceToMoveHigh;
        Large.LowPart = lDistanceToMove;
        }
    else {
        Large.QuadPart = lDistanceToMove;
        }
    switch (dwMoveMethod) {
        case FILE_BEGIN :
            CurrentPosition.CurrentByteOffset = Large;
                break;

        case FILE_CURRENT :

            //
            // Get the current position of the file pointer
            //

            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &CurrentPosition,
                        sizeof(CurrentPosition),
                        FilePositionInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                WmipBaseSetLastNTError(Status);
                return (DWORD)-1;
                }
            CurrentPosition.CurrentByteOffset.QuadPart += Large.QuadPart;
            break;

        case FILE_END :
            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &StandardInfo,
                        sizeof(StandardInfo),
                        FileStandardInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                WmipBaseSetLastNTError(Status);
                return (DWORD)-1;
                }
            CurrentPosition.CurrentByteOffset.QuadPart =
                                StandardInfo.EndOfFile.QuadPart + Large.QuadPart;
            break;

        default:
            WmipSetLastError(ERROR_INVALID_PARAMETER);
            return (DWORD)-1;
            break;
        }

    //
    // If the resulting file position is negative, or if the app is not
    // prepared for greater than
    // then 32 bits than fail
    //

    if ( CurrentPosition.CurrentByteOffset.QuadPart < 0 ) {
        WmipSetLastError(ERROR_NEGATIVE_SEEK);
        return (DWORD)-1;
        }
    if ( !ARGUMENT_PRESENT(lpDistanceToMoveHigh) &&
        (CurrentPosition.CurrentByteOffset.HighPart & MAXLONG) ) {
        WmipSetLastError(ERROR_INVALID_PARAMETER);
        return (DWORD)-1;
        }


    //
    // Set the current file position
    //

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
    if ( NT_SUCCESS(Status) ) {
        if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)){
            *lpDistanceToMoveHigh = CurrentPosition.CurrentByteOffset.HighPart;
            }
        if ( CurrentPosition.CurrentByteOffset.LowPart == -1 ) {
            WmipSetLastError(0);
            }
        return CurrentPosition.CurrentByteOffset.LowPart;
        }
    else {
        WmipBaseSetLastNTError(Status);
        if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)){
            *lpDistanceToMoveHigh = -1;
            }
        return (DWORD)-1;
        }
}



BOOL
WINAPI
WmipReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    Data can be read from a file using ReadFile.

    This API is used to read data from a file.  Data is read from the
    file from the position indicated by the file pointer.  After the
    read completes, the file pointer is adjusted by the number of bytes
    actually read.  A return value of TRUE coupled with a bytes read of
    0 indicates that the file pointer was beyond the current end of the
    file at the time of the read.

Arguments:

    hFile - Supplies an open handle to a file that is to be read.  The
        file handle must have been created with GENERIC_READ access to
        the file.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the file.

    nNumberOfBytesToRead - Supplies the number of bytes to read from the
        file.

    lpNumberOfBytesRead - Returns the number of bytes read by this call.
        This parameter is always set to 0 before doing any IO or error
        checking.

    lpOverlapped - Optionally points to an OVERLAPPED structure to be used with the
    request. If NULL then the transfer starts at the current file position
    and ReadFile will not return until the operation completes.

    If the handle hFile was created without specifying FILE_FLAG_OVERLAPPED
    the file pointer is moved to the specified offset plus
    lpNumberOfBytesRead before ReadFile returns. ReadFile will wait for the
    request to complete before returning (it will not return
    ERROR_IO_PENDING).

    When FILE_FLAG_OVERLAPPED is specified, ReadFile may return
    ERROR_IO_PENDING to allow the calling function to continue processing
    while the operation completes. The event (or hFile if hEvent is NULL) will
    be set to the signalled state upon completion of the request.

    When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
    is set to NULL, ReadFile will return ERROR_INVALID_PARAMTER because
    the file offset is required.


Return Value:

    TRUE - The operation was successul.

    FALSE - The operation failed.  Extended error status is available
        using WmipGetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PPEB Peb;
    DWORD InputMode;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
        *lpNumberOfBytesRead = 0;
        }

    Peb = NtCurrentPeb();

    switch( HandleToUlong(hFile) ) {
        case STD_INPUT_HANDLE:  hFile = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hFile = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hFile = Peb->ProcessParameters->StandardError;
                                break;
        }
    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtReadFile(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                lpBuffer,
                nNumberOfBytesToRead,
                &Li,
                NULL
                );


        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                try {
                    *lpNumberOfBytesRead = (DWORD)lpOverlapped->InternalHigh;
                    }
                except(EXCEPTION_EXECUTE_HANDLER) {
                    *lpNumberOfBytesRead = 0;
                    }
                }
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                *lpNumberOfBytesRead = 0;
                }
            WmipBaseSetLastNTError(Status);
            return FALSE;
            }
        else {
            WmipBaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        Status = NtReadFile(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                lpBuffer,
                nNumberOfBytesToRead,
                NULL,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            *lpNumberOfBytesRead = 0;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
                }
            WmipBaseSetLastNTError(Status);
            return FALSE;
            }
        }
}

BOOL
WmipCloseHandle(
    HANDLE hObject
    )
{
    NTSTATUS Status;

    Status = NtClose(hObject);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;

    } else {

        WmipBaseSetLastNTError(Status);
        return FALSE;
    }
}

DWORD
APIENTRY
WmipWaitForSingleObjectEx(
    HANDLE hHandle,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObjectEx function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified object entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any
    one of the above wait termination conditions, or because an I/O
    completion callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    0xffffffff - The wait terminated due to an error. WmipGetLastError may be
        used to get additional error information.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    PPEB Peb;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&Frame, NULL); // make the process default activation context active so that APCs are delivered under it
    __try {

        Peb = NtCurrentPeb();
        switch( HandleToUlong(hHandle) ) {
            case STD_INPUT_HANDLE:  hHandle = Peb->ProcessParameters->StandardInput;
                                    break;
            case STD_OUTPUT_HANDLE: hHandle = Peb->ProcessParameters->StandardOutput;
                                    break;
            case STD_ERROR_HANDLE:  hHandle = Peb->ProcessParameters->StandardError;
                                    break;
            }

        pTimeOut = WmipBaseFormatTimeOut(&TimeOut,dwMilliseconds);
    rewait:
        Status = NtWaitForSingleObject(hHandle,(BOOLEAN)bAlertable,pTimeOut);
        if ( !NT_SUCCESS(Status) ) {
            WmipBaseSetLastNTError(Status);
            Status = (NTSTATUS)0xffffffff;
            }
        else {
            if ( bAlertable && Status == STATUS_ALERTED ) {
                goto rewait;
                }
            }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&Frame);
    }

    return (DWORD)Status;
}


BOOL
WINAPI
WmipGetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    )

/*++

Routine Description:

    The GetOverlappedResult function returns the result of the last
    operation that used lpOverlapped and returned ERROR_IO_PENDING.

Arguments:

    hFile - Supplies the open handle to the file that the overlapped
        structure lpOverlapped was supplied to ReadFile, WriteFile,
        ConnectNamedPipe, WaitNamedPipe or TransactNamedPipe.

    lpOverlapped - Points to an OVERLAPPED structure previously supplied to
        ReadFile, WriteFile, ConnectNamedPipe, WaitNamedPipe or
        TransactNamedPipe.

    lpNumberOfBytesTransferred - Returns the number of bytes transferred
        by the operation.

    bWait -  A boolean value that affects the behavior when the operation
        is still in progress. If TRUE and the operation is still in progress,
        GetOverlappedResult will wait for the operation to complete before
        returning. If FALSE and the operation is incomplete,
        GetOverlappedResult will return FALSE. In this case the extended
        error information available from the WmipGetLastError function will be
        set to ERROR_IO_INCOMPLETE.

Return Value:

    TRUE -- The operation was successful, the pipe is in the
        connected state.

    FALSE -- The operation failed. Extended error status is available using
        WmipGetLastError.

--*/
{
    DWORD WaitReturn;

    //
    // Did caller specify an event to the original operation or was the
    // default (file handle) used?
    //

    if (lpOverlapped->Internal == (DWORD)STATUS_PENDING ) {
        if ( bWait ) {
            WaitReturn = WmipWaitForSingleObject(
                            ( lpOverlapped->hEvent != NULL ) ?
                                lpOverlapped->hEvent : hFile,
                            INFINITE
                            );
            }
        else {
            WaitReturn = WAIT_TIMEOUT;
            }

        if ( WaitReturn == WAIT_TIMEOUT ) {
            //  !bWait and event in not signalled state
            WmipSetLastError( ERROR_IO_INCOMPLETE );
            return FALSE;
            }

        if ( WaitReturn != 0 ) {
             return FALSE;    // WaitForSingleObject calls BaseSetLastError
             }
        }

    *lpNumberOfBytesTransferred = (DWORD)lpOverlapped->InternalHigh;

    if ( NT_SUCCESS((NTSTATUS)lpOverlapped->Internal) ){
        return TRUE;
        }
    else {
        WmipBaseSetLastNTError( (NTSTATUS)lpOverlapped->Internal );
        return FALSE;
        }
}


PLARGE_INTEGER
WmipBaseFormatTimeOut(
    OUT PLARGE_INTEGER TimeOut,
    IN DWORD Milliseconds
    )

/*++

Routine Description:

    This function translates a Win32 style timeout to an NT relative
    timeout value.

Arguments:

    TimeOut - Returns an initialized NT timeout value that is equivalent
         to the Milliseconds parameter.

    Milliseconds - Supplies the timeout value in milliseconds.  A value
         of -1 indicates indefinite timeout.

Return Value:


    NULL - A value of null should be used to mimic the behavior of the
        specified Milliseconds parameter.

    NON-NULL - Returns the TimeOut value.  The structure is properly
        initialized by this function.

--*/

{
    if ( (LONG) Milliseconds == -1 ) {
        return( NULL );
        }
    TimeOut->QuadPart = UInt32x32To64( Milliseconds, 10000 );
    TimeOut->QuadPart *= -1;
    return TimeOut;
}


DWORD
WmipWaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObject function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

--*/

{
    return WmipWaitForSingleObjectEx(hHandle,dwMilliseconds,FALSE);
}


BOOL
WINAPI
WmipDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    An operation on a device may be performed by calling the device driver
    directly using the DeviceIoContrl function.

    The device driver must first be opened to get a valid handle.

Arguments:

    hDevice - Supplies an open handle a device on which the operation is to
        be performed.

    dwIoControlCode - Supplies the control code for the operation. This
        control code determines on which type of device the operation must
        be performed and determines exactly what operation is to be
        performed.

    lpInBuffer - Suplies an optional pointer to an input buffer that contains
        the data required to perform the operation.  Whether or not the
        buffer is actually optional is dependent on the IoControlCode.

    nInBufferSize - Supplies the length of the input buffer in bytes.

    lpOutBuffer - Suplies an optional pointer to an output buffer into which
        the output data will be copied. Whether or not the buffer is actually
        optional is dependent on the IoControlCode.

    nOutBufferSize - Supplies the length of the output buffer in bytes.

    lpBytesReturned - Supplies a pointer to a dword which will receive the
        actual length of the data returned in the output buffer.

    lpOverlapped - An optional parameter that supplies an overlap structure to
        be used with the request. If NULL or the handle was created without
        FILE_FLAG_OVERLAPPED then the DeviceIoControl will not return until
        the operation completes.

        When lpOverlapped is supplied and FILE_FLAG_OVERLAPPED was specified
        when the handle was created, DeviceIoControl may return
        ERROR_IO_PENDING to allow the caller to continue processing while the
        operation completes. The event (or File handle if hEvent == NULL) will
        be set to the not signalled state before ERROR_IO_PENDING is
        returned. The event will be set to the signalled state upon completion
        of the request. GetOverlappedResult is used to determine the result
        when ERROR_IO_PENDING is returned.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        WmipGetLastError.

--*/
{

    NTSTATUS Status;
    BOOLEAN DevIoCtl;

    if ( dwIoControlCode >> 16 == FILE_DEVICE_FILE_SYSTEM ) {
        DevIoCtl = FALSE;
        }
    else {
        DevIoCtl = TRUE;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;

        if ( DevIoCtl ) {

            Status = NtDeviceIoControlFile(
                        hDevice,
                        lpOverlapped->hEvent,
                        NULL,             // APC routine
                        (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                        (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }
        else {

            Status = NtFsControlFile(
                        hDevice,
                        lpOverlapped->hEvent,
                        NULL,             // APC routine
                        (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                        (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );

            }

        // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
        if ( !NT_ERROR(Status) && ARGUMENT_PRESENT(lpBytesReturned) ) {
            try {
                *lpBytesReturned = (DWORD)lpOverlapped->InternalHigh;
                }
            except(EXCEPTION_EXECUTE_HANDLER) {
                *lpBytesReturned = 0;
                }
            }
        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            return TRUE;
            }
        else {
            WmipBaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        IO_STATUS_BLOCK Iosb;

        if ( DevIoCtl ) {
            Status = NtDeviceIoControlFile(
                        hDevice,
                        NULL,
                        NULL,             // APC routine
                        NULL,             // APC Context
                        &Iosb,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }
        else {
            Status = NtFsControlFile(
                        hDevice,
                        NULL,
                        NULL,             // APC routine
                        NULL,             // APC Context
                        &Iosb,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & Iosb destroyed
            Status = NtWaitForSingleObject( hDevice, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = Iosb.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpBytesReturned = (DWORD)Iosb.Information;
            return TRUE;
            }
        else {
            // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
            if ( !NT_ERROR(Status) ) {
                *lpBytesReturned = (DWORD)Iosb.Information;
            }
            WmipBaseSetLastNTError(Status);
            return FALSE;
            }
        }
}

BOOL
WINAPI
WmipCancelIo(
    HANDLE hFile
    )

/*++

Routine Description:

    This routine cancels all of the outstanding I/O for the specified handle
    for the specified file.

Arguments:

    hFile - Supplies the handle to the file whose pending I/O is to be
        canceled.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed.  Extended error status is available using
        WmipGetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Simply cancel the I/O for the specified file.
    //

    Status = NtCancelIoFile(hFile, &IoStatusBlock);

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        WmipBaseSetLastNTError(Status);
        return FALSE;
        }

}



VOID
APIENTRY
WmipExitThread(
    DWORD dwExitCode
    )
{
    RtlExitUserThread(dwExitCode);
}


DWORD
WINAPI
WmipGetCurrentProcessId(
    VOID
    )

/*++

Routine Description:

    The process ID of the current process may be retrieved using
    GetCurrentProcessId.

Arguments:

    None.

Return Value:

    Returns a unique value representing the process ID of the currently
    executing process.  The return value may be used to open a handle to
    a process.

--*/

{
    return HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess);
}


DWORD
APIENTRY
WmipGetCurrentThreadId(
    VOID
    )

/*++

Routine Description:

The thread ID of the current thread may be retrieved using
GetCurrentThreadId.

Arguments:

    None.

Return Value:

    Returns a unique value representing the thread ID of the currently
    executing thread.  The return value may be used to identify a thread
    in the system.

--*/

{
    return HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread);
}

HANDLE
WINAPI
WmipGetCurrentProcess(
    VOID
    )

/*++

Routine Description:

    A pseudo handle to the current process may be retrieved using
    GetCurrentProcess.

    A special constant is exported by Win32 that is interpreted as a
    handle to the current process.  This handle may be used to specify
    the current process whenever a process handle is required.  On
    Win32, this handle has PROCESS_ALL_ACCESS to the current process.
    On NT/Win32, this handle has the maximum access allowed by any
    security descriptor placed on the current process.

Arguments:

    None.

Return Value:

    Returns the pseudo handle of the current process.

--*/

{
    return NtCurrentProcess();
}


BOOL
WmipSetEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    An event can be set to the signaled state (TRUE) with the SetEvent
    function.

    Setting the event causes the event to attain a state of Signaled,
    which releases all currently waiting threads (for manual reset
    events), or a single waiting thread (for automatic reset events).

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using WmipGetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtSetEvent(hEvent,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        WmipBaseSetLastNTError(Status);
        return FALSE;
        }
}


VOID
WINAPI
WmipGetSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
    )

/*++

Routine Description:

    The GetSystemInfo function is used to return information about the
    current system.  This includes the processor type, page size, oem
    id, and other interesting pieces of information.

Arguments:

    lpSystemInfo - Returns information about the current system.

        SYSTEM_INFO Structure:

        WORD wProcessorArchitecture - returns the architecture of the
            processors in the system: e.g. Intel, Mips, Alpha or PowerPC

        DWORD dwPageSize - Returns the page size.  This is specifies the
            granularity of page protection and commitment.

        LPVOID lpMinimumApplicationAddress - Returns the lowest memory
            address accessible to applications and DLLs.

        LPVOID lpMaximumApplicationAddress - Returns the highest memory
            address accessible to applications and DLLs.

        DWORD dwActiveProcessorMask - Returns a mask representing the
            set of processors configured into the system.  Bit 0 is
            processor 0, bit 31 is processor 31.

        DWORD dwNumberOfProcessors - Returns the number of processors in
            the system.

        WORD wProcessorLevel - Returns the level of the processors in the
            system.  All processors are assumed to be of the same level,
            stepping, and are configured with the same options.

        WORD wProcessorRevision - Returns the revision or stepping of the
            processors in the system.  All processors are assumed to be
            of the same level, stepping, and are configured with the
            same options.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_PROCESSOR_INFORMATION ProcessorInfo;

    RtlZeroMemory(lpSystemInfo,sizeof(*lpSystemInfo));

    Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return;
        }

    Status = NtQuerySystemInformation(
                SystemProcessorInformation,
                &ProcessorInfo,
                sizeof(ProcessorInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return;
        }

    lpSystemInfo->wProcessorArchitecture = ProcessorInfo.ProcessorArchitecture;
    lpSystemInfo->wReserved = 0;
    lpSystemInfo->dwPageSize = BasicInfo.PageSize;
    lpSystemInfo->lpMinimumApplicationAddress = (LPVOID)BasicInfo.MinimumUserModeAddress;
    lpSystemInfo->lpMaximumApplicationAddress = (LPVOID)BasicInfo.MaximumUserModeAddress;
    lpSystemInfo->dwActiveProcessorMask = BasicInfo.ActiveProcessorsAffinityMask;
    lpSystemInfo->dwNumberOfProcessors = BasicInfo.NumberOfProcessors;
    lpSystemInfo->wProcessorLevel = ProcessorInfo.ProcessorLevel;
    lpSystemInfo->wProcessorRevision = ProcessorInfo.ProcessorRevision;

    if (ProcessorInfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
        if (ProcessorInfo.ProcessorLevel == 3) {
            lpSystemInfo->dwProcessorType = PROCESSOR_INTEL_386;
            }
        else
        if (ProcessorInfo.ProcessorLevel == 4) {
            lpSystemInfo->dwProcessorType = PROCESSOR_INTEL_486;
            }
        else {
            lpSystemInfo->dwProcessorType = PROCESSOR_INTEL_PENTIUM;
            }
        }
    else
    if (ProcessorInfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_MIPS) {
        lpSystemInfo->dwProcessorType = PROCESSOR_MIPS_R4000;
        }
    else
    if (ProcessorInfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA) {
        lpSystemInfo->dwProcessorType = PROCESSOR_ALPHA_21064;
        }
    else
    if (ProcessorInfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_PPC) {
        lpSystemInfo->dwProcessorType = 604;  // backward compatibility
        }
    else
    if (ProcessorInfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64) {
        lpSystemInfo->dwProcessorType = PROCESSOR_INTEL_IA64;
        }
    else {
        lpSystemInfo->dwProcessorType = 0;
        }

    lpSystemInfo->dwAllocationGranularity = BasicInfo.AllocationGranularity;

    //
    // for apps less than 3.51, then return 0 in dwReserved. This allows borlands
    // debugger to continue to run since it mistakenly used dwReserved
    // as AllocationGranularity
    //
/*   commented by Digvijay
    if ( WmipGetProcessVersion(0) < 0x30033 ) {
        lpSystemInfo->wProcessorLevel = 0;
        lpSystemInfo->wProcessorRevision = 0;
        }*/

    return;
}


VOID
WINAPI
WmipGlobalMemoryStatus(
    LPMEMORYSTATUS lpBuffer
    )
{
    DWORD NumberOfPhysicalPages;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    VM_COUNTERS VmCounters;
    QUOTA_LIMITS QuotaLimits;
    NTSTATUS Status;
    PPEB Peb;
    PIMAGE_NT_HEADERS NtHeaders;
    DWORDLONG Memory64;

	#if defined(BUILD_WOW6432) || defined(_WIN64)
			Status = NtQuerySystemInformation(SystemBasicInformation,
											  &SysInfo,
											  sizeof(SYSTEM_BASIC_INFORMATION),
											  NULL
											 );

			if (!NT_SUCCESS(Status)) {
				return;
			}

	#endif

    Status = NtQuerySystemInformation(
                SystemPerformanceInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );
    ASSERT(NT_SUCCESS(Status));

    lpBuffer->dwLength = sizeof( *lpBuffer );

    //
    // Capture the number of physical pages as it can change dynamically.
    // If it goes up or down in the middle of this routine, the results may
    // look strange (ie: available > total, etc), but it will quickly
    // right itself.
    //

    NumberOfPhysicalPages = USER_SHARED_DATA->NumberOfPhysicalPages;

    //
    // Determine the memory load.  < 100 available pages is 100
    // Otherwise load is ((TotalPhys - AvailPhys) * 100) / TotalPhys
    //

    if (PerfInfo.AvailablePages < 100) {
        lpBuffer->dwMemoryLoad = 100;
    }
    else {
        lpBuffer->dwMemoryLoad =
            ((DWORD)(NumberOfPhysicalPages - PerfInfo.AvailablePages) * 100) /
                NumberOfPhysicalPages;
    }

    Memory64 =  (DWORDLONG)NumberOfPhysicalPages * BASE_SYSINFO.PageSize;

    lpBuffer->dwTotalPhys = (SIZE_T) __min(Memory64, MAXULONG_PTR);

    Memory64 = ((DWORDLONG)PerfInfo.AvailablePages * (DWORDLONG)BASE_SYSINFO.PageSize);

    lpBuffer->dwAvailPhys = (SIZE_T) __min(Memory64, MAXULONG_PTR);

    if (gpTermsrvAdjustPhyMemLimits) {
        gpTermsrvAdjustPhyMemLimits(&(lpBuffer->dwTotalPhys),
                                    &(lpBuffer->dwAvailPhys),
                                    BASE_SYSINFO.PageSize);
    }
    //
    // Zero returned values in case the query process fails.
    //

    RtlZeroMemory (&QuotaLimits, sizeof (QUOTA_LIMITS));
    RtlZeroMemory (&VmCounters, sizeof (VM_COUNTERS));

    Status = NtQueryInformationProcess (NtCurrentProcess(),
                                        ProcessQuotaLimits,
                                        &QuotaLimits,
                                        sizeof(QUOTA_LIMITS),
                                        NULL );

    Status = NtQueryInformationProcess (NtCurrentProcess(),
                                        ProcessVmCounters,
                                        &VmCounters,
                                        sizeof(VM_COUNTERS),
                                        NULL );
    //
    // Determine the total page file space with respect to this process.
    //

    Memory64 = __min(PerfInfo.CommitLimit, QuotaLimits.PagefileLimit);

    Memory64 *= BASE_SYSINFO.PageSize;

    lpBuffer->dwTotalPageFile = (SIZE_T)__min(Memory64, MAXULONG_PTR);

    //
    // Determine remaining page file space with respect to this process.
    //

    Memory64 = __min(PerfInfo.CommitLimit - PerfInfo.CommittedPages,
                     QuotaLimits.PagefileLimit - VmCounters.PagefileUsage);

    Memory64 *= BASE_SYSINFO.PageSize;

    lpBuffer->dwAvailPageFile = (SIZE_T) __min(Memory64, MAXULONG_PTR);

    lpBuffer->dwTotalVirtual = (BASE_SYSINFO.MaximumUserModeAddress -
                                BASE_SYSINFO.MinimumUserModeAddress) + 1;

    lpBuffer->dwAvailVirtual = lpBuffer->dwTotalVirtual - VmCounters.VirtualSize;

#if !defined(_WIN64)

    //
    // Lie about available memory if application can't handle large (>2GB) addresses
    //
    Peb = NtCurrentPeb();
    NtHeaders = RtlImageNtHeader( Peb->ImageBaseAddress );
    if (NtHeaders && !(NtHeaders->FileHeader.Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE)) {
        if (lpBuffer->dwTotalPhys > 0x7FFFFFFF) {
            lpBuffer->dwTotalPhys = 0x7FFFFFFF;
            }
        if (lpBuffer->dwAvailPhys > 0x7FFFFFFF) {
            lpBuffer->dwAvailPhys = 0x7FFFFFFF;
            }
        if (lpBuffer->dwTotalVirtual > 0x7FFFFFFF) {
            lpBuffer->dwTotalVirtual = 0x7FFFFFFF;
            }
        if (lpBuffer->dwAvailVirtual > 0x7FFFFFFF) {
            lpBuffer->dwAvailVirtual = 0x7FFFFFFF;
            }
        }
#endif

    return;
}


DWORD
APIENTRY
WmipWaitForMultipleObjectsEx(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on multiple waitable objects (up to
    MAXIMUM_WAIT_OBJECTS) is accomplished with the
    WaitForMultipleObjects function.

    This API can be used to wait on any of the specified objects to
    enter the signaled state, or all of the objects to enter the
    signaled state.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified objects entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any one of
    the above wait termination conditions, or because an I/O completion
    callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    nCount - A count of the number of objects that are to be waited on.

    lpHandles - An array of object handles.  Each handle must have
        SYNCHRONIZE access to the associated object.

    bWaitAll - A flag that supplies the wait type.  A value of TRUE
        indicates a "wait all".  A value of false indicates a "wait
        any".

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - indicates that the wait was terminated due to the
        TimeOut conditions.

    0 to MAXIMUM_WAIT_OBJECTS-1, indicates, in the case of wait for any
        object, the object number which satisfied the wait.  In the case
        of wait for all objects, the value only indicates that the wait
        was completed successfully.

    0xffffffff - The wait terminated due to an error. WmipGetLastError may be
        used to get additional error information.

    WAIT_ABANDONED_0 to (WAIT_ABANDONED_0)+(MAXIMUM_WAIT_OBJECTS - 1),
        indicates, in the case of wait for any object, the object number
        which satisfied the event, and that the object which satisfied
        the event was abandoned.  In the case of wait for all objects,
        the value indicates that the wait was completed successfully and
        at least one of the objects was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    DWORD i;
    LPHANDLE HandleArray;
    HANDLE Handles[ 8 ];
    PPEB Peb;

    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&Frame, NULL); // make the process default activation context active so that APCs are delivered under it
    __try {
        if (nCount > 8) {
            HandleArray = (LPHANDLE) RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), nCount*sizeof(HANDLE));
            if (HandleArray == NULL) {
                WmipBaseSetLastNTError(STATUS_NO_MEMORY);
                return 0xffffffff;
            }
        } else {
            HandleArray = Handles;
        }
        RtlCopyMemory(HandleArray,(LPVOID)lpHandles,nCount*sizeof(HANDLE));

        Peb = NtCurrentPeb();
        for (i=0;i<nCount;i++) {
            switch( HandleToUlong(HandleArray[i]) ) {
                case STD_INPUT_HANDLE:  HandleArray[i] = Peb->ProcessParameters->StandardInput;
                                        break;
                case STD_OUTPUT_HANDLE: HandleArray[i] = Peb->ProcessParameters->StandardOutput;
                                        break;
                case STD_ERROR_HANDLE:  HandleArray[i] = Peb->ProcessParameters->StandardError;
                                        break;
                }
            }

        pTimeOut = WmipBaseFormatTimeOut(&TimeOut,dwMilliseconds);
    rewait:
        Status = NtWaitForMultipleObjects(
                     (CHAR)nCount,
                     HandleArray,
                     bWaitAll ? WaitAll : WaitAny,
                     (BOOLEAN)bAlertable,
                     pTimeOut
                     );
        if ( !NT_SUCCESS(Status) ) {
            WmipBaseSetLastNTError(Status);
            Status = (NTSTATUS)0xffffffff;
            }
        else {
            if ( bAlertable && Status == STATUS_ALERTED ) {
                goto rewait;
                }
            }

        if (HandleArray != Handles) {
            RtlFreeHeap(RtlProcessHeap(), 0, HandleArray);
        }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&Frame);
    }

    return (DWORD)Status;
}

VOID
WmipSleep(
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    The execution of the current thread can be delayed for a specified
    interval of time with the Sleep function.

    The Sleep function causes the current thread to enter a
    waiting state until the specified interval of time has passed.

Arguments:

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    None.

--*/

{
    WmipSleepEx(dwMilliseconds,FALSE);
}

DWORD
APIENTRY
WmipSleepEx(
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    The execution of the current thread can be delayed for a specified
    interval of time with the SleepEx function.

    The SleepEx function causes the current thread to enter a waiting
    state until the specified interval of time has passed.

    If the bAlertable parameter is FALSE, the only way the SleepEx
    returns is when the specified time interval has passed.  If the
    bAlertable parameter is TRUE, then the SleepEx can return due to the
    expiration of the time interval (return value of 0), or because an
    I/O completion callback terminated the SleepEx early (return value
    of WAIT_IO_COMPLETION).

Arguments:

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  A timeout value of -1 specifies an infinite
        timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        SleepEx may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    0 - The SleepEx terminated due to expiration of the time interval.

    WAIT_IO_COMPLETION - The SleepEx terminated due to one or more I/O
        completion callbacks.

--*/
{
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    NTSTATUS Status;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&Frame, NULL); // make the process default activation context active so that APCs are delivered under it
    __try {
        pTimeOut = WmipBaseFormatTimeOut(&TimeOut,dwMilliseconds);
        if (pTimeOut == NULL) {
            //
            // If Sleep( -1 ) then delay for the longest possible integer
            // relative to now.
            //

            TimeOut.LowPart = 0x0;
            TimeOut.HighPart = 0x80000000;
            pTimeOut = &TimeOut;
            }

    rewait:
        Status = NtDelayExecution(
                    (BOOLEAN)bAlertable,
                    pTimeOut
                    );
        if ( bAlertable && Status == STATUS_ALERTED ) {
            goto rewait;
            }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&Frame);
    }

    return Status == STATUS_USER_APC ? WAIT_IO_COMPLETION : 0;
}

BOOL
APIENTRY
WmipSetThreadPriority(
    HANDLE hThread,
    int nPriority
    )

/*++

Routine Description:

    The specified thread's priority can be set using SetThreadPriority.

    A thread's priority may be set using SetThreadPriority.  This call
    allows the thread's relative execution importance to be communicated
    to the system.  The system normally schedules threads according to
    their priority.  The system is free to temporarily boost the
    priority of a thread when signifigant events occur (e.g.  keyboard
    or mouse input...).  Similarly, as a thread runs without blocking,
    the system will decay its priority.  The system will never decay the
    priority below the value set by this call.

    In the absence of system originated priority boosts, threads will be
    scheduled in a round-robin fashion at each priority level from
    THREAD_PRIORITY_TIME_CRITICAL to THREAD_PRIORITY_IDLE.  Only when there
    are no runnable threads at a higher level, will scheduling of
    threads at a lower level take place.

    All threads initially start at THREAD_PRIORITY_NORMAL.

    If for some reason the thread needs more priority, it can be
    switched to THREAD_PRIORITY_ABOVE_NORMAL or THREAD_PRIORITY_HIGHEST.
    Switching to THREAD_PRIORITY_TIME_CRITICAL should only be done in extreme
    situations.  Since these threads are given the highes priority, they
    should only run in short bursts.  Running for long durations will
    soak up the systems processing bandwidth starving threads at lower
    levels.

    If a thread needs to do low priority work, or should only run there
    is nothing else to do, its priority should be set to
    THREAD_PRIORITY_BELOW_NORMAL or THREAD_PRIORITY_LOWEST.  For extreme
    cases, THREAD_PRIORITY_IDLE can be used.

    Care must be taken when manipulating priorites.  If priorities are
    used carelessly (every thread is set to THREAD_PRIORITY_TIME_CRITICAL),
    the effects of priority modifications can produce undesireable
    effects (e.g.  starvation, no effect...).

Arguments:

    hThread - Supplies a handle to the thread whose priority is to be
        set.  The handle must have been created with
        THREAD_SET_INFORMATION access.

    nPriority - Supplies the priority value for the thread.  The
        following five priority values (ordered from lowest priority to
        highest priority) are allowed.

        nPriority Values:

        THREAD_PRIORITY_IDLE - The thread's priority should be set to
            the lowest possible settable priority.

        THREAD_PRIORITY_LOWEST - The thread's priority should be set to
            the next lowest possible settable priority.

        THREAD_PRIORITY_BELOW_NORMAL - The thread's priority should be
            set to just below normal.

        THREAD_PRIORITY_NORMAL - The thread's priority should be set to
            the normal priority value.  This is the value that all
            threads begin execution at.

        THREAD_PRIORITY_ABOVE_NORMAL - The thread's priority should be
            set to just above normal priority.

        THREAD_PRIORITY_HIGHEST - The thread's priority should be set to
            the next highest possible settable priority.

        THREAD_PRIORITY_TIME_CRITICAL - The thread's priority should be set
            to the highest possible settable priority.  This priority is
            very likely to interfere with normal operation of the
            system.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using WmipGetLastError.
--*/

{
    NTSTATUS Status;
    LONG BasePriority;

    BasePriority = (LONG)nPriority;


    //
    // saturation is indicated by calling with a value of 16 or -16
    //

    if ( BasePriority == THREAD_PRIORITY_TIME_CRITICAL ) {
        BasePriority = ((HIGH_PRIORITY + 1) / 2);
        }
    else if ( BasePriority == THREAD_PRIORITY_IDLE ) {
        BasePriority = -((HIGH_PRIORITY + 1) / 2);
        }
    Status = NtSetInformationThread(
                hThread,
                ThreadBasePriority,
                &BasePriority,
                sizeof(BasePriority)
                );
    if ( !NT_SUCCESS(Status) ) {
        WmipBaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;
}

BOOL
WmipDuplicateHandle(
    HANDLE hSourceProcessHandle,
    HANDLE hSourceHandle,
    HANDLE hTargetProcessHandle,
    LPHANDLE lpTargetHandle,
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwOptions
    )

/*++

Routine Description:

    A duplicate handle can be created with the DuplicateHandle function.

    This is a generic function and operates on the following object
    types:

        - Process Object

        - Thread Object

        - Mutex Object

        - Event Object

        - Semaphore Object

        - File Object

    Please note that Module Objects are not in this list.

    This function requires PROCESS_DUP_ACCESS to both the
    SourceProcessHandle and the TargetProcessHandle.  This function is
    used to pass an object handle from one process to another.  Once
    this call is complete, the target process needs to be informed of
    the value of the target handle.  The target process can then operate
    on the object using this handle value.

Arguments:

    hSourceProcessHandle - An open handle to the process that contains the
        handle to be duplicated. The handle must have been created with
        PROCESS_DUP_HANDLE access to the process.

    hSourceHandle - An open handle to any object that is valid in the
        context of the source process.

    hTargetProcessHandle - An open handle to the process that is to
        receive the duplicated handle.  The handle must have been
        created with PROCESS_DUP_HANDLE access to the process.

    lpTargetHandle - A pointer to a variable which receives the new handle
        that points to the same object as SourceHandle does.  This
        handle value is valid in the context of the target process.

    dwDesiredAccess - The access requested to for the new handle.  This
        parameter is ignored if the DUPLICATE_SAME_ACCESS option is
        specified.

    bInheritHandle - Supplies a flag that if TRUE, marks the target
        handle as inheritable.  If this is the case, then the target
        handle will be inherited to new processes each time the target
        process creates a new process using CreateProcess.

    dwOptions - Specifies optional behaviors for the caller.

        Options Flags:

        DUPLICATE_CLOSE_SOURCE - The SourceHandle will be closed by
            this service prior to returning to the caller.  This occurs
            regardless of any error status returned.

        DUPLICATE_SAME_ACCESS - The DesiredAccess parameter is ignored
            and instead the GrantedAccess associated with SourceHandle
            is used as the DesiredAccess when creating the TargetHandle.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using WmipGetLastError.

--*/

{
    NTSTATUS Status;
    PPEB Peb;

    Peb = NtCurrentPeb();
    switch( HandleToUlong(hSourceHandle) ) {
        case STD_INPUT_HANDLE:  hSourceHandle = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hSourceHandle = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hSourceHandle = Peb->ProcessParameters->StandardError;
                                break;
        }

    Status = NtDuplicateObject(
                hSourceProcessHandle,
                hSourceHandle,
                hTargetProcessHandle,
                lpTargetHandle,
                (ACCESS_MASK)dwDesiredAccess,
                bInheritHandle ? OBJ_INHERIT : 0,
                dwOptions
                );
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        WmipBaseSetLastNTError(Status);
        return FALSE;
        }

    return FALSE;
}

UINT
WmipSetErrorMode(
    UINT uMode
    )
{

    UINT PreviousMode;
    UINT NewMode;

    PreviousMode = WmipGetErrorMode();

    NewMode = uMode;
    if (NewMode & SEM_FAILCRITICALERRORS ) {
        NewMode &= ~SEM_FAILCRITICALERRORS;
        }
    else {
        NewMode |= SEM_FAILCRITICALERRORS;
        }

    //
    // Once SEM_NOALIGNMENTFAULTEXCEPT has been enabled for a given
    // process, it cannot be disabled via this API.
    //

    NewMode |= (PreviousMode & SEM_NOALIGNMENTFAULTEXCEPT);

    if ( NT_SUCCESS(NtSetInformationProcess(
                        NtCurrentProcess(),
                        ProcessDefaultHardErrorMode,
                        (PVOID) &NewMode,
                        sizeof(NewMode)
                        ) ) ){
        }

    return( PreviousMode );
}

UINT
WmipGetErrorMode()
{

    UINT PreviousMode;
    NTSTATUS Status;

    Status = NtQueryInformationProcess(
                NtCurrentProcess(),
                ProcessDefaultHardErrorMode,
                (PVOID) &PreviousMode,
                sizeof(PreviousMode),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        WmipBaseSetLastNTError(Status);
        return 0;
        }

    if (PreviousMode & 1) {
        PreviousMode &= ~SEM_FAILCRITICALERRORS;
        }
    else {
        PreviousMode |= SEM_FAILCRITICALERRORS;
        }
    return PreviousMode;
}

ULONG WmipBuildGuidObjectAttributes(
    IN LPGUID Guid,
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PUNICODE_STRING GuidString,
    OUT PWCHAR GuidObjectName
    )
{
    WCHAR GuidChar[37];

	WmipAssert(Guid != NULL);
    
    //
    // Build up guid name into the ObjectAttributes
    //
    swprintf(GuidChar, L"%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
               Guid->Data1, Guid->Data2, 
               Guid->Data3,
               Guid->Data4[0], Guid->Data4[1],
               Guid->Data4[2], Guid->Data4[3],
               Guid->Data4[4], Guid->Data4[5],
               Guid->Data4[6], Guid->Data4[7]);

	WmipAssert(wcslen(GuidChar) == 36);
	
	wcscpy(GuidObjectName, WmiGuidObjectDirectory);
	wcscat(GuidObjectName, GuidChar);    
	RtlInitUnicodeString(GuidString, GuidObjectName);
    
	memset(ObjectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
	ObjectAttributes->Length = sizeof(OBJECT_ATTRIBUTES);
	ObjectAttributes->ObjectName = GuidString;
	
    return(ERROR_SUCCESS);    
}

HANDLE
APIENTRY
WmipCreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    )
{
	HANDLE ThreadHandle;

	NTSTATUS st =
            RtlCreateUserThread(
                NtCurrentProcess(),     // process handle
                lpThreadAttributes,     // security descriptor
                TRUE,                   // Create suspended?
                0L,                     // ZeroBits: default
                dwStackSize,            // Max stack size: default
                0L,                     // Committed stack size: default
                lpStartAddress,         // Function to start in
                lpParameter,			// Event the thread signals when ready
                &ThreadHandle,		    // Thread handle return
                (PCLIENT_ID)lpThreadId  // Thread id
            );

    if(NT_SUCCESS(st)){

        st = NtResumeThread(ThreadHandle,NULL);
    }

    if(NT_SUCCESS(st)){
        
	    return ThreadHandle;

    } else {

        return NULL;
    }
}


/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////

// TLS FUNCTIONS

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////

DWORD
WmipTlsAlloc(
    VOID
    )

/*++

Routine Description:

    A TLS index may be allocated using TlsAllocHelper.  Win32 garuntees a
    minimum number of TLS indexes are available in each process.  The
    constant TLS_MINIMUM_AVAILABLE defines the minimum number of
    available indexes.  This minimum is at least 64 for all Win32
    systems.

Arguments:

    None.

Return Value:

    Not-0xffffffff - Returns a TLS index that may be used in a
        subsequent call to TlsFreeHelper, TlsSetValueHelper, or TlsGetValueHelper.  The
        storage associated with the index is initialized to NULL.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    PPEB Peb;
    PTEB Teb;
    DWORD Index;

    Peb = NtCurrentPeb();
    Teb = NtCurrentTeb();

    RtlAcquirePebLock();
    try {

        Index = RtlFindClearBitsAndSet((PRTL_BITMAP)Peb->TlsBitmap,1,0);
        if ( Index == 0xffffffff ) {
            Index = RtlFindClearBitsAndSet((PRTL_BITMAP)Peb->TlsExpansionBitmap,1,0);
            if ( Index == 0xffffffff ) {
                //WmipSetLastError(RtlNtStatusToDosError(STATUS_NO_MEMORY));
                }
            else {
                if ( !Teb->TlsExpansionSlots ) {
                    Teb->TlsExpansionSlots = RtlAllocateHeap(
                                                RtlProcessHeap(),
                                                MAKE_TAG( TMP_TAG ) | HEAP_ZERO_MEMORY,
                                                TLS_EXPANSION_SLOTS * sizeof(PVOID)
                                                );
                    if ( !Teb->TlsExpansionSlots ) {
                        RtlClearBits((PRTL_BITMAP)Peb->TlsExpansionBitmap,Index,1);
                        Index = 0xffffffff;
                        //WmipSetLastError(RtlNtStatusToDosError(STATUS_NO_MEMORY));
                        return Index;
                        }
                    }
                Teb->TlsExpansionSlots[Index] = NULL;
                Index += TLS_MINIMUM_AVAILABLE;
                }
            }
        else {
            Teb->TlsSlots[Index] = NULL;
            }
        }
    finally {
        RtlReleasePebLock();
        }
#if DBG
    Index |= TLS_MASK;
#endif
    return Index;
}

LPVOID
WmipTlsGetValue(
    DWORD dwTlsIndex
    )

/*++

Routine Description:

    This function is used to retrive the value in the TLS storage
    associated with the specified index.

    If the index is valid this function clears the value returned by
    GetLastError(), and returns the value stored in the TLS slot
    associated with the specified index.  Otherwise a value of NULL is
    returned with GetLastError updated appropriately.

    It is expected, that DLLs will use TlsAllocHelper and TlsGetValueHelper as
    follows:

      - Upon DLL initialization, a TLS index will be allocated using
        TlsAllocHelper.  The DLL will then allocate some dynamic storage and
        store its address in the TLS slot using TlsSetValueHelper.  This
        completes the per thread initialization for the initial thread
        of the process.  The TLS index is stored in instance data for
        the DLL.

      - Each time a new thread attaches to the DLL, the DLL will
        allocate some dynamic storage and store its address in the TLS
        slot using TlsSetValueHelper.  This completes the per thread
        initialization for the new thread.

      - Each time an initialized thread makes a DLL call requiring the
        TLS, the DLL will call TlsGetValueHelper to get the TLS data for the
        thread.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAllocHelper.  The
        index specifies which TLS slot is to be located.  Translating a
        TlsIndex does not prevent a TlsFreeHelper call from proceding.

Return Value:

    NON-NULL - The function was successful. The value is the data stored
        in the TLS slot associated with the specified index.

    NULL - The operation failed, or the value associated with the
        specified index was NULL.  Extended error status is available
        using GetLastError.  If this returns non-zero, the index was
        invalid.

--*/
{
    PTEB Teb;
    LPVOID *Slot;

#if DBG
    // See if the Index passed in is from TlsAllocHelper or random goo...
    ASSERTMSG( "BASEDLL: Invalid TlsIndex passed to TlsGetValueHelper\n", (dwTlsIndex & TLS_MASK));
    dwTlsIndex &= ~TLS_MASK;
#endif

    Teb = NtCurrentTeb();

    if ( dwTlsIndex < TLS_MINIMUM_AVAILABLE ) {
        Slot = &Teb->TlsSlots[dwTlsIndex];
        Teb->LastErrorValue = 0;
        return *Slot;
        }
    else {
        if ( dwTlsIndex >= TLS_MINIMUM_AVAILABLE+TLS_EXPANSION_SLOTS ) {
            WmipSetLastError(RtlNtStatusToDosError(STATUS_INVALID_PARAMETER));
            return NULL;
            }
        else {
            Teb->LastErrorValue = 0;
            if ( Teb->TlsExpansionSlots ) {
                return  Teb->TlsExpansionSlots[dwTlsIndex-TLS_MINIMUM_AVAILABLE];
                }
            else {
                return NULL;
                }
            }
        }
}

BOOL
WmipTlsSetValue(
    DWORD dwTlsIndex,
    LPVOID lpTlsValue
    )

/*++

Routine Description:

    This function is used to store a value in the TLS storage associated
    with the specified index.

    If the index is valid this function stores the value and returns
    TRUE. Otherwise a value of FALSE is returned.

    It is expected, that DLLs will use TlsAllocHelper and TlsSetValueHelper as
    follows:

      - Upon DLL initialization, a TLS index will be allocated using
        TlsAllocHelper.  The DLL will then allocate some dynamic storage and
        store its address in the TLS slot using TlsSetValueHelper.  This
        completes the per thread initialization for the initial thread
        of the process.  The TLS index is stored in instance data for
        the DLL.

      - Each time a new thread attaches to the DLL, the DLL will
        allocate some dynamic storage and store its address in the TLS
        slot using TlsSetValueHelper.  This completes the per thread
        initialization for the new thread.

      - Each time an initialized thread makes a DLL call requiring the
        TLS, the DLL will call TlsGetValueHelper to get the TLS data for the
        thread.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAllocHelper.  The
        index specifies which TLS slot is to be located.  Translating a
        TlsIndex does not prevent a TlsFreeHelper call from proceding.

    lpTlsValue - Supplies the value to be stored in the TLS Slot.

Return Value:

    TRUE - The function was successful. The value lpTlsValue was
        stored.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PTEB Teb;

#if DBG
    // See if the Index passed in is from TlsAllocHelper or random goo...
    ASSERTMSG( "BASEDLL: Invalid TlsIndex passed to TlsSetValueHelper\n", (dwTlsIndex & TLS_MASK));
    dwTlsIndex &= ~TLS_MASK;
#endif

    Teb = NtCurrentTeb();

    if ( dwTlsIndex >= TLS_MINIMUM_AVAILABLE ) {
        dwTlsIndex -= TLS_MINIMUM_AVAILABLE;
        if ( dwTlsIndex < TLS_EXPANSION_SLOTS ) {
            if ( !Teb->TlsExpansionSlots ) {
                RtlAcquirePebLock();
                if ( !Teb->TlsExpansionSlots ) {
                    Teb->TlsExpansionSlots = RtlAllocateHeap(
                                                RtlProcessHeap(),
                                                MAKE_TAG( TMP_TAG ) | HEAP_ZERO_MEMORY,
                                                TLS_EXPANSION_SLOTS * sizeof(PVOID)
                                                );
                    if ( !Teb->TlsExpansionSlots ) {
                        RtlReleasePebLock();
                        WmipSetLastError(RtlNtStatusToDosError(STATUS_NO_MEMORY));
                        return FALSE;
                        }
                    }
                RtlReleasePebLock();
                }
            Teb->TlsExpansionSlots[dwTlsIndex] = lpTlsValue;
            }
        else {
            WmipSetLastError(RtlNtStatusToDosError(STATUS_INVALID_PARAMETER));
            return FALSE;
            }
        }
    else {
        Teb->TlsSlots[dwTlsIndex] = lpTlsValue;
        }
    return TRUE;
}

BOOL
WmipTlsFree(
    DWORD dwTlsIndex
    )

/*++

Routine Description:

    A valid TLS index may be free'd using TlsFreeHelper.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAllocHelper.  If the
        index is a valid index, it is released by this call and is made
        available for reuse.  DLLs should be carefull to release any
        per-thread data pointed to by all of their threads TLS slots
        before calling this function.  It is expected that DLLs will
        only call this function (if at ALL) during their process detach
        routine.

Return Value:

    TRUE - The operation was successful.  Calling TlsTranslateIndex with
        this index will fail.  TlsAllocHelper is free to reallocate this
        index.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PPEB Peb;
    BOOLEAN ValidIndex;
    PRTL_BITMAP TlsBitmap;
    NTSTATUS Status;
    DWORD Index2;

#if DBG
    // See if the Index passed in is from TlsAllocHelper or random goo...
    ASSERTMSG( "BASEDLL: Invalid TlsIndex passed to TlsFreeHelper\n", (dwTlsIndex & TLS_MASK));
    dwTlsIndex &= ~TLS_MASK;
#endif

    Peb = NtCurrentPeb();

    RtlAcquirePebLock();
    try {

        if ( dwTlsIndex >= TLS_MINIMUM_AVAILABLE ) {
            Index2 = dwTlsIndex - TLS_MINIMUM_AVAILABLE;
            if ( Index2 >= TLS_EXPANSION_SLOTS ) {
                ValidIndex = FALSE;
                }
            else {
                TlsBitmap = (PRTL_BITMAP)Peb->TlsExpansionBitmap;
                ValidIndex = RtlAreBitsSet(TlsBitmap,Index2,1);
                }
            }
        else {
            TlsBitmap = (PRTL_BITMAP)Peb->TlsBitmap;
            Index2 = dwTlsIndex;
            ValidIndex = RtlAreBitsSet(TlsBitmap,Index2,1);
            }
        if ( ValidIndex ) {

            Status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadZeroTlsCell,
                        &dwTlsIndex,
                        sizeof(dwTlsIndex)
                        );
            if ( !NT_SUCCESS(Status) ) {
                WmipSetLastError(RtlNtStatusToDosError(STATUS_INVALID_PARAMETER));
                return FALSE;
                }

            RtlClearBits(TlsBitmap,Index2,1);
            }
        else {
            WmipSetLastError(RtlNtStatusToDosError(STATUS_INVALID_PARAMETER));
            }
        }
    finally {
        RtlReleasePebLock();
        }
    return ValidIndex;
}

BOOL
WmipBasep8BitStringToDynamicUnicodeString(
    OUT PUNICODE_STRING UnicodeString,
    IN LPCSTR lpSourceString
    )
/*++

Routine Description:

    Captures and converts a 8-bit (OEM or ANSI) string into a heap-allocated
    UNICODE string

Arguments:

    UnicodeString - location where UNICODE_STRING is stored

    lpSourceString - string in OEM or ANSI

Return Value:

    TRUE if string is correctly stored, FALSE if an error occurred.  In the
    error case, the last error is correctly set.

--*/

{
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    //
    //  Convert input into dynamic unicode string
    //

    RtlInitString( &AnsiString, lpSourceString );
    Status = RtlAnsiStringToUnicodeString( UnicodeString, &AnsiString, TRUE );

    //
    //  If we couldn't do this, fail
    //

    if (!NT_SUCCESS( Status )){
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            WmipSetLastError( ERROR_FILENAME_EXCED_RANGE );
        } else {
            WmipBaseSetLastNTError( Status );
        }
        return FALSE;
        }

    return TRUE;
}


DWORD
APIENTRY
WmipGetFullPathNameA(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    )

/*++

Routine Description:

    ANSI thunk to GetFullPathNameW

--*/

{

    NTSTATUS Status;
    ULONG UnicodeLength;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING UnicodeResult;
    ANSI_STRING AnsiResult;
    PWSTR Ubuff;
    PWSTR FilePart;
    PWSTR *FilePartPtr;
    INT PrefixLength = 0;

    if ( ARGUMENT_PRESENT(lpFilePart) ) {
        FilePartPtr = &FilePart;
        }
    else {
        FilePartPtr = NULL;
        }

    if (!WmipBasep8BitStringToDynamicUnicodeString( &UnicodeString, lpFileName )) {
        return 0;
    }

    Ubuff = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (MAX_PATH<<1) + sizeof(UNICODE_NULL));
    if ( !Ubuff ) {
        RtlFreeUnicodeString(&UnicodeString);
        WmipBaseSetLastNTError(STATUS_NO_MEMORY);
        return 0;
        }

    UnicodeLength = RtlGetFullPathName_U(
                        UnicodeString.Buffer,
                        (MAX_PATH<<1),
                        Ubuff,
                        FilePartPtr
                        );

    //
    // UnicodeLength contains the byte count of unicode string.
    // Original code does "UnicodeLength / sizeof(WCHAR)" to get
    // the size of corresponding ansi string.
    // This is correct in SBCS environment. However in DBCS environment,
    // it's definitely WRONG.
    //
    if ( UnicodeLength <= ((MAX_PATH * sizeof(WCHAR) + sizeof(UNICODE_NULL))) ) {

        Status = RtlUnicodeToMultiByteSize(&UnicodeLength, Ubuff, UnicodeLength);
        //
        // At this point, UnicodeLength variable contains
        // Ansi based byte length.
        //
        if ( NT_SUCCESS(Status) ) {
            if ( UnicodeLength && ARGUMENT_PRESENT(lpFilePart) && FilePart != NULL ) {
                INT UnicodePrefixLength;

                UnicodePrefixLength = (INT)(FilePart - Ubuff) * sizeof(WCHAR);
                Status = RtlUnicodeToMultiByteSize( &PrefixLength,
                                                    Ubuff,
                                                    UnicodePrefixLength );
                //
                // At this point, PrefixLength variable contains
                // Ansi based byte length.
                //
                if ( !NT_SUCCESS(Status) ) {
                    WmipBaseSetLastNTError(Status);
                    UnicodeLength = 0;
                }
            }
        } else {
            WmipBaseSetLastNTError(Status);
            UnicodeLength = 0;
        }
    } else {
        //
        // we exceed the MAX_PATH limit. we should log the error and
        // return zero. however US code returns the byte count of
        // buffer required and doesn't log any error.
        //
        UnicodeLength = 0;
    }
    if ( UnicodeLength && UnicodeLength < nBufferLength ) {
        RtlInitUnicodeString(&UnicodeResult,Ubuff);
        Status = BasepUnicodeStringTo8BitString(&AnsiResult,&UnicodeResult,TRUE);
        if ( NT_SUCCESS(Status) ) {
            RtlMoveMemory(lpBuffer,AnsiResult.Buffer,UnicodeLength+1);
            RtlFreeAnsiString(&AnsiResult);

            if ( ARGUMENT_PRESENT(lpFilePart) ) {
                if ( FilePart == NULL ) {
                    *lpFilePart = NULL;
                    }
                else {
                    *lpFilePart = lpBuffer + PrefixLength;
                    }
                }
            }
        else {
            WmipBaseSetLastNTError(Status);
            UnicodeLength = 0;
            }
        }
    else {
        if ( UnicodeLength ) {
            UnicodeLength++;
            }
        }
    RtlFreeUnicodeString(&UnicodeString);
    RtlFreeHeap(RtlProcessHeap(), 0,Ubuff);

    return (DWORD)UnicodeLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\proppage\wmiprop.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       wmiprop.c
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <prsht.h>
#include <ole2.h>

extern "C" {
#include <commdlg.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include <regstr.h>
}

#include <wbemidl.h>

#include "wmiprop.h"
#include "resource.h"


HINSTANCE g_hInstance;



#if DBG
#define DEBUG_HEAP 1

#define WmiAssert(x) if (! (x) ) { \
    DebugPrint((1, "WMI Assertion: "#x" at %s %d\n", __FILE__, __LINE__)); \
    DebugBreak(); }
#else
#define WmiAssert(x)
#endif

#if DEBUG_HEAP
#undef LocalAlloc
#undef LocalFree
#define LocalAlloc(lptr, size) DebugAlloc(size)
#define LocalFree(p) DebugFree(p)

PVOID WmiPrivateHeap;

PVOID DebugAlloc(ULONG size)
{
    PVOID p = NULL;
    
    if (WmiPrivateHeap == NULL)
    {
        WmiPrivateHeap = RtlCreateHeap(HEAP_GROWABLE | 
                                      HEAP_TAIL_CHECKING_ENABLED |
                                      HEAP_FREE_CHECKING_ENABLED | 
                                      HEAP_DISABLE_COALESCE_ON_FREE,
                                      NULL,
                                      0,
                                      0,
                                      NULL,
                                      NULL);
    }
    
    if (WmiPrivateHeap != NULL)
    {
        p = RtlAllocateHeap(WmiPrivateHeap, 0, size);
        if (p != NULL)
        {
            memset(p, 0, size);
        }
    }
    return(p);
}

void DebugFree(PVOID p)
{
    RtlFreeHeap(WmiPrivateHeap, 0, p);
}
#endif

#if DBG
PCHAR WmiGuidToString(
    PCHAR s,
    LPGUID piid
    )
{
    GUID XGuid = *piid;

    sprintf(s, "%x-%x-%x-%x%x%x%x%x%x%x%x",
               XGuid.Data1, XGuid.Data2,
               XGuid.Data3,
               XGuid.Data4[0], XGuid.Data4[1],
               XGuid.Data4[2], XGuid.Data4[3],
               XGuid.Data4[4], XGuid.Data4[5],
               XGuid.Data4[6], XGuid.Data4[7]);

    return(s);
}
#endif

TCHAR *WmiDuplicateString(
    TCHAR *String
    )
{
    ULONG Len;
    PTCHAR Copy;

    Len = _tcslen(String);
    Copy = (PTCHAR)LocalAlloc(LPTR,
                              (Len+1) * sizeof(TCHAR));
    if (Copy != NULL)
    {
        _tcscpy(Copy, String);
    }
    return(Copy);
}

BOOLEAN WmiGetDataBlockDesc(
    IN IWbemServices *pIWbemServices,
    IN IWbemClassObject *pIWbemClassObject,
    OUT PDATA_BLOCK_DESCRIPTION *DBD,
    IN PDATA_BLOCK_DESCRIPTION ParentDataBlockDesc,
    IN BOOLEAN IsParentReadOnly
    );

BOOLEAN WmiRefreshDataBlockFromWbem(
    IWbemClassObject *pIWbemClassObject,
    PDATA_BLOCK_DESCRIPTION DataBlockDesc
    );

BOOLEAN WmiRefreshWbemFromDataBlock(
    IN IWbemServices *pIWbemServices,
    IN IWbemClassObject *pIWbemClassObject,
    IN PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    IN BOOLEAN IsEmbeddedClass
    );


BOOLEAN WmiBstrToTchar(
    OUT PTCHAR *TString,
    IN BSTR BString
    )
/*+++

Routine Description:

    This routine will convert a BSTR into a TCHAR *
        
Arguments:

    BString is the BSTR to convert from
        
    *TString returns with a pointer to a string containing the contents of
        the BSTR. It should be freed with LocalFree.

Return Value:

    TRUE if successful else FALSE

---*/
{
    ULONG SizeNeeded;
    BOOLEAN ReturnStatus;
    
    WmiAssert(BString != NULL);
    WmiAssert(TString != NULL);
    
    SizeNeeded = (SysStringLen(BString)+1) * sizeof(TCHAR);
    *TString = (PTCHAR)LocalAlloc(LPTR, SizeNeeded);
    if (*TString != NULL)
    {
        _tcscpy(*TString, BString);
        ReturnStatus = TRUE;
    } else {
        ReturnStatus = FALSE;
    }
    return(ReturnStatus);
}

BOOLEAN WmiBstrToUlong64(
    OUT PULONG64 Number,
    IN BSTR BString
    )
/*+++

Routine Description:

    This routine will convert a BSTR into a ULONG64 number
        
Arguments:

    BString is the BSTR to convert from
        
    *Number returns with the value of the contents of BString converted to
        a number

Return Value:

    TRUE if successful else FALSE

---*/
{
    WmiAssert(BString != NULL);
    WmiAssert(Number != NULL);

    *Number = _ttoi64(BString);
    
    return(TRUE);
}

BOOLEAN WmiGetArraySize(
    IN SAFEARRAY *Array,
    OUT LONG *LBound,
    OUT LONG *UBound,
    OUT LONG *NumberElements
)
/*+++

Routine Description:

    This routine will information about the size and bounds of a single
    dimensional safe array.
        
Arguments:

    Array is the safe array
        
    *LBound returns with the lower bound of the array

    *UBound returns with the upper bound of the array
        
    *NumberElements returns with the number of elements in the array

Return Value:

    TRUE if successful else FALSE

---*/
{
    HRESULT hr;
    BOOLEAN ReturnStatus;

    WmiAssert(Array != NULL);
    WmiAssert(LBound != NULL);
    WmiAssert(UBound != NULL);
    WmiAssert(NumberElements != NULL);
    
    //
    // Only single dim arrays are supported
    //
    WmiAssert(SafeArrayGetDim(Array) == 1);
    
    hr = SafeArrayGetLBound(Array, 1, LBound);
    
    if (hr == WBEM_S_NO_ERROR)
    {
        hr = SafeArrayGetUBound(Array, 1, UBound);
        *NumberElements = (*UBound - *LBound) + 1;
        ReturnStatus = (hr == WBEM_S_NO_ERROR);
    } else {
        ReturnStatus = FALSE;
    }
    return(ReturnStatus);
}



BOOLEAN WmiConnectToWbem(
    PTCHAR MachineName,
    IWbemServices **pIWbemServices
    )
/*+++

Routine Description:

    This routine will establishes a connection to the WBEM service and
    saves the global IWbemServices interface

Arguments:

    MachineName is the name of the remote machine we should connect to.
    If NULL then we connect to the local machine.

Return Value:

    if this routine is successful then *pIWbemServices will have a valid
    IWbemServices pointer, if not then it is NULL.

---*/
{
    #define Namespace TEXT("root\\wmi")
    
    IWbemLocator *pIWbemLocator;
    DWORD hr;
    SCODE sc;
    BSTR s;
    BOOLEAN ReturnStatus = FALSE;
    PTCHAR NamespacePath;
    
    WmiAssert(pIWbemServices != NULL);

    if (MachineName == NULL)
    {
        NamespacePath = Namespace;
    } else {
        NamespacePath = (PTCHAR)LocalAlloc(LPTR,  (_tcslen(Namespace) +
                                           _tcslen(MachineName) +
                                           2) * sizeof(TCHAR) );
        if (NamespacePath != NULL)
        {
            _tcscpy(NamespacePath, MachineName);
            _tcscat(NamespacePath, TEXT("\\"));
            _tcscat(NamespacePath, Namespace);
        } else {
            DebugPrint((1, "WMIPROP: Could not alloc memory for NamespacePath\n"));
            return(FALSE);
        }
    }
    
    hr = CoCreateInstance(CLSID_WbemLocator,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pIWbemLocator);
    if (hr == S_OK)
    {
        s = SysAllocString(NamespacePath);
        if (s != NULL)
        {
            *pIWbemServices = NULL;
            sc = pIWbemLocator->ConnectServer(s,
                            NULL,                           // Userid
                            NULL,                           // PW
                            NULL,                           // Locale
                            0,                              // flags
                            NULL,                           // Authority
                            NULL,                           // Context
                            pIWbemServices
                           );
                       
           SysFreeString(s);
                       
           if (sc != WBEM_NO_ERROR) 
           {
               *pIWbemServices = NULL;
           } else {
               //
               // Set security level to IMPERSONATE so that access
               // to wbem objects will be granted
               //
               sc = CoSetProxyBlanket( (IUnknown *)*pIWbemServices,
                                       RPC_C_AUTHN_WINNT,
                                       RPC_C_AUTHZ_NONE,
                                       NULL,
                                       RPC_C_AUTHN_LEVEL_CALL,
                                       RPC_C_IMP_LEVEL_IMPERSONATE,
                                       NULL,
                                       0);
                   
               if (sc == S_OK)
               {
                   ReturnStatus = TRUE;
               } else {
                    (*pIWbemServices)->Release();
                   *pIWbemServices = NULL;
               }
           }
       
           pIWbemLocator->Release();
       } else {
           *pIWbemServices = NULL;
       }
    }
    
    if (MachineName != NULL)
    {       
        LocalFree(NamespacePath);
    }
    
    return(ReturnStatus);
}

#define IsWhiteSpace(c) ( (c == TEXT(' ')) || (c == TEXT('\t')) )

BOOLEAN WmiHexToUlong64(
    IN PTCHAR Text,
    OUT PULONG64 Number
    )
/*+++

Routine Description:

    This routine will convert a string with number in hex format into
    a ULONG64
        
Arguments:

    Text is the string
        
    *Number returns with the hex value for string

Return Value:

    TRUE if successful else FALSE

---*/
{
    ULONG64 Value;
    ULONG Count;

    WmiAssert(Text != NULL);
    WmiAssert(Number != NULL);
    
    Value = 0;
    Count = 0;
    while ((*Text != 0) && (! IsWhiteSpace(*Text)))
    {
        if (Count == 16)
        {
            return(FALSE);
        }
        
        if (*Text >= '0' && *Text <= '9')
            Value = (Value << 4) + *Text - '0';
        else if (*Text >= 'A' && *Text <= 'F')
            Value = (Value << 4) + *Text - 'A' + 10;
        else if (*Text >= 'a' && *Text <= 'f')
            Value = (Value << 4) + *Text - 'a' + 10;
        else
            return(FALSE);
        
        Text++;
    }

    *Number = Value;
    return(TRUE);
    
}

BOOLEAN WmiValidateRange(
    IN struct _DATA_ITEM_DESCRIPTION *DataItemDesc,
    OUT PULONG64 Number,
    IN PTCHAR Text
    )
/*+++

Routine Description:

    This routine will validate that the value proposed for the property is
    correct. It checks that the value is a well formed number and within
    the appropriate range
        
Arguments:

    DataItemDesc is the data item description for the property being validated

    *Number returns with the value as a ULONG64
        
    Text is the proposed value for the property. Note that hex values are
        required to be preceeded with 0x
        
Return Value:

    TRUE if Value is appropriate for the property

---*/
{
    #define HexMarkerText TEXT("0x")
        
    BOOLEAN ReturnStatus;
    PTCHAR s;
    PRANGELISTINFO RangeListInfo;
    PRANGEINFO RangeInfo;
    ULONG i;
   
    WmiAssert(DataItemDesc != NULL);
    WmiAssert(Number != NULL);
    WmiAssert(Text != NULL);
    
    //
    // Skip over any leading spaces
    //
    s = Text;
    while (IsWhiteSpace(*s) && (*s != 0))
    {
        s++;
    }
    
    if (*s != 0)
    {
        //
        // If this is not an empty string then go parse the number
        //
        if (_tcsnicmp(s, 
                      HexMarkerText, 
                      (sizeof(HexMarkerText) / sizeof(TCHAR))-1) == 0)
        {
            //
            // this is a hex number (starts with 0x), advance string ptr
            // and setup to use hex digit validation
            //
            s += (sizeof(HexMarkerText) / sizeof(TCHAR)) - 1;
            ReturnStatus = WmiHexToUlong64(s, Number);
        } else {
            *Number = _ttoi64(s);
            ReturnStatus = TRUE;
            while ((*s != 0) && ReturnStatus)
            {
                ReturnStatus = (_istdigit(*s) != 0);
                s++;
            }    
        }

        //
        // Make sure that all characters are digits
        //
        if (ReturnStatus)
        {
            //
            // Now verify that the value is within the correct range
            //
            RangeListInfo = DataItemDesc->RangeListInfo;
            WmiAssert(RangeListInfo != NULL);
            
            ReturnStatus = FALSE;
            for (i = 0; (i < RangeListInfo->Count) && (! ReturnStatus); i++)
            {
                RangeInfo = &RangeListInfo->Ranges[i];
                ReturnStatus = ( (*Number >= RangeInfo->Minimum) &&
                                 (*Number <= RangeInfo->Maximum) );
            }
        }
    } else {
        ReturnStatus = FALSE;
    }
    return(ReturnStatus);
}

BOOLEAN WmiValidateDateTime(
    IN struct _DATA_ITEM_DESCRIPTION *DataItemDesc,
    IN PTCHAR Value
    )
/*+++

Routine Description:

    This routine will validate that the value proposed for the property is
    correct. It will make sure that it is in a valid format for a 
    DATETIME with is of the form 19940525133015.000000-300
        
Arguments:

    DataItemDesc is the data item description for the property being validated

    Value is the proposed value for the property
        
Return Value:

    TRUE if Value is appropriate for the property

---*/
{
    #define DATETIME_LENGTH 25
        
    ULONG Length;
    BOOLEAN ReturnStatus;
    ULONG i;
    
    WmiAssert(DataItemDesc != NULL);
    WmiAssert(Value != NULL);
    
    //
    // Validate that datetime is in correct format
    // TODO: Validate that the component parts of the DATETIME are correct,
    //       for example that the month is between 1 and 12, the correct
    //       month doesn't have too many days, The time is ok (not 30:11)
    //
    Length = _tcslen(Value);
    if (Length == DATETIME_LENGTH)
    {
        ReturnStatus = TRUE;
        for (i = 0; (i < 14) && ReturnStatus; i++)
        {
            ReturnStatus = (_istdigit(Value[i]) != 0);
        }
        
        if (ReturnStatus)
        {
            ReturnStatus = (Value[14] == TEXT('.')) &&
                           ((Value[21] == TEXT('-')) ||
                            (Value[21] == TEXT('+')) );
                        
            if (ReturnStatus)
            {
                for (i = 22; (i < DATETIME_LENGTH) && ReturnStatus; i++)
                {
                    ReturnStatus =  (_istdigit(Value[i]) != 0);
                }
            }
        }
    } else {
        ReturnStatus = FALSE;
    }
        
    return(ReturnStatus);
}

BOOLEAN WmiGet8bitFromVariant(
    VARIANT *Value,
    PVOID Result
    )
{
    BOOLEAN ReturnStatus;
    
    ReturnStatus = TRUE;
    //
    // 8 bit values can come back as signed or unsigned
    // or as 16 or 32 bit values
    //
    switch(Value->vt)
    {
        case VT_I1:
        {
            *((PCHAR)Result) = Value->cVal;
            break;
        }
                            
        case VT_UI1:
        {
            *((PUCHAR)Result) = Value->bVal;
            break;
        }
                            
        case VT_I2:
        {
            *((PCHAR)Result) = (CHAR)Value->iVal;
            break;
        }
                            
        case VT_I4:
        {
            *((PCHAR)Result) = (CHAR)Value->lVal;
            break;
        }
                                
        default:
        {
            ReturnStatus = FALSE;
        }
    }
    return(ReturnStatus);
}

BOOLEAN WmiGet16bitFromVariant(
    VARIANT *Value,
    PVOID Result
    )
{
    BOOLEAN ReturnStatus;
    
    ReturnStatus = TRUE;
    //
    // 16 bit values can come back as signed or unsigned
    // or as 32 bit values
    //
    switch(Value->vt)
    {
        case VT_I2:
        {
            *((PSHORT)Result) = Value->iVal;
            break;
        }
                            
        case VT_UI2:
        {
            *((PUSHORT)Result) = Value->uiVal;
            break;
        }
                            
        case VT_I4:
        {
            *((PSHORT)Result) = (SHORT)Value->lVal;
            break;
        }
                                
        default:
        {
            ReturnStatus = FALSE;
        }
    }
    return(ReturnStatus);
}

BOOLEAN WmiGet32bitFromVariant(
    VARIANT *Value,
    PVOID Result
    )
{
    BOOLEAN ReturnStatus;
    
    ReturnStatus = TRUE;
    //
    // 32 bit values can come back as signed or unsigned
    //
    switch (Value->vt)
    {
        case VT_UI4:
        {
            *((PULONG)Result) = Value->ulVal;
            break;
        }
            
        case VT_I4:
        {
            *((PLONG)Result) = Value->lVal;
            break;
        }
            
        default:
        {
            ReturnStatus = FALSE;
        }
    }
    
    return(ReturnStatus);   
}

BOOLEAN WmiGetSint64FromVariant(
    VARIANT *Value,
    PVOID Result
    )
{
    BOOLEAN ReturnStatus;
    
    ReturnStatus = TRUE;
    
    //
    // 64 bit numbers are returned in a BSTR with the
    // number represented as a string. So we need to 
    // convert back to a 64bit number.
    //
    WmiAssert(Value->vt == VT_BSTR);
    *((PLONGLONG)Result) = _ttoi64(Value->bstrVal);
                        
    return(ReturnStatus);   
}

BOOLEAN WmiGetUint64FromVariant(
    VARIANT *Value,
    PVOID Result
    )
{
    BOOLEAN ReturnStatus;
    
    ReturnStatus = TRUE;
    
    //
    // 64 bit numbers are returned in a BSTR with the
    // number represented as a string. So we need to 
    // convert back to a 64bit number.
    //
    WmiAssert(Value->vt == VT_BSTR);
    *((PULONGLONG)Result) = _ttoi64(Value->bstrVal);
                        
    return(ReturnStatus);   
}

BOOLEAN WmiGetBooleanFromVariant(
    VARIANT *Value,
    PVOID Result
    )
{
    BOOLEAN ReturnStatus;
    
    ReturnStatus = TRUE;
    
    //
    // BOOLEAN values are true or false
    //
    WmiAssert(Value->vt == VT_BOOL);
    *((PBOOLEAN)Result) = (Value->boolVal != 0) ? 
                                            1 : 0;

    return(ReturnStatus);
}

BOOLEAN WmiGetStringFromVariant(
    VARIANT *Value,
    PVOID Result
    )
{
    BOOLEAN ReturnStatus;
    
    WmiAssert( *((PTCHAR)Result) == NULL);
    ReturnStatus = WmiBstrToTchar((PTCHAR *)Result,
                                  Value->bstrVal);
    
    return(ReturnStatus);
}


BOOLEAN WmiGetObjectFromVariant(
    VARIANT *Value,
    PVOID Result
    )
{
    IUnknown *punk;
    HRESULT hr;

    punk = Value->punkVal;
    hr = punk->QueryInterface(IID_IWbemClassObject,
                              (PVOID *)Result);
    
    return(hr == WBEM_S_NO_ERROR);
}

ULONG WmiGetElementSize(
    CIMTYPE CimType
    )
{
    ULONG Size;
    
    switch(CimType)
    {
        case CIM_UINT8:
        case CIM_SINT8:
        {
            Size = sizeof(CHAR);
            break;
        }
        
        case CIM_CHAR16:
        case CIM_UINT16:
        case CIM_SINT16:
        {
            Size = sizeof(SHORT);
            break;
        }
        
        case CIM_UINT32:
        case CIM_SINT32:
        {
            Size = sizeof(LONG);
            break;
        }
        
        case CIM_SINT64:
        {
            Size = sizeof(LONGLONG);
            break;
        }
        
        case CIM_UINT64:
        {
            Size = sizeof(ULONGLONG);
            break;
        }
        
        case CIM_BOOLEAN:
        {
            Size = sizeof(BOOLEAN);
            break;
        }
        
        case CIM_DATETIME:
        case CIM_STRING:
        {
            Size = sizeof(PTCHAR);
            break;
        }

        case CIM_OBJECT:
        {
            Size = sizeof(IWbemClassObject *);
            break;
        }
        
        //
        // Floating point values not supported
        //
        case CIM_REAL32:
        case CIM_REAL64:
            
        default:
        {
            Size = 0;
            break;
        }       
    }
    
    return(Size);
}


typedef BOOLEAN (*GETVALUEFROMVARIANTFUNC)(
    VARIANT *Value,
    PVOID Result
);


BOOLEAN WmiGetValueFunc(
    CIMTYPE CimType,
    GETVALUEFROMVARIANTFUNC *GetValueFunc
    )
{
    BOOLEAN ReturnStatus;
    
    ReturnStatus = TRUE;
    
    switch(CimType)
    {
        case CIM_UINT8:
        case CIM_SINT8:
        {
            *GetValueFunc = WmiGet8bitFromVariant;
            break;
        }
        
        case CIM_CHAR16:
        case CIM_UINT16:
        case CIM_SINT16:
        {
            *GetValueFunc = WmiGet16bitFromVariant;
            break;
        }
        
        case CIM_UINT32:
        case CIM_SINT32:
        {
            *GetValueFunc = WmiGet32bitFromVariant;
            break;
        }
        
        case CIM_SINT64:
        {
            *GetValueFunc = WmiGetSint64FromVariant;
            break;
        }
        
        case CIM_UINT64:
        {
            *GetValueFunc = WmiGetUint64FromVariant;
            break;
        }
        
        case CIM_BOOLEAN:
        {
            *GetValueFunc = WmiGetBooleanFromVariant;
            break;
        }
        
        case CIM_DATETIME:
        case CIM_STRING:
        {
            *GetValueFunc = WmiGetStringFromVariant;
            break;
        }

        case CIM_OBJECT:
        {
            *GetValueFunc = WmiGetObjectFromVariant;
            break;
        }
        
        //
        // Floating point values not supported
        //
        case CIM_REAL32:
        case CIM_REAL64:
            
        default:
        {
            *GetValueFunc = NULL;
            ReturnStatus = FALSE;
            break;
        }       
    }
    
    return(ReturnStatus);
}

BOOLEAN WmiRefreshDataItemFromWbem(
    IN OUT PDATA_ITEM_DESCRIPTION DataItemDesc,
    IN IWbemClassObject *pIWbemClassObject
    )
/*+++

Routine Description:

    This routine will call WBEM to get the latest value for the property
    represented by the DataItemDesc
        
Arguments:

    DataItemDesc is the data item description for the property

    pIWbemClassObject is the instance class object interface for the class
        
Return Value:

    TRUE if successful

---*/
{
    ULONG i;
    LONG i1;
    BSTR s;
    HRESULT hr;
    VARIANT Value;
    CIMTYPE ValueType;
    BOOLEAN ReturnStatus;
    ULONG ElementSize;
    GETVALUEFROMVARIANTFUNC GetValueFunc;

    WmiAssert(DataItemDesc != NULL);
    WmiAssert(pIWbemClassObject != NULL);

    DebugPrint((1,"WMI: Refreshing data item %ws\n", DataItemDesc->Name));
    ReturnStatus = FALSE;
    s = SysAllocString(DataItemDesc->Name);
    if (s != NULL)
    {
        hr = pIWbemClassObject->Get(s,
                                        0,
                                        &Value,
                                        &ValueType,
                                        NULL);
        if (hr == WBEM_S_NO_ERROR)
        {
            DebugPrint((1, "WMIPROP: Got value for %ws as variant type 0x%x, cim type 0x%x at variant %p\n",
                            s, Value.vt, ValueType, &Value));
            WmiAssert((ValueType & ~CIM_FLAG_ARRAY) == DataItemDesc->DataType);
            
            WmiCleanDataItemDescData(DataItemDesc);
            
            if ( (ValueType & CIM_FLAG_ARRAY) == 0)
            {
                //
                // Non Array value, just pull the value out of the variant
                // and stash into DataItemDesc
                //
                WmiAssert(DataItemDesc->IsVariableArray == 0);
                WmiAssert(DataItemDesc->IsFixedArray == 0);
                
                //
                // For all  types we get the getvalue
                // function and the pull the value out of the
                // variant and into the DataItemDesc
                //
                if (WmiGetValueFunc(DataItemDesc->DataType,
                                    &GetValueFunc))
                {
                    //
                    // TODO: Keep track of data item position and
                    //       padding within data block
                    //
                    ReturnStatus = (*GetValueFunc)(
                                       &Value,
                                   (PVOID)&DataItemDesc->Data);
#if DBG
                    if (ReturnStatus == FALSE)
                    {
                        DebugPrint((1, "WMIPROP: Property %ws is type %d, but got type %d variant %p\n",
                                        DataItemDesc->Name,
                                        DataItemDesc->DataType,
                                        Value.vt, &Value));
                                        WmiAssert(FALSE);
                    }
#endif
                }
                
            } else {
                //
                // Get all of the data for an array
                //
                LONG LBound, UBound, NumberElements;
                PUCHAR Array;
                LONG Index;
                VARIANT Element;
                ULONG ElementSize;
                ULONG SizeNeeded;
                VARTYPE vt;
            
                WmiAssert((DataItemDesc->IsVariableArray != 0) || 
                          (DataItemDesc->IsFixedArray != 0));
                
                WmiAssert(Value.vt & VT_ARRAY);
                
                if (WmiGetArraySize(Value.parray,
                                    &LBound,
                                    &UBound,
                                    &NumberElements))
                {
                    if (WmiGetValueFunc(DataItemDesc->DataType,
                                        &GetValueFunc))
                    {
                        //
                        // The size of each element is not allowed to
                        // change, but the number of elements are
                        //
                        WmiAssert(DataItemDesc->ArrayPtr == NULL);
                        ElementSize = DataItemDesc->DataSize;
                        SizeNeeded = NumberElements * ElementSize;

                        Array = (PUCHAR)LocalAlloc(LPTR, SizeNeeded);
                        DataItemDesc->ArrayElementCount = NumberElements;
                        DebugPrint((1,"WMIPROP: Alloc 0x%x bytes at %p\n", SizeNeeded, Array));
                        memset(Array, 0, SizeNeeded);
                        
                        if (Array != NULL)
                        {
                            // CONSIDER: Use SafeArrayAccessData for number
                            //           types
                            //
                            // Now that we have memory for the array data
                            // extract the data from the safe array and 
                            // store it in the C array
                            //
                            DataItemDesc->ArrayPtr = (PVOID)Array;
                            hr = SafeArrayGetVartype(Value.parray,
                                                     &vt);
                            if (hr == WBEM_S_NO_ERROR)
                            {
                                ReturnStatus = TRUE;
                                for (i1 = 0, Index = LBound; 
                                     (i1 < NumberElements) && ReturnStatus; 
                                     i1++, Index++)
                                {
                                    VariantInit(&Element);
                                    Element.vt = vt;
                                    hr = SafeArrayGetElement(Value.parray,
                                                             &Index,
                                                             &Element.boolVal);
                                    if (hr == WBEM_S_NO_ERROR)
                                    {    
                                        Element.vt = vt;
                                        DebugPrint((1, "WMIPROP: GetValueFunc at %p\n", Array));
                                        ReturnStatus = (*GetValueFunc)(
                                                                &Element,
                                                                (PVOID)Array);
                                        Array += ElementSize;
                                    } else {
                                        ReturnStatus = FALSE;
                                    }
                                }
                            }
                        }
                    } else {
                        DebugPrint((1, "WMIPROP: Property %ws is array of type %d, but got type %d variant %p\n",
                                            DataItemDesc->Name,
                                            DataItemDesc->DataType,
                                            Value.vt, &Value));
                        WmiAssert(FALSE);
                    }
                }
            }
            VariantClear(&Value);
        }
        
        SysFreeString(s);
    }
    
    return(ReturnStatus);
}

BOOLEAN WmiRefreshDataBlockFromWbem(
    IN IWbemClassObject *pIWbemClassObject,
    IN OUT PDATA_BLOCK_DESCRIPTION DataBlockDesc
    )
/*+++

Routine Description:

    This routine will call WBEM to get the latest values for all property
    in data block represented by the DataBlockDesc
        
Arguments:

    DataBlockDesc is the data item description for the class

    pIWbemClassObject is the instance class object interface for the class
        
Return Value:

    TRUE if successful

---*/
{
    PDATA_ITEM_DESCRIPTION DataItemDesc;
    BOOLEAN ReturnStatus;
    ULONG i;
    
    WmiAssert(DataBlockDesc != NULL);
    WmiAssert(pIWbemClassObject != NULL);
    
    ReturnStatus = TRUE;
    for (i = 0; (i < DataBlockDesc->DataItemCount) && ReturnStatus; i++)
    {
        DataItemDesc = &DataBlockDesc->DataItems[i];
        ReturnStatus = WmiRefreshDataItemFromWbem(DataItemDesc,
                                                  pIWbemClassObject);
    }
    
    return(ReturnStatus);
}

VARTYPE WmiVarTypeForCimType(
    CIMTYPE CimType
    )
{
    VARTYPE vt;
    
    //
    // Most things match their CIM types, except those below
    vt = (VARTYPE)CimType;
    
    switch(CimType)
    {
        case CIM_UINT8:
        case CIM_SINT8:
        {
            vt = VT_I4;
            break;
        }
                        
        case CIM_CHAR16:
        case CIM_UINT16:
        {
            vt = VT_I2;
            break;
        }
                                                                            
        case CIM_UINT32:                        
        {
            vt = VT_I4;
            break;
        }
                            
        case CIM_STRING:
        case CIM_DATETIME:
        case CIM_SINT64:
        case CIM_UINT64:
        {
            vt = VT_BSTR;
            break;
        }
        
        case CIM_OBJECT:
        {
            vt = VT_UNKNOWN;
            break;
        }
        
        case CIM_BOOLEAN:
        {
            vt = VT_BOOL;
            break;
        }
        
        
    }
    return(vt); 
}

typedef BOOLEAN (*SETVALUEFUNC)(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    );

BOOLEAN WmiSetBooleanValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    BOOLEAN Value;
    
    //
    // A boolean needs to ve expressed as a VARIANT_TRUE or VARIANT_FALSE
    //
    Value = *((PBOOLEAN)DataPtr);
    *((VARIANT_BOOL *)DestPtr) = Value ? VARIANT_TRUE : VARIANT_FALSE;
    *SetPtr = (PVOID)DestPtr;
    return(TRUE);
}

BOOLEAN WmiSetStringValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    BSTR s;
    PTCHAR String;
    BOOLEAN ReturnStatus;
    
    //
    // Strings must be converted to BSTR
    //
    String = *((PTCHAR *)DataPtr);
    
    WmiAssert(String != NULL);
    
    s = SysAllocString(String);
    if (s != NULL)
    {
        *((BSTR *)DestPtr) = s;
        *SetPtr = (PVOID)s;
        ReturnStatus = TRUE;
    } else {
        ReturnStatus = FALSE;
    }
    return(ReturnStatus);
}

BOOLEAN WmiSetEmbeddedValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    IUnknown *pUnk;
    IWbemClassObject *pIWbemClassObject;
    HRESULT hr;
    BOOLEAN ReturnStatus;
            
    //
    // QI for IUnknown since we are expected to put the IUnknown into
    // the property.
    //
    pIWbemClassObject = *((IWbemClassObject **)DataPtr);
    hr = pIWbemClassObject->QueryInterface(IID_IUnknown,
                                          (PVOID *)&pUnk);
                                      
    if (hr == WBEM_S_NO_ERROR)
    {
        *((IUnknown **)DestPtr) = pUnk;
        *SetPtr = (PVOID)pUnk;
        ReturnStatus = TRUE;
    } else {
        ReturnStatus = FALSE;
    }                
    return(ReturnStatus);
}

BOOLEAN WmiSetSint8ValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    //
    // CHARs must be expressed as a LONG to keep WBEM happy
    //
    *((LONG *)DestPtr) = (LONG)(*((CHAR *)DataPtr));
    *SetPtr = (PVOID)DestPtr;
    return(TRUE);
}

BOOLEAN WmiSetUint8ValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    //
    // UCHARs must be expressed as a LONG to keep WBEM happy
    //
    *((LONG *)DestPtr) = (LONG)(*((UCHAR *)DataPtr));
    *SetPtr = (PVOID)DestPtr;
    return(TRUE);
}

BOOLEAN WmiSetSint16ValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    //
    // SHORTs must be expressed as a SHORT to keep WBEM happy
    //
    *((SHORT *)DestPtr) = (*((SHORT *)DataPtr));
    *SetPtr = (PVOID)DestPtr;
    return(TRUE);
}

BOOLEAN WmiSetUint16ValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    //
    // USHORTs must be expressed as a SHORT to keep WBEM happy
    //
    *((SHORT *)DestPtr) = (SHORT)(*((USHORT *)DataPtr));
    *SetPtr = (PVOID)DestPtr;
    return(TRUE);
}

BOOLEAN WmiSetSint32ValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    //
    // LONGs must be expressed as a LONG to keep WBEM happy
    //
    *((LONG *)DestPtr) = (*((LONG *)DataPtr));
    *SetPtr = (PVOID)DestPtr;
    return(TRUE);
}

BOOLEAN WmiSetUint32ValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    //
    // ULONGs must be expressed as a LONG to keep WBEM happy
    //
    *((LONG *)DestPtr) = (ULONG)(*((ULONG *)DataPtr));
    *SetPtr = (PVOID)DestPtr;
    return(TRUE);
}

BOOLEAN WmiSetSint64ValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    TCHAR Text[MAX_PATH];
    BSTR s;
    BOOLEAN ReturnStatus;
    
    //
    // 64 bit values must be set via a BSTR
    //
    wsprintf(Text, TEXT("%ld"), *((LONGLONG *)DataPtr));
                   
    s = SysAllocString(Text);
    if (s != NULL)
    {            
        *((BSTR *)DestPtr) = s;
        *SetPtr = (PVOID)s;
        ReturnStatus = TRUE;
    } else {
        ReturnStatus = FALSE;
    }
    return(ReturnStatus);
}

BOOLEAN WmiSetUint64ValueFunc(
    PVOID DataPtr,
    PVOID DestPtr,
    PVOID *SetPtr
    )
{
    TCHAR Text[MAX_PATH];
    BSTR s;
    BOOLEAN ReturnStatus;
    
    //
    // 64 bit values must be set via a BSTR
    //
    wsprintf(Text, TEXT("%ld"), *((ULONGLONG *)DataPtr));
                   
    s = SysAllocString(Text);
    if (s != NULL)
    {            
        *((BSTR *)DestPtr) = s;
        *SetPtr = (PVOID)s;
        ReturnStatus = TRUE;
    } else {
        ReturnStatus = FALSE;
    }
    return(ReturnStatus);
}

SETVALUEFUNC WmiGetSetValueFunc(
    CIMTYPE CimType
    )
{
    SETVALUEFUNC SetValueFunc;
    
    switch(CimType)
    {
        case CIM_SINT8:
        {
            SetValueFunc = WmiSetSint8ValueFunc;
            break;
        }
        
        case CIM_UINT8:
        {
            SetValueFunc = WmiSetUint8ValueFunc;
            break;
        }
        
        case CIM_CHAR16:
        case CIM_SINT16:
        {
            SetValueFunc = WmiSetSint16ValueFunc;
            break;
        }
        
        case CIM_UINT16:
        {
            SetValueFunc = WmiSetUint16ValueFunc;
            break;
        }
        
        case CIM_SINT32:
        {
            SetValueFunc = WmiSetSint32ValueFunc;
            break;
        }
        
        case CIM_UINT32:
        {
            SetValueFunc = WmiSetUint32ValueFunc;
            break;
        }
        
        case CIM_SINT64:
        {
            SetValueFunc = WmiSetSint64ValueFunc;
            break;
        }
        
        case CIM_UINT64:
        {
            SetValueFunc = WmiSetUint64ValueFunc;
            break;
        }
        
        case CIM_BOOLEAN:
        {
            SetValueFunc = WmiSetBooleanValueFunc;
            break;
        }
        
        case CIM_DATETIME:
        case CIM_STRING:
        {
            SetValueFunc = WmiSetStringValueFunc;
            break;
        }

        case CIM_OBJECT:
        {
            SetValueFunc = WmiSetEmbeddedValueFunc;
            break;
        }
        
        default:
        {
            SetValueFunc = NULL;
            break;
        }               
    }
    return(SetValueFunc);
}

BOOLEAN WmiAssignToVariantFromDataItem(
    OUT VARIANT *NewValue,
    IN PDATA_ITEM_DESCRIPTION DataItemDesc
)
/*+++

Routine Description:

    This routine will assign the value for a property from the DataItemDesc
    into an initied variant. It will figure out all of the strange rules
    for what types of variants WBEM likes for different data types.
        
Arguments:

    DataBlockDesc is the data item description for the class

    pIWbemClassObject is the instance class object interface for the class
        
Return Value:

    TRUE if successful

---*/
{
    BOOLEAN ReturnStatus;
    BSTR s;
    TCHAR Text[MAX_PATH];
    SETVALUEFUNC SetValueFunc;
    VARTYPE vt;
    PVOID SetPtr;
    
    WmiAssert(NewValue != NULL);
    WmiAssert(DataItemDesc != NULL);    
        
    SetValueFunc = WmiGetSetValueFunc(DataItemDesc->DataType);

    if (SetValueFunc != NULL)
    {
        ReturnStatus = TRUE;
        vt = WmiVarTypeForCimType(DataItemDesc->DataType);

        if ((DataItemDesc->IsFixedArray == 0) &&
            (DataItemDesc->IsVariableArray == 0))
        {
            //
            // This is a non array case
            //
            NewValue->vt = vt;
            ReturnStatus = (*SetValueFunc)((PVOID)&DataItemDesc->Data,
                                           &NewValue->lVal,
                                           &SetPtr);    
        } else {
            //
            // This is an array, so we need to create a safe array in order to
            // call WBEM.
            //
            SAFEARRAY *SafeArray;
            PUCHAR DataArray;
            PVOID DataPtr;
            PVOID Temp;
            HRESULT hr;
            ULONG i;

            //
            // We do not support arrays of embedded classes
            //
            SafeArray = SafeArrayCreateVector(vt,
                                          0,
                                          DataItemDesc->ArrayElementCount);
            if (SafeArray != NULL)
            {
                DataArray = (PUCHAR)DataItemDesc->ArrayPtr;
                WmiAssert(DataArray != NULL);

                ReturnStatus = TRUE;
                for (i = 0; 
                     (i < DataItemDesc->ArrayElementCount) && ReturnStatus; 
                     i++)
                {
                    ReturnStatus = (*SetValueFunc)(DataArray, &Temp, &SetPtr);
                    if (ReturnStatus)
                    {
                        hr = SafeArrayPutElement(SafeArray,
                                               (PLONG)&i,
                                               SetPtr);
                        if (hr == WBEM_S_NO_ERROR)
                        {
                            DataArray += DataItemDesc->DataSize;
                        } else {
                            ReturnStatus = FALSE;
                        }
                    }
                }

                if (ReturnStatus == FALSE)
                {
                    //
                    // if we failed to build the safearray we need to clean
                    // it up.
                    //
                    SafeArrayDestroy(SafeArray);
                } else {
                    NewValue->vt = vt | VT_ARRAY;
                    NewValue->parray = SafeArray;
                }

            } else {
                ReturnStatus = FALSE;
            }
        }
    } else {
        WmiAssert(FALSE);
        ReturnStatus = FALSE;
    }
    
    return(ReturnStatus);
}

BOOLEAN WmiRefreshWbemFromDataItem(
    IN IWbemServices *pIWbemServices,
    IN IWbemClassObject *pIWbemClassObject,
    IN PDATA_ITEM_DESCRIPTION DataItemDesc
    )
/*+++

Routine Description:

    This routine will update the WBEM property with the value specified in
    the DataItemDesc.
        
Arguments:

    DataItemDesc is the data item description for the property

    pIWbemClassObject is the instance class object interface for the class
        
Return Value:

    TRUE if successful

---*/
{
    VARIANT NewValue;
    BOOLEAN ReturnStatus;
    HRESULT hr;
    BSTR s;

    WmiAssert(pIWbemClassObject != NULL);
    WmiAssert(DataItemDesc != NULL);
    
    ReturnStatus = TRUE;
    if (DataItemDesc->IsReadOnly == 0)
    {
        //
        // Property is not read only so we want to try to update it
        //
                    
        //
        // Now build the value into a variant and call WBEM to get him
        // to update it.
        //
        VariantInit(&NewValue);        
        
        ReturnStatus = WmiAssignToVariantFromDataItem(&NewValue,
                                                      DataItemDesc);
        //
        // if we need to update the value of the property do so and then
        // free up the variant
        //
        if (ReturnStatus)
        {
            s = SysAllocString(DataItemDesc->Name);
            if (s != NULL)
            {
                DebugPrint((1, "WMIPROP: Property %ws (%p) being updated to 0x%x (type 0x%x)\n",
                             DataItemDesc->Name,
                             DataItemDesc,
                             NewValue.ulVal,
                             NewValue.vt));
                hr = pIWbemClassObject->Put(s,
                                        0,
                                        &NewValue,
                                        0);
#if DBG                                            
                if (hr != WBEM_S_NO_ERROR)
                {
                    DebugPrint((1, "WMIPROP: Property %ws (%p) Error %x from pIWbemClassObejct->Put\n", 
                    DataItemDesc->Name,
                    DataItemDesc,
                    hr));
                }
#endif                    
                SysFreeString(s);
            }
            VariantClear(&NewValue);
        }
    }
    return(ReturnStatus);
}

BOOLEAN WmiRefreshWbemFromDataBlock(
    IN IWbemServices *pIWbemServices,
    IN IWbemClassObject *pIWbemClassObject,
    IN PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    IN BOOLEAN IsEmbeddedClass
)
/*+++

Routine Description:

    This routine will update the WBEM class with the values specified in
    the DataBlockDesc. If the class is not an embedded (ie, top level) then
    it will put the instance which will update the values in the schema and
    call the provider (ie, device driver).
        
Arguments:

    pIWbemServices is the Wbem Service interface

    pIWbemClassObject is the instance class object interface for the class
        
    DataBlockDesc is the data block description for the class
    
    IsEmbeddedClass is TRUE if the class is an embedeed class.
        
Return Value:

    TRUE if successful

---*/
{
    ULONG i;
    PDATA_ITEM_DESCRIPTION DataItemDesc;
    BOOLEAN ReturnStatus;
    HRESULT hr;
    
    WmiAssert(pIWbemServices != NULL);
    WmiAssert(pIWbemClassObject != NULL);
    WmiAssert(DataBlockDesc != NULL);
    
    ReturnStatus = TRUE;
    
    for (i = 0; (i < DataBlockDesc->DataItemCount) && ReturnStatus; i++)
    {
        DataItemDesc = &DataBlockDesc->DataItems[i];
        ReturnStatus = WmiRefreshWbemFromDataItem(pIWbemServices,
                                                  pIWbemClassObject,
                                                  DataItemDesc);
    }
    
    if ((ReturnStatus) && (! IsEmbeddedClass))
    {
        //
        // No need to do PutInsance on embedded classes, only top level ones
        //
        hr = pIWbemServices->PutInstance(pIWbemClassObject,
                                         WBEM_FLAG_UPDATE_ONLY,
                                         NULL,
                                         NULL);
#if DBG
        if (hr != WBEM_S_NO_ERROR)
        {
            DebugPrint((1, "WMIPROP: Error %x returned from PutInstance for %ws (%p)\n",
                            hr, DataBlockDesc->Name, DataBlockDesc));
        }
#endif
                                     
        ReturnStatus = (hr == WBEM_S_NO_ERROR);
    }
    
    return(ReturnStatus);
}



PTCHAR WmiGetDeviceInstanceId(
    IN HDEVINFO         deviceInfoSet,
    IN PSP_DEVINFO_DATA deviceInfoData,
    IN HANDLE           MachineHandle
    )
/*+++

Routine Description:

    This routine will obtain the device instance id for the device that
    we are working with.

Arguments:

    deviceInfoSet
    deviceInfoData            

Return Value:

    returns pointer to device instance id or NULL if unavailable

---*/
{
    ULONG Status;
    PTCHAR Id;    
    ULONG SizeNeeded;

    WmiAssert(deviceInfoSet != NULL);
    WmiAssert(deviceInfoData != NULL);
    
    SizeNeeded = (MAX_DEVICE_ID_LEN + 1) * sizeof(TCHAR);
    Id = (PTCHAR)LocalAlloc(LPTR, SizeNeeded);
    if (Id != NULL)
    {
        Status = CM_Get_Device_ID_Ex(deviceInfoData->DevInst,
                                     Id,
                                     SizeNeeded / sizeof(TCHAR),
                                     0,
                                     MachineHandle);
            
        if (Status != CR_SUCCESS)
        {   
            DebugPrint((1, "WMIPROP: CM_Get_Device_ID_Ex returned %d\n",
                         Status));
            LocalFree(Id);
            Id = NULL;
        }
        
    } else {
        DebugPrint((1, "WMIPROP: Could not alloc for device Id\n"));
    }
    return(Id);
}

PTCHAR WmiGetDeviceInstanceName(
    IN HDEVINFO         deviceInfoSet,
    IN PSP_DEVINFO_DATA deviceInfoData,
    IN HANDLE           MachineHandle
    )
/*+++

Routine Description:

    This routine will obtain the WMI instance name id for the device that
    we are working with.

Arguments:

    deviceInfoSet
    deviceInfoData            

Return Value:

    returns pointer to device instance name or NULL if unavailable

---*/
{
    #define InstanceNumberText TEXT("_0")
    PTCHAR Id, in, s;
    PTCHAR InstanceName;
    ULONG SizeNeeded;
    
    WmiAssert(deviceInfoSet != NULL);
    WmiAssert(deviceInfoData != NULL);
    
    InstanceName = NULL;
    Id = WmiGetDeviceInstanceId(deviceInfoSet,
                                deviceInfoData,
                                MachineHandle);
                            
    if (Id != NULL)
    {
        //
        // We need to play some games with the device id to make it into
        // a WMI instance name.
        //
        // 1. We need to convert any "\\" in the instance name to "\\\\".
        //    For some reason wbem likes it this way.
        // 2. We need to append a "_0" to the end to indicate the instance
        //    number we are dealing with.
            
        s = Id;
        SizeNeeded = (_tcslen(Id) * sizeof(TCHAR)) + 
                     sizeof(InstanceNumberText);
        while (*s != 0)
        {
            if (*s++ == TEXT('\\'))
            {
                SizeNeeded += sizeof(TCHAR);
            }
        }
        
        InstanceName = (PTCHAR)LocalAlloc(LPTR, SizeNeeded);
        if (InstanceName != NULL)
        {
            in = InstanceName;
            s = Id;
            while (*s != 0)
            {
                *in++ = *s;
                if (*s++ == TEXT('\\'))
                {
                    *in++ = TEXT('\\');
                }
            }
            _tcscat(InstanceName, InstanceNumberText);
        }
        LocalFree(Id);
    }
    return(InstanceName);
}


BOOLEAN WmiGetQualifier(
    IN IWbemQualifierSet *pIWbemQualifierSet,
    IN PTCHAR QualifierName,
    IN VARTYPE Type,
    OUT VARIANT *Value
    )
/*+++

Routine Description:

    This routine will return the value for a specific qualifier
        
Arguments:

    pIWbemQualifierSet is the qualifier set object
        
    QualifierName is the name of the qualifier
        
    Type is the type of qualifier expected
        
    *Value returns with the value of the qualifier

Return Value:

    returns pointer to device instance name or NULL if unavailable

---*/
{
    BSTR s;
    HRESULT hr;
    BOOLEAN ReturnStatus;

    WmiAssert(pIWbemQualifierSet != NULL);
    WmiAssert(QualifierName != NULL);
    WmiAssert(Value != NULL);
    
    s = SysAllocString(QualifierName);
    if (s != NULL)
    {
        hr = pIWbemQualifierSet->Get(s,
                                0,
                                Value,
                                NULL);
                
        if (hr == WBEM_S_NO_ERROR)
        {
            ReturnStatus  = ((Value->vt & ~CIM_FLAG_ARRAY) == Type);
        } else {
            ReturnStatus = FALSE;
        }
        
        SysFreeString(s);
    } else {
        ReturnStatus = FALSE;
    }
    
    return(ReturnStatus);
}

BOOLEAN WmiParseRange(
    OUT PRANGEINFO RangeInfo,
    IN BSTR Range
    )
/*+++

Routine Description:

    This routine will parse a range specified in the for x or x - y. The 
    former means the value x and the latter means from x to y.
        
Arguments:

    *RangeInfo returns with the range specified
        
    Range is the text representation of the range
        
Return Value:

    TRUE if successful else FALSE

---*/
{
    #define RangeSeparator TEXT('-')
    #define Space TEXT(' ')
    #define MAX_RANGE_VALUE_LENGTH 64
        
    LONG64 BeginValue, EndValue;
    TCHAR *s;
    TCHAR *d;
    TCHAR ValueText[MAX_RANGE_VALUE_LENGTH];
    ULONG i;
    BOOLEAN ReturnStatus;
 
    WmiAssert(RangeInfo != NULL);
    WmiAssert(Range != NULL);
    
    //
    // Obtain the beginning value by copying up to the separator and
    // then converting to a number
    //
    s = Range;
    d = ValueText;
    i = 0;
    while ((*s != 0) && (*s != RangeSeparator) && (*s != Space) &&
           (i < MAX_RANGE_VALUE_LENGTH))
    {
        *d++ = *s++;
        i++;
    }
    *d = 0;
    
    if (i < MAX_RANGE_VALUE_LENGTH)
    {
        BeginValue = _ttoi64(ValueText);
        EndValue = BeginValue;
        if (*s != 0)
        {
            //
            // Skip to the beginning of the next number
            //
            while ( (*s != 0) && 
                    ((*s == RangeSeparator) || (*s == Space)) )
            {
                s++;
            }
            
            if (*s != 0)
            {
                //
                // We do have a second number, copy it out
                //
                d = ValueText;
                i = 0;
                while ((*s != 0) && (*s != Space) &&
                       (i < MAX_RANGE_VALUE_LENGTH))
                  {
                    *d++ = *s++;
                    i++;
                 }
                *d = 0;
                
                if (*s == 0)
                {
                    EndValue = _ttoi64(ValueText);
                }
                
            }
        }        
        
        //
        // Fill out the output RangeInfo making sure that the smaller value
        // is placed in the miniumum and larger in the maximum.
        //
        if (BeginValue < EndValue)
        {
            RangeInfo->Minimum = BeginValue;
            RangeInfo->Maximum = EndValue;
        } else {
            RangeInfo->Minimum = EndValue;
            RangeInfo->Maximum = BeginValue;
        }        
        
        ReturnStatus = TRUE;
    } else {
        //
        // if range text is too long then give up
        //
        ReturnStatus = FALSE;
    }
    return(ReturnStatus);
}

BOOLEAN WmiRangeProperty(
    IN IWbemQualifierSet *pIWbemQualifierSet,
    OUT PDATA_ITEM_DESCRIPTION DataItemDesc
    )
/*+++

Routine Description:

    This routine will obtain information about the valid ranges of values
    for the data item
        
Arguments:

    pIWbemQualifierSet is the qualifier set object
        
    DataItemDesc gets filled with info about ranges

Return Value:

    TRUE if successful else FALSE

---*/
{
    #define RangeText TEXT("Range")
        
    VARIANT Range;
    BSTR RangeData;
    LONG RangeLBound, RangeUBound, RangeElements;
    LONG i, Index;
    HRESULT hr;
    ULONG SizeNeeded;
    PRANGELISTINFO RangeListInfo;
    BOOLEAN ReturnStatus;
            
    WmiAssert(pIWbemQualifierSet != NULL);
    WmiAssert(DataItemDesc != NULL);
    
    if (WmiGetQualifier(pIWbemQualifierSet,
                         RangeText,
                         VT_BSTR, // array
                         &Range))
    {
        if (Range.vt & CIM_FLAG_ARRAY)
        {
            //
            // Array of ranges
            //
            if (WmiGetArraySize(Range.parray, 
                                &RangeLBound,
                                &RangeUBound,
                                &RangeElements))
            {
                SizeNeeded = sizeof(RANGELISTINFO) + 
                             (RangeElements * sizeof(RANGEINFO));
                RangeListInfo = (PRANGELISTINFO)LocalAlloc(LPTR, SizeNeeded);
                if (RangeListInfo != NULL)
                {
                    ReturnStatus = TRUE;
                    DataItemDesc->RangeListInfo = RangeListInfo;
                    RangeListInfo->Count = RangeElements;
                    for (i = 0; (i < RangeElements) && ReturnStatus; i++)
                    {
                        Index = i + RangeLBound;
                        hr = SafeArrayGetElement(Range.parray,
                                                 &Index,
                                                 &RangeData);
                        if (hr == WBEM_S_NO_ERROR)
                        {
                            ReturnStatus = WmiParseRange(
                                                    &RangeListInfo->Ranges[i],
                                                    RangeData);
#if DBG
                            if (ReturnStatus == FALSE)
                            {
                                DebugPrint((1, "WMIPROP: Error parsing range %ws\n",
                                              RangeData));
                            }
#endif
                        } else {
                            ReturnStatus = FALSE;
                        }
                    }
                } else {
                    ReturnStatus = FALSE;
                }
            } else {
                ReturnStatus = FALSE;
            }
        } else {
            // 
            // Single range
            //
            RangeListInfo = (PRANGELISTINFO)LocalAlloc(LPTR, sizeof(RANGELISTINFO));
            if (RangeListInfo != NULL)
            {
                DataItemDesc->RangeListInfo = RangeListInfo;
                RangeListInfo->Count = 1;
                ReturnStatus = WmiParseRange(&RangeListInfo->Ranges[0],
                                              Range.bstrVal);
            } else {
                ReturnStatus = FALSE;
            }
        }
        VariantClear(&Range);
    } else {
        ReturnStatus = FALSE;
    }
    
    return(ReturnStatus);
}


BOOLEAN WmiValueMapProperty(
    IN IWbemQualifierSet *pIWbemQualifierSet,
    OUT PDATA_ITEM_DESCRIPTION DataItemDesc
    )
/*+++

Routine Description:

    This routine will obtain information about the enumeration values for
    the data block
        
Arguments:

    pIWbemQualifierSet is the qualifier set object
        
    DataItemDesc gets filled with info about enumerations

Return Value:

    TRUE if successful else FALSE

---*/
{
    #define ValueMapText TEXT("ValueMap")
    #define ValuesText TEXT("Values")
        
    VARIANT Values, ValueMap;
    BSTR ValuesData, ValueMapData;
    BOOLEAN ReturnStatus = FALSE;
    VARTYPE ValuesType, ValueMapType;
    LONG ValuesUBound, ValuesLBound, ValuesSize;
    LONG ValueMapUBound, ValueMapLBound, ValueMapSize;
    ULONG SizeNeeded;
    PENUMERATIONINFO EnumerationInfo;
    LONG i;
    LONG Index;
    HRESULT hr;
    
    WmiAssert(pIWbemQualifierSet != NULL);
    WmiAssert(DataItemDesc != NULL);
    
    //
    // Get the Values and ValueMap qualifier values. These can be single
    // strings or arrays of strings.
    //
    if ((WmiGetQualifier(pIWbemQualifierSet,
                         ValuesText,
                         VT_BSTR, // array
                         &Values)) &&
        (WmiGetQualifier(pIWbemQualifierSet,
                         ValueMapText,
                         VT_BSTR, // array
                         &ValueMap)))
    {
        //
        // if we've got both qualifiers then we can do value map, make sure
        // that both of them are strings and are either scalar or arrays with
        // the same length.
        //
        ValuesType = Values.vt & ~CIM_FLAG_ARRAY;
        ValueMapType = ValueMap.vt & ~CIM_FLAG_ARRAY;
        if ((ValuesType == CIM_STRING) && 
            (ValueMapType == CIM_STRING) && 
            (Values.vt == ValueMap.vt))
        {
            if (Values.vt & CIM_FLAG_ARRAY)
            {
                //
                // We have sets of arrays for the value map, make sure
                // both arrays are the same size
                //                
                SAFEARRAY *ValuesArray = Values.parray;
                SAFEARRAY *ValueMapArray = ValueMap.parray;
                if ((WmiGetArraySize(ValuesArray,
                                     &ValuesLBound,
                                     &ValuesUBound,
                                     &ValuesSize)) &&
                    (WmiGetArraySize(ValueMapArray,
                                     &ValueMapLBound,
                                     &ValueMapUBound,
                                     &ValueMapSize)) &&
                    (ValueMapSize == ValuesSize))
                {
                    //
                    // Everything checks out with the arrays, just need to 
                    // copy the values and valuemap into data item desc
                    //
                    SizeNeeded = sizeof(ENUMERATIONINFO) + 
                                 ValuesSize * sizeof(ENUMERATIONITEM);
                    EnumerationInfo = (PENUMERATIONINFO)LocalAlloc(LPTR,
                                                                  SizeNeeded);
                    if (EnumerationInfo != NULL)
                    {
                        //
                        // We have memory to store the enumeration info
                        // loop over all enumations and record the info
                        //
                        ReturnStatus = TRUE;
                        DataItemDesc->EnumerationInfo = EnumerationInfo;
                        EnumerationInfo->Count = ValuesSize;
                        for (i = 0; (i < ValuesSize) && ReturnStatus; i++)
                        {
                            Index = i + ValuesLBound;
                            hr = SafeArrayGetElement(ValuesArray,
                                                 &Index,
                                                 &ValuesData);
                            if (hr == WBEM_S_NO_ERROR)
                            {
                                Index = i + ValueMapLBound;
                                hr = SafeArrayGetElement(ValueMapArray,
                                                     &Index,
                                                     &ValueMapData);
                                if (hr == WBEM_S_NO_ERROR)
                                {
                                    ReturnStatus = 
                        (WmiBstrToTchar(&EnumerationInfo->List[i].Text,
                                        ValuesData)) &&
                        (WmiBstrToUlong64(&EnumerationInfo->List[i].Value,
                                          ValueMapData));
                                                   
                                }
                            } else {
                                ReturnStatus = FALSE;
                            }
                        }
                    }
                }
            } else {
                //
                // Single value in ValueMap
                //
                EnumerationInfo = (PENUMERATIONINFO)LocalAlloc(LPTR,
                                                      sizeof(ENUMERATIONINFO));
                if (EnumerationInfo != NULL)
                {
                    DataItemDesc->EnumerationInfo = EnumerationInfo;
                    EnumerationInfo->Count = 1;
                    ReturnStatus = 
                        (WmiBstrToTchar(&EnumerationInfo->List[0].Text,
                                        Values.bstrVal)) &&
                        (WmiBstrToUlong64(&EnumerationInfo->List[0].Value,
                                          ValueMap.bstrVal));
                                                   
                } else {
                    ReturnStatus = FALSE;
                }
            }
        }                        
    }
    
    VariantClear(&Values);
    VariantClear(&ValueMap);
    
    return(ReturnStatus);
}

BOOLEAN WmiGetEmbeddedDataItem(
    IN IWbemServices *pIWbemServices,
    IN IWbemQualifierSet *pIWbemQualifierSet,
    IN PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    IN OUT PDATA_ITEM_DESCRIPTION DataItemDesc
    )
{
    #define ObjectColonText TEXT("object:")
    #define ObjectColonTextChars ((sizeof(ObjectColonText)/sizeof(TCHAR))-1)
    #define CIMTYPEText TEXT("CIMTYPE")
        
    IWbemClassObject *pIWbemClassObjectEmbedded;
    VARIANT CimType;
    BSTR s;
    HRESULT hr;
    BOOLEAN ReturnStatus;
    
    //
    // This is an embedded class, so we need to dig
    // out the name of the embedded class from the CIMTYPE
    // qualifier for the property and then go and get
    // that class object (via IWbemServices) as if it
    // were just another top level class. 
    //
    ReturnStatus = FALSE;

    if (WmiGetQualifier(pIWbemQualifierSet,
                        CIMTYPEText,
                        VT_BSTR,
                        &CimType))
    {
        //
        // Make sure that CIMTYPE value starts with object:
        //
        if (_tcsnicmp(CimType.bstrVal, 
                      ObjectColonText, 
                      ObjectColonTextChars) == 0)
        {
            //
            // and if so then the rest of the string is the embedded class
            // name, so make that a bstr so we can get a class object to it.
            //
            s = SysAllocString(CimType.bstrVal + ObjectColonTextChars);
            if (s != NULL)
            {
                pIWbemClassObjectEmbedded = NULL;
                hr = pIWbemServices->GetObject(s,
                                               WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                               NULL,
                                               &pIWbemClassObjectEmbedded,
                                               NULL);
                if (hr == WBEM_S_NO_ERROR)
                {
                    DebugPrint((1, "WMIPROP: Parsing embedded class %ws for %ws \n",
                                           s, DataItemDesc->Name));
                    ReturnStatus = WmiGetDataBlockDesc(
                                       pIWbemServices,
                                       pIWbemClassObjectEmbedded,
                                       &DataItemDesc->DataBlockDesc,
                                       DataBlockDesc,
                                       (DataItemDesc->IsReadOnly == 1));
                    DebugPrint((1, "WMIPROP: Parsed embedded class %ws for %ws (%p) %ws\n",
                                  s,
                                  DataItemDesc->Name,
                                     DataItemDesc->DataBlockDesc,
                                  ReturnStatus ? L"ok" : L"failed"));
        
                    pIWbemClassObjectEmbedded->Release();
                    
                }
                SysFreeString(s);
            }
        }
        VariantClear(&CimType);
    } 
    return(ReturnStatus);
}
        

BOOLEAN WmiGetDataItem(
    IWbemServices *pIWbemServices,
    IWbemClassObject *pIWbemClassObject,
    BSTR PropertyName,
    IWbemQualifierSet *pIWbemQualifierSet,
    PDATA_ITEM_DESCRIPTION DataItemDesc,
    PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    BOOLEAN IsParentReadOnly
    )
{
    #define DescriptionText TEXT("Description")
    #define MaxText TEXT("max")
    #define WmiSizeIsText TEXT("WmiSizeIs")
    #define WriteText TEXT("Write")
    #define WmiDisplayInHexText TEXT("WmiDisplayInHex")
    #define WmiDisplayNameText TEXT("DisplayName")
    
    HRESULT hr;
    CIMTYPE PropertyType;
    LONG PropertyFlavor;
    VARIANT WriteValue;
    VARIANT DisplayHexValue;
    VARIANT MaxValue;
    VARIANT WmiSizeIsValue;
    BOOLEAN ReturnStatus;
    VARIANT Description;
    VARIANT DisplayName;
    PRANGELISTINFO RangeListInfo;
    PRANGEINFO RangeInfo;
    VARIANT PropertyValue;

    WmiAssert(pIWbemServices != NULL);
    WmiAssert(pIWbemClassObject != NULL);
    WmiAssert(PropertyName != NULL);
    WmiAssert(pIWbemQualifierSet != NULL);
    WmiAssert(DataItemDesc != NULL);
    
    hr = pIWbemClassObject->Get(PropertyName,
                                0,
                                &PropertyValue,
                                &PropertyType,
                                &PropertyFlavor);
                            
    if (hr == WBEM_S_NO_ERROR)
    {
        DebugPrint((1, "Property %ws (%p) is Type %x\n",
                            PropertyName, DataItemDesc, PropertyType));
        //
        // Make sure this is not a system property
        //
        WmiAssert((PropertyFlavor & WBEM_FLAVOR_ORIGIN_SYSTEM) == 0);
            
        //
        // Gather up the important information about the data item and
        // remember it
        //
        if (WmiBstrToTchar(&DataItemDesc->Name, PropertyName))
        {
            ReturnStatus = TRUE;
            DataItemDesc->DataType = (PropertyType & ~CIM_FLAG_ARRAY);
        
            //
            // Get Description for data item
            //
            if (WmiGetQualifier(pIWbemQualifierSet,
                                DescriptionText,
                                VT_BSTR,
                                &Description))
            {
                WmiBstrToTchar(&DataItemDesc->Description, 
                           Description.bstrVal);
                DebugPrint((1, "Property %ws (%p) has description %ws\n",
                             PropertyName, DataItemDesc,
                            DataItemDesc->Description));
                VariantClear(&Description);
            }

            //
            // Get display name for data item
            //
            if (WmiGetQualifier(pIWbemQualifierSet,
                                WmiDisplayNameText,
                                VT_BSTR,
                                &DisplayName))
            {
                WmiBstrToTchar(&DataItemDesc->DisplayName, 
                           DisplayName.bstrVal);
                DebugPrint((1, "Property %ws (%p) has display name %ws\n",
                             PropertyName, DataItemDesc,
                            DataItemDesc->DisplayName));             
                VariantClear(&DisplayName);
            }

            //
            // Lets see if this should be displayed in Hex
            // 
            DataItemDesc->DisplayInHex = 0;
            if (WmiGetQualifier(pIWbemQualifierSet,
                             WmiDisplayInHexText,
                             VT_BOOL,
                             &DisplayHexValue))
            {
                if (DisplayHexValue.boolVal != 0)
                {
                    DataItemDesc->DisplayInHex = 1;
                    DebugPrint((1, "Property %ws (%p) is DisplayInHex\n",
                                 DataItemDesc->Name, DataItemDesc));
                }
                VariantClear(&DisplayHexValue);
            }
            
            
            //
            // Lets see if this is read only or not
            // 
            DataItemDesc->IsReadOnly = 1;
            if ( (IsParentReadOnly == FALSE) &&
                 (WmiGetQualifier(pIWbemQualifierSet,
                             WriteText,
                             VT_BOOL,
                             &WriteValue)) )
            {
                if (WriteValue.boolVal != 0)
                {
                    DataItemDesc->IsReadOnly = 0;
                    DebugPrint((1, "Property %ws (%p) is Read/Write\n",
                                 DataItemDesc->Name, DataItemDesc));
                }
                VariantClear(&WriteValue);
            }
            
            //
            // See if this is an array and if so which kind
            //
            if (PropertyType & CIM_FLAG_ARRAY)
            {
                DataItemDesc->CurrentArrayIndex = 0;
                if (WmiGetQualifier(pIWbemQualifierSet,
                                MaxText,
                                VT_I4,
                                &MaxValue))
                {
                    //
                    // A fixed length array
                    //
                    DataItemDesc->IsFixedArray = 1;
                    DataItemDesc->ArrayElementCount = MaxValue.lVal;
                } else if (WmiGetQualifier(pIWbemQualifierSet,
                                    WmiSizeIsText,
                                    VT_BSTR,
                                    &WmiSizeIsValue)) {
                    //
                    // A VL arrays
                    //
                    DataItemDesc->IsVariableArray = 1;
                } else {
                    //
                    // Arrays must be fixed or variable length
                    //
                    ReturnStatus = FALSE;
                }                
            }
            
            if (ReturnStatus)
            {
                //
                // Now we know enough to assign the validation function
                //
                DataItemDesc->DataSize = WmiGetElementSize(DataItemDesc->DataType);
                switch(DataItemDesc->DataType)
                {
                    case CIM_SINT8:
                    case CIM_UINT8:
                    case CIM_SINT16:
                    case CIM_UINT16:
                    case CIM_SINT32:
                    case CIM_UINT32:
                    case CIM_SINT64:
                    case CIM_UINT64:
                    {
                        //
                        // Numbers can be validated by ranges or value maps
                        // 
                        if (WmiValueMapProperty(pIWbemQualifierSet,
                                                DataItemDesc))
                        {
                            //
                            // Validation is based upon value map
                            //
                            DataItemDesc->ValidationFunc = WmiValueMapValidation;                            
                            DebugPrint((1, "Property %ws (%p) is a ValueMap (%p)\n",
                                     DataItemDesc->Name, DataItemDesc, DataItemDesc->EnumerationInfo));
                        } else if (WmiRangeProperty(pIWbemQualifierSet,
                                                    DataItemDesc)) {
                            //
                            // Validation is based upon ranges
                            //
                            DataItemDesc->ValidationFunc = WmiRangeValidation;
                            DebugPrint((1, "Property %ws (%p) is an explicit range (%p)\n",
                                     DataItemDesc->Name, DataItemDesc, DataItemDesc->EnumerationInfo));
                        } else {
                            //
                            // No validation specified for number so create
                            // a range that corresponds to the minimum and
                            // maximum values for the data type
                            //
                            DataItemDesc->ValidationFunc = WmiRangeValidation;
                            RangeListInfo = (PRANGELISTINFO)LocalAlloc(LPTR, 
                                                       sizeof(RANGELISTINFO));
                            if (RangeListInfo != NULL)
                            {
                                DebugPrint((1, "Property %ws (%p) is an implicit range (%p)\n",
                                     DataItemDesc->Name, DataItemDesc, RangeListInfo));
                                DataItemDesc->RangeListInfo = RangeListInfo;
                                RangeListInfo->Count = 1;
                                RangeInfo = &RangeListInfo->Ranges[0];
                                RangeInfo->Minimum = 0;
                                DataItemDesc->IsSignedValue = 0;
                                switch(DataItemDesc->DataType)
                                {
                                    case CIM_SINT8:
                                    {
                                        DataItemDesc->IsSignedValue = 1;
                                        // Fall through
                                    }
                                    case CIM_UINT8:
                                    {
                                        RangeInfo->Maximum = 0xff;
                                        break;
                                    }
                                    
                                    case CIM_SINT16:
                                    {
                                        DataItemDesc->IsSignedValue = 1;
                                        // Fall through
                                    }
                                    case CIM_UINT16:
                                    {
                                        RangeInfo->Maximum = 0xffff;
                                        break;
                                    }
                                    
                                    case CIM_SINT32:
                                    {
                                        DataItemDesc->IsSignedValue = 1;
                                        // Fall through
                                    }
                                    case CIM_UINT32:
                                    {
                                        RangeInfo->Maximum = 0xffffffff;
                                        break;
                                    }
                                    
                                    case CIM_SINT64:
                                    {
                                        DataItemDesc->IsSignedValue = 1;
                                        // Fall through
                                    }
                                    case CIM_UINT64:
                                    {
                                        RangeInfo->Maximum = 0xffffffffffffffff;
                                        break;
                                    }
                                }
                                    
                            } else {
                                ReturnStatus = FALSE;
                            }
                        }
                        break;
                    }
                    
                    case CIM_BOOLEAN:
                    {
                        ULONG SizeNeeded;
                        PENUMERATIONINFO EnumerationInfo;
                        
                        //
                        // We create a Valuemap with TRUE being 1 and
                        // FALSE being 0
                        //
                        DebugPrint((1, "Property %ws (%p) uses boolean validation\n",
                                     DataItemDesc->Name, DataItemDesc));
                        DataItemDesc->ValidationFunc = WmiValueMapValidation;                            
                        SizeNeeded = sizeof(ENUMERATIONINFO) +
                                     2 * sizeof(ENUMERATIONITEM);
                        EnumerationInfo = (PENUMERATIONINFO)LocalAlloc(LPTR,
                                                                  SizeNeeded);
                        if (EnumerationInfo != NULL)
                        {                           
                            DataItemDesc->EnumerationInfo = EnumerationInfo;
                            EnumerationInfo->Count = 2;
                            EnumerationInfo->List[0].Value = 0;
                            EnumerationInfo->List[0].Text = WmiDuplicateString(TEXT("FALSE"));
                            EnumerationInfo->List[1].Value = 1;
                            EnumerationInfo->List[1].Text = WmiDuplicateString(TEXT("TRUE"));
                        }
                        
                        break;
                    }
                    
                    case CIM_STRING:
                    {
                        //
                        // String values are also validated simply
                        //
                        DebugPrint((1, "Property %ws (%p) uses string validation\n",
                                     DataItemDesc->Name, DataItemDesc));
                        DataItemDesc->ValidationFunc = WmiStringValidation;
                        break;
                    }
                    
                    case CIM_DATETIME:
                    {
                        //
                        // Date time values are also validated simply
                        //
                        DebugPrint((1, "Property %ws (%p) uses datetime validation\n",
                                     DataItemDesc->Name, DataItemDesc));
                        DataItemDesc->ValidationFunc = WmiDateTimeValidation;
                        break;
                    }
                    
                    case CIM_REAL32:
                    case CIM_REAL64:
                    {
                        //
                        // Floating point are not supported
                        //
                        DebugPrint((1, "Property %ws (%p) is floating point - not supported\n",
                                     DataItemDesc->Name, DataItemDesc));
                        ReturnStatus = FALSE;
                        break;
                    }
                    
                    case CIM_OBJECT:
                    {
                        if (WmiGetEmbeddedDataItem(pIWbemServices,
                                                   pIWbemQualifierSet,
                                                   DataBlockDesc,
                                                   DataItemDesc))
                        {
                            DataItemDesc->ValidationFunc = WmiEmbeddedValidation;
                        } else {
                            ReturnStatus = FALSE;
                        }
                        break;
                    }
                    
                    default:
                    {
                        DebugPrint((1, "Property %ws (%p) is unknoen type %d\n",
                                     DataItemDesc->Name, DataItemDesc,
                                     DataItemDesc->DataType));
                        ReturnStatus = FALSE;
                        break;
                    }
                }
            }
            
        } else {
            ReturnStatus = FALSE;
        }
        
        VariantClear(&PropertyValue);
    } else {
        ReturnStatus = FALSE;
    }
        
    return(ReturnStatus);
}

#if DBG
void WmiDumpQualifiers(
    IWbemQualifierSet *pIWbemQualiferSet
)
{
    HRESULT hr;
    LONG UBound, LBound, Count, i;
    BSTR s;
    SAFEARRAY *Quals = NULL;

    WmiAssert(pIWbemQualiferSet != NULL);
    
    hr = pIWbemQualiferSet->GetNames(0,
                                      &Quals);
        
    hr = SafeArrayGetLBound(Quals, 1, &LBound);
    hr = SafeArrayGetUBound(Quals, 1, &UBound);
    Count = UBound - LBound + 1;
    for (i = LBound; i < Count; i++)
    {
        hr = SafeArrayGetElement(Quals,  
                                 &i,
                                 &s);        
        DebugPrint((1, "qual - %ws\n", s));
    }
    SafeArrayDestroy(Quals);    
}
#endif

BOOLEAN WmiGetAllDataItems(
    IWbemServices *pIWbemServices,
    IWbemClassObject *pIWbemClassObject,
    SAFEARRAY *Names,
    LONG LBound,
    LONG Count,
    PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    BOOLEAN IsParentReadOnly
    )
{
    #define WmiDataIdText TEXT("WmiDataId")
        
    BOOLEAN ReturnStatus = TRUE;
    HRESULT hr;
    BSTR s;
    VARIANT DataIdIndex;
    LONG Index;
    LONG i;
    BSTR PropertyName;
    CIMTYPE PropertyType;
    VARIANT PropertyValue;
    LONG PropertyFlavor;
    PDATA_ITEM_DESCRIPTION DataItemDesc;
    IWbemQualifierSet *pIWbemQualifierSet;
 
    WmiAssert(pIWbemServices != NULL);
    WmiAssert(pIWbemClassObject != NULL);
    WmiAssert(Names != NULL);
    WmiAssert(DataBlockDesc != NULL);
    
    //
    // Loop over all of the WmiDataItem property
    for (i = 0; (i < Count) && ReturnStatus; i++)
    {
        //
        // Get the name of the first property
        //
        PropertyName = NULL;
        Index = i + LBound;
        hr = SafeArrayGetElement(Names,  
                                 &Index,
                                 &PropertyName);
        if (hr == WBEM_S_NO_ERROR)
        {
            //
            // Now lets get the qualifier list so we can determine 
            // interesting things about the property
            // 
            hr = pIWbemClassObject->GetPropertyQualifierSet(PropertyName,
                                                        &pIWbemQualifierSet);
            if (hr == WBEM_S_NO_ERROR)
            {                
                if (WmiGetQualifier(pIWbemQualifierSet,
                                    WmiDataIdText,
                                    VT_I4,
                                    &DataIdIndex))
                {
                    WmiAssert(DataIdIndex.vt == VT_I4);
                    Index = DataIdIndex.lVal - 1;
                    VariantClear(&DataIdIndex);
                    DataItemDesc = &DataBlockDesc->DataItems[Index];
                    DebugPrint((1, "Property %ws (%p) has WmiDataId %d\n",
                                    PropertyName, DataItemDesc, Index));
                    ReturnStatus = WmiGetDataItem(pIWbemServices,
                                                  pIWbemClassObject,
                                                  PropertyName,
                                                  pIWbemQualifierSet,
                                                  DataItemDesc,
                                                  DataBlockDesc,
                                                  IsParentReadOnly);
                                              
#if DBG
                    if (! ReturnStatus)
                    {
                        DebugPrint((1, "Property %ws (%p) failed WmiGetDataItem\n",
                                        PropertyName, DataItemDesc));
                    }
#endif
                } else {
                    //
                    // Since our IWbemClassObject->GetNames call specified
                    // only retrieve those properties with WmiDataId qualifier
                    // we expect that it will be found
                    //
                    WmiAssert(FALSE);
                }
                
                pIWbemQualifierSet->Release();
            } else {
                ReturnStatus = FALSE;
            }                    
        } else {
            ReturnStatus = FALSE;
        }
        
        SysFreeString(PropertyName);
    }
    
    return(ReturnStatus);
}

BOOLEAN WmiGetDataBlockDesc(
    IN IWbemServices *pIWbemServices,
    IN IWbemClassObject *pIWbemClassObject,
    OUT PDATA_BLOCK_DESCRIPTION *DBD,
    IN PDATA_BLOCK_DESCRIPTION ParentDataBlockDesc,
    IN BOOLEAN IsParentReadOnly
    )
{
    HRESULT hr;
    BSTR s;
    SAFEARRAY *Names = NULL;
    BOOLEAN ReturnStatus = FALSE;
    LONG LBound, UBound, Count;
    PDATA_BLOCK_DESCRIPTION DataBlockDesc;
    VARIANT DisplayName, Description;
    IWbemQualifierSet *pIWbemQualifierSet;
    ULONG SizeNeeded;
    
    WmiAssert(pIWbemServices != NULL);
    WmiAssert(pIWbemClassObject != NULL);
    WmiAssert(DBD != NULL);
    
    *DBD = NULL;
    s = SysAllocString(WmiDataIdText);
    if (s != NULL)
    {
        hr = pIWbemClassObject->GetNames(s,
                           WBEM_FLAG_ONLY_IF_TRUE | WBEM_FLAG_NONSYSTEM_ONLY,
                           NULL,
                           &Names);
        if (hr == WBEM_S_NO_ERROR)
        {
#if DBG            
            //
            // Verify that the safe array of names has 1 dimension and is
            // an array of BSTR.
            //
            {
                HRESULT hr;
                VARTYPE vt;
                
                WmiAssert(SafeArrayGetDim(Names) == 1);
                hr = SafeArrayGetVartype(Names, &vt);
                WmiAssert( (hr == WBEM_S_NO_ERROR) &&
                        (vt == VT_BSTR) );
            }
#endif                
            hr = SafeArrayGetLBound(Names, 1, &LBound);
            if (hr == WBEM_S_NO_ERROR)
            {
                hr = SafeArrayGetUBound(Names, 1, &UBound);
                if (hr == WBEM_S_NO_ERROR)
                {
                    Count = (UBound - LBound) + 1;
                    DebugPrint((1, "WMIPROP: %d properties found for class\n", 
                                 Count));
                    if (Count > 0)
                    {
                        SizeNeeded = sizeof(DATA_BLOCK_DESCRIPTION) + 
                                  Count * sizeof(DATA_ITEM_DESCRIPTION);

                        DataBlockDesc = (PDATA_BLOCK_DESCRIPTION)LocalAlloc(LPTR, 
                                                                      SizeNeeded);
                        if (DataBlockDesc != NULL)
                        {
                            DataBlockDesc->ParentDataBlockDesc = ParentDataBlockDesc;
                            if (WmiGetAllDataItems(pIWbemServices,
                                                   pIWbemClassObject,
                                                   Names,
                                                   LBound,
                                                   Count,
                                                   DataBlockDesc,
                                                   IsParentReadOnly))
                            {
                                DataBlockDesc->DataItemCount = Count;
                                DataBlockDesc->CurrentDataItem = 0;

                                //
                                // Get display name and description for class
                                //                                
                                pIWbemQualifierSet = NULL;
                                hr = pIWbemClassObject->GetQualifierSet(
                                                             &pIWbemQualifierSet);
                                if (hr == WBEM_S_NO_ERROR)
                                {
                                    if (WmiGetQualifier(pIWbemQualifierSet,
                                                    WmiDisplayNameText,
                                                    VT_BSTR,
                                                    &DisplayName))
                                    {
                                        WmiBstrToTchar(&DataBlockDesc->DisplayName,
                                                       DisplayName.bstrVal);
                                        VariantClear(&DisplayName);
                                    }

                                    if (WmiGetQualifier(pIWbemQualifierSet,
                                                    DescriptionText,
                                                    VT_BSTR,
                                                    &Description))
                                    {
                                        WmiBstrToTchar(&DataBlockDesc->Description,
                                                       Description.bstrVal);
                                        VariantClear(&Description);
                                    }
                                    pIWbemQualifierSet->Release();
                                } else {
                                    DebugPrint((1, "WMIPROP: Error %x getting qualifier set from %ws\n",
                                            hr, s));
                                }

                                *DBD = DataBlockDesc;
                                ReturnStatus = TRUE;
                            } else {
                                LocalFree(DataBlockDesc);
                            }
                        }
                    } else {
                        ReturnStatus = FALSE;
                    }
                }                
            }
            SafeArrayDestroy(Names);
        }
        SysFreeString(s);
    }
    return(ReturnStatus);
}
    

BOOLEAN WmiBuildConfigClass(
    IN PTCHAR MachineName,
    IN IWbemServices *pIWbemServices,
    IN PTCHAR ClassName,
    IN PTCHAR InstanceName,
    OUT PCONFIGCLASS ConfigClass
    )
/*+++

Routine Description:

    This routine will try to get the wbem object corresponding to the 
    ClassName and InstanceName and then query the class to gather info
    needed to fill the ConfigClass.
        
Arguments:

    ClassName is the name of the class
        
    InstanceName is the name of the instance 
        
    ConfigClass 

Return Value:

    TRUE if successful else FALSE

---*/
{
    #define RelPathText1 TEXT(".InstanceName=\"")        
    #define RelPathText2 TEXT("\"")

    ULONG RelPathSize;
    PTCHAR RelPath;
    HRESULT hr;
    IWbemClassObject *pIWbemClassObject, *pInstance;
    ULONG SizeNeeded, i;
    BOOLEAN ReturnStatus = FALSE;
    BSTR sRelPath, sClassName;
    
    WmiAssert(pIWbemServices != NULL);
    WmiAssert(ClassName != NULL);
    WmiAssert(InstanceName != NULL);
    WmiAssert(ConfigClass != NULL);

    if (MachineName != NULL)
    {
        RelPathSize = (_tcslen(MachineName) + 1) * sizeof(TCHAR);
        ConfigClass->MachineName = (PTCHAR)LocalAlloc(LPTR, RelPathSize);
        if (ConfigClass->MachineName != NULL)
        {
            _tcscpy(ConfigClass->MachineName, MachineName);
        } else {
            return(FALSE);
        }
    }

    
    //
    // Build up the relative path to the object
    //
    RelPathSize = 
                  (_tcslen(ClassName) * sizeof(TCHAR)) + 
                  sizeof(RelPathText1) + 
                  (_tcslen(InstanceName) * sizeof(TCHAR)) +
                  sizeof(RelPathText2) + 
                  sizeof(TCHAR);
              
    RelPath = (PTCHAR)LocalAlloc(LPTR, RelPathSize);
    if (RelPath != NULL)
    {
        _tcscpy(RelPath, ClassName);
        _tcscat(RelPath, RelPathText1);
        _tcscat(RelPath, InstanceName);
        _tcscat(RelPath, RelPathText2);
        ConfigClass->RelPath = RelPath;
                        
        //
        // CONSIDER: Use semisynchronous call
        //
        sRelPath = SysAllocString(RelPath);
        if (sRelPath != NULL)
        {
            pInstance = NULL;        
            hr = pIWbemServices->GetObject(sRelPath,
                                  WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                  NULL,
                                  &pInstance,
                                  NULL);

            if (hr == WBEM_S_NO_ERROR)
            {            
                //
                // Now we know that the instance of the class exists so
                // we need to get a class object for the class only. We
                // need to do this since the instance class object does
                // not have any of the qualifiers, but the class only
                // class object does. 
                //
                sClassName = SysAllocString(ClassName);
                if (sClassName != NULL)
                {
                    pIWbemClassObject= NULL;
                    hr = pIWbemServices->GetObject(sClassName,
                                                   WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                                   NULL,
                                                   &pIWbemClassObject,
                                                   NULL);
                    if (hr == WBEM_S_NO_ERROR)
                    {            

                        //
                        // Go and get the data block description for
                        // the class. Note that if we are on a remote
                        // machine we force the entire data block to be
                        // read only so that it is consistent with the
                        // rest of device manager
                        //
                        if (WmiGetDataBlockDesc(pIWbemServices,
                                                pIWbemClassObject,
                                                &ConfigClass->DataBlockDesc,
                                                NULL,
                                                (MachineName != NULL) ?
                                                    TRUE :
                                                    FALSE))
                        {
                            WmiBstrToTchar(&ConfigClass->DataBlockDesc->Name,
                                           sClassName);
                                       
                            ReturnStatus = TRUE;
                        }
                        pIWbemClassObject->Release();
                    } else {
                        DebugPrint((1, "WMIPROP: Error %x getting %ws class \n", hr, sClassName));
                    }
                    
                    SysFreeString(sClassName);
                }
                //
                // we have to release the class object to the instance of the
                // class. We cannot hang onto the interface since it is 
                // only valid in this thread.  We will again get a new
                // instnace interface later in the window message thread
                //
                pInstance->Release();
            } else {
                DebugPrint((1, "WMIPROP: Error %x getting %ws class instance\n", hr, sRelPath));
            }
        }
        
        SysFreeString(sRelPath);
    }
    return(ReturnStatus);
}

void WmiCleanDataItemDescData(
    PDATA_ITEM_DESCRIPTION DataItemDesc
    )
{
    ULONG j;
    
    if ((DataItemDesc->IsVariableArray == 1) ||
        (DataItemDesc->IsFixedArray == 1))
    {
        if (DataItemDesc->ArrayPtr != NULL)
        {
            if ((DataItemDesc->DataType == CIM_STRING) ||
                (DataItemDesc->DataType == CIM_DATETIME))
            {
                for (j = 0; j < DataItemDesc->ArrayElementCount; j++)
                {
                    if (DataItemDesc->StringArray[j] != NULL)
                    {
                        LocalFree(DataItemDesc->StringArray[j]);
                        DataItemDesc->StringArray[j] = NULL;
                    }
                }
            } else if (DataItemDesc->DataType == CIM_OBJECT) {
                for (j = 0; j < DataItemDesc->ArrayElementCount; j++)
                {
                    if (DataItemDesc->StringArray[j] != NULL)
                    {
                        DataItemDesc->pIWbemClassObjectArray[j]->Release();
                        DataItemDesc->pIWbemClassObjectArray[j] = NULL;
                    }
                }
            }

            LocalFree(DataItemDesc->ArrayPtr);
            DataItemDesc->ArrayPtr = NULL;
        }
    } else {
        if ((DataItemDesc->DataType == CIM_STRING) ||
            (DataItemDesc->DataType == CIM_DATETIME))
        {
            LocalFree(DataItemDesc->String);
            DataItemDesc->String = NULL;
        }

        if (DataItemDesc->DataType == CIM_OBJECT)
        {
            if (DataItemDesc->pIWbemClassObject != NULL)
            {
                DataItemDesc->pIWbemClassObject->Release();
                DataItemDesc->pIWbemClassObject = NULL;
            }
        }
    }
}

void WmiFreeDataBlockDesc(
    PDATA_BLOCK_DESCRIPTION DataBlockDesc
    )
/*+++

Routine Description:

    This routine will free all resources used by a data block description
        
Arguments:


Return Value:

---*/
{
    ULONG i,j;
    PDATA_ITEM_DESCRIPTION DataItemDesc;
    PENUMERATIONINFO EnumerationInfo;
    PRANGELISTINFO RangeListInfo;
    
    if (DataBlockDesc != NULL)
    {
        //
        // This is freed when walking the data item desc looking for
        // embedded classes
        //
        DataBlockDesc->ParentDataBlockDesc = NULL;
        
        if (DataBlockDesc->Name != NULL)
        {
            LocalFree(DataBlockDesc->Name);
            DataBlockDesc->Name = NULL;
        }
        
        if (DataBlockDesc->DisplayName != NULL)
        {
            LocalFree(DataBlockDesc->DisplayName);
            DataBlockDesc->DisplayName = NULL;
        }
        
        if (DataBlockDesc->Description != NULL)
        {
            LocalFree(DataBlockDesc->Description);
            DataBlockDesc->Description = NULL;
        }

        if (DataBlockDesc->pInstance != NULL)
        {
            DataBlockDesc->pInstance->Release();
            DataBlockDesc->pInstance = NULL;
        }
        
        for (i = 0; i < DataBlockDesc->DataItemCount; i++)
        {
            DataItemDesc = &DataBlockDesc->DataItems[i];
            
            DebugPrint((1, "WMIPROP: Freeing %ws (%p) index %d\n",
                             DataItemDesc->Name,
                             DataItemDesc,
                             i));

            WmiCleanDataItemDescData(DataItemDesc);
            
            if (DataItemDesc->Name != NULL)
            {
                LocalFree(DataItemDesc->Name);
                DataItemDesc->Name = NULL;
            }
            
            if (DataItemDesc->DisplayName != NULL)
            {
                LocalFree(DataItemDesc->DisplayName);
                DataItemDesc->DisplayName = NULL;
            }
            
            if (DataItemDesc->Description != NULL)
            {
                LocalFree(DataItemDesc->Description);
                DataItemDesc->Description = NULL;
            }
            
            
            if ((DataItemDesc->ValidationFunc == WmiValueMapValidation) &&
                (DataItemDesc->EnumerationInfo))
            {
                EnumerationInfo = DataItemDesc->EnumerationInfo;
                for (j = 0; j < EnumerationInfo->Count; j++)
                {
                    if (EnumerationInfo->List[j].Text != NULL)
                    {
                        LocalFree(EnumerationInfo->List[j].Text);
                        EnumerationInfo->List[j].Text = NULL;
                    }
                }
                
                LocalFree(EnumerationInfo);
                DataItemDesc->EnumerationInfo = NULL;
            }
            
            if ((DataItemDesc->ValidationFunc == WmiRangeValidation) &&
                (DataItemDesc->RangeListInfo != NULL))
            {
                LocalFree(DataItemDesc->RangeListInfo);
                DataItemDesc->RangeListInfo = NULL;
            }            
            
            if (DataItemDesc->ValidationFunc == WmiEmbeddedValidation)
            {
                if (DataItemDesc->DataBlockDesc != NULL)
                {
                    WmiFreeDataBlockDesc(DataItemDesc->DataBlockDesc);
                    DataItemDesc->DataBlockDesc = NULL;
                }                
            }
        }
        
        LocalFree(DataBlockDesc);
    }
}

void WmiFreePageInfo(
    PPAGE_INFO PageInfo
    )
/*+++

Routine Description:

    This routine will free all resources used by a page info
        
Arguments:


Return Value:

---*/
{
    ULONG i;
    PCONFIGCLASS ConfigClass;
    
    WmiAssert(PageInfo != NULL);
    
    if (PageInfo->hKeyDev != (HKEY) INVALID_HANDLE_VALUE) 
    {
        RegCloseKey(PageInfo->hKeyDev);
        PageInfo->hKeyDev = (HKEY) INVALID_HANDLE_VALUE;
    }

    ConfigClass = &PageInfo->ConfigClass;
    if (ConfigClass->RelPath != NULL)
    {
        LocalFree(ConfigClass->RelPath);
        ConfigClass->RelPath = NULL;                
    }
        
    if (ConfigClass->pIWbemServices != NULL)
    {
        ConfigClass->pIWbemServices->Release();
        ConfigClass->pIWbemServices = NULL;
    }

    if (ConfigClass->MachineName != NULL)
    {
        LocalFree(ConfigClass->MachineName);
        ConfigClass->MachineName = NULL;
    }
    
    WmiFreeDataBlockDesc(ConfigClass->DataBlockDesc);
    
    LocalFree(PageInfo);
}

PPAGE_INFO WmiCreatePageInfo(
    IN PTCHAR MachineName,
    IN IWbemServices *pIWbemServices,
    IN PTCHAR ClassName,
    IN PTCHAR InstanceName,
    IN HDEVINFO         deviceInfoSet,
    IN PSP_DEVINFO_DATA deviceInfoData
    )
/*+++

Routine Description:

    This routine will create a PAGE_INFO structure that is used to describe
    property pages.
        
Arguments:


Return Value:

---*/
{
    PPAGE_INFO  PageInfo;
    BOOLEAN ReturnStatus;
    HKEY hKeyDev;

    WmiAssert(pIWbemServices != NULL);
    WmiAssert(ClassName != NULL);
    WmiAssert(InstanceName != NULL);
    WmiAssert(deviceInfoSet != NULL);
    WmiAssert(deviceInfoData != NULL);
    
    //
    // Allocate room to store data for the property page
    //
    PageInfo = (PPAGE_INFO)LocalAlloc(LPTR, sizeof(PAGE_INFO));
    if (PageInfo == NULL) {
        return(NULL);
    }
    
    hKeyDev = SetupDiCreateDevRegKey(deviceInfoSet,
                               deviceInfoData,
                               DICS_FLAG_GLOBAL,
                               0,
                               DIREG_DEV,
                               NULL,
                               NULL);
        
    PageInfo->hKeyDev = hKeyDev;
    PageInfo->deviceInfoSet = deviceInfoSet;
    PageInfo->deviceInfoData = deviceInfoData;
    
    ReturnStatus = WmiBuildConfigClass(MachineName,
                                       pIWbemServices,
                                       ClassName, 
                                       InstanceName,
                                       &PageInfo->ConfigClass);
    if (! ReturnStatus)
    {
        WmiFreePageInfo(PageInfo);
        PageInfo = NULL;
    }
    
    return(PageInfo);
}

void
WmiDestroyPageInfo(PPAGE_INFO * ppPageInfo)
{
    PPAGE_INFO ppi = *ppPageInfo;

    WmiFreePageInfo(ppi);
    *ppPageInfo = NULL;
}

HPROPSHEETPAGE
WmiCreatePropertyPage(PROPSHEETPAGE *  ppsp,
                      PPAGE_INFO       ppi,
                      PTCHAR ClassName)
{
    
    WmiAssert(ppi != NULL);
    WmiAssert(ppsp != NULL);
    WmiAssert(ClassName != NULL);
    
    //
    // Add the Port Settings property page
    //
    ppsp->dwSize      = sizeof(PROPSHEETPAGE);
    ppsp->dwFlags     = PSP_USECALLBACK | PSP_USETITLE; // | PSP_HASHELP;
    ppsp->hInstance   = g_hInstance;
    ppsp->pszTemplate = MAKEINTRESOURCE(ID_WMI_PROPPAGE);
    ppsp->pszTitle = ClassName;

    //
    // following points to the dlg window proc
    //
    ppsp->pfnDlgProc = WmiDlgProc;
    ppsp->lParam     = (LPARAM) ppi;

    //
    // Following points to the control callback of the dlg window proc.
    // The callback gets called before creation/after destruction of the page
    //
    ppsp->pfnCallback = WmiDlgCallback;

    //
    // Allocate the actual page
    //
    return CreatePropertySheetPage(ppsp);
}

BOOLEAN WmiIsDuplicateClass(
    PTCHAR ClassName,
    PTCHAR ClassList,
    PTCHAR ClassListEnd
    )
{
    BOOLEAN Found;
    ULONG NameLen;

    Found = FALSE;
    NameLen = _tcslen(ClassName);
    
    while (ClassList < ClassListEnd)
    {
        if (_tcsnicmp(ClassList, ClassName, NameLen) == 0)
        {
            //
            // We found a duplicate name
            //
            return(TRUE);
        }

        while (*ClassList != ',')
        {
            if (ClassList >= ClassListEnd)
            {
                return(FALSE);
            }

            ClassList++;
        }
        ClassList++;
    }

    return(Found);
}

PTCHAR WmiGetNextClass(
    PTCHAR *ClassList 
    )
{
    PTCHAR s = *ClassList;
    PTCHAR Class, ClassName;
    ULONG Len;
    
    //
    // skip over any white space
    //
    while (IsWhiteSpace(*s) && (*s != 0))
    {
        s++;
    }
    
    //
    // Search for separator or end of string
    //
    ClassName = s;
    Len = 0;
    while ((*s != TEXT(',')) && (*s != 0))
    {
        s++;
        Len++;
    }
    
    if (*s != 0)
    {
        //
        // If we have a string then alloc and copy it over
        //
        Class = (PTCHAR)LocalAlloc(LPTR, (Len+1)*sizeof(TCHAR));
        if (Class != NULL)
        {
            _tcsncpy(Class, ClassName, Len);
            DebugPrint((1,"WMIPROP: Class %ws is in list\n", Class));
        }
        
        s++;
    } else {
        //
        // End of string, all done
        //
        Class = NULL;
    }

    *ClassList = s;
    return(Class);
}

BOOL
WmiPropPageProvider(HDEVINFO                  deviceInfoSet,
                    PSP_DEVINFO_DATA          deviceInfoData,
                    PSP_ADDPROPERTYPAGE_DATA  AddPPageData,
                    PTCHAR                    MachineName,
                    HANDLE                    MachineHandle
                   )
{
    #define WmiConfigClassesText TEXT("WmiConfigClasses")
        
    PSP_PROPSHEETPAGE_REQUEST ppr;
    PROPSHEETPAGE    psp;
    HPROPSHEETPAGE   hpsp;
    TCHAR ClassListStatic[MAX_PATH];
    TCHAR *ClassList, *DeviceList;
    ULONG Status, Size, ClassListSize, DeviceListSize;
    ULONG RegType;
    HKEY hKeyDev, hKeyClass;
    BOOLEAN PageAdded;    
    PPAGE_INFO ppi;
    TCHAR *s;
    IWbemServices *pIWbemServices;
    PTCHAR InstanceName;
    PTCHAR ClassName;
    ULONG PageIndex;
    PUCHAR Ptr;
    CHAR ss[MAX_PATH];
    PTCHAR ClassListEnd;

    DebugPrint((1, "WMI: Enter WmiPropPageProvider(%p, %p, %p) \n",
                        deviceInfoSet,
                deviceInfoData,
                AddPPageData));
   
    WmiAssert(deviceInfoSet != NULL);
    WmiAssert(deviceInfoData != NULL);
    
    PageAdded = FALSE;

    //
    // Get List of classes from registry. It should be in the 
    // WmiConfigClasses value under class specific key
    // HKLM\CurrentControlSet\Control\CLASS\<ClassGuid>
    // key.
    //
    ClassList = ClassListStatic;
    Size = sizeof(ClassListStatic);
    *ClassList = 0;
    
    hKeyClass = SetupDiOpenClassRegKeyEx(&deviceInfoData->ClassGuid,
                                      KEY_READ,
                                      DIOCR_INSTALLER,
                                      MachineName,
                                      NULL);
    if (hKeyClass != NULL)
    {
        Status = RegQueryValueEx(hKeyClass,
                                 WmiConfigClassesText,
                                 NULL,
                                 &RegType,
                                 (PUCHAR)ClassList,
                                 &Size);
        
        if (Status == ERROR_MORE_DATA)
        {
            //
            // The class list is bigger than we though so allocate room
            // for the bigger class list and extra room for the device
            // list
            //
            Size = 2*(Size + sizeof(WCHAR));
            ClassList = (PTCHAR)LocalAlloc(LPTR, Size);
            if (ClassList != NULL)
            {
                Status = RegQueryValueEx(hKeyClass,
                                         WmiConfigClassesText,
                                         NULL,
                                         &RegType,
                                         (PUCHAR)ClassList,
                                         &Size);
            } else {
                //
                // We couldn't alloc memory for the class list so we
                // forget about it
                //
                Status = ERROR_NOT_ENOUGH_MEMORY;
                ClassList = ClassListStatic;
                Size = sizeof(ClassListStatic);
                *ClassList = 0;
            }
        }
               
        RegCloseKey(hKeyClass);
    } else {
        Status = ERROR_INVALID_PARAMETER;
        DebugPrint((1, "WMIPROP: Could not open class key for %s --> %d\n",
                    WmiGuidToString(ss, &deviceInfoData->ClassGuid),
                    GetLastError()));
    }

    //
    // Compute size and location of device list
    //
    if ((Status == ERROR_SUCCESS) && (RegType == REG_SZ))
    {
        if (*ClassList != 0)
        {
            //
            // If there is a class be sure to add a , at the end to
            // aid in parsing
            //
            _tcscat(ClassList, TEXT(","));
        }

        //
        // Compute location to append the device class list
        //
        ClassListSize = _tcslen(ClassList) * sizeof(TCHAR);
        DeviceList = (PTCHAR)((PUCHAR)ClassList + ClassListSize);
        WmiAssert(*DeviceList == 0);
        DeviceListSize = Size - ClassListSize;
    } else {
        ClassListSize = 0;
        DeviceList = ClassList;
        DeviceListSize = Size;
        DebugPrint((1, "WMIPROP: Query for class list in class key %s failed %d\n",
                    WmiGuidToString(ss, &deviceInfoData->ClassGuid),
                    Status));
    }   

    
    //
    // Get List of classes from registry. It should be in the 
    // WmiConfigClasses value under device specific key
    // HKLM\CurrentControlSet\Control\CLASS\<ClassGuid>\<inst id>
    // key.
    //
    hKeyDev = SetupDiCreateDevRegKey(deviceInfoSet,
                               deviceInfoData,
                               DICS_FLAG_GLOBAL,
                               0,
                               DIREG_DRV,
                               NULL,
                               NULL);
    
    if (hKeyDev != (HKEY)INVALID_HANDLE_VALUE)
    {
        Size = DeviceListSize;
        Status = RegQueryValueEx(hKeyDev,
                                 WmiConfigClassesText,
                                 NULL,
                                 &RegType,
                                 (PUCHAR)DeviceList,
                                 &Size);
        
        if (Status == ERROR_MORE_DATA)
        {
            //
            // Not enough room for the device list so allocate enough
            // memory for the class and device lists combined and copy
            // the class list into the new buffer
            //
            Ptr = (PUCHAR)LocalAlloc(LPTR, Size+ClassListSize);
            if (Ptr != NULL)
            {
                memcpy(Ptr, ClassList, ClassListSize);

                if (ClassList != ClassListStatic)
                {
                    LocalFree(ClassList);
                }
                ClassList = (PTCHAR)Ptr;

                DeviceList = (PTCHAR)(Ptr + ClassListSize);
                WmiAssert(*DeviceList == 0);
                Status = RegQueryValueEx(hKeyDev,
                                         WmiConfigClassesText,
                                         NULL,
                                         &RegType,
                                         (PUCHAR)DeviceList,
                                         &Size);
            } else {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        
        RegCloseKey(hKeyDev);
        
        if ((Status != ERROR_SUCCESS) || (RegType != REG_SZ))
        {
            *DeviceList = 0;
            DebugPrint((1, "WMIPROP: Query for class list in class key %s failed %d\n",
                         WmiGuidToString(ss, &deviceInfoData->ClassGuid),
                        Status));
        }
    }
        
    if (*ClassList != 0)
    {
        //
        // Establish connection to WBEM and obtain information 
        // about the class whose properties are being acted upon
        //
        if (WmiConnectToWbem(MachineName, &pIWbemServices))
        {
            WmiAssert(pIWbemServices != NULL);
                
            //
            // Get WMI InstanceName for device
            //
            InstanceName = WmiGetDeviceInstanceName(deviceInfoSet,
                                                    deviceInfoData,
                                                    MachineHandle);
            if (InstanceName != NULL)
            {
                //
                // Loop over all classes specified and create property
                // page for each one
                //
                DebugPrint((1, "WMIPROP: Setup propsheets for %ws for classlist %ws\n",
                                InstanceName,
                                ClassList));
                s  = ClassList;
                do 
                {
                    ClassListEnd = s;
                    ClassName = WmiGetNextClass(&s);
                    if (ClassName != NULL)
                    {
                        if (*ClassName != 0)
                        {
                            if (! WmiIsDuplicateClass(ClassName,
                                                      ClassList,
                                                      ClassListEnd))
                            {
                                //
                                // create property page data structure
                                // that corresponds to this class
                                //
                                DebugPrint((1, "WMIPROP: Parsing class %ws for instance %ws\n",
                                        ClassName, InstanceName));
                                ppi = WmiCreatePageInfo(MachineName,
                                                        pIWbemServices,
                                                        ClassName,
                                                        InstanceName,
                                                        deviceInfoSet,
                                                        deviceInfoData);
                                if (ppi != NULL)
                                {
                                    hpsp = WmiCreatePropertyPage(
                                        &psp,
                                        ppi,
                                        ppi->ConfigClass.DataBlockDesc->DisplayName ? 
                                        ppi->ConfigClass.DataBlockDesc->DisplayName :
                                        ClassName);

                                    if (hpsp != NULL) 
                                    {   
                                        //
                                        // Add the sheet into the list
                                        //
                                        PageIndex = AddPPageData->NumDynamicPages;
                                        if (PageIndex < MAX_INSTALLWIZARD_DYNAPAGES)
                                        {
                                            AddPPageData->NumDynamicPages++;
                                            AddPPageData->DynamicPages[PageIndex] = hpsp;
                                            PageAdded = TRUE;
                                        } else {
                                            DebugPrint((1, "WMIPROP: Can add page, already %d pages",
                                                        PageIndex));                                            
                                        }
                                    } else {
                                        WmiFreePageInfo(ppi);
                                    }
                                }
                            }
                        }
                        LocalFree(ClassName);
                    }
                } while (ClassName != NULL);
                LocalFree(InstanceName);
            } else {
                DebugPrint((1, "WMIPROP: Unable to get instance name\n"));
            }
                
            //
            // We release the interface rather than holding it 
            // since it cannot be used in a different thread and 
            // we'll be running in a different thread later.
            //
            pIWbemServices->Release();
        } else {
            DebugPrint((1, "WMIPROP: Unable to connect to wbem\n"));
        }
    }

    if (ClassList != ClassListStatic)
    {
        LocalFree(ClassList);
    }
    
    DebugPrint((1, "WMI: Leave %s WmiPropPageProvider(%p, %p, %p) \n",
                PageAdded ? "TRUE" : "FALSE",
                        deviceInfoSet,
                deviceInfoData,
                AddPPageData));
   
    
    return(PageAdded);
}

UINT CALLBACK
WmiDlgCallback(HWND            hwnd,
               UINT            uMsg,
               LPPROPSHEETPAGE ppsp)
{
    PPAGE_INFO ppi;

    DebugPrint((1, "WMI: Enter WniDlgCallback(%p, %d, 0x%x) \n",
                        hwnd, uMsg, ppsp));   
   
    switch (uMsg) {
    case PSPCB_CREATE:
        DebugPrint((1, "WMI: Leave TRUE WniDlgCallback(%p, %d, 0x%x) \n",
                        hwnd, uMsg, ppsp));   
   
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        ppi = (PPAGE_INFO) ppsp->lParam;
        WmiDestroyPageInfo(&ppi);

        DebugPrint((1, "WMI: Leave FALSE WniDlgCallback(%p, %d, 0x%x) \n",
                        hwnd, uMsg, ppsp));   
   
        return 0;       // return value ignored

    default:
        break;
    }

    DebugPrint((1, "WMI: Leave TRUE WniDlgCallback(%p, %d, 0x%x) \n",
                        hwnd, uMsg, ppsp));   
   
    return TRUE;
}

BOOLEAN WmiGetDataItemValue(
    IN PDATA_ITEM_DESCRIPTION DataItemDesc,
    OUT ULONG64 *DataValue
    )
{
    ULONG64 ReturnValue;
    BOOLEAN ReturnStatus = TRUE;
    BOOLEAN IsArray;
    ULONG Index;

    IsArray = (DataItemDesc->IsVariableArray) || (DataItemDesc->IsFixedArray);
    Index = DataItemDesc->CurrentArrayIndex;
    
    switch(DataItemDesc->DataType)
    {
        case CIM_SINT8:
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->sint8Array[Index];
            } else {
                ReturnValue = DataItemDesc->sint8;
            }
            break;
        }
                    
        case CIM_UINT8:
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->uint8Array[Index];
            } else {
                ReturnValue = DataItemDesc->uint8;
            }
            break;
        }

        case CIM_SINT16:
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->sint16Array[Index];
            } else {
                ReturnValue = DataItemDesc->sint16;
            }
            break;
        }
                                                                        
        case CIM_UINT16:
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->uint16Array[Index];
            } else {
                ReturnValue = DataItemDesc->uint16;
            }
            break;
        }
                                                                        
        case CIM_SINT32:
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->sint32Array[Index];
            } else {
                ReturnValue = DataItemDesc->sint32;
            }
            break;
        }
                                                
        case CIM_UINT32:                        
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->uint32Array[Index];
            } else {
                ReturnValue = DataItemDesc->uint32;
            }
            break;
        }
                                                
        case CIM_SINT64:
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->sint64Array[Index];
            } else {
                ReturnValue = DataItemDesc->sint64;
            }
            break;
        }
                                                
        case CIM_UINT64:
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->uint64Array[Index];
            } else {
                ReturnValue = DataItemDesc->uint64;
            }
            break;
        }
                        
        case CIM_BOOLEAN:
        {
            if (IsArray)
            {
                ReturnValue = DataItemDesc->boolArray[Index] == 0 ? 0 : 1;
            } else {
                ReturnValue = DataItemDesc->boolval == 0 ? 0 : 1;
            }
            break;
        }
                        
        case CIM_REAL32:
        case CIM_REAL64:
        default:
        {
            WmiAssert(FALSE);
            ReturnStatus = FALSE;
            ReturnValue = 0;
        }
        
    }
    *DataValue = ReturnValue;
    return(ReturnStatus);
}

BOOLEAN WmiSetDataItemValue(
    IN PDATA_ITEM_DESCRIPTION DataItemDesc,
    IN ULONG64 DataValue
    )
{
    BOOLEAN ReturnStatus = TRUE;
    BOOLEAN IsArray;
    ULONG Index;
    
    WmiAssert(DataItemDesc != NULL);

    IsArray = (DataItemDesc->IsVariableArray) || (DataItemDesc->IsFixedArray);
    Index = DataItemDesc->CurrentArrayIndex;
    
    switch(DataItemDesc->DataType)
    {
        case CIM_SINT8:
        {
            if (IsArray)
            {
                DataItemDesc->sint8Array[Index] = (CHAR)DataValue;
            } else {
                DataItemDesc->sint8 = (CHAR)DataValue;
            }
            break;
        }
                    
        case CIM_UINT8:
        {
            if (IsArray)
            {
                DataItemDesc->uint8Array[Index] = (UCHAR)DataValue;
            } else {
                DataItemDesc->uint8 = (UCHAR)DataValue;
            }
            break;
        }

        case CIM_SINT16:
        {
            if (IsArray)
            {
                DataItemDesc->sint16Array[Index] = (SHORT)DataValue;
            } else {
                DataItemDesc->sint16 = (SHORT)DataValue;
            }
            break;
        }
                                                                        
        case CIM_UINT16:
        {
            if (IsArray)
            {
                DataItemDesc->uint16Array[Index] = (USHORT)DataValue;
            } else {
                DataItemDesc->uint16 = (USHORT)DataValue;
            }
            break;
        }
                                                                        
        case CIM_SINT32:
        {
            if (IsArray)
            {
                DataItemDesc->sint32Array[Index] = (LONG)DataValue;
            } else {
                DataItemDesc->sint32 = (LONG)DataValue;
            }
            break;
        }
                                                
        case CIM_UINT32:                        
        {
            if (IsArray)
            {
                DataItemDesc->uint32Array[Index] = (ULONG)DataValue;
            } else {
                DataItemDesc->uint32 = (ULONG)DataValue;
            }
            break;
        }
                                                
        case CIM_SINT64:
        {
            if (IsArray)
            {
                DataItemDesc->sint64Array[Index] = (LONG64)DataValue;
            } else {
                DataItemDesc->sint64 = (LONG64)DataValue;
            }
            break;
        }
                                                
        case CIM_UINT64:
        {
            if (IsArray)
            {
                DataItemDesc->uint64Array[Index] = DataValue;
            } else {
                DataItemDesc->uint64 = DataValue;
            }
            break;
        }

        case CIM_BOOLEAN:
        {
            if (IsArray)
            {
                DataItemDesc->boolArray[Index] = (DataValue == 0) ? 0 : 1;
            } else {
                DataItemDesc->boolval = (DataValue == 0) ? 0 : 1;
            }
            break;
        }
                        
        case CIM_REAL32:
        case CIM_REAL64:
        default:
        {
            WmiAssert(FALSE);
            ReturnStatus = FALSE;
        }
        
    }
    return(ReturnStatus);
}


void WmiRefreshDataItemToControl(
    HWND hDlg,
    PDATA_ITEM_DESCRIPTION DataItemDesc,
    BOOLEAN FullUpdate
    )
{
    HWND hWnd;
    BOOLEAN IsReadOnly, IsArray;
    PTCHAR v;
    
    WmiAssert(hDlg != NULL);
    WmiAssert(DataItemDesc != NULL);

    IsArray = (DataItemDesc->IsVariableArray) || (DataItemDesc->IsFixedArray);

    if (FullUpdate)
    {
        //
        // This code is run when we switch from one property to another
        // property
        //
        if (DataItemDesc->Description != NULL)
        {
            hWnd = GetDlgItem(hDlg, IDC_DESCRIPTION_TEXT);
            if (hWnd != NULL)
            {
                SendMessage(hWnd,
                            WM_SETTEXT,
                            0,
                            (LPARAM)DataItemDesc->Description);
                ShowWindow(hWnd, SW_SHOW);
            }
        }
    }

    if ((DataItemDesc->ValidationFunc == WmiStringValidation) ||
        (DataItemDesc->ValidationFunc == WmiDateTimeValidation) )
    {
        ULONG64 DataItemValue;
        TCHAR s[MAX_PATH];

        hWnd = GetDlgItem(hDlg, IDC_DATA_EDIT);

        ShowWindow(hWnd, SW_SHOW);
        EnableWindow(hWnd, (DataItemDesc->IsReadOnly == 1) ?  FALSE : TRUE);

        if (IsArray)
        {
            v = DataItemDesc->StringArray[DataItemDesc->CurrentArrayIndex];
        } else {
            v = DataItemDesc->String;
        }

        if (hWnd != NULL)
        {
            WmiAssert(DataItemDesc->String != NULL);
            SendMessage(hWnd,
                        WM_SETTEXT,
                        0,
                        (LPARAM)v);
        } else {
            WmiAssert(FALSE);
        }
    } else if (DataItemDesc->ValidationFunc == WmiRangeValidation) {
        ULONG64 DataItemValue;
        TCHAR s[MAX_PATH];
        PTCHAR FormatString;
        ULONG FormatStringIndex;
        static PTCHAR FormatStringList[4] = { TEXT("%lu"),
                                              TEXT("%ld"),
                                              TEXT("0x%lx"),
                                              TEXT("0x%lx") };

        hWnd = GetDlgItem(hDlg, IDC_DATA_EDIT);

        ShowWindow(hWnd, SW_SHOW);
        EnableWindow(hWnd, (DataItemDesc->IsReadOnly == 1) ? FALSE : TRUE);

        if (hWnd != NULL)
        {
            if (WmiGetDataItemValue(DataItemDesc, &DataItemValue))
            {
                FormatStringIndex = DataItemDesc->DisplayInHex * 2 +
                                    DataItemDesc->IsSignedValue;
                FormatString = FormatStringList[FormatStringIndex];

                wsprintf(s, 
                         FormatString,
                         DataItemValue);
                SendMessage(hWnd,
                                WM_SETTEXT,
                                0,
                                (LPARAM)s);
            }
        } else {
            WmiAssert(FALSE);
        }
    } else if (DataItemDesc->ValidationFunc == WmiValueMapValidation) {
        PENUMERATIONINFO EnumerationInfo;
        ULONG j;
        ULONG64 DataItemValue;

        hWnd = GetDlgItem(hDlg, IDC_DATA_COMBO);

        if (hWnd != NULL)
        {
            EnumerationInfo = DataItemDesc->EnumerationInfo;
            WmiAssert(EnumerationInfo != NULL);

            SendMessage(hWnd,
                        CB_RESETCONTENT,
                        0,
                        0);

            for (j = 0; j < EnumerationInfo->Count; j++)
            {
                WmiAssert(EnumerationInfo->List[j].Text != NULL);
                SendMessage(hWnd,
                            CB_ADDSTRING,
                            0,
                            (LPARAM)EnumerationInfo->List[j].Text);
            }
            ShowWindow(hWnd, SW_SHOW);
            EnableWindow(hWnd, (DataItemDesc->IsReadOnly == 1) ?
                                                      FALSE : TRUE);

            if (WmiGetDataItemValue(DataItemDesc, &DataItemValue))
            {
                for (j = 0; j < EnumerationInfo->Count; j++)
                {
                    if (DataItemValue == EnumerationInfo->List[j].Value)
                    {
                        SendMessage(hWnd,
                                        CB_SETCURSEL,
                                        (WPARAM)j,
                                        0);
                        break;
                    }
                }
            }
        } else {
            WmiAssert(FALSE);
        }
    } else if (DataItemDesc->ValidationFunc == WmiEmbeddedValidation) {
        hWnd = GetDlgItem(hDlg, IDC_DATA_BUTTON);
        if (hWnd != NULL)
        {
            SendMessage(hWnd,
                        WM_SETTEXT,
                        0,
                        (LPARAM) (DataItemDesc->DisplayName ? 
                                           DataItemDesc->DisplayName :
                                           DataItemDesc->Name));
            ShowWindow(hWnd, SW_SHOW);
            EnableWindow(hWnd, TRUE);

        } else {
            WmiAssert(FALSE);
        }
    } else {
        WmiAssert(FALSE);
    }

    if (FullUpdate)
    {
        if (IsArray)
        {
            TCHAR s[MAX_PATH];

            hWnd = GetDlgItem(hDlg, IDC_ARRAY_SPIN);
            if (hWnd != NULL)
            {
                SendMessage(hWnd,
                            UDM_SETRANGE32,
                            (WPARAM)1,
                            (LPARAM)DataItemDesc->ArrayElementCount);

                DebugPrint((1, "WMIPROP: SetPos32 -> %d\n",
                                DataItemDesc->CurrentArrayIndex+1));
                SendMessage(hWnd,
                            UDM_SETPOS32,
                            (WPARAM)0,
                            (LPARAM)DataItemDesc->CurrentArrayIndex+1);

                ShowWindow(hWnd, SW_SHOW);
            }

            hWnd = GetDlgItem(hDlg, IDC_ARRAY_TEXT);
            if (hWnd != NULL)
            {
                ShowWindow(hWnd, SW_SHOW);
            }

            hWnd = GetDlgItem(hDlg, IDC_ARRAY_STATIC);
            if (hWnd != NULL)
            {
                ShowWindow(hWnd, SW_SHOW);
            }
        }
    }
}

void
WmiRefreshDataBlockToControls(
    HWND hDlg,
    PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    BOOLEAN FullUpdate
    )
{
    ULONG i;
 
    WmiAssert(hDlg != NULL);
    WmiAssert(DataBlockDesc != NULL);
    WmiAssert(DataBlockDesc->CurrentDataItem < DataBlockDesc->DataItemCount);

    WmiHideAllControls(hDlg, FALSE, FullUpdate);
    WmiRefreshDataItemToControl(hDlg,
                                &DataBlockDesc->DataItems[DataBlockDesc->CurrentDataItem],
                                FullUpdate);
}


void
WmiInitializeControlsFromDataBlock(
    HWND hDlg,
    PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    BOOLEAN IsEmbeddedClass
    )
{
    HWND hWnd, hWndBuddy;
    PDATA_ITEM_DESCRIPTION DataItemDesc;
    ULONG i;
    BSTR s;
    int ShowOrHide;
    BOOLEAN IsReadOnly;
        
    WmiAssert(hDlg != NULL);
    WmiAssert(DataBlockDesc != NULL);

    WmiHideAllControls(hDlg, TRUE, TRUE);
    
    hWnd = GetDlgItem(hDlg, IDC_PROPERTY_LISTBOX);
    if (hWnd != NULL)
    {
        SendMessage(hWnd,
                    LB_RESETCONTENT,
                    0,
                    0);

        for (i = 0; i < DataBlockDesc->DataItemCount; i++)
        {
            DataItemDesc = &DataBlockDesc->DataItems[i];
            SendMessage(hWnd,
                        LB_ADDSTRING,
                        0,
                        (LPARAM) (DataItemDesc->DisplayName ? 
                                           DataItemDesc->DisplayName :
                                           DataItemDesc->Name));
        }
        
        SendMessage(hWnd,
                    LB_SETCURSEL,
                    (WPARAM)DataBlockDesc->CurrentDataItem,
                    0);


        ShowWindow(hWnd, SW_SHOW);
        EnableWindow(hWnd, TRUE);
        
        //
        // Refresh data from wbem and if successful update the controls
        //

        WmiRefreshDataBlockToControls(hDlg,
                                      DataBlockDesc,
                                      TRUE);
        
    }

    ShowOrHide = IsEmbeddedClass ? SW_SHOW : SW_HIDE;
    
    hWnd = GetDlgItem(hDlg, IDC_WMI_EMBEDDED_OK);
    if (hWnd != NULL)
    {
        ShowWindow(hWnd, ShowOrHide);
    }

    hWnd = GetDlgItem(hDlg, IDC_WMI_EMBEDDED_CANCEL);
    if (hWnd != NULL)
    {
        ShowWindow(hWnd, ShowOrHide);
    }

    hWnd = GetDlgItem(hDlg, IDC_ARRAY_SPIN);
    if (hWnd != NULL)
    {
        hWndBuddy = GetDlgItem(hDlg, IDC_ARRAY_TEXT);
        SendMessage(hWnd,
                    UDM_SETBUDDY,
                    (WPARAM)hWndBuddy,
                    0);
    }
}


BOOLEAN WmiReconnectToWbem(
    PCONFIGCLASS ConfigClass,
    IWbemClassObject **pInstance
    )
{
    BOOLEAN ReturnStatus;
    IWbemClassObject *pIWbemClassObject;
    IWbemServices *pIWbemServices;
    HRESULT hr;
    BSTR s;
    
    WmiAssert(ConfigClass != NULL);
    
    //
    // Reestablish our interfaces to WBEM now that we are on the
    // window message thread
    //
    ReturnStatus = FALSE;
    if (WmiConnectToWbem(ConfigClass->MachineName,
                         &pIWbemServices))
    {
        ConfigClass->pIWbemServices = pIWbemServices;
        s = SysAllocString(ConfigClass->RelPath);
        if (s != NULL)
        {
            pIWbemClassObject = NULL;
            hr = pIWbemServices->GetObject(s,
                                           WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                           NULL,
                                           &pIWbemClassObject,
                                           NULL);
            if (hr == WBEM_S_NO_ERROR)
            {
                *pInstance = pIWbemClassObject;
                ReturnStatus = TRUE;
            } else {
                DebugPrint((1, "WMIPROP: Error %x reestablishing IWbemClassObject to instance for %ws\n",
                             hr, ConfigClass->RelPath));
            }
            SysFreeString(s);
        }
    }                 
        
    return(ReturnStatus);
}

void WmiHideAllControls(
    HWND hDlg,
    BOOLEAN HideEmbeddedControls,
    BOOLEAN HideArrayControls                       
    )
{
    HWND hWnd;
    
    WmiAssert(hDlg != NULL);
    
    hWnd = GetDlgItem(hDlg, IDC_DATA_EDIT);
    if (hWnd != NULL)
    {
        ShowWindow(hWnd, SW_HIDE);
    }

    hWnd = GetDlgItem(hDlg, IDC_DATA_COMBO);
    if (hWnd != NULL)
    {
        ShowWindow(hWnd, SW_HIDE);
    }

    hWnd = GetDlgItem(hDlg, IDC_DATA_CHECK);
    if (hWnd != NULL)
    {
        ShowWindow(hWnd, SW_HIDE);
    }

    hWnd = GetDlgItem(hDlg, IDC_DATA_BUTTON);
    if (hWnd != NULL)
    {
        ShowWindow(hWnd, SW_HIDE);
    }

    hWnd = GetDlgItem(hDlg, IDC_ARRAY_EDIT);
    if (hWnd != NULL)
    {
        ShowWindow(hWnd, SW_HIDE);
    }

    if (HideArrayControls)
    {
        hWnd = GetDlgItem(hDlg, IDC_ARRAY_SPIN);
        if (hWnd != NULL)
        {
            ShowWindow(hWnd, SW_HIDE);
        }

        hWnd = GetDlgItem(hDlg, IDC_ARRAY_STATIC);
        if (hWnd != NULL)
        {
            ShowWindow(hWnd, SW_HIDE);
        }

        hWnd = GetDlgItem(hDlg, IDC_ARRAY_TEXT);
        if (hWnd != NULL)
        {
            ShowWindow(hWnd, SW_HIDE);
        }
    }

    if (HideEmbeddedControls)
    {
        hWnd = GetDlgItem(hDlg, IDC_WMI_EMBEDDED_OK);
        if (hWnd != NULL)
        {
            ShowWindow(hWnd, SW_HIDE);
        }

        hWnd = GetDlgItem(hDlg, IDC_WMI_EMBEDDED_CANCEL);
        if (hWnd != NULL)
        {
            ShowWindow(hWnd, SW_HIDE);
        }
    }
}

void
WmiInitializeDialog(
    PPAGE_INFO   ppi,
    HWND         hDlg
    )
{
    PCONFIGCLASS ConfigClass;
    HWND hWnd;
    BOOLEAN ReturnStatus;
    
    WmiAssert(ppi != NULL);
    WmiAssert(hDlg != NULL);
    
    ConfigClass = &ppi->ConfigClass;
    
    ReturnStatus = FALSE;
    if (WmiReconnectToWbem(ConfigClass,
                           &ConfigClass->DataBlockDesc->pInstance))
    {
        if (WmiRefreshDataBlockFromWbem( ConfigClass->DataBlockDesc->pInstance,
                                         ConfigClass->DataBlockDesc))
        {
            WmiInitializeControlsFromDataBlock(hDlg,
                                               ConfigClass->DataBlockDesc,
                                               FALSE);
            hWnd = GetDlgItem(hDlg, IDC_WMI_CONNECT_ERR);
            if (hWnd != NULL)
            {
                ShowWindow(hWnd, SW_HIDE);
            }
            ReturnStatus = TRUE;
        }
    }
        
    if (! ReturnStatus)
    {
        //
        // Hide all controls except for a static string that says we cannot
        // connect to wbem.
        //
        hWnd = GetDlgItem(hDlg, IDC_PROPERTY_LISTBOX);
        if (hWnd != NULL)
        {
            ShowWindow(hWnd, SW_HIDE);
        }

        WmiHideAllControls(hDlg, TRUE, TRUE);
        hWnd = GetDlgItem(hDlg, IDC_WMI_CONNECT_ERR);
        if (hWnd != NULL)
        {
            ShowWindow(hWnd, SW_SHOW);
        }
    }
}


BOOLEAN WmiGetControlText(
    HWND hWnd,
    PTCHAR *Text
)
{
    ULONG SizeNeeded;
    BOOLEAN ReturnStatus = FALSE;
    ULONG CharNeeded, CharCopied;
    
    WmiAssert(hWnd != NULL);
    WmiAssert(Text != NULL);
    
    CharNeeded = (ULONG)SendMessage(hWnd,
                             WM_GETTEXTLENGTH,
                             0,
                             0);
    if (CharNeeded > 0)
    {
        SizeNeeded = (++CharNeeded) * sizeof(TCHAR);
        *Text = (PTCHAR)LocalAlloc(LPTR, SizeNeeded);
        if (*Text != NULL)
        {
            CharCopied = (ULONG)SendMessage(hWnd,
                                     WM_GETTEXT,
                                     CharNeeded,
                                     (LPARAM)*Text);
            ReturnStatus = TRUE;
        }
    }
    return(ReturnStatus);
}

void WmiValidationError(
    HWND hWnd,
    PDATA_ITEM_DESCRIPTION DataItemDesc
    )
{
    TCHAR buf[MAX_PATH];
    TCHAR buf2[MAX_PATH];
    ULONG Bytes;
    
    //
    // TODO: Do a better job of informing the user
    //
    
    
    //
    // Get the string template for the error message
    //
    Bytes = LoadString(g_hInstance, 
                       IDS_WMI_VALIDATION_ERROR, 
                       buf, 
                       MAX_PATH);
    wsprintf(buf2, buf, DataItemDesc->Name);
    MessageBox(hWnd, buf2, NULL, MB_ICONWARNING);
}

BOOLEAN WmiRefreshDataItemFromControl(
    HWND hDlg,
    PDATA_ITEM_DESCRIPTION DataItemDesc,
    PBOOLEAN UpdateValues
    )
{
    HWND hWnd;
    BOOLEAN ReturnStatus;
 
    WmiAssert(hDlg != NULL);
    WmiAssert(DataItemDesc != NULL);
    WmiAssert(UpdateValues != NULL);
    
    ReturnStatus = TRUE;
    *UpdateValues = FALSE;
    if (DataItemDesc->IsReadOnly == 0)
    {
        //
        // Property is not read only so see what we need to update
        //
        if (DataItemDesc->ValidationFunc == WmiValueMapValidation)
        {
            //
            // if a value map or enumeration then we get the current
            // location and then lookup the corresponding value to
            // set
            //
            ULONG CurSel;
            ULONG64 EnumValue;
                    
            hWnd = GetDlgItem(hDlg, IDC_DATA_COMBO);
            if (hWnd != NULL)
            {                    
                CurSel = (ULONG)SendMessage(hWnd,
                                     CB_GETCURSEL,
                                     0,
                                     0);
                                     
                if (CurSel != CB_ERR)
                {
                    if (CurSel < DataItemDesc->EnumerationInfo->Count)
                    {
                        EnumValue = DataItemDesc->EnumerationInfo->List[CurSel].Value;
                        WmiSetDataItemValue(DataItemDesc,
                                            EnumValue);
                        
                        *UpdateValues = TRUE;
                    } else {
                        WmiAssert(FALSE);
                    }
                }
            } else {
                WmiAssert(FALSE);
            }
        } else {
            //
            // All of the rest of the validation types are based
            // upon the contents of the edit box, so get the value
            // from there
            //
            PTCHAR Text;
            ULONG64 Number;
                    
            hWnd = GetDlgItem(hDlg, IDC_DATA_EDIT);
            if (hWnd != NULL)
            {
                if (WmiGetControlText(hWnd,
                                      &Text))
                {
                    if (DataItemDesc->ValidationFunc == WmiRangeValidation) {
                        if (WmiValidateRange(DataItemDesc, &Number, Text))
                        {
                            WmiSetDataItemValue(DataItemDesc,
                                                Number);
                        
                            *UpdateValues = TRUE;
                        } else {
                            //
                            // Validation failed, go tell user
                            //
                             WmiValidationError(hDlg, DataItemDesc);
                             ReturnStatus = FALSE;
                        }
                    } else if (DataItemDesc->ValidationFunc == WmiDateTimeValidation) {
                        if (WmiValidateDateTime(DataItemDesc, Text))
                        {
                            DataItemDesc->DateTime = Text;
                            Text = NULL;
                            *UpdateValues = TRUE;
                        } else {
                            //
                            // Validation failed, go tell user
                            //
                            WmiValidationError(hDlg, DataItemDesc);
                            ReturnStatus = FALSE;
                        }
                    } else if (DataItemDesc->ValidationFunc == WmiStringValidation) {
                        DataItemDesc->String = Text;
                        Text = NULL;
                        *UpdateValues = TRUE;
                    }
                                    
                    if (Text != NULL)
                    {
                        LocalFree(Text);
                    }
                }
            } else {
                WmiAssert(FALSE);
            }
        }
    }    
    return(ReturnStatus);
}

BOOLEAN WmiRefreshDataBlockFromControls(
    HWND hDlg,
    PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    PBOOLEAN UpdateValues
    )
{
    ULONG i;
    PDATA_ITEM_DESCRIPTION DataItemDesc;
    BOOLEAN UpdateItem, ReturnStatus;
    
    WmiAssert(hDlg != NULL);
    WmiAssert(DataBlockDesc != NULL);
    WmiAssert(UpdateValues != NULL);

    *UpdateValues = FALSE;
    
    DataItemDesc = &DataBlockDesc->DataItems[DataBlockDesc->CurrentDataItem];
        
    //
    // We are not going to worry about failures from this function
    // so we'll just use the previous values in the function
    //
    ReturnStatus = WmiRefreshDataItemFromControl(hDlg,
                                  DataItemDesc,
                                  &UpdateItem);
    if (ReturnStatus && UpdateItem)
    {
        *UpdateValues = TRUE;
        DataBlockDesc->UpdateClass = TRUE;
    }
    
    return(ReturnStatus);
}

void WmiPushIntoEmbeddedClass(
    HWND hDlg,
    PPAGE_INFO ppi,
    PDATA_BLOCK_DESCRIPTION DataBlockDesc
    )
{
    ULONG i;
    PDATA_ITEM_DESCRIPTION DataItemDesc;

    WmiAssert(ppi != NULL);
    WmiAssert(DataBlockDesc != NULL);
    
    DataItemDesc = &DataBlockDesc->DataItems[DataBlockDesc->CurrentDataItem];
    
    if (DataItemDesc->ValidationFunc == WmiEmbeddedValidation)
    {
        //
        // The property is an embedded class so all we need to do
        // is to change the controls to our embededded class
        //
        DataBlockDesc = DataItemDesc->DataBlockDesc;
        WmiAssert(DataBlockDesc != NULL);
        DataBlockDesc->UpdateClass = FALSE;

        if ((DataItemDesc->IsVariableArray) ||
            (DataItemDesc->IsFixedArray))
        {
            DataBlockDesc->pInstance = DataItemDesc->pIWbemClassObjectArray[DataItemDesc->CurrentArrayIndex];
        } else {
            DataBlockDesc->pInstance = DataItemDesc->pIWbemClassObject;
        }
        DataBlockDesc->pInstance->AddRef();
        
        WmiRefreshDataBlockFromWbem(DataBlockDesc->pInstance,
                                    DataBlockDesc);
                                    
        ppi->ConfigClass.DataBlockDesc = DataBlockDesc;
    } else {
        WmiAssert(FALSE);
    }   
}

void WmiPopOutEmbeddedClass(
    HWND hDlg,
    PPAGE_INFO ppi,
    PDATA_BLOCK_DESCRIPTION DataBlockDesc,
    BOOLEAN SaveChanges
    )
{    
    PDATA_BLOCK_DESCRIPTION ParentDataBlockDesc;

    ParentDataBlockDesc = DataBlockDesc->ParentDataBlockDesc;
    WmiAssert(ParentDataBlockDesc != NULL);

    if ((SaveChanges) && (DataBlockDesc->UpdateClass))
    {
        //
        // Copy the properties for the data block back into WBEM
        //
        WmiRefreshWbemFromDataBlock(ppi->ConfigClass.pIWbemServices,
                                    DataBlockDesc->pInstance,
                                    DataBlockDesc,
                                    TRUE);
        ParentDataBlockDesc->UpdateClass = TRUE;
    }

    DataBlockDesc->pInstance->Release();
    DataBlockDesc->pInstance = NULL;
                                
    ppi->ConfigClass.DataBlockDesc = ParentDataBlockDesc;   
}

void WmiButtonSelected(
    HWND hDlg,
    PPAGE_INFO ppi,
    ULONG ControlId
    )
{
    BOOLEAN UpdateValues, ReturnStatus;
    PDATA_BLOCK_DESCRIPTION DataBlockDesc;
    
    WmiAssert(ppi != NULL);
    
    if (ControlId == IDC_DATA_BUTTON)
    {
        DataBlockDesc = ppi->ConfigClass.DataBlockDesc;
        WmiAssert(DataBlockDesc != NULL);
        
        ReturnStatus = WmiRefreshDataBlockFromControls(hDlg,
                                        DataBlockDesc,
                                        &UpdateValues);

        if (ReturnStatus)
        {
            WmiPushIntoEmbeddedClass(hDlg,
                                     ppi,
                                     DataBlockDesc);

            WmiInitializeControlsFromDataBlock(hDlg,
                                               ppi->ConfigClass.DataBlockDesc,
                                               TRUE);
        } else {
            WmiRefreshDataBlockToControls(hDlg,
                                          DataBlockDesc,
                                          FALSE);
        }
    }
}

void WmiButtonEmbeddedOk(
    HWND hDlg,
    PPAGE_INFO ppi
    )
{
    PDATA_BLOCK_DESCRIPTION DataBlockDesc;
    PDATA_BLOCK_DESCRIPTION ParentDataBlockDesc;
    BOOLEAN UpdateValues, ReturnStatus;
    
    WmiAssert(ppi != NULL);
    WmiAssert(hDlg != NULL);

    DataBlockDesc = ppi->ConfigClass.DataBlockDesc;
    WmiAssert(DataBlockDesc != NULL);
    
    ReturnStatus = WmiRefreshDataBlockFromControls(hDlg,
                                    DataBlockDesc,
                                    &UpdateValues);

    if (ReturnStatus)
    {
        WmiPopOutEmbeddedClass(hDlg,
                               ppi,
                               DataBlockDesc,
                               TRUE);

        ParentDataBlockDesc = ppi->ConfigClass.DataBlockDesc;
        WmiAssert(ParentDataBlockDesc != NULL);
        WmiInitializeControlsFromDataBlock(hDlg, 
                                           ParentDataBlockDesc, 
                           (ParentDataBlockDesc->ParentDataBlockDesc != NULL));
    } else {
        WmiRefreshDataBlockToControls(hDlg,
                                      DataBlockDesc,
                                      FALSE);
    }
}

void WmiButtonEmbeddedCancel(
    HWND hDlg,
    PPAGE_INFO ppi
    )
{
    PDATA_BLOCK_DESCRIPTION DataBlockDesc;
    PDATA_BLOCK_DESCRIPTION ParentDataBlockDesc;
    BOOLEAN UpdateValues, ReturnStatus;
    
    WmiAssert(ppi != NULL);
    WmiAssert(hDlg != NULL);

    DataBlockDesc = ppi->ConfigClass.DataBlockDesc;
    WmiAssert(DataBlockDesc != NULL);
    
    WmiPopOutEmbeddedClass(hDlg,
                               ppi,
                               DataBlockDesc,
                               FALSE);

    ParentDataBlockDesc = ppi->ConfigClass.DataBlockDesc;
    WmiAssert(ParentDataBlockDesc != NULL);
    WmiInitializeControlsFromDataBlock(hDlg, 
                                           ParentDataBlockDesc, 
                           (ParentDataBlockDesc->ParentDataBlockDesc != NULL));
}

BOOLEAN
WmiApplyChanges(
    PPAGE_INFO ppi,
    HWND       hDlg
    )
{
    PDATA_BLOCK_DESCRIPTION DataBlockDesc;
    IWbemClassObject *pIWbemClassObject;
    BOOLEAN UpdateClass, ReturnStatus;
    IWbemServices *pIWbemServices;
    
    WmiAssert(ppi != NULL);
    WmiAssert(hDlg != NULL);
    
    DataBlockDesc = ppi->ConfigClass.DataBlockDesc;
    pIWbemServices =  ppi->ConfigClass.pIWbemServices;
            
    ReturnStatus = WmiRefreshDataBlockFromControls(hDlg,
                                    DataBlockDesc,
                                    &UpdateClass);

    if (ReturnStatus)
    {
        //
        // Pop out of embedded classes to the root class
        //
        while (DataBlockDesc->ParentDataBlockDesc != NULL)
        {
            WmiPopOutEmbeddedClass(hDlg,
                                   ppi,
                                   DataBlockDesc,
                                   TRUE);
            DataBlockDesc = ppi->ConfigClass.DataBlockDesc;
        }


        //
        // Now we are at the root class so save that
        //
        if (DataBlockDesc->UpdateClass)
        {
            WmiRefreshWbemFromDataBlock(pIWbemServices,
                                        DataBlockDesc->pInstance,
                                        DataBlockDesc,
                                        FALSE);
            UpdateClass = TRUE;
        }

        DataBlockDesc->pInstance->Release();
        DataBlockDesc->pInstance = NULL;
    } else {
        WmiRefreshDataBlockToControls(hDlg,
                                      DataBlockDesc,
                                      FALSE);
    }
    
    return(ReturnStatus);
}

INT_PTR WmipDataItemSelectionChange(
    HWND hDlg,
    PPAGE_INFO ppi
    )
{
    PDATA_BLOCK_DESCRIPTION DataBlockDesc;
    HWND hWnd;
    BOOLEAN UpdateClass, ReturnStatus;
    
    WmiAssert(ppi != NULL);
    WmiAssert(hDlg != NULL);
    
    DataBlockDesc = ppi->ConfigClass.DataBlockDesc;
    WmiAssert(DataBlockDesc != NULL);
    
    hWnd = GetDlgItem(hDlg, IDC_PROPERTY_LISTBOX);
    if (hWnd != NULL)
    {
        ReturnStatus = WmiRefreshDataBlockFromControls(hDlg,
                                        DataBlockDesc,
                                        &UpdateClass);

        if (UpdateClass)
        {
            DataBlockDesc->UpdateClass = TRUE;
        }

        //
        // New value for data item is ok, refresh display with new
        // data item
        //
        DataBlockDesc->CurrentDataItem = (ULONG)SendMessage(hWnd,
                                                     LB_GETCURSEL,
                                                     0,
                                                     0);
        WmiRefreshDataBlockToControls(hDlg,
                                      DataBlockDesc,
                                      TRUE);
    }
    
    return(0);
}

void WmiSetArrayIndex(
    HWND hDlg,
    PPAGE_INFO ppi,
    int NewIndex
    )
{
    PDATA_BLOCK_DESCRIPTION DataBlockDesc;
    PDATA_ITEM_DESCRIPTION DataItemDesc;
    HWND hWnd;
    BOOLEAN UpdateClass, ReturnStatus;
    
    WmiAssert(ppi != NULL);
    WmiAssert(hDlg != NULL);

    DebugPrint((1, "WMIPROP: Set index to %d\n", NewIndex));
    
    DataBlockDesc = ppi->ConfigClass.DataBlockDesc;
    WmiAssert(DataBlockDesc != NULL);
    
    DataItemDesc = &DataBlockDesc->DataItems[DataBlockDesc->CurrentDataItem];

    if ((ULONG)NewIndex < DataItemDesc->ArrayElementCount)
    {
        ReturnStatus = WmiRefreshDataBlockFromControls(hDlg,
                                        DataBlockDesc,
                                        &UpdateClass);

        if (UpdateClass)
        {
            DataBlockDesc->UpdateClass = TRUE;
        }

        DataItemDesc->CurrentArrayIndex = NewIndex;

        WmiRefreshDataBlockToControls(hDlg,
                                      DataBlockDesc,
                                      FALSE);
    }
}

INT_PTR WmiControlColorStatic(
    HDC DC,
    HWND HStatic
    )
{
    UINT id = GetDlgCtrlID(HStatic);
    UINT ControlType;

    //
    // WM_CTLCOLORSTATIC is sent for the edit controls because they are read 
    // only
    //
    if ((id == IDC_DATA_CHECK) ||
        (id == IDC_DATA_BUTTON))
    {
        SetBkColor(DC, GetSysColor(COLOR_WINDOW));
        return (INT_PTR) GetSysColorBrush(COLOR_WINDOW);
    }

    return FALSE;
    
}

INT_PTR APIENTRY
WmiDlgProc(IN HWND   hDlg,
           IN UINT   uMessage,
           IN WPARAM wParam,
           IN LPARAM lParam)
{
    PPAGE_INFO ppi;
    BOOLEAN ReturnStatus;

    DebugPrint((7, "WMI: Enter WmiDlgProc(%p, %d, 0x%x, 0x%x\n",
                hDlg, uMessage, wParam, lParam));
    
    ppi = (PPAGE_INFO) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage) {
    case WM_INITDIALOG:

        //
        // on WM_INITDIALOG call, lParam points to the property
        // sheet page.
        //
        // The lParam field in the property sheet page struct is set by the
        // caller. When I created the property sheet, I passed in a pointer
        // to a struct containing information about the device. Save this in
        // the user window long so I can access it on later messages.
        //
        ppi = (PPAGE_INFO) ((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) ppi);

        //
        // Initialize dlg controls
        //
        WmiInitializeDialog(ppi,
                            hDlg);

        //
        // Didn't set the focus to a particular control.  If we wanted to,
        // then return FALSE
        //
        DebugPrint((7, "WMI: Leave TRUE WmiDlgProc(%p, %d, 0x%x, 0x%x\n",
                        hDlg, uMessage, wParam, lParam));   
   
        return TRUE;

    case WM_COMMAND:

        if (HIWORD(wParam) == LBN_SELCHANGE)
        {
            WmipDataItemSelectionChange(hDlg, ppi);
            return(TRUE);
        }

        if (HIWORD(wParam) == CBN_SELCHANGE)
        {
           PropSheet_Changed(GetParent(hDlg), hDlg);
           DebugPrint((7, "WMI: Leave TRUE WmiDlgProc(%p, %d, 0x%x, 0x%x\n",
                        hDlg, uMessage, wParam, lParam));   

           return TRUE;
        }

        switch (wParam)
        {
            case IDC_DATA_BUTTON:
            {
                WmiButtonSelected(hDlg, ppi, (ULONG)wParam);
                break;
            }
        
            case IDC_WMI_EMBEDDED_OK:
            {
                WmiButtonEmbeddedOk(hDlg, ppi);
                break;
            }

            case IDC_WMI_EMBEDDED_CANCEL:
            {
                WmiButtonEmbeddedCancel(hDlg, ppi);
                break;
            }
        }

#if 0
        //
        // Add this code back in if we will need it
        //
        switch(LOWORD(wParam)) {

        default:
            break;
        }
#endif 
        break;

    case WM_CONTEXTMENU:
        DebugPrint((7, "WMI: Leave ? WmiDlgProc(%p, %d, 0x%x, 0x%x\n",
                        hDlg, uMessage, wParam, lParam));   
   
        return WmiContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        WmiHelp(hDlg, (LPHELPINFO) lParam);
        break;

    case WM_CTLCOLORSTATIC:
        return WmiControlColorStatic((HDC)wParam, (HWND)lParam);
        
    case WM_NOTIFY:

        switch (((NMHDR *)lParam)->code) {

        //
        // Sent when the user clicks on Apply OR OK !!
        //
        case PSN_APPLY:
            //
            // Do what ever action is necessary
            //
            ReturnStatus = WmiApplyChanges(ppi,
                            hDlg);

            if (ReturnStatus)
            {
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

                DebugPrint((7, "WMI: Leave TRUE WmiDlgProc(%p, %d, 0x%x, 0x%x\n",
                            hDlg, uMessage, wParam, lParam));
            }

            SetWindowLong(hDlg,
                          DWLP_MSGRESULT, ReturnStatus ?
                                            PSNRET_NOERROR : PSNRET_INVALID);

            return(TRUE);

        case UDN_DELTAPOS:
        {
            LPNMUPDOWN UpDown = (LPNMUPDOWN)lParam;
            
            //
            // Array spinner has changed. Note that it is biased +1 as
            // compared with the array index
            //
            DebugPrint((1, "WMIPROP: iPos = %d, iDelta = %d\n",
                             UpDown->iPos, UpDown->iDelta));
            
            WmiSetArrayIndex(hDlg,
                             ppi,
                             UpDown->iPos + UpDown->iDelta - 1);
            
            return(TRUE);
        }
            
        default:
            break;
        }

        break;
   }

   SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

   DebugPrint((7, "WMI: Leave FALSE WmiDlgProc(%p, %d, 0x%x, 0x%x\n",
                hDlg, uMessage, wParam, lParam));   
   
   return FALSE;
}

void
WmiUpdate (PPAGE_INFO ppi,
           HWND       hDlg)
{
}

BOOL
WmiContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
    return FALSE;
}

void
WmiHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    )
{
}

//
// Debug support
//
#if DBG

#include <stdio.h>          // for _vsnprintf
ULONG WmiDebug = 0;
CHAR WmiBuffer[DEBUG_BUFFER_LENGTH];


VOID
WmiDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )
/*++

Routine Description:

    Debug print for properties pages - stolen from classpnp\class.c

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);


    if ((DebugPrintLevel <= (WmiDebug & 0x0000ffff)) ||
        ((1 << (DebugPrintLevel + 15)) & WmiDebug)) {

        _vsnprintf(WmiBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

        OutputDebugStringA(WmiBuffer);
    }

    va_end(ap);

} // end WmiDebugPrint()

#else

//
// WmiDebugPrint stub
//

VOID
WmiDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )
{
}

#endif // DBG


HRESULT DifAddPropertyPageAdvanced(
    IN     HDEVINFO                  DeviceInfoSet,
    IN     PSP_DEVINFO_DATA          DeviceInfoData,
    IN     PTCHAR                    MachineName,
    IN     HANDLE                    MachineHandle
    )
{
    SP_ADDPROPERTYPAGE_DATA AddPropertyPageData;
    BOOL b, PageAdded;

    memset(&AddPropertyPageData, 0, sizeof(SP_ADDPROPERTYPAGE_DATA));
    AddPropertyPageData.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    
    b = SetupDiGetClassInstallParams(DeviceInfoSet, DeviceInfoData,
                             (PSP_CLASSINSTALL_HEADER)&AddPropertyPageData,
                             sizeof(SP_ADDPROPERTYPAGE_DATA), NULL );
    if (b)
    {
        if (AddPropertyPageData.NumDynamicPages < MAX_INSTALLWIZARD_DYNAPAGES)
        {
            PageAdded = WmiPropPageProvider(DeviceInfoSet,
                                            DeviceInfoData,
                                            &AddPropertyPageData,
                                            MachineName,
                                            MachineHandle);
            if (PageAdded)
            {
                b = SetupDiSetClassInstallParams(
                                DeviceInfoSet,
                                DeviceInfoData,
                                (PSP_CLASSINSTALL_HEADER)&AddPropertyPageData,
                                sizeof(SP_ADDPROPERTYPAGE_DATA));
                if (! b)
                {
                    DebugPrint((1, "WMIPROP: SetupDiSetClassInstallParams(%p, %p) failed %d\n",
                                DeviceInfoSet, DeviceInfoData, GetLastError()));                    
                }
                    
            }
        } else {
            DebugPrint((1, "WMIPROP: Already %d property sheets\n",
                        AddPropertyPageData.NumDynamicPages));
        }
    } else {
        DebugPrint((1, "WMIPROP: SetupDiGetClassInstallParams(%p, %p) failed %d\n",
                    DeviceInfoSet, DeviceInfoData, GetLastError()));                    
    }

            
    return(NO_ERROR);
}

//+---------------------------------------------------------------------------
//
//  Function:   MyCoInstaller
//
//  Purpose:    Responds to co-installer messages
//
//  Arguments:
//      InstallFunction   [in] 
//      DeviceInfoSet     [in]
//      DeviceInfoData    [in]
//      Context           [inout]
//
//  Returns:    NO_ERROR, ERROR_DI_POSTPROCESSING_REQUIRED, or an error code.
//
HRESULT
WmiPropCoInstaller (
               IN     DI_FUNCTION               InstallFunction,
               IN     HDEVINFO                  DeviceInfoSet,
               IN     PSP_DEVINFO_DATA          DeviceInfoData,  OPTIONAL
               IN OUT PCOINSTALLER_CONTEXT_DATA Context
               )
{
    if (DeviceInfoData != NULL)
    {
        //
        // Only try to display property page for devices and not for
        // the class
        //
        switch (InstallFunction)
        {
            case DIF_ADDPROPERTYPAGE_ADVANCED:
            {


                DifAddPropertyPageAdvanced(DeviceInfoSet,
                                           DeviceInfoData,
                                           NULL,
                                           NULL);

                break;
            }

            case DIF_ADDREMOTEPROPERTYPAGE_ADVANCED:
            {
                SP_DEVINFO_LIST_DETAIL_DATA Detail;

                Detail.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA);
                if (SetupDiGetDeviceInfoListDetail(DeviceInfoSet,
                                                    &Detail))
                {
                    DebugPrint((1, "WMIPROP: Adding remote property pages for %ws\n",
                                Detail.RemoteMachineName));
                    DifAddPropertyPageAdvanced(DeviceInfoSet,
                                               DeviceInfoData,
                                               Detail.RemoteMachineName,
                                               Detail.RemoteMachineHandle);
                } else {
                    DebugPrint((1, "WMIPROP: SetupDiGetDeviceInfoListDetailA failed %d\n",
                                GetLastError()));
                }
                break;
            }

            default:
            {
                break;
            }
        }
    }
    
    return NO_ERROR;    
}

BOOL WINAPI
DllMain(
    HINSTANCE DllInstance,
    DWORD Reason,
    PVOID Reserved
    )
{
    switch(Reason) {

        case DLL_PROCESS_ATTACH: {

            g_hInstance = DllInstance;
            DisableThreadLibraryCalls(DllInstance);
            break;
        }

        case DLL_PROCESS_DETACH: {
            g_hInstance = NULL;
            break;
        }

        default: {
            break;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\proppage\wmiprop.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       wmiprop.h
//
//--------------------------------------------------------------------------

#ifndef ___wmiprop_h___
#define ___wmiprop_h___

typedef TCHAR *PTCHAR;

//
// Datablock description
//

//
// Holds a list of valid values for an enumeration type
//
typedef struct _ENUMERATIONITEM
{
    ULONG64 Value;
    PTCHAR Text;
    ULONG Reserved;
} ENUMERATIONITEM, *PENUMERATIONITEM;

typedef struct _ENUMERATIONINFO
{
    ULONG Count;
    ULONG Reserved;
    ENUMERATIONITEM List[1];
} ENUMERATIONINFO, *PENUMERATIONINFO;

//
// Holds a range of values
typedef struct
{
    ULONG64 Minimum;
    ULONG64 Maximum;
} RANGEINFO, *PRANGEINFO;

//
// Holds a list of ranges of values
//
typedef struct
{
    ULONG Count;
    RANGEINFO Ranges[1];
} RANGELISTINFO, *PRANGELISTINFO;

typedef enum VALIDATIONFUNC
{
    WmiStringValidation,
    WmiDateTimeValidation,
    WmiRangeValidation,
    WmiValueMapValidation,
    WmiEmbeddedValidation
} VALIDATIONFUNC, *PVALIDATIONFUNC;
#define WmiMaximumValidation WmiEmbeddedValidation

struct _DATA_BLOCK_DESCRIPTION;

typedef struct _DATA_ITEM_DESCRIPTION
{
    // CONSIDER: Make Name a BSTR
    PTCHAR Name;
    PTCHAR DisplayName;
    PTCHAR Description;
    CIMTYPE DataType;
    ULONG DataSize;
    VALIDATIONFUNC ValidationFunc;
    union
    {
        //
        // Used for enumeration data types
        //
        PENUMERATIONINFO EnumerationInfo;
    
        //
        // Used for a range of numbers
        PRANGELISTINFO RangeListInfo;    

        //
	// Used for embedded classes
        struct _DATA_BLOCK_DESCRIPTION *DataBlockDesc;
    };
    
    //
    // Number of elements in array if this item is an array
    //
    ULONG ArrayElementCount;
	ULONG CurrentArrayIndex;
    

	//
	// Flags about property
	//
    ULONG IsReadOnly : 1;
    ULONG IsSignedValue : 1;
    ULONG DisplayInHex : 1;
    ULONG IsFixedArray : 1;
    ULONG IsVariableArray : 1;
	
    //
    // Actual value of the property
    //
    union
    {
        //
		// storage for non array
		//
        UCHAR Data;

        BOOLEAN boolval;
        CHAR sint8;
        SHORT sint16;
        LONG sint32;
        LONG64 sint64;
        UCHAR uint8;
        USHORT uint16;
        ULONG uint32;
        ULONG64 uint64;
        PTCHAR String;
        PTCHAR DateTime;
        IWbemClassObject *pIWbemClassObject;
	
		//
		// pointer for storage to arrays
		//
        PVOID ArrayPtr;

        BOOLEAN *boolArray;
        CHAR *sint8Array;
        SHORT *sint16Array;
        LONG *sint32Array;
        LONG64 *sint64Array;
        UCHAR *uint8Array;
        USHORT *uint16Array;
        ULONG *uint32Array;
        ULONG64 *uint64Array;
        PTCHAR *StringArray;
        PTCHAR *DateTimeArray;
		IWbemClassObject **pIWbemClassObjectArray;
    };
           
} DATA_ITEM_DESCRIPTION, *PDATA_ITEM_DESCRIPTION;

typedef struct _DATA_BLOCK_DESCRIPTION
{
    PTCHAR Name;
    PTCHAR DisplayName;
    PTCHAR Description;
    struct _DATA_BLOCK_DESCRIPTION *ParentDataBlockDesc;
	IWbemClassObject *pInstance;
    ULONG DataItemCount;
	ULONG CurrentDataItem;
	BOOLEAN UpdateClass;
    DATA_ITEM_DESCRIPTION DataItems[1];    
} DATA_BLOCK_DESCRIPTION, *PDATA_BLOCK_DESCRIPTION;

BOOLEAN ValidateEnumeration(
    PDATA_ITEM_DESCRIPTION DataItem,
    PTCHAR Value
    );

BOOLEAN ValidateRangeList(
    PDATA_ITEM_DESCRIPTION DataItem,
    ULONG64 Value
    );

BOOLEAN ValidateDateTime(
    PDATA_ITEM_DESCRIPTION DataItem,
    PTCHAR DateTime
    );


typedef struct
{
    PTCHAR MachineName;
    PTCHAR RelPath;
    PDATA_BLOCK_DESCRIPTION DataBlockDesc;
    IWbemServices *pIWbemServices;
} CONFIGCLASS, *PCONFIGCLASS;


//
// PageInfo and Prototypes
//

typedef struct _PAGE_INFO {
    HDEVINFO         deviceInfoSet;
    PSP_DEVINFO_DATA deviceInfoData;

    HKEY             hKeyDev;

    CONFIGCLASS ConfigClass;
} PAGE_INFO, * PPAGE_INFO;


//
// Debug support
//
#ifdef DebugPrint
#undef DebugPrint
#endif

#if DBG

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

#define DEBUG_BUFFER_LENGTH 256

#define DebugPrint(x) WmiDebugPrint x

#else

#define DebugPrint(x)

#endif // DBG

VOID
WmiDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );




//
// function prototype
//

void WmiCleanDataItemDescData(
    PDATA_ITEM_DESCRIPTION DataItemDesc
    );

void WmiHideAllControls(
    HWND hDlg,
    BOOLEAN HideEmbeddedControls,
    BOOLEAN HideArrayControls						
    );


BOOLEAN WmiValidateNumber(
    struct _DATA_ITEM_DESCRIPTION *DataItemDesc,
    PTCHAR Value
    );

BOOLEAN WmiValidateDateTime(
    struct _DATA_ITEM_DESCRIPTION *DataItemDesc,
    PTCHAR Value
    );

BOOLEAN WmiValidateRange(
    struct _DATA_ITEM_DESCRIPTION *DataItemDesc,
    PTCHAR Value
    );

PPAGE_INFO
WmiCreatePageInfo(IN HDEVINFO         deviceInfoSet,
                  IN PSP_DEVINFO_DATA deviceInfoData);

void
WmiDestroyPageInfo(PPAGE_INFO * ppPageInfo);

//
// Function Prototypes
//
BOOL APIENTRY
WmiPropPageProvider(LPVOID               pinfo,
                    LPFNADDPROPSHEETPAGE pfnAdd,
                    LPARAM               lParam);

HPROPSHEETPAGE
WmiCreatePropertyPage(PROPSHEETPAGE *  ppsp,
                      PPAGE_INFO       ppi);

UINT CALLBACK
WmiDlgCallback(HWND            hwnd,
               UINT            uMsg,
               LPPROPSHEETPAGE ppsp);

INT_PTR APIENTRY
WmiDlgProc(IN HWND   hDlg,
           IN UINT   uMessage,
           IN WPARAM wParam,
           IN LPARAM lParam);

BOOLEAN
WmiApplyChanges(PPAGE_INFO ppi,
                HWND       hDlg);

void
WmiUpdate (PPAGE_INFO ppi,
           HWND       hDlg);

BOOL
WmiContextMenu(HWND HwndControl,
                           WORD Xpos,
                           WORD Ypos);

void
WmiHelp(HWND       ParentHwnd,
                LPHELPINFO HelpInfo);

#endif // ___Wmiprop_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\ntdll\umlog.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    umlog.c

Abstract:

    Process Private Logger.

Author:

    20-Oct-1998 Melur Raghuraman

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>          // for ntutrl.h
#include <nturtl.h>         // for RTL_CRITICAL_SECTION in winbase.h/wtypes.h
#include <wtypes.h>         // for LPGUID in wmium.h
#include "wmiump.h"
#include "evntrace.h"
#include "traceump.h"
#include "tracelib.h"
#include "trcapi.h"

//
// The following structures must match what's in ntos\wmi\tracelog.c
//
#define DEFAULT_BUFFER_SIZE               4096
#define MAXSTR                            1024
#define BUFFER_STATE_UNUSED     0               // Buffer is empty, not used
#define BUFFER_STATE_DIRTY      1               // Buffer is being used
#define BUFFER_STATE_FULL       2               // Buffer is filled up
#define BUFFER_STATE_FLUSH      4               // Buffer ready for flush
#define SEMAPHORE_LIMIT      1024
#define DEFAULT_AGE_LIMIT      15
#define ERROR_RETRY_COUNT       10
#define ROUND_TO_PAGES(Size, Page)  (((ULONG)(Size) + Page-1) & ~(Page-1))
#define BYTES_PER_MB              1048576       // Conversion for FileSizeLimit

extern ULONG WmiTraceAlignment;
extern LONG NtdllLoggerLock;

LONG  WmipLoggerCount = 0;                     // Use to refcount UM Log
ULONG WmipGlobalSequence = 0;
RTL_CRITICAL_SECTION UMLogCritSect;

#define WmipEnterUMCritSection() RtlEnterCriticalSection(&UMLogCritSect)
#define WmipLeaveUMCritSection() RtlLeaveCriticalSection(&UMLogCritSect)

#define WmipIsLoggerOn() \
        (WmipLoggerContext != NULL) && \
        (WmipLoggerContext != (PWMI_LOGGER_CONTEXT) &WmipLoggerContext)
//
// Increase refcount on a logger context
#define WmipLockLogger() \
            InterlockedIncrement(&WmipLoggerCount)

// Decrease refcount on a logger context
#define WmipUnlockLogger() InterlockedDecrement(&WmipLoggerCount)

PWMI_LOGGER_CONTEXT WmipLoggerContext = NULL; // Global pointer to LoggerContext
LARGE_INTEGER       OneSecond = {(ULONG)(-1 * 1000 * 1000 * 10), -1};

// #define WmipReleaseTraceBuffer(BufferResource) \
//         InterlockedDecrement(&((BufferResource)->ReferenceCount))
LONG
FASTCALL
WmipReleaseTraceBuffer(
    IN PWMI_BUFFER_HEADER BufferResource
    );

/*
 * Since we do not want to make a kernel mode  transition to get the
 * thread CPU Times, we settle for just getting the CPU Cycle counts.
 * We use the following macros from BradW to get the CPU cycle count.
 * This method may be inaccurate if the clocks are not synchronized
 * between processors.
 */
// NOTE: inline asm is not supported by C++
#if defined(_IA64_)
#include <ia64reg.h>
#endif

#pragma warning( disable: 4035 )    /* Don't complain about lack of ret value */
#pragma warning( disable: 4127 )

/*
__inline
__int64
WmipGetCycleCount()
{
#if defined(_X86_)
    __asm   _emit   0x0F
    __asm   _emit   0x31    /* rdtsc */
    // returns edx:eax
/*#elif defined(_AMD64_)
    return ReadTimeStampCounter();
#elif defined(_IA64_)
    return __getReg(CV_IA64_ApITC);
#else
#error  "no build target defined"
#endif
}*/

#pragma warning( default: 4035 )
#pragma warning( default: 4127 )

#if DBG
#define TraceDebug(x)    DbgPrint x
#else
#define TraceDebug(x)
#endif

ULONG
WmipReceiveReply(
    HANDLE ReplyHandle,
    ULONG ReplyCount,
    ULONG ReplyIndex,
    PVOID OutBuffer,
    ULONG OutBufferSize
    );


VOID
WmipLogger(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

ULONG
WmipStopUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

PWMI_LOGGER_CONTEXT
WmipInitLoggerContext(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
WmipAllocateTraceBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

ULONG
WmipFlushBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER Buffer
    );

ULONG
WmipFlushAllBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext);

PWMI_BUFFER_HEADER
FASTCALL
WmipSwitchBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER OldBuffer,
    IN ULONG Processor
    );

ULONG
WmipFreeLoggerContext(
    PWMI_LOGGER_CONTEXT LoggerContext
    );

BOOLEAN
FASTCALL
WmipIsPrivateLoggerOn()
{
    if (!WmipIsLoggerOn())
        return FALSE;
    return (WmipLoggerContext->CollectionOn == TRUE);
}

ULONG
WmipSendUmLogRequest(
    IN WMITRACECODE RequestCode,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This routine send a UserMode Logger Request (Start/Stop/Query).

Arguments:

    RequestCode - Request Code
    LoggerInfo  - Logger Information necessary for the request


Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    ULONG Status;
    ULONG SizeNeeded;
    PWMICREATEUMLOGGER   UmRequest;
    ULONG RetSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING GuidString;
    WCHAR GuidObjectName[WmiGuidObjectNameLength+1];
    PUCHAR Buffer;
    PWNODE_HEADER Wnode;

    SizeNeeded = sizeof(WMICREATEUMLOGGER) + ((PWNODE_HEADER)LoggerInfo)->BufferSize;

    SizeNeeded = (SizeNeeded +7) & ~7;

    Buffer = WmipAlloc(SizeNeeded);
    if (Buffer == NULL) {
        return ERROR_OUTOFMEMORY;
    }

    UmRequest = (PWMICREATEUMLOGGER) Buffer;

    UmRequest->ObjectAttributes = &ObjectAttributes;
    UmRequest->ControlGuid = LoggerInfo->Wnode.Guid;

    Status = WmipBuildGuidObjectAttributes(&UmRequest->ControlGuid,
                                        &ObjectAttributes,
                                        &GuidString,
                                        GuidObjectName);

    if (Status == ERROR_SUCCESS) {

        Wnode = (PWNODE_HEADER)((PUCHAR)Buffer + sizeof(WMICREATEUMLOGGER));
        memcpy(Wnode, LoggerInfo, LoggerInfo->Wnode.BufferSize);

        Wnode->ProviderId = RequestCode;   // This Wnode is part of the Message.

        Status = WmipSendWmiKMRequest(NULL,
                                  IOCTL_WMI_CREATE_UM_LOGGER,
                                  Buffer,
                                  SizeNeeded,
                                  Buffer,
                                  SizeNeeded,
                                  &RetSize,
                                  NULL);

        if (Status == ERROR_SUCCESS) {

            Status = WmipReceiveReply(UmRequest->ReplyHandle.Handle,
                                      UmRequest->ReplyCount,
                                      Wnode->Version,
                                      LoggerInfo,
                                      LoggerInfo->Wnode.BufferSize);

            NtClose(UmRequest->ReplyHandle.Handle);

        }
    }

    WmipFree(Buffer);

    return Status;
}

void
WmipAddInstanceIdToNames(
    PWMI_LOGGER_INFORMATION LoggerInfo,
    PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    ULONG Offset;

    Offset = sizeof(WMI_LOGGER_INFORMATION);
    LoggerInfo->LoggerName.Buffer = (PVOID)((char*)LoggerInfo + Offset);


    Offset += LoggerInfo->LoggerName.MaximumLength;
    LoggerInfo->LogFileName.Buffer = (PVOID)((char*)LoggerInfo + Offset);
    WmipInitString(&LoggerContext->LoggerName, NULL, 0);

    RtlCreateUnicodeString(&LoggerContext->LoggerName,
                         LoggerInfo->LoggerName.Buffer);

    WmipInitString(&LoggerContext->LogFileName, NULL, 0);

    if (LoggerInfo->InstanceCount == 1) {
        RtlCreateUnicodeString(&LoggerContext->LogFileName,
                              LoggerInfo->LogFileName.Buffer);

    }
    else {
        WCHAR TempStr[MAXSTR];

        if (LoggerInfo->LogFileName.MaximumLength <= MAXSTR) {
            swprintf(TempStr, L"%s_%d",
                     LoggerInfo->LogFileName.Buffer,
                     LoggerInfo->InstanceId);
        }
        else {
            RtlCopyMemory((PVOID)TempStr,
                           LoggerInfo->LogFileName.Buffer,
                           MAXSTR);
            TempStr[MAXSTR/2] = '\0';
        }

        RtlCreateUnicodeString (&LoggerContext->LogFileName, TempStr);
    }

    LoggerInfo->LoggerName = LoggerContext->LoggerName;
    LoggerInfo->LogFileName = LoggerContext->LogFileName;
}

ULONG
WmipQueryUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    ULONG Offset;
    PWMI_LOGGER_CONTEXT LoggerContext;
#if DBG
    LONG RefCount;

    RefCount =
#endif
    WmipLockLogger();

    TraceDebug(("QueryUm: %d->%d\n", RefCount-1, RefCount));

    if (!WmipIsLoggerOn()) {
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("QueryUm: %d->%d OBJECT_NOT_FOUND\n", RefCount+1,RefCount));
        return ERROR_OBJECT_NOT_FOUND;
    }

    LoggerContext = WmipLoggerContext;

    *SizeUsed = 0;
    *SizeNeeded = sizeof(WMI_LOGGER_INFORMATION);
    if (WnodeSize < *SizeNeeded) {
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("QueryUm: %d->%d ERROR_MORE_DATA\n", RefCount+1, RefCount));
        return ERROR_MORE_DATA;
    }

    LoggerInfo->Wnode.Guid      = LoggerContext->InstanceGuid;
    LoggerInfo->LogFileMode     = LoggerContext->LogFileMode;
    LoggerInfo->MaximumFileSize = LoggerContext->MaximumFileSize;
    LoggerInfo->FlushTimer      = (ULONG)(LoggerContext->FlushTimer.QuadPart
                                           / OneSecond.QuadPart);
    LoggerInfo->BufferSize      = LoggerContext->BufferSize / 1024;
    LoggerInfo->NumberOfBuffers = LoggerContext->NumberOfBuffers;
    LoggerInfo->MinimumBuffers  = LoggerContext->MinimumBuffers;
    LoggerInfo->MaximumBuffers  = LoggerContext->MaximumBuffers;
    LoggerInfo->EventsLost      = LoggerContext->EventsLost;
    LoggerInfo->FreeBuffers     = LoggerContext->BuffersAvailable;
    LoggerInfo->BuffersWritten  = LoggerContext->BuffersWritten;
    LoggerInfo->LogBuffersLost  = LoggerContext->LogBuffersLost;
    LoggerInfo->RealTimeBuffersLost = LoggerContext->RealTimeBuffersLost;
    LoggerInfo->AgeLimit        = (ULONG)(LoggerContext->BufferAgeLimit.QuadPart
                                        / OneSecond.QuadPart / 60);
    LoggerInfo->LoggerThreadId = LoggerContext->LoggerThreadId;
    LoggerInfo->Wnode.ClientContext = LoggerContext->UsePerfClock;
    WmiSetLoggerId(1,
            (PTRACE_ENABLE_CONTEXT) &LoggerInfo->Wnode.HistoricalContext);

    // Copy LogFileName and LoggerNames into Buffer, if space is available
    //
    Offset = sizeof(WMI_LOGGER_INFORMATION);
    if ((Offset + LoggerContext->LoggerName.MaximumLength) < WnodeSize) {
        LoggerInfo->LoggerName.Buffer = (PVOID)((char*)LoggerInfo + Offset);
        if (LoggerInfo->LoggerName.MaximumLength == 0) {
            LoggerInfo->LoggerName.MaximumLength =
                    LoggerContext->LoggerName.MaximumLength;
        }
        else {
            LoggerInfo->LoggerName.MaximumLength =
                            __min(LoggerInfo->LoggerName.MaximumLength,
                                  LoggerContext->LoggerName.MaximumLength);
        }
        RtlCopyUnicodeString(&LoggerInfo->LoggerName,
                                 &LoggerContext->LoggerName);

        *SizeNeeded += LoggerContext->LoggerName.MaximumLength;
    }

    Offset += LoggerContext->LoggerName.MaximumLength;
    if ((Offset + LoggerContext->LogFileName.MaximumLength) < WnodeSize) {
        LoggerInfo->LogFileName.Buffer = (PVOID)((char*)LoggerInfo
                                                  + Offset);
        if (LoggerInfo->LogFileName.MaximumLength == 0) {
            LoggerInfo->LogFileName.MaximumLength =
                    LoggerContext->LogFileName.MaximumLength;
        }
        else {
            LoggerInfo->LogFileName.MaximumLength =
                            __min(LoggerInfo->LogFileName.MaximumLength,
                                  LoggerContext->LogFileName.MaximumLength);
        }
        RtlCopyUnicodeString(&LoggerInfo->LogFileName,
                              &LoggerContext->LogFileName);
        *SizeNeeded += LoggerContext->LogFileName.MaximumLength;
    }
    *SizeUsed = *SizeNeeded;
#if DBG
        RefCount =
#endif
    WmipUnlockLogger();
    TraceDebug(("QueryUm: %d->%d ERROR_SUCCESS\n", RefCount+1, RefCount));
    return ERROR_SUCCESS;
}

ULONG
WmipUpdateUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    ULONG Status = ERROR_SUCCESS;
    PWMI_LOGGER_CONTEXT LoggerContext;

    //
    // Check for parameters first
    //
    *SizeUsed = 0;
    *SizeNeeded = sizeof(WMI_LOGGER_INFORMATION);
    if (WnodeSize < * SizeNeeded) {
        return ERROR_MORE_DATA;
    }

    if (LoggerInfo->BufferSize != 0 || LoggerInfo->MinimumBuffers != 0
                                    || LoggerInfo->MaximumBuffers != 0
                                    || LoggerInfo->MaximumFileSize != 0
                                    || LoggerInfo->EnableFlags != 0
                                    || LoggerInfo->AgeLimit != 0) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Lock logger down if it is running
    //
    WmipLockLogger();
    if (!WmipIsLoggerOn()) {
        WmipUnlockLogger();
        return ERROR_OBJECT_NOT_FOUND;
    }

    LoggerContext = WmipLoggerContext;

    if (((LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) &&
         (LoggerContext->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL))
        || ((LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL)
            && (LoggerContext->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR))
        || (LoggerInfo->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
        WmipUnlockLogger();
        return (ERROR_INVALID_PARAMETER);
    }

    LoggerInfo->LoggerName.Buffer = (PWCHAR)
            (((PCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION));
    LoggerInfo->LogFileName.Buffer = (PWCHAR)
            (((PCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION)
                                  + LoggerInfo->LoggerName.MaximumLength);

    if (LoggerInfo->FlushTimer > 0) {
        LoggerContext->FlushTimer.QuadPart = LoggerInfo->FlushTimer
                                               * OneSecond.QuadPart;
    }

    if (LoggerInfo->LogFileName.Length > 0) {
        if (LoggerContext->LogFileHandle != NULL) {
            PWMI_LOGGER_INFORMATION WmipLoggerInfo = NULL;
            ULONG                   lSizeUsed;
            ULONG                   lSizeNeeded = 0;

            lSizeUsed = sizeof(WMI_LOGGER_INFORMATION)
                      + 2 * MAXSTR * sizeof(WCHAR);
            WmipLoggerInfo = (PWMI_LOGGER_INFORMATION) WmipAlloc(lSizeUsed);
            if (WmipLoggerInfo == NULL) {
                Status = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }
            RtlZeroMemory(WmipLoggerInfo, lSizeUsed);
            WmipLoggerInfo->Wnode.BufferSize  = lSizeUsed;
            WmipLoggerInfo->Wnode.Flags      |= WNODE_FLAG_TRACED_GUID;
            Status = WmipQueryUmLogger(
                            WmipLoggerInfo->Wnode.BufferSize,
                            & lSizeUsed,
                            & lSizeNeeded,
                            WmipLoggerInfo);
            if (Status != ERROR_SUCCESS) {
                WmipFree(WmipLoggerInfo);
                goto Cleanup;
            }
            NtClose(LoggerContext->LogFileHandle);
            Status = WmipFinalizeLogFileHeader(WmipLoggerInfo);
            if (Status != ERROR_SUCCESS) {
                WmipFree(WmipLoggerInfo);
                goto Cleanup;
            }
            WmipFree(WmipLoggerInfo);
        }

        LoggerInfo->BufferSize      = LoggerContext->BufferSize / 1024;
        LoggerInfo->MaximumFileSize = LoggerContext->MaximumFileSize;
        LoggerInfo->LogFileMode     = LoggerContext->LogFileMode;

        if (LoggerContext->LogFileName.Buffer != NULL) {
            RtlFreeUnicodeString(& LoggerContext->LogFileName);
        }
        WmipAddInstanceIdToNames(LoggerInfo, LoggerContext);
        Status = WmipAddLogHeaderToLogFile(LoggerInfo, NULL, TRUE);
        if (Status != ERROR_SUCCESS) {
            goto Cleanup;
        }
        LoggerContext->LogFileHandle = LoggerInfo->LogFileHandle;

        RtlCreateUnicodeString(&LoggerContext->LogFileName,
                               LoggerInfo->LogFileName.Buffer);
    }

Cleanup:
    if (Status == ERROR_SUCCESS) {
        Status = WmipQueryUmLogger(WnodeSize, SizeUsed, SizeNeeded, LoggerInfo);
    }
    WmipUnlockLogger();
    return (Status);
}

ULONG
WmipStartUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    NTSTATUS Status;
    ULONG ErrorCode;
    LARGE_INTEGER TimeOut = {(ULONG)(-2000 * 1000 * 10), -1};  // 2 secs
    UNICODE_STRING SavedLoggerName;
    UNICODE_STRING SavedLogFileName;
    PTRACE_ENABLE_CONTEXT pContext;
    CLIENT_ID  ClientId;

    PWNODE_HEADER Wnode = (PWNODE_HEADER)&LoggerInfo->Wnode;
    PVOID RequestAddress;
    PVOID RequestContext;
    ULONG RequestCookie;
    ULONG BufferSize;
    PWMI_LOGGER_CONTEXT LoggerContext;
#if DBG
    LONG RefCount;
#endif
    if (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        return ERROR_INVALID_PARAMETER;

    if ( (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_SEQUENTIAL) &&
         (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( (LoggerInfo->LogFileMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) &&
         (LoggerInfo->LogFileMode & EVENT_TRACE_USE_LOCAL_SEQUENCE) ) {
        return ERROR_INVALID_PARAMETER;
    }

    if (WmipLoggerContext != NULL) {
        return ERROR_WMI_ALREADY_ENABLED;
    }

#if DBG
    RefCount =
#endif
    WmipLockLogger();
    TraceDebug(("StartUm: %d->%d\n", RefCount-1, RefCount));

    if (InterlockedCompareExchangePointer(&WmipLoggerContext,
                                          &WmipLoggerContext,
                                          NULL
                                         )  != NULL) {
#if DBG
    RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("StartUm: %d->%d ALREADY_ENABLED\n", RefCount+1, RefCount));
        return ERROR_WMI_ALREADY_ENABLED;
    }

    LoggerContext = WmipInitLoggerContext(LoggerInfo);
    if (LoggerContext == NULL) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // The LogFileName and LoggerNames are passed in as offset to the
    // LOGGER_INFORMATION structure. Reassign the Pointers for UNICODE_STRING
    //

    SavedLoggerName = LoggerInfo->LoggerName;
    SavedLogFileName = LoggerInfo->LogFileName;

    //
    // Since there may multiple processes registering for the same control guid
    // we want to make sure a start logger call from all of them do not
    // collide on the same file. So we tag on a InstanceId to the file name.
    //

    WmipAddInstanceIdToNames(LoggerInfo, LoggerContext);

    ErrorCode = WmipAddLogHeaderToLogFile(LoggerInfo, NULL, FALSE);

    if (ErrorCode != ERROR_SUCCESS) {
        goto Cleanup;
    }
    else
    {
        ULONG Min_Buffers, Max_Buffers;
        ULONG NumberProcessors;

        NumberProcessors = LoggerInfo->NumberOfProcessors;
        LoggerContext->NumberOfProcessors = NumberProcessors;

        // EventsLost is UNIONed to NumberOfProcessors in WMI_LOGGER_INFORMATION
        // in UM case. Need to reset EventsLost back to 0
        //
        LoggerInfo->EventsLost = 0;

        Min_Buffers            = NumberProcessors + 1;
        Max_Buffers            = 1024;

        if (LoggerInfo->MaximumBuffers >= Min_Buffers ) {
            LoggerContext->MaximumBuffers = LoggerInfo->MaximumBuffers;
        }
        else {
            LoggerContext->MaximumBuffers = 25;
        }

        if (LoggerInfo->MinimumBuffers >= Min_Buffers &&
            LoggerInfo->MinimumBuffers <= LoggerContext->MaximumBuffers) {
            LoggerContext->MinimumBuffers = LoggerInfo->MinimumBuffers;
        }
        else {
            LoggerContext->MinimumBuffers = Min_Buffers;
        }

        if (LoggerContext->MaximumBuffers > Max_Buffers)
            LoggerContext->MaximumBuffers = Max_Buffers;
        if (LoggerContext->MinimumBuffers > Max_Buffers)
            LoggerContext->MinimumBuffers = Max_Buffers;
        LoggerContext->NumberOfBuffers  = LoggerContext->MinimumBuffers;
    }

    LoggerContext->LogFileHandle       = LoggerInfo->LogFileHandle;
    LoggerContext->BufferSize          = LoggerInfo->BufferSize * 1024;
    LoggerContext->BuffersWritten      = LoggerInfo->BuffersWritten;
    LoggerContext->ByteOffset.QuadPart = LoggerInfo->BuffersWritten
                                           * LoggerInfo->BufferSize * 1024;
    LoggerContext->InstanceGuid        = LoggerInfo->Wnode.Guid;
    LoggerContext->MaximumFileSize     = LoggerInfo->MaximumFileSize;

    LoggerContext->UsePerfClock = LoggerInfo->Wnode.ClientContext;

    ErrorCode = WmipAllocateTraceBuffers(LoggerContext);
    if (ErrorCode != ERROR_SUCCESS) {
        goto Cleanup;
    }

    LoggerInfo->NumberOfBuffers = LoggerContext->NumberOfBuffers;
    LoggerInfo->MaximumBuffers  = LoggerContext->MaximumBuffers;
    LoggerInfo->MinimumBuffers  = LoggerContext->MinimumBuffers;
    LoggerInfo->FreeBuffers     = LoggerContext->BuffersAvailable;

    pContext = (PTRACE_ENABLE_CONTEXT)&LoggerInfo->Wnode.HistoricalContext;

    pContext->InternalFlag |= EVENT_TRACE_INTERNAL_FLAG_PRIVATE;
    pContext->LoggerId = 1;
    if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE) {
        WmipGlobalSequence = 0;
        LoggerContext->SequencePtr = &WmipGlobalSequence;
    }
    else if (LoggerInfo->LogFileMode & EVENT_TRACE_USE_LOCAL_SEQUENCE)
        LoggerContext->SequencePtr = &LoggerContext->LocalSequence;

    //
    // Initialize Events,  Semaphores and Crit Sections
    //

    Status = NtCreateEvent(
                &LoggerContext->LoggerEvent,
                EVENT_ALL_ACCESS,
                NULL,
                SynchronizationEvent,
                FALSE);
    if (!NT_SUCCESS(Status)) {
        ErrorCode = ERROR_OBJECT_NOT_FOUND;
        goto Cleanup;
    }

// TODO:
// This requires a private routine to create initial stack and
// call NtCreateThread
//
    LoggerContext->hThread = WmipCreateThread(NULL,
                                 0,
                                 (LPTHREAD_START_ROUTINE) &WmipLogger,
                                 (LPVOID)LoggerContext,
                                 0,
                                 (LPDWORD)&ClientId);

    LoggerContext->LoggerThreadId = ClientId.UniqueThread;

    if((LoggerContext->hThread == NULL) || (LoggerContext->LoggerThreadId == 0)){
        ErrorCode = WmipGetLastError();
        goto Cleanup;
    }
    else {

        WmipCloseHandle(LoggerContext->hThread);

        //
        // Elevate the priority of the Logging thread to highest
        //

        WmipSetThreadPriority(LoggerContext->hThread, THREAD_PRIORITY_HIGHEST);
    }


  /*      Status = STATUS_TIMEOUT;
        while (Status == STATUS_TIMEOUT) {
            Status = NtWaitForSingleObject(LoggerContext->LoggerEvent, FALSE, &TimeOut);

#if DBG
            WmipAssert(Status != STATUS_TIMEOUT);
#endif
            DbgPrint("Process Id : %d, Thread Id : %d\n",WmipGetCurrentProcessId(),LoggerContext->LoggerThreadId);
            DbgPrint("Start : %x\n",&WmipLogger);
        }

    NtClearEvent(LoggerContext->LoggerEvent);

    WmipLoggerContext = LoggerContext;*/

    //
    // Look to see if this Provider is currently enabled.
    //

    RequestCookie = Wnode->ClientContext;

    if ( (RequestCookie != 0)  &&
         (WmipLookupCookie(RequestCookie,
                             &Wnode->Guid,
                             &RequestAddress,
                             &RequestContext)) ) {

            WmipDebugPrint(("WMI: LookUpCookie %d  RequestAddress %X\n",
                             RequestCookie, RequestAddress));

    }
    else {
        WmipDebugPrint(("WMI: LOOKUP COOKIE FAILED\n"));
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("StartUm: %d->%d DP_FAILED\n", RefCount+1, RefCount));
        return(ERROR_WMI_DP_FAILED);
    }
    try
    {
        PGUIDMAPENTRY pControlGMEntry = RequestAddress;
        PTRACE_REG_INFO pTraceRegInfo = NULL;
        WMIDPREQUEST WmiDPRequest = NULL;

        BufferSize = Wnode->BufferSize;

        if (RequestAddress != NULL)
            pTraceRegInfo  = pControlGMEntry->pControlGuidData;
        if (pTraceRegInfo != NULL) {
            RequestAddress = pTraceRegInfo->NotifyRoutine;
            if (pTraceRegInfo->EnabledState)
                WmiDPRequest = (WMIDPREQUEST)RequestAddress;
        }

        if (*WmiDPRequest != NULL) {
            ErrorCode = (*WmiDPRequest)(WMI_ENABLE_EVENTS,
                                 RequestContext,
                                 &BufferSize,
                                 Wnode);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
#if DBG
        ErrorCode = GetExceptionCode();
        WmipDebugPrint(("WMI: Service request call caused an exception %d\n",
                        Status));
#endif
        ErrorCode = ERROR_WMI_DP_FAILED;
    }

Cleanup:
    LoggerInfo->LogFileName = SavedLogFileName;
    LoggerInfo->LoggerName = SavedLoggerName;

    if (ErrorCode != ERROR_SUCCESS) {
        if (LoggerInfo->LogFileHandle) {
            NtClose(LoggerInfo->LogFileHandle);
            LoggerInfo->LogFileHandle = NULL;
            if (LoggerContext != NULL) {
                LoggerContext->LogFileHandle = NULL;
            }
        }
#if DBG
        RefCount =
#endif
        WmipLockLogger();
        TraceDebug(("StartUm: %d->%d %d Freeing\n", RefCount-1, RefCount));
        WmipFreeLoggerContext(LoggerContext);
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("StartUm: %d->%d %d\n", RefCount+1, RefCount, ErrorCode));
    }
    else {
        *SizeUsed = LoggerInfo->Wnode.BufferSize;
        *SizeNeeded = LoggerInfo->Wnode.BufferSize;
        // Logger remains locked with refcount = 1
    }
    return ErrorCode;
}

ULONG
WmipStopLoggerInstance(
    VOID
    )
{
    ULONG LoggerOn;
    NTSTATUS Status;
    LARGE_INTEGER TimeOut = {(ULONG)(-1000 * 1000 * 10), -1}; // 1sec
    PWMI_LOGGER_CONTEXT LoggerContext = WmipLoggerContext;

    if (LoggerContext == NULL) {
        return  ERROR_OBJECT_NOT_FOUND;
    }

    LoggerOn = InterlockedExchange(&LoggerContext->CollectionOn, FALSE);
    if (LoggerOn == FALSE) {
        return ERROR_OBJECT_NOT_FOUND;
    }
    NtReleaseSemaphore(LoggerContext->Semaphore, 1, NULL);

    Status = STATUS_TIMEOUT;
    while (Status == STATUS_TIMEOUT) {
        Status = NtWaitForSingleObject(
                    LoggerContext->LoggerEvent, FALSE, &TimeOut);
#if DBG
        WmipAssert(Status != STATUS_TIMEOUT);
#endif
    }


    NtClearEvent(LoggerContext->LoggerEvent);

    return ERROR_SUCCESS;
}

ULONG
WmipDisableTraceProvider(
    PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    WMIDPREQUEST WmiDPRequest;
    PVOID RequestAddress;
    PVOID RequestContext;
    WNODE_HEADER Wnode;
    ULONG Cookie;
    ULONG BufferSize;
    ULONG Status = ERROR_SUCCESS;

    BufferSize = sizeof(WNODE_HEADER);
    RtlCopyMemory(&Wnode, &LoggerInfo->Wnode, BufferSize);

    Wnode.BufferSize = BufferSize;

    Wnode.ProviderId =  WMI_DISABLE_EVENTS;

    Cookie = Wnode.CountLost;

    if (WmipLookupCookie(Cookie,
                 &Wnode.Guid,
                 &RequestAddress,
                 &RequestContext)) {
        WmiDPRequest = (WMIDPREQUEST)RequestAddress;
        try
        {
            WmipGenericTraceEnable(Wnode.ProviderId, &Wnode, (PVOID*)&WmiDPRequest);

            if (*WmiDPRequest != NULL) {
                Status = (*WmiDPRequest)(Wnode.ProviderId,
                                     RequestContext,
                                     &BufferSize,
                                     &Wnode);
            }
            else
                Status = ERROR_WMI_DP_NOT_FOUND;
        } except (EXCEPTION_EXECUTE_HANDLER) {
#if DBG
            Status = GetExceptionCode();
            WmipDebugPrint(("WMI: Service request call caused an exception %d\n",
                            Status));
#endif
            Status = ERROR_WMI_DP_FAILED;
        }
    }

    return Status;
}


ULONG
WmipStopUmLogger(
        IN ULONG WnodeSize,
        IN OUT ULONG *SizeUsed,
        OUT ULONG *SizeNeeded,
        IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    ULONG Status = ERROR_SUCCESS;
#if DBG
    LONG RefCount;

    RefCount =
#endif
    WmipLockLogger();
    TraceDebug(("StopUm: %d->%d\n", RefCount-1, RefCount));
    if (!WmipIsLoggerOn()) {
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("StopUm: %d->%d INSTANCE_NOT_FOUND\n",RefCount+1,RefCount));
        return (ERROR_WMI_INSTANCE_NOT_FOUND);
    }
    Status = WmipStopLoggerInstance();

    if (Status == ERROR_SUCCESS) {
        Status = WmipQueryUmLogger(WnodeSize, SizeUsed, SizeNeeded, LoggerInfo);
    }
    if (Status != ERROR_SUCCESS) {
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("StopUm: %d->%d %d\n", RefCount+1, RefCount, Status));
        WmipSetLastError(Status);
        return(Status);
    }

    //
    // Finalize LogHeader ?
    //
    if (Status == ERROR_SUCCESS) {
        LoggerInfo->BuffersWritten = WmipLoggerContext->BuffersWritten;
        LoggerInfo->LogFileMode = WmipLoggerContext->LogFileMode;
        Status = WmipFinalizeLogFileHeader(LoggerInfo);
    }

    WmipFreeLoggerContext(WmipLoggerContext);
    WmipDisableTraceProvider(LoggerInfo);

    return Status;
}

ULONG
WmipProcessUMRequest(
    PWMI_LOGGER_INFORMATION LoggerInfo,
    PVOID DeliveryContext,
    ULONG ReplyIndex
    )
{
    ULONG Status;
    PWMIMBREPLY Reply;
    ULONG BufferSize;
    PUCHAR Buffer = NULL;
    ULONG WnodeSize = 0;
    ULONG SizeUsed, SizeNeeded;
    ULONG RequestCode = 0;
    ULONG RetSize;
    struct {
        WMIMBREPLY MBreply;
        ULONG      Status;
    }     DefaultReply;
    Reply = (PWMIMBREPLY) &DefaultReply;

    Reply->Handle.Handle = (HANDLE)DeliveryContext;
    Reply->ReplyIndex = ReplyIndex;

    BufferSize = sizeof(DefaultReply);

    if ( (LoggerInfo==NULL) ||
         (DeliveryContext == NULL) ) {
        DefaultReply.Status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    RequestCode = LoggerInfo->Wnode.ProviderId;
    WnodeSize = LoggerInfo->Wnode.BufferSize;
    SizeUsed = 0;
    SizeNeeded = 0;
    switch (RequestCode) {
        case WmiStartLoggerCode:
                Status = WmipStartUmLogger(WnodeSize,
                                            &SizeUsed,
                                            &SizeNeeded,
                                            LoggerInfo);
                break;

        case WmiStopLoggerCode:
                Status = WmipStopUmLogger(WnodeSize,
                                            &SizeUsed,
                                            &SizeNeeded,
                                            LoggerInfo);
                break;
        case WmiQueryLoggerCode:
                Status = WmipQueryUmLogger(WnodeSize,
                                            &SizeUsed,
                                            &SizeNeeded,
                                            LoggerInfo);
                break;
        case WmiUpdateLoggerCode:
            Status = WmipUpdateUmLogger(WnodeSize,
                                     &SizeUsed,
                                     &SizeNeeded,
                                     LoggerInfo);
                break;
        default:
                Status = ERROR_INVALID_PARAMETER;
                break;
    }

    BufferSize += WnodeSize;

    Buffer = WmipAlloc(BufferSize);
    if (Buffer == NULL) {
        BufferSize = sizeof(DefaultReply);
        DefaultReply.Status = ERROR_OUTOFMEMORY;
    }
    else {
        Reply = (PWMIMBREPLY) Buffer;
        Reply->Handle.Handle = (HANDLE)DeliveryContext;
        Reply->ReplyIndex = ReplyIndex;

        if (LoggerInfo != NULL)
        {
            memcpy(Reply->Message, LoggerInfo, LoggerInfo->Wnode.BufferSize);
        }
    }

cleanup:
    Status = WmipSendWmiKMRequest(NULL,
                              IOCTL_WMI_MB_REPLY,
                              Reply,
                              BufferSize,
                              Reply,
                              BufferSize,
                              &RetSize,
                              NULL);

   if (Buffer != NULL) {
       WmipFree(Buffer);
   }
   return Status;

}

PWMI_LOGGER_CONTEXT
WmipInitLoggerContext(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    PWMI_LOGGER_CONTEXT LoggerContext;
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION SystemInfo;

    LoggerContext = (PWMI_LOGGER_CONTEXT) WmipAlloc(sizeof(WMI_LOGGER_CONTEXT));
    if (LoggerContext == NULL) {
        return LoggerContext;
    }

    RtlZeroMemory(LoggerContext, sizeof(WMI_LOGGER_CONTEXT));

    if (LoggerInfo->BufferSize > 0) {
        LoggerContext->BufferSize = LoggerInfo->BufferSize * 1024;
    }
    else {
        LoggerContext->BufferSize       = DEFAULT_BUFFER_SIZE;
    }
    LoggerInfo->BufferSize = LoggerContext->BufferSize / 1024;


    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       &SystemInfo,
                                       sizeof (SystemInfo),
                                       NULL);

    if (!NT_SUCCESS(Status)) {
        WmipFree(LoggerContext);
        return NULL;
    }

    //
    // Round the Buffer Size to page size multiple and save it
    // for allocation later.
    //

    LoggerContext->BufferPageSize = ROUND_TO_PAGES(LoggerContext->BufferSize,
                                       SystemInfo.PageSize);

    LoggerContext->LogFileHandle = LoggerInfo->LogFileHandle;
    LoggerContext->ByteOffset.QuadPart = LoggerInfo->BuffersWritten
                                         * LoggerInfo->BufferSize * 1024;


    LoggerContext->LogFileMode      = EVENT_TRACE_PRIVATE_LOGGER_MODE;
    if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
        LoggerContext->LogFileMode |= EVENT_TRACE_FILE_MODE_CIRCULAR;
    else
        LoggerContext->LogFileMode |= EVENT_TRACE_FILE_MODE_SEQUENTIAL;

    LoggerContext->EventsLost       = 0;
    LoggerContext->BuffersWritten   = LoggerInfo->BuffersWritten;
    LoggerContext->BuffersAvailable = LoggerContext->NumberOfBuffers;

    LoggerContext->ProcessorBuffers = NULL;

    LoggerContext->StartTime.QuadPart = WmipGetSystemTime();

    InitializeListHead(&LoggerContext->FreeList);
    InitializeListHead(&LoggerContext->FlushList);

    LoggerContext->BufferAgeLimit.QuadPart =
            15 * OneSecond.QuadPart * 60 * DEFAULT_AGE_LIMIT;
    if (LoggerInfo->AgeLimit > 0) {
        LoggerContext->BufferAgeLimit.QuadPart =
            LoggerInfo->AgeLimit * OneSecond.QuadPart * 60;
    }
    else if (LoggerInfo->AgeLimit < 0)
        LoggerContext->BufferAgeLimit.QuadPart = 0;

    Status = NtCreateSemaphore(
                &LoggerContext->Semaphore,
                SEMAPHORE_ALL_ACCESS,
                NULL,
                0,
                SEMAPHORE_LIMIT);

    if (!NT_SUCCESS(Status)) {
        WmipFree(LoggerContext);
        return NULL;
    }

//    RtlInitializeCriticalSection(&UMLogCritSect);

    return LoggerContext;
}

PWMI_BUFFER_HEADER
FASTCALL
WmipGetFreeBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    PWMI_BUFFER_HEADER Buffer = NULL;

    if (IsListEmpty(&LoggerContext->FreeList)) {
        ULONG BufferSize = LoggerContext->BufferPageSize;
        ULONG MaxBuffers = LoggerContext->MaximumBuffers;
        ULONG NumberOfBuffers = LoggerContext->NumberOfBuffers;

        if (NumberOfBuffers < MaxBuffers) {
            Buffer = (PWMI_BUFFER_HEADER)
                        WmipMemCommit(
                            (PVOID)((char*)LoggerContext->BufferSpace +
                                     BufferSize *  NumberOfBuffers),
                            BufferSize);
            if (Buffer != NULL) {
                RtlZeroMemory(Buffer, sizeof(WMI_BUFFER_HEADER));
                Buffer->CurrentOffset       = sizeof(WMI_BUFFER_HEADER);
                Buffer->Flags               = BUFFER_STATE_DIRTY;
                Buffer->ReferenceCount      = 0;
                Buffer->SavedOffset         = 0;
                Buffer->Wnode.ClientContext = 0;
                InterlockedIncrement(&LoggerContext->NumberOfBuffers);
            }
        }
    }
    else {
        PLIST_ENTRY pEntry = RemoveHeadList(&LoggerContext->FreeList);
        if (pEntry != NULL) {
            Buffer = CONTAINING_RECORD(pEntry, WMI_BUFFER_HEADER, Entry);
            InterlockedDecrement(&LoggerContext->BuffersAvailable);
            Buffer->CurrentOffset       = sizeof(WMI_BUFFER_HEADER);
            Buffer->Flags               = BUFFER_STATE_DIRTY;
            Buffer->SavedOffset         = 0;
            Buffer->ReferenceCount      = 0;
            Buffer->Wnode.ClientContext = 0;
        }
    }
    return Buffer;
}


ULONG
WmipAllocateTraceBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
/*++

Routine Description:

    This routine is called to allocate the necessary buffers for user-mode
    only logging.

Arguments:

    None

Return Value:

    Status of allocating the buffers
--*/

{
    ULONG Processors;
    ULONG BufferSize;
    ULONG BufferPageSize;
    ULONG NumberOfBuffers;
    ULONG i;
    PVOID BufferSpace;
    PWMI_BUFFER_HEADER Buffer;

    Processors = LoggerContext->NumberOfProcessors;
    if (Processors == 0)
        Processors = 1;
    BufferSize = LoggerContext->BufferSize;
    if (BufferSize < 1024)
        BufferSize = 4096;

    NumberOfBuffers = LoggerContext->NumberOfBuffers;
    if (NumberOfBuffers < Processors+1)
        NumberOfBuffers = Processors + 1;

    //
    // Determine the number of processors first
    //
    LoggerContext->ProcessorBuffers = WmipAlloc( Processors
                                                 * sizeof(PWMI_BUFFER_HEADER));
    if (LoggerContext->ProcessorBuffers == NULL) {
        return ERROR_OUTOFMEMORY;
    }
    BufferSpace = WmipMemReserve( LoggerContext->MaximumBuffers *
                                  LoggerContext->BufferPageSize );
    if (BufferSpace == NULL) {
        WmipFree(LoggerContext->ProcessorBuffers);
        LoggerContext->ProcessorBuffers = NULL;
        return ERROR_OUTOFMEMORY;
    }

    LoggerContext->BufferSpace = BufferSpace;

    for (i=0; i<NumberOfBuffers; i++) {
        Buffer = (PWMI_BUFFER_HEADER)
                    WmipMemCommit(
                        (PVOID)((char*)BufferSpace + i * LoggerContext->BufferPageSize),
                        BufferSize);
        if (Buffer == NULL) {
            WmipMemFree(LoggerContext->BufferSpace);
            WmipFree(LoggerContext->ProcessorBuffers);
            LoggerContext->ProcessorBuffers = NULL;
            LoggerContext->BufferSpace = NULL;
            return ERROR_OUTOFMEMORY;
        }
        RtlZeroMemory(Buffer, sizeof(WMI_BUFFER_HEADER));
        Buffer->TimeStamp.QuadPart = WmipGetSystemTime();
        Buffer->CurrentOffset = sizeof(WMI_BUFFER_HEADER);
        Buffer->Wnode.Flags = BUFFER_STATE_DIRTY;
        InsertTailList(&LoggerContext->FreeList, & (Buffer->Entry));
    }
    LoggerContext->NumberOfBuffers  = NumberOfBuffers;
    LoggerContext->BuffersAvailable = NumberOfBuffers;
    for (i=0; i<Processors; i++) {
        Buffer = (PWMI_BUFFER_HEADER) WmipGetFreeBuffer(LoggerContext);
        LoggerContext->ProcessorBuffers[i] = Buffer;
        if (Buffer != NULL) {
            Buffer->ClientContext.ProcessorNumber = (UCHAR) i;
        }
        else {
            WmipMemFree(LoggerContext->BufferSpace);
            WmipFree(LoggerContext->ProcessorBuffers);
            LoggerContext->ProcessorBuffers = NULL;
            LoggerContext->BufferSpace = NULL;
            return ERROR_OUTOFMEMORY;
        }
    }

    return ERROR_SUCCESS;
}

VOID
WmipLogger(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )

/*++

Routine Description:
    This function is the logger itself. It is started as a separate thread.
    It will not return until someone has stopped data collection or it
    is not successful is flushing out a buffer (e.g. disk is full).

Arguments:

    None.

Return Value:

    The status of running the buffer manager

--*/

{
    PWMI_BUFFER_HEADER Buffer;
    NTSTATUS Status;
    ULONG    i, ErrorCount;
    PLIST_ENTRY pEntry;
    LIST_ENTRY  FlushList;
    BOOLEAN StopLogging = FALSE;

    Status = STATUS_SUCCESS;

    LoggerContext->LoggerStatus = Status;
    if (NT_SUCCESS(Status)) {
//
// This is the only place where CollectionOn will be turn on!!!
//
        LoggerContext->CollectionOn = TRUE;
        WmipLoggerContext = LoggerContext;
        //NtSetEvent(LoggerContext->LoggerEvent, NULL);
    }
    else {
        //NtSetEvent(LoggerContext->LoggerEvent, NULL);
         WmipExitThread(0);;
    }

    InterlockedDecrement(&NtdllLoggerLock);

    ErrorCount = 0;
// by now, the caller has been notified that the logger is running

//
// Loop and wait for buffers to be filled until someone turns off CollectionOn
//
    while (LoggerContext->CollectionOn) {
        ULONG Counter;
        ULONG DelayFlush;
        PLARGE_INTEGER FlushTimer;

        if (LoggerContext->FlushTimer.QuadPart == 0) {
            FlushTimer = NULL;
        }
        else {
            FlushTimer = &LoggerContext->FlushTimer;
        }

        Status = NtWaitForSingleObject( LoggerContext->Semaphore, FALSE,
                                      FlushTimer);

        DelayFlush = FALSE;
        if ( Status == WAIT_TIMEOUT) {
//
// FlushTimer used, and we just timed out. Go through per processor buffer
// and mark each as FULL so that it will get flushed next time
//
            for (i=0; i<(ULONG)LoggerContext->NumberOfProcessors; i++) {
                Buffer = (PWMI_BUFFER_HEADER)LoggerContext->ProcessorBuffers[i];
                if (Buffer == NULL)
                    continue;

                if (Buffer->CurrentOffset == sizeof(WMI_BUFFER_HEADER))
                    Buffer->Flags = BUFFER_STATE_UNUSED;
                if (Buffer->Flags != BUFFER_STATE_UNUSED) {
                    Buffer->Flags = BUFFER_STATE_FULL;
                    DelayFlush = TRUE; // let ReserveTraceBuffer send semaphore
                }
            }
        }

        if (DelayFlush)    // will only be TRUE if FlushTimer is used
            continue;

        if (IsListEmpty(&LoggerContext->FlushList)){ //should not happen normally
            continue;
        }

        LoggerContext->TransitionBuffer = LoggerContext->FlushList.Flink;

        WmipEnterUMCritSection();

        //
        // Copy the current LoggerContext->Flushlist information to new FlushList
        //

        FlushList.Flink  = LoggerContext->FlushList.Flink;
        FlushList.Flink->Blink = &FlushList;

        FlushList.Blink = LoggerContext->FlushList.Blink;
        FlushList.Blink->Flink = &FlushList;

        //
        // Reinitialize LoggerContext->FlushList
        //

        InitializeListHead(&LoggerContext->FlushList);

        WmipLeaveUMCritSection();

        do{
            pEntry = IsListEmpty(&FlushList) ? NULL : RemoveHeadList(&FlushList);

            if (pEntry ){

                Buffer = CONTAINING_RECORD(pEntry, WMI_BUFFER_HEADER, Entry);
                if (Buffer->Flags == BUFFER_STATE_UNUSED) {
                    Buffer->Flags = BUFFER_STATE_DIRTY; // Let FlushBuffer deal with it
                }

                Status = WmipFlushBuffer(LoggerContext, Buffer);

                WmipEnterUMCritSection();
                if (LoggerContext->BufferAgeLimit.QuadPart == 0) {
                    InsertTailList(&LoggerContext->FreeList, &Buffer->Entry);
                }
                else {
                    InsertHeadList(&LoggerContext->FreeList, &Buffer->Entry);
                }
                WmipLeaveUMCritSection();

                if (!NT_SUCCESS(Status)) {

                    if((Status == STATUS_LOG_FILE_FULL)    ||
                       (Status == STATUS_NO_DATA_DETECTED) ||
                       (Status == STATUS_SEVERITY_WARNING)){

                       if (Status == STATUS_LOG_FILE_FULL){
                           ErrorCount++;
                       } else {
                           ErrorCount = 0;    // reset to zero otherwise
                       }

                       if (ErrorCount > ERROR_RETRY_COUNT){
                            StopLogging = TRUE; // for now. Should raise WMI event
                            break;
                       }
                    } else {
                        StopLogging = TRUE; // Some Kind of Severe Error
                        break;
                    }
                }
            }

        }while( pEntry );

        LoggerContext->TransitionBuffer = NULL;

        if (StopLogging) {
#if DBG
            LONG RefCount;
#endif
            Status = NtClose(LoggerContext->LogFileHandle);
            LoggerContext->LogFileHandle = NULL;

            WmipStopLoggerInstance();
#if DBG
            RefCount =
#endif
            WmipLockLogger();
            TraceDebug(("WmipLogger: %d->%d\n", RefCount-1, RefCount));
            WmipFreeLoggerContext (LoggerContext);
            WmipSetNtStatus(Status);
            WmipExitThread(0);
        }
    } // while loop

    // if a normal collection end, flush out all the buffers before stopping
    //
    WmipFlushAllBuffers(LoggerContext);

    NtSetEvent(LoggerContext->LoggerEvent, NULL);
//    RtlDeleteCriticalSection(&UMLogCritSect);
    WmipExitThread(0); // check to see if this thread terminate itself with this
}


ULONG
WmipFlushBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER Buffer
    )
/*++

Routine Description:
    This function is responsible for flushing a filled buffer out to
    disk, or to a real time consumer.

Arguments:

    LoggerContext       Context of the logger

Return Value:

    The status of flushing the buffer

--*/
{
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    PWMI_BUFFER_HEADER OldBuffer;
    ULONG BufferSize;

//
// Grab the buffer to be flushed
//
    BufferSize = LoggerContext->BufferSize;
//
// Put end of record marker in buffer if available space
//
    if (Buffer->SavedOffset > 0) {
        Buffer->Offset = Buffer->SavedOffset;
    }
    else {
        Buffer->Offset = Buffer->CurrentOffset;
    }

    if (Buffer->Offset < BufferSize) {
        RtlFillMemory(
                (char *) Buffer + Buffer->Offset,
                BufferSize - Buffer->Offset,
                0xFF);
    }
    if (Buffer->Offset < sizeof(WMI_BUFFER_HEADER)) { // should not happen
        Status = STATUS_INVALID_PARAMETER;
        goto ResetTraceBuffer;
    }
    if (Buffer->Offset == sizeof(WMI_BUFFER_HEADER)) { // empty buffer
        Status = STATUS_NO_DATA_DETECTED;
        goto ResetTraceBuffer;
    }
    Status = STATUS_SUCCESS;
    Buffer->Wnode.BufferSize       = BufferSize;
    Buffer->ClientContext.LoggerId = (USHORT) LoggerContext->LoggerId;

    Buffer->ClientContext.Alignment = (UCHAR) WmiTraceAlignment;
    Buffer->SavedOffset   = WmipGetCurrentProcessId();
    RtlCopyMemory(&Buffer->Wnode.Guid, &EventTraceGuid, sizeof(GUID));
    Buffer->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    Buffer->Flags |= WNODE_FLAG_THREAD_BUFFER;

    Buffer->Wnode.TimeStamp.QuadPart = WmipGetSystemTime();

    if (LoggerContext->LogFileHandle == NULL) {
        goto ResetTraceBuffer;
    }

    if (LoggerContext->MaximumFileSize > 0) { // if quota given
        ULONG64 FileSize = LoggerContext->LastFlushedBuffer * BufferSize;
        ULONG64 FileLimit = LoggerContext->MaximumFileSize * BYTES_PER_MB;
        if ( FileSize >= FileLimit ) { // reaches maximum file size
           ULONG LoggerMode = LoggerContext->LogFileMode & 0X000000FF;
           LoggerMode &= ~EVENT_TRACE_FILE_MODE_APPEND;

            switch (LoggerMode) {


            case EVENT_TRACE_FILE_MODE_SEQUENTIAL :
                // do not write to logfile anymore
                Status = STATUS_LOG_FILE_FULL; // control needs to stop logging
                // need to fire up a Wmi Event to control console
                break;

            case EVENT_TRACE_FILE_MODE_CIRCULAR   :
            {
                // reposition file

                LoggerContext->ByteOffset
                    = LoggerContext->FirstBufferOffset;
                LoggerContext->LastFlushedBuffer = (ULONG)
                      (LoggerContext->FirstBufferOffset.QuadPart
                        / LoggerContext->BufferSize);
                break;
            }
            default :
                break;
            }
        }
    }

    if (NT_SUCCESS(Status)) {
        Status = NtWriteFile(
                    LoggerContext->LogFileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    Buffer,
                    BufferSize,
                    &LoggerContext->ByteOffset,
                    NULL);
    }

    if (NT_SUCCESS(Status)) {
        LoggerContext->ByteOffset.QuadPart += BufferSize;
    }

 ResetTraceBuffer:

    if (NT_SUCCESS(Status)) {
        LoggerContext->BuffersWritten++;
        LoggerContext->LastFlushedBuffer++;
    }
    else {
        if ((Status != STATUS_NO_DATA_DETECTED) &&
            (Status != STATUS_SEVERITY_WARNING))
            LoggerContext->LogBuffersLost++;
    }

//
// Reset the buffer state
//

    Buffer->EventsLost     = 0;
    Buffer->SavedOffset    = 0;
    Buffer->ReferenceCount = 0;
    Buffer->Flags          = BUFFER_STATE_UNUSED;

//
// Try and remove an unused buffer if it has not been used for a while
//

    InterlockedIncrement(& LoggerContext->BuffersAvailable);
    return Status;
}

PVOID
FASTCALL
WmipReserveTraceBuffer(
    IN  ULONG RequiredSize,
    OUT PWMI_BUFFER_HEADER *BufferResource
    )
{
    PWMI_BUFFER_HEADER Buffer, OldBuffer;
    PVOID       ReservedSpace;
    ULONG       Offset;
    ULONG       fCircularBufferOnly = FALSE; // tracelog.c v39->v40
    ULONG Processor = (ULONG) (NtCurrentTeb()->IdealProcessor);
    PWMI_LOGGER_CONTEXT LoggerContext = WmipLoggerContext;

    //
    // NOTE: This routine assumes that the caller has verified that
    // WmipLoggerContext is valid and is locked
    //
    if (Processor >= LoggerContext->NumberOfProcessors) {
        Processor = LoggerContext->NumberOfProcessors-1;
    }


    *BufferResource = NULL;

    RequiredSize = (ULONG) ALIGN_TO_POWER2(RequiredSize, WmiTraceAlignment);

  TryFindSpace:
//
// Get the processor specific buffer pool
//
    Buffer = LoggerContext->ProcessorBuffers[Processor];
    if (Buffer == NULL) {
        return NULL;
    }

    //
    // Increment refcount to buffer first to prevent it from going away
    //
    InterlockedIncrement(&Buffer->ReferenceCount);
    if ((Buffer->Flags != BUFFER_STATE_FULL) &&
        (Buffer->Flags != BUFFER_STATE_UNUSED)) {
//
// This should happen 99% of the time. Offset will have the old value
//
        Offset = (ULONG) InterlockedExchangeAdd(
                                & Buffer->CurrentOffset, RequiredSize);

//
// First, check to see if there is enough space. If not, it will
//   need to get another fresh buffer, and have the current buffer flushed
//
        if (Offset+RequiredSize < WmipLoggerContext->BufferSize) {
//
// Found the space so return it. This should happen 99% of the time
//
            ReservedSpace = (PVOID) (Offset +  (char*)Buffer);
            if (LoggerContext->SequencePtr) {
                *((PULONG) ReservedSpace) =
                    InterlockedIncrement(LoggerContext->SequencePtr);
            }
            goto FoundSpace;
        }
    }
    else {
        Offset = Buffer->CurrentOffset; // Initialize Local Variable
                                        // tracelog.c v40 -> v41
    }
    if (Offset <LoggerContext->BufferSize) {
        Buffer->SavedOffset = Offset;       // save this for FlushBuffer
    }

//  if there is absolutely no more buffers, then return quickly
//
    if ((LoggerContext->NumberOfBuffers == LoggerContext->MaximumBuffers)
         && (LoggerContext->BuffersAvailable == 0)) {
        goto LostEvent;
    }

// Out of buffer space. Need to take the long route to find a buffer
//
    Buffer->Flags = BUFFER_STATE_FULL;

    OldBuffer = Buffer;
    Buffer = WmipSwitchBuffer(LoggerContext, OldBuffer, Processor);
    if (Buffer == NULL) {
        Buffer = OldBuffer;
        goto LostEvent;
    }

    //
    // Decrement the refcount that we blindly incremented earlier
    // so that it can be flushed by the logger thread
    //
    InterlockedDecrement(&OldBuffer->ReferenceCount);
    Buffer->ClientContext.ProcessorNumber = (UCHAR) (Processor);

    if (!fCircularBufferOnly) {
        NtReleaseSemaphore(LoggerContext->Semaphore, 1, NULL);
    }

    goto TryFindSpace;

LostEvent:
//
// Will get here if we are throwing away events.
// from tracelog.c v36->v37
//
    LoggerContext->EventsLost ++;
    Buffer->EventsLost ++;
    InterlockedDecrement(& Buffer->ReferenceCount);
    Buffer        = NULL;
    ReservedSpace = NULL;
    if (LoggerContext->SequencePtr) {
        InterlockedIncrement(LoggerContext->SequencePtr);
    }

FoundSpace:
//
// notify the logger after critical section
//
    *BufferResource = Buffer;

    return ReservedSpace;
}



//
// This Routine is called to Relog an event for straigtening out an ETL
// in time order. This will result in two events being, one for Processor
// number and the actual event  without any modifications.
//

ULONG
FASTCALL
WmipRelogEvent(
    IN PWNODE_HEADER Wnode
    )
{
    PWMI_BUFFER_HEADER BufferResource = NULL;
    PEVENT_TRACE pEvent = (PEVENT_TRACE) Wnode;
    PWMI_LOGGER_CONTEXT LoggerContext;

    PUCHAR BufferSpace;
    PULONG Marker;
    ULONG Size;
    ULONG MaxSize;
    ULONG SavedProcessor = (ULONG)NtCurrentTeb()->IdealProcessor;
    ULONG Processor;
    ULONG Mask;
    ULONG status;

    if (pEvent->Header.Size < sizeof(EVENT_TRACE) ) {
        return ERROR_INVALID_PARAMETER;
    }
    LoggerContext = WmipLoggerContext;
    Processor = ((PWMI_CLIENT_CONTEXT)&pEvent->ClientContext)->ProcessorNumber;

    Size = pEvent->MofLength;
    MaxSize = LoggerContext->BufferSize - sizeof(WMI_BUFFER_HEADER);
    if ((Size == 0) || (Size > MaxSize)) {
        LoggerContext->EventsLost++;
        return ERROR_BUFFER_OVERFLOW;
    }
    NtCurrentTeb()->IdealProcessor = (BOOLEAN)Processor;
    BufferSpace = (PUCHAR)
        WmipReserveTraceBuffer(
            Size,
            &BufferResource
            );
    NtCurrentTeb()->IdealProcessor = (BOOLEAN)SavedProcessor;

    if (BufferSpace == NULL) {
        return ERROR_OUTOFMEMORY;
    }


    RtlCopyMemory(BufferSpace, pEvent->MofData, Size);
    WmipReleaseTraceBuffer( BufferResource );

    return ERROR_SUCCESS;
}



ULONG
FASTCALL
WmiTraceUmEvent(
    IN PWNODE_HEADER Wnode
    )
/*++

Routine Description:

    This routine is used by WMI data providers to trace events.
    It expects the user to pass in the handle to the logger.
    Also, the user cannot ask to log something that is larger than
    the buffer size (minus buffer header).

Arguments:

    Wnode           The WMI node header that will be overloaded


Return Value:

    STATUS_SUCCESS  if the event trace is recorded successfully

--*/
{
    PEVENT_TRACE_HEADER TraceRecord = (PEVENT_TRACE_HEADER) Wnode;
    ULONG WnodeSize, Size, Flags, HeaderSize;
    PWMI_BUFFER_HEADER BufferResource = NULL;
    PWMI_LOGGER_CONTEXT LoggerContext;
    ULONG Marker;
    MOF_FIELD MofFields[MAX_MOF_FIELDS];
    long MofCount = 0;
    PCLIENT_ID Cid;
#if DBG
    LONG RefCount;
#endif


    HeaderSize = sizeof(WNODE_HEADER);  // same size as EVENT_TRACE_HEADER
    Size = Wnode->BufferSize;     // take the first DWORD flags
    Marker = Size;
    if (Marker & TRACE_HEADER_FLAG) {
        if ( ((Marker & TRACE_HEADER_ENUM_MASK) >> 16)
                == TRACE_HEADER_TYPE_INSTANCE )
            HeaderSize = sizeof(EVENT_INSTANCE_HEADER);
        Size = TraceRecord->Size;
    }
    WnodeSize = Size;           // WnodeSize is for the contiguous block
                                    // Size is for what we want in buffer

    Flags = Wnode->Flags;
    if (!(Flags & WNODE_FLAG_LOG_WNODE) &&
        !(Flags & WNODE_FLAG_TRACED_GUID))
        return ERROR_INVALID_PARAMETER;

#if DBG
    RefCount =
#endif
    WmipLockLogger();
#if DBG
    TraceDebug(("TraceUm: %d->%d\n", RefCount-1, RefCount));
#endif

    if (!WmipIsLoggerOn()) {
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
#if DBG
        TraceDebug(("TraceUm: %d->%d INVALID_HANDLE\n",
                        RefCount+1, RefCount));
#endif
        return ERROR_INVALID_HANDLE;
    }

    LoggerContext = WmipLoggerContext;

    if (Flags & WNODE_FLAG_NO_HEADER) {
        ULONG Status;

        Status = WmipRelogEvent( Wnode );
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();

#if DBG
        if (Status != ERROR_SUCCESS) {
            TraceDebug(("TraceUm: %d->%d Relog Error \n",
                            RefCount+1, RefCount));
        }
#endif
        return Status;

    }

    if (Flags & WNODE_FLAG_USE_MOF_PTR) {
    //
    // Need to compute the total size required, since the MOF fields
    // in Wnode merely contains pointers
    //
        long i;
        PCHAR Offset = ((PCHAR)Wnode) + HeaderSize;
        ULONG MofSize, MaxSize;

        MaxSize = LoggerContext->BufferSize - sizeof(WMI_BUFFER_HEADER);
        MofSize = WnodeSize - HeaderSize;
        // allow only the maximum
        if (MofSize > (sizeof(MOF_FIELD) * MAX_MOF_FIELDS))
            return ERROR_INVALID_DATA;

        // TODO: Do we need to zero memory here?
        RtlZeroMemory( MofFields, MAX_MOF_FIELDS * sizeof(MOF_FIELD));
        if (MofSize > 0) {
            RtlCopyMemory(MofFields, Offset, MofSize);
        }
        Size = HeaderSize;

        MofCount = MofSize / sizeof(MOF_FIELD);
        for (i=0; i<MofCount; i++) {
            MofSize = MofFields[i].Length;
            if (MofSize > (MaxSize - Size)) {
#if DBG
                RefCount =
#endif
                WmipUnlockLogger();
#if DBG
                TraceDebug(("TraceUm: %d->%d BUF_OVERFLOW1\n",
                            RefCount+1, RefCount));
#endif
                return ERROR_BUFFER_OVERFLOW;
            }

            Size += MofSize;
            if ((Size > MaxSize) || (Size < MofSize)) {
#if DBG
                RefCount =
#endif
                WmipUnlockLogger();
#if DBG
                TraceDebug(("TraceUm: %d->%d BUF_OVERFLOW2\n",
                            RefCount+1, RefCount));
#endif
                return ERROR_BUFFER_OVERFLOW;
            }
        }
    }
    if (Size > LoggerContext->BufferSize - sizeof(WMI_BUFFER_HEADER)) {
        LoggerContext->EventsLost++;
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
#if DBG
        TraceDebug(("TraceUm: %d->%d BUF_OVERFLOW3\n",
                    RefCount+1, RefCount));
#endif
        return ERROR_BUFFER_OVERFLOW;
    }

// So, now reserve some space in logger buffer and set that to TraceRecord

    TraceRecord = (PEVENT_TRACE_HEADER)
        WmipReserveTraceBuffer(
            Size,
            &BufferResource
            );

    if (TraceRecord == NULL) {
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
#if DBG
        TraceDebug(("TraceUm: %d->%d NO_MEMORY\n", RefCount+1, RefCount));
#endif
        return ERROR_OUTOFMEMORY;
    }

    if (Flags & WNODE_FLAG_USE_MOF_PTR) {
    //
    // Now we need to probe and copy all the MOF data fields
    //
        PVOID MofPtr;
        ULONG MofLen;
        long i;
        PCHAR TraceOffset = ((PCHAR) TraceRecord) + HeaderSize;

        RtlCopyMemory(TraceRecord, Wnode, HeaderSize);
        TraceRecord->Size = (USHORT)Size;           // reset to Total Size
        for (i=0; i<MofCount; i++) {
            MofPtr = (PVOID) MofFields[i].DataPtr;
            MofLen = MofFields[i].Length;

            if (MofPtr == NULL || MofLen == 0)
                continue;

            RtlCopyMemory(TraceOffset, MofPtr, MofLen);
            TraceOffset += MofLen;
        }
    }
    else {
        RtlCopyMemory(TraceRecord, Wnode, Size);
    }
    if (Flags & WNODE_FLAG_USE_GUID_PTR) {
        PVOID GuidPtr = (PVOID) ((PEVENT_TRACE_HEADER)Wnode)->GuidPtr;

        RtlCopyMemory(&TraceRecord->Guid, GuidPtr, sizeof(GUID));
    }

    //
    // By now, we have reserved space in the trace buffer
    //

    if (Marker & TRACE_HEADER_FLAG) {
        if (! (WNODE_FLAG_USE_TIMESTAMP & TraceRecord->MarkerFlags) )
            TraceRecord->ProcessorTime = WmipGetCycleCount();

        if (LoggerContext->UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
            TraceRecord->TimeStamp.QuadPart = TraceRecord->ProcessorTime;
        }
        else {
            TraceRecord->TimeStamp.QuadPart = WmipGetSystemTime();
        }
        Cid = &NtCurrentTeb()->ClientId;
        TraceRecord->ThreadId = HandleToUlong(Cid->UniqueThread);
        TraceRecord->ProcessId = HandleToUlong(Cid->UniqueProcess);
    }

    WmipReleaseTraceBuffer( BufferResource );
#if DBG
    RefCount =
#endif
    WmipUnlockLogger();

#if DBG
    TraceDebug(("TraceUm: %d->%d\n", RefCount+1, RefCount));
#endif

    return ERROR_SUCCESS;
}

PWMI_BUFFER_HEADER
FASTCALL
WmipSwitchBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER OldBuffer,
    IN ULONG Processor
    )
{
    PWMI_BUFFER_HEADER Buffer;
    ULONG CircularBufferOnly = FALSE;

    if ( (LoggerContext->LogFileMode & EVENT_TRACE_BUFFERING_MODE) &&
         (LoggerContext->BufferAgeLimit.QuadPart == 0) &&
         (LoggerContext->LogFileHandle == NULL) ) {
        CircularBufferOnly = TRUE;
    }
    WmipEnterUMCritSection();
    if (OldBuffer != LoggerContext->ProcessorBuffers[Processor]) {
        WmipLeaveUMCritSection();
        return OldBuffer;
    }
    Buffer = WmipGetFreeBuffer(LoggerContext);
    if (Buffer == NULL) {
        WmipLeaveUMCritSection();
        return NULL;
    }
    LoggerContext->ProcessorBuffers[Processor] = Buffer;
    if (CircularBufferOnly) {
        InsertTailList(&LoggerContext->FreeList, &OldBuffer->Entry);
    }
    else {
        InsertTailList(&LoggerContext->FlushList, &OldBuffer->Entry);
    }
    WmipLeaveUMCritSection();

    return Buffer;
}

ULONG
WmipFreeLoggerContext(
    PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    LONG RefCount;
    if (LoggerContext != NULL) {
        LARGE_INTEGER Timeout = {(ULONG)(-300 * 1000 * 10), -1};  // 300ms
        RefCount = WmipUnlockLogger();
#if DBG
        TraceDebug(("FreeLogger: %d->%d\n", RefCount+1, RefCount));
#endif
        if (RefCount > 1) {
            LONG count = 0;
            NTSTATUS Status = STATUS_TIMEOUT;

            while (Status == STATUS_TIMEOUT) {
                count ++;
                Status = NtWaitForSingleObject(
                            WmipLoggerContext->LoggerEvent, FALSE, &Timeout);
                if (WmipLoggerCount <= 1)
                    break;
                if (WmipLoggerCount == RefCount) {
#if DBG
                    TraceDebug(("FreeLogger: RefCount remained at %d\n",
                                 RefCount));
                    WmipAssert(Status != STATUS_TIMEOUT);
#endif
                    if (count >= 10)
                        WmipLoggerCount = 1;
                }
            }

        }
        if (LoggerContext->BufferSpace != NULL) {
            WmipMemFree(LoggerContext->BufferSpace);
        }
        if (LoggerContext->ProcessorBuffers != NULL) {
            WmipFree(LoggerContext->ProcessorBuffers);
        }
        if (LoggerContext->LoggerName.Buffer != NULL) {
            RtlFreeUnicodeString(&LoggerContext->LoggerName);
        }
        if (LoggerContext->LogFileName.Buffer != NULL) {
            RtlFreeUnicodeString(&LoggerContext->LogFileName);
        }
        WmipLoggerContext = NULL;
        WmipFree(LoggerContext);
#if DBG
        RefCount =
#endif
        WmipUnlockLogger();
        TraceDebug(("FreeLogger: %d->%d\n", RefCount+1, RefCount));

//        RtlDeleteCriticalSection(&UMLogCritSect);
    }
    return ERROR_SUCCESS;
}

ULONG
WmipFlushAllBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    NTSTATUS           Status = STATUS_SUCCESS;
    ULONG              i;
    ULONG              NumberOfBuffers;
    PLIST_ENTRY        pEntry;
    PWMI_BUFFER_HEADER Buffer;
    ULONG RetryCount;

    WmipEnterUMCritSection();

    // First, move the per processor buffer out to FlushList
    //
    for (i = 0; i < LoggerContext->NumberOfProcessors; i ++) {
        Buffer = (PWMI_BUFFER_HEADER) LoggerContext->ProcessorBuffers[i];
        LoggerContext->ProcessorBuffers[i] = NULL;
        if (Buffer != NULL) {

            //
            // Check to see if the Buffer ReferenceCount is 0. If Yes,
            // no one is writing to this buffer and it's okay to flush it.
            // If No, we need to wait until the other thread is done
            // writing to this buffer before flushing.
            //
            RetryCount = 0;
            while (Buffer->ReferenceCount != 0) {
                WmipSleep (250);  // Retry every 1/4 second.
                RetryCount++;
                if (RetryCount > 300) {
                    //
                    // Since there is no guarantee that the ReferenceCount
                    // will ever go down to zero, we try this for over a minute.
                    // After that time we continue and free the buffer
                    // instead of spinning for ever.
#if DBG
                    TraceDebug(("WmipFlushAllBuffer: RetryCount %d exceeds limit", RetryCount));
#endif
                    break;
                }
            }
            InsertTailList(& LoggerContext->FlushList, & Buffer->Entry);
        }
    }
    NumberOfBuffers = LoggerContext->NumberOfBuffers;

    while (   NT_SUCCESS(Status)
           && NumberOfBuffers > 0
           && (  LoggerContext->BuffersAvailable
               < LoggerContext->NumberOfBuffers))
    {
        pEntry = IsListEmpty(& LoggerContext->FlushList)
               ? NULL
               : RemoveHeadList(& LoggerContext->FlushList);

        if (pEntry == NULL)
            break;

        Buffer = CONTAINING_RECORD(pEntry, WMI_BUFFER_HEADER, Entry);
        Status = WmipFlushBuffer(LoggerContext, Buffer);
        InsertHeadList(& LoggerContext->FreeList, & Buffer->Entry);
        NumberOfBuffers --;
    }

    // Note that LoggerContext->LogFileObject needs to remain set
    // for QueryLogger to work after close
    //
    Status = NtClose(LoggerContext->LogFileHandle);

    LoggerContext->LogFileHandle = NULL;
    LoggerContext->LoggerStatus = Status;

    WmipLeaveUMCritSection();

    return ERROR_SUCCESS;
}

ULONG
WmipFlushUmLoggerBuffer()
{
    ULONG Status = ERROR_SUCCESS;
#if DBG
    LONG RefCount;

    RefCount =
#endif
    WmipLockLogger();
    TraceDebug(("FlushUm: %d->%d\n", RefCount-1, RefCount));

    if (WmipIsLoggerOn()) {
        WmipLoggerContext->CollectionOn = FALSE;
        Status = WmipFlushAllBuffers(WmipLoggerContext);
        if (Status == ERROR_SUCCESS) {
            PWMI_LOGGER_INFORMATION WmipLoggerInfo = NULL;
            ULONG                   lSizeUsed;
            ULONG                   lSizeNeeded = 0;

            lSizeUsed = sizeof(WMI_LOGGER_INFORMATION)
                      + 2 * MAXSTR * sizeof(WCHAR);
            WmipLoggerInfo = (PWMI_LOGGER_INFORMATION) WmipAlloc(lSizeUsed);
            if (WmipLoggerInfo == NULL) {
                Status = ERROR_OUTOFMEMORY;
            }
            else {
                RtlZeroMemory(WmipLoggerInfo, lSizeUsed);
                WmipLoggerInfo->Wnode.BufferSize  = lSizeUsed;
                WmipLoggerInfo->Wnode.Flags      |= WNODE_FLAG_TRACED_GUID;
                Status = WmipQueryUmLogger(
                                WmipLoggerInfo->Wnode.BufferSize,
                                & lSizeUsed,
                                & lSizeNeeded,
                                WmipLoggerInfo);

                if (Status == ERROR_SUCCESS) {
                    Status = WmipFinalizeLogFileHeader(WmipLoggerInfo);
                }
                WmipFree(WmipLoggerInfo);
            }
        }
        WmipFreeLoggerContext(WmipLoggerContext);
    }

    return Status;
}

LONG
FASTCALL
WmipReleaseTraceBuffer(
    IN PWMI_BUFFER_HEADER BufferResource
    )
{
    ULONG RefCount;

    if (BufferResource == NULL)
        return 0;

    RefCount = InterlockedDecrement(&BufferResource->ReferenceCount);
    if ((RefCount == 0) && (BufferResource->Flags == BUFFER_STATE_FULL)) {
        NtReleaseSemaphore(WmipLoggerContext->Semaphore, 1, NULL);
    }
    return RefCount;
}


ULONG
WmipReceiveReply(
    HANDLE ReplyHandle,
    ULONG  ReplyCount,
    ULONG ReplyIndex,
    PVOID OutBuffer,
    ULONG OutBufferSize
    )
{
    ULONG Status = ERROR_SUCCESS;
    ULONG ReturnSize;
    PWMIRECEIVENOTIFICATION RcvNotification;
    ULONG RcvNotificationSize;
    PUCHAR Buffer;
    ULONG BufferSize;
    PWNODE_TOO_SMALL WnodeTooSmall;
    PWNODE_HEADER Wnode;
    ULONG Linkage;
    ULONG RcvCount = 0;
    struct {
        WMIRECEIVENOTIFICATION Notification;
        HANDLE3264 Handle;
    } NotificationInfo;


    RcvNotificationSize = sizeof(WMIRECEIVENOTIFICATION) +
                          sizeof(HANDLE3264);

    RcvNotification = (PWMIRECEIVENOTIFICATION) &NotificationInfo;

    Status = ERROR_SUCCESS;
    RcvNotification->Handles[0].Handle = ReplyHandle;
    RcvNotification->HandleCount = 1;
    RcvNotification->Action = RECEIVE_ACTION_NONE;
    WmipSetPVoid3264(RcvNotification->UserModeCallback, NULL);

    BufferSize = 0x1000;
    Status = ERROR_INSUFFICIENT_BUFFER;
    while ( (Status == ERROR_INSUFFICIENT_BUFFER) ||
            ((Status == ERROR_SUCCESS) && (RcvCount < ReplyCount)) )
    {
        Buffer = WmipAlloc(BufferSize);
        if (Buffer != NULL)
        {
            Status = WmipSendWmiKMRequest(NULL,
                                      IOCTL_WMI_RECEIVE_NOTIFICATIONS,
                                      RcvNotification,
                                      RcvNotificationSize,
                                      Buffer,
                                      BufferSize,
                                      &ReturnSize,
                                      NULL);

             if (Status == ERROR_SUCCESS)
             {
                 WnodeTooSmall = (PWNODE_TOO_SMALL)Buffer;
                 if ((ReturnSize == sizeof(WNODE_TOO_SMALL)) &&
                     (WnodeTooSmall->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL))
                 {
                    //
                    // The buffer passed to kernel mode was too small
                    // so we need to make it larger and then try the
                    // request again
                    //
                    BufferSize = WnodeTooSmall->SizeNeeded;
                    Status = ERROR_INSUFFICIENT_BUFFER;
                 } else {
                    //
                    // We got a buffer of notifications so lets go
                    // process them and callback the caller
                    //
                    PUCHAR Result = (PUCHAR)OutBuffer;
                    ULONG SizeNeeded = 0;
                    ULONG SizeUsed = 0;
                    Wnode = (PWNODE_HEADER)Buffer;


                    do
                    {
                        Linkage = Wnode->Linkage;
                        Wnode->Linkage = 0;

                        if (Wnode->Flags & WNODE_FLAG_INTERNAL)
                        {
                             // If this is the Reply copy it to the buffer
                             PWMI_LOGGER_INFORMATION LoggerInfo;

                             RcvCount++;

                             LoggerInfo = (PWMI_LOGGER_INFORMATION)((PUCHAR)Wnode + sizeof(WNODE_HEADER));
                             SizeNeeded = LoggerInfo->Wnode.BufferSize;

                             if ((SizeUsed + SizeNeeded) <= OutBufferSize) {
                                 memcpy(Result, LoggerInfo, LoggerInfo->Wnode.BufferSize);
                                 Result += SizeNeeded;
                                 SizeUsed += SizeNeeded;
                             }
                             else Status = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        Wnode = (PWNODE_HEADER)OffsetToPtr(Wnode, Linkage);
                     } while (Linkage != 0);
                 }
             }
             WmipFree(Buffer);
         } else {
             Status = ERROR_NOT_ENOUGH_MEMORY;
         }
     }

     return Status;
}
NTSTATUS
WmipTraceUmMessage(
    IN ULONG    Size,
    IN ULONG64  LoggerHandle,
    IN ULONG    MessageFlags,
    IN LPGUID   MessageGuid,
    IN USHORT   MessageNumber,
    va_list     MessageArgList
)
/*++
Routine Description:
Arguments:
Return Value:
--*/
{
    PMESSAGE_TRACE_HEADER Header;
    char * pMessageData ;
    PWMI_BUFFER_HEADER BufferResource = NULL ;
    ULONG SequenceNumber ;
    PWMI_LOGGER_CONTEXT LoggerContext;

    WmipLockLogger();                           // Lock the logger
    if (!WmipIsLoggerOn()) {
        WmipUnlockLogger();
        return STATUS_INVALID_HANDLE;
    }
    LoggerContext = WmipLoggerContext;

    try {
         // Figure the total size of the message including the header
         Size += (MessageFlags&TRACE_MESSAGE_SEQUENCE ? sizeof(ULONG):0) +
                 (MessageFlags&TRACE_MESSAGE_GUID ? sizeof(GUID):0) +
                 (MessageFlags&TRACE_MESSAGE_COMPONENTID ? sizeof(ULONG):0) +
                 (MessageFlags&(TRACE_MESSAGE_TIMESTAMP | TRACE_MESSAGE_PERFORMANCE_TIMESTAMP) ? sizeof(LARGE_INTEGER):0) +
                 (MessageFlags&TRACE_MESSAGE_SYSTEMINFO ? 2 * sizeof(ULONG):0) +
                 sizeof (MESSAGE_TRACE_HEADER) ;

        //
        // Allocate Space in the Trace Buffer
        //
         if (Size > LoggerContext->BufferSize - sizeof(WMI_BUFFER_HEADER)) {
             LoggerContext->EventsLost++;
             WmipUnlockLogger();
             return STATUS_BUFFER_OVERFLOW;
         }

        if ((Header = (PMESSAGE_TRACE_HEADER)WmipReserveTraceBuffer(Size,&BufferResource)) == NULL) {
            WmipUnlockLogger();
            return STATUS_NO_MEMORY;
        }
        //
        // Sequence Number is returned in the Marker field of the buffer
        //
        SequenceNumber = Header->Marker ;

        //
        // Now copy the necessary information into the buffer
        //

        Header->Marker = TRACE_MESSAGE | TRACE_HEADER_FLAG ;
        //
        // Fill in Header.
        //
        Header->Size = (USHORT)(Size & 0xFFFF) ;
        Header->Packet.OptionFlags = ((USHORT)MessageFlags &
                                      (TRACE_MESSAGE_SEQUENCE |
                                      TRACE_MESSAGE_GUID |
                                      TRACE_MESSAGE_COMPONENTID |
                                      TRACE_MESSAGE_TIMESTAMP |
                                      TRACE_MESSAGE_PERFORMANCE_TIMESTAMP |
                                      TRACE_MESSAGE_SYSTEMINFO)) &
                                      TRACE_MESSAGE_FLAG_MASK ;
        // Message Number
        Header->Packet.MessageNumber =  MessageNumber ;

        //
        // Now add in the header options we counted.
        //
        pMessageData = &(((PMESSAGE_TRACE)Header)->Data);


        //
        // Note that the order in which these are added is critical New entries must
        // be added at the end!
        //
        // [First Entry] Sequence Number
        if (MessageFlags&TRACE_MESSAGE_SEQUENCE) {
            RtlCopyMemory(pMessageData, &SequenceNumber, sizeof(ULONG)) ;
            pMessageData += sizeof(ULONG) ;
        }

        // [Second Entry] GUID ? or CompnentID ?
        if (MessageFlags&TRACE_MESSAGE_COMPONENTID) {
            RtlCopyMemory(pMessageData,MessageGuid,sizeof(ULONG)) ;
            pMessageData += sizeof(ULONG) ;
        } else if (MessageFlags&TRACE_MESSAGE_GUID) { // Can't have both
            RtlCopyMemory(pMessageData,MessageGuid,sizeof(GUID));
            pMessageData += sizeof(GUID) ;
        }

        // [Third Entry] Timestamp?
        if (MessageFlags&TRACE_MESSAGE_TIMESTAMP) {
            LARGE_INTEGER Perfcount ;
            if (MessageFlags&TRACE_MESSAGE_PERFORMANCE_TIMESTAMP) {
                LARGE_INTEGER Frequency ;
                NTSTATUS Status ;
                Status = NtQueryPerformanceCounter(&Perfcount, &Frequency);
            } else {
                Perfcount.QuadPart = WmipGetSystemTime();
            };
            RtlCopyMemory(pMessageData,&Perfcount,sizeof(LARGE_INTEGER));
            pMessageData += sizeof(LARGE_INTEGER);
        }


        // [Fourth Entry] System Information?
        if (MessageFlags&TRACE_MESSAGE_SYSTEMINFO) {
            PCLIENT_ID Cid;
            ULONG Id;     // match with NTOS version

            Cid = &NtCurrentTeb()->ClientId;
            *((PULONG)pMessageData) = HandleToUlong(Cid->UniqueThread);
            pMessageData += sizeof(ULONG) ;
            *((PULONG)pMessageData) = HandleToUlong(Cid->UniqueProcess);
            pMessageData += sizeof(ULONG) ;
        }

        //
        // Add New Header Entries immediately before this comment!
        //

        //
        // Now Copy in the Data.
        //
        { // Allocation Block
            va_list ap;
            PCHAR source;
            ap = MessageArgList ;
            while ((source = va_arg (ap, PVOID)) != NULL) {
                size_t elemBytes;
                elemBytes = va_arg (ap, size_t);
                RtlCopyMemory (pMessageData, source, elemBytes);
                pMessageData += elemBytes;
            }
        } // Allocation Block

        //
        // Buffer Complete, Release
        //
        WmipReleaseTraceBuffer( BufferResource );
        WmipUnlockLogger();
        //
        // Return Success
        //
        return (STATUS_SUCCESS);

    } except  (EXCEPTION_EXECUTE_HANDLER) {
        if (BufferResource != NULL) {
               WmipReleaseTraceBuffer ( BufferResource );   // also unlocks the logger
        }
        WmipUnlockLogger();
        return GetExceptionCode();
    }
}

PWMI_BUFFER_HEADER
FASTCALL
WmipGetFullFreeBuffer(
    VOID
    )
{

    PWMI_BUFFER_HEADER Buffer;

    PWMI_LOGGER_CONTEXT LoggerContext = WmipLoggerContext;

    WmipEnterUMCritSection();
 
    Buffer = WmipGetFreeBuffer(LoggerContext);

    if(Buffer) {
        
        InterlockedIncrement(&Buffer->ReferenceCount);

    } else {

        LoggerContext->EventsLost ++;
    }
    
    WmipLeaveUMCritSection();

    return Buffer;
}


ULONG
WmipReleaseFullBuffer(
    IN PWMI_BUFFER_HEADER Buffer
    )
{
    
    PWMI_LOGGER_CONTEXT LoggerContext = WmipLoggerContext;
    ULONG CircularBufferOnly = FALSE;


    if(!Buffer) return STATUS_UNSUCCESSFUL;

    if ( (LoggerContext->LogFileMode & EVENT_TRACE_BUFFERING_MODE) &&
         (LoggerContext->BufferAgeLimit.QuadPart == 0) &&
         (LoggerContext->LogFileHandle == NULL) ) {
        CircularBufferOnly = TRUE;
    }

    WmipEnterUMCritSection();

    Buffer->SavedOffset = Buffer->CurrentOffset;
    Buffer->Flags = BUFFER_STATE_FULL;
    Buffer->CurrentOffset = WmipGetCurrentThreadId();

    InterlockedDecrement(&Buffer->ReferenceCount);

    if (CircularBufferOnly) {
        InsertTailList(&LoggerContext->FreeList, &Buffer->Entry);
    }
    else {
        InsertTailList(&LoggerContext->FlushList, &Buffer->Entry);
    }

    WmipLeaveUMCritSection();

    return ERROR_SUCCESS;
}

PWMI_BUFFER_HEADER
FASTCALL
WmipSwitchFullBuffer(
    IN PWMI_BUFFER_HEADER OldBuffer
    )
{
    PWMI_BUFFER_HEADER Buffer;
    PWMI_LOGGER_CONTEXT LoggerContext = WmipLoggerContext;
    ULONG CircularBufferOnly = FALSE;

    if ( (LoggerContext->LogFileMode & EVENT_TRACE_BUFFERING_MODE) &&
         (LoggerContext->BufferAgeLimit.QuadPart == 0) &&
         (LoggerContext->LogFileHandle == NULL) ) {
        CircularBufferOnly = TRUE;
    }

    WmipEnterUMCritSection();

    Buffer = WmipGetFullFreeBuffer();

    OldBuffer->SavedOffset = OldBuffer->CurrentOffset;
    OldBuffer->Flags = BUFFER_STATE_FULL;
    OldBuffer->CurrentOffset = WmipGetCurrentThreadId();

    if (CircularBufferOnly) {
        InsertTailList(&LoggerContext->FreeList, &OldBuffer->Entry);
    }
    else {
        InsertTailList(&LoggerContext->FlushList, &OldBuffer->Entry);
    }
    WmipLeaveUMCritSection();

    if (!CircularBufferOnly) {
        NtReleaseSemaphore(LoggerContext->Semaphore, 1, NULL);
    }
    
    return Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\ntdll\wmiump.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    wmiump.h

Abstract:

    Private headers for WMI user mode

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#define _WMI_SOURCE_

//
// Define this to track reference counts
//#define TRACK_REFERNECES

//
// Define this to get extra checks on heap validation
//#define HEAPVALIDATION

//
// Define this to get a trace of critical section
//#define CRITSECTTRACE

//
// Define this to compile WMI to run as a service under NT
#define RUN_AS_SERVICE

//
// Define this to include WMI user mode functionality. Note that if you enable
// this then you also need to fix the files: wmi\dll\sources and wmi\makefil0.
//#define WMI_USER_MODE

//
// Define this to track memory leaks
//#define TRACK_MEMORY_LEAKS

#ifndef MEMPHIS
#define UNICODE
#define _UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <ole2.h>
#include <tchar.h>
#include <stdio.h>

#ifndef MEMPHIS
#include "svcs.h"
#endif

#include <netevent.h>

#ifdef MEMPHIS
//
// CONSIDER: Is there a better place to get this stuff on MEMPHIS
//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//


#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

typedef LONG NTSTATUS;
typedef NTSTATUS (*PUSER_THREAD_START_ROUTINE)(
    PVOID ThreadParameter
    );


#include <stdio.h>
#endif

#include "wmium.h"
#include "wmiumkm.h"
#include "ntwmi.h"
#include "wmiguid.h"

#if DBG
#define WmipAssert(x) if (! (x) ) { \
    BOOLEAN OldLoggingEnabled = WmipLoggingEnabled; \
    WmipLoggingEnabled = TRUE; \
    WmipDbgPrint(("WMI Assertion: "#x" at %s %d\n", __FILE__, __LINE__)); \
    WmipLoggingEnabled = OldLoggingEnabled; \
    DbgBreakPoint(); }
#else
#define WmipAssert(x)
#endif

#if DBG
extern BOOLEAN WmipLoggingEnabled;
#ifdef MEMPHIS
void __cdecl DebugOut(char *Format, ...);
#define WmipDebugPrint(_x_) { if (WmipLoggingEnabled) DebugOut _x_; }
#define WmipDbgPrint(_x_) { if (WmipLoggingEnabled) DebugOut _x_; }
#else
#define WmipDebugPrint(_x_) { if (WmipLoggingEnabled) DbgPrint _x_; }
#define WmipDbgPrint(_x_) { if (WmipLoggingEnabled) DbgPrint _x_; }
#endif
#else
#define WmipDebugPrint(_x_)
#define WmipDbgPrint(_x_)
#endif

#define NULL_GUID  {0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

//
// Registry based config options. Only available on checked builds
//
#define WmiRegKeyText TEXT("SYSTEM\\CurrentControlSet\\Control\\WMI")
#define PumpTimeoutRegValueText TEXT("NotificationPumpTimeout")
#define LoggingEnableValueText TEXT("LoggingEnabled")





//
// WMI RPC related definitions
typedef struct
{
    WNODE_HEADER WnodeHeader;
    BYTE Data[1];
} WNODE_INTERNAL, *PWNODE_INTERNAL;

#define INTERNAL_PROVIDER_ID 1

//
// Size of initial buffer used to read notifications from kernel mode
#define STARTNOTIFICATIONBUFFERSIZE 4096

#ifdef MEMPHIS
#define WmiRpcProtocolSequence TEXT("ncalrpc")

#define WmiServiceRpcProtocolSequence TEXT("ncalrpc")
#define WmiServiceRpcEndpoint TEXT("WmiRpcEndpoint")
#else
//#define WmiRpcProtocolSequence TEXT("ncalrpc")
//#define WmiRpcEndpointPrefix TEXT("NT")

#define WmiRpcProtocolSequence TEXT("ncacn_np")
#define WmiRpcEndpointPrefix TEXT("\\pipe\\")

#define WmiServiceRpcProtocolSequence TEXT("ncacn_np")
#define WmiServiceRpcEndpoint SVCS_RPC_PIPE
#endif

#define MinRpcCalls 1
#define MaxRpcCalls RPC_C_PROTSEQ_MAX_REQS_DEFAULT

//
// Time to wait between retrying an RPC call that was too busy to complete
#define RPC_BUSY_WAIT_TIMER   500

//
// Number of times to retry an RPC call that was too busy to complete
#define RPC_BUSY_WAIT_RETRIES 5

//
// WMI RPC interface principle name
#define WMI_RPC_PRINC_NAME TEXT("WMI_RPC_PRINC_NAME")

//
// This macro will break CountedString into a pointer to the actual string
// and the actual length of the string excluding any trailing nul characters
#define WmipBreakCountedString(CountedString, CountedStringLen) { \
    CountedStringLen = *CountedString++; \
    if (CountedString[(CountedStringLen-sizeof(WCHAR))/sizeof(WCHAR)] == UNICODE_NULL) \
    { \
        CountedStringLen -= sizeof(WCHAR); \
    } \
}


typedef struct
{
    HANDLE GuidHandle;
    PVOID DeliveryInfo;
    ULONG_PTR DeliveryContext;
    ULONG Flags;
} NOTIFYEE, *PNOTIFYEE;

#define STATIC_NOTIFYEE_COUNT 2

typedef struct
{
    LIST_ENTRY GNList;
    GUID Guid;
    ULONG RefCount;	
    ULONG NotifyeeCount;
    PNOTIFYEE Notifyee;
    NOTIFYEE StaticNotifyee[STATIC_NOTIFYEE_COUNT];
} GUIDNOTIFICATION, *PGUIDNOTIFICATION;

#define WmipAllocGNEntry() (PGUIDNOTIFICATION)WmipAlloc(sizeof(GUIDNOTIFICATION))
#define WmipFreeGNEntry(GNEntry) WmipFree(GNEntry)
#define WmipReferenceGNEntry(GNEntry) InterlockedIncrement(&GNEntry->RefCount);


//
// Notification Cookie data structures
#if DBG
#define NOTIFYCOOKIESPERCHUNK 2
#else
#define NOTIFYCOOKIESPERCHUNK 128
#endif

typedef struct
{
    PVOID DeliveryContext;
    PVOID DeliveryInfo;
    GUID Guid;
    BOOLEAN InUse;
} NOTIFYCOOKIE, *PNOTIFYCOOKIE;

typedef struct
{
    LIST_ENTRY Next;                         // Next cookie chunk
    ULONG BaseSlot;                          // Index of first slot number
    USHORT FreeSlot;                         // Index to a free cookie
    BOOLEAN Full;                            // TRUE if this chunk is full
    NOTIFYCOOKIE Cookies[NOTIFYCOOKIESPERCHUNK];
} NOTIFYCOOKIECHUNK, *PNOTIFYCOOKIECHUNK;

//
// Useful macro to establish a WNODE_HEADER quickly
#ifdef _WIN64

#define WmipBuildWnodeHeader(Wnode, WnodeSize, FlagsUlong, Handle) { \
    (Wnode)->Flags = FlagsUlong;                           \
    (Wnode)->KernelHandle = Handle;                \
    (Wnode)->BufferSize = WnodeSize;                 \
    (Wnode)->Linkage = 0;                 \
}

#else

#define WmipBuildWnodeHeader(Wnode, WnodeSize, FlagsUlong, Handle) { \
    (Wnode)->Flags = FlagsUlong;                           \
    *((PULONG64)(&((Wnode)->TimeStamp))) = (ULONG64)(IntToPtr(PtrToInt(Handle))); \
    (Wnode)->BufferSize = WnodeSize;                 \
    (Wnode)->Linkage = 0;                 \
}

#endif

#ifdef MEMPHIS
extern HANDLE PMMutex;
#define WmipEnterPMCritSection() WaitForSingleObject(PMMutex, INFINITE)

#define WmipLeavePMCritSection() ReleaseMutex(PMMutex)

#else
extern RTL_CRITICAL_SECTION PMCritSect;
#if DBG
#define WmipEnterPMCritSection() \
                WmipAssert(NT_SUCCESS(RtlEnterCriticalSection(&PMCritSect)));
#define WmipLeavePMCritSection() { \
     WmipAssert(PMCritSect.LockCount >= 0); \
     WmipAssert(NT_SUCCESS(RtlLeaveCriticalSection(&PMCritSect))); }
#else
#define WmipEnterPMCritSection() RtlEnterCriticalSection(&PMCritSect)
#define WmipLeavePMCritSection() RtlLeaveCriticalSection(&PMCritSect)
#endif // DBG
#endif // MEMPHIS


typedef struct
{
    NOTIFICATIONCALLBACK Callback;
    ULONG_PTR Context;
    PWNODE_HEADER Wnode;
    BYTE WnodeBuffer[1];
} NOTIFDELIVERYCTX, *PNOTIFDELIVERYCTX;


// from handle.c

#define WmipVerifyToken() \
{ \
    ULONG VerifyStatus; \
    VerifyStatus = WmipCheckImpersonationTokenType(); \
    if (VerifyStatus != ERROR_SUCCESS) \
	{ \
		WmipSetLastError(VerifyStatus); \
		return(VerifyStatus); \
	} \
}

ULONG WmipCheckImpersonationTokenType(
    void
    );

ULONG WmipCopyStringToCountedUnicode(
    LPCWSTR String,
    PWCHAR CountedString,
    ULONG *BytesUsed,
    BOOLEAN ConvertFromAnsi
    );

ULONG WmipCountedAnsiToCountedUnicode(
    PCHAR Ansi,
    PWCHAR Unicode
    );

ULONG WmipCountedUnicodeToCountedAnsi(
    PWCHAR Unicode,
    PCHAR Ansi
    );

#ifndef MEMPHIS
ULONG WmipCheckGuidAccess(
    LPGUID Guid,
    ACCESS_MASK DesiredAccess
    );

ULONG WmipOpenKernelGuid(
    LPGUID Guid,
    ACCESS_MASK DesiredAccess,
    PHANDLE Handle,
    ULONG Ioctl
    );
#endif

ULONG WmipAllocateCookie(
    PVOID DeliveryInfo,
    PVOID DeliveryContext,
    LPGUID Guid
    );

BOOLEAN WmipLookupCookie(
    ULONG CookieSlot,
    LPGUID Guid,
    PVOID *DeliveryInfo,
    PVOID *DeliveryContext
    );

void WmipGetGuidInCookie(
    ULONG CookieSlot,
    LPGUID Guid
    );

void WmipFreeCookie(
    ULONG CookieSlot
    );

PGUIDNOTIFICATION
WmipFindGuidNotification(
    LPGUID Guid
    );

ULONG
WmipAddToGNList(
    LPGUID Guid,
    PVOID DeliveryInfo,
    ULONG_PTR DeliveryContext,
    ULONG Flags,
    HANDLE GuidHandle
    );

ULONG
WmipRemoveFromGNList(
    LPGUID Guid,
    PVOID DeliveryInfo,
    BOOLEAN ActuallyRemove
    );

void
WmipDereferenceGNEntry(
    PGUIDNOTIFICATION GNEntry
    );

PTCHAR GuidToString(
    PTCHAR s,
    LPGUID piid
    );

PCHAR GuidToStringA(
    PCHAR s,
    LPGUID piid
    );


// from request.c
ULONG WmipSendWmiRequest(
    ULONG ActionCode,
    PWNODE_HEADER Wnode,
    ULONG WnodeSize,
    PVOID OutBuffer,
    ULONG MaxBufferSize,
    ULONG *RetSize
    );

ULONG WmipSendWmiKMRequest(
    HANDLE Handle,
    ULONG Ioctl,
    PVOID InBuffer,
    ULONG InBufferSize,
    PVOID OutBuffer,
    ULONG MaxBufferSize,
    ULONG *ReturnSize,
    LPOVERLAPPED Overlapped
    );

ULONG WmipConvertWADToAnsi(
    PWNODE_ALL_DATA Wnode
    );

ULONG WmipConvertWADToUnicode(
    PWNODE_ALL_DATA WnodeAllData,
    ULONG *BufferSize
    );

/*ULONG WmipQueryPidEntry(
    IN  GUID Guid,
    IN  ULONG Pid,
    OUT BOOLEAN *PidEntry
   );*/

ULONG WmipRegisterGuids(
    IN LPGUID MasterGuid,
    IN ULONG RegistrationCookie,    
    IN PWMIREGINFOW RegInfo,
    IN ULONG GuidCount,
    OUT PTRACEGUIDMAP *GuidMapHandle,
    OUT ULONG64 *LoggerContext,
    OUT HANDLE *RegistrationHandle
    );

//
// from intrnldp.c
ULONG WmipInternalProvider(
    ULONG ActionCode,
    PWNODE_HEADER Wnode,
    ULONG MaxWnodeSize,
    PVOID OutBuffer,
    ULONG *RetSize
   );

ULONG
WmipEnumRegGuids(
    PWMIGUIDLISTINFO *pGuidInfo
    );

//
// from dcapi.c
ULONG
WmipNotificationRegistration(
    IN LPGUID InGuid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG64 LoggerContext,
    IN ULONG Flags,
    IN BOOLEAN IsAnsi
    );


//
// from mofapi.c
//
void WmipProcessLanguageAddRemoveEvent(
    IN PWNODE_SINGLE_INSTANCE WnodeSI,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    );

void WmipProcessMofAddRemoveEvent(
    IN PWNODE_SINGLE_INSTANCE WnodeSI,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    );


//
// from notify.c
extern ULONG WmipNotificationSinkIndex;
#ifndef MEMPHIS

ULONG WmipProcessUMRequest(
    PWMI_LOGGER_INFORMATION LoggerInfo,
    PVOID DeliveryContext,
    ULONG ReplyIndex
    );

#endif

ULONG WmipAddHandleToEventPump(
    LPGUID Guid,
    PVOID DeliveryInfo,
    ULONG_PTR DeliveryContext,
    ULONG NotificationFlags,
    HANDLE GuidHandle
    );

void WmipMakeEventCallbacks(
    IN PWNODE_HEADER Wnode,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    );


ULONG
WmipReceiveNotifications(
    IN ULONG HandleCount,
    IN HANDLE *HandleList,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi,
    IN ULONG Action,
    IN PUSER_THREAD_START_ROUTINE UserModeCallback,
    IN HANDLE ProcessHandle
    );

ULONG WmipEventPump(
    PVOID Param
    );

//
// from main.c
VOID
WmipCreateHeap(
    VOID
    );

#ifndef IsEqualGUID
#define IsEqualGUID(guid1, guid2) \
                (!memcmp((guid1), (guid2), sizeof(GUID)))
#endif


//
// These define the dll and mof resource name for all of the builtin mof
// resources
#define WMICOREDLLNAME L"wmicore.dll"
#define WMICOREMOFRESOURCENAME L"MofResource"


//
// This defines the registry key under which security descriptors associated
// with the guids are stored.
#ifndef MEMPHIS
#define WMISECURITYREGISTRYKEY TEXT("System\\CurrentControlSet\\Control\\Wmi\\Security")
#endif


//
// This defines the initial value of the buffer passed to each data provider
// to retrieve the registration information
#if DBG
#define INITIALREGINFOSIZE sizeof(WNODE_TOO_SMALL)
#else
#define INITIALREGINFOSIZE 8192
#endif


//
// Chunk Management definitions
// All structures that rely upon the chunk allocator must be defined so that
// their members match that of ENTRYHEADER. These include DATASOURCE,
// GUIDENTRY, INSTANCESET, DCENTRY, NOTIFICATIONENTRY, MOFCLASS, MOFRESOURCE
// Also ENTRYHEADER reserves 0x80000000 for its own flag.

struct _CHUNKINFO;
struct _ENTRYHEADER;

typedef void (*ENTRYCLEANUP)(
    struct _CHUNKINFO *,
    struct _ENTRYHEADER *
    );

typedef struct _CHUNKINFO
{
    LIST_ENTRY ChunkHead;        // Head of list of chunks
    ULONG EntrySize;            // Size of a single entry
    ULONG EntriesPerChunk;        // Number of entries per chunk allocation
    ENTRYCLEANUP EntryCleanup;   // Entry cleanup routine
    ULONG InitialFlags;         // Initial flags for all entries
    ULONG Signature;
#if DBG
    ULONG AllocCount;
    ULONG FreeCount;
#endif
} CHUNKINFO, *PCHUNKINFO;

typedef struct
{
    LIST_ENTRY ChunkList;        // Node in list of chunks
    LIST_ENTRY FreeEntryHead;    // Head of list of free entries in chunk
    ULONG EntriesInUse;            // Count of entries being used
} CHUNKHEADER, *PCHUNKHEADER;

typedef struct _ENTRYHEADER
{
    union
    {
        LIST_ENTRY FreeEntryList;    // Node in list of free entries
        LIST_ENTRY InUseEntryList;   // Node in list ofin use entries
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;                // Flags
    ULONG RefCount;                 // Reference Count
    ULONG Signature;
} ENTRYHEADER, *PENTRYHEADER;

                                // Set if the entry is free
#define FLAG_ENTRY_ON_FREE_LIST       0x80000000
#define FLAG_ENTRY_ON_INUSE_LIST      0x40000000
#define FLAG_ENTRY_INVALID            0x20000000
#define FLAG_ENTRY_REMOVE_LIST        0x10000000


#define WmipReferenceEntry(Entry) \
    InterlockedIncrement(&((PENTRYHEADER)(Entry))->RefCount)

// chunk.c
#ifndef MEMPHIS
ULONG WmipBuildGuidObjectAttributes(
    IN LPGUID Guid,
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PUNICODE_STRING GuidString,
    OUT PWCHAR GuidObjectName
    );
#endif

ULONG WmipUnreferenceEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry);

PENTRYHEADER WmipAllocEntry(
    PCHUNKINFO ChunkInfo
    );

void WmipFreeEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

//
// This is the guid that denotes non event notifications. WMICore
// automatically registers anyone opening a guid to
extern GUID RegChangeNotificationGuid;

extern CHUNKINFO DSChunkInfo;
extern CHUNKINFO GEChunkInfo;
extern CHUNKINFO ISChunkInfo;
extern CHUNKINFO DCChunkInfo;
extern CHUNKINFO NEChunkInfo;
extern CHUNKINFO MRChunkInfo;

struct tagGUIDENTRY;
typedef struct tagGUIDENTRY GUIDENTRY, *PGUIDENTRY, *PBGUIDENTRY;

struct tagDATASOURCE;


//
// An INSTANCESET contains the information a set of instances that is provided
// by a single data source. An instance set is part of two lists. One list is
// the set of instance sets for a particular guid. The other list is the list
// of instance sets supported by a data source.
//

//
// Instance names for an instance set registered with a base name and count
// are stored in a ISBASENAME structure. This structure is tracked by
// PDFISBASENAME in wmicore.idl.
typedef struct
{
    ULONG BaseIndex;            // First index to append to base name
    WCHAR BaseName[1];            // Actual base name
} ISBASENAME, *PISBASENAME, *PBISBASENAME;

//
// This defines the maximum number of characters that can be part of a suffix
// to a basename. The current value of 6 will allow up to 999999 instances
// of a guid with a static base name
#define MAXBASENAMESUFFIXSIZE    6

//
// Instance names for an instance set registerd with a set of static names
// are kept in a ISSTATICNAMES structure. This structure is tracked by
// PDFISSTATICNAMES defined in wmicore.idl
typedef struct
{
    PWCHAR StaticNamePtr[1];     // pointers to static names
//    WCHAR StaticNames[1];
} ISSTATICENAMES, *PISSTATICNAMES, *PBISSTATICNAMES;

typedef struct tagInstanceSet
{
    union
    {
        // Entry in list of instances within a guid
        LIST_ENTRY GuidISList;

        // Entry in main list of free instances
        LIST_ENTRY FreeISList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    // Reference count of number of guids using this instance set
    ULONG RefCount;

    // Signature to identify entry
    ULONG Signature;

    // Entry in list of instances within a data source
    LIST_ENTRY DSISList;

    // Back link to guid that this instance set is a member
    PBGUIDENTRY GuidEntry;

    // Back link to data source that this instance set is a member
    struct tagDATASOURCE *DataSource;

    // Count of instances in instance set
    ULONG Count;

    //
    // If IS_INSTANCE_BASENAME is set then IsBaseName pointe at instance base
    // name structure. Else if IS_INSTANCE_STATICNAME is set then
    // IsStaticNames points to static instance name list. If
    union
    {
        PBISBASENAME IsBaseName;
        PBISSTATICNAMES IsStaticNames;
    };

} INSTANCESET, *PINSTANCESET, *PBINSTANCESET;

#define IS_SIGNATURE 'nalA'

//
// Guid Map Entry List maintains the list of Guid and their maps.
// Only those Guids that are Unregistered while a logger session is in
// progress is kept in this list.
// It is also used as a placeholder for InstanceIds. Trace Guid Registration
// calls return a handle to a GUIDMAPENTRY which maintains the map and the
// Instance Ids.
//

typedef struct tagTRACE_REG_INFO
{
    ULONG       RegistrationCookie;
    HANDLE      InProgressEvent; // Registration is in Progress Event
    BOOLEAN     EnabledState;    // Indicates if this GUID is Enabled or not.
    PVOID       NotifyRoutine;
    PVOID       TraceCtxHandle;
} TRACE_REG_INFO, *PTRACE_REG_INFO;

typedef struct
{
    LIST_ENTRY      Entry;
    TRACEGUIDMAP    GuidMap;
    ULONG           InstanceId;
    ULONG64         LoggerContext;
    PTRACE_REG_INFO pControlGuidData;
} GUIDMAPENTRY, *PGUIDMAPENTRY;


#define IS_INSTANCE_BASENAME        0x00000001
#define IS_INSTANCE_STATICNAMES     0x00000002
#define IS_EXPENSIVE                0x00000004    // set if collection must be enabled
#define IS_COLLECTING               0x00000008    // set when collecting

#define IS_KM_PROVIDER              0x00000080    // KM data provider
#define IS_SM_PROVIDER              0x00000100    // Shared memory provider
#define IS_UM_PROVIDER              0x00000200    // User mode provider
#define IS_NEWLY_REGISTERED         0x00000800    // set if IS is registering

//
// Any traced guids are used for trace logging and not querying
#define IS_TRACED                   0x00001000

// Set when events are enabled for instance set
#define IS_ENABLE_EVENT             0x00002000

// Set when events are enabled for instance set
#define IS_ENABLE_COLLECTION        0x00004000

// Set if guid is used only for firing events and not querying
#define IS_EVENT_ONLY               0x00008000

// Set if data provider for instance set is expecting ansi instsance names
#define IS_ANSI_INSTANCENAMES       0x00010000

// Set if instance names are originated from a PDO
#define IS_PDO_INSTANCENAME         0x00020000

// If set the data provider for the InstanceSet is internal to wmi.dll
#define IS_INTERNAL_PROVIDER        0x00040000

// Set if a Traced Guid is also a Trace Control Guid
#define IS_CONTROL_GUID             0x00080000

#define IS_ON_FREE_LIST             0x80000000

typedef struct tagGUIDENTRY
{
    union
    {
        // Entry in list of all guids registered with WMI
        LIST_ENTRY MainGEList;

        // Entry in list of free guid entry blocks
        LIST_ENTRY FreeGEList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    // Count of number of data sources using this guid
    ULONG RefCount;

    // Signature to identify entry
    ULONG Signature;

    // Count of InstanceSets headed by this guid
    ULONG ISCount;

    // Head of list of all instances for guid
    LIST_ENTRY ISHead;

    // Guid that represents data block
    GUID Guid;

} GUIDENTRY, *PGUIDENTRY, *PBGUIDENTRY;

#define GE_SIGNATURE 'diuG'

#define GE_ON_FREE_LIST        0x80000000

//
// When set this guid is an internally defined guid that has no data source
// attached to it.
#define GE_FLAG_INTERNAL    0x00000001



typedef struct
{
    union
    {
        // Entry in list of all DS
        LIST_ENTRY MainMRList;

        // Entry in list of free DS
        LIST_ENTRY FreeMRList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    ULONG RefCount;

    // Signature to identify entry
    ULONG Signature;

    PWCHAR MofImagePath;           // Path to image file with resource
    PWCHAR MofResourceName;        // Name of resource containing mof data
#ifdef WMI_USER_MODE
    LIST_ENTRY MRMCHead;
#endif

} MOFRESOURCE, *PMOFRESOURCE;

#define MR_SIGNATURE 'yhsA'


#if DBG
#define AVGMOFRESOURCECOUNT 1
#else
#define AVGMOFRESOURCECOUNT 4
#endif

typedef struct tagDATASOURCE
{
    union
    {
        // Entry in list of all DS
        LIST_ENTRY MainDSList;

        // Entry in list of free DS
        LIST_ENTRY FreeDSList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    ULONG RefCount;

    ULONG Signature;

    // Head of list of instances for this DS
    LIST_ENTRY ISHead;

    // Binding string and callback address for DS rpc server
    PTCHAR BindingString;
    RPC_BINDING_HANDLE RpcBindingHandle;
    ULONG RequestAddress;
    ULONG RequestContext;

    // Provider id of kernel mode driver
    ULONG_PTR ProviderId;

    // Path to registry holding ACLs
    PTCHAR RegistryPath;

    // Head of list of MofResources attached to data source
    ULONG MofResourceCount;
    PMOFRESOURCE *MofResources;
    PMOFRESOURCE StaticMofResources[AVGMOFRESOURCECOUNT];
};

#define DS_SIGNATURE ' naD'

#define VERIFY_DPCTXHANDLE(DsCtxHandle) \
    ( ((DsCtxHandle) == NULL) || \
      (((PBDATASOURCE)(DsCtxHandle))->Signature == DS_SIGNATURE) )
	
typedef struct tagDATASOURCE DATASOURCE, *PDATASOURCE, *PBDATASOURCE;

#define DS_ALLOW_ALL_ACCESS    0x00000001
#define DS_KERNEL_MODE         0x00000002

//
// Set in the Internal WMI data source
#define DS_INTERNAL            0x00000004

#define DS_ON_FREE_LIST        0x80000000


//
// A list of enabled notifications is maintained by the wmi service to mange
// delivering events and to know when to send enable and disable event
// wmi requests to the data providers. Each NOTIFICATIONENTRY has an array of
// DCREF which is a reference to the data consumer who is interested in the
// event.

#define RPCOUTSTANDINGCALLLIMIT 128

typedef struct
{
    LIST_ENTRY MainDCList;        // Node on global data consumer list
    PCHUNKHEADER Chunk;           // Chunk in which entry is located
    ULONG Flags;
    ULONG RefCount;

    ULONG Signature;
                                  // Actual RPC binding handle
    RPC_BINDING_HANDLE RpcBindingHandle;

    PUCHAR EventData;             // Buffer to hold events to be sent
    ULONG LastEventOffset;        // Offset in EventData to previous event
    ULONG NextEventOffset;        // Offset in EventData to write next event
    ULONG EventDataSizeLeft;      // Number of bytes left to use in EventData

    ULONG RpcCallsOutstanding;    // Number of rpc calls outstanding
#if DBG
    PTCHAR BindingString;         // Binding string for consumer
#endif
} DCENTRY, *PDCENTRY;

#define DC_SIGNATURE 'cirE'

// If the data consumer has had its context rundown routine then this flag
// is set. This indicates that the data consumer has gone away and no more
// events should be sent to him.
#define DC_FLAG_RUNDOWN        0x00000001

#define VERIFY_DCCTXHANDLE(DcCtxHandle) \
    ( ((DcCtxHandle) == NULL) || \
      (((PDCENTRY)(DcCtxHandle))->Signature == DC_SIGNATURE) )


typedef struct
{
    PDCENTRY DcEntry;     // points at data consumer interested in notification
                          // Number of times collect has been enabled by
                          // this DC.
    ULONG CollectRefCount;

                          // Number of times collect has been enabled by
                          // this DC.
    ULONG EventRefCount;

    ULONG Flags;         // Flags
    ULONG LostEventCount;
} DCREF, *PDCREF;

//
// _ENABLED flag set if DP already called to enable notification or collection
#define DCREF_FLAG_NOTIFICATION_ENABLED    0x00000001
#define DCREF_FLAG_COLLECTION_ENABLED      0x00000002

// if DCREF_FLAG_NO_EXTRA_THREAD set then WMI will not create a special thread
// to do the direct notification callback.
#define DCREF_FLAG_NO_EXTRA_THREAD        0x00000008

// If this flag is set then the notification callback is expecting an ANSI
// instance names.
#define DCREF_FLAG_ANSI                   0x00000010

// NOTE: Other notification flags in wmium.h are:
// NOTIFICATION_TRACE_FLAG 0x00010000
//
// NOTIFICATION_FLAG_CALLBACK_DIRECT is set when NotifyAddress specifies
// a direct callback address for delivering the event.
//
// NOTIFICATION_FLAG_CALLBACK_DIRECT is set when NotifyAddress specifies
// a direct callback address for delivering the event.
//
#define NOTIFICATION_FLAG_CALLBACK_DIRECT    0x00020000
#define NOTIFICATION_FLAG_CALLBACK_QUEUED    0x00040000
#define NOTIFICATION_FLAG_WINDOW             0x00080000
#define NOTIFICATION_FLAG_BATCHED            0x00100000

#define NOTIFICATION_FLAG_GROUPED_EVENT      0x00200000

//
// These are the flags contained in DcRef->Flags that pertain to Notifications
#define NOTIFICATION_MASK_EVENT_FLAGS  \
                                    (NOTIFICATION_FLAG_CALLBACK_DIRECT | \
                                     NOTIFICATION_FLAG_CALLBACK_QUEUED | \
                                     NOTIFICATION_FLAG_WINDOW | \
                                     DCREF_FLAG_NO_EXTRA_THREAD | \
                                     DCREF_FLAG_ANSI)


//
// This defines the number of DC references a NOTIFICATIONENTRY can have
// in a single entry

// CONSIDER: Merging NOTIFICATIONENTRY with GUIDENTRY
#define DCREFPERNOTIFICATION    16

typedef struct _notificationentry
{
    LIST_ENTRY MainNotificationList;    // Node in main notifications list
    PCHUNKHEADER Chunk;                 // Chunk in which entry is located
    ULONG Flags;                        // flags
    ULONG RefCount;

    // Signature to identify entry
    ULONG Signature;

    GUID Guid;                          // guid representing notification
                                        // If > DCREFPERNOTIFICATION DC have
                                        // enabled this event then this points
                                        // to another NOTIFICATIONENTRY which
                                        // has another DCREF array
    struct _notificationentry *Continuation;
    ULONG EventRefCount;                // Global count of event enables
    ULONG CollectRefCount;              // Global count of collection enables
    ULONG64 LoggerContext;              // Logger context handle
	    
    HANDLE CollectInProgress;           // Event set when all collect complete

    DCREF DcRef[DCREFPERNOTIFICATION];    // DC that have enabled this event
} NOTIFICATIONENTRY, *PNOTIFICATIONENTRY;

#define NE_SIGNATURE 'eluJ'

// Set when a notification request is being processed by the data providers
#define NE_FLAG_NOTIFICATION_IN_PROGRESS 0x00000001

// Set when a collection request is being processed by the data providers
#define NE_FLAG_COLLECTION_IN_PROGRESS 0x00000002

// Set when a trace disable is being processed by a worker thread
#define NE_FLAG_TRACEDISABLE_IN_PROGRESS 0x00000004

#ifdef WMI_USER_MODE
//
// Valid MOF data types for qualifiers and properties (data items)
typedef enum
{
    MOFInt32 = 0,                // 32bit integer
    MOFUInt32 = 1,               // 32bit unsigned integer
    MOFInt64 = 2,                // 64bit integer
    MOFUInt64 = 3,               // 32bit unsigned integer
    MOFInt16 = 4,                // 16bit integer
    MOFUInt16 = 5,               // 16bit unsigned integer
    MOFChar = 6,                 // 8bit integer
    MOFByte = 7,                 // 8bit unsigned integer
    MOFWChar = 8,                // Wide (16bit) character
    MOFDate = 9,                 // Date field
    MOFBoolean = 10,             // 8bit Boolean value
    MOFEmbedded = 11,            // Embedded class
    MOFString = 12,              // Counted String type
    MOFZTString = 13,            // NULL terminated unicode string
    MOFAnsiString = 14,          // NULL terminated ansi string
    MOFUnknown = 0xffffffff      // Data type is not known
} MOFDATATYPE, *PMOFDATATYPE;

// Data items that are of type MOFString are stored in the data block as a
// counted unicode string. The text of the string is always preceeded by
// a USHORT which contains the count of bytes following that composes the
// string. The string may be NULL terminated and in that case the count must
// include the null termination bytes.


// Data items that are of type MOFDate are fixed length Unicode strings and
// not preceeded by a count value. It is in the following fixed format:
//
//      yyyymmddhhmmss.mmmmmmsutc
//
// Where  yyyy is a 4 digit year, mm is the month, dd is the day,  hh  is
// the  hour  (24-hour clock), mm is the minute, ss is  the  second,  the
// mmmmmm is the number of microseconds (typically all zeros) and s is  a
//  "+"  or  "-" indicating the sign of the UTC (correction field, and  utc
// is  the  offset from UTC in minutes (using the sign indicated  by  s).
// For  example,  Wednesday, May 25, 1994, at 1:30:15  PM  EDT  would  be
// represented as:
//
//      19940525133015.0000000-300
//
// Values  MUST  be zero-padded so that the entire string is  always  the
// same 25-character length.  Fields which are not significant  MUST  be
// replaced  with asterisk characters.  Similarly,  intervals   use  the
// same  format, except   that   the  interpretation of the fields is based
// on elapsed time. For  example,  an  elapsed time of 1 day, 13 hours,
// 23 minutes, and 12 seconds  would  be:
//
//      00000001132312.000000+000
//
// A UTC offset of zero is always used for interval properties.

struct _MOFCLASSINFOW;
struct _MOFCLASSINFOA;

//
// Each class has one or more data items that are described by a MOFDATAITEM
// structure.
typedef struct
{
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
           Name;                    // Text name of data item
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
           Description;             // Text description of data item
    MOFDATATYPE DataType;           // MOF data type
    ULONG Version;                  // Version that this MOF is part of
    ULONG SizeInBytes;              // Size of data item in Blob
    ULONG Flags;                    // Flags, See MOFDI_FLAG_*
    GUID EmbeddedClassGuid;         // Guid of data item's embedded class
    ULONG FixedArrayElements;       // Number of elements in fixed sized array
                                    // Used when MOF_FLAG_FIXED_ARRAY is set

    ULONG VariableArraySizeId;      // MOF_FLAG_VARIABLE_ARRAY, Data id of
                                    // variable containing number of elements
                                    // in array

    PVOID VarArrayTempPtr;
    PVOID EcTempPtr;
    ULONG_PTR PropertyQualifierHandle;
    ULONG MethodId;
    LPWSTR HeaderName;// Name of structure in generated header
    struct _MOFCLASSINFOW *MethodClassInfo;
} MOFDATAITEMW, *PMOFDATAITEMW;

typedef struct
{
    LPSTR
           Name;                    // Text name of data item
    LPSTR
           Description;             // Text description of data item
    MOFDATATYPE DataType;           // MOF data type
    ULONG Version;                  // Version that this MOF is part of
    ULONG SizeInBytes;              // Size of data item in Blob
    ULONG Flags;                    // Flags, See MOFDI_FLAG_*
    GUID EmbeddedClassGuid;         // Guid of data item's embedded class
    ULONG FixedArrayElements;       // Number of elements in fixed sized array
                                    // Used when MOF_FLAG_FIXED_ARRAY is set

    ULONG VariableArraySizeId;      // MOF_FLAG_VARIABLE_ARRAY, Data id of
                                    // variable containing number of elements
                                    // in array
    PVOID VarArrayTempPtr;
    PVOID EcTempPtr;
    ULONG_PTR PropertyQualifierHandle;
    ULONG MethodId;
    LPSTR HeaderName;               // Name of structure in generated header
    struct _MOFCLASSINFOA *MethodClassInfo;
} MOFDATAITEMA, *PMOFDATAITEMA;

#ifdef UNICODE
typedef MOFDATAITEMW MOFDATAITEM;
typedef PMOFDATAITEMW PMOFDATAITEM;
#else
typedef MOFDATAITEMA MOFDATAITEM;
typedef PMOFDATAITEMA PMOFDATAITEM;
#endif


// Data item is actually a fixed sized array
#define MOFDI_FLAG_FIXED_ARRAY        0x00000001

// Data item is actually a variable length array
#define MOFDI_FLAG_VARIABLE_ARRAY     0x00000002

// Data item is actually an embedded class
#define MOFDI_FLAG_EMBEDDED_CLASS     0x00000004

// Data item is readable
#define MOFDI_FLAG_READABLE           0x00000008

// Data item is writable
#define MOFDI_FLAG_WRITEABLE          0x00000010

// Data item is an event
#define MOFDI_FLAG_EVENT              0x00000020

// Embedded class Guid is not set
#define MOFDI_FLAG_EC_GUID_NOT_SET    0x00000040

// Data item is really a method
#define MOFDI_FLAG_METHOD             0x00000080

// Data item is an input method parameter
#define MOFDI_FLAG_INPUT_METHOD       0x00000100

// Data item is an output method parameter
#define MOFDI_FLAG_OUTPUT_METHOD      0x00000200

//
// The MOFCLASSINFO structure describes the format of a data block
typedef struct _MOFCLASSINFOW
{
    GUID Guid;                    // Guid that represents class

#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
                      Name;       // Text name of class
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
                      Description;// Text description of class
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
                      HeaderName;// Name of structure in generated header
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
                      GuidName1;// Name of Guid in generated header
#ifdef MIDL_PASS
    [string] PDFWCHAR
#else
    LPWSTR
#endif
                      GuidName2;// Name of Guid in generated header
    USHORT Language;                // Language of MOF
    USHORT Reserved;
    ULONG Flags;                  // Flags, see MOFGI_FLAG_*
    ULONG Version;                // Version of Guid
    ULONG DataItemCount;          // Number of wmi data items (properties)
    ULONG MethodCount;            // Number of wmi data items (properties)
                                  // Array of Property info
#ifdef MIDL_PASS
    [size_is(DataItemCount)]
#endif
      MOFDATAITEMW *DataItems;
#ifndef MIDL_PASS
    UCHAR Tail[1];
#endif
} MOFCLASSINFOW, *PMOFCLASSINFOW;

typedef struct _MOFCLASSINFOA
{
    GUID Guid;                    // Guid that represents class

    LPSTR
                      Name;       // Text name of class
    LPSTR
                      Description;// Text description of class
    LPSTR
                      HeaderName;// Name of structure in generated header
    LPSTR
                      GuidName1;// Name of Guid in generated header
    LPSTR
                      GuidName2;// Name of Guid in generated header
    USHORT Language;                // Language of MOF
    USHORT Reserved;
    ULONG Flags;                  // Flags, see MOFGI_FLAG_*
    ULONG Version;                // Version of Guid
    ULONG DataItemCount;          // Number of wmi data items (properties)
    ULONG MethodCount;            // Number of wmi data items (properties)
                                  // Array of Property info
    MOFDATAITEMA *DataItems;
    UCHAR Tail[1];
} MOFCLASSINFOA, *PMOFCLASSINFOA;

#ifdef UNICODE
typedef MOFCLASSINFOW MOFCLASSINFO;
typedef PMOFCLASSINFOW PMOFCLASSINFO;
#else
typedef MOFCLASSINFOA MOFCLASSINFO;
typedef PMOFCLASSINFOA PMOFCLASSINFO;
#endif

// 0x00000001 to 0x00000004 are not available
#define MOFCI_FLAG_EVENT          0x10000000
#define MOFCI_FLAG_EMBEDDED_CLASS 0x20000000
#define MOFCI_FLAG_READONLY       0x40000000
#define MOFCI_FLAG_METHOD_PARAMS  0x80000000

typedef struct
{
    union
    {
        // Entry in list of all DS
        LIST_ENTRY MainMCList;

        // Entry in list of free DS
        LIST_ENTRY FreeMCList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    ULONG RefCount;

    PMOFCLASSINFOW MofClassInfo;   // Actual class info data

    LIST_ENTRY MCMRList;          // Entry in list of MCs in a MR

    LIST_ENTRY MCVersionList;     // Head or entry in list of MCs with
                                  // same guid, but possibly different versions

    ULONG_PTR ClassObjectHandle;      // CBMOFObj, BMOF class object ptr
    PMOFRESOURCE MofResource;     // Resource holding class info

} MOFCLASS, *PMOFCLASS;

// If this is set then the MOF class can never be replaced with a later version
#define MC_FLAG_NEVER_REPLACE 0x00000001

#endif

//
// AVGGUIDSPERDS defines a guess as to the number of guids that get registered
// by any data provider. It is used to allocate the buffer used to deliver
// registration change notifications.
#if DBG
#define AVGGUIDSPERDS    2
#else
#define AVGGUIDSPERDS    256
#endif


#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)(Base) + (Offset)))



//
// Guid and InstanceSet cache
#if DBG
#define PTRCACHEGROWSIZE 2
#else
#define PTRCACHEGROWSIZE 64
#endif

typedef struct
{
    LPGUID Guid;
    PBINSTANCESET InstanceSet;
} PTRCACHE;


//
// Registration data structures
//

#ifdef MEMPHIS

extern HANDLE SMMutex;
#define WmipEnterSMCritSection() WaitForSingleObject(SMMutex, INFINITE)

#define WmipLeaveSMCritSection() ReleaseMutex(SMMutex)

#else
extern RTL_CRITICAL_SECTION SMCritSect;
#if DBG
#ifdef CRITSECTTRACE
#define WmipEnterSMCritSection() { \
    WmipDebugPrint(("WMI: %d Enter SM Crit %s %d\n", GetCurrentThreadId(), __FILE__, __LINE__)); \
    RtlEnterCriticalSection(&SMCritSect); }

#define WmipLeaveSMCritSection() { \
    WmipDebugPrint(("WMI: %d Leave SM Crit %s %d\n", GetCurrentThreadId(), __FILE__, __LINE__)); \
    RtlLeaveCriticalSection(&SMCritSect); }
#else
#define WmipEnterSMCritSection() \
                WmipAssert(NT_SUCCESS(RtlEnterCriticalSection(&SMCritSect)));
#define WmipLeaveSMCritSection() { \
     WmipAssert(SMCritSect.LockCount >= 0); \
     WmipAssert(NT_SUCCESS(RtlLeaveCriticalSection(&SMCritSect))); }
#endif // CRITSECTTRACE

#else
#define WmipEnterSMCritSection() RtlEnterCriticalSection(&SMCritSect)
#define WmipLeaveSMCritSection() RtlLeaveCriticalSection(&SMCritSect)
#endif // DBG
#endif // MEMPHIS

#ifndef IsEqualGUID
#define IsEqualGUID(guid1, guid2) \
                (!memcmp((guid1), (guid2), sizeof(GUID)))
#endif


//
// WMI MOF result codes. Since they are never given to the caller they are
// defined in here
#define ERROR_WMIMOF_INCORRECT_DATA_TYPE -1               /* 0xffffffff */
#define ERROR_WMIMOF_NO_DATA -2                           /* 0xfffffffe */
#define ERROR_WMIMOF_NOT_FOUND -3                         /* 0xfffffffd */
#define ERROR_WMIMOF_UNUSED -4                            /* 0xfffffffc */
// Property %ws in class %ws has no embedded class name
#define ERROR_WMIMOF_NO_EMBEDDED_CLASS_NAME -5            /* 0xfffffffb */
// Property %ws in class %ws has an unknown data type
#define ERROR_WMIMOF_UNKNOWN_DATA_TYPE -6                 /* 0xfffffffa */
// Property %ws in class %ws has no syntax qualifier
#define ERROR_WMIMOF_NO_SYNTAX_QUALIFIER -7               /* 0xfffffff9 */
#define ERROR_WMIMOF_NO_CLASS_NAME -8                     /* 0xfffffff8 */
#define ERROR_WMIMOF_BAD_DATA_FORMAT -9                   /* 0xfffffff7 */
// Property %ws in class %ws has the same WmiDataId %d as property %ws
#define ERROR_WMIMOF_DUPLICATE_ID -10                     /* 0xfffffff6 */
// Property %ws in class %ws has a WmiDataId of %d which is out of range
#define ERROR_WMIMOF_BAD_DATAITEM_ID -11                  /* 0xfffffff5 */
#define ERROR_WMIMOF_MISSING_DATAITEM -12                 /* 0xfffffff4 */
// Property for WmiDataId %d is not defined in class %ws
#define ERROR_WMIMOF_DATAITEM_NOT_FOUND -13               /* 0xfffffff3 */
// Embedded class %ws not defined for Property %ws in Class %ws
#define ERROR_WMIMOF_EMBEDDED_CLASS_NOT_FOUND -14         /* 0xfffffff2 */
// Property %ws in class %ws has an incorrect [WmiVersion] qualifier
#define ERROR_WMIMOF_INCONSISTENT_VERSIONING -15          /* 0xfffffff1 */
#define ERROR_WMIMOF_NO_PROPERTY_QUALIFERS -16            /* 0xfffffff0 */
// Class %ws has a badly formed or missing [guid] qualifier
#define ERROR_WMIMOF_BAD_OR_MISSING_GUID -17              /* 0xffffffef */
// Could not find property %ws which is the array size for property %ws in class %ws
#define ERROR_WMIMOF_VL_ARRAY_SIZE_NOT_FOUND -18          /* 0xffffffee */
// A class could not be parsed properly
#define ERROR_WMIMOF_CLASS_NOT_PARSED -19                 /* 0xffffffed */
// Wmi class %ws requires the qualifiers [Dynamic, Provider("WmiProv")]
#define ERROR_WMIMOF_MISSING_HMOM_QUALIFIERS -20          /* 0xffffffec */
// Error accessing binary mof file %s
#define ERROR_WMIMOF_CANT_ACCESS_FILE -21                 /* 0xffffffeb */
// Property InstanceName in class %ws must be type string and not %ws
#define ERROR_WMIMOF_INSTANCENAME_BAD_TYPE -22            /* 0xffffffea */
// Property Active in class %ws must be type bool and not %ws
#define ERROR_WMIMOF_ACTIVE_BAD_TYPE -23                  /* 0xffffffe9 */
// Property %ws in class %ws does not have [WmiDataId()] qualifier
#define ERROR_WMIMOF_NO_WMIDATAID -24                     /* 0xffffffe8 */
// Property InstanceName in class %ws must have [key] qualifier
#define ERROR_WMIMOF_INSTANCENAME_NOT_KEY -25             /* 0xffffffe7 */
// Class %ws does not have an InstanceName qualifier
#define ERROR_WMIMOF_NO_INSTANCENAME -26                  /* 0xffffffe6 */
// Class %ws does not have an Active qualifier
#define ERROR_WMIMOF_NO_ACTIVE -27                        /* 0xffffffe5 */
// Property %ws in class %ws is an array, but doesn't specify a dimension
#define ERROR_WMIMOF_MUST_DIM_ARRAY -28                   /* 0xffffffe4 */
// The element count property %ws for the variable length array %ws in class %ws is not an integral type
#define ERROR_WMIMOF_BAD_VL_ARRAY_SIZE_TYPE -29           /* 0xdddddde4 */
// Property %ws in class %ws is both a fixed and variable length array
#define ERROR_WMIMOF_BOTH_FIXED_AND_VARIABLE_ARRAY -30    /* 0xffffffe3 */
// Embedded class %ws should not have InstaneName or Active properties
#define ERROR_WMIMOF_EMBEDDED_CLASS -31                   /* 0xffffffe2 */
#define ERROR_WMIMOF_IMPLEMENTED_REQUIRED -32             /* 0xffffffe1 */
//    TEXT("WmiMethodId for method %ws in class %ws must be unique")
#define ERROR_WMIMOF_DUPLICATE_METHODID -33             /* 0xffffffe0 */
//    TEXT("WmiMethodId for method %ws in class %ws must be specified")
#define ERROR_WMIMOF_MISSING_METHODID -34             /* 0xffffffdf */
//    TEXT("WmiMethodId for method %ws in class %ws must not be 0")
#define ERROR_WMIMOF_METHODID_ZERO -35             /* 0xffffffde */
//    TEXT("Class %ws is derived from WmiEvent and may not be [abstract]")
#define ERROR_WMIMOF_WMIEVENT_ABSTRACT -36             /* 0xffffffdd */


#define ERROR_WMIMOF_COUNT 36

// This file is not a valid binary mof file
// ERROR_WMI_INVALID_MOF

// There was not enough memory to complete an operation
// ERROR_NOT_ENOUGH_MEMORY

//
// Function prototypes for private functions

//
// sharemem.c
ULONG WmipEstablishSharedMemory(
    PBDATASOURCE DataSource,
    LPCTSTR SectionName,
    ULONG SectionSize
    );

//
// validate.c
BOOLEAN WmipValidateCountedString(
    WCHAR *String
    );

BOOLEAN WmipValidateGuid(
    LPGUID Guid
    );

BOOLEAN WmipProbeForRead(
    PUCHAR Buffer,
    ULONG BufferSize
    );

//
// alloc.c

extern LIST_ENTRY GEHead;
extern PLIST_ENTRY GEHeadPtr;
extern CHUNKINFO GEChunkInfo;

extern LIST_ENTRY NEHead;
extern PLIST_ENTRY NEHeadPtr;
extern CHUNKINFO NEChunkInfo;

extern LIST_ENTRY DSHead;
extern PLIST_ENTRY DSHeadPtr;
extern CHUNKINFO DSChunkInfo;

extern LIST_ENTRY DCHead;
extern PLIST_ENTRY DCHeadPtr;
extern CHUNKINFO DCChunkInfo;

extern LIST_ENTRY MRHead;
extern PLIST_ENTRY MRHeadPtr;
extern CHUNKINFO MRChunkInfo;

extern CHUNKINFO ISChunkInfo;

extern LIST_ENTRY GMHead;
extern PLIST_ENTRY GMHeadPtr;

#ifdef WMI_USER_MODE
extern LIST_ENTRY MCHead;
extern PLIST_ENTRY MCHeadPtr;
extern CHUNKINFO MCChunkInfo;
#endif

#ifdef TRACK_REFERNECES
#define WmipUnreferenceDS(DataSource) \
{ \
    WmipDebugPrint(("WMI: Unref DS %x at %s %d\n", DataSource, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&DSChunkInfo, (PENTRYHEADER)DataSource); \
}

#define WmipReferenceDS(DataSource) \
{ \
    WmipDebugPrint(("WMI: Ref DS %x at %s %d\n", DataSource, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)DataSource); \
}

#define WmipUnreferenceGE(GuidEntry) \
{ \
    WmipDebugPrint(("WMI: Unref GE %x at %s %d\n", GuidEntry, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&GEChunkInfo, (PENTRYHEADER)GuidEntry); \
}

#define WmipReferenceGE(GuidEntry) \
{ \
    WmipDebugPrint(("WMI: Ref GE %x at %s %d\n", GuidEntry, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)GuidEntry); \
}

#define WmipUnreferenceIS(InstanceSet) \
{ \
    WmipDebugPrint(("WMI: Unref IS %x at %s %d\n", InstanceSet, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&ISChunkInfo, (PENTRYHEADER)InstanceSet); \
}

#define WmipReferenceIS(InstanceSet) \
{ \
    WmipDebugPrint(("WMI: Ref IS %x at %s %d\n", InstanceSet, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)InstanceSet); \
}

#define WmipUnreferenceDC(DataConsumer) \
{ \
    WmipDebugPrint(("WMI: Unref DC %x at %s %d\n", DataConsumer, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&DCChunkInfo, (PENTRYHEADER)DataConsumer); \
}

#define WmipReferenceDC(DataConsumer) \
{ \
    WmipDebugPrint(("WMI: Ref DC %x at %s %d\n", DataConsumer, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)DataConsumer); \
}

#define WmipUnreferenceNE(NotificationEntry) \
{ \
    WmipDebugPrint(("WMI: Unref NE %x at %s %d\n", NotificationEntry, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&NEChunkInfo, (PENTRYHEADER)NotificationEntry); \
}

#define WmipReferenceNE(NotificationEntry) \
{ \
    WmipDebugPrint(("WMI: Ref NE %x at %s %d\n", NotificationEntry, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)NotificationEntry); \
}

#define WmipUnreferenceMR(MofResource) \
{ \
    WmipDebugPrint(("WMI: Unref MR %x at %s %d\n", MofResource, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&MRChunkInfo, (PENTRYHEADER)MofResource); \
}

#define WmipReferenceMR(MofResource) \
{ \
    WmipDebugPrint(("WMI: Ref MR %x at %s %d\n", MofResource, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)MofResource); \
}

#ifdef WMI_USER_MODE
#define WmipUnreferenceMC(MofClass) \
{ \
    WmipDebugPrint(("WMI: Unref MC %x at %s %d\n", MofClass, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&MCChunkInfo, (PENTRYHEADER)MofClass); \
}

#define WmipReferenceMC(MofClass) \
{ \
    WmipDebugPrint(("WMI: Ref MC %x at %s %d\n", MofClass, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)MofClass); \
}
#endif
#else
#define WmipUnreferenceDS(DataSource) \
    WmipUnreferenceEntry(&DSChunkInfo, (PENTRYHEADER)DataSource)

#define WmipReferenceDS(DataSource) \
    WmipReferenceEntry((PENTRYHEADER)DataSource)

#define WmipUnreferenceGE(GuidEntry) \
    WmipUnreferenceEntry(&GEChunkInfo, (PENTRYHEADER)GuidEntry)

#define WmipReferenceGE(GuidEntry) \
    WmipReferenceEntry((PENTRYHEADER)GuidEntry)

#define WmipUnreferenceIS(InstanceSet) \
    WmipUnreferenceEntry(&ISChunkInfo, (PENTRYHEADER)InstanceSet)

#define WmipReferenceIS(InstanceSet) \
    WmipReferenceEntry((PENTRYHEADER)InstanceSet)

#define WmipUnreferenceDC(DataConsumer) \
    WmipUnreferenceEntry(&DCChunkInfo, (PENTRYHEADER)DataConsumer)

#define WmipReferenceDC(DataConsumer) \
    WmipReferenceEntry((PENTRYHEADER)DataConsumer)

#define WmipUnreferenceNE(NotificationEntry) \
    WmipUnreferenceEntry(&NEChunkInfo, (PENTRYHEADER)NotificationEntry)

#define WmipReferenceNE(NotificationEntry) \
    WmipReferenceEntry((PENTRYHEADER)NotificationEntry)

#define WmipUnreferenceMR(MofResource) \
    WmipUnreferenceEntry(&MRChunkInfo, (PENTRYHEADER)MofResource)

#define WmipReferenceMR(MofResource) \
    WmipReferenceEntry((PENTRYHEADER)MofResource)

#ifdef WMI_USER_MODE
#define WmipUnreferenceMC(MofClass) \
    WmipUnreferenceEntry(&MCChunkInfo, (PENTRYHEADER)MofClass)

#define WmipReferenceMC(MofClass) \
    WmipReferenceEntry((PENTRYHEADER)MofClass)
#endif
#endif

PBDATASOURCE WmipAllocDataSource(
    void
    );

PBGUIDENTRY WmipAllocGuidEntry(
    void
    );

#define WmipAllocInstanceSet() ((PBINSTANCESET)WmipAllocEntry(&ISChunkInfo))
#define WmipAllocDataConsumer() ((PDCENTRY)WmipAllocEntry(&DCChunkInfo))

#define WmipAllocNotificationEntry() ((PNOTIFICATIONENTRY)WmipAllocEntry(&NEChunkInfo))

#define WmipAllocMofResource() ((PMOFRESOURCE)WmipAllocEntry(&MRChunkInfo))

#ifdef WMI_USER_MODE
#define WmipAllocMofClass() ((PMOFCLASS)WmipAllocEntry(&MCChunkInfo))
#endif

#define WmipAllocString(Size) \
    WmipAlloc((Size)*sizeof(WCHAR))

#define WmipFreeString(Ptr) \
    WmipFree(Ptr)

#ifdef MEMPHIS
#define WmipAlloc(Size) \
    malloc(Size)

#define WmipFree(Ptr) \
    free(Ptr)
	
#define WmipInitProcessHeap()
#else

//
// Reserve 1MB for WMI.DLL, but only commit 16K initially
#define DLLRESERVEDHEAPSIZE 1024 * 1024
#define DLLCOMMITHEAPSIZE     0 * 1024

//
// Reserve 1MB for WMI service, but only commit 16K initially
#define CORERESERVEDHEAPSIZE 1024 * 1024
#define CORECOMMITHEAPSIZE     16 * 1024


extern PVOID WmipProcessHeap;

#define WmipInitProcessHeap() \
{ \
    if (WmipProcessHeap == NULL) \
    { \
        WmipCreateHeap(); \
    } \
}


#ifdef HEAPVALIDATION
PVOID WmipAlloc(
    ULONG Size
    );

void WmipFree(
    PVOID p
    );

#else
#if DBG
_inline PVOID WmipAlloc(ULONG Size)
{
    WmipAssert(WmipProcessHeap != NULL);
    return(RtlAllocateHeap(WmipProcessHeap, 0, Size));
}

_inline void WmipFree(PVOID Ptr)
{
    RtlFreeHeap(WmipProcessHeap, 0, Ptr);
}

#else
#define WmipAlloc(Size) \
    RtlAllocateHeap(WmipProcessHeap, 0, Size)

#define WmipFree(Ptr) \
    RtlFreeHeap(WmipProcessHeap, 0, Ptr)
#endif
#endif
#endif

BOOLEAN WmipRealloc(
    PVOID *Buffer,
    ULONG CurrentSize,
    ULONG NewSize,
    BOOLEAN FreeOriginalBuffer
    );


//
// datastr.c
extern GUID WmipBinaryMofGuid;

void WmipGenerateBinaryMofNotification(
    PBINSTANCESET BianryMofInstanceSet,
    LPCGUID Guid	
    );

BOOLEAN WmipEstablishInstanceSetRef(
    PBDATASOURCE DataSourceRef,
    LPGUID Guid,
    PBINSTANCESET InstanceSet
    );

ULONG WmipAddDataSource(
    PTCHAR QueryBinding,
    ULONG RequestAddress,
    ULONG RequestContext,
    LPCTSTR ImagePath,
    PWMIREGINFOW RegistrationInfo,
    ULONG RegistrationInfoSize,
    ULONG_PTR *ProviderId,
    BOOLEAN IsAnsi
    );

ULONG WmipUpdateAddGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PWMIREGINFO RegistrationInfo,
    PBINSTANCESET *AddModInstanceSet
    );

ULONG WmipUpdateModifyGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PWMIREGINFO RegistrationInfo,
    PBINSTANCESET *AddModInstanceSet
    );

BOOLEAN  WmipUpdateRemoveGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PBINSTANCESET *AddModInstanceSet
    );

void WmipUpdateDataSource(
    ULONG_PTR ProviderId,
    PWMIREGINFOW RegistrationInfo,
    ULONG RetSize
    );

void WmipRemoveDataSource(
    ULONG_PTR ProviderId
    );

void WmipRemoveDataSourceByDS(
    PBDATASOURCE DataSource
    );

ULONG WmipRegisterInternalDataSource(
    void
    );

PBGUIDENTRY WmipFindGEByGuid(
    LPGUID Guid,
    BOOLEAN MakeTopOfList
    );

PBINSTANCESET WmipFindISInDSByGuid(
    PBDATASOURCE DataSource,
    LPGUID Guid
    );

PNOTIFICATIONENTRY WmipFindNEByGuid(
    GUID UNALIGNED *Guid,
    BOOLEAN MakeTopOfList
    );

PDCREF WmipFindExistingAndFreeDCRefInNE(
    PNOTIFICATIONENTRY NotificationEntry,
    PDCENTRY DataConsumer,
    PDCREF *FreeDcRef
    );

PDCREF WmipFindDCRefInNE(
    PNOTIFICATIONENTRY NotificationEntry,
    PDCENTRY DataConsumer
    );

PBDATASOURCE WmipFindDSByProviderId(
    ULONG_PTR ProviderId
    );

PBINSTANCESET WmipFindISByGuid(
    PBDATASOURCE DataSource,
    GUID UNALIGNED *Guid
    );

PMOFRESOURCE WmipFindMRByNames(
    LPCWSTR ImagePath,
    LPCWSTR MofResourceName
    );

#ifdef WMI_USER_MODE
PMOFCLASS WmipFindMCByGuid(
    LPGUID Guid
    );

PMOFCLASS WmipFindMCByGuidAndBestLanguage(
    LPGUID Guid,
    WORD Language
    );

PMOFCLASS WmipFindMCByGuidAndLanguage(
    LPGUID Guid,
    WORD Language
    );
#endif

PBINSTANCESET WmipFindISinGEbyName(
    PBGUIDENTRY GuidEntry,
    PWCHAR InstanceName,
    PULONG InstanceIndex
    );

PWNODE_HEADER WmipGenerateRegistrationNotification(
    PBDATASOURCE DataSource,
    PWNODE_HEADER Wnode,
    ULONG GuidMax,
    ULONG NotificationCode
    );

BOOLEAN
WmipIsControlGuid(
    PBGUIDENTRY GuidEntry
    );

void WmipGenerateMofResourceNotification(
    LPWSTR ImagePath,
    LPWSTR ResourceName,
    LPCGUID Guid
    );

//
// wbem.c
ULONG WmipBuildMofClassInfo(
    PBDATASOURCE DataSource,
    LPWSTR ImagePath,
    LPWSTR MofResourceName,
    PBOOLEAN NewMofResource
    );

ULONG WmipReadBuiltinMof(
    void
    );


//
// from krnlmode.c
ULONG WmipInitializeKM(
    HANDLE *WmiKMHandle
    );

void WmipKMNonEventNotification(
    HANDLE WmiKMHandle,
    PWNODE_HEADER Wnode
    );

//
// main.c

extern HANDLE WmipRestrictedToken;

void WmipGetRegistryValue(
    TCHAR *ValueName,
    PULONG Value
    );

ULONG WmiRunService(
    ULONG Context
#ifdef MEMPHIS
    , HINSTANCE InstanceHandle
#endif
    );

ULONG WmipInitializeAccess(
    PTCHAR *RpcStringBinding
    );

void WmiTerminateService(
    void
    );

ULONG WmiInitializeService(
    void
);

void WmiDeinitializeService(
    void
);

void WmipEventNotification(
    PWNODE_HEADER Wnode,
    BOOLEAN SingleEvent,
    ULONG EventSizeGuess
    );

#define WmipBuildRegistrationNotification(Wnode, WnodeSize, NotificationCode, GuidCount) { \
    memset(Wnode, 0, sizeof(WNODE_HEADER)); \
    memcpy(&Wnode->Guid, &RegChangeNotificationGuid, sizeof(GUID)); \
    Wnode->BufferSize = WnodeSize; \
    Wnode->Linkage = NotificationCode; \
    Wnode->Version = GuidCount; \
    Wnode->Flags = WNODE_FLAG_INTERNAL; \
}

void WmipSendQueuedEvents(
    void
    );

ULONG WmipCleanupDataConsumer(
    PDCENTRY DataConsumer
#if DBG
    ,BOOLEAN *NotificationsEnabled,
    BOOLEAN *CollectionsEnabled
#endif
    );
//
// This defines the maximum number of replacement strings over all of the
// event messages.
#define MAX_MESSAGE_STRINGS 2
void __cdecl WmipReportEventLog(
    ULONG MessageCode,
    WORD MessageType,
    WORD MessageCategory,
    DWORD RawDataSize,
    PVOID RawData,
    WORD StringCount,
    ...
    );

#ifdef MEMPHIS
long WINAPI
DeviceNotificationWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam);

void WmipDestroyDeviceNotificationWindow(
    HINSTANCE InstanceHandle,
    HWND WindowHandle
    );

ULONG WmipCreateDeviceNotificationWindow(
    HINSTANCE InstanceHandle,
    HWND *DeviceNotificationWindow
    );

#endif


//
// server.c
void WmipRpcServerDeinitialize(
    void
    );

ULONG WmipRpcServerInitialize(
    void
    );

ULONG WmipDeliverWnodeToDS(
    ULONG ActionCode,
    PBDATASOURCE DataSource,
    PWNODE_HEADER Wnode
);

ULONG WmipDoDisableRequest(
    PNOTIFICATIONENTRY NotificationEntry,
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext,
    ULONG InProgressFlag
    );

ULONG CollectOrEventWorker(
    PDCENTRY DataConsumer,
    LPGUID Guid,
    BOOLEAN Enable,
    BOOLEAN IsEvent,
    ULONG *NotificationCookie,
    ULONG64 LoggerContext,
    ULONG NotificationFlags
    );

ULONG WmipCreateRestrictedToken(
    HANDLE *RestrictedToken
    );

void WmipShowPrivs(
    HANDLE TokenHandle
    );

#ifdef MEMPHIS
#define WmipRestrictToken(Token) (ERROR_SUCCESS)
#define WmipUnrestrictToken() (ERROR_SUCCESS)
#else
ULONG WmipRestrictToken(
    HANDLE RestrictedToken
    );

ULONG WmipUnrestrictToken(
    void
    );

ULONG WmipServiceDisableTraceProviders(
    PWNODE_HEADER Wnode
    );

#endif

void WmipReleaseCollectionEnabled(
    PNOTIFICATIONENTRY NotificationEntry
    );

//
// chunk.c
ULONG UnicodeToAnsi(
    LPCWSTR pszW,
    LPSTR * ppszA,
    ULONG *AnsiSizeInBytes OPTIONAL
    );

ULONG AnsiToUnicode(
    LPCSTR pszA,
    LPWSTR * ppszW
    );

ULONG AnsiSizeForUnicodeString(
    PWCHAR UnicodeString,
    ULONG *AnsiSizeInBytes
    );

ULONG UnicodeSizeForAnsiString(
    LPCSTR AnsiString,
    ULONG *UnicodeSizeInBytes
    );

//
// debug.c
#if DBG
void WmipDumpIS(
    PBINSTANCESET IS,
    BOOLEAN RecurseGE,
    BOOLEAN RecurseDS
    );

void WmipDumpGE(
    PBGUIDENTRY GE,
    BOOLEAN RecurseIS
    );

void WmipDumpDS(
    PBDATASOURCE DS,
    BOOLEAN RecurseIS
    );

void WmipDumpAllDS(
    void
    );

#endif

#ifndef MEMPHIS

typedef enum
{
    TRACELOG_START        = 0,
    TRACELOG_STOP         = 1,
    TRACELOG_QUERY        = 2,
    TRACELOG_QUERYALL     = 3,
    TRACELOG_QUERYENABLED = 4,
    TRACELOG_UPDATE       = 5,
    TRACELOG_FLUSH        = 6
} TRACEREQUESTCODE;

typedef struct _WMI_REF_CLOCK {
    LARGE_INTEGER   StartTime;
    LARGE_INTEGER   StartPerfClock;
} WMI_REF_CLOCK, *PWMI_REF_CLOCK;



//
// logsup.c

ULONG
WmiUnregisterGuids(
    IN WMIHANDLE WMIHandle,
    IN LPGUID    Guid,
    OUT ULONG64  *LoggerContext
);

void
WmipGenericTraceEnable(
    IN ULONG RequestCode,
    IN PVOID Buffer,
    IN OUT PVOID *RequestAddress
    );

ULONG
WmipAddLogHeaderToLogFile(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN PWMI_REF_CLOCK RefClock,
    IN ULONG Update
    );

ULONG
WmipStartLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
WmipStopLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
WmipQueryLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN ULONG Update
    );
ULONG
WmipFlushLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

VOID
WmipInitString(
    IN PVOID Destination,
    IN PVOID Buffer,
    IN ULONG Size
    );

ULONG
WmipGetTraceRegKeys(
    );

ULONG
WmipFinalizeLogFileHeader(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    );

//
// umlog.c
BOOLEAN
FASTCALL
WmipIsPrivateLoggerOn();

ULONG
WmipFlushUmLoggerBuffer();

ULONG
WmipSendUmLogRequest(
    IN WMITRACECODE RequestCode,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
FASTCALL
WmiTraceUmEvent(
    IN PWNODE_HEADER Wnode
    );

ULONG
WmipStartUmLogger(
    IN ULONG WnodeSize,
    IN OUT ULONG *SizeUsed,
    OUT ULONG *SizeNeeded,
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
WmipStopUmLogger(
        IN ULONG WnodeSize,
        IN OUT ULONG *SizeUsed,
        OUT ULONG *SizeNeeded,
        IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

PWMI_BUFFER_HEADER
FASTCALL
WmipGetFullFreeBuffer();

LONG
FASTCALL
WmipReleaseTraceBuffer(
    IN PWMI_BUFFER_HEADER BufferResource
    );

PWMI_BUFFER_HEADER
FASTCALL
WmipSwitchFullBuffer(
    IN PWMI_BUFFER_HEADER OldBuffer
    );

ULONG
WmipReleaseFullBuffer(
    IN PWMI_BUFFER_HEADER Buffer
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\acpimap\method.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    method.c

Abstract:

    acpi mapper test app

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>

#include "wmium.h"

GUID AAGuid = {0xABBC0F5A, 0x8ea1, 0x11d1, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0x00, 0x00};
GUID ABGuid = {0xABBC0F5B, 0x8ea1, 0x11d1, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0x00, 0x00};
GUID A0Guid = {0xABBC0F5C, 0x8ea1, 0x11d1, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0x00, 0x00};

GUID BAGuid = {0xABBC0F6A, 0x8ea1, 0x11d1, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0x00, 0x00};
GUID BBGuid = {0xABBC0F6B, 0x8ea1, 0x11d1, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0x00, 0x00};
GUID B0Guid = {0xABBC0F6C, 0x8ea1, 0x11d1, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0x00, 0x00};

GUID CAGuid = {0xABBC0F7A, 0x8ea1, 0x11d1, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, 0x00, 0x00};

#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)Base + Offset))

ULONG InstanceCount;
PCHAR *InstanceNames;

#define InstanceName0 InstanceNames[0]
#define InstanceName1 InstanceNames[1]
#define InstanceName2 InstanceNames[2]

#define MYSTRING L"XYZZY-PLUGH-PLOVER"
WCHAR FUNNYSTRING[] = { sizeof(MYSTRING), MYSTRING }; 

ULONG ValueBuffer[4] = { 0x66666666, 0x77777777, 0x88888888, 0x99999999 };


ULONG DetermineInstanceNames(
    LPGUID Guid,
    PULONG InstanceCount,
    PCHAR **InstanceNamePtrArray
	)
{
	ULONG j;
	WMIHANDLE Handle;
	ULONG status;
	ULONG bufferSize;
	PUCHAR buffer;
	ULONG i, iCount, linkage;
	PWNODE_ALL_DATA WAD;
	PCHAR *iNames;	
	PULONG pInstanceNameOffsets;
	PCHAR pName;
	PUSHORT pNameSize;
	
	status = WmiOpenBlock(Guid,
                          GENERIC_READ,
                          &Handle);
					  
    if (status != ERROR_SUCCESS)
	{
		printf("WmiOpenBlock(Statyus) => %d\n", status);
		return(status);
	}

	bufferSize = 0x1000;
	buffer = NULL;
	status = ERROR_INSUFFICIENT_BUFFER;
	
	while (status == ERROR_INSUFFICIENT_BUFFER)
	{
		if (buffer != NULL)
		{
			free(buffer);
		}
		
    	buffer = malloc(bufferSize);
		if (buffer == NULL)
		{
			status = ERROR_NOT_ENOUGH_MEMORY;
			break;
		}
		
		status = WmiQueryAllData(Handle,
                                 &bufferSize,
                                 buffer);
	}
	
	if (status == ERROR_SUCCESS)
	{
		WAD = (PWNODE_ALL_DATA)buffer;
		linkage = 0;				
		iCount = 0;
		do
		{
			WAD = (PWNODE_ALL_DATA)OffsetToPtr(WAD, linkage);
			linkage = WAD->WnodeHeader.Linkage;
			iCount += WAD->InstanceCount;

		} while (linkage != 0);

		
        iNames = malloc(iCount * sizeof(PCHAR));
		if (iNames == NULL)
		{
			status = ERROR_NOT_ENOUGH_MEMORY;
			return(status);
		}
		
		WAD = (PWNODE_ALL_DATA)buffer;
		linkage = 0;				
		i = 0;
		do
		{
			WAD = (PWNODE_ALL_DATA)OffsetToPtr(WAD, linkage);
			
			pInstanceNameOffsets = (PULONG)OffsetToPtr(WAD, WAD->OffsetInstanceNameOffsets);
            for (j = 0; j < WAD->InstanceCount; j++)
			{
    			pNameSize = (PUSHORT)OffsetToPtr(WAD, pInstanceNameOffsets[j]);
	    		pName = (PCHAR)OffsetToPtr(pNameSize, sizeof(USHORT));
			
		    	iNames[i] = malloc(*pNameSize + 1);
    			if (iNames[i] == NULL)
	    		{
    				status = ERROR_NOT_ENOUGH_MEMORY;
	    			return(status);
    			}
				
    			memset(iNames[i], 0, *pNameSize + 1);
	    		memcpy(iNames[i], pName, *pNameSize);
    			i++;
			}
			
			linkage = WAD->WnodeHeader.Linkage;

		} while (linkage != 0);
		
	} else {
		printf("QAD(status) -> %d\n", status);
	}
	
	free(buffer);
	
	*InstanceCount = iCount;
	*InstanceNamePtrArray = iNames;
	
	return(ERROR_SUCCESS);
}


PCHAR GuidToString(
    PCHAR s,
    LPGUID piid
    )
{
    sprintf(s, "%x-%x-%x-%x%x%x%x%x%x%x%x",
               piid->Data1, piid->Data2, 
               piid->Data3,
               piid->Data4[0], piid->Data4[1],
               piid->Data4[2], piid->Data4[3],
               piid->Data4[4], piid->Data4[5],
               piid->Data4[6], piid->Data4[7]);

    return(s);
}


ULONG 
QuerySetCheck(
    LPGUID Guid,
    PCHAR InstanceName,
    BOOLEAN UseString,
    BOOLEAN *Success
    )
{
    WMIHANDLE WmiHandle;
    BYTE Buffer[4096];
    ULONG BufferSize;
    PUCHAR CheckValue, Value;
    ULONG CheckSize, ValueSize;
    CHAR s[MAX_PATH];
    ULONG Status;
    PWNODE_SINGLE_INSTANCE Wnode;
    
    if (UseString)
    {
        Value = (PUCHAR)FUNNYSTRING;
        ValueSize = sizeof(FUNNYSTRING);
    } else {
        Value = (PUCHAR)ValueBuffer;
        ValueSize = sizeof(ValueBuffer);
    }
    
    Status = WmiOpenBlock(Guid, 0, &WmiHandle);
    if (Status == ERROR_SUCCESS)
    {
        Status = WmiSetSingleInstance(WmiHandle,
                                      InstanceName,
                                      0,
                                      ValueSize,
                                      Value);
                                  
         if (Status == ERROR_SUCCESS)
         {
             BufferSize = sizeof(Buffer);
             Status = WmiQuerySingleInstance(WmiHandle,
                                             InstanceName,
                                             &BufferSize,
                                             Buffer);
             if (Status == ERROR_SUCCESS)
             {
                 Wnode = (PWNODE_SINGLE_INSTANCE)Buffer;
                 CheckValue = Buffer + Wnode->DataBlockOffset;
                 CheckSize = Wnode->SizeDataBlock;
                 
                 *Success = ((CheckSize == ValueSize) &&
                             (memcmp(CheckValue, Value, ValueSize) == 0));
                     
             } else {
                 printf("QuerySetCheck: WmiQuerySingleInstance(%s) -> %d\n", 
                     GuidToString(s, Guid),
                     Status);
             }
         } else {
             printf("QuerySetCheck: WmiSetSingleInstance(%s) -> %d\n", 
                 GuidToString(s, Guid),
                 Status);
         }
         WmiCloseBlock(WmiHandle);
    } else {
        printf("QuerySetCheck: WmiOpenBlock(%s) -> %d\n", 
             GuidToString(s, Guid),
            Status);
    }
    return(Status);
}


ULONG 
TrySmallQuery(
    LPGUID Guid,
    PCHAR InstanceName
    )
{
    UCHAR Buffer[4096];
    ULONG BufferSize;
    ULONG Status;
    WMIHANDLE WmiHandle;
    CHAR s[MAX_PATH];
    
    Status = WmiOpenBlock(Guid, 0, &WmiHandle);
    if (Status == ERROR_SUCCESS)
    {
        BufferSize = 0;
        Status = ERROR_INSUFFICIENT_BUFFER;
        while (Status == ERROR_INSUFFICIENT_BUFFER)
        {
            printf("TrySmallQuery(%s): size %d --> ", 
                 GuidToString(s, Guid),
                BufferSize);
            Status = WmiQuerySingleInstance(WmiHandle,
                                             InstanceName,
                                             &BufferSize,
                                             Buffer);
            printf("%d\n", Status);
                                         
        }
	
        printf("TrySmallQuery(%s): -> %d size %d\n", 
                 GuidToString(s, Guid),
               Status,
            BufferSize);
    } else {
        printf("TrySmallQuery: WmiOpenBlock(%s) -> %d\n", 
                 GuidToString(s, Guid),
            Status);
    }
    return(Status);
}


typedef struct
{
    HANDLE Event;
    PUCHAR Value;
    ULONG ValueSize;
    BOOLEAN Success;
} CHECK_EVENT_CONTEXT, *PCHECK_EVENT_CONTEXT;

void NotificationRoutine(
    PWNODE_HEADER Wnode,
    ULONG Context
    )
{
    PWNODE_SINGLE_INSTANCE WnodeSi = (PWNODE_SINGLE_INSTANCE)Wnode;
    PUCHAR CheckValue, Value;
    ULONG CheckSize, ValueSize;
    PCHECK_EVENT_CONTEXT CheckEventContext;
    CHAR s[MAX_PATH];
    HANDLE Handle;
    ULONG Status;
    
    Status = RpcImpersonateClient(0);
    
    printf("RpcImpersonateClient -> %d\n", Status);
    
    Handle = CreateFile("foo.bar",
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
		
    if (Handle == INVALID_HANDLE_VALUE)
    {
        printf("Error opening locked file %d\n", GetLastError());
    } else {
        printf("Opened locked file\n");
	CloseHandle(Handle);
    }
    
    if (Status == ERROR_SUCCESS)
    {
        RpcRevertToSelf();
    }
    
    printf("Event Received for %s\n", GuidToString(s, &Wnode->Guid));
    CheckEventContext = (PCHECK_EVENT_CONTEXT)Context;
    
    CheckSize = WnodeSi->SizeDataBlock;
    CheckValue = ((PUCHAR)WnodeSi) + WnodeSi->DataBlockOffset;

    ValueSize = CheckEventContext->ValueSize;
    Value = CheckEventContext->Value;
    
    if ((CheckSize != ValueSize) ||
        (memcmp(CheckValue, Value, ValueSize) != 0))
    {
        printf("Event Data doesn't match %x %d != %x %d\n",
               Value, ValueSize, CheckValue, CheckSize);        
    } else {
        CheckEventContext->Success = TRUE;
    }
                     
    SetEvent(CheckEventContext->Event);
    
}

ULONG 
DoMethodAndCatchEvent(
    LPGUID MethodGuid,
    PCHAR InstanceName,
    LPGUID EventGuid,
    BOOLEAN UseString,
    BOOLEAN EnableEvent,
    PBOOLEAN MethodSuccess,
    PBOOLEAN EventSuccess
    )
{
    UCHAR Buffer[4096];
    ULONG BufferSize;
    ULONG Status, Status2;
    WMIHANDLE WmiHandle;
    PUCHAR CheckValue, Value;
    ULONG CheckSize, ValueSize;
    HANDLE Event;
    CHAR s[MAX_PATH];
    PCHECK_EVENT_CONTEXT CheckEventContext;
    PWNODE_SINGLE_INSTANCE Wnode;

    CheckEventContext = (PCHECK_EVENT_CONTEXT)malloc(sizeof(CHECK_EVENT_CONTEXT));
    if (CheckEventContext != NULL)
    {
        Event = CreateEvent(NULL, FALSE, FALSE, NULL);
        CheckEventContext->Event = Event;
        if (UseString)
        {
            Value = (PUCHAR)FUNNYSTRING;
            ValueSize = sizeof(FUNNYSTRING);
        } else {
            Value = (PUCHAR)ValueBuffer;
            ValueSize = sizeof(ValueBuffer);
        }
        
        CheckEventContext->Value = Value;
        CheckEventContext->ValueSize = ValueSize;
        CheckEventContext->Success = FALSE;
            
        Status = WmiOpenBlock(MethodGuid, 0, &WmiHandle);
        if (Status == ERROR_SUCCESS)
        {
            if (EnableEvent)
            {
                Status = WmiNotificationRegistration(EventGuid,
                                         TRUE,
                                         NotificationRoutine,
                                         (ULONG)CheckEventContext,
                                         NOTIFICATION_CALLBACK_DIRECT);
            } else {
                Status = ERROR_SUCCESS;
            }
                                     
            if (Status == ERROR_SUCCESS)
            {
                CheckSize = sizeof(Buffer);
                Status = WmiExecuteMethod(WmiHandle,
                                      InstanceName,
                                      1,
                                      ValueSize,
                                      Value,
                                      &CheckSize,
                                      Buffer);
            
                if (Status == ERROR_SUCCESS)
                {
                    CheckValue = (PUCHAR)Buffer;
                    
                    *MethodSuccess = ((CheckSize == ValueSize) &&
                             (memcmp(CheckValue, Value, ValueSize) == 0));
                     
                    Status2 = WaitForSingleObject(Event, 10*1000);
                    if (Status2 == WAIT_OBJECT_0)
                    {
                        *EventSuccess = CheckEventContext->Success;
                        free(CheckEventContext);
                    } else {
                        printf("Event for %s not received\n",
                                    GuidToString(s, EventGuid));
                    }
                 } else {
                    printf("DoMethodAndCatchEvent: WmiExecuteMethod(%s) -> %d\n", 
                         GuidToString(s, MethodGuid),
                           Status);
                }
                
                if (EnableEvent)
                {
                    WmiNotificationRegistration(EventGuid,
                                        FALSE,
                                        NULL,
                                        0,
                                        NOTIFICATION_CALLBACK_DIRECT);
                }
            } else {
                printf("DoMethodAndCatchEvent: WmiNotificationRegistration(%s) -> %d\n", 
                     GuidToString(s, EventGuid),
                       Status);
            }
            WmiCloseBlock(WmiHandle);            
        } else {
            printf("DoMethodAndCatchEvent: WmiOpenBlock(%s) -> %d\n", 
                 GuidToString(s, MethodGuid),
                Status);
            
        }
        
    }
    return(Status);
}


void TinyQueryTest(
    void
    )
{
    ULONG Status;
    
    Status = TrySmallQuery(&AAGuid, 
                           InstanceName0);
                       
    Status = TrySmallQuery(&BAGuid, 
                           InstanceName0);

    Status = TrySmallQuery(&BAGuid, 
                           InstanceName1);

    Status = TrySmallQuery(&BAGuid, 
                           InstanceName2);

    Status = TrySmallQuery(&CAGuid, 
                           InstanceName2);

}

ULONG QuerySetStuffTest(
    LPGUID Guid,
    CHAR *InstanceName,
    BOOLEAN UseString,
    PULONG QueryStatus,
    PULONG SetStatus		
	)
{
    WMIHANDLE WmiHandle;
    BYTE Buffer[4096];
    ULONG BufferSize;
    PUCHAR Value;
    ULONG ValueSize;
    CHAR s[MAX_PATH];
    ULONG Status;
	
    if (UseString)
    {
        Value = (PUCHAR)FUNNYSTRING;
        ValueSize = sizeof(FUNNYSTRING);
    } else {
        Value = (PUCHAR)ValueBuffer;
        ValueSize = sizeof(ValueBuffer);
    }
	
    Status = WmiOpenBlock(Guid, 0, &WmiHandle);
    if (Status == ERROR_SUCCESS)
    {
        *SetStatus = WmiSetSingleInstance(WmiHandle,
                                      InstanceName,
                                      0,
                                      ValueSize,
                                      Value);
                                  

         BufferSize = sizeof(Buffer);
         *QueryStatus = WmiQuerySingleInstance(WmiHandle,
                                             InstanceName,
                                             &BufferSize,
                                             Buffer);
										 
        WmiCloseBlock(WmiHandle);
    } else {
        printf("QuerySetTest: WmiOpenBlock(%s) -> %d\n", 
             GuidToString(s, Guid),
            Status);
    }
	return(Status);
}

ULONG SetBadStringTest(
    LPGUID Guid,
    CHAR *InstanceName,
    ULONG BadStringLength,
	PUCHAR BadString,
    PULONG SetStatus		
	)
{
    WMIHANDLE WmiHandle;
    PUCHAR Value;
    ULONG ValueSize;
    CHAR s[MAX_PATH];
    ULONG Status;
	
    Value = (PUCHAR)BadString;
    ValueSize = BadStringLength;
	
    Status = WmiOpenBlock(Guid, 0, &WmiHandle);
    if (Status == ERROR_SUCCESS)
    {
        *SetStatus = WmiSetSingleInstance(WmiHandle,
                                      InstanceName,
                                      0,
                                      ValueSize,
                                      Value);
                                  

        WmiCloseBlock(WmiHandle);
    } else {
        printf("SetBadString: WmiOpenBlock(%s) -> %d\n", 
             GuidToString(s, Guid),
            Status);
    }
	return(Status);
}

ULONG ExecuteMethodTest(
    LPGUID Guid,
    CHAR *InstanceName,
    BOOLEAN UseString,
    PULONG OutBufferSize,
    PUCHAR OutBuffer,
    PULONG ExecuteStatus
	)
{
    WMIHANDLE WmiHandle;
    CHAR s[MAX_PATH];
    PUCHAR Value;
    ULONG ValueSize;
    ULONG Status;
	
    if (UseString)
    {
        Value = (PUCHAR)FUNNYSTRING;
        ValueSize = sizeof(FUNNYSTRING);
    } else {
        Value = (PUCHAR)ValueBuffer;
        ValueSize = sizeof(ValueBuffer);
    }
	
    Status = WmiOpenBlock(Guid, 0, &WmiHandle);
    if (Status == ERROR_SUCCESS)
    {
        *ExecuteStatus = WmiExecuteMethod(WmiHandle,
                                      InstanceName,
                                      1,
                                      ValueSize,
                                      Value,
                                      OutBufferSize,
                                      OutBuffer);
                                  

        WmiCloseBlock(WmiHandle);
    } else {
        printf("ExecuteMehtod: WmiOpenBlock(%s) -> %d\n", 
             GuidToString(s, Guid),
            Status);
    }
	return(Status);
}

void QuerySetEventAndMethodTest(
    void
    )
{
	ULONG Status;
	ULONG QueryStatus, SetStatus;

	Status = QuerySetStuffTest(&A0Guid,
                          InstanceName0,
		                  FALSE,
                          &QueryStatus,
                          &SetStatus);
					  
    if (Status == ERROR_SUCCESS)
	{
		printf("QuerySetStuffTest(&A0) Query -> %d, Set -> %d\n",
			    QueryStatus,
                SetStatus);
	} else {
		printf("QuerySetTest: WmiOpenBlock(abbc0f5c-... is ok, not a failure\n");
	}

	Status = QuerySetStuffTest(&ABGuid,
                          InstanceName0,
		                  TRUE,
                          &QueryStatus,
                          &SetStatus);

    if (Status != ERROR_SUCCESS)
	{
		printf("QUerySetStuffTest(&AB) failed %d\n", Status);
	}
	
    if ((Status == ERROR_SUCCESS) &&
		((QueryStatus == ERROR_SUCCESS) || (SetStatus == ERROR_SUCCESS)))
	{
		printf("QuerySetStuffTest(&AB) Query -> %d, Set -> %d\n",
			    QueryStatus,
                SetStatus);
	}
}

void 
SetBadStringsTest(
    void
	)
{
	UCHAR BadStringBuffer[0x100];
	ULONG Status, SetStatus;
	
	*((PWCHAR)BadStringBuffer) = 0x7890;
	Status = SetBadStringTest(&AAGuid,
                     InstanceName0,
                     sizeof(BadStringBuffer),
                     BadStringBuffer,
                     &SetStatus);
    if (Status != ERROR_SUCCESS)
	{
		printf("SetBadStringTest too long failed %d\n", Status);
	}				 
				 
    if ((Status == ERROR_SUCCESS) && (SetStatus == ERROR_SUCCESS))
	{
		printf("SetBadStringTest: too long -> %d\n", SetStatus);
	}
				 
    memset(BadStringBuffer, 0xa9, sizeof(BadStringBuffer));
	*((PWCHAR)BadStringBuffer) = 0x10;
	Status = SetBadStringTest(&AAGuid,
                     InstanceName0,
                     sizeof(BadStringBuffer),
                     BadStringBuffer,
                     &SetStatus);
    if ((Status == ERROR_SUCCESS) && (SetStatus == ERROR_SUCCESS))
	{
		printf("SetBadStringTest: bad string -> %d - this is not a failure\n", SetStatus);
	} else {
		printf("SetBadStringTest bad string failed %d\n", Status);
	}
	
}

void 
SetEmptyTest(
    void
	)
{
	UCHAR BadStringBuffer[0x100];
	ULONG Status, SetStatus;
	
	Status = SetBadStringTest(&AAGuid,
                     InstanceName0,
                     0,
                     BadStringBuffer,
                     &SetStatus);
    if ((Status == ERROR_SUCCESS) && (SetStatus != ERROR_SUCCESS))
	{
		printf("SetEmptyTest:  -> %d\n", SetStatus);
	}				 	
	
	Status = SetBadStringTest(&BAGuid,
                     InstanceName0,
                     0,
                     BadStringBuffer,
                     &SetStatus);
    if ((Status == ERROR_SUCCESS) && (SetStatus != ERROR_SUCCESS))
	{
		printf("SetEmptyTest(BA):  -> %d\n", SetStatus);
	}				 	
	
	// TODO: check that instances actually set to empty
}

void 
ExecuteEmptyTest(
    void
	)
{
	UCHAR OutBuffer[0x100];
	ULONG Status, SetStatus;
	ULONG OutSize;
	
	Status = ExecuteMethodTest(&ABGuid,
                     InstanceName0,
                     TRUE,
                     &OutSize,
                     NULL,
					 &SetStatus);
    if ((Status == ERROR_SUCCESS) && (SetStatus != ERROR_SUCCESS))
	{
		printf("ExecuteMethodTest (void):  -> %d, size = %d\n", SetStatus, OutSize);
	}				 	
	
	OutSize = 1;
	Status = ExecuteMethodTest(&ABGuid,
                     InstanceName0,
                     TRUE,
                     &OutSize,
                     OutBuffer,
					 &SetStatus);
    if ((Status == ERROR_SUCCESS) && (SetStatus != ERROR_INSUFFICIENT_BUFFER))
	{
		printf("ExecuteMethodTest (too small):  -> %d, size = %d\n", SetStatus, OutSize);
	}	
	
	Status = ExecuteMethodTest(&ABGuid,
                     InstanceName0,
                     TRUE,
                     &OutSize,
                     OutBuffer,
					 &SetStatus);
    if ((Status == ERROR_SUCCESS) && (SetStatus != ERROR_SUCCESS))
	{
		printf("ExecuteMethodTest (right size):  -> %d, size = %d\n", SetStatus, OutSize);
	}	
	
	
}

void
QuerySetTest(
    void
    )
{
    ULONG Status;
    BOOLEAN Success;
    
    Status = QuerySetCheck(&AAGuid,
                           InstanceName0,
                           TRUE,
                           &Success);
                       
    if (Status == ERROR_SUCCESS)
    {
        if ( ! Success)
        {
            printf("QuerySetTest AAGuid Data didn't match\n");
        }
    }

    Status = QuerySetCheck(&BAGuid,
                           InstanceName0,
                           FALSE,
                           &Success);
    if (Status == ERROR_SUCCESS)
    {
        if ( ! Success)
        {
            printf("QuerySetTest BAGuid 0 Data didn't match\n");
        }
    }

    Status = QuerySetCheck(&BAGuid,
                           InstanceName1,
                           FALSE,
                           &Success);
    if (Status == ERROR_SUCCESS)
    {
        if ( ! Success)
        {
            printf("QuerySetTest BAGuid 1 Data didn't match\n");
        }
    }

    Status = QuerySetCheck(&BAGuid,
                           InstanceName2,
                           FALSE,
                           &Success);
    if (Status == ERROR_SUCCESS)
    {
        if ( ! Success)
        {
            printf("QuerySetTest BAGuid 2 Data didn't match\n");
        }
    }

}

void
FireEventTest(
    void
    )
{
    ULONG Status;
    BOOLEAN MethodSuccess, EventSuccess;
    
    Status = DoMethodAndCatchEvent(&ABGuid,
                                   InstanceName0,
                                   &A0Guid,
                                   TRUE,
                                   TRUE,
                                   &MethodSuccess,
                                   &EventSuccess);
                               
    if (Status == ERROR_SUCCESS)
    {
        if (! MethodSuccess)
        {
            printf("FireEventTest AAGuid Method Data didn't match\n");
        }
        
        if (! EventSuccess)
        {
            printf("FireEventTest AAGuid Event Data didn't match\n");
        }
    }
                                   
    Status = DoMethodAndCatchEvent(&BBGuid,
                                   InstanceName0,
                                   &B0Guid,
                                   FALSE,
                                   TRUE,
                                   &MethodSuccess,
                                   &EventSuccess);
                               
    if (Status == ERROR_SUCCESS)
    {
        if (! MethodSuccess)
        {
            printf("FireEventTest BBGuid Method Data didn't match\n");
        }
        
        if (! EventSuccess)
        {
            printf("FireEventTest BBGuid Event Data didn't match\n");
        }
    }
                                   
}

int _cdecl main(int argc, char *argv[])
{

    ULONG Status;

	
	Status = DetermineInstanceNames(&BAGuid,
		                            &InstanceCount,
                                    &InstanceNames);
	
    if (Status != ERROR_SUCCESS)
	{
		printf("DetermineInstanceNames failed %d\n", Status);
		return(Status);
	}

#if 1
//
// Expected successful completion tests
    TinyQueryTest();
    QuerySetTest();
    FireEventTest();    
    
//
// Error condition tests
    QuerySetEventAndMethodTest();
    SetBadStringsTest();
	SetEmptyTest();
	ExecuteEmptyTest();
#endif

                   
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\dc1\dc1.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    dc1.c

Abstract:

    data consumer test

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>

#define MEMPHIS

#include "wmium.h"

#include "wmiumkm.h"

#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)Base + Offset))

typedef struct tagTESTGUID TESTGUID;

GUID BotDynGuid = {0xce5b1020,0x8ea9,0x11d0,0xa4, 0xec, 0x00, 0xa0, 0xc9,0x06,0x29,0x10};

GUID TopDynGuid = {0xce5b1023,0x8ea9,0x11d0,0xa4, 0xec, 0x00, 0xa0, 0xc9,0x06,0x29,0x10};
GUID RSIGuid = {0xce5b1023,0x8ea9,0x11d0,0xa4, 0xec, 0x00, 0xa0, 0xc9,0x06,0x29,0x10};
GUID RSBGuid = {0xce5b1024,0x8ea9,0x11d0,0xa4, 0xec, 0x00, 0xa0, 0xc9,0x06,0x29,0x10};

// both
GUID SIGuid = {0xce5b1021,0x8ea9,0x11d0,0xa4, 0xec, 0x00, 0xa0, 0xc9,0x06,0x29,0x10};
GUID SBGuid = {0xce5b1022,0x8ea9,0x11d0,0xa4, 0xec, 0x00, 0xa0, 0xc9,0x06,0x29,0x10};
GUID UnRegGuid = {0xce5b1025,0x8ea9,0x11d0,0xa4, 0xec, 0x00, 0xa0, 0xc9,0x06,0x29,0x10};


GUID GuidNull = 
{ 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 } };

ULONG BufferSize = 4096;
BYTE Buffer[4096];


void EventCallbackRoutine0(PWNODE_HEADER WnodeHeader, ULONG Context);
void EventCallbackRoutine1(PWNODE_HEADER WnodeHeader, ULONG Context);
void EventCallbackRoutine2(PWNODE_HEADER WnodeHeader, ULONG Context);
void EventCallbackRoutine3(PWNODE_HEADER WnodeHeader, ULONG Context);
void EventCallbackRoutine4(PWNODE_HEADER WnodeHeader, ULONG Context);


typedef BOOLEAN (*QADVALIDATION)(
    TESTGUID *TestGuid,
    PVOID Buffer, 
    ULONG BufferSize
);

typedef ULONG (*QSINSET)(
    TESTGUID *TestGuid,
    PULONG *DataList,
    PULONG DataListSize,
    PBYTE *ValueBuffer, 
    ULONG *ValueBufferSize, 
    ULONG Instance
);

typedef ULONG (*QSITSET)(
    TESTGUID *TestGuid,
    PULONG *DataList,
    PULONG DataListSize,
    PBYTE *ValueBuffer, 
    ULONG *ValueBufferSize, 
    ULONG Instance, 
    ULONG ItemId
    );

typedef BOOLEAN (*QSINTVALIDATION)(
    TESTGUID *TestGuid,
    PULONG *DataList,
    PULONG DataListSize,
    PVOID Buffer, 
    ULONG BufferSize, 
    ULONG Instance
    );

typedef PWCHAR (*GETINSTANCENAME)(
    TESTGUID *TestGuid,
    ULONG Instance
    );

typedef struct tagTESTGUID
{
    LPGUID Guid;
    HANDLE Handle;

    PULONG DataListSize;
    
    PULONG *InitDataList;
    PULONG *SINDataList;
    PULONG *SITDataList;
    
    PWCHAR *InstanceNames;
    
    QADVALIDATION QADValidation;
    ULONG QADFlags;
    
    ULONG InstanceCount;    
    GETINSTANCENAME GetInstanceName;
    
    ULONG QSINTFlags;
    QSINTVALIDATION QSINTValidation;
    
    QSINSET QSINSet;

    ULONG ItemCount;
    QSITSET QSITSet;

    ULONG EventsSent;
    ULONG EventsReceived;
    NOTIFICATIONCALLBACK NotificationCallback;
} TESTGUID;

//
// Common validation/set routines
ULONG QSINSet(
    TESTGUID *TestGuid,
    PULONG *DataList,
    PULONG DataListSize,
    PBYTE *ValueBuffer, 
    ULONG *ValueBufferSize, 
    ULONG Instance
)
{
    *ValueBuffer = (PBYTE)DataList[Instance];
    *ValueBufferSize = DataListSize[Instance];

    return(ERROR_SUCCESS);
}

BOOLEAN QSINTValidate(
    TESTGUID *TestGuid,
    PULONG *DataList,
    PULONG DataListSize,
    PVOID Buffer, 
    ULONG BufferSize, 
    ULONG Instance
    )
{
    PWNODE_SINGLE_INSTANCE Wnode = Buffer;
    PULONG Data;
    PULONG NameOffsets;
    PWCHAR Name;
    ULONG NameLen;
    
    if ((Wnode->WnodeHeader.BufferSize == 0) ||
        (Wnode->WnodeHeader.ProviderId == 0) ||
        (Wnode->WnodeHeader.Version != 1) ||
#ifndef MEMPHIS		
        (Wnode->WnodeHeader.TimeStamp.HighPart == 0) ||
        (Wnode->WnodeHeader.TimeStamp.LowPart == 0) ||
#endif		
        (memcmp(&Wnode->WnodeHeader.Guid, TestGuid->Guid, sizeof(GUID)) != 0) ||
        (Wnode->WnodeHeader.Flags != TestGuid->QSINTFlags) ||
        (Wnode->SizeDataBlock != DataListSize[Instance]))
    {
        return(FALSE);
    }
    
    Data = (ULONG *)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
    if (memcmp(Data, DataList[Instance], DataListSize[Instance]) != 0)
    {
        return(FALSE);
    }
    Name = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
    NameLen = wcslen(TestGuid->InstanceNames[Instance]) * sizeof(WCHAR);
    if (((*Name != NameLen) && (*Name != NameLen+sizeof(WCHAR))) ||
            (memcmp(++Name, TestGuid->InstanceNames[Instance], NameLen) != 0))
    {
        return(FALSE);
    }
    
    return(TRUE);
}

ULONG QSITSet(
    TESTGUID *TestGuid,
    PULONG *DataList,
    PULONG DataListSize,
    PBYTE *ValueBuffer, 
    ULONG *ValueBufferSize, 
    ULONG Instance, 
    ULONG ItemId
    )
{
    *ValueBuffer = (PBYTE)(DataList[Instance] + ItemId);
    *ValueBufferSize = sizeof(ULONG);
    return(ERROR_SUCCESS);
}

PWCHAR GetInstanceName(
    TESTGUID *TestGuid,
    ULONG Instance
    )
{
    return(TestGuid->InstanceNames[Instance]);
}





//
// Guid 20
ULONG Values20Init_1[4] = { 1,2,3,4};
ULONG Values20Init_2[4] = { 5,6,7,8};

PULONG Values20Init_List[4] =
{
    Values20Init_1,
    Values20Init_2,
    Values20Init_1,
    Values20Init_2
};

ULONG Values20_Size[4] = { 0x10,0x10,0x10,0x10 };

ULONG Values20_1[4] = { 0x11111111,0x22222222,0x33333333,0x44444444};
ULONG Values20_2[4] = { 0x55555555,0x66666666,0x77777777,0x88888888};
ULONG Values20_3[4] = { 0x12345678,0x23456789,0x3456789A,0x456789AB};
ULONG Values20_4[4] = { 0x56789ABC,0x6789ABCD,0x789ABCDE,0x89ABCDEF};
PULONG Values20_List[4] = 
{
    Values20_1,
    Values20_2,
    Values20_3,
    Values20_4
};

ULONG Values20T_1[4] = { 0x1000,0x2000,0x3000,0x4000};
ULONG Values20T_2[4] = { 0x50000000,0x60000000,0x70000000,0x80000000};
ULONG Values20T_3[4] = { 0x90000000,0xA0000000,0xB0000000,0xC0000000};
ULONG Values20T_4[4] = { 0x0000D000,0x0000E000,0x0000F000,0x00000000};
PULONG Values20T_List[4] = 
{
    Values20_1,
    Values20_2,
    Values20_3,
    Values20_4
};


PWCHAR InstanceName20[4] = 
{
    L"InstanceX",
    L"InstanceY",
    L"InstanceA",
    L"InstanceB"
};

BOOLEAN QADValidate20(
    TESTGUID *TestGuid,
    PVOID Buffer, 
    ULONG BufferSize
)
{
    PWNODE_ALL_DATA Wnode = Buffer;
    PULONG Data;
    PULONG NameOffsets;
    PWCHAR Name;
    ULONG NameLen;
    ULONG i;
    
    if ((Wnode->WnodeHeader.BufferSize == 0) ||
        (Wnode->WnodeHeader.ProviderId == 0) ||
        (Wnode->WnodeHeader.Version != 1) ||
#ifndef MEMPHIS
        (Wnode->WnodeHeader.TimeStamp.HighPart == 0) ||
        (Wnode->WnodeHeader.TimeStamp.LowPart == 0) ||
#endif		
        (memcmp(&Wnode->WnodeHeader.Guid, TestGuid->Guid, sizeof(GUID)) != 0) ||
        (Wnode->WnodeHeader.Flags != TestGuid->QADFlags) ||
        (Wnode->InstanceCount != 2) ||
        (Wnode->FixedInstanceSize != 0x10))
    {
        return(FALSE);
    }
    
    Data = (ULONG *)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
    for (i = 0; i < 2; i++)
    {
        if (memcmp(Data, TestGuid->InitDataList[i], TestGuid->DataListSize[i]) != 0)
        {
            return(FALSE);
        }
        
        Data += 4;
    }
    
    NameOffsets = (ULONG *)OffsetToPtr(Wnode, Wnode->OffsetInstanceNameOffsets);
    for (i = 0; i < 2; i++)
    {
        Name = (PWCHAR)OffsetToPtr(Wnode, *NameOffsets++);
        NameLen = wcslen(TestGuid->InstanceNames[i]) * sizeof(WCHAR);
        if (((*Name != NameLen) && (*Name != NameLen+sizeof(WCHAR))) ||
            ((memcmp(++Name, TestGuid->InstanceNames[i], NameLen) != 0) &&
             (memcmp(Name, TestGuid->InstanceNames[i+2], NameLen) != 0)))
        {
            return(FALSE);
        }
    }
    
    //
    // Get second wnode in chain
    if (Wnode->WnodeHeader.Linkage == 0)
    {
        return(FALSE);
    }
    Wnode = (PWNODE_ALL_DATA)OffsetToPtr(Wnode, Wnode->WnodeHeader.Linkage);
    
    if ((Wnode->WnodeHeader.BufferSize == 0) ||
        (Wnode->WnodeHeader.ProviderId == 0) ||
        (Wnode->WnodeHeader.Version != 1) ||
#ifndef MEMPHIS
        (Wnode->WnodeHeader.TimeStamp.HighPart == 0) ||
        (Wnode->WnodeHeader.TimeStamp.LowPart == 0) ||
#endif		
        (memcmp(&Wnode->WnodeHeader.Guid, TestGuid->Guid, sizeof(GUID)) != 0) ||
        (Wnode->WnodeHeader.Flags != TestGuid->QADFlags) ||
        (Wnode->InstanceCount != 2) ||
        (Wnode->FixedInstanceSize != 0x10))
    {
        return(FALSE);
    }
    
    Data = (ULONG *)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
    for (i = 2; i < 4; i++)
    {
        if (memcmp(Data, TestGuid->InitDataList[i], TestGuid->DataListSize[i]) != 0)
        {
            return(FALSE);
        }
        
        Data += 4;
    }
    
    NameOffsets = (ULONG *)OffsetToPtr(Wnode, Wnode->OffsetInstanceNameOffsets);
    for (i = 2; i < 4; i++)
    {
        Name = (PWCHAR)OffsetToPtr(Wnode, *NameOffsets++);
        NameLen = wcslen(TestGuid->InstanceNames[i])  * sizeof(WCHAR);
        if (((*Name != NameLen) && (*Name != NameLen+sizeof(WCHAR))) ||
            ((memcmp(++Name, TestGuid->InstanceNames[i], NameLen) != 0) &&
             (memcmp(Name, TestGuid->InstanceNames[i-2], NameLen) != 0)))
        {
            return(FALSE);
        }
    }
    
    
    if (Wnode->WnodeHeader.Linkage != 0)
    {
        return(FALSE);
    }
        
    return(TRUE);
}

//
// Guid 21

PWCHAR InstanceName21[4] = 
{
    L"InstanceX",
    L"InstanceY",
    L"InstanceA",
    L"InstanceB"
};


//
// Guid 22
PWCHAR InstanceName22[4] = 
{
    L"Instance2",
    L"Instance3",
    L"Instance0",
    L"Instance1"
};


//
// Guid 23
PWCHAR InstanceName23[4] = 
{
    L"InstanceA",
    L"InstanceB"
};

BOOLEAN QADValidate23(
    TESTGUID *TestGuid,
    PVOID Buffer, 
    ULONG BufferSize
)
{
    PWNODE_ALL_DATA Wnode = Buffer;
    PULONG Data;
    PULONG NameOffsets;
    PWCHAR Name;
    ULONG NameLen;
    ULONG i;
    
    if ((Wnode->WnodeHeader.BufferSize == 0) ||
        (Wnode->WnodeHeader.ProviderId == 0) ||
        (Wnode->WnodeHeader.Version != 1) ||
#ifndef MEMPHIS
        (Wnode->WnodeHeader.TimeStamp.HighPart == 0) ||
        (Wnode->WnodeHeader.TimeStamp.LowPart == 0) ||
#endif		
        (memcmp(&Wnode->WnodeHeader.Guid, TestGuid->Guid, sizeof(GUID)) != 0) ||
        (Wnode->WnodeHeader.Flags != TestGuid->QADFlags) ||
        (Wnode->InstanceCount != 2) ||
        (Wnode->FixedInstanceSize != 0x10))
    {
        return(FALSE);
    }
    
    Data = (ULONG *)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
    for (i = 0; i < 2; i++)
    {
        if (memcmp(Data, TestGuid->InitDataList[i], TestGuid->DataListSize[i]) != 0)
        {
            return(FALSE);
        }
        
        Data += 4;
    }
    
    NameOffsets = (ULONG *)OffsetToPtr(Wnode, Wnode->OffsetInstanceNameOffsets);
    for (i = 0; i < 2; i++)
    {
        Name = (PWCHAR)OffsetToPtr(Wnode, *NameOffsets++);
        NameLen = wcslen(TestGuid->InstanceNames[i]) * sizeof(WCHAR);
        if (((*Name != NameLen) && (*Name != NameLen+sizeof(WCHAR))) ||
            (memcmp(++Name, TestGuid->InstanceNames[i], NameLen) != 0))
        {
            return(FALSE);
        }
    }
    
    if (Wnode->WnodeHeader.Linkage != 0)
    {
        return(FALSE);
    }
        
    return(TRUE);
}


//
// Guid 24
PWCHAR InstanceName24[4] = 
{
    L"Instance0",
    L"Instance1"
};


#define TestCount 5
TESTGUID TestList[TestCount] = {
    
    { 
        &BotDynGuid, 
        0, 
            
        Values20_Size,
            
        Values20Init_List,            
        Values20_List,            
        Values20T_List,
            
        InstanceName20,            
            
        QADValidate20, 
        (WNODE_FLAG_ALL_DATA | WNODE_FLAG_FIXED_INSTANCE_SIZE),
            
        4, 
            
        GetInstanceName,
            
        WNODE_FLAG_SINGLE_INSTANCE,
        QSINTValidate,
            
        QSINSet,
            
        4,
            
        QSITSet,
            
        0,
        0,
        EventCallbackRoutine0
    },
        
    { 
        &SIGuid, 
        0, 
            
        Values20_Size,
            
        Values20Init_List,            
        Values20_List,            
        Values20T_List,
            
        InstanceName21,            
            
        QADValidate20, 
        (WNODE_FLAG_ALL_DATA | WNODE_FLAG_FIXED_INSTANCE_SIZE | WNODE_FLAG_STATIC_INSTANCE_NAMES),
            
        4, 
            
        GetInstanceName,
            
        WNODE_FLAG_SINGLE_INSTANCE | WNODE_FLAG_STATIC_INSTANCE_NAMES,
        QSINTValidate,
            
        QSINSet,
            
        4,
            
        QSITSet,
            
        0,
        0,
        EventCallbackRoutine1
            
    },
        
    { 
        &SBGuid, 
        0, 
            
        Values20_Size,
            
        Values20Init_List,            
        Values20_List,            
        Values20T_List,
            
        InstanceName22,            
            
        QADValidate20, 
        (WNODE_FLAG_ALL_DATA | WNODE_FLAG_FIXED_INSTANCE_SIZE | WNODE_FLAG_STATIC_INSTANCE_NAMES),
            
        4, 
            
        GetInstanceName,
            
        WNODE_FLAG_SINGLE_INSTANCE | WNODE_FLAG_STATIC_INSTANCE_NAMES,
        QSINTValidate,
            
        QSINSet,
            
        4,
            
        QSITSet,
            
        0,
        0,
        EventCallbackRoutine2                        
    },
        
    { 
        &RSIGuid, 
        0, 
            
        Values20_Size,
            
        Values20Init_List,            
        Values20_List,            
        Values20T_List,
            
        InstanceName23,            
            
        QADValidate23, 
        (WNODE_FLAG_ALL_DATA | WNODE_FLAG_FIXED_INSTANCE_SIZE | WNODE_FLAG_STATIC_INSTANCE_NAMES),
            
        2, 
            
        GetInstanceName,
            
        WNODE_FLAG_SINGLE_INSTANCE | WNODE_FLAG_STATIC_INSTANCE_NAMES,
        QSINTValidate,
            
        QSINSet,
            
        4,
            
        QSITSet,
            
        0,
        0,
        EventCallbackRoutine3
            
    },
        
    { 
        &RSBGuid, 
        0, 
            
        Values20_Size,
            
        Values20Init_List,            
        Values20_List,            
        Values20T_List,
            
        InstanceName24,            
            
        QADValidate23, 
        (WNODE_FLAG_ALL_DATA | WNODE_FLAG_FIXED_INSTANCE_SIZE | WNODE_FLAG_STATIC_INSTANCE_NAMES),
            
        2, 
            
        GetInstanceName,
            
        WNODE_FLAG_SINGLE_INSTANCE | WNODE_FLAG_STATIC_INSTANCE_NAMES,
        QSINTValidate,
            
        QSINSet,
            
        4,
            
        QSITSet,
            
        0,
        0,
        EventCallbackRoutine4            
    },
        
};

ULONG QADTest(
    ULONG FirstTestNumber,
    ULONG LastTestNumber
    )
{
    ULONG i;
    ULONG Status;

    
    for (i = FirstTestNumber; i < LastTestNumber; i++)
    {
        Status = WMIOpenBlock(NULL,
                              TestList[i].Guid,
                              &TestList[i].Handle);
                          
        if (Status != ERROR_SUCCESS)
        {
            printf("Error: QADTest: Couldn't open Handle %d %x\n", i, Status);
            TestList[i].Handle = (HANDLE)NULL;
        }                              
    }

    for (i = FirstTestNumber; i < LastTestNumber;i++)
    {
        if (TestList[i].Handle != (HANDLE)NULL)
        {
            BufferSize = sizeof(Buffer);
            Status = WMIQueryAllData(TestList[i].Handle,
                                 &BufferSize,
                                 Buffer);
                             
            if (Status == ERROR_SUCCESS)
            {
                if (! (*TestList[i].QADValidation)(&TestList[i], Buffer, BufferSize))
                {
                    printf("ERROR: QADValidation %d failed\n", i);
                }
            } else {
                printf("Error TestList WMIQueryAllData %d failed %x\n", i, Status);
            }
        }                
    }

    for (i = FirstTestNumber; i < LastTestNumber;i++)
    {
        if (TestList[i].Handle != (HANDLE)NULL)
        {
            WMICloseBlock(TestList[i].Handle);
        }
    }        
    return(ERROR_SUCCESS);
}

ULONG QSINTest(
    ULONG FirstTestNumber,
    ULONG LastTestNumber
    )
{
    ULONG i,j;
    ULONG Status;
    ULONG InstanceCount;
    PWCHAR InstanceName;
    PBYTE ValueBuffer;
    ULONG ValueBufferSize;
    
    for (i = FirstTestNumber; i < LastTestNumber; i++)
    {
        Status = WMIOpenBlock(NULL,
                              TestList[i].Guid,
                              &TestList[i].Handle);
                          
        if (Status != ERROR_SUCCESS)
        {
            printf("Error: QSINTest: Couldn't open Handle %d %x\n", i, Status);
            TestList[i].Handle = (HANDLE)NULL;
        }                              
        
        InstanceCount = TestList[i].InstanceCount;
        for (j = 0; j < InstanceCount; j++)
        {
            InstanceName = ((*TestList[i].GetInstanceName)(&TestList[i], j));

            //
            // Initial value check
            BufferSize = sizeof(Buffer);
            Status = WMIQuerySingleInstance(TestList[i].Handle,
                                            InstanceName,
                                            &BufferSize,
                                            Buffer);
            if (Status == ERROR_SUCCESS)
            {
                if (! (*TestList[i].QSINTValidation)(&TestList[i], 
                                                     TestList[i].InitDataList,
                                                     TestList[i].DataListSize,
                                                     Buffer, BufferSize, j))
                {
                    printf("ERROR: QSINTest Init %d/%d Validation failed %x\n", i,j,Status);
                }
            } else {
                printf("Error QSINTest WMIQuerySingleInstance %d/%d failed %x\n", i, j, Status);
            }
            
            
            //
            // Set new values
            (*TestList[i].QSINSet)(&TestList[i],
                                   TestList[i].SINDataList,
                                   TestList[i].DataListSize,
                                   &ValueBuffer, &ValueBufferSize, j);
            Status = WMISetSingleInstance(TestList[i].Handle,
                                          InstanceName,
                                          1,
                                          ValueBufferSize,
                                          ValueBuffer);
            if (Status != ERROR_SUCCESS)
            {
                printf("ERROR: QSINTest WMISetSingleInstance %d/%d failed %x\n", i,j,Status);
            }
                                      

            //
            // Check new values set properly
            BufferSize = sizeof(Buffer);
            Status = WMIQuerySingleInstance(TestList[i].Handle,
                                            InstanceName,
                                            &BufferSize,
                                            Buffer);
            if (Status == ERROR_SUCCESS)
            {                                            
                if (!(*TestList[i].QSINTValidation)(&TestList[i], 
                                                    TestList[i].SINDataList,
                                                    TestList[i].DataListSize,
                                                    Buffer, BufferSize, j))
                {
                    printf("ERROR: QSINTTest %d/%d Validation # 2 failed %x\n", i,j,Status);
                }
            } else {                
                printf("ERROR: QSINTest: WMIQuerySingleInstance %d/%d failed %x\n", i,j,Status);
            }
            
            //
            // Reset to initial values
            (*TestList[i].QSINSet)(&TestList[i], 
                                     TestList[i].InitDataList,
                                    TestList[i].DataListSize,
                                   &ValueBuffer, &ValueBufferSize, j);
            Status = WMISetSingleInstance(TestList[i].Handle,
                                          InstanceName,
                                          1,
                                          ValueBufferSize,
                                          ValueBuffer);
            if (Status != ERROR_SUCCESS)
            {
                printf("ERROR: QSINTTest WMISetSingleInstance Init %d/%d failed %x\n", i,j,Status);
            }
                                      

            //
            // Check reset to initial values
            BufferSize = sizeof(Buffer);
            Status = WMIQuerySingleInstance(TestList[i].Handle,
                                            InstanceName,
                                            &BufferSize,
                                            Buffer);
            if (Status == ERROR_SUCCESS)
            {                                            
                if (!(*TestList[i].QSINTValidation)(&TestList[i], 
                                                    TestList[i].InitDataList,
                                                    TestList[i].DataListSize,
                                                    Buffer, BufferSize, j))
                {
                    printf("ERROR: QSINT %d/%d Validation #2 failed %x\n", i,j,Status);
                }
            } else {                
                printf("ERROR: WMIQuerySingleInstance # 2 %d/%d failed %x\n", i,j,Status);
            }
            
        }        
    }
    for (i = FirstTestNumber; i < LastTestNumber;i++)
    {
        if (TestList[i].Handle != (HANDLE)NULL)
        {
            WMICloseBlock(TestList[i].Handle);
        }
    }        
    return(ERROR_SUCCESS);
}

ULONG QSITTest(
    ULONG FirstTestNumber,
    ULONG LastTestNumber
    )
{
    ULONG i,j,k;
    ULONG Status;
    ULONG InstanceCount;
    PWCHAR InstanceName;
    ULONG ItemCount;
    PBYTE ValueBuffer;
    ULONG ValueBufferSize;
    
    for (i = FirstTestNumber; i < LastTestNumber; i++)
    {
        Status = WMIOpenBlock(NULL,
                              TestList[i].Guid,
                              &TestList[i].Handle);
                          
        if (Status != ERROR_SUCCESS)
        {
            printf("Error: QSITTest: Couldn't open Handle %d %x\n", i, Status);
            TestList[i].Handle = (HANDLE)NULL;
        }                              
        
        InstanceCount = TestList[i].InstanceCount;
        for (j = 0; j < InstanceCount; j++)
        {
            InstanceName = (*TestList[i].GetInstanceName)(&TestList[i],j);            
            
            //
            // Set new values
            ItemCount = TestList[i].ItemCount;
            for (k = 0; k < ItemCount; k++)
            {                
                (*TestList[i].QSITSet)(&TestList[i], 
                                        TestList[i].SITDataList,
                                       TestList[i].DataListSize,
                                       &ValueBuffer, &ValueBufferSize, j,k);
                Status = WMISetSingleItem(TestList[i].Handle,
                                          InstanceName,
                                          k,
                                          1,
                                          ValueBufferSize,
                                          ValueBuffer);
                if (Status != ERROR_SUCCESS)
                {
                    printf("ERROR: QSIT WMISetSingleItem %d/%d/%d failed %x\n", i,j,k,Status);
                }                                        
            }

            //
            // Check new values set properly
            BufferSize = sizeof(Buffer);
            Status = WMIQuerySingleInstance(TestList[i].Handle,
                                            InstanceName,
                                            &BufferSize,
                                            Buffer);
            if (Status == ERROR_SUCCESS)
            {                                            
                if (!(*TestList[i].QSINTValidation)(&TestList[i], 
                                                    TestList[i].SITDataList,
                                                    TestList[i].DataListSize,
                                                    Buffer, BufferSize, j))
                {
                    printf("ERROR: QSIT %d/%d Validation failed %x\n", i,j,Status);
                }
            } else {                
                printf("ERROR: QSIT %d/%d QMIQuerySingleInstance failed %x\n", i,j,Status);
            }
            
            //
            // Reset to initial values
            (*TestList[i].QSINSet)(&TestList[i],
                                   TestList[i].InitDataList,
                                   TestList[i].DataListSize,
                                   &ValueBuffer, &ValueBufferSize, j);
            Status = WMISetSingleInstance(TestList[i].Handle,
                                          InstanceName,
                                          1,
                                          ValueBufferSize,
                                          ValueBuffer);
            if (Status != ERROR_SUCCESS)
            {
                printf("ERROR: QSIT WMISetSingleInstance %d/%d failed %x\n", i,j,Status);
            }                                      

            //
            // Check reset to initial values
            BufferSize = sizeof(Buffer);
            Status = WMIQuerySingleInstance(TestList[i].Handle,
                                            InstanceName,
                                            &BufferSize,
                                            Buffer);
            if (Status == ERROR_SUCCESS)
            {                                            
                if (!(*TestList[i].QSINTValidation)(&TestList[i],
                                                    TestList[i].InitDataList,
                                                    TestList[i].DataListSize,
                                                    Buffer, BufferSize, j))
                {
                    printf("ERROR: QSIT %d/%d Validation # 2 failed %x\n", i,j,Status);
                }
            } else {                
                printf("ERROR: QSIT WMISetSingleInstance # 2 %d/%d  failed %x\n", i,j,Status);
            }
            
        }
    }
    
    for (i = FirstTestNumber; i < LastTestNumber;i++)
    {
        if (TestList[i].Handle != (HANDLE)NULL)
        {
            WMICloseBlock(TestList[i].Handle);
        }
    }        
    return(ERROR_SUCCESS);
}

#define EventDeviceName TEXT("\\\\.\\STBTest")
#define EventInstanceName L"InstanceA"

ULONG EventsReceived, EventsSent;
ULONG GlobalEventsReceived, GlobalEventsSent;


void GlobalEventCallbackRoutine(PWNODE_HEADER WnodeHeader, ULONG Context)
{
    PULONG Data;
    PWNODE_SINGLE_INSTANCE Wnode = (PWNODE_SINGLE_INSTANCE)WnodeHeader;
    PWCHAR Name;
    ULONG NameLen;
    
    GlobalEventsReceived++;

    if (Context != 0x12345678)
    {
        printf("Event validate failed - context\n");
    }
    
    if ((Wnode->WnodeHeader.BufferSize == 0) ||
        (Wnode->WnodeHeader.ProviderId == 0) ||
        (Wnode->WnodeHeader.Version != 1) ||
#ifndef MEMPHIS
        (Wnode->WnodeHeader.TimeStamp.HighPart == 0) ||
        (Wnode->WnodeHeader.TimeStamp.LowPart == 0) ||
#endif		
        (Wnode->WnodeHeader.Flags != (WNODE_FLAG_EVENT_ITEM | WNODE_FLAG_SINGLE_INSTANCE)) ||
        (Wnode->SizeDataBlock != 4))
    {
        printf("Global Event validation failed #1\n");
        return;
    }
    
    Data = (ULONG *)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
//    if (Data[0] != Wnode->WnodeHeader.Linkage)
//    {
//        printf("Global Event validation failed #2\n");
//        return;
//    }
    Name = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
    NameLen = wcslen(EventInstanceName) * sizeof(WCHAR);
    if (((*Name != NameLen) && (*Name != NameLen+sizeof(WCHAR))) ||
            (memcmp(++Name, EventInstanceName, NameLen) != 0))
    {
        printf("Global Event validation failed #3\n");
    }
}


void EventCallbackRoutine0(PWNODE_HEADER WnodeHeader, ULONG Context)
{
    PULONG Data;
    PWNODE_SINGLE_INSTANCE Wnode = (PWNODE_SINGLE_INSTANCE)WnodeHeader;
    PWCHAR Name;
    ULONG NameLen;
    
    if (Context != 0xABCDEF01)
    {
        printf("Event validate failed - context\n");
    }
    
    TestList[0].EventsReceived++;
    if ((Wnode->WnodeHeader.BufferSize == 0) ||
        (Wnode->WnodeHeader.ProviderId == 0) ||
        (Wnode->WnodeHeader.Version != 1) ||
#ifndef MEMPHIS
        (Wnode->WnodeHeader.TimeStamp.HighPart == 0) ||
        (Wnode->WnodeHeader.TimeStamp.LowPart == 0) ||
#endif		
        (memcmp(&Wnode->WnodeHeader.Guid, &BotDynGuid, sizeof(GUID)) != 0) ||
        (Wnode->WnodeHeader.Flags != (WNODE_FLAG_EVENT_ITEM | WNODE_FLAG_SINGLE_INSTANCE)) ||
        (Wnode->SizeDataBlock != 4))
    {
        printf("Event validation failed #1\n");
    }
    
    Data = (ULONG *)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
//    if (Data[0] != Wnode->WnodeHeader.Linkage)
//    {
//        printf("Event validation failed #2\n");
//    }
//    Name = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
//    NameLen = wcslen(EventInstanceName) * sizeof(WCHAR);
//    
//    if (((*Name != NameLen) && (*Name != NameLen+sizeof(WCHAR))) ||
//            (memcmp(++Name, EventInstanceName, NameLen) != 0))
//    {
//        printf("Event validation failed #3\n");
//    }

}

void EventCallbackRoutine1(PWNODE_HEADER WnodeHeader, ULONG Context)
{
    PULONG Data;
    PWNODE_SINGLE_INSTANCE Wnode = (PWNODE_SINGLE_INSTANCE)WnodeHeader;
    PWCHAR Name;
    ULONG NameLen;
    
    if (Context != 0xABCDEF01)
    {
        printf("Event validate failed - context\n");
    }
    
    TestList[1].EventsReceived++;
    if ((Wnode->WnodeHeader.BufferSize == 0) ||
        (Wnode->WnodeHeader.ProviderId == 0) ||
        (Wnode->WnodeHeader.Version != 1) ||
#ifndef MEMPHIS
        (Wnode->WnodeHeader.TimeStamp.HighPart == 0) ||
        (Wnode->WnodeHeader.TimeStamp.LowPart == 0) ||
#endif		
        (memcmp(&Wnode->WnodeHeader.Guid, &SIGuid, sizeof(GUID)) != 0) ||
        (Wnode->WnodeHeader.Flags != (WNODE_FLAG_EVENT_ITEM | WNODE_FLAG_SINGLE_INSTANCE)) ||
        (Wnode->SizeDataBlock != 4))
    {
        printf("Event validation failed #1\n");
    }
    
    Data = (ULONG *)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
//    if (Data[0] != Wnode->WnodeHeader.Linkage)
//    {
//        printf("Event validation failed #2\n");
//    }
    Name = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
    NameLen = wcslen(EventInstanceName) * sizeof(WCHAR);
    if (((*Name != NameLen) && (*Name != NameLen+sizeof(WCHAR))) ||
            (memcmp(++Name, EventInstanceName, NameLen) != 0))
    {
        printf("Event validation failed #3\n");
    }
}


void EventCallbackRoutine2(PWNODE_HEADER WnodeHeader, ULONG Context)
{
    PULONG Data;
    PWNODE_SINGLE_INSTANCE Wnode = (PWNODE_SINGLE_INSTANCE)WnodeHeader;
    PWCHAR Name;
    ULONG NameLen;
    
    if (Context != 0xABCDEF01)
    {
        printf("Event validate failed - context\n");
    }
    
    TestList[2].EventsReceived++;
    if ((Wnode->WnodeHeader.BufferSize == 0) ||
        (Wnode->WnodeHeader.ProviderId == 0) ||
        (Wnode->WnodeHeader.Version != 1) ||
#ifndef MEMPHIS
        (Wnode->WnodeHeader.TimeStamp.HighPart == 0) ||
        (Wnode->WnodeHeader.TimeStamp.LowPart == 0) ||
#endif		
        (memcmp(&Wnode->WnodeHeader.Guid, &SBGuid, sizeof(GUID)) != 0) ||
        (Wnode->WnodeHeader.Flags != (WNODE_FLAG_EVENT_ITEM | WNODE_FLAG_SINGLE_INSTANCE)) ||
        (Wnode->SizeDataBlock != 4))
    {
        printf("Event validation failed #1\n");
    }
    
    Data = (ULONG *)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
//    if (Data[0] != Wnode->WnodeHeader.Linkage)
//    {
//        printf("Event validation failed #2\n");
//    }
    Name = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
    NameLen = wcslen(EventInstanceName) * sizeof(WCHAR);
    if (((*Name != NameLen) && (*Name != NameLen+sizeof(WCHAR))) ||
            (memcmp(++Name, EventInstanceName, NameLen) != 0))
    {
        printf("Event validation failed #3\n");
    }
}

void EventCallbackRoutine3(PWNODE_HEADER WnodeHeader, ULONG Context)
{
    PULONG Data;
    PWNODE_SINGLE_INSTANCE Wnode = (PWNODE_SINGLE_INSTANCE)WnodeHeader;
    PWCHAR Name;
    ULONG NameLen;
    
    if (Context != 0xABCDEF01)
    {
        printf("Event validate failed - context\n");
    }
    
    TestList[3].EventsReceived++;
    if ((Wnode->WnodeHeader.BufferSize == 0) ||
        (Wnode->WnodeHeader.ProviderId == 0) ||
        (Wnode->WnodeHeader.Version != 1) ||
#ifndef MEMPHIS
        (Wnode->WnodeHeader.TimeStamp.HighPart == 0) ||
        (Wnode->WnodeHeader.TimeStamp.LowPart == 0) ||
#endif		
        (memcmp(&Wnode->WnodeHeader.Guid, &RSIGuid, sizeof(GUID)) != 0) ||
        (Wnode->WnodeHeader.Flags != (WNODE_FLAG_EVENT_ITEM | WNODE_FLAG_SINGLE_INSTANCE)) ||
        (Wnode->SizeDataBlock != 4))
    {
        printf("Event validation failed #1\n");
    }
    
    Data = (ULONG *)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
//    if (Data[0] != Wnode->WnodeHeader.Linkage)
//    {
//        printf("Event validation failed #2\n");
//    }
    Name = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
    NameLen = wcslen(EventInstanceName) * sizeof(WCHAR);
    if (((*Name != NameLen) && (*Name != NameLen+sizeof(WCHAR))) ||
            (memcmp(++Name, EventInstanceName, NameLen) != 0))
    {
        printf("Event validation failed #3\n");
    }
}


void EventCallbackRoutine4(PWNODE_HEADER WnodeHeader, ULONG Context)
{
    PULONG Data;
    PWNODE_SINGLE_INSTANCE Wnode = (PWNODE_SINGLE_INSTANCE)WnodeHeader;
    PWCHAR Name;
    ULONG NameLen;

    if (Context != 0xABCDEF01)
    {
        printf("Event validate failed - context\n");
    }
    
    TestList[4].EventsReceived++;
    if ((Wnode->WnodeHeader.BufferSize == 0) ||
        (Wnode->WnodeHeader.ProviderId == 0) ||
        (Wnode->WnodeHeader.Version != 1) ||
#ifndef MEMPHIS
        (Wnode->WnodeHeader.TimeStamp.HighPart == 0) ||
        (Wnode->WnodeHeader.TimeStamp.LowPart == 0) ||
#endif		
        (memcmp(&Wnode->WnodeHeader.Guid, &RSBGuid, sizeof(GUID)) != 0) ||
        (Wnode->WnodeHeader.Flags != (WNODE_FLAG_EVENT_ITEM | WNODE_FLAG_SINGLE_INSTANCE)) ||
        (Wnode->SizeDataBlock != 4))
    {
        printf("Event validation failed #1\n");
    }
    
    Data = (ULONG *)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
//    if (Data[0] != Wnode->WnodeHeader.Linkage)
//    {
//        printf("Event validation failed #2\n");
//    }
    Name = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
    NameLen = wcslen(EventInstanceName) * sizeof(WCHAR);
    if (((*Name != NameLen) && (*Name != NameLen+sizeof(WCHAR))) ||
            (memcmp(++Name, EventInstanceName, NameLen) != 0))
    {
        printf("Event validation failed #3\n");
    }
}



void EventTest(
    ULONG Unused1,
    ULONG Unused2
    )
{
    HANDLE STBHandle;
    BOOLEAN f;
    ULONG retsize;
    ULONG Status;
    ULONG WnodeEventSize;
    PWNODE_SINGLE_INSTANCE Wnode;
    PWCHAR InstanceNamePtr;
    PULONG DataPtr;
    ULONG i,j;
    ULONG Size;
    HANDLE DataBlockHandle;
    
    Status = WMIOpenBlock(NULL,
                          &SIGuid,
                          &DataBlockHandle);
    if (Status != ERROR_SUCCESS)
    {
        printf("ERROR: Couldn't open data block %x\n", Status);
        return;
    }
    
    
    Size = sizeof(WNODE_SINGLE_INSTANCE) + 
           sizeof(EventInstanceName) + sizeof(WCHAR) + 
           1 * sizeof(ULONG);
    Wnode = malloc(Size);
    if (Wnode == NULL)
    {
        printf("ERROR: couldn't alloc mem for event\n");
        return;
    }
    
    STBHandle = CreateFile(
                     EventDeviceName,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     );
    if (STBHandle == (HANDLE)-1)
    {
        printf("ERROR - couldn't open Event device file %x\n",
                GetLastError());
        free(Wnode);
        return;
    }
        
    Status = WMINotificationRegistration(&GuidNull,
                                         TRUE,
                                         GlobalEventCallbackRoutine,
                                         0x12345678,
                                         NULL,
                                         0,
                                         0);
    if (Status != ERROR_SUCCESS)
    {
        printf("ERROR: WMINotificationRegistration Global Enable failed %x\n", Status);
    }

    
    for (j = 0; j < TestCount; j++)
    {
        Status = WMINotificationRegistration(TestList[j].Guid,
                                         TRUE,
                                         TestList[j].NotificationCallback,
                                         0xABCDEF01,
                                         NULL,
                                         0,
                                         0);
        if (Status != ERROR_SUCCESS)
        {
            printf("ERROR: WMINotificationRegistration Enable %d failed %x\n", j, Status);
            free(Wnode);
            goto done;
        }
    }
        
    Wnode->WnodeHeader.BufferSize = Size;
    Wnode->WnodeHeader.TimeStamp.LowPart = 1;
    Wnode->WnodeHeader.TimeStamp.HighPart = 1;
    Wnode->WnodeHeader.Flags = WNODE_FLAG_SINGLE_INSTANCE | WNODE_FLAG_EVENT_ITEM | WNODE_FLAG_STATIC_INSTANCE_NAMES;
    Wnode->WnodeHeader.Version = 1;
//    InstanceNamePtr = (PWCHAR)(&Wnode->VariableData);
//    *InstanceNamePtr = sizeof(EventInstanceName);
//    wcscpy(InstanceNamePtr + 1, EventInstanceName);
//    DataPtr = (ULONG *)((PBYTE)InstanceNamePtr + sizeof(EventInstanceName) + sizeof(WCHAR));
//    Wnode->OffsetInstanceName = (ULONG)((ULONG)InstanceNamePtr - (ULONG)Wnode);    
    DataPtr = (ULONG *)&Wnode->VariableData;
    Wnode->SizeDataBlock = 4;
    Wnode->DataBlockOffset = (ULONG)((ULONG)DataPtr - (ULONG)Wnode );

    EventsSent = 0;
    EventsReceived = 0;
    GlobalEventsSent = 0;
    GlobalEventsReceived = 0;
    
    for (i = 0; i < 25; i++)
    {
        DataPtr[0] = i;
        
        for (j = 0; j < TestCount; j++)
        {		
            memcpy(&Wnode->WnodeHeader.Guid, TestList[j].Guid, sizeof(GUID));
	    Wnode->InstanceIndex = i % 5;
            f = DeviceIoControl( STBHandle,
                         IOCTL_WMI_GENERATE_EVENT,
                        Wnode, 
                        Wnode->WnodeHeader.BufferSize,
                        NULL,
                        0,
                        &retsize,
                        NULL);
            if (! f)
            {
                printf("ERROR: DeviceIoCOntrol(EventGen) failed %x\n", Wnode);
            } else {
                TestList[j].EventsSent++;
                GlobalEventsSent++;
            }
            Sleep(1000);
        }        
    }

    //
    // Send event for unregistered guid
    memcpy(&Wnode->WnodeHeader.Guid, &UnRegGuid, sizeof(GUID));
    Wnode->WnodeHeader.Linkage = i;
    DataPtr[0] = i;
        
    f = DeviceIoControl( STBHandle,
                         IOCTL_WMI_GENERATE_EVENT,
                        Wnode, 
                        Wnode->WnodeHeader.BufferSize,
                        NULL,
                        0,
                        &retsize,
                        NULL);
    if (! f)
    {
        printf("ERROR: DeviceIoCOntrol(EventGen) failed\n");
    } else {
        GlobalEventsSent++;
    }
    Sleep(10000);

    for (j = 0; j < TestCount; j++)
    {
        Status = WMINotificationRegistration(TestList[j].Guid,
                                         FALSE,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         0);
						 
						 
        if (Status != ERROR_SUCCESS)
        {
            printf("ERROR: WMINotificationRegistration disable %d failed %x\n", j, Status);
        }
    }
    
    Status = WMINotificationRegistration(&GuidNull,
                                         FALSE,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         0);
						 
    if (Status != ERROR_SUCCESS)
    {
        printf("ERROR: WMINotificationRegistration disable GuidNull failed %x\n", Status);
    }
    
                                     
    free(Wnode);
    
    for (j = 0; j < TestCount; j++)
    {
        if (TestList[j].EventsReceived != TestList[j].EventsSent)
        {
            printf("Error - Sent %d events, but received %d for %d\n",
                        TestList[j].EventsSent, TestList[j].EventsReceived, j);
        }
        printf("Error - Sent %d events, but received %d for %d\n",
                    TestList[j].EventsSent, TestList[j].EventsReceived, j);
    }
    
    if (GlobalEventsReceived != GlobalEventsSent)
    {
        printf("Error - Sent %d global events, but received %d\n", 
            GlobalEventsSent, GlobalEventsReceived);
    }
    
    printf("Error - Sent %d global events, but received %d\n", 
            GlobalEventsSent, GlobalEventsReceived);

done:    
    WMICloseBlock(DataBlockHandle);
    CloseHandle(STBHandle);

    
}

typedef ULONG (*THREADFUNC)(
    ULONG FirstTestNumber,
    ULONG LastTestNumber
    );


typedef struct
{
    THREADFUNC ThreadFunc;
    ULONG FirstTestNumber;
    ULONG LastTestNumber;
} LAUNCHCTX, *PLAUNCHCTX;

ULONG LaunchThreadProc(PVOID Context)
{
    PLAUNCHCTX LaunchCtx = (PLAUNCHCTX)Context;
    
    (*LaunchCtx->ThreadFunc)(LaunchCtx->FirstTestNumber, 
                             LaunchCtx->LastTestNumber);
		     
    return(0);
}

void LaunchThread(
    THREADFUNC ThreadFunc,
    ULONG FirstTestNumber,
    ULONG LastTestNumber
    )
{
    PLAUNCHCTX LaunchCtx;
    HANDLE ThreadHandle;
    
    LaunchCtx = (PLAUNCHCTX)malloc(sizeof(LAUNCHCTX));
    
    if (LaunchCtx != NULL)
    {
        LaunchCtx->ThreadFunc = ThreadFunc;
	LaunchCtx->FirstTestNumber = FirstTestNumber;
	LaunchCtx->LastTestNumber = LastTestNumber;
	
        ThreadHandle = CreateThread(NULL,
                                    0,
                                    LaunchThreadProc,
                                    &LaunchCtx,
                                    0,
                                    NULL);
        if (ThreadHandle != NULL)
        {
            CloseHandle(ThreadHandle);
        }
    }
}

int _cdecl main(int argc, char *argv[])
{
    printf("At Main in DC1\n");
    QADTest(0, TestCount);
    QSINTest(0, TestCount);
    QSITTest(0, TestCount);
    EventTest(0, TestCount);

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\devinst\devinst.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    devinst.c

Abstract:

    device instance id test

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>

#include "wmium.h"
#include "wmiguid.h"

#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)(Base) + (Offset)))

BYTE Buffer[4096];

GUID InstanceInfoGuid = INSTANCE_INFO_GUID;

void DumpCString(PCHAR What, PWCHAR String)
{
    WCHAR Buf[MAX_PATH];
    ULONG Len;
    
    memset(Buf, 0, MAX_PATH);
    Len = *String++;
    memcpy(Buf, String, Len);
    
    printf("%s -> %ws\n", What, Buf);
}

void DumpBuffer(PWNODE_SINGLE_INSTANCE Wnode )
{
    PWCHAR String;
    
    String = (PWCHAR)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
    
    DumpCString("FriendlyName", String);
    String += (*String + sizeof(USHORT)) / sizeof(WCHAR);
    
    DumpCString("Description", String);
    String += (*String + sizeof(USHORT)) / sizeof(WCHAR);

    DumpCString("Location", String);
    String += (*String + sizeof(USHORT)) / sizeof(WCHAR);

    DumpCString("Manufacturer", String);
    String += (*String + sizeof(USHORT)) / sizeof(WCHAR);

    DumpCString("Service", String);
    String += (*String + sizeof(USHORT)) / sizeof(WCHAR);
}


void TestDevInst(
    void
    )
/*
Bad length
bad out buffer
bad input bufffer

*/
{
}


int _cdecl main(int argc, char *argv[])
{
    CHAR DevInstA[MAX_PATH];
    WMIHANDLE Handle;
    ULONG Status;
    ULONG SizeNeeded;
    ULONG BufLen;
    
    TestDevInst();
    
    if (argc == 1)
    {
        printf("devinst <device instance name>\n");
        return(0);
    }

    SizeNeeded = WmiDevInstToInstanceNameA(NULL,
                                           0,
                                           argv[1],
                                           0);
                   
    printf("SizeNeedde (%s) -> %d\n", argv[1], SizeNeeded);
    
                                       
    SizeNeeded = WmiDevInstToInstanceNameA(DevInstA,
                                           SizeNeeded,
                                           argv[1],
                                           0);
       printf("SizeNeedde (%s) -> %d\n", DevInstA, SizeNeeded);
    
    Status = WmiOpenBlock(&InstanceInfoGuid,
                          0,
                          &Handle);
    if (Status != ERROR_SUCCESS)
    {
        printf("WmiOpenBlock -> %d\n", Status);
    } else {
        BufLen = sizeof(Buffer);
        Status = WmiQuerySingleInstance(Handle,
                                        DevInstA,
                                        &BufLen,
                                        (PVOID)Buffer);
        if (Status != ERROR_SUCCESS)
        {
            printf("WmiQuerySingleInstance -> %d\n", Status);
        } else {
            DumpBuffer((PWNODE_SINGLE_INSTANCE)Buffer);
        }
        WmiCloseBlock(Handle);
    }
                                       
    
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\diskperf\dpdump.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    dpsump.c

Abstract:

    
    test program

Author:

    16-Jan-1997 AlanWar

Revision History:

     7-Jan-2001 insungp

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>

#include <ntdddisk.h>

#include <wmium.h>
#include <mountmgr.h>

GUID DiskPerfGuid = {0xBDD865D1,0xD7C1,0x11d0,0xA5,0x01,0x00,0xA0,0xC9,0x06,0x29,0x10};

BYTE Buffer[4096];

ULONG QueryAllDataAndDump(LPGUID Guid)
{
    WMIHANDLE WmiHandle;
    ULONG Size;
    ULONG Status;
    PWNODE_ALL_DATA WAD;
    WCHAR InstanceName[MAX_PATH];
    PWCHAR InstanceNamePtr;
    ULONG InstanceNameOffset;
    PDISK_PERFORMANCE DiskPerformance;

    
    Status = WmiOpenBlock(Guid, 0, &WmiHandle);                    
        
    if (Status != ERROR_SUCCESS)
    {
        printf("WMIOpenBlock %d\n", Status);
    return(Status);
    }
    
    Size = sizeof(Buffer);
    Status = WmiQueryAllDataW(WmiHandle, &Size, Buffer);                    

    if (Status != ERROR_SUCCESS)
    {
        printf("WMIQueryAllData %d\n", Status);     
    } else {
        
        WAD = (PWNODE_ALL_DATA)Buffer;
        while (1)
        {
            DiskPerformance = (PDISK_PERFORMANCE)( (PUCHAR)WAD + WAD->DataBlockOffset);
            InstanceNameOffset = *((PULONG)( (PUCHAR)WAD + WAD->OffsetInstanceNameOffsets));
            InstanceNamePtr = (PWCHAR)( (PUCHAR)WAD + InstanceNameOffset);
            
            memcpy(InstanceName, InstanceNamePtr+1, *InstanceNamePtr);
            InstanceName[(*InstanceNamePtr)/sizeof(WCHAR)] = 0;

            printf("%ws\n", InstanceName);
            printf("     BytesRead = %x%x\n", 
                                    DiskPerformance->BytesRead.HighPart, 
                                    DiskPerformance->BytesRead.LowPart);
            printf("     BytesWritten = %x%x\n", 
                                    DiskPerformance->BytesWritten.HighPart, 
                                    DiskPerformance->BytesWritten.LowPart);
            printf("     ReadTime = %x%x\n", 
                                    DiskPerformance->ReadTime.HighPart, 
                                    DiskPerformance->ReadTime.LowPart);
            printf("     WriteTime = %x%x\n", 
                                    DiskPerformance->WriteTime.HighPart, 
                                    DiskPerformance->WriteTime.LowPart);
            printf("     ReadCount = %x\n", DiskPerformance->ReadCount);
            printf("     WriteCount = %x\n", DiskPerformance->WriteCount);
            printf("     QueueDepth = %x\n", DiskPerformance->QueueDepth);
            printf("\n\n");
            
            if (WAD->WnodeHeader.Linkage == 0)
            {
                break;
            }
            
            WAD = (PWNODE_ALL_DATA)((PUCHAR)WAD + WAD->WnodeHeader.Linkage);
        }
    }
        
    WmiCloseBlock(WmiHandle);
    
    return(Status);
}

ULONG
QueryUsingIoctl()
{
    ULONG nDisk, i;
    SYSTEM_DEVICE_INFORMATION DeviceInfo;
    NTSTATUS status;

    UNICODE_STRING UnicodeName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;

    WCHAR devname[256];
    PWCHAR s;

    HANDLE PartitionHandle, MountMgrHandle, VolumeHandle;
    DWORD ReturnedBytes, MountError;

    DISK_PERFORMANCE DiskPerformance;

    status = NtQuerySystemInformation(SystemDeviceInformation, &DeviceInfo, sizeof(DeviceInfo), NULL);
    if (!NT_SUCCESS(status)) {
        printf("NtQuerySystemInformation returns %X\n", status);
    }

    nDisk = DeviceInfo.NumberOfDisks;
    // for each physical disk
    for (i = 0; i < nDisk; i++) {

        swprintf(devname, L"\\Device\\Harddisk%d\\Partition0", i);

        RtlInitUnicodeString(&UnicodeName, devname);

        InitializeObjectAttributes(
                   &ObjectAttributes,
                   &UnicodeName,
                   OBJ_CASE_INSENSITIVE,
                   NULL,
                   NULL
                   );
        // opening a partition handle for physical drives
        status = NtOpenFile(
                &PartitionHandle,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatus,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                );

        if ( !NT_SUCCESS(status) ) {
            printf("Error %x: Cannot open disk %ws\n", GetLastError(), devname);
            continue;
        }
        // sending IOCTL over to Partition Handle
        if (!DeviceIoControl(PartitionHandle,
                        IOCTL_DISK_PERFORMANCE,
                        NULL, 
                        0, 
                        &DiskPerformance,
                        sizeof(DISK_PERFORMANCE),
                        &ReturnedBytes,
                        NULL
                        )) {
            printf("Error %x: Cannot get Disk Performance Information for %ws\n", GetLastError(),
                    devname);
        }
        else {
            printf("Physical Drive %d\n", i);

            printf("     BytesRead = %x%x\n", 
                                DiskPerformance.BytesRead.HighPart, 
                                DiskPerformance.BytesRead.LowPart);
            printf("     BytesWritten = %x%x\n", 
                                DiskPerformance.BytesWritten.HighPart, 
                                DiskPerformance.BytesWritten.LowPart);
            printf("     ReadTime = %x%x\n", 
                                DiskPerformance.ReadTime.HighPart, 
                                DiskPerformance.ReadTime.LowPart);
            printf("     WriteTime = %x%x\n", 
                                DiskPerformance.WriteTime.HighPart, 
                                DiskPerformance.WriteTime.LowPart);
            printf("     ReadCount = %x\n", DiskPerformance.ReadCount);
            printf("     WriteCount = %x\n", DiskPerformance.WriteCount);
            printf("     QueueDepth = %x\n", DiskPerformance.QueueDepth);
            printf("\n\n");
        }
        
        NtClose(PartitionHandle);
    }

    MountMgrHandle = FindFirstVolumeW(devname, sizeof(devname));
    if (MountMgrHandle == NULL) {
        printf("Cannot find first volume\n");
        return 0;
    }
    s = (PWCHAR) &devname[wcslen(devname)-1];
    if (*s == L'\\') {
        *s = UNICODE_NULL;
    }

    VolumeHandle = CreateFileW(devname, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (VolumeHandle != INVALID_HANDLE_VALUE) {
        RtlZeroMemory(&DiskPerformance, sizeof(DISK_PERFORMANCE));
        // sending IOCTL over to a volume handle
        if (!DeviceIoControl(VolumeHandle,
               IOCTL_DISK_PERFORMANCE,
               NULL,
               0,
               &DiskPerformance,
               sizeof(DISK_PERFORMANCE),
               &ReturnedBytes,
               NULL
               )) {
            printf("IOCTL failed for %ws %d\n", devname, GetLastError());
        }
        else {
            printf("%ws\n", devname);

            printf("     BytesRead = %x%x\n",
                                    DiskPerformance.BytesRead.HighPart,
                                    DiskPerformance.BytesRead.LowPart);
            printf("     BytesWritten = %x%x\n",
                                    DiskPerformance.BytesWritten.HighPart,
                                    DiskPerformance.BytesWritten.LowPart);
            printf("     ReadTime = %x%x\n",
                                    DiskPerformance.ReadTime.HighPart,
                                    DiskPerformance.ReadTime.LowPart);
            printf("     WriteTime = %x%x\n",
                                    DiskPerformance.WriteTime.HighPart,
                                    DiskPerformance.WriteTime.LowPart);
            printf("     ReadCount = %x\n", DiskPerformance.ReadCount);
            printf("     WriteCount = %x\n", DiskPerformance.WriteCount);
            printf("     QueueDepth = %x\n", DiskPerformance.QueueDepth);
            printf("\n\n");
        }
        CloseHandle(VolumeHandle);
    }
    else {
        printf("Error %x: Cannot open volume %ws\n", GetLastError(), devname);
    }

    while (FindNextVolumeW(MountMgrHandle, devname, sizeof(devname))) {
        s = (PWCHAR) &devname[wcslen(devname)-1];
        if (*s == L'\\') {
            *s = UNICODE_NULL;
        }
        VolumeHandle = CreateFileW(devname, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
        if (VolumeHandle != INVALID_HANDLE_VALUE) {
            RtlZeroMemory(&DiskPerformance, sizeof(DISK_PERFORMANCE));
            if (!DeviceIoControl(VolumeHandle,
                   IOCTL_DISK_PERFORMANCE,
                   NULL,
                   0,
                   &DiskPerformance,
                   sizeof(DISK_PERFORMANCE),
                   &ReturnedBytes,
                   NULL
                   )) {
                printf("IOCTL failed for %ws %d\n", devname, GetLastError());
                continue;
            }
            printf("%ws\n", devname);

            printf("     BytesRead = %x%x\n",
                                    DiskPerformance.BytesRead.HighPart,
                                    DiskPerformance.BytesRead.LowPart);
            printf("     BytesWritten = %x%x\n",
                                    DiskPerformance.BytesWritten.HighPart,
                                    DiskPerformance.BytesWritten.LowPart);
            printf("     ReadTime = %x%x\n",
                                    DiskPerformance.ReadTime.HighPart,
                                    DiskPerformance.ReadTime.LowPart);
            printf("     WriteTime = %x%x\n",
                                    DiskPerformance.WriteTime.HighPart,
                                    DiskPerformance.WriteTime.LowPart);
            printf("     ReadCount = %x\n", DiskPerformance.ReadCount);
            printf("     WriteCount = %x\n", DiskPerformance.WriteCount);
            printf("     QueueDepth = %x\n", DiskPerformance.QueueDepth);
            printf("\n\n");

            CloseHandle(VolumeHandle);
        }
        else {
            printf("Error %x: Cannot open volume %ws\n", GetLastError(), devname);
        }
    }
    FindVolumeClose(MountMgrHandle);
    return ERROR_SUCCESS;
}

int _cdecl main(int argc, char *argv[])
{
    if ((argc > 1) && (!strcmp(argv[1], "-ioctl"))) {
        QueryUsingIoctl();
    }
    else {
        QueryAllDataAndDump(&DiskPerfGuid);
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\genmcas\gen.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntiologc.h>

//
// This tool will generate MOF definitions for the event to eventlog
// subscriptions for MCA events/eventlogs
//

CHAR Buffer[2*8192];

ULONG FilePrintVaList(
    HANDLE FileHandle,
    CHAR *Format,
    va_list pArg
    )
{
    ULONG Size, Written;
    ULONG Status;

    Size = _vsnprintf(Buffer, sizeof(Buffer), Format, pArg);
    if (WriteFile(FileHandle,
                       Buffer,
                       Size,
                       &Written,
                       NULL))
    {
        Status = ERROR_SUCCESS;
    } else {
        Status = GetLastError();
    }

    return(Status);
}

ULONG FilePrint(
    HANDLE FileHandle,
    char *Format,
    ...
    )
{
    ULONG Status;
    va_list pArg;

    va_start(pArg, Format);
    Status = FilePrintVaList(FileHandle, Format, pArg);
    return(Status);
}

typedef struct
{
	char *CodeName;
	ULONG Code;
	char *Class;
	ULONG InsertCount;
	char *Insert2;
	char *Insert3;
	char *Insert4;
} tab, *ptab;

tab TabList[] =
{
	{
		"MCA_WARNING_CACHE",
		MCA_WARNING_CACHE,
		"MSMCAEvent_CPUError",
		1,
		"%level%",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_CACHE",
		MCA_ERROR_CACHE,
		"MSMCAEvent_CPUError",
		1,
		"%level%",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_WARNING_TLB",
		MCA_WARNING_TLB,
		"MSMCAEvent_CPUError",
		1,
		"%level%",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_TLB",
		MCA_ERROR_TLB,
		"MSMCAEvent_CPUError",
		1,
		"%level%",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_WARNING_CPU_BUS",
		MCA_WARNING_CPU_BUS,
		"MSMCAEvent_CPUError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_CPU_BUS",
		MCA_ERROR_CPU_BUS,
		"MSMCAEvent_CPUError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_WARNING_REGISTER_FILE",
		MCA_WARNING_REGISTER_FILE,
		"MSMCAEvent_CPUError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_REGISTER_FILE",
		MCA_ERROR_REGISTER_FILE,
		"MSMCAEvent_CPUError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_WARNING_MAS",
		MCA_WARNING_MAS,
		"MSMCAEvent_CPUError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_MAS",
		MCA_ERROR_MAS,
		"MSMCAEvent_CPUError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_WARNING_MEM_UNKNOWN",
		MCA_WARNING_MEM_UNKNOWN,
		"MSMCAEvent_MemoryError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_MEM_UNKNOWN",
		MCA_ERROR_MEM_UNKNOWN,
		"MSMCAEvent_MemoryError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_WARNING_MEM_1_2",
		MCA_WARNING_MEM_1_2,
		"MSMCAEvent_MemoryError",
		1,
		"%MEM_PHYSICAL_ADDR%",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_MEM_1_2",
		MCA_ERROR_MEM_1_2,
		"MSMCAEvent_MemoryError",
		1,
		"%MEM_PHYSICAL_ADDR%",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_WARNING_MEM_1_2_5",
		MCA_WARNING_MEM_1_2_5,
		"MSMCAEvent_MemoryError",
		2,
		"%MEM_PHYSICAL_ADDR%",
		"%MEM_MODULE%",
		"N/A"
	},
	
	{
		"MCA_ERROR_MEM_1_2_5",
		MCA_ERROR_MEM_1_2_5,
		"MSMCAEvent_MemoryError",
		2,
		"%MEM_PHYSICAL_ADDR%",
		"%MEM_MODULE%",
		"N/A"
	},
	
	{
		"MCA_WARNING_MEM_1_2_5_4",
		MCA_WARNING_MEM_1_2_5_4,
		"MSMCAEvent_MemoryError",
		3,
		"%MEM_PHYSICAL_ADDR%",
		"%MEM_MODULE%",
		"%MEM_CARD%"
	},
	
	{
		"MCA_ERROR_MEM_1_2_5_4",
		MCA_ERROR_MEM_1_2_5_4,
		"MSMCAEvent_MemoryError",
		3,
		"%MEM_PHYSICAL_ADDR%",
		"%MEM_MODULE%",
		"%MEM_CARD%"
	},
	
	{
		"MCA_WARNING_SYSTEM_EVENT",
		MCA_WARNING_SYSTEM_EVENT,
		"MSMCAEvent_SystemEventError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_SYSTEM_EVENT",
		MCA_ERROR_SYSTEM_EVENT,
		"MSMCAEvent_SystemEventError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_WARNING_PCI_BUS_PARITY",
		MCA_WARNING_PCI_BUS_PARITY,
		"MSMCAEvent_PCIBusError",
		3,
		"%PCI_BUS_CMD%",
		"%PCI_BUS_ADDRESS%",
		"%PCI_BUS_ID_BusNumber%"
	},
	
	{
		"MCA_ERROR_PCI_BUS_PARITY",
		MCA_ERROR_PCI_BUS_PARITY,
		"MSMCAEvent_PCIBusError",
		3,
		"%PCI_BUS_CMD%",
		"%PCI_BUS_ADDRESS%",
		"%PCI_BUS_ID_BusNumber%"
	},
	
	{
		"MCA_WARNING_PCI_BUS_PARITY_NO_INFO",
		MCA_WARNING_PCI_BUS_PARITY_NO_INFO,
		"MSMCAEvent_PCIBusError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_PCI_BUS_PARITY_NO_INFO",
		MCA_ERROR_PCI_BUS_PARITY_NO_INFO,
		"MSMCAEvent_PCIBusError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_WARNING_PCI_BUS_SERR",
		MCA_WARNING_PCI_BUS_SERR,
		"MSMCAEvent_PCIBusError",
		3,
		"%PCI_BUS_CMD%",
		"%PCI_BUS_ADDRESS%",
		"%PCI_BUS_ID_BusNumber%"
	},
	
	{
		"MCA_ERROR_PCI_BUS_SERR",
		MCA_ERROR_PCI_BUS_SERR,
		"MSMCAEvent_PCIBusError",
		3,
		"%PCI_BUS_CMD%",
		"%PCI_BUS_ADDRESS%",
		"%PCI_BUS_ID_BusNumber%"
	},
	
	{
		"MCA_WARNING_PCI_BUS_SERR_NO_INFO",
		MCA_WARNING_PCI_BUS_SERR_NO_INFO,
		"MSMCAEvent_PCIBusError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_PCI_BUS_SERR_NO_INFO",
		MCA_ERROR_PCI_BUS_SERR_NO_INFO,
		"MSMCAEvent_PCIBusError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_WARNING_PCI_BUS_MASTER_ABORT",
		MCA_WARNING_PCI_BUS_MASTER_ABORT,
		"MSMCAEvent_PCIBusError",
		3,
		"%PCI_BUS_CMD%",
		"%PCI_BUS_ADDRESS%",
		"%PCI_BUS_ID_BusNumber%"
	},
	
	{
		"MCA_ERROR_PCI_BUS_MASTER_ABORT",
		MCA_ERROR_PCI_BUS_MASTER_ABORT,
		"MSMCAEvent_PCIBusError",
		3,
		"%PCI_BUS_CMD%",
		"%PCI_BUS_ADDRESS%",
		"%PCI_BUS_ID_BusNumber%"
	},
	
	{
		"MCA_WARNING_PCI_BUS_MASTER_ABORT_NO_INFO",
		MCA_WARNING_PCI_BUS_MASTER_ABORT_NO_INFO,
		"MSMCAEvent_PCIBusError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_PCI_BUS_MASTER_ABORT_NO_INFO",
		MCA_ERROR_PCI_BUS_MASTER_ABORT_NO_INFO,
		"MSMCAEvent_PCIBusError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_WARNING_PCI_BUS_TIMEOUT",
		MCA_WARNING_PCI_BUS_TIMEOUT,
		"MSMCAEvent_PCIBusError",
		3,
		"%PCI_BUS_CMD%",
		"%PCI_BUS_ADDRESS%",
		"%PCI_BUS_ID_BusNumber%"
	},
	
	{
		"MCA_ERROR_PCI_BUS_TIMEOUT",
		MCA_ERROR_PCI_BUS_TIMEOUT,
		"MSMCAEvent_PCIBusError",
		3,
		"%PCI_BUS_CMD%",
		"%PCI_BUS_ADDRESS%",
		"%PCI_BUS_ID_BusNumber%"
	},
	
	{
		"MCA_WARNING_PCI_BUS_TIMEOUT_NO_INFO",
		MCA_WARNING_PCI_BUS_TIMEOUT_NO_INFO,
		"MSMCAEvent_PCIBusError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_PCI_BUS_TIMEOUT_NO_INFO",
		MCA_ERROR_PCI_BUS_TIMEOUT_NO_INFO,
		"MSMCAEvent_PCIBusError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_WARNING_PCI_BUS_UNKNOWN",
		MCA_WARNING_PCI_BUS_UNKNOWN,
		"MSMCAEvent_PCIBusError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_PCI_BUS_UNKNOWN",
		MCA_ERROR_PCI_BUS_UNKNOWN,
		"MSMCAEvent_PCIBusError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	
	{
		"MCA_WARNING_PCI_DEVICE",
		MCA_WARNING_PCI_DEVICE,
		"MSMCAEvent_PCIComponentError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_PCI_DEVICE",
		MCA_ERROR_PCI_DEVICE,
		"MSMCAEvent_PCIComponentError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	
	{
		"MCA_WARNING_SMBIOS",
		MCA_WARNING_SMBIOS,
		"MSMCAEvent_SMBIOSError",
		2,
		"%SMBIOS_EVENT_TYPE%",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_SMBIOS",
		MCA_ERROR_SMBIOS,
		"MSMCAEvent_SMBIOSError",
		1,
		"%SMBIOS_EVENT_TYPE%",
		"N/A",
		"N/A"
	},
	
	
	{
		"MCA_WARNING_PLATFORM_SPECIFIC",
		MCA_WARNING_PLATFORM_SPECIFIC,
		"MSMCAEvent_PlatformSpecificError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_PLATFORM_SPECIFIC",
		MCA_ERROR_PLATFORM_SPECIFIC,
		"MSMCAEvent_PlatformSpecificError",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
		
	{
		"MCA_WARNING_UNKNOWN",
		MCA_WARNING_UNKNOWN,
		"MSMCAEvent_Unknown",
		0,
		"N/A",
		"N/A",
		"N/A"
	},
	
	{
		"MCA_ERROR_UNKNOWN",
		MCA_ERROR_UNKNOWN,
		"MSMCAEvent_Unknown",
		0,
		"N/A",
		"N/A",
		"N/A"
	}
	
	
};

#define TabSize (sizeof(TabList) / sizeof(tab))

int _cdecl main(int argc, char *argv[])
{
	HANDLE TemplateHandle;
	ULONG i;
	
    TemplateHandle = CreateFile(argv[1],
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

    if ((TemplateHandle == NULL) || (TemplateHandle == INVALID_HANDLE_VALUE))
    {
        return(GetLastError());
    }


	for (i = 0; i < (TabSize); i++)
	{
		FilePrint(TemplateHandle,
				  "DEFINE_EVENT_TO_EVENTLOG_SUBSCRIPTION(\n"
				  "        MCA%d,\n"
				  "        \"MCA%d\",\n"
				  "        %u, // %s \n"
				  "        \"select * from %s where type = %u\",\n"
				  "        \"WMIxWDM\",\n"
				  "        \"RawRecord\",\n"
				  "        %d, \"%%Cpu%%\", \"%%AdditionalErrors%%\", \"%s\", \"%s\", \"%s\")\n\n",

				  i,
				  i,
				  TabList[i].Code, TabList[i].CodeName,
				  TabList[i].Class, TabList[i].Code,
				  TabList[i].InsertCount+2, TabList[i].Insert2,
				                          TabList[i].Insert3,
				                          TabList[i].Insert4);
	}

	CloseHandle(TemplateHandle);
	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\constantmap.cpp ===
// ConstantMap.cpp: implementation of the CConstantMap class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************


#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <list>


using namespace std;



#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>


#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"
#include "Logger.h"
#include "TCOData.h"
#include "Utilities.h"
#include "StructureWrappers.h"

#include "ConstantMap.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
   
CConstantMap::CConstantMap()
{
	MAPPAIR pair;

	pair.first = _T("EVENT_TRACE_TYPE_INFO");
	pair.second = EVENT_TRACE_TYPE_INFO;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_START");
	pair.second = EVENT_TRACE_TYPE_START;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_END");
	pair.second = EVENT_TRACE_TYPE_END;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_DC_START");
	pair.second = EVENT_TRACE_TYPE_DC_START;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_DC_END");
	pair.second = EVENT_TRACE_TYPE_DC_END;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_EXTENSION");
	pair.second = EVENT_TRACE_TYPE_EXTENSION;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_REPLY");
	pair.second = EVENT_TRACE_TYPE_REPLY;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_RESERVED7");
	pair.second = EVENT_TRACE_TYPE_RESERVED7;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_RESERVED8");
	pair.second = EVENT_TRACE_TYPE_RESERVED8;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_RESERVED9");
	pair.second = EVENT_TRACE_TYPE_RESERVED9;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_LOAD");
	pair.second = EVENT_TRACE_TYPE_LOAD;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_IO_READ");
	pair.second = EVENT_TRACE_TYPE_IO_READ;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_IO_WRITE");
	pair.second = EVENT_TRACE_TYPE_IO_WRITE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_TF");
	pair.second = EVENT_TRACE_TYPE_MM_TF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_DZF");
	pair.second = EVENT_TRACE_TYPE_MM_DZF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_COW");
	pair.second = EVENT_TRACE_TYPE_MM_COW;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_GPF");
	pair.second = EVENT_TRACE_TYPE_MM_GPF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_HPF");
	pair.second = EVENT_TRACE_TYPE_MM_HPF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_SEND");
	pair.second = EVENT_TRACE_TYPE_SEND;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_MM_HPF");
	pair.second = EVENT_TRACE_TYPE_MM_HPF;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_RECEIVE");
	pair.second = EVENT_TRACE_TYPE_RECEIVE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_CONNECT");
	pair.second = EVENT_TRACE_TYPE_CONNECT;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_DISCONNECT");
	pair.second = EVENT_TRACE_TYPE_DISCONNECT;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_GUIDMAP");
	pair.second = EVENT_TRACE_TYPE_GUIDMAP;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_CONFIG");
	pair.second = EVENT_TRACE_TYPE_CONFIG;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_TYPE_SIDINFO");
	pair.second = EVENT_TRACE_TYPE_SIDINFO;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_PROCESS");
	pair.second = EVENT_TRACE_FLAG_PROCESS;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_THREAD");
	pair.second = EVENT_TRACE_FLAG_THREAD;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_IMAGE_LOAD");
	pair.second = EVENT_TRACE_FLAG_IMAGE_LOAD;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_DISK_IO");
	pair.second = EVENT_TRACE_FLAG_DISK_IO;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_DISK_FILE_IO");
	pair.second = EVENT_TRACE_FLAG_DISK_FILE_IO;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS");
	pair.second = EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS");
	pair.second = EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_NETWORK_TCPIP");
	pair.second = EVENT_TRACE_FLAG_NETWORK_TCPIP;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_EXTENSION");
	pair.second = EVENT_TRACE_FLAG_EXTENSION;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FLAG_FORWARD_WMI");
	pair.second = EVENT_TRACE_FLAG_FORWARD_WMI;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FILE_MODE_NONE");
	pair.second = EVENT_TRACE_FILE_MODE_NONE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FILE_MODE_SEQUENTIAL");
	pair.second = EVENT_TRACE_FILE_MODE_SEQUENTIAL;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FILE_MODE_CIRCULAR");
	pair.second = EVENT_TRACE_FILE_MODE_CIRCULAR;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_FILE_MODE_NEWFILE");
	pair.second = EVENT_TRACE_FILE_MODE_NEWFILE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_PRIVATE_LOGGER_MODE");
	pair.second = EVENT_TRACE_PRIVATE_LOGGER_MODE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_REAL_TIME_MODE");
	pair.second = EVENT_TRACE_REAL_TIME_MODE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_DELAY_OPEN_FILE_MODE");
	pair.second = EVENT_TRACE_DELAY_OPEN_FILE_MODE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_BUFFERING_MODE");
	pair.second = EVENT_TRACE_BUFFERING_MODE;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_CONTROL_QUERY");
	pair.second = EVENT_TRACE_CONTROL_QUERY;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_CONTROL_STOP");
	pair.second = EVENT_TRACE_CONTROL_STOP;
	m_Map.insert(pair);

	pair.first = _T("EVENT_TRACE_CONTROL_UPDATE");
	pair.second = EVENT_TRACE_CONTROL_UPDATE;
	m_Map.insert(pair);

	pair.first = _T("WNODE_FLAG_TRACED_GUID");
	pair.second = WNODE_FLAG_TRACED_GUID;
	m_Map.insert(pair);

	pair.first = _T("ERROR_SUCCESS");
	pair.second = ERROR_SUCCESS;
	m_Map.insert(pair);

	pair.first = _T("ERROR_INVALID_PARAMETER");
	pair.second = ERROR_INVALID_PARAMETER;
	m_Map.insert(pair);

	pair.first = _T("ERROR_INVALID_NAME");
	pair.second = ERROR_INVALID_NAME;
	m_Map.insert(pair);

	pair.first = _T("ERROR_BAD_LENGTH");
	pair.second = ERROR_BAD_LENGTH;
	m_Map.insert(pair);


	pair.first = _T("VALUE_NULL");
	pair.second = NULL;
	m_Map.insert(pair);

	pair.first = _T("VALUE_MAX_MEMORY");
	pair.second = 0;
	m_Map.insert(pair);

	pair.first = _T("VALUE_ZERO");
	pair.second = 0;
	m_Map.insert(pair);

}

CConstantMap::~CConstantMap()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\collectioncontrol.h ===
#if !defined(AFX_COLLECTIONCONTROL_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
#define AFX_COLLECTIONCONTROL_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

int StartTraceAPI
(
	IN LPTSTR lptstrAction,				// For logging only.
 	IN LPCTSTR pctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// StartTrace API call return
);

int StopTraceAPI
(	
 	IN LPTSTR lptstrAction,				// For logging only.
 	IN LPCTSTR pctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN bool bUseTraceHandle,			// If true use the handle.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// StopTrace API call return
);

// Enable all Guids
int EnableTraceAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.
	IN LPCTSTR pctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// EnableTrace API call return
);

// Only enable one Guid
int EnableTraceAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.
 	IN LPCTSTR pctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN int nGuidIndex,					// Index or if -1 use Guid from WNode.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// EnableTrace API call return
);

int QueryTraceAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.
 	IN LPCTSTR pctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN bool bUseTraceHandle,			// If true use the handle.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// QueryTrace API call return
);

int UpdateTraceAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.
 	IN LPCTSTR pctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN bool bUseTraceHandle,			// If true use the handle.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// UpdateTrace API call return
);

int QueryAllTracesAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.
	OUT int *pAPIReturn					// QueryAllTraces API call return
);

#endif // !defined(AFX_COLLECTIONCONTROL_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\constantmap.h ===
// ConstantMap.h: interface for the CConstantMap class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if !defined(AFX_CONSTANTMAP_H__C5372480_EDF1_11D2_804A_009027345EE2__INCLUDED_)
#define AFX_CONSTANTMAP_H__C5372480_EDF1_11D2_804A_009027345EE2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

typedef pair<t_string, unsigned int> MAPPAIR;
typedef map<t_string, unsigned int> CONSTMAP;


class CConstantMap  
{
public:
	CConstantMap();
	virtual ~CConstantMap();
	CONSTMAP m_Map;
};

#endif // !defined(AFX_CONSTANTMAP_H__C5372480_EDF1_11D2_804A_009027345EE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\collectioncontrol.cpp ===
// CollectionControl.cpp : Defines the entry point for the DLL application.
//
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************



#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <list>


using namespace std;


#include <tchar.h>
#include <process.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"


#include "Persistor.h"
#include "Logger.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h" 
#include "TCOData.h"
#include "Utilities.h"

#include "CollectionControl.h"
 
extern CConstantMap g_ConstantMap;

#if 0



Command line arguments:
Must provide at least -action, and -file.
-action is one of start, stop, enable, query, update or queryall
-file is a single data file.
Examples: 
-file E:\EventTrace\TCODataFiles\ANSI\1-1-1-2.txt
-detail E:\EventTrace\TCOLogFiles\ANSI\TestRuns



If you are using this framework to drive non-collection control tests
use -action scenario.


#endif


#define ERROR_COULD_NOT_CREATE_PROCESS      10
#define ERROR_COULD_NOT_GET_PROCESS_RETURN	11
#define ERROR_WAIT_FAILED					12


struct ProcessData
{
	// Passed from caller.
	LPTSTR m_lptstrExePath;
	LPTSTR m_lptstrCmdLine;
	LPTSTR m_lptstrTCOId;
	LPTSTR m_lptstrLogFile;
	int m_nGuids;
	LPGUID m_lpguidArray;
	HANDLE m_hEventContinue;
	HANDLE m_hEventProcessCompleted;
	// Filled in by thread that starts the process
	DWORD m_dwThreadReturn;
	HANDLE m_hProcess;
	DWORD m_dwProcessReturn;
	int m_nSystemError;
};

struct StartTraceWithProviderData
{
	TCOData *m_pstructTCOData;
	TCOFunctionalData *m_pstructTCOFunctionalData;
	LPTSTR m_lptstrAction;
	LPTSTR m_lptstrDataFile;
	LPTSTR m_lptstrDetailPath;
	
	LPTSTR m_lptstrTCOTestError;
	ProcessData *m_pstructProcessData;
	bool m_bStartConsumers;
	ProcessData **m_pstructConsumerDataArray;
	HANDLE *m_handleConsmers;
};

void FreeStartTraceWithProviderData(StartTraceWithProviderData *p);
void FreeStartTraceWithProviderDataArray(StartTraceWithProviderData **p, int nP);

ProcessData *InitializeProcessData
(
	TCOData *pstructTCOData,
	TCOFunctionalData *pstructTCOFunctionalData,
	LPTSTR lptstrDetailPath, 
	int nProcessIndex,
	bool bProvider
);

void FreeProcessData(ProcessData *pProcessData);
void FreeProcessDataArray(ProcessData **pProcessData, int nProcessData);

void InitializeExeAndCmdLine
(
	ProcessData *&pstructProcessData,
	TCOData *pstructTCOData,
	TCOFunctionalData *pstructTCOFunctionalData,
	LPTSTR lptstrDetailPath,
	int nProcessIndex,
	bool bProvider
);

// Just allows the test to be driven programatically in addition to from
// the command line.  Dispatches based upon lptstrAction.
int BeginTCOTest
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	LPTSTR lptstrUpdateDataFile,
	LPTSTR lptstrProviderExe,
	bool bLogExpected,
	bool bUseTraceHandle
);

// List of files or single file.
int ActionScenario
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	bool bLogExpected
);

int ActionStartTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	bool bLogExpected
);

int ActionStopTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	bool bLogExpected,
	bool bUseTraceHandle
);

int ActionEnableTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	bool bLogExpected
);

int ActionQueryTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	bool bLogExpected,
	bool bUseTraceHandle
);

int ActionUpdateTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	LPTSTR lptstrUpdateDataFile,
	bool bLogExpected,
	bool bUseTraceHandle
);

int ActionQueryAllTraces
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDetailPath
);

int ActionStartProvider
(
	LPTSTR lptstrAction,
	LPTSTR lptstrProviderExe
);

int RunActionScenarioWithProvider
(
	TCOData *pstructTCOData,
	TCOFunctionalData *pstructTCOFunctionalData,
	LPTSTR &lptstrAction,
	LPTSTR &lpctstrDataFile,		
	LPTSTR &lptstrDetailPath,
	
	LPTSTR &lptstrTCOTestError
);

unsigned int __stdcall RunActionScenarioWithProvider(void *pVoid);

int GetArgs
(
	t_string tsCommandLine,
	LPTSTR &lptstrAction,
	LPTSTR &lptstrDataFile,
	LPTSTR &lptstrDetailPath,
	
	LPTSTR &lptstrUpdateDataFile,
	LPTSTR &lptstrProviderExe,
	bool &bLogExpected,
	bool &bUseTraceHandle		// QueryTrace, EnableTrace,  UpdateTrace, and StopTrace
);

int FreeArgs
(
	LPTSTR &lptstrAction,
	LPTSTR &lptstrDataFile,
	LPTSTR &lptstrDetailPath,
	
	LPTSTR &lptstrUpdateDataFile,
	LPTSTR &lptstrProviderExe
);

t_string GetTestName(LPTSTR lptstrDataFile);

unsigned int __stdcall RunProcess (void * pVoid);

void ThreadLogger
(int nState, LPCTSTR lptstrFunction, LPCTSTR lptstrMsg, bool bUseULONGValue, ULONG ulValue);

CLogger g_ThreadLogger(_T("E:\\EventTrace\\TCOLogFiles\\ThreadLog.txt"), false);

// Command line 
// -action starttrace  -file E:\EventTrace\TCODataFiles\unicode\1-1-1-2.txt  -detail E:\EventTrace\TCOLogFiles\ANSI\TestRuns 

#ifdef NT5BUILD
__cdecl
#else
int
#endif
main(int argc, char* argv[])
{
	LPTSTR lptstrAction = NULL;
	LPTSTR lptstrDataFile = NULL;
	LPTSTR lptstrDetailPath = NULL;
	LPTSTR lptstrUpdateDataFile = NULL;
	LPTSTR lptstrProviderExe = NULL;

	bool bLogExpected = true;
	bool bUseTraceHandle = false;

	t_string tsCommandLine;
	LPTSTR lptstrCommandLine = NewTCHAR (GetCommandLine());
	tsCommandLine = lptstrCommandLine;
	free(lptstrCommandLine);
	lptstrCommandLine = NULL;

	int nReturn = 
		GetArgs
		(
			tsCommandLine,
			lptstrAction,
			lptstrDataFile,
			lptstrDetailPath,
			
			lptstrUpdateDataFile,
			lptstrProviderExe,
			bLogExpected,
			bUseTraceHandle
		);

	if (nReturn != 0)
	{
		t_cout << _T("Command line error with: \n") << tsCommandLine.c_str() << _T(".\n");
		FreeArgs
		(
			lptstrAction,
			lptstrDataFile,
			lptstrDetailPath,
			
			lptstrUpdateDataFile,
			lptstrProviderExe
		);

		return nReturn;
	} 

	if (!lptstrDataFile && 
		!(case_insensitive_compare(lptstrAction,_T("queryalltraces")) == 0 ||
		  case_insensitive_compare(lptstrAction,_T("providerexe")) == 0 || 
		  case_insensitive_compare(lptstrAction,_T("line")) == 0 ||
		  case_insensitive_compare(lptstrAction,_T("sleep")) == 0)
	    )
	{
		t_cout << _T("Must provide a data file!\n");
		FreeArgs
		(
			lptstrAction,
			lptstrDataFile,
			lptstrDetailPath,
			
			lptstrUpdateDataFile,
			lptstrProviderExe
		);
	
		return -1;
	}

	nReturn = 
		BeginTCOTest 
		(
			lptstrAction,
			lptstrDataFile,
			lptstrDetailPath,
			
			lptstrUpdateDataFile,
			lptstrProviderExe,
			bLogExpected,
			bUseTraceHandle
		);

	FreeArgs
		(
			lptstrAction,
			lptstrDataFile,
			lptstrDetailPath,
			lptstrUpdateDataFile,
			lptstrProviderExe
		);

	return nReturn;

}

int BeginTCOTest
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	LPTSTR lptstrUpdateDataFile,
	LPTSTR lptstrProviderExe,
	bool bLogExpected,
	bool bUseTraceHandle
)
{
	int nReturn = ERROR_SUCCESS;

	if (case_insensitive_compare(lptstrAction,_T("scenario")) == 0)
	{
		nReturn = 
			ActionScenario
			(
				lptstrAction,
				lptstrDataFile,
				lptstrDetailPath,
				
				bLogExpected
			);
	}
	else if (case_insensitive_compare(lptstrAction,_T("starttrace")) == 0)
	{
		nReturn = 
			ActionStartTrace
			(
				lptstrAction,
				lptstrDataFile,
				lptstrDetailPath,
				
				bLogExpected
			);
	}
	else if (case_insensitive_compare(lptstrAction,_T("stoptrace")) == 0)
	{
		nReturn = 
			ActionStopTrace
			(
				lptstrAction,
				lptstrDataFile,
				lptstrDetailPath,
				
				bLogExpected,
				bUseTraceHandle
			);
	}
	else if (case_insensitive_compare(lptstrAction,_T("enabletrace")) == 0)
	{
		nReturn = 
			ActionEnableTrace
			(
				lptstrAction,
				lptstrDataFile,
				lptstrDetailPath,
				
				bLogExpected
			);
	}
	else if (case_insensitive_compare(lptstrAction,_T("querytrace")) == 0)
	{
		nReturn = 
			ActionQueryTrace
			(
				lptstrAction,
				lptstrDataFile,
				lptstrDetailPath,
				
				bLogExpected,
				bUseTraceHandle
			);
	}
	else if (case_insensitive_compare(lptstrAction,_T("updatetrace")) == 0)
	{
		// If bUseTraceHandle is true we will start things with the 
		// lptstrDataFile and update with the lptstrUpdateDataFile.
		// If bUseTraceHandle is false we will update with the
		// lptstrDataFile.  
		nReturn = 
			ActionUpdateTrace
			(
				lptstrAction,
				lptstrDataFile,
				lptstrDetailPath,
				
				lptstrUpdateDataFile,
				bLogExpected,
				bUseTraceHandle
			);
	}
	else if (case_insensitive_compare(lptstrAction,_T("queryalltraces")) == 0)
	{
		nReturn = 
			ActionQueryAllTraces
			(
				lptstrAction,
				lptstrDetailPath
			);
	}
	else if (case_insensitive_compare(lptstrAction,_T("providerexe")) == 0)
	{
		nReturn = 
			ActionStartProvider
			(
				lptstrAction,
				lptstrProviderExe
			);
	}
	else if (case_insensitive_compare(lptstrAction,_T("sleep")) == 0)
	{
		nReturn = ERROR_SUCCESS;
		Sleep(5000);
	}
	else if (case_insensitive_compare(lptstrAction,_T("line")) == 0)
	{
		t_cout << _T("\n");
	}

	return nReturn;
}

int ActionStartTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	bool bLogExpected
)
{
	int nResult = ERROR_SUCCESS;
	LPTSTR lptstrTCOTestError = NULL;
	TCOData *pstructTCOData = NULL;
	TCOFunctionalData *pstructTCOFunctionalData = NULL;
	int nAPICallResult = 0;
	t_string tsDetailFile;
		
	nResult = 
		GetAllTCOData
		(
			lptstrDataFile ,
			&pstructTCOData,
			&pstructTCOFunctionalData,
			&lptstrTCOTestError
		);

	if (nResult != ERROR_SUCCESS)
	{
		t_cout << _T("Could not get TCO Data: ") << lptstrTCOTestError << _T("\n");
		FreeTCOData(pstructTCOData);
		pstructTCOData = NULL;
		FreeTCOFunctionalData(pstructTCOFunctionalData);
		pstructTCOFunctionalData = NULL;
		free(lptstrTCOTestError);
		lptstrTCOTestError = NULL;
		return nResult;
	}

	tsDetailFile = lptstrDetailPath;
	tsDetailFile += _T("\\");
	tsDetailFile += GetTestName(lptstrDataFile);

	nResult = 
		StartTraceAPI
		(
			lptstrAction,
			lptstrDataFile,
			tsDetailFile.c_str(),
			bLogExpected,
			pstructTCOData,
			&nAPICallResult
		);

	tsDetailFile.erase();

	FreeTCOData(pstructTCOData);
	FreeTCOFunctionalData(pstructTCOFunctionalData);

	return nResult;
}

int ActionStopTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	bool bLogExpected,
	bool bUseTraceHandle
)
{
	int nResult = ERROR_SUCCESS;
	LPTSTR lptstrTCOTestError = NULL;
	TCOData *pstructTCOData = NULL;
	TCOFunctionalData *pstructTCOFunctionalData = NULL;
	int nAPICallResult = 0;
	t_string tsDetailFile;
		
	nResult = 
		GetAllTCOData
		(
			lptstrDataFile ,
			&pstructTCOData,
			&pstructTCOFunctionalData,
			&lptstrTCOTestError
		);

	if (nResult != ERROR_SUCCESS)
	{
		t_cout << _T("Could not get TCO Data: ") << lptstrTCOTestError << _T("\n");
		FreeTCOData(pstructTCOData);
		pstructTCOData = NULL;
		FreeTCOFunctionalData(pstructTCOFunctionalData);
		pstructTCOFunctionalData = NULL;
		free(lptstrTCOTestError);
		lptstrTCOTestError = NULL;
		return nResult;
	}

	tsDetailFile = lptstrDetailPath;
	tsDetailFile += _T("\\");
	tsDetailFile += GetTestName(lptstrDataFile);
	t_string tsError;

	// If bUseTraceHandle is true we will start the logger.  
	if (bUseTraceHandle)
	{
		nResult = 
			StartTraceAPI
			(
				lptstrAction,
				lptstrDataFile,
				tsDetailFile.c_str(),
				false,
				pstructTCOData,
				&nAPICallResult
			);

		if (nResult != ERROR_SUCCESS)
		{
			FreeTCOData(pstructTCOData);
			FreeTCOFunctionalData(pstructTCOFunctionalData);
			return nResult;
		}

		Sleep(2000);

		int nResult2 = 
			EnableTraceAPI
			(
				lptstrAction,
				lptstrDataFile,
				tsDetailFile.c_str(),
				false,
				pstructTCOData,
				&nAPICallResult
			);
		Sleep(5000);
		// Restore this.
		nAPICallResult = ERROR_SUCCESS;
	}

	nResult = 
		StopTraceAPI
		(
			lptstrAction,	
			lptstrDataFile,
			tsDetailFile.c_str(),
			bLogExpected,
			bUseTraceHandle,
			pstructTCOData,
			&nAPICallResult
		);

	tsDetailFile.erase();

	FreeTCOData(pstructTCOData);
	FreeTCOFunctionalData(pstructTCOFunctionalData);

	return nResult;
}

int ActionEnableTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	bool bLogExpected
)
{
	int nResult = ERROR_SUCCESS;
	LPTSTR lptstrTCOTestError = NULL;
	TCOData *pstructTCOData = NULL;
	TCOFunctionalData *pstructTCOFunctionalData = NULL;
	int nAPICallResult = 0;
	t_string tsDetailFile;
	
	t_string tsError;


	nResult = 
		GetAllTCOData
		(
			lptstrDataFile ,
			&pstructTCOData,
			&pstructTCOFunctionalData,
			&lptstrTCOTestError
		);

	if (nResult != ERROR_SUCCESS)
	{
		t_cout << _T("Could not get TCO Data: ") << lptstrTCOTestError << _T("\n");
		FreeTCOData(pstructTCOData);
		pstructTCOData = NULL;
		FreeTCOFunctionalData(pstructTCOFunctionalData);
		pstructTCOFunctionalData = NULL;
		free(lptstrTCOTestError);
		lptstrTCOTestError = NULL;
		return nResult;
	}

	tsDetailFile = lptstrDetailPath;
	tsDetailFile += _T("\\");
	tsDetailFile += GetTestName(lptstrDataFile);

	nResult = 
		StartTraceAPI
		(
			lptstrAction,
			lptstrDataFile,
			tsDetailFile.c_str(),
			false,
			pstructTCOData,
			&nAPICallResult
		);

	// We have a problem here if nResult != ERROR_SUCCESS and nAPICallResult == ERROR_SUCCESS
	// we need to call EnableTrace so that the provider can be stopped via a StopTrace
	// call.
	if (nResult != ERROR_SUCCESS && nAPICallResult == ERROR_SUCCESS)
	{
		Sleep(2000);
		// Do not really care what result is!
		int nResult2 = 
			EnableTraceAPI
			(
				lptstrAction,
				lptstrDataFile,
				tsDetailFile.c_str(),
				false,
				pstructTCOData,
				&nAPICallResult
			);
		Sleep(5000);
		// Restore this.
		nAPICallResult = ERROR_SUCCESS;
	}
	
	if (nResult == ERROR_SUCCESS)
	{
		Sleep(2000);

		nResult = 
			EnableTraceAPI
			(
				lptstrAction,
				lptstrDataFile,
				tsDetailFile.c_str(),
				bLogExpected,
				pstructTCOData,
				&nAPICallResult
			);
		Sleep(5000);
	}

	tsDetailFile.erase();

	FreeTCOData(pstructTCOData);
	FreeTCOFunctionalData(pstructTCOFunctionalData);

	return nResult;
}

int ActionQueryTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	bool bLogExpected,
	bool bUseTraceHandle
)
{
	int nResult = ERROR_SUCCESS;
	LPTSTR lptstrTCOTestError = NULL;
	TCOData *pstructTCOData = NULL;
	TCOFunctionalData *pstructTCOFunctionalData = NULL;
	int nAPICallResult = 0;
	t_string tsDetailFile;

	nResult = 
		GetAllTCOData
		(
			lptstrDataFile ,
			&pstructTCOData,
			&pstructTCOFunctionalData,
			&lptstrTCOTestError
		);

	if (nResult != ERROR_SUCCESS)
	{
		t_cout << _T("Could not get TCO Data: ") << lptstrTCOTestError << _T("\n");
		FreeTCOData(pstructTCOData);
		pstructTCOData = NULL;
		FreeTCOFunctionalData(pstructTCOFunctionalData);
		pstructTCOFunctionalData = NULL;
		free(lptstrTCOTestError);
		lptstrTCOTestError = NULL;
		return nResult;
	}

	tsDetailFile = lptstrDetailPath;
	tsDetailFile += _T("\\");
	tsDetailFile += GetTestName(lptstrDataFile);

	// If bUseTraceHandle is true we will start the logger.  
	if (bUseTraceHandle)
	{
		nResult = 
			StartTraceAPI
			(
				lptstrAction,
				lptstrDataFile,
				tsDetailFile.c_str(),
				false,
				pstructTCOData,
				&nAPICallResult
			);

		t_string tsError;

		if (nAPICallResult != ERROR_SUCCESS)
		{
			FreeTCOData(pstructTCOData);
			FreeTCOFunctionalData(pstructTCOFunctionalData);

			return nAPICallResult;
		}
		Sleep(2000);

		int nResult2 = 
			EnableTraceAPI
			(
				lptstrAction,
				lptstrDataFile,
				tsDetailFile.c_str(),
				false,
				pstructTCOData,
				&nAPICallResult
			);

		if (nAPICallResult != ERROR_SUCCESS)
		{
			FreeTCOData(pstructTCOData);
			FreeTCOFunctionalData(pstructTCOFunctionalData);

			return nAPICallResult;
		}

		Sleep(5000);
	}

	nResult = 
		QueryTraceAPI
		(
			lptstrAction,
			lptstrDataFile,
			tsDetailFile.c_str(),
			bLogExpected,
			bUseTraceHandle,
			pstructTCOData,
			&nAPICallResult
		);

	tsDetailFile.erase();

	FreeTCOData(pstructTCOData);
	FreeTCOFunctionalData(pstructTCOFunctionalData);

	return nResult;
}

int ActionUpdateTrace
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	LPTSTR lptstrUpdateDataFile,
	bool bLogExpected,
	bool bUseTraceHandle
)
{
	int nResult = ERROR_SUCCESS;
	LPTSTR lptstrTCOTestError = NULL;
	TCOData *pstructTCOData = NULL;
	TCOData *pstructUpdateData = NULL;  // Remember to free!
	TCOFunctionalData *pstructTCOFunctionalData = NULL;
	int nAPICallResult = 0;
	t_string tsDetailFile;

	if (bUseTraceHandle && !lptstrUpdateDataFile)
	{
		t_cout << _T("Error in ActionUpdateTrace:  If -usetracehandle 1 is true you must provide an -updatedata argument.\n");
		return -1;
	}

	if (bUseTraceHandle && lptstrUpdateDataFile)
	{
		nResult = 
				GetAllTCOData
				(
					lptstrUpdateDataFile ,
					&pstructUpdateData,
					NULL,
					&lptstrTCOTestError,
					false
				);
	}
	
	nResult = 
		GetAllTCOData
		(
			lptstrDataFile ,
			&pstructTCOData,
			&pstructTCOFunctionalData,
			&lptstrTCOTestError
		);

	if (nResult != ERROR_SUCCESS)
	{
		t_cout << _T("Could not get TCO Data: ") << lptstrTCOTestError << _T("\n");
		FreeTCOData(pstructTCOData);
		pstructTCOData = NULL;
		FreeTCOFunctionalData(pstructTCOFunctionalData);
		pstructTCOFunctionalData = NULL;
		free(lptstrTCOTestError);
		lptstrTCOTestError = NULL;
		return nResult;
	}

	tsDetailFile = lptstrDetailPath;
	tsDetailFile += _T("\\");
	tsDetailFile += GetTestName(lptstrDataFile);

	// If bUseTraceHandle is true we will start the logger.  
	if (bUseTraceHandle)
	{
		nResult = 
			StartTraceAPI
			(
				lptstrAction,
				lptstrDataFile,
				tsDetailFile.c_str(),
				false,
				pstructTCOData,
				&nAPICallResult
			);

		t_string tsError;

		if (nAPICallResult != ERROR_SUCCESS)
		{
			FreeTCOData(pstructTCOData);
			FreeTCOFunctionalData(pstructTCOFunctionalData);

			return nAPICallResult;
		}
		Sleep(2000);

		int nResult2 = 
			EnableTraceAPI
			(
				lptstrAction,
				lptstrDataFile,
				tsDetailFile.c_str(),
				false,
				pstructTCOData,
				&nAPICallResult
			);

		if (nAPICallResult != ERROR_SUCCESS)
		{
			FreeTCOData(pstructTCOData);
			FreeTCOFunctionalData(pstructTCOFunctionalData);

			return nAPICallResult;
		}

		Sleep(5000);
	}

	if (bUseTraceHandle)
	{
		pstructUpdateData->m_pTraceHandle =  
			(TRACEHANDLE *) malloc (sizeof(TRACEHANDLE));
		*pstructUpdateData->m_pTraceHandle = *pstructTCOData->m_pTraceHandle;
	}

	nResult = 
		UpdateTraceAPI
		(
			lptstrAction,
			lptstrDataFile,
			tsDetailFile.c_str(),
			bLogExpected,
			bUseTraceHandle,
			bUseTraceHandle ? pstructUpdateData : pstructTCOData,
			&nAPICallResult
		);

	tsDetailFile.erase();

	FreeTCOData(pstructTCOData);
	FreeTCOFunctionalData(pstructTCOFunctionalData);
	FreeTCOData(pstructUpdateData);

	return nResult;
}

int ActionQueryAllTraces
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDetailPath
)
{
	int nAPICallResult = ERROR_SUCCESS;
		
	int nResult = 
		QueryAllTracesAPI
		(
			lptstrAction,		
			&nAPICallResult
		);


	t_string tsError;

	if (nResult != ERROR_SUCCESS)
	{
		tsError = ULONGVarToTString(nResult, true);
		LPTSTR lptstrError = DecodeStatus(nResult);
		t_cout << _T("ActionQueryAllTraces Failure: ") << tsError;
		if (lptstrError)
		{
			t_cout << _T(" - ") << lptstrError << _T("\n");
		}
		else
		{
			t_cout << _T(".\n");
		}
		free (lptstrError);
		lptstrError = NULL;
	
	}

	return nResult;
}

int ActionStartProvider
(
	LPTSTR lptstrAction,
	LPTSTR lptstrProviderExe
)
{
	t_string tsExeAndCmdLine;
	tsExeAndCmdLine = lptstrProviderExe;
	int nEndExe = tsExeAndCmdLine.find(_T(".exe"));
	nEndExe += 4;

	t_string tsExe;
	tsExe = tsExeAndCmdLine.substr(0,nEndExe);

	t_string tsCmdLine;

	if (nEndExe + 1 < tsExeAndCmdLine.length())
	{
		tsCmdLine = tsExeAndCmdLine.substr(nEndExe + 1,t_string::npos);
	}

	PROCESS_INFORMATION pinfoProvider;

	RtlZeroMemory(&pinfoProvider, sizeof(PROCESS_INFORMATION));

	STARTUPINFO sinfoProvider;

	RtlZeroMemory(&sinfoProvider, sizeof(STARTUPINFO));

	sinfoProvider.cb = sizeof(sinfoProvider);
	sinfoProvider.lpReserved = NULL;
	sinfoProvider.lpDesktop = NULL;
	sinfoProvider.lpTitle = NULL;
	sinfoProvider.dwFlags = 0;
	sinfoProvider.cbReserved2 = 0;
	sinfoProvider.lpReserved2 = NULL;
	sinfoProvider.hStdInput = NULL;
	sinfoProvider.hStdOutput = NULL;
	sinfoProvider.hStdError = NULL;

	BOOL bReturn =
		CreateProcess(
				tsExe.c_str(),
				(TCHAR *) tsCmdLine.c_str(),
				NULL,
				NULL,
				NULL,
				DETACHED_PROCESS,
				NULL,
				NULL,
				&sinfoProvider,
				&pinfoProvider);


	if (!bReturn)
	{
		DWORD dwError = GetLastError();
		t_cout << _T("\nCreateProcess failed for provider ") << tsExe << _T("\n");
		t_cout << _T("with command line ") << tsCmdLine << _T(".\n");
		LPTSTR lpstrReturnedError = DecodeStatus(dwError);
		t_cout << _T("Error: ") << lpstrReturnedError << _T("\n");
		free(lpstrReturnedError);

		return ERROR_COULD_NOT_CREATE_PROCESS;
	}


	t_cout << _T("\nCreateProcess succeeded for provider ") << tsExe << _T("\n");
	t_cout << _T("with command line ") << tsCmdLine << _T(".\n");

	// Do not need to hold on to this!
	CloseHandle(pinfoProvider.hProcess);
	CloseHandle(pinfoProvider.hThread);

	// Give the process 5 seconds to get going.
	Sleep(5000);

	return ERROR_SUCCESS;
}


int ActionScenario
(
	LPTSTR lptstrAction,
	LPTSTR lptstrDataFile,
	LPTSTR lptstrDetailPath,
	
	bool bLogExpected
)
{
	int nResult = ERROR_SUCCESS;
	LPTSTR lptstrTCOTestError = NULL;
	TCOData *pstructTCOData = NULL;
	TCOFunctionalData *pstructTCOFunctionalData = NULL;

	nResult = 
		GetAllTCOData
		(
			lptstrDataFile ,
			&pstructTCOData,
			&pstructTCOFunctionalData,
			&lptstrTCOTestError
		);

	if (nResult != ERROR_SUCCESS)
	{
		t_cout << _T("Could not get TCO Data: ") << lptstrTCOTestError << _T("\n");
		FreeTCOData(pstructTCOData);
		pstructTCOData = NULL;
		FreeTCOFunctionalData(pstructTCOFunctionalData);
		pstructTCOFunctionalData = NULL;
		free(lptstrTCOTestError);
		lptstrTCOTestError = NULL;
		return nResult;
	}

	nResult = 
		RunActionScenarioWithProvider
		(
			pstructTCOData,
			pstructTCOFunctionalData,
			lptstrAction,
			lptstrDataFile,
			lptstrDetailPath,
			lptstrTCOTestError
		);

	FreeTCOData(pstructTCOData);
	FreeTCOFunctionalData(pstructTCOFunctionalData);

	t_string tsError;
	if (nResult != ERROR_SUCCESS)
	{
		tsError = ULONGVarToTString(nResult, true);
		LPTSTR lptstrError = DecodeStatus(nResult);
		t_cout << _T("ActionScenario Failure: ") << tsError;
		if (lptstrError)
		{
			t_cout << _T(" - ") << lptstrError << _T("\n");
		}
		else
		{
			t_cout << _T(".\n");
		}
		free (lptstrError);
		lptstrError = NULL;
	}

	return nResult;
}

int RunActionScenarioWithProvider
(
	TCOData *pstructTCOData,
	TCOFunctionalData *pstructTCOFunctionalData,
	LPTSTR &lptstrAction,
	LPTSTR &lptstrDataFile,
	LPTSTR &lptstrDetailPath,
	LPTSTR &lptstrTCOTestError
)
{	
	bool bLast = false;
	int nResult = ERROR_SUCCESS;
	int i;

	ProcessData **pstructProviderDataArray = NULL;
	StartTraceWithProviderData  **pstructStartTraceData = NULL;
	HANDLE *phandleProviderThreads = NULL;

	// Here we want to build up array of provider ProcessData./
	// Start a thread for each.
	// Wait for all of the provider threads to complete.

	if (pstructTCOFunctionalData->m_nProviders > 0)
	{
		pstructStartTraceData = 
			(StartTraceWithProviderData **) malloc
				(sizeof (StartTraceWithProviderData *) * 
					pstructTCOFunctionalData->m_nProviders);

		RtlZeroMemory
			(pstructStartTraceData, 
			 sizeof (StartTraceWithProviderData *) * 
					pstructTCOFunctionalData->m_nProviders);

		for (i = 0; i < pstructTCOFunctionalData->m_nProviders; i++)
		{
			pstructStartTraceData[i] = 
				(StartTraceWithProviderData *) malloc (sizeof(StartTraceWithProviderData));

			RtlZeroMemory
			(pstructStartTraceData[i], 
			 sizeof (StartTraceWithProviderData));
		}

		pstructProviderDataArray = 
			(ProcessData **) malloc 
				(sizeof (ProcessData *) * 
					pstructTCOFunctionalData->m_nProviders);

		RtlZeroMemory
			(pstructProviderDataArray, 
			 sizeof (ProcessData *) * 
			 pstructTCOFunctionalData->m_nProviders);

		phandleProviderThreads = 
			(HANDLE *) malloc (sizeof (HANDLE) * 
								pstructTCOFunctionalData->m_nProviders);

		RtlZeroMemory
			(phandleProviderThreads,
			 sizeof (HANDLE) * 
			 pstructTCOFunctionalData->m_nProviders);

		for (int n = 0; n < pstructTCOFunctionalData->m_nProviders; n++)
		{
				pstructProviderDataArray[n] = 
					InitializeProcessData
					(
						pstructTCOData,
						pstructTCOFunctionalData,
						lptstrDetailPath,
						n,		// 0 index gets the first provider or consumer.
						true	// bProvider, if false we get Consumer.
					);

				if (!pstructProviderDataArray[n]->m_hEventContinue || 
					!pstructProviderDataArray[n]->m_hEventProcessCompleted)
				{
					lptstrTCOTestError = 
						NewTCHAR(_T("Provider Data Array:  Could not create events."));
					FreeProcessDataArray
						(pstructProviderDataArray,pstructTCOFunctionalData->m_nProviders);
					return -1;
				}

		}
	}

	ProcessData **pstructConsumerDataArray = NULL;
	int npstructStartTraceDataWithConsumers = -1;

	for (i = 0; i < pstructTCOFunctionalData->m_nProviders; i++)
	{
		if (i == pstructTCOFunctionalData->m_nProviders - 1)
		{
			bLast = true;
		}

		bool bStartConsumers = 
			(!pstructTCOData->m_pProps)
			? false
			:
			 (pstructTCOData->m_pProps->LogFileMode == EVENT_TRACE_REAL_TIME_MODE && i == 0) 
			 ? true 
			 : (pstructTCOData->m_pProps->LogFileMode != EVENT_TRACE_REAL_TIME_MODE && bLast)
			   ?
			   true:
			   false;

		pstructStartTraceData[i]->m_pstructTCOData = pstructTCOData;
		pstructStartTraceData[i]->m_pstructTCOFunctionalData = pstructTCOFunctionalData;
		pstructStartTraceData[i]->m_lptstrAction = lptstrAction;
		pstructStartTraceData[i]->m_lptstrDataFile = lptstrDataFile;
		pstructStartTraceData[i]->m_lptstrDetailPath = lptstrDetailPath;
		pstructStartTraceData[i]->m_pstructProcessData = pstructProviderDataArray[i];
		pstructStartTraceData[i]->m_bStartConsumers = bStartConsumers;
		pstructStartTraceData[i]->m_pstructConsumerDataArray = pstructConsumerDataArray;
		if (bStartConsumers)
		{
			pstructStartTraceData[i]->m_handleConsmers = 
				(HANDLE *) malloc (sizeof(HANDLE) *  pstructTCOFunctionalData->m_nConsumers);
			RtlZeroMemory(pstructStartTraceData[i]->m_handleConsmers,
						  sizeof(HANDLE) *  pstructTCOFunctionalData->m_nConsumers);
			npstructStartTraceDataWithConsumers = i;
		}
	
		// Start the provider processes via a thread.  The thread will become
		// the surogate for thr process.

		UINT uiThreadId = NULL;

		phandleProviderThreads[i]  = 
			(HANDLE) _beginthreadex
				(NULL,  0, RunActionScenarioWithProvider, 
				(void *) pstructStartTraceData[i], 0 , &uiThreadId);

		HANDLE hTemp = phandleProviderThreads[i];
		ThreadLogger(3,_T("RunActionScenarioWithProvider"),
					_T("Just created thread with handle"),true,
					 (ULONG)hTemp);

		if (phandleProviderThreads[i] == 0)
		{
			int nError = errno;
			lptstrTCOTestError = 
				NewTCHAR(_T("Could not start RunActionScenarioWithProvider thread."));
			nResult = nError;
			break;
		}
	}

	// Big logic here.  This is where we wait for all of the 
	// conusmer processes to complete if we have consumers and
	// all of the provider threads.  The provider threads wait for the
	// provider processes to complete so we just wait on the threads.
	// One of the provider threads starts the consumer processes but
	// does not wait on them.  So we wait on them here.  Again, we
	// wait on the consumer threads.

	// After the threads complete we will call StopTrace.

	// Create an array to hold the handles
	HANDLE *phandleAllThreads = 
			(HANDLE *) malloc (sizeof (HANDLE) * 
								(pstructTCOFunctionalData->m_nProviders +
								pstructTCOFunctionalData->m_nConsumers));

	RtlZeroMemory
			(phandleAllThreads,
			 sizeof (HANDLE) * 
			 (pstructTCOFunctionalData->m_nProviders +
								pstructTCOFunctionalData->m_nConsumers));

	int nHandles = 0;

	// Copy handles into it.
	for (i = 0; i < pstructTCOFunctionalData->m_nProviders; i++)
	{
		if (phandleProviderThreads[i])
		{
			phandleAllThreads[nHandles++] = phandleProviderThreads[i];
		}
	}

	for (i = 0; i < pstructTCOFunctionalData->m_nConsumers; i++)
	{
		if (pstructStartTraceData[npstructStartTraceDataWithConsumers]->m_handleConsmers[i])
		{
			phandleAllThreads[nHandles++] = 
				pstructStartTraceData[npstructStartTraceDataWithConsumers]->m_handleConsmers[i];
		}
	}
	
	Sleep (5000);
	// Wait for the provider and consumer threads to complete.
	DWORD dwWait = 
		WaitForMultipleObjects
		(
			nHandles,
			phandleAllThreads,
			TRUE,
			10000
		);
 
	free(phandleAllThreads);  // Just free storage the handles get closed elsewhere.

	int nAPICallResult = 0;

	if (pstructStartTraceData[0]->m_pstructTCOData->m_pProps->LoggerName &&
		pstructStartTraceData[0]->m_pstructTCOData->m_pProps)
	{
		nResult = StopTraceAPI
			(	
				lptstrAction,
				NULL,	// Only use name.
				NULL,	// If valid we will log to it, can be NULL.
				false,
				true,
				pstructStartTraceData[0]->m_pstructTCOData,
				&nAPICallResult
			);

		if (nAPICallResult != ERROR_SUCCESS)
		{
			LPTSTR lptstrError = 
				DecodeStatus(nAPICallResult);
			t_string tsError;
			tsError = _T("StopTraceAPI failed with error: ");
			tsError += lptstrError;
			lptstrTCOTestError = 
				NewTCHAR(tsError.c_str());
			free (lptstrError);
			lptstrError = NULL;
			nResult = nAPICallResult;
		}
	}

	// Need to CloseHandle(); before we free these guys!
	for (i = 0; i < pstructTCOFunctionalData->m_nProviders; i++)
	{
		if (phandleProviderThreads[i])
		{
			if (phandleProviderThreads[i])
			{
				CloseHandle(phandleProviderThreads[i]);
			}
		}
	}
	free (phandleProviderThreads);

	FreeProcessDataArray
		(pstructProviderDataArray,pstructTCOFunctionalData->m_nProviders);

	FreeProcessDataArray
		(pstructConsumerDataArray,pstructTCOFunctionalData->m_nConsumers);

	FreeStartTraceWithProviderDataArray
		(pstructStartTraceData,pstructTCOFunctionalData->m_nProviders);

	return nResult;
}

// This gets started in its own thread and its caller waits for it to complete.
unsigned int __stdcall RunActionScenarioWithProvider(void *pVoid)
{
	StartTraceWithProviderData  *pData = 
		(StartTraceWithProviderData  *) pVoid;

	t_string tsLogMsg;

	tsLogMsg = _T("RunActionScenarioWithProvider");

	ThreadLogger(1,tsLogMsg.c_str(),_T(""),false,0);

	pData->m_pstructConsumerDataArray = NULL;

	// We do not exit this function until the process has failed to be
	// created or has completed.  We can not free things in the ProcessData
	// structure until we are sure that the thread has exited one way or
	// another.
	
	UINT uiThreadId = NULL;

	HANDLE hThreadProvider = 
		(HANDLE) _beginthreadex
			(NULL,  0, RunProcess, (void *) pData->m_pstructProcessData, 0 , &uiThreadId);

	if (hThreadProvider == 0)
	{
		int nError = errno;
		pData->m_lptstrTCOTestError = 
			NewTCHAR(_T("Could not start RunProcesss thread."));
		ThreadLogger(3,_T("RunActionScenarioWithProvider"),
					pData->m_lptstrTCOTestError,true, nError);
		_endthreadex(nError);
		return nError;
	}

	DWORD dwReturn = 
		WaitForSingleObject
			(pData->m_pstructProcessData->m_hEventContinue, 6000);

	// Give the thread 1 second to get going.
	Sleep(3000);

	// If the thread is not active there was a problem getting it 
	// started so we will bail.
	DWORD dwExitCode;
	GetExitCodeThread(hThreadProvider, &dwExitCode);
	if (dwExitCode != STILL_ACTIVE || 
		pData->m_pstructProcessData->m_dwThreadReturn == ERROR_COULD_NOT_CREATE_PROCESS)
	{
		CloseHandle(hThreadProvider);
		if (pData->m_pstructProcessData->m_dwThreadReturn == ERROR_COULD_NOT_CREATE_PROCESS)
		{
			pData->m_lptstrTCOTestError = NewTCHAR(_T("Could not create process."));
		}
		else
		{
			pData->m_lptstrTCOTestError = NewTCHAR(_T("Error in RunProcesss thread."));
		}
		if(pData->m_pstructProcessData->m_hProcess)
		{
			CloseHandle(pData->m_pstructProcessData->m_hProcess);
			pData->m_pstructProcessData->m_hProcess = NULL;
		}
		ThreadLogger(2,_T("RunActionScenarioWithProvider"),
					pData->m_lptstrTCOTestError,false, 0);
		_endthreadex(-1);
		return -1;
	}

	t_string tsDetailFile;
	if (pData->m_lptstrDetailPath)
	{
		tsDetailFile = pData->m_lptstrDetailPath;
		tsDetailFile += _T("\\");
		tsDetailFile += GetTestName(pData->m_lptstrDataFile);
	}

	// nAPICallResult is what the StartTrace call returned.
	// If the call does not succeed we have to clean up the 
	// process.  If the call does succeed we need to call
	// EnableTrace to get the provider going.
	int nAPICallResult = ERROR_SUCCESS;

	int nResult = 
		StartTraceAPI
		(
			pData->m_lptstrAction,
			pData->m_lptstrDataFile,
			pData->m_lptstrDetailPath ? tsDetailFile.c_str() : NULL,
			false,
			pData->m_pstructTCOData,
			&nAPICallResult
		);

	// Big assumption here!
	// If nAPICallResult == 0x000000a1 we assume that multiple StartTraces and that
	// the first one succeeded!

	if (nAPICallResult == ERROR_BAD_PATHNAME)
	{
		ThreadLogger(3,_T("RunActionScenarioWithProvider"),
					_T("StartTraceAPI function returned ERROR_BAD_PATHNAME. Proceeding."),false, 0);
		nAPICallResult = ERROR_SUCCESS;
		nResult = ERROR_SUCCESS;
	}
	else
	{
		ThreadLogger(3,_T("RunActionScenarioWithProvider"),
					_T("StartTraceAPI function returned "),true, nResult);
		ThreadLogger(3,_T("RunActionScenarioWithProvider"),
					_T("StartTrace API call returned "),true, nAPICallResult);
	}


	if (nAPICallResult != ERROR_SUCCESS)
	{
		// Here we must cleanup process because 
		// provider is running and we must stop it!
		BOOL bResult = 
			TerminateProcess(pData->m_pstructProcessData->m_hProcess,0);

		if (!bResult)
		{
			int nError = GetLastError();
			ThreadLogger(3,_T("RunActionScenarioWithProvider"),
				_T("Could not terminate process "),true, nError);

		}
		// Do not want to free the data structures until process
		// terminates.  Use thread as surrogate for process.
		GetExitCodeThread(hThreadProvider, &dwExitCode);
		while (dwExitCode == STILL_ACTIVE)
		{
			Sleep(500);
			GetExitCodeThread(hThreadProvider, &dwExitCode);
		}
	}

	// If we were able to call StartTrace successfully we must call
	// EnableTrace to get the provider going so it can complete.
	// If we do not successfully call EnableTrace we need to
	// clean up the thread and the process.
	if (nAPICallResult == ERROR_SUCCESS)
	{
		// If we cannot start the provider using the GUID in 
		// Wnode.Guid we give up.  Also, we do not care
		// if EnableTrace fails for the other GUIDs.
		ULONG ulStatus = EnableTraceAPI
				(	
					pData->m_lptstrAction,
					NULL,
					NULL,
					false,
					-1,
					pData->m_pstructTCOData,
					&nAPICallResult
				);

		// Exit here after we clean up!
		if (nAPICallResult != ERROR_SUCCESS)
		{
			pData->m_lptstrTCOTestError = NewTCHAR(_T("Could not EnableTrace to start provider."));
			// Here we must cleanup thread and process because 
			// EnableTrace failed.
			TerminateProcess(pData->m_pstructProcessData->m_hProcess,0);
			// Do not want to free the data structures until process
			// terminates.  Use thread as surrogate for process.
			GetExitCodeThread(hThreadProvider, &dwExitCode);
			while (dwExitCode == STILL_ACTIVE)
			{
				Sleep(500);
			}
			CloseHandle(hThreadProvider); 
			if(pData->m_pstructProcessData->m_hProcess)
			{
				CloseHandle(pData->m_pstructProcessData->m_hProcess);
				pData->m_pstructProcessData->m_hProcess = NULL;
			}
			ThreadLogger(2,_T("RunActionScenarioWithProvider"),
						pData->m_lptstrTCOTestError,true,ulStatus);
			_endthreadex(nAPICallResult);
			return nAPICallResult;
		}     

		if (pData->m_bStartConsumers)
		{
			if (pData->m_pstructTCOFunctionalData->m_nConsumers > 0)
			{
				pData->m_pstructConsumerDataArray = 
					(ProcessData **) malloc 
							(sizeof (ProcessData *) * 
								pData->m_pstructTCOFunctionalData->m_nConsumers);
				RtlZeroMemory
					(pData->m_pstructConsumerDataArray, 
					 sizeof (ProcessData *) * 
					 pData->m_pstructTCOFunctionalData->m_nConsumers);

				int n;
				for (n = 0; n < pData->m_pstructTCOFunctionalData->m_nConsumers; n++)
				{
					pData->m_pstructConsumerDataArray[n] = 
						InitializeProcessData
						(
							pData->m_pstructTCOData,
							pData->m_pstructTCOFunctionalData,
							pData->m_lptstrDetailPath,
							n,		// 0 index gets the first provider or consumer.
							false	// bProvider, if false we get Consumer.
						);

						if (!pData->m_pstructConsumerDataArray[n]->m_hEventContinue || 
							!pData->m_pstructConsumerDataArray[n]->m_hEventProcessCompleted)
						{
							pData->m_lptstrTCOTestError = 
								NewTCHAR(_T("Could not create events."));
							CloseHandle(hThreadProvider); 
							if(pData->m_pstructProcessData->m_hProcess)
							{
								CloseHandle(pData->m_pstructProcessData->m_hProcess);
								pData->m_pstructProcessData->m_hProcess = NULL;
							}
							ThreadLogger(2,_T("RunActionScenarioWithProvider"),
										pData->m_lptstrTCOTestError,false,0);
							_endthreadex(-1);
							return -1;
						}

				}


				for (n = 0; n < pData->m_pstructTCOFunctionalData->m_nConsumers; n++)
				{
					UINT uiThreadId = NULL;

					pData->m_handleConsmers[n] = 
						(HANDLE) _beginthreadex
							(NULL,  
							0, 
							RunProcess, 
							(void *) pData->m_pstructConsumerDataArray[n], 
							0 , 
							&uiThreadId);
					// We use the thread as the surrogate for the process because
					// we do not exit the thread until the process ends or is
					// terminated.
					if (pData->m_handleConsmers[n] == 0)
					{
						int nError = errno;
						pData->m_lptstrTCOTestError = 
							NewTCHAR(_T("Could not start RunProcesss thread for consumer."));
						CloseHandle(hThreadProvider); 
						if(pData->m_pstructProcessData->m_hProcess)
						{
							CloseHandle(pData->m_pstructProcessData->m_hProcess);
							pData->m_pstructProcessData->m_hProcess = NULL;
						}
						ThreadLogger(2,_T("RunActionScenarioWithProvider"),
										pData->m_lptstrTCOTestError,true,errno);
						_endthreadex(errno);
						return nError;
					}
					Sleep(3000);
					// We do not need the handle to the process.
					if (pData->m_pstructConsumerDataArray[n]->m_hProcess)
					{
						CloseHandle(pData->m_pstructConsumerDataArray[n]->m_hProcess);
						pData->m_pstructConsumerDataArray[n]->m_hProcess = 0;
					}
				}
			}

		}

		// Enable the other GUIDS for provider.  We do not check
		// the return code.
		for (int i = 0; i < pData->m_pstructTCOData->m_nGuids; i++)
		{
			EnableTraceAPI
				(	
					pData->m_lptstrAction,
					NULL,
					NULL,
					false,
					i,
					pData->m_pstructTCOData,
					&nAPICallResult	
				);
			Sleep(3000);
		}
	}


	// Do not need this. 
	CloseHandle(hThreadProvider); 


	
	if (nAPICallResult == ERROR_SUCCESS)
	{
		ThreadLogger(3,_T("RunActionScenarioWithProvider"),
				_T("About to wait for process to complete "),false, 0);

		dwReturn = 
		WaitForSingleObject
			(pData->m_pstructProcessData->m_hEventProcessCompleted, 6000);

		ThreadLogger(3,_T("RunActionScenarioWithProvider"),
				_T("After wait for process to complete "),false, 0);
	}

	if (nResult != ERROR_SUCCESS)
	{
		t_string tsError;
		tsError = _T("Failure in RunActionScenarioWithProvider: StartTraceAPI failed.");
		pData->m_lptstrTCOTestError = NewTCHAR(tsError.c_str());
		if (nAPICallResult != ERROR_SUCCESS)
		{
			if(pData->m_pstructProcessData->m_hProcess)
			{
				CloseHandle(pData->m_pstructProcessData->m_hProcess);
				pData->m_pstructProcessData->m_hProcess = NULL;
			}
			ThreadLogger(2,_T("RunActionScenarioWithProvider"),
						pData->m_lptstrTCOTestError,true,nResult);
			_endthreadex(nResult);
			return nResult;
		}
	}
          
	if(pData->m_pstructProcessData->m_hProcess)
	{
		CloseHandle(pData->m_pstructProcessData->m_hProcess);
		pData->m_pstructProcessData->m_hProcess = NULL;
	}

	ThreadLogger(2,_T("RunActionScenarioWithProvider"),
				_T("Normal exit"),true,nResult);
	_endthreadex(nResult);
	return nResult;
}


// This can deal with command line arguments in double quotes and
// you must double quote command line arguments which contain spaces.
t_string FindValue(t_string tsCommandLine, int nPos)
{
	int nLen = tsCommandLine.length();

	TCHAR tc = tsCommandLine[nPos];
	bool bQuote = false;

	while ((nPos < nLen) && tc == _T(' ') || tc == _T('\t') || tc == _T('"'))
	{
		if (tc == _T('"'))
		{
			// Quotes allow embedded white spaces.
			bQuote = true;
		}
		++nPos;
		tc = tsCommandLine[nPos];
	}

	if (nPos == nLen)
	{
		return _T("");  // Empty string means failure.
	}


	int nEnd = nPos;

	tc = tsCommandLine[nEnd];

	while ((nEnd < nLen) && 
			( (!bQuote && (tc != _T(' ') && tc != _T('\t'))) 
			  || 
			  (bQuote && tc != _T('"'))
			)
		  )
	{
		++nEnd;
		tc = tsCommandLine[nEnd];
	}

	t_string tsReturn;
	tsReturn = tsCommandLine.substr(nPos,nEnd - nPos);

	return tsReturn; 

}

int GetArgs
(
	t_string tsCommandLine,
	LPTSTR &lptstrAction,
	LPTSTR &lptstrDataFile,
	LPTSTR &lptstrDetailPath,
	LPTSTR &lptstrUpdateDataFile,
	LPTSTR &lptstrProviderExe,
	bool &bLogExpected,
	bool &bUseTraceHandle
)
{
	int nFind;

	nFind = tsCommandLine.find(_T("-action"));
	t_string tsValue;

	if (nFind != t_string::npos)
	{
		nFind += 7;
		tsValue= FindValue(tsCommandLine,nFind);
		if (tsValue.empty())
		{
			return -1;
		}
		else
		{
			lptstrAction = NewTCHAR(tsValue.c_str());
		}
		tsValue.erase();
	}

	nFind = tsCommandLine.find(_T("-file"));

	if (nFind != t_string::npos)
	{
		nFind += 5;
		tsValue= FindValue(tsCommandLine,nFind);
		if (tsValue.empty())
		{
			return -1;
		}
		else
		{
			lptstrDataFile = NewTCHAR(tsValue.c_str());
		}
		tsValue.erase();
	}

	nFind = tsCommandLine.find(_T("-detail"));

	if (nFind == t_string::npos)
	{
		nFind += 7;
		tsValue= FindValue(tsCommandLine,nFind);
		if (tsValue.empty())
		{
			return -1;
		}
	}
	else
	{
		nFind += 7;
		tsValue= FindValue(tsCommandLine,nFind);
		if (tsValue.empty())
		{
			return -1;
		}
		else
		{
			lptstrDetailPath = NewTCHAR(tsValue.c_str());
		}
		tsValue.erase();
	}

	nFind = tsCommandLine.find(_T("-logexpected"));

	if (nFind != t_string::npos)
	{
		nFind += 12;
		tsValue= FindValue(tsCommandLine,nFind);
		if (tsValue.empty())
		{
			return -1;
		}
		else
		{
			int nComp = tsValue.compare(_T("0"));
			if (nComp == 0)
			{
				bLogExpected = false;
			}
			else
			{
				bLogExpected = true;
			}
		}
		tsValue.erase();
	}

	nFind = tsCommandLine.find(_T("-usetracehandle"));

	if (nFind != t_string::npos)
	{
		nFind += 15;
		tsValue= FindValue(tsCommandLine,nFind);
		if (tsValue.empty())
		{
			return -1;
		}
		else
		{
			int nComp = tsValue.compare(_T("0"));
			if (nComp == 0)
			{
				bUseTraceHandle = false;
			}
			else
			{
				bUseTraceHandle = true;
			}
		}
		tsValue.erase();
	}

	nFind = tsCommandLine.find(_T("-providerexe"));

	if (nFind != t_string::npos)
	{
		nFind += 12;
		tsValue= FindValue(tsCommandLine,nFind);
		if (tsValue.empty())
		{
			return -1;
		}
		else
		{
			lptstrProviderExe = NewTCHAR(tsValue.c_str());
		}
		tsValue.erase();
	}

	nFind = tsCommandLine.find(_T("-updatedata"));

	if (nFind != t_string::npos)
	{
		nFind += 11;
		tsValue= FindValue(tsCommandLine,nFind);
		if (tsValue.empty())
		{
			return -1;
		}
		else
		{
			lptstrUpdateDataFile = NewTCHAR(tsValue.c_str());
		}
		tsValue.erase();
	}


	return 0;
}


int FreeArgs
(
	LPTSTR &lptstrAction,
	LPTSTR &lptstrDataFile,
	LPTSTR &lptstrDetailPath,
	
	LPTSTR &lptstrUpdateDataFile,
	LPTSTR &lptstrProviderExe
)
{
	free (lptstrAction);
	free (lptstrDataFile);
	free (lptstrDetailPath);
	free (lptstrUpdateDataFile);
	free (lptstrProviderExe);

	lptstrAction = NULL;
	lptstrDataFile = NULL;
	lptstrDetailPath = NULL;
	lptstrUpdateDataFile = NULL;
	lptstrProviderExe = NULL;

	return 0;
}

unsigned int __stdcall RunProcess(void * pVoid)
{
	ProcessData *pProcessData = (ProcessData *) pVoid;
	pProcessData->m_dwProcessReturn = 0;
	pProcessData->m_dwThreadReturn = 0;
	pProcessData->m_nSystemError = 0;
		
	PROCESS_INFORMATION pinfoProvider;

	RtlZeroMemory(&pinfoProvider, sizeof(PROCESS_INFORMATION));

	STARTUPINFO sinfoProvider;

	RtlZeroMemory(&sinfoProvider, sizeof(STARTUPINFO));

	sinfoProvider.cb = sizeof(sinfoProvider);
	sinfoProvider.lpReserved = NULL;
	sinfoProvider.lpDesktop = NULL;
	sinfoProvider.lpTitle = NULL;
	sinfoProvider.dwFlags = 0;
	sinfoProvider.cbReserved2 = 0;
	sinfoProvider.lpReserved2 = NULL;
	sinfoProvider.hStdInput = NULL;
	sinfoProvider.hStdOutput = NULL;
	sinfoProvider.hStdError = NULL;

	BOOL bReturn =
		CreateProcess(
				pProcessData->m_lptstrExePath,
				pProcessData->m_lptstrCmdLine,
				NULL,
				NULL,
				NULL,
				DETACHED_PROCESS,
				NULL,
				NULL,
				&sinfoProvider,
				&pinfoProvider);


	if (!bReturn)
	{
		pProcessData->m_nSystemError = GetLastError();
		pProcessData->m_dwThreadReturn = ERROR_COULD_NOT_CREATE_PROCESS;
		SetEvent(pProcessData->m_hEventContinue);
		_endthreadex(ERROR_COULD_NOT_CREATE_PROCESS);
		return ERROR_COULD_NOT_CREATE_PROCESS;
	}

	pProcessData->m_hProcess = pinfoProvider.hProcess;

	// Do not need to hold on to this!
	CloseHandle(pinfoProvider.hThread);

	// Give the process 5 seconds to get going.
	Sleep(5000);

	SetEvent(pProcessData->m_hEventContinue);

	pProcessData->m_dwProcessReturn =
		WaitForSingleObject(pinfoProvider.hProcess,6000);

	if (pProcessData->m_dwProcessReturn != WAIT_OBJECT_0)
	{
		pProcessData->m_nSystemError = GetLastError();  
		pProcessData->m_dwThreadReturn = ERROR_WAIT_FAILED;
		SetEvent(pProcessData->m_hEventProcessCompleted);
		_endthreadex(ERROR_WAIT_FAILED);
		return (ERROR_WAIT_FAILED);
	}

	bReturn =
		GetExitCodeProcess
		(pinfoProvider.hProcess, &pProcessData->m_dwProcessReturn);

	if (!bReturn)
	{
		pProcessData->m_nSystemError = GetLastError();
		pProcessData->m_dwThreadReturn = 
			ERROR_COULD_NOT_GET_PROCESS_RETURN;
		SetEvent(pProcessData->m_hEventProcessCompleted);
		_endthreadex(ERROR_COULD_NOT_GET_PROCESS_RETURN);
		return (ERROR_COULD_NOT_GET_PROCESS_RETURN);
	}

	bReturn = SetEvent(pProcessData->m_hEventProcessCompleted);

	if (!bReturn)
	{
		int n = GetLastError();
	}

	_endthreadex(0);
	return (0);

}

t_string GetTestName(LPTSTR lptstrDataFile)
{
	t_string tsTemp;
	
	tsTemp = lptstrDataFile;

	t_string tsPath;

	int nBeg = tsTemp.find_last_of(_T('\\'));
	++nBeg;

	int nEnd = tsTemp.find_last_of(_T('.'));
	if (nEnd == t_string::npos)
	{
		nEnd = tsTemp.length();
	}

	int nNum = nEnd - nBeg;

	tsTemp = tsTemp.substr(nBeg, nNum);
	tsTemp += _T("Detail.txt");

	return tsTemp;
}


ProcessData *InitializeProcessData
(
	TCOData *pstructTCOData,
	TCOFunctionalData *pstructTCOFunctionalData,
	LPTSTR lptstrDetailPath,
	int nProcessIndex,
	bool bProvider
)
{
	ProcessData *pstructProcessData = (ProcessData *) malloc(sizeof(ProcessData));
	RtlZeroMemory(pstructProcessData, sizeof(ProcessData));

	InitializeExeAndCmdLine
	(
		pstructProcessData, 
		pstructTCOData,
		pstructTCOFunctionalData,
		lptstrDetailPath,
		nProcessIndex,
		bProvider
	);

	pstructProcessData->m_lptstrTCOId =
			NewTCHAR(pstructTCOData->m_lptstrShortDesc);
	pstructProcessData->m_lptstrLogFile = 
			NewTCHAR(lptstrDetailPath);
	// First Guid is in the properties.
	
	int nGuids;
	int nDelta;
	if (pstructTCOData->m_pProps != NULL)
	{
		nGuids= pstructTCOData->m_nGuids + 1;
		pstructProcessData->m_lpguidArray = 
			(GUID *) malloc (sizeof (GUID) * nGuids);
		pstructProcessData->m_lpguidArray[0] = pstructTCOData->m_pProps->Wnode.Guid;
		nDelta = 1;
	}
	else
	{
		nGuids= pstructTCOData->m_nGuids;
		if (nGuids > 0)
		{
			pstructProcessData->m_lpguidArray = 
				(GUID *) malloc (sizeof (GUID) * nGuids);
		}
		else
		{
			pstructProcessData->m_lpguidArray = NULL;
		}
		nDelta = 0;
	}
	
	for (int i = 0; i < pstructTCOData->m_nGuids; i++)
	{
		pstructProcessData->m_lpguidArray[i + nDelta] = 
			pstructTCOData->m_lpguidArray[i];
	}
	

	pstructProcessData->m_hEventContinue = CreateEvent(NULL,FALSE,FALSE,NULL);;
	pstructProcessData->m_hEventProcessCompleted = CreateEvent(NULL,FALSE,FALSE,NULL);;

	pstructProcessData->m_hProcess = NULL;
	pstructProcessData->m_dwProcessReturn = 0;
	pstructProcessData->m_dwThreadReturn = 0;
	pstructProcessData->m_nSystemError = 0;

	return pstructProcessData;
}

void InitializeExeAndCmdLine
(
	ProcessData *&pstructProcessData,
	TCOData *pstructTCOData,
	TCOFunctionalData *pstructTCOFunctionalData,
	LPTSTR lptstrDetailPath,
	int nProcessIndex,
	bool bProvider
)
{
	t_string tsProcess;
	if (bProvider)
	{
		tsProcess = pstructTCOFunctionalData->m_lptstrProviderArray[nProcessIndex];
	}
	else
	{
		tsProcess = pstructTCOFunctionalData->m_lptstrConsumerArray[nProcessIndex];
	}
	
	t_string tsExe;
	t_string tsCmdLine;

	int nEndExe = tsProcess.find(_T(".exe"));
	nEndExe += 4;

	tsExe = tsProcess.substr(0,nEndExe);

	if (nEndExe + 1 < tsExe.length())
	{
		tsCmdLine = tsProcess.substr(nEndExe + 1,t_string::npos);
	}

	tsCmdLine += _T(" -TESTID ");
	tsCmdLine += pstructTCOData->m_lptstrShortDesc;

	if (lptstrDetailPath)
	{
		tsCmdLine += _T("-TESTLOGPATH ");
		tsCmdLine += lptstrDetailPath;
	}

	tsCmdLine += _T("-GUIDS ");

	LPTSTR lptstrGuid = NULL;

	if (pstructTCOData->m_pProps != 0 &&
		pstructTCOData->m_pProps->Wnode.Guid.Data1 != 0 &&
		pstructTCOData->m_pProps->Wnode.Guid.Data2 != 0 &&
		pstructTCOData->m_pProps->Wnode.Guid.Data3 != 0)
	{
		lptstrGuid = LPTSTRFromGuid(pstructTCOData->m_pProps->Wnode.Guid);
		tsCmdLine += lptstrGuid;
		free (lptstrGuid);
		lptstrGuid = NULL;
		if (pstructTCOData->m_nGuids > 0)
		{
				tsCmdLine += _T(",");
		}
	}

	if (pstructTCOData->m_pProps != 0)
	{
		for (int i = 0; i < pstructTCOData->m_nGuids; i++) 
		{
			lptstrGuid = LPTSTRFromGuid(pstructTCOData->m_lpguidArray[i]);
			tsCmdLine += lptstrGuid;
			free (lptstrGuid);
			lptstrGuid = NULL;
			if (pstructTCOData->m_nGuids > 1 
				&& i < pstructTCOData->m_nGuids - 1)
			{
				tsCmdLine += _T(",");
			}
		}
	}

	t_string tsTemp;
	if (bProvider)
	{
		tsCmdLine += _T(" -EnableFlag ");
		tsTemp = ULONGVarToTString(pstructTCOData->m_ulEnableFlag ,true);
		tsCmdLine += tsTemp;
		
		tsCmdLine += _T(" -EnableLevel ");
		tsTemp = ULONGVarToTString(pstructTCOData->m_ulEnableLevel ,true);
		tsCmdLine += tsTemp;
		
	}
	else
	{
	
		if (pstructTCOData->m_pProps != 0)
		{
			tsCmdLine += _T(" -LogFile ");
			tsCmdLine += pstructTCOData->m_pProps->LogFileName;
			tsCmdLine += _T(" -Logger ");
			tsCmdLine += pstructTCOData->m_pProps->LoggerName;
		}
	}
	pstructProcessData->m_lptstrExePath = NewTCHAR(tsExe.c_str());
	
	pstructProcessData->m_lptstrCmdLine = NewTCHAR(tsCmdLine.c_str());
}

void FreeProcessDataArray(ProcessData **pProcessData, int nProcessData)
{
	if (pProcessData == NULL)
	{
		return;
	}

	for (int i = 0; i < nProcessData; i++)
	{
		if (pProcessData[i])
		{
			FreeProcessData(pProcessData[i]);
		}
	}

	free (pProcessData);
}

void FreeProcessData(ProcessData *pProcessData)
{
	free (pProcessData->m_lptstrExePath);
	free (pProcessData->m_lptstrCmdLine);
	free (pProcessData->m_lptstrTCOId);
	free (pProcessData->m_lptstrLogFile);
	free (pProcessData->m_lpguidArray);
	pProcessData->m_nGuids = 0;

	if (pProcessData->m_hEventContinue)
	{ 
		if (pProcessData->m_hEventContinue)
		{
			CloseHandle(pProcessData->m_hEventContinue);
		}
	}

	if (pProcessData->m_hEventProcessCompleted)
	{
		if (pProcessData->m_hEventProcessCompleted)
		{
			CloseHandle(pProcessData->m_hEventProcessCompleted);
		}
	}

	if (pProcessData->m_hProcess)
	{
		if (pProcessData->m_hProcess)
		{
			CloseHandle(pProcessData->m_hProcess);
		}
	}
	
	pProcessData->m_lptstrExePath = NULL;
	pProcessData->m_lptstrCmdLine = NULL;
	pProcessData->m_lptstrTCOId = NULL;
	pProcessData->m_lptstrLogFile = NULL;
	pProcessData->m_lpguidArray = NULL;
	pProcessData->m_hEventContinue = NULL;
	pProcessData->m_hEventProcessCompleted = NULL;
	pProcessData->m_hProcess = NULL;
	
	free (pProcessData);
}

void FreeStartTraceWithProviderData(StartTraceWithProviderData *p)
{
	if (!p)
	{
		return;
	}

	free (p->m_lptstrTCOTestError);
	p->m_lptstrTCOTestError = NULL;

	int nConsumers = p->m_pstructTCOFunctionalData->m_nConsumers;

	if (p->m_handleConsmers)
	{
		for (int i = 0; i < nConsumers; i++)
		{
			CloseHandle(p->m_handleConsmers[i]);
		}

		free(p->m_handleConsmers);
	}

	free(p);

	// All other data is shared and freed elsewhere!

}
void FreeStartTraceWithProviderDataArray(StartTraceWithProviderData **p, int nP)
{
	if (!p) 
	{
		return;
	}

	for (int i = 0; i < nP; i++)
	{
		if (p[i])
		{
			FreeStartTraceWithProviderData(p[i]);
		}
	}

	free(p);


}

// nState 1 = entering, 2 - leaving, 3 = none of the above.
void ThreadLogger
(int nState, LPCTSTR lptstrFunction, LPCTSTR lptstrMsg, bool bUseULONGValue, ULONG ulValue)
{

	CRITICAL_SECTION csMyCriticalSection;

	InitializeCriticalSection (&csMyCriticalSection);

	__try
	{
		EnterCriticalSection (&csMyCriticalSection);

		g_ThreadLogger.LogTCHAR(_T("\n"));

		g_ThreadLogger.LogTCHAR(_T("Thread ID: "));
		g_ThreadLogger.LogULONG((ULONG) GetCurrentThreadId());
		g_ThreadLogger.LogTCHAR(_T(".\n"));

		if (nState == 1)
		{
			g_ThreadLogger.LogTCHAR(_T("Entering - "));

		}
		else if (nState == 2)
		{
			g_ThreadLogger.LogTCHAR(_T("Leaving - "));
		}

		g_ThreadLogger.LogTCHAR(lptstrFunction);

		if (_tcslen(lptstrMsg) > 0)
		{
			g_ThreadLogger.LogTCHAR(_T(":\n"));
			g_ThreadLogger.LogTCHAR(lptstrMsg);
		}

		if (bUseULONGValue)
		{
			g_ThreadLogger.LogTCHAR(_T(" - "));
			g_ThreadLogger.LogULONG(ulValue);
		}
			
		g_ThreadLogger.LogTCHAR(_T(".\n"));	
	}
	 __finally
	 {
		// Release ownership of the critical section
		LeaveCriticalSection (&csMyCriticalSection);

	 }
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\enabletraceapi.cpp ===
// 
//
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <ctime>
#include <list>


using namespace std;


#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h" 
#include "TCOData.h"
#include "Persistor.h"
#include "Logger.h"
#include "Validator.h"
#include "Utilities.h"

#include "CollectionControl.h"
  
// Enable all Guids
int EnableTraceAPI
(	
 	IN LPTSTR lptstrAction,				// For logging only.
	IN LPCTSTR lpctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// EnableTrace API call return
)
{
	*pAPIReturn = -1;


	ULONG ulResult =
		EnableTraceAPI
		(	
			lptstrAction,
			lpctstrDataFile,
			lpctstrTCODetailFile,
			bLogExpected,
			-1,
			pstructTCOData,
			pAPIReturn
		);

	for (int i = 0; i < pstructTCOData->m_nGuids; i++)
	{
		ulResult = 
			EnableTraceAPI
			(	
				lptstrAction,
				lpctstrDataFile,
				NULL,		// Write detail only for the first Guid enabled!
				bLogExpected,
				i,
				pstructTCOData,
				pAPIReturn	
			);
	}
	return ulResult;

}

int EnableTraceAPI
(	
 	IN LPTSTR lptstrAction,				// For logging only.
	IN LPCTSTR lpctstrDataFile,			// For logging only.
	IN LPCTSTR lpctstrTCODetailFile,	// If valid we will log to it, can be NULL.
	IN bool bLogExpected,				// If true we log expected vs actual result.
	IN int nGuidIndex,					// Index or if -1 use Guid from WNode.
	IN OUT TCOData *pstructTCOData,		// TCO test data.
	OUT int *pAPIReturn					// EnableTrace API call return
)
{	

	LPTSTR lpstrReturnedError = NULL;

	CLogger *pDetailLogger = NULL;

	int nResult = 0;

	// We only log if the test of "interest" is EnableTrace.
	if (pstructTCOData->m_ulAPITest == TCOData::EnableTraceTest)
	{
		nResult = 
			OpenLogFiles
			(	
				lpctstrTCODetailFile,
				pDetailLogger,
				&lpstrReturnedError
			);
	}
	

	if (FAILED(nResult))
	{
		delete pDetailLogger;
		//  Open log files sets error string lpstrReturnedError.
		
		LogSummaryBeforeCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			_T("EnableTrace"),
			bLogExpected
		);

		LogSummaryAfterCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			nResult,
			lpstrReturnedError,
			bLogExpected
		);
		free(lpstrReturnedError);
		lpstrReturnedError = NULL;
		return nResult;
	}
			
	// This is our log file.
	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(_T("\n-------------------------------------------------------\n"));
		pDetailLogger->LogTCHAR(_T("EnableTraceAPI TCO test "));
		pDetailLogger->Flush();	
	}

	if (pDetailLogger)
	{
		pDetailLogger->LogTCHAR(pstructTCOData->m_lptstrShortDesc);
		int n = pDetailLogger->LogTCHAR(_T(" started at time "));
		time_t Time;
		time(&Time);
		pDetailLogger->LogTime(Time);
		pDetailLogger->LogTCHAR(_T(".\n"));
		pDetailLogger->Flush();
	}

	BOOL bAdmin = IsAdmin();

	if (pDetailLogger)
	{
		// Log argument values before calling StopTrace.
		LogDetailBeforeCall
		(
			pDetailLogger,
			pstructTCOData,
			bAdmin
		);
	}

	LogSummaryBeforeCall
	(	
		pstructTCOData, 
		lpctstrDataFile,
		lptstrAction,
		_T("EnableTrace"),
		bLogExpected
	);

	GUID Guid = nGuidIndex == -1 ?
				pstructTCOData->m_pProps->Wnode.Guid:
				pstructTCOData->m_lpguidArray[nGuidIndex];

	*pAPIReturn =
		EnableTrace
		(	 
			pstructTCOData->m_ulEnable ? TRUE : FALSE,
			pstructTCOData->m_ulEnableFlag,
			pstructTCOData->m_ulEnableLevel,
			&Guid,
			*pstructTCOData->m_pTraceHandle
		);

	ULONG ulResult = pstructTCOData->m_ulExpectedResult == *pAPIReturn ? ERROR_SUCCESS : -1;

	if (ulResult != ERROR_SUCCESS && *pAPIReturn == ERROR_SUCCESS)
	{
		ulResult = *pAPIReturn;
	}
	else if (*pAPIReturn != ERROR_SUCCESS)
	{
		lpstrReturnedError = DecodeStatus(*pAPIReturn);
	}
	else if (pstructTCOData->m_ulAPITest == TCOData::EnableTraceTest &&
			pstructTCOData->m_lptstrValidator && 
			_tcslen(pstructTCOData->m_lptstrValidator) > 0)
	{
		CValidator Validator;
			
		bool bValid = 
			Validator.Validate
			(
				pstructTCOData->m_pTraceHandle, 
				pstructTCOData->m_lptstrInstanceName, 
				pstructTCOData->m_pProps, 
				pstructTCOData->m_lptstrValidator
			);

		if (!bValid)
		{
			ulResult = -1;
			lpstrReturnedError = NewTCHAR(_T("Validation routine failed."));
		}
	}

	t_string tsBanner;
	LPTSTR lptstrGuid = NULL;

	if (pstructTCOData->m_pProps != 0 &&
		Guid.Data1 != 0 &&
		Guid.Data2 != 0 &&
		Guid.Data3 != 0)
	{
		lptstrGuid = LPTSTRFromGuid(Guid);
		tsBanner = _T("EnableTrace for Guid:");
		tsBanner += lptstrGuid;
		free (lptstrGuid);
		lptstrGuid = NULL;
	}

	if (pDetailLogger)
	{
		LogDetailAfterCall
		(	pDetailLogger,
			pstructTCOData,
			&pstructTCOData->m_pProps,
			*pAPIReturn,
			lpstrReturnedError,
			true,
			bAdmin,
			tsBanner.length() > 0 ? tsBanner.c_str() : NULL,
			false
		);
	}

	tsBanner.erase();

	LogSummaryAfterCall
		(	
			pstructTCOData, 
			lpctstrDataFile,
			lptstrAction,
			*pAPIReturn,
			lpstrReturnedError,
			bLogExpected
		);


	free(lpstrReturnedError);
	lpstrReturnedError = NULL;

	return ulResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\logger.cpp ===
// Logger.cpp: implementation of the CPersistor class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#include <string>
#include <iosfwd> 
#include <iostream>
#include <fstream>
#include <ctime>
#include <list>

using namespace std;

#include <malloc.h>
#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"
#include "Logger.h"
#include "TCOData.h"
#include "Utilities.h"
#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"

#include "Logger.h"


#ifdef _UNICODE
static TCHAR g_tcBeginFile[] = {0xfeff,0x0d, 0x0a};
static TCHAR g_atcNL[] = {0x0d, 0x0a, 0x00};
#endif

CLogger::CLogger(LPCTSTR lpctstrFileName, bool bAppend)
{
#ifdef _UNICODE
	m_sFileName = NewLPSTR((LPCWSTR) const_cast<LPTSTR>(lpctstrFileName));
#else
	m_sFileName = NewTCHAR(lpctstrFileName);
#endif

	m_pPersistor = new CPersistor(m_sFileName, ios::out, false);
	m_hr = m_pPersistor -> OpenLog(bAppend);
}

CLogger::~CLogger()
{
	free(m_sFileName);
	delete m_pPersistor;
}

int CLogger::LogTCHAR(LPCTSTR lpctstrOut)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}

	if (lpctstrOut)
	{
		PutALine(m_pPersistor->Stream(), lpctstrOut, -1);
		m_pPersistor->Stream().flush();
	}

	return 0;
}

int CLogger::LogTime(time_t &Time)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}

	TCHAR tcArray[26];
	LPCTSTR lpctstrTime = t_ctime(&Time);
	_tcscpy(tcArray,lpctstrTime);
	tcArray[24] = _T('\0');
	TCHAR *p = tcArray;

	PutALine(m_pPersistor->Stream(), p, -1);
	m_pPersistor->Stream().flush();

	return 0;
}

int CLogger::LogULONG(ULONG ul, bool bHex)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}
	
	if (bHex)
	{
		PutALine(m_pPersistor->Stream(), _T("0x"), -1);
	}

	PutAULONGVar(m_pPersistor->Stream(), ul, bHex);

	m_pPersistor->Stream().flush();

	return 0;
}

int CLogger::LogULONG64(ULONG64 ul, bool bHex)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}
	
	if (bHex)
	{
		PutALine(m_pPersistor->Stream(), _T("0x"), -1);
	}

	PutAULONG64Var(m_pPersistor->Stream(), ul);

	m_pPersistor->Stream().flush();

	return 0;
}

int CLogger::LogGUID(GUID Guid)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}

	GUIDOut(m_pPersistor->Stream(), Guid);

	m_pPersistor->Stream().flush();

	return 0;
}

int CLogger::LogEventTraceProperties(PEVENT_TRACE_PROPERTIES pProps)
{
	if (FAILED(m_hr))
	{
		return m_hr;
	}

	if (pProps == NULL)
	{
		PutALine(m_pPersistor->Stream(),_T("_EVENT_TRACE_PROPERTIES Instance NULL\n"),-1);
		return 0;
	}

	CEventTraceProperties Props(pProps);

	m_pPersistor->Stream() << Props;

	m_pPersistor->Stream().flush();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\persistor.cpp ===
// Persistor.cpp: implementation of the CPersistor class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#include <string>
#include <iosfwd> 
#include <iostream>
#include <fstream>

using namespace std;

#include <WTYPES.H>
#include "t_string.h"

#include "Persistor.h"

#include "StructureWapperHelpers.h"



#ifdef _UNICODE
static TCHAR g_tcBeginFile[] = {0xfeff};
static TCHAR g_atcNL[] = {0x0d, 0x0a, 0x00};
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CPersistor::CPersistor
(const char *pszFilename, int nMode, bool bLoading)
{
	m_sFilename = pszFilename;
	m_nMode = nMode;
	m_bLoading = bLoading;
	m_pfsFile = NULL;
	m_bFirst = true;
	m_pfsFile = NULL;
}

CPersistor::~CPersistor()
{
	Close();
}

HRESULT CPersistor::Close()
{
	if (m_pfsFile && m_pfsFile->is_open())
	{
#ifdef _UNICODE
		if (!m_bLoading)
		{
		
		}
#endif
		m_pfsFile->flush();
		m_pfsFile->close();
		delete m_pfsFile;
		m_pfsFile = NULL;
	}
	else if (m_pfsFile)
	{
		delete m_pfsFile;
		m_pfsFile = NULL;
	}

	return S_OK;

}

HRESULT CPersistor::Open()
{

	m_pfsFile = NULL;

	m_pfsFile = new t_fstream
				(m_sFilename.c_str(),m_nMode | ios_base::binary);

	if (m_pfsFile && m_pfsFile->fail())
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
#ifdef _UNICODE
		if (m_bFirst && !m_bLoading)
		{
			// To Do:  Need to write out here the UNICODE string.
			PutALine(*m_pfsFile, g_tcBeginFile, 1);
		}
		else if (m_bFirst)
		{
			// Need to skip over the UNICODE string.
			fpos_t p = m_pfsFile->tellp();
			if (p == (fpos_t) 0)
			{
				TCHAR tc;
				tc = Stream().peek();
				// Need to make sure that the file is unicode.
				if (tc != 0xff)
				{
					m_pfsFile ->close();
					delete m_pfsFile;
					m_pfsFile = NULL;
					return HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
				}
				
				TCHAR t;

				GetAChar(Stream(), t);
				
			}
		}
#else
		if (m_bFirst && m_bLoading)
		{
			// Need to make sure that the file is not unicode.
			int tc;
			tc = Stream().peek();
			if (tc == 0xff)
			{
				m_pfsFile ->close();
				delete m_pfsFile;
				m_pfsFile = NULL;
				return HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
			}
		}
#endif
		m_bFirst = false;
		return S_OK;
	}


}

// 
HRESULT CPersistor::OpenLog(bool bAppend)
{

	m_pfsFile = NULL;

	m_pfsFile = new t_fstream
		(m_sFilename.c_str(),m_nMode | ios_base::binary | (bAppend ?  ios::app : 0));

	if (m_pfsFile && m_pfsFile->fail())
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
#ifdef _UNICODE
		//m_pfsFile->seekp(ios::end);
		//fpos_t p = m_pfsFile->tellp();
		//if (p == (fpos_t) 0)
		//{
			PutALine(*m_pfsFile, g_tcBeginFile, 1);
		//}
#endif
		return S_OK;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\logger.h ===
#if !defined(AFX_LOGGER_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
#define AFX_LOGGER_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CLogger
{
public:
	CLogger(LPCTSTR lpctstrFileName,  bool bAppend = true);
	~CLogger();
	int LogTCHAR(LPCTSTR lpctstrOut);
	int LogULONG(ULONG uLong, bool bHex = true);
	int LogULONG64(ULONG64 uLong64,  bool bHex = true);
	int LogGUID(GUID Guid);
	int LogEventTraceProperties(PEVENT_TRACE_PROPERTIES pProps);
	int LogTime(time_t &Time);
	void Flush() {m_pPersistor->Stream().flush();}
	HRESULT GetOpenStatus() {return m_hr;}
private:
	CPersistor *m_pPersistor;
	char *m_sFileName;
	HRESULT m_hr;
};

#endif // !defined(AFX_LOGGER_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\persistor.h ===
// Persistor.h: interface for the CPersistor class.
//
//////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#if !defined(AFX_PERSISTOR_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
#define AFX_PERSISTOR_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CPersistor  
{
public:
	virtual ~CPersistor();
	CPersistor(const char *pszFilename, int nMode, bool bLoading = true );
	HRESULT Close();
	HRESULT Open();
	// For logging support.  We only log out.
	HRESULT OpenLog(bool bAppend = true);
	t_fstream &Stream() {return *m_pfsFile;}
	bool IsLoading() {return m_bLoading;}
	const char* GetFilename() {return m_sFilename.c_str();} 
protected:
	t_fstream *m_pfsFile;
	bool m_bLoading;
	string m_sFilename;
	int m_nMode;
	bool m_bFirst;
};

#endif // !defined(AFX_PERSISTOR_H__74C9CD33_EC48_11D2_826A_0008C75BFC19__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\queryalltracesapi.cpp ===
// 
//
//***************************************************************************
//
//  judyp      May 1999        
//
//***************************************************************************

#include "stdafx.h"

#pragma warning (disable : 4786)
#pragma warning (disable : 4275)

#include <iostream>
#include <strstream>
#include <fstream>
#include <string>
#include <sstream>
#include <map>
#include <ctime>
#include <list>


using namespace std;


#include <tchar.h>
#include <windows.h>
#ifdef NONNT5
typedef unsigned long ULONG_PTR;
#endif
#include <wmistr.h>
#include <guiddef.h>
#include <initguid.h>
#include <evntrace.h>

#include <WTYPES.H>
#include "t_string.h"

#include "StructureWrappers.h"
#include "StructureWapperHelpers.h"
#include "ConstantMap.h" 
#include "TCOData.h"
#include "Persistor.h"
#include "Logger.h"
#include "Utilities.h"

#include "CollectionControl.h"
  
int QueryAllTracesAPI
(	
	IN LPTSTR lptstrAction,				// For logging only.
	OUT int *pAPIReturn					// QueryAllTraces API call return
)
{
	*pAPIReturn = ERROR_SUCCESS;

	int nResult = 0;
			
	t_cout << _T("QueryAllTracesAPI TCO tests 1.6.1.\n");
	

	PEVENT_TRACE_PROPERTIES pPropsArray = NULL;
	ULONG ulSessionCount = 0;

	// 1.6.1.1
	ULONG ulStatus = 
		QueryAllTraces
		(	
			NULL,
			32,
			&ulSessionCount
		);

	if (ulStatus == ERROR_INVALID_PARAMETER)
	{
		t_cout << _T("1.6.1.1 - Passed\n");
	}
	else
	{
		t_cout << _T("1.6.1.1 - Failed\n");
	}

	InitializePropsArray(pPropsArray, 4);

	// 1.6.1.2
	ulStatus = 
		QueryAllTraces
		(	
			&pPropsArray,
			32,
			&ulSessionCount
		);

	if (ulStatus == ERROR_SUCCESS)
	{
		t_cout << _T("1.6.1.2 - Passed\n");
	}
	else
	{
		t_cout << _T("1.6.1.2 - Failed\n");
	}

	// 1.6.1.3
	ulStatus = 
		QueryAllTraces
		(	
			&pPropsArray,
			4,
			&ulSessionCount
		);

	if (ulStatus == ERROR_SUCCESS)
	{
		t_cout << _T("1.6.1.3 - Passed\n");
	}
	else
	{
		t_cout << _T("1.6.1.3 - Failed\n");
	}

	// 1.6.1.4
	ulStatus = 
		QueryAllTraces
		(	
			&pPropsArray,
			0,
			&ulSessionCount
		);

	if (ulStatus == ERROR_INVALID_PARAMETER)
	{
		t_cout << _T("1.6.1.4 - Passed\n");
	}
	else
	{
		t_cout << _T("1.6.1.4 - Failed\n");
	}

	// 1.6.1.5
	ulStatus = 
		QueryAllTraces
		(	
			&pPropsArray,
			33,
			&ulSessionCount
		);

	if (ulStatus == ERROR_INVALID_PARAMETER)
	{
		t_cout << _T("1.6.1.5 - Passed\n");
	}
	else
	{
		t_cout << _T("1.6.1.5 - Failed\n");
	}

	// 1.6.1.6
	ulStatus = 
		QueryAllTraces
		(	
			&pPropsArray,
			4,
			NULL
		);

	if (ulStatus == ERROR_INVALID_PARAMETER)
	{
		t_cout << _T("1.6.1.6 - Passed\n");
	}
	else
	{
		t_cout << _T("1.6.1.1 - Failed\n");
	}
	
	return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\tests\logger\starttraceapi.cpp ===
